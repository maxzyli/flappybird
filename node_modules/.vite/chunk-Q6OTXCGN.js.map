{
  "version": 3,
  "sources": ["../@oasis-engine/math/src/enums/ContainmentType.ts", "../@oasis-engine/math/src/enums/PlaneIntersectionType.ts", "../@oasis-engine/math/src/MathUtil.ts", "../@oasis-engine/math/src/Vector3.ts", "../@oasis-engine/math/src/BoundingSphere.ts", "../@oasis-engine/math/src/BoundingBox.ts", "../@oasis-engine/math/src/CollisionUtil.ts", "../@oasis-engine/math/src/Plane.ts", "../@oasis-engine/math/src/BoundingFrustum.ts", "../@oasis-engine/math/src/Matrix3x3.ts", "../@oasis-engine/math/src/Quaternion.ts", "../@oasis-engine/math/src/Matrix.ts", "../@oasis-engine/math/src/Ray.ts", "../@oasis-engine/math/src/Vector2.ts", "../@oasis-engine/math/src/Vector4.ts", "../@oasis-engine/math/src/Color.ts", "../@oasis-engine/math/src/Rect.ts", "../@oasis-engine/math/src/SphericalHarmonics3.ts", "../@oasis-engine/core/src/asset/AssetPromise.ts", "../@oasis-engine/core/src/base/Util.ts", "../@oasis-engine/core/src/asset/ResourceManager.ts", "../@oasis-engine/core/src/base/Event.ts", "../@oasis-engine/core/src/clone/enums/CloneMode.ts", "../@oasis-engine/core/src/clone/CloneManager.ts", "../@oasis-engine/core/src/base/EngineObject.ts", "../@oasis-engine/core/src/base/EventDispatcher.ts", "../@oasis-engine/core/src/base/Logger.ts", "../@oasis-engine/core/src/base/Time.ts", "../@oasis-engine/core/src/base/Constant.ts", "../@oasis-engine/core/src/DisorderedArray.ts", "../@oasis-engine/core/src/shader/ShaderMacroCollection.ts", "../@oasis-engine/core/src/ComponentsManager.ts", "../@oasis-engine/core/src/clone/ComponentCloner.ts", "../@oasis-engine/core/src/ComponentsDependencies.ts", "../@oasis-engine/core/src/Layer.ts", "../@oasis-engine/core/src/Component.ts", "../@oasis-engine/core/src/UpdateFlag.ts", "../@oasis-engine/core/src/UpdateFlagManager.ts", "../@oasis-engine/core/src/Transform.ts", "../@oasis-engine/core/src/Entity.ts", "../@oasis-engine/core/src/FeatureManager.ts", "../@oasis-engine/core/src/material/enums/RenderQueueType.ts", "../@oasis-engine/core/src/asset/RefObject.ts", "../@oasis-engine/core/src/shader/enums/ShaderDataGroup.ts", "../@oasis-engine/core/src/texture/Texture.ts", "../@oasis-engine/core/src/shaderlib/pbr/index.ts", "../@oasis-engine/core/src/shaderlib/ShaderLib.ts", "../@oasis-engine/core/src/shaderlib/ShaderFactory.ts", "../@oasis-engine/core/src/shader/ShaderMacro.ts", "../@oasis-engine/core/src/shader/ShaderUniform.ts", "../@oasis-engine/core/src/shader/ShaderUniformBlock.ts", "../@oasis-engine/core/src/shader/ShaderProgram.ts", "../@oasis-engine/core/src/shader/ShaderProperty.ts", "../@oasis-engine/core/src/shader/Shader.ts", "../@oasis-engine/core/src/shader/ShaderData.ts", "../@oasis-engine/core/src/shader/enums/BlendFactor.ts", "../@oasis-engine/core/src/shader/enums/BlendOperation.ts", "../@oasis-engine/core/src/shader/enums/ColorWriteMask.ts", "../@oasis-engine/core/src/shader/state/RenderTargetBlendState.ts", "../@oasis-engine/core/src/shader/state/BlendState.ts", "../@oasis-engine/core/src/shader/enums/CompareFunction.ts", "../@oasis-engine/core/src/shader/state/DepthState.ts", "../@oasis-engine/core/src/shader/enums/CullMode.ts", "../@oasis-engine/core/src/shader/state/RasterState.ts", "../@oasis-engine/core/src/shader/enums/StencilOperation.ts", "../@oasis-engine/core/src/shader/state/StencilState.ts", "../@oasis-engine/core/src/shader/state/RenderState.ts", "../@oasis-engine/core/src/material/Material.ts", "../@oasis-engine/core/src/RenderPipeline/ClassPool.ts", "../@oasis-engine/core/src/RenderPipeline/RenderContext.ts", "../@oasis-engine/core/src/RenderPipeline/RenderElement.ts", "../@oasis-engine/core/src/RenderPipeline/SpriteElement.ts", "../@oasis-engine/core/src/RenderPipeline/SpriteMaskElement.ts", "../@oasis-engine/core/src/2d/enums/SpriteMaskInteraction.ts", "../@oasis-engine/core/src/Renderer.ts", "../@oasis-engine/core/src/2d/enums/SpriteMaskLayer.ts", "../@oasis-engine/core/src/2d/sprite/SpriteMask.ts", "../@oasis-engine/core/src/graphic/enums/VertexElementFormat.ts", "../@oasis-engine/core/src/graphic/enums/BufferUsage.ts", "../@oasis-engine/core/src/graphic/enums/IndexFormat.ts", "../@oasis-engine/core/src/graphic/BufferUtil.ts", "../@oasis-engine/core/src/graphic/VertexElement.ts", "../@oasis-engine/core/src/graphic/enums/BufferBindFlag.ts", "../@oasis-engine/core/src/graphic/enums/SetDataOptions.ts", "../@oasis-engine/core/src/graphic/Buffer.ts", "../@oasis-engine/core/src/graphic/enums/MeshTopology.ts", "../@oasis-engine/core/src/graphic/IndexBufferBinding.ts", "../@oasis-engine/core/src/graphic/SubMesh.ts", "../@oasis-engine/core/src/graphic/Mesh.ts", "../@oasis-engine/core/src/graphic/VertexBufferBinding.ts", "../@oasis-engine/core/src/texture/enums/TextureFilterMode.ts", "../@oasis-engine/core/src/texture/enums/TextureFormat.ts", "../@oasis-engine/core/src/texture/enums/TextureWrapMode.ts", "../@oasis-engine/core/src/texture/Texture2D.ts", "../@oasis-engine/core/src/texture/enums/RenderBufferColorFormat.ts", "../@oasis-engine/core/src/texture/enums/RenderBufferDepthFormat.ts", "../@oasis-engine/core/src/texture/enums/TextureCubeFace.ts", "../@oasis-engine/core/src/texture/TextureCubeMap.ts", "../@oasis-engine/core/src/texture/RenderDepthTexture.ts", "../@oasis-engine/core/src/texture/RenderTarget.ts", "../@oasis-engine/core/src/texture/RenderColorTexture.ts", "../@oasis-engine/core/src/mesh/ModelMesh.ts", "../@oasis-engine/core/src/mesh/Skin.ts", "../@oasis-engine/core/src/mesh/MeshRenderer.ts", "../@oasis-engine/core/src/mesh/SkinnedMeshRenderer.ts", "../@oasis-engine/core/src/mesh/PrimitiveMesh.ts", "../@oasis-engine/core/src/mesh/BufferMesh.ts", "../@oasis-engine/core/src/mesh/BlendShapeFrame.ts", "../@oasis-engine/core/src/mesh/BlendShape.ts", "../@oasis-engine/core/src/RenderPipeline/Basic2DBatcher.ts", "../@oasis-engine/core/src/RenderPipeline/SpriteMaskBatcher.ts", "../@oasis-engine/core/src/RenderPipeline/SpriteMaskManager.ts", "../@oasis-engine/core/src/enums/BackgroundMode.ts", "../@oasis-engine/core/src/enums/BackgroundTextureFillMode.ts", "../@oasis-engine/core/src/sky/Sky.ts", "../@oasis-engine/core/src/Background.ts", "../@oasis-engine/core/src/lighting/enums/DiffuseMode.ts", "../@oasis-engine/core/src/lighting/AmbientLight.ts", "../@oasis-engine/core/src/SceneFeature.ts", "../@oasis-engine/core/src/lighting/Light.ts", "../@oasis-engine/core/src/lighting/DirectLight.ts", "../@oasis-engine/core/src/lighting/PointLight.ts", "../@oasis-engine/core/src/lighting/SpotLight.ts", "../@oasis-engine/core/src/lighting/LightFeature.ts", "../@oasis-engine/core/src/Scene.ts", "../@oasis-engine/core/src/SceneManager.ts", "../@oasis-engine/core/src/shader/ShaderPool.ts", "../@oasis-engine/core/src/shader/ShaderProgramPool.ts", "../@oasis-engine/core/src/collider/ColliderFeature.ts", "../@oasis-engine/core/src/collider/Collider.ts", "../@oasis-engine/core/src/collider/ABoxCollider.ts", "../@oasis-engine/core/src/collider/PlaneCollider.ts", "../@oasis-engine/core/src/collider/ASphereCollider.ts", "../@oasis-engine/core/src/collider/BoxCollider.ts", "../@oasis-engine/core/src/collider/SphereCollider.ts", "../@oasis-engine/core/src/collider/index.ts", "../@oasis-engine/core/src/HitResult.ts", "../@oasis-engine/core/src/PhysicsManager.ts", "../@oasis-engine/core/src/Engine.ts", "../@oasis-engine/core/src/SystemInfo.ts", "../@oasis-engine/core/src/EngineFeature.ts", "../@oasis-engine/core/src/Script.ts", "../@oasis-engine/core/src/enums/CameraClearFlags.ts", "../@oasis-engine/core/src/RenderPipeline/RenderPass.ts", "../@oasis-engine/core/src/RenderPipeline/SpriteBatcher.ts", "../@oasis-engine/core/src/RenderPipeline/RenderQueue.ts", "../@oasis-engine/core/src/RenderPipeline/BasicRenderPipeline.ts", "../@oasis-engine/core/src/Camera.ts", "../@oasis-engine/core/src/asset/request.ts", "../@oasis-engine/core/src/asset/Loader.ts", "../@oasis-engine/core/src/asset/AssetType.ts", "../@oasis-engine/core/src/material/enums/RenderFace.ts", "../@oasis-engine/core/src/material/enums/BlendMode.ts", "../@oasis-engine/core/src/material/BaseMaterial.ts", "../@oasis-engine/core/src/material/BlinnPhongMaterial.ts", "../@oasis-engine/core/src/material/PBRBaseMaterial.ts", "../@oasis-engine/core/src/material/PBRMaterial.ts", "../@oasis-engine/core/src/material/PBRSpecularMaterial.ts", "../@oasis-engine/core/src/material/UnlitMaterial.ts", "../@oasis-engine/core/src/2d/atlas/SpriteAtlas.ts", "../@oasis-engine/core/src/2d/sprite/Sprite.ts", "../@oasis-engine/core/src/2d/sprite/SpriteRenderer.ts", "../@oasis-engine/core/src/animation/AnimationClipCurveBinding.ts", "../@oasis-engine/core/src/animation/enums/AnimationProperty.ts", "../@oasis-engine/core/src/animation/Motion.ts", "../@oasis-engine/core/src/animation/AnimationClip.ts", "../@oasis-engine/core/src/animation/AnimatorUtils.ts", "../@oasis-engine/core/src/animation/enums/AnimatorLayerBlendingMode.ts", "../@oasis-engine/core/src/animation/enums/LayerState.ts", "../@oasis-engine/core/src/animation/internal/AnimationCurveOwner.ts", "../@oasis-engine/core/src/animation/internal/AnimationEventHandler.ts", "../@oasis-engine/core/src/animation/AnimatorTransition.ts", "../@oasis-engine/core/src/animation/enums/WrapMode.ts", "../@oasis-engine/core/src/animation/internal/AnimatorStatePlayData.ts", "../@oasis-engine/core/src/animation/internal/AnimatorLayerData.ts", "../@oasis-engine/core/src/animation/internal/AnimatorStateData.ts", "../@oasis-engine/core/src/animation/internal/AnimatorStateInfo.ts", "../@oasis-engine/core/src/animation/internal/CrossCurveData.ts", "../@oasis-engine/core/src/animation/Animator.ts", "../@oasis-engine/core/src/animation/AnimatorController.ts", "../@oasis-engine/core/src/animation/AnimatorControllerLayer.ts", "../@oasis-engine/core/src/animation/AnimatorState.ts", "../@oasis-engine/core/src/animation/AnimatorStateMachine.ts", "../@oasis-engine/core/src/animation/enums/InterpolableValueType.ts", "../@oasis-engine/core/src/animation/enums/InterpolationType.ts", "../@oasis-engine/core/src/animation/AnimationCurve.ts", "../@oasis-engine/core/src/animation/KeyFrame.ts", "../@oasis-engine/core/src/animation/AnimationEvent.ts", "../@oasis-engine/core/src/animation/enums/AnimatorConditionMode.ts", "../@oasis-engine/core/src/sky/SkyBoxMaterial.ts", "../@oasis-engine/core/src/particle/ParticleRenderer.ts", "../@oasis-engine/core/src/trail/TrailMaterial.ts", "../@oasis-engine/core/src/trail/TrailRenderer.ts", "../@oasis-engine/core/src/collision/intersect.ts", "../@oasis-engine/core/src/collision/CollisionDetection.ts", "../@oasis-engine/core/src/fog/Fog.ts", "../@oasis-engine/core/src/fog/EXP2Fog.ts", "../@oasis-engine/core/src/fog/LinearFog.ts", "../@oasis-engine/core/src/env-probe/Probe.ts", "../@oasis-engine/core/src/env-probe/CubeProbe.ts", "../@oasis-engine/core/src/shadow/LightShadow.ts", "../@oasis-engine/core/src/shadow/Extension.ts", "../@oasis-engine/core/src/shadow/ShadowMapMaterial.ts", "../@oasis-engine/core/src/shadow/ShadowMapPass.ts", "../@oasis-engine/core/src/shadow/ShadowMaterial.ts", "../@oasis-engine/core/src/shadow/ShadowPass.ts", "../@oasis-engine/core/src/shadow/ShadowFeature.ts", "../@oasis-engine/core/src/shadow/index.ts", "../@oasis-engine/core/src/index.ts", "../@oasis-engine/rhi-webgl/src/type.ts", "../@oasis-engine/rhi-webgl/src/WebCanvas.ts", "../@oasis-engine/rhi-webgl/src/GLCapability.ts", "../@oasis-engine/rhi-webgl/src/GLExtensions.ts", "../@oasis-engine/rhi-webgl/src/GLPrimitive.ts", "../@oasis-engine/rhi-webgl/src/GLTexture.ts", "../@oasis-engine/rhi-webgl/src/GLRenderColorTexture.ts", "../@oasis-engine/rhi-webgl/src/GLRenderDepthTexture.ts", "../@oasis-engine/rhi-webgl/src/GLRenderStates.ts", "../@oasis-engine/rhi-webgl/src/GLRenderTarget.ts", "../@oasis-engine/rhi-webgl/src/GLTexture2D.ts", "../@oasis-engine/rhi-webgl/src/GLTextureCubeMap.ts", "../@oasis-engine/rhi-webgl/src/WebGLRenderer.ts", "../@oasis-engine/rhi-webgl/src/WebGLEngine.ts", "../@oasis-engine/draco/src/DRACOWorker.ts", "../@oasis-engine/draco/src/worker/worker.js", "../@oasis-engine/draco/src/decoder.ts", "../@oasis-engine/loader/src/BufferLoader.ts", "../@oasis-engine/loader/src/gltf/Schema.ts", "../@oasis-engine/loader/src/gltf/GLTFUtil.ts", "../@oasis-engine/loader/src/gltf/parser/Parser.ts", "../@oasis-engine/loader/src/gltf/parser/AnimationParser.ts", "../@oasis-engine/loader/src/gltf/parser/BufferParser.ts", "../@oasis-engine/loader/src/gltf/parser/EntityParser.ts", "../@oasis-engine/loader/src/gltf/parser/MaterialParser.ts", "../@oasis-engine/loader/src/gltf/parser/MeshParser.ts", "../@oasis-engine/loader/src/gltf/parser/SceneParser.ts", "../@oasis-engine/loader/src/gltf/parser/SkinParser.ts", "../@oasis-engine/loader/src/gltf/parser/TextureParser.ts", "../@oasis-engine/loader/src/gltf/parser/Validator.ts", "../@oasis-engine/loader/src/gltf/GLTFParser.ts", "../@oasis-engine/loader/src/gltf/GLTFResource.ts", "../@oasis-engine/loader/src/GLTFLoader.ts", "../@oasis-engine/loader/src/JSONLoader.ts", "../@oasis-engine/loader/src/compressed-texture/KhronosTextureContainer.ts", "../@oasis-engine/loader/src/compressed-texture/index.ts", "../@oasis-engine/loader/src/KTXCubeLoader.ts", "../@oasis-engine/loader/src/KTXLoader.ts", "../@oasis-engine/loader/src/Texture2DLoader.ts", "../@oasis-engine/loader/src/TextureCubeLoader.ts", "../@oasis-engine/loader/src/SpriteAtlasLoader.ts", "../@oasis-engine/loader/src/gltf/extensions/ExtensionParser.ts", "../@oasis-engine/loader/src/gltf/extensions/KHR_draco_mesh_compression.ts", "../@oasis-engine/loader/src/gltf/extensions/KHR_lights_punctual.ts", "../@oasis-engine/loader/src/gltf/extensions/KHR_materials_pbrSpecularGlossiness.ts", "../@oasis-engine/loader/src/gltf/extensions/KHR_materials_unlit.ts", "../@oasis-engine/loader/src/gltf/extensions/KHR_materials_variants.ts", "../@oasis-engine/loader/src/gltf/extensions/KHR_mesh_quantization.ts", "../@oasis-engine/loader/src/gltf/extensions/KHR_texture_transform.ts", "../@oasis-engine/loader/src/scene-loader/GLTFModel.ts", "../@oasis-engine/loader/src/scene-loader/Model.ts", "../@oasis-engine/loader/src/scene-loader/plugins/PluginManager.ts", "../@oasis-engine/loader/src/scene-loader/temp.compatible.ts", "../@oasis-engine/loader/src/scene-loader/Parser.ts", "../@oasis-engine/loader/src/scene-loader/utils.ts", "../@oasis-engine/loader/src/scene-loader/resources/SchemaResource.ts", "../@oasis-engine/loader/src/scene-loader/resources/AnimationClipResource.ts", "../@oasis-engine/loader/src/scene-loader/resources/AnimatorControllerResource.ts", "../@oasis-engine/loader/src/scene-loader/resources/TextureResource.ts", "../@oasis-engine/loader/src/scene-loader/resources/BlinnPhongMaterialResource.ts", "../@oasis-engine/loader/src/scene-loader/resources/PBRMaterialResource.ts", "../@oasis-engine/loader/src/scene-loader/resources/PBRSpecularMaterialResource.ts", "../@oasis-engine/loader/src/scene-loader/resources/UnlitMaterialResource.ts", "../@oasis-engine/loader/src/scene-loader/resources/GLTFResource.ts", "../@oasis-engine/loader/src/scene-loader/resources/ScriptResource.ts", "../@oasis-engine/loader/src/scene-loader/resources/SpriteResource.ts", "../@oasis-engine/loader/src/scene-loader/resources/TextureCubeMapResource.ts", "../@oasis-engine/loader/src/scene-loader/resources/BaseResource.ts", "../@oasis-engine/loader/src/scene-loader/AbilityManager.ts", "../@oasis-engine/loader/src/scene-loader/NodeManager.ts", "../@oasis-engine/loader/src/scene-loader/SceneManager.ts", "../@oasis-engine/loader/src/scene-loader/resources/SpriteAtlasResource.ts", "../@oasis-engine/loader/src/scene-loader/ResourceManager.ts", "../@oasis-engine/loader/src/scene-loader/Oasis.ts", "../oasis-engine/src/index.ts"],
  "sourcesContent": ["/**\n * Defines how the bounding volumes intersects or contain one another.\n */\nexport enum ContainmentType {\n  /** Indicates that there is no overlap between two bounding volumes. */\n  Disjoint,\n  /** Indicates that one bounding volume completely contains another volume. */\n  Contains,\n  /** Indicates that bounding volumes partially overlap one another. */\n  Intersects\n}\n", "/**\n * Defines the intersection between a plane and a bounding volume.\n */\nexport enum PlaneIntersectionType {\n  /** There is no intersection, the bounding volume is in the back of the plane. */\n  Back,\n  /** There is no intersection, the bounding volume is in the front of the plane. */\n  Front,\n  /** The plane is intersected. */\n  Intersecting\n}\n", "/**\n * Common utility methods for math operations.\n */\nexport class MathUtil {\n  /** The value for which all absolute numbers smaller than are considered equal to zero. */\n  static readonly zeroTolerance: number = 1e-6;\n  /** The conversion factor that radian to degree. */\n  static readonly radToDegreeFactor: number = 180 / Math.PI;\n  /** The conversion factor that degree to radian. */\n  static readonly degreeToRadFactor: number = Math.PI / 180;\n\n  /**\n   * Clamps the specified value.\n   * @param v - The specified value\n   * @param min - The min value\n   * @param max - The max value\n   * @returns The result of clamping a value between min and max\n   */\n  static clamp(v: number, min: number, max: number): number {\n    return Math.max(min, Math.min(max, v));\n  }\n\n  /**\n   * Checks if a and b are almost equals.\n   * The absolute value of the difference between a and b is close to zero.\n   * @param a - The left value to compare\n   * @param b - The right value to compare\n   * @returns True if a almost equal to b, false otherwise\n   */\n  static equals(a: number, b: number): boolean {\n    return Math.abs(a - b) <= MathUtil.zeroTolerance;\n  }\n\n  /**\n   * Determines whether the specified v is pow2.\n   * @param v - The specified v\n   * @returns True if the specified v is pow2, false otherwise\n   */\n  static isPowerOf2(v: number): boolean {\n    return (v & (v - 1)) === 0;\n  }\n\n  /**\n   * Modify the specified r from radian to degree.\n   * @param r - The specified r\n   * @returns The degree value\n   */\n  static radianToDegree(r: number): number {\n    return r * MathUtil.radToDegreeFactor;\n  }\n\n  /**\n   * Modify the specified d from degree to radian.\n   * @param d - The specified d\n   * @returns The radian value\n   */\n  static degreeToRadian(d: number): number {\n    return d * MathUtil.degreeToRadFactor;\n  }\n}\n", "import { IClone } from \"@oasis-engine/design\";\nimport { MathUtil } from \"./MathUtil\";\nimport { Matrix } from \"./Matrix\";\nimport { Quaternion } from \"./Quaternion\";\nimport { Vector4 } from \"./Vector4\";\n\n/**\n * Describes a 3D-vector.\n */\nexport class Vector3 implements IClone {\n  /** @internal */\n  static readonly _zero = new Vector3(0.0, 0.0, 0.0);\n  /** @internal */\n  static readonly _one = new Vector3(1.0, 1.0, 1.0);\n\n  /**\n   * Determines the sum of two vectors.\n   * @param left - The first vector to add\n   * @param right - The second vector to add\n   * @param out - The sum of two vectors\n   */\n  static add(left: Vector3, right: Vector3, out: Vector3): void {\n    out.x = left.x + right.x;\n    out.y = left.y + right.y;\n    out.z = left.z + right.z;\n  }\n\n  /**\n   * Determines the difference between two vectors.\n   * @param left - The first vector to subtract\n   * @param right - The second vector to subtract\n   * @param out - The difference between two vectors\n   */\n  static subtract(left: Vector3, right: Vector3, out: Vector3): void {\n    out.x = left.x - right.x;\n    out.y = left.y - right.y;\n    out.z = left.z - right.z;\n  }\n\n  /**\n   * Determines the product of two vectors.\n   * @param left - The first vector to multiply\n   * @param right - The second vector to multiply\n   * @param out - The product of two vectors\n   */\n  static multiply(left: Vector3, right: Vector3, out: Vector3): void {\n    out.x = left.x * right.x;\n    out.y = left.y * right.y;\n    out.z = left.z * right.z;\n  }\n\n  /**\n   * Determines the divisor of two vectors.\n   * @param left - The first vector to divide\n   * @param right - The second vector to divide\n   * @param out - The divisor of two vectors\n   */\n  static divide(left: Vector3, right: Vector3, out: Vector3): void {\n    out.x = left.x / right.x;\n    out.y = left.y / right.y;\n    out.z = left.z / right.z;\n  }\n\n  /**\n   * Determines the dot product of two vectors.\n   * @param left - The first vector to dot\n   * @param right - The second vector to dot\n   * @returns The dot product of two vectors\n   */\n  static dot(left: Vector3, right: Vector3): number {\n    return left.x * right.x + left.y * right.y + left.z * right.z;\n  }\n\n  /**\n   * Determines the cross product of two vectors.\n   * @param left - The first vector to cross\n   * @param right - The second vector to cross\n   * @param out - The cross product of two vectors\n   */\n  static cross(left: Vector3, right: Vector3, out: Vector3): void {\n    const ax = left.x;\n    const ay = left.y;\n    const az = left.z;\n    const bx = right.x;\n    const by = right.y;\n    const bz = right.z;\n\n    out.x = ay * bz - az * by;\n    out.y = az * bx - ax * bz;\n    out.z = ax * by - ay * bx;\n  }\n\n  /**\n   * Determines the distance of two vectors.\n   * @param a - The first vector\n   * @param b - The second vector\n   * @returns The distance of two vectors\n   */\n  static distance(a: Vector3, b: Vector3): number {\n    const x = b.x - a.x;\n    const y = b.y - a.y;\n    const z = b.z - a.z;\n    return Math.sqrt(x * x + y * y + z * z);\n  }\n\n  /**\n   * Determines the squared distance of two vectors.\n   * @param a - The first vector\n   * @param b - The second vector\n   * @returns The squared distance of two vectors\n   */\n  static distanceSquared(a: Vector3, b: Vector3): number {\n    const x = b.x - a.x;\n    const y = b.y - a.y;\n    const z = b.z - a.z;\n    return x * x + y * y + z * z;\n  }\n\n  /**\n   * Determines whether the specified vectors are equals.\n   * @param left - The first vector to compare\n   * @param right - The second vector to compare\n   * @returns True if the specified vectors are equals, false otherwise\n   */\n  static equals(left: Vector3, right: Vector3): boolean {\n    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z);\n  }\n\n  /**\n   * Performs a linear interpolation between two vectors.\n   * @param start - The first vector\n   * @param end - The second vector\n   * @param t - The blend amount where 0 returns start and 1 end\n   * @param out - The result of linear blending between two vectors\n   */\n  static lerp(start: Vector3, end: Vector3, t: number, out: Vector3): void {\n    const { x, y, z } = start;\n    out.x = x + (end.x - x) * t;\n    out.y = y + (end.y - y) * t;\n    out.z = z + (end.z - z) * t;\n  }\n\n  /**\n   * Calculate a vector containing the largest components of the specified vectors.\n   * @param left - The first vector\n   * @param right - The second vector\n   * @param out - The vector containing the largest components of the specified vectors\n   */\n  static max(left: Vector3, right: Vector3, out: Vector3): void {\n    out.x = Math.max(left.x, right.x);\n    out.y = Math.max(left.y, right.y);\n    out.z = Math.max(left.z, right.z);\n  }\n\n  /**\n   * Calculate a vector containing the smallest components of the specified vectors.\n   * @param left - The first vector\n   * @param right - The second vector\n   * @param out - The vector containing the smallest components of the specified vectors\n   */\n  static min(left: Vector3, right: Vector3, out: Vector3): void {\n    out.x = Math.min(left.x, right.x);\n    out.y = Math.min(left.y, right.y);\n    out.z = Math.min(left.z, right.z);\n  }\n\n  /**\n   * Reverses the direction of a given vector.\n   * @param a - The vector to negate\n   * @param out - The vector facing in the opposite direction\n   */\n  static negate(a: Vector3, out: Vector3): void {\n    out.x = -a.x;\n    out.y = -a.y;\n    out.z = -a.z;\n  }\n\n  /**\n   * Converts the vector into a unit vector.\n   * @param a - The vector to normalize\n   * @param out - The normalized vector\n   */\n  static normalize(a: Vector3, out: Vector3): void {\n    const { x, y, z } = a;\n    let len: number = Math.sqrt(x * x + y * y + z * z);\n    if (len > 0) {\n      // TODO\n      len = 1 / len;\n      out.x = x * len;\n      out.y = y * len;\n      out.z = z * len;\n    }\n  }\n\n  /**\n   * Scale a vector by the given value.\n   * @param a - The vector to scale\n   * @param s - The amount by which to scale the vector\n   * @param out - The scaled vector\n   */\n  static scale(a: Vector3, s: number, out: Vector3): void {\n    out.x = a.x * s;\n    out.y = a.y * s;\n    out.z = a.z * s;\n  }\n\n  /**\n   * Performs a normal transformation using the given 4x4 matrix.\n   * @remarks\n   * A normal transform performs the transformation with the assumption that the w component\n   * is zero. This causes the fourth row and fourth column of the matrix to be unused. The\n   * end result is a vector that is not translated, but all other transformation properties\n   * apply. This is often preferred for normal vectors as normals purely represent direction\n   * rather than location because normal vectors should not be translated.\n   * @param v - The normal vector to transform\n   * @param m - The transform matrix\n   * @param out - The transformed normal\n   */\n  static transformNormal(v: Vector3, m: Matrix, out: Vector3): void {\n    const { x, y, z } = v;\n    const e = m.elements;\n    out.x = x * e[0] + y * e[4] + z * e[8];\n    out.y = x * e[1] + y * e[5] + z * e[9];\n    out.z = x * e[2] + y * e[6] + z * e[10];\n  }\n\n  /**\n   * Performs a transformation using the given 4x4 matrix.\n   * @param v - The vector to transform\n   * @param m - The transform matrix\n   * @param out - The transformed vector3\n   */\n  static transformToVec3(v: Vector3, m: Matrix, out: Vector3): void {\n    const { x, y, z } = v;\n    const e = m.elements;\n\n    out.x = x * e[0] + y * e[4] + z * e[8] + e[12];\n    out.y = x * e[1] + y * e[5] + z * e[9] + e[13];\n    out.z = x * e[2] + y * e[6] + z * e[10] + e[14];\n  }\n\n  /**\n   * Performs a transformation from vector3 to vector4 using the given 4x4 matrix.\n   * @param v - The vector to transform\n   * @param m - The transform matrix\n   * @param out - The transformed vector4\n   */\n  static transformToVec4(v: Vector3, m: Matrix, out: Vector4): void {\n    const { x, y, z } = v;\n    const e = m.elements;\n\n    out.x = x * e[0] + y * e[4] + z * e[8] + e[12];\n    out.y = x * e[1] + y * e[5] + z * e[9] + e[13];\n    out.z = x * e[2] + y * e[6] + z * e[10] + e[14];\n    out.w = x * e[3] + y * e[7] + z * e[11] + e[15];\n  }\n\n  /**\n   * Performs a coordinate transformation using the given 4x4 matrix.\n   *\n   * @remarks\n   * A coordinate transform performs the transformation with the assumption that the w component\n   * is one. The four dimensional vector obtained from the transformation operation has each\n   * component in the vector divided by the w component. This forces the w-component to be one and\n   * therefore makes the vector homogeneous. The homogeneous vector is often preferred when working\n   * with coordinates as the w component can safely be ignored.\n   * @param v - The coordinate vector to transform\n   * @param m - The transform matrix\n   * @param out - The transformed coordinates\n   */\n  static transformCoordinate(v: Vector3, m: Matrix, out: Vector3): void {\n    const { x, y, z } = v;\n    const e = m.elements;\n    let w = x * e[3] + y * e[7] + z * e[11] + e[15];\n    w = 1.0 / w;\n\n    out.x = (x * e[0] + y * e[4] + z * e[8] + e[12]) * w;\n    out.y = (x * e[1] + y * e[5] + z * e[9] + e[13]) * w;\n    out.z = (x * e[2] + y * e[6] + z * e[10] + e[14]) * w;\n  }\n\n  /**\n   * Performs a transformation using the given quaternion.\n   * @param v - The vector to transform\n   * @param quaternion - The transform quaternion\n   * @param out - The transformed vector\n   */\n  static transformByQuat(v: Vector3, quaternion: Quaternion, out: Vector3): void {\n    const { x, y, z } = v;\n    const { x: qx, y: qy, z: qz, w: qw } = quaternion;\n\n    // calculate quat * vec\n    const ix = qw * x + qy * z - qz * y;\n    const iy = qw * y + qz * x - qx * z;\n    const iz = qw * z + qx * y - qy * x;\n    const iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n    out.x = ix * qw - iw * qx - iy * qz + iz * qy;\n    out.y = iy * qw - iw * qy - iz * qx + ix * qz;\n    out.z = iz * qw - iw * qz - ix * qy + iy * qx;\n  }\n\n  /** The x component of the vector.*/\n  x: number;\n  /** The y component of the vector.*/\n  y: number;\n  /** The z component of the vector.*/\n  z: number;\n\n  /**\n   * Constructor of Vector3.\n   * @param x - The x component of the vector, default 0\n   * @param y - The y component of the vector, default 0\n   * @param z - The z component of the vector, default 0\n   */\n  constructor(x: number = 0, y: number = 0, z: number = 0) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  /**\n   * Set the value of this vector.\n   * @param x - The x component of the vector\n   * @param y - The y component of the vector\n   * @param z - The z component of the vector\n   * @returns This vector\n   */\n  setValue(x: number, y: number, z: number): Vector3 {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  }\n\n  /**\n   * Set the value of this vector by an array.\n   * @param array - The array\n   * @param offset - The start offset of the array\n   * @returns This vector\n   */\n  setValueByArray(array: ArrayLike<number>, offset: number = 0): Vector3 {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    return this;\n  }\n\n  /**\n   * Determines the sum of this vector and the specified vector.\n   * @param right - The specified vector\n   * @returns This vector\n   */\n  add(right: Vector3): Vector3 {\n    this.x += right.x;\n    this.y += right.y;\n    this.z += right.z;\n    return this;\n  }\n\n  /**\n   * Determines the difference of this vector and the specified vector.\n   * @param right - The specified vector\n   * @returns This vector\n   */\n  subtract(right: Vector3): Vector3 {\n    this.x -= right.x;\n    this.y -= right.y;\n    this.z -= right.z;\n    return this;\n  }\n\n  /**\n   * Determines the product of this vector and the specified vector.\n   * @param right - The specified vector\n   * @returns This vector\n   */\n  multiply(right: Vector3): Vector3 {\n    this.x *= right.x;\n    this.y *= right.y;\n    this.z *= right.z;\n    return this;\n  }\n\n  /**\n   * Determines the divisor of this vector and the specified vector.\n   * @param right - The specified vector\n   * @returns This vector\n   */\n  divide(right: Vector3): Vector3 {\n    this.x /= right.x;\n    this.y /= right.y;\n    this.z /= right.z;\n    return this;\n  }\n\n  /**\n   * Calculate the length of this vector.\n   * @returns The length of this vector\n   */\n  length(): number {\n    const { x, y, z } = this;\n    return Math.sqrt(x * x + y * y + z * z);\n  }\n\n  /**\n   * Calculate the squared length of this vector.\n   * @returns The squared length of this vector\n   */\n  lengthSquared(): number {\n    const { x, y, z } = this;\n    return x * x + y * y + z * z;\n  }\n\n  /**\n   * Reverses the direction of this vector.\n   * @returns This vector\n   */\n  negate(): Vector3 {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  }\n\n  /**\n   * Converts this vector into a unit vector.\n   * @returns This vector\n   */\n  normalize(): Vector3 {\n    Vector3.normalize(this, this);\n    return this;\n  }\n\n  /**\n   * Scale this vector by the given value.\n   * @param s - The amount by which to scale the vector\n   * @returns This vector\n   */\n  scale(s: number): Vector3 {\n    this.x *= s;\n    this.y *= s;\n    this.z *= s;\n    return this;\n  }\n\n  /**\n   * Clone the value of this vector to an array.\n   * @param out - The array\n   * @param outOffset - The start offset of the array\n   */\n  toArray(out: number[] | Float32Array | Float64Array, outOffset: number = 0) {\n    out[outOffset] = this.x;\n    out[outOffset + 1] = this.y;\n    out[outOffset + 2] = this.z;\n  }\n\n  /**\n   * Creates a clone of this vector.\n   * @returns A clone of this vector\n   */\n  clone(): Vector3 {\n    return new Vector3(this.x, this.y, this.z);\n  }\n\n  /**\n   * Clones this vector to the specified vector.\n   * @param out - The specified vector\n   * @returns The specified vector\n   */\n  cloneTo(out: Vector3): Vector3 {\n    out.x = this.x;\n    out.y = this.y;\n    out.z = this.z;\n    return out;\n  }\n\n  /**\n   * This vector performs a normal transformation using the given 4x4 matrix.\n   * @remarks\n   * A normal transform performs the transformation with the assumption that the w component\n   * is zero. This causes the fourth row and fourth column of the matrix to be unused. The\n   * end result is a vector that is not translated, but all other transformation properties\n   * apply. This is often preferred for normal vectors as normals purely represent direction\n   * rather than location because normal vectors should not be translated.\n   * @param m - The transform matrix\n   * @returns This vector\n   */\n  transformNormal(m: Matrix): Vector3 {\n    Vector3.transformNormal(this, m, this);\n    return this;\n  }\n\n  /**\n   * This vector performs a transformation using the given 4x4 matrix.\n   * @param m - The transform matrix\n   * @returns This vector\n   */\n  transformToVec3(m: Matrix): Vector3 {\n    Vector3.transformToVec3(this, m, this);\n    return this;\n  }\n\n  /**\n   * This vector performs a coordinate transformation using the given 4x4 matrix.\n   * @remarks\n   * A coordinate transform performs the transformation with the assumption that the w component\n   * is one. The four dimensional vector obtained from the transformation operation has each\n   * component in the vector divided by the w component. This forces the w-component to be one and\n   * therefore makes the vector homogeneous. The homogeneous vector is often preferred when working\n   * with coordinates as the w component can safely be ignored.\n   * @param m - The transform matrix\n   * @returns This vector\n   */\n  transformCoordinate(m: Matrix): Vector3 {\n    Vector3.transformCoordinate(this, m, this);\n    return this;\n  }\n\n  /**\n   * This vector performs a transformation using the given quaternion.\n   * @param quaternion - The transform quaternion\n   * @returns This vector\n   */\n  transformByQuat(quaternion: Quaternion): Vector3 {\n    Vector3.transformByQuat(this, quaternion, this);\n    return this;\n  }\n}\n", "import { IClone } from \"@oasis-engine/design\";\nimport { BoundingBox } from \"./BoundingBox\";\nimport { Vector3 } from \"./Vector3\";\n\n/**\n * A bounding sphere.\n * */\nexport class BoundingSphere implements IClone {\n  private static _tempVec30: Vector3 = new Vector3();\n\n  /**\n   * Calculate a bounding sphere that fully contains the given points.\n   * @param points - The given points\n   * @param out - The calculated bounding sphere\n   */\n  static fromPoints(points: Vector3[], out: BoundingSphere): void {\n    if (!points || points.length === 0) {\n      throw new Error(\"points must be array and length must > 0\");\n    }\n\n    const len = points.length;\n    const center = BoundingSphere._tempVec30;\n    center.x = center.y = center.z = 0;\n\n    // Calculate the center of the sphere.\n    for (let i = 0; i < len; ++i) {\n      Vector3.add(points[i], center, center);\n    }\n\n    // The center of the sphere.\n    Vector3.scale(center, 1 / len, out.center);\n\n    // Calculate the radius of the sphere.\n    let radius = 0.0;\n    for (let i = 0; i < len; ++i) {\n      const distance = Vector3.distanceSquared(center, points[i]);\n      distance > radius && (radius = distance);\n    }\n    // The radius of the sphere.\n    out.radius = Math.sqrt(radius);\n  }\n\n  /**\n   * Calculate a bounding sphere from a given box.\n   * @param box - The given box\n   * @param out - The calculated bounding sphere\n   */\n  static fromBox(box: BoundingBox, out: BoundingSphere): void {\n    const { center } = out;\n    const { min, max } = box;\n\n    center.x = (min.x + max.x) * 0.5;\n    center.y = (min.y + max.y) * 0.5;\n    center.z = (min.z + max.z) * 0.5;\n    out.radius = Vector3.distance(center, max);\n  }\n\n  /** The center point of the sphere. */\n  public readonly center: Vector3 = new Vector3();\n  /** The radius of the sphere. */\n  public radius: number = 0;\n\n  /**\n   * Constructor of BoundingSphere.\n   * @param center - The center point of the sphere\n   * @param radius - The radius of the sphere\n   */\n  constructor(center: Vector3 = null, radius: number = 0) {\n    center && center.cloneTo(this.center);\n    this.radius = radius;\n  }\n\n  /**\n   * Creates a clone of this sphere.\n   * @returns A clone of this sphere\n   */\n  clone(): BoundingSphere {\n    return new BoundingSphere(this.center, this.radius);\n  }\n\n  /**\n   * Clones this sphere to the specified sphere.\n   * @param out - The specified sphere\n   * @returns The specified sphere\n   */\n  cloneTo(out: BoundingSphere): BoundingSphere {\n    this.center.cloneTo(out.center);\n    out.radius = this.radius;\n    return out;\n  }\n}\n", "import { IClone } from \"@oasis-engine/design\";\nimport { BoundingSphere } from \"./BoundingSphere\";\nimport { Matrix } from \"./Matrix\";\nimport { Vector3 } from \"./Vector3\";\n\n/**\n * Axis Aligned Bound Box (AABB).\n */\nexport class BoundingBox implements IClone {\n  private static _tempVec30: Vector3 = new Vector3();\n  private static _tempVec31: Vector3 = new Vector3();\n\n  /**\n   * Calculate a bounding box from the center point and the extent of the bounding box.\n   * @param center - The center point\n   * @param extent - The extent of the bounding box\n   * @param out - The calculated bounding box\n   */\n  static fromCenterAndExtent(center: Vector3, extent: Vector3, out: BoundingBox): void {\n    Vector3.subtract(center, extent, out.min);\n    Vector3.add(center, extent, out.max);\n  }\n\n  /**\n   * Calculate a bounding box that fully contains the given points.\n   * @param points - The given points\n   * @param out - The calculated bounding box\n   */\n  static fromPoints(points: Vector3[], out: BoundingBox): void {\n    if (!points || points.length === 0) {\n      throw new Error(\"points must be array and length must > 0\");\n    }\n\n    const { min, max } = out;\n    min.x = min.y = min.z = Number.MAX_VALUE;\n    max.x = max.y = max.z = -Number.MAX_VALUE;\n\n    for (let i = 0, l = points.length; i < l; ++i) {\n      const point = points[i];\n      Vector3.min(min, point, min);\n      Vector3.max(max, point, max);\n    }\n  }\n\n  /**\n   * Calculate a bounding box from a given sphere.\n   * @param sphere - The given sphere\n   * @param out - The calculated bounding box\n   */\n  static fromSphere(sphere: BoundingSphere, out: BoundingBox): void {\n    const { center, radius } = sphere;\n    const { min, max } = out;\n\n    min.x = center.x - radius;\n    min.y = center.y - radius;\n    min.z = center.z - radius;\n    max.x = center.x + radius;\n    max.y = center.y + radius;\n    max.z = center.z + radius;\n  }\n\n  /**\n   * Transform a bounding box.\n   * @param source - The original bounding box\n   * @param matrix - The transform to apply to the bounding box\n   * @param out - The transformed bounding box\n   */\n  static transform(source: BoundingBox, matrix: Matrix, out: BoundingBox): void {\n    // https://zeux.io/2010/10/17/aabb-from-obb-with-component-wise-abs/\n    const center = BoundingBox._tempVec30;\n    const extent = BoundingBox._tempVec31;\n    source.getCenter(center);\n    source.getExtent(extent);\n    Vector3.transformCoordinate(center, matrix, center);\n\n    const { x, y, z } = extent;\n    const e = matrix.elements;\n    extent.x = Math.abs(x * e[0]) + Math.abs(y * e[4]) + Math.abs(z * e[8]);\n    extent.y = Math.abs(x * e[1]) + Math.abs(y * e[5]) + Math.abs(z * e[9]);\n    extent.z = Math.abs(x * e[2]) + Math.abs(y * e[6]) + Math.abs(z * e[10]);\n\n    // set min\u3001max\n    Vector3.subtract(center, extent, out.min);\n    Vector3.add(center, extent, out.max);\n  }\n\n  /**\n   * Calculate a bounding box that is as large as the total combined area of the two specified boxes.\n   * @param box1 - The first box to merge\n   * @param box2 - The second box to merge\n   * @param out - The merged bounding box\n   * @returns The merged bounding box\n   */\n  static merge(box1: BoundingBox, box2: BoundingBox, out: BoundingBox): BoundingBox {\n    Vector3.min(box1.min, box2.min, out.min);\n    Vector3.max(box1.max, box2.max, out.max);\n    return out;\n  }\n\n  /** The minimum point of the box. */\n  public readonly min: Vector3 = new Vector3();\n  /** The maximum point of the box. */\n  public readonly max: Vector3 = new Vector3();\n\n  /**\n   * Constructor of BoundingBox.\n   * @param min - The minimum point of the box\n   * @param max - The maximum point of the box\n   */\n  constructor(min: Vector3 = null, max: Vector3 = null) {\n    min && min.cloneTo(this.min);\n    max && max.cloneTo(this.max);\n  }\n\n  /**\n   * Creates a clone of this box.\n   * @returns A clone of this box\n   */\n  clone(): BoundingBox {\n    return new BoundingBox(this.min, this.max);\n  }\n\n  /**\n   * Clones this box to the specified box.\n   * @param out - The specified box\n   * @returns The specified box\n   */\n  cloneTo(out: BoundingBox): BoundingBox {\n    this.min.cloneTo(out.min);\n    this.max.cloneTo(out.max);\n    return out;\n  }\n\n  /**\n   * Get the center point of this bounding box.\n   * @param out - The center point of this bounding box\n   * @returns The center point of this bounding box\n   */\n  getCenter(out: Vector3): Vector3 {\n    Vector3.add(this.min, this.max, out);\n    Vector3.scale(out, 0.5, out);\n    return out;\n  }\n\n  /**\n   * Get the extent of this bounding box.\n   * @param out - The extent of this bounding box\n   * @returns The extent of this bounding box\n   */\n  getExtent(out: Vector3): Vector3 {\n    Vector3.subtract(this.max, this.min, out);\n    Vector3.scale(out, 0.5, out);\n    return out;\n  }\n\n  /**\n   * Get the eight corners of this bounding box.\n   * @param out - An array of points representing the eight corners of this bounding box\n   * @returns An array of points representing the eight corners of this bounding box\n   */\n  getCorners(out: Vector3[] = []): Vector3[] {\n    const { min, max } = this;\n    const minX = min.x;\n    const minY = min.y;\n    const minZ = min.z;\n    const maxX = max.x;\n    const maxY = max.y;\n    const maxZ = max.z;\n    const len = out.length;\n\n    // The array length is less than 8 to make up\n    if (len < 8) {\n      for (let i = 0, l = 8 - len; i < l; ++i) {\n        out[len + i] = new Vector3();\n      }\n    }\n\n    out[0].setValue(minX, maxY, maxZ);\n    out[1].setValue(maxX, maxY, maxZ);\n    out[2].setValue(maxX, minY, maxZ);\n    out[3].setValue(minX, minY, maxZ);\n    out[4].setValue(minX, maxY, minZ);\n    out[5].setValue(maxX, maxY, minZ);\n    out[6].setValue(maxX, minY, minZ);\n    out[7].setValue(minX, minY, minZ);\n\n    return out;\n  }\n\n  /**\n   * Transform a bounding box.\n   * @param matrix - The transform to apply to the bounding box\n   * @returns The transformed bounding box\n   */\n  public transform(matrix: Matrix): BoundingBox {\n    BoundingBox.transform(this, matrix, this);\n    return this;\n  }\n}\n", "import { BoundingBox } from \"./BoundingBox\";\nimport { BoundingFrustum } from \"./BoundingFrustum\";\nimport { BoundingSphere } from \"./BoundingSphere\";\nimport { ContainmentType } from \"./enums/ContainmentType\";\nimport { PlaneIntersectionType } from \"./enums/PlaneIntersectionType\";\nimport { MathUtil } from \"./MathUtil\";\nimport { Plane } from \"./Plane\";\nimport { Ray } from \"./Ray\";\nimport { Vector3 } from \"./Vector3\";\n\n/**\n * Contains static methods to help in determining intersections, containment, etc.\n */\nexport class CollisionUtil {\n  private static _tempVec30: Vector3 = new Vector3();\n  private static _tempVec31: Vector3 = new Vector3();\n\n  /**\n   * Calculate the distance from a point to a plane.\n   * @param plane - The plane\n   * @param point - The point\n   * @returns The distance from a point to a plane\n   */\n  static distancePlaneAndPoint(plane: Plane, point: Vector3): number {\n    return Vector3.dot(plane.normal, point) + plane.distance;\n  }\n\n  /**\n   * Get the intersection type between a plane and a point.\n   * @param plane - The plane\n   * @param point - The point\n   * @returns The intersection type\n   */\n  static intersectsPlaneAndPoint(plane: Plane, point: Vector3): PlaneIntersectionType {\n    const distance = CollisionUtil.distancePlaneAndPoint(plane, point);\n    if (distance > 0) {\n      return PlaneIntersectionType.Front;\n    }\n    if (distance < 0) {\n      return PlaneIntersectionType.Back;\n    }\n    return PlaneIntersectionType.Intersecting;\n  }\n\n  /**\n   * Get the intersection type between a plane and a box (AABB).\n   * @param plane - The plane\n   * @param box - The box\n   * @returns The intersection type\n   */\n  static intersectsPlaneAndBox(plane: Plane, box: BoundingBox): PlaneIntersectionType {\n    const { min, max } = box;\n    const { normal } = plane;\n    const front = CollisionUtil._tempVec30;\n    const back = CollisionUtil._tempVec31;\n\n    if (normal.x >= 0) {\n      front.x = max.x;\n      back.x = min.x;\n    } else {\n      front.x = min.x;\n      back.x = max.x;\n    }\n    if (normal.y >= 0) {\n      front.y = max.y;\n      back.y = min.y;\n    } else {\n      front.y = min.y;\n      back.y = max.y;\n    }\n    if (normal.z >= 0) {\n      front.z = max.z;\n      back.z = min.z;\n    } else {\n      front.z = min.z;\n      back.z = max.z;\n    }\n\n    if (CollisionUtil.distancePlaneAndPoint(plane, front) < 0) {\n      return PlaneIntersectionType.Back;\n    }\n\n    if (CollisionUtil.distancePlaneAndPoint(plane, back) > 0) {\n      return PlaneIntersectionType.Front;\n    }\n\n    return PlaneIntersectionType.Intersecting;\n  }\n\n  /**\n   * Get the intersection type between a plane and a sphere.\n   * @param plane - The plane\n   * @param sphere - The sphere\n   * @returns The intersection type\n   */\n  static intersectsPlaneAndSphere(plane: Plane, sphere: BoundingSphere): PlaneIntersectionType {\n    const { center, radius } = sphere;\n    const distance = CollisionUtil.distancePlaneAndPoint(plane, center);\n    if (distance > radius) {\n      return PlaneIntersectionType.Front;\n    }\n    if (distance < -radius) {\n      return PlaneIntersectionType.Back;\n    }\n    return PlaneIntersectionType.Intersecting;\n  }\n\n  /**\n   * Get the intersection type between a ray and a plane.\n   * @param ray - The ray\n   * @param plane - The plane\n   * @returns The distance from ray to plane if intersecting, -1 otherwise\n   */\n  static intersectsRayAndPlane(ray: Ray, plane: Plane): number {\n    const { normal } = plane;\n    const { zeroTolerance } = MathUtil;\n\n    const dir = Vector3.dot(normal, ray.direction);\n    // Parallel\n    if (Math.abs(dir) < zeroTolerance) {\n      return -1;\n    }\n\n    const position = Vector3.dot(normal, ray.origin);\n    let distance = (-plane.distance - position) / dir;\n\n    if (distance < 0) {\n      if (distance < -zeroTolerance) {\n        return -1;\n      }\n\n      distance = 0;\n    }\n\n    return distance;\n  }\n\n  /**\n   * Get the intersection type between a ray and a box (AABB).\n   * @param ray - The ray\n   * @param box - The box\n   * @returns The distance from ray to box if intersecting, -1 otherwise\n   */\n  static intersectsRayAndBox(ray: Ray, box: BoundingBox): number {\n    const { zeroTolerance } = MathUtil;\n    const { origin, direction } = ray;\n    const { min, max } = box;\n    const dirX = direction.x;\n    const dirY = direction.y;\n    const dirZ = direction.z;\n    const oriX = origin.x;\n    const oriY = origin.y;\n    const oriZ = origin.z;\n    let distance = 0;\n    let tmax = Number.MAX_VALUE;\n\n    if (Math.abs(dirX) < zeroTolerance) {\n      if (oriX < min.x || oriX > max.x) {\n        return -1;\n      }\n    } else {\n      const inverse = 1.0 / dirX;\n      let t1 = (min.x - oriX) * inverse;\n      let t2 = (max.x - oriX) * inverse;\n\n      if (t1 > t2) {\n        const temp = t1;\n        t1 = t2;\n        t2 = temp;\n      }\n\n      distance = Math.max(t1, distance);\n      tmax = Math.min(t2, tmax);\n\n      if (distance > tmax) {\n        return -1;\n      }\n    }\n\n    if (Math.abs(dirY) < zeroTolerance) {\n      if (oriY < min.y || oriY > max.y) {\n        return -1;\n      }\n    } else {\n      const inverse = 1.0 / dirY;\n      let t1 = (min.y - oriY) * inverse;\n      let t2 = (max.y - oriY) * inverse;\n\n      if (t1 > t2) {\n        const temp = t1;\n        t1 = t2;\n        t2 = temp;\n      }\n\n      distance = Math.max(t1, distance);\n      tmax = Math.min(t2, tmax);\n\n      if (distance > tmax) {\n        return -1;\n      }\n    }\n\n    if (Math.abs(dirZ) < zeroTolerance) {\n      if (oriZ < min.z || oriZ > max.z) {\n        return -1;\n      }\n    } else {\n      const inverse = 1.0 / dirZ;\n      let t1 = (min.z - oriZ) * inverse;\n      let t2 = (max.z - oriZ) * inverse;\n\n      if (t1 > t2) {\n        const temp = t1;\n        t1 = t2;\n        t2 = temp;\n      }\n\n      distance = Math.max(t1, distance);\n      tmax = Math.min(t2, tmax);\n\n      if (distance > tmax) {\n        return -1;\n      }\n    }\n\n    return distance;\n  }\n\n  /**\n   * Get the intersection type between a ray and a sphere.\n   * @param ray - The ray\n   * @param sphere - The sphere\n   * @returns The distance from ray to sphere if intersecting, -1 otherwise\n   */\n  static intersectsRayAndSphere(ray: Ray, sphere: BoundingSphere): number {\n    const { origin, direction } = ray;\n    const { center, radius } = sphere;\n\n    const m = CollisionUtil._tempVec30;\n    Vector3.subtract(origin, center, m);\n    const b = Vector3.dot(m, direction);\n    const c = Vector3.dot(m, m) - radius * radius;\n\n    if (b > 0 && c > 0) {\n      return -1;\n    }\n\n    let discriminant = b * b - c;\n    if (discriminant < 0) {\n      return -1;\n    }\n\n    let distance = -b - Math.sqrt(discriminant);\n    if (distance < 0) {\n      distance = 0;\n    }\n\n    return distance;\n  }\n\n  /**\n   * Get whether or not a specified bounding box intersects with this frustum (Contains or Intersects).\n   * @param frustum - The frustum\n   * @param box - The box\n   * @returns True if bounding box intersects with this frustum, false otherwise\n   */\n  static intersectsFrustumAndBox(frustum: BoundingFrustum, box: BoundingBox): boolean {\n    const { min, max } = box;\n    const back = CollisionUtil._tempVec30;\n\n    for (let i = 0; i < 6; ++i) {\n      const plane = frustum.getPlane(i);\n      const normal = plane.normal;\n\n      back.x = normal.x >= 0 ? min.x : max.x;\n      back.y = normal.y >= 0 ? min.y : max.y;\n      back.z = normal.z >= 0 ? min.z : max.z;\n      if (Vector3.dot(plane.normal, back) > -plane.distance) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Get the containment type between a frustum and a box (AABB).\n   * @param frustum - The frustum\n   * @param box - The box\n   * @returns The containment type\n   */\n  static frustumContainsBox(frustum: BoundingFrustum, box: BoundingBox): ContainmentType {\n    const { min, max } = box;\n    const front = CollisionUtil._tempVec30;\n    const back = CollisionUtil._tempVec31;\n    let result = ContainmentType.Contains;\n\n    for (let i = 0; i < 6; ++i) {\n      const plane = frustum.getPlane(i);\n      const normal = plane.normal;\n\n      if (normal.x >= 0) {\n        front.x = max.x;\n        back.x = min.x;\n      } else {\n        front.x = min.x;\n        back.x = max.x;\n      }\n      if (normal.y >= 0) {\n        front.y = max.y;\n        back.y = min.y;\n      } else {\n        front.y = min.y;\n        back.y = max.y;\n      }\n      if (normal.z >= 0) {\n        front.z = max.z;\n        back.z = min.z;\n      } else {\n        front.z = min.z;\n        back.z = max.z;\n      }\n\n      if (CollisionUtil.intersectsPlaneAndPoint(plane, back) === PlaneIntersectionType.Front) {\n        return ContainmentType.Disjoint;\n      }\n\n      if (CollisionUtil.intersectsPlaneAndPoint(plane, front) === PlaneIntersectionType.Front) {\n        result = ContainmentType.Intersects;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the containment type between a frustum and a sphere.\n   * @param frustum - The frustum\n   * @param sphere - The sphere\n   * @returns The containment type\n   */\n  static frustumContainsSphere(frustum: BoundingFrustum, sphere: BoundingSphere): ContainmentType {\n    let result = ContainmentType.Contains;\n\n    for (let i = 0; i < 6; ++i) {\n      const plane = frustum.getPlane(i);\n      const intersectionType = CollisionUtil.intersectsPlaneAndSphere(plane, sphere);\n      if (intersectionType === PlaneIntersectionType.Front) {\n        return ContainmentType.Disjoint;\n      } else if (intersectionType === PlaneIntersectionType.Intersecting) {\n        result = ContainmentType.Intersects;\n        break;\n      }\n    }\n\n    return result;\n  }\n}\n", "import { IClone } from \"@oasis-engine/design\";\nimport { Vector3 } from \"./Vector3\";\n\n/**\n * Represents a plane in three dimensional space.\n */\nexport class Plane implements IClone {\n  /**\n   * Normalize the normal vector of the specified plane.\n   * @param p - The specified plane\n   * @param out - A normalized version of the specified plane\n   */\n  static normalize(p: Plane, out: Plane): void {\n    const { normal } = p;\n    const factor = 1.0 / normal.length();\n\n    const outNormal = out.normal;\n    outNormal.x = normal.x * factor;\n    outNormal.y = normal.y * factor;\n    outNormal.z = normal.z * factor;\n    out.distance = p.distance * factor;\n  }\n\n  /**\n   * Calculate the plane that contains the three specified points.\n   * @param point0 - The first point\n   * @param point1 - The second point\n   * @param point2 - The third point\n   * @param out - The calculated plane\n   */\n  static fromPoints(point0: Vector3, point1: Vector3, point2: Vector3, out: Plane): void {\n    const x0 = point0.x;\n    const y0 = point0.y;\n    const z0 = point0.z;\n    const x1 = point1.x - x0;\n    const y1 = point1.y - y0;\n    const z1 = point1.z - z0;\n    const x2 = point2.x - x0;\n    const y2 = point2.y - y0;\n    const z2 = point2.z - z0;\n    const yz = y1 * z2 - z1 * y2;\n    const xz = z1 * x2 - x1 * z2;\n    const xy = x1 * y2 - y1 * x2;\n    const invPyth = 1.0 / Math.sqrt(yz * yz + xz * xz + xy * xy);\n\n    const x = yz * invPyth;\n    const y = xz * invPyth;\n    const z = xy * invPyth;\n\n    const { normal } = out;\n    normal.x = x;\n    normal.y = y;\n    normal.z = z;\n\n    out.distance = -(x * x0 + y * y0 + z * z0);\n  }\n\n  /** The normal of the plane. */\n  public readonly normal: Vector3 = new Vector3();\n  /** The distance of the plane along its normal to the origin. */\n  public distance: number = 0;\n\n  /**\n   * Constructor of Plane.\n   * @param normal - The normal vector\n   * @param distance - The distance of the plane along its normal to the origin\n   */\n  constructor(normal: Vector3 = null, distance: number = 0) {\n    normal && normal.cloneTo(this.normal);\n    this.distance = distance;\n  }\n\n  /**\n   * Normalize the normal vector of this plane.\n   * @returns The plane after normalize\n   */\n  normalize(): Plane {\n    Plane.normalize(this, this);\n    return this;\n  }\n\n  /**\n   * Creates a clone of this plane.\n   * @returns A clone of this plane\n   */\n  clone(): Plane {\n    const out = new Plane();\n    this.cloneTo(out);\n    return out;\n  }\n\n  /**\n   * Clones this plane to the specified plane.\n   * @param out - The specified plane\n   * @returns The specified plane\n   */\n  cloneTo(out: Plane): Plane {\n    this.normal.cloneTo(out.normal);\n    out.distance = this.distance;\n    return out;\n  }\n}\n", "import { IClone } from \"@oasis-engine/design\";\nimport { BoundingBox } from \"./BoundingBox\";\nimport { BoundingSphere } from \"./BoundingSphere\";\nimport { CollisionUtil } from \"./CollisionUtil\";\nimport { ContainmentType } from \"./enums/ContainmentType\";\nimport { Matrix } from \"./Matrix\";\nimport { Plane } from \"./Plane\";\n\n/**\n * A bounding frustum.\n */\nexport class BoundingFrustum implements IClone {\n  /** The near plane of this frustum. */\n  public near: Plane;\n  /** The far plane of this frustum. */\n  public far: Plane;\n  /** The left plane of this frustum. */\n  public left: Plane;\n  /** The right plane of this frustum. */\n  public right: Plane;\n  /** The top plane of this frustum. */\n  public top: Plane;\n  /** The bottom plane of this frustum. */\n  public bottom: Plane;\n\n  /**\n   * Constructor of BoundingFrustum.\n   * @param matrix - The view-projection matrix\n   */\n  constructor(matrix: Matrix = null) {\n    this.near = new Plane();\n    this.far = new Plane();\n    this.left = new Plane();\n    this.right = new Plane();\n    this.top = new Plane();\n    this.bottom = new Plane();\n\n    matrix && this.calculateFromMatrix(matrix);\n  }\n\n  /**\n   * Creates a clone of this frustum.\n   * @returns A clone of this frustum\n   */\n  clone(): BoundingFrustum {\n    const bf = new BoundingFrustum();\n    this.cloneTo(bf);\n    return bf;\n  }\n\n  /**\n   * Clones this frustum to the specified frustum.\n   * @param out - The specified frustum\n   * @returns The specified frustum\n   */\n  cloneTo(out: BoundingFrustum): BoundingFrustum {\n    this.near.cloneTo(out.near);\n    this.far.cloneTo(out.far);\n    this.left.cloneTo(out.left);\n    this.right.cloneTo(out.right);\n    this.top.cloneTo(out.top);\n    this.bottom.cloneTo(out.bottom);\n    return out;\n  }\n\n  /**\n   * Get the plane by the given index.\n   * 0: near\n   * 1: far\n   * 2: left\n   * 3: right\n   * 4: top\n   * 5: bottom\n   * @param index - The index\n   * @returns The plane get\n   */\n  getPlane(index: number): Plane {\n    switch (index) {\n      case 0:\n        return this.near;\n      case 1:\n        return this.far;\n      case 2:\n        return this.left;\n      case 3:\n        return this.right;\n      case 4:\n        return this.top;\n      case 5:\n        return this.bottom;\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Update all planes from the given matrix.\n   * @param matrix - The given view-projection matrix\n   */\n  public calculateFromMatrix(matrix: Matrix): void {\n    const me = matrix.elements;\n    const m11 = me[0];\n    const m12 = me[1];\n    const m13 = me[2];\n    const m14 = me[3];\n    const m21 = me[4];\n    const m22 = me[5];\n    const m23 = me[6];\n    const m24 = me[7];\n    const m31 = me[8];\n    const m32 = me[9];\n    const m33 = me[10];\n    const m34 = me[11];\n    const m41 = me[12];\n    const m42 = me[13];\n    const m43 = me[14];\n    const m44 = me[15];\n\n    // near\n    const nearNormal = this.near.normal;\n    nearNormal.x = -m14 - m13;\n    nearNormal.y = -m24 - m23;\n    nearNormal.z = -m34 - m33;\n    this.near.distance = -m44 - m43;\n    this.near.normalize();\n\n    // far\n    const farNormal = this.far.normal;\n    farNormal.x = m13 - m14;\n    farNormal.y = m23 - m24;\n    farNormal.z = m33 - m34;\n    this.far.distance = m43 - m44;\n\n    this.far.normalize();\n\n    // left\n    const leftNormal = this.left.normal;\n    leftNormal.x = -m14 - m11;\n    leftNormal.y = -m24 - m21;\n    leftNormal.z = -m34 - m31;\n    this.left.distance = -m44 - m41;\n    this.left.normalize();\n\n    // right\n    const rightNormal = this.right.normal;\n    rightNormal.x = m11 - m14;\n    rightNormal.y = m21 - m24;\n    rightNormal.z = m31 - m34;\n    this.right.distance = m41 - m44;\n    this.right.normalize();\n\n    // top\n    const topNormal = this.top.normal;\n    topNormal.x = m12 - m14;\n    topNormal.y = m22 - m24;\n    topNormal.z = m32 - m34;\n    this.top.distance = m42 - m44;\n    this.top.normalize();\n\n    // bottom\n    const bottomNormal = this.bottom.normal;\n    bottomNormal.x = -m14 - m12;\n    bottomNormal.y = -m24 - m22;\n    bottomNormal.z = -m34 - m32;\n    this.bottom.distance = -m44 - m42;\n    this.bottom.normalize();\n  }\n\n  /**\n   * Get whether or not a specified bounding box intersects with this frustum (Contains or Intersects).\n   * @param box - The box for testing\n   * @returns True if bounding box intersects with this frustum, false otherwise\n   */\n  public intersectsBox(box: BoundingBox): boolean {\n    return CollisionUtil.intersectsFrustumAndBox(this, box);\n  }\n\n  /**\n   * Get whether or not a specified bounding sphere intersects with this frustum (Contains or Intersects).\n   * @param sphere - The sphere for testing\n   * @returns True if bounding sphere intersects with this frustum, false otherwise\n   */\n  public intersectsSphere(sphere: BoundingSphere): boolean {\n    return CollisionUtil.frustumContainsSphere(this, sphere) !== ContainmentType.Disjoint;\n  }\n}\n", "import { IClone } from \"@oasis-engine/design\";\nimport { MathUtil } from \"./MathUtil\";\nimport { Matrix } from \"./Matrix\";\nimport { Quaternion } from \"./Quaternion\";\nimport { Vector2 } from \"./Vector2\";\n\n/**\n * Represents a 3x3 mathematical matrix.\n */\nexport class Matrix3x3 implements IClone {\n  /**\n   * Determines the sum of two matrices.\n   * @param left - The first matrix to add\n   * @param right - The second matrix to add\n   * @param out - The sum of two matrices\n   */\n  static add(left: Matrix3x3, right: Matrix3x3, out: Matrix3x3): void {\n    const le = left.elements;\n    const re = right.elements;\n    const oe = out.elements;\n\n    oe[0] = le[0] + re[0];\n    oe[1] = le[1] + re[1];\n    oe[2] = le[2] + re[2];\n\n    oe[3] = le[3] + re[3];\n    oe[4] = le[4] + re[4];\n    oe[5] = le[5] + re[5];\n\n    oe[6] = le[6] + re[6];\n    oe[7] = le[7] + re[7];\n    oe[8] = le[8] + re[8];\n  }\n\n  /**\n   * Determines the difference between two matrices.\n   * @param left - The first matrix to subtract\n   * @param right - The second matrix to subtract\n   * @param out - The difference between two matrices\n   */\n  static subtract(left: Matrix3x3, right: Matrix3x3, out: Matrix3x3): void {\n    const le = left.elements;\n    const re = right.elements;\n    const oe = out.elements;\n\n    oe[0] = le[0] - re[0];\n    oe[1] = le[1] - re[1];\n    oe[2] = le[2] - re[2];\n\n    oe[3] = le[3] - re[3];\n    oe[4] = le[4] - re[4];\n    oe[5] = le[5] - re[5];\n\n    oe[6] = le[6] - re[6];\n    oe[7] = le[7] - re[7];\n    oe[8] = le[8] - re[8];\n  }\n\n  /**\n   * Determines the product of two matrices.\n   * @param left - The first matrix to multiply\n   * @param right - The second matrix to multiply\n   * @param out - The product of two matrices\n   */\n  static multiply(left: Matrix3x3, right: Matrix3x3, out: Matrix3x3): void {\n    const le = left.elements;\n    const re = right.elements;\n    const oe = out.elements;\n\n    const l11 = le[0],\n      l12 = le[1],\n      l13 = le[2];\n    const l21 = le[3],\n      l22 = le[4],\n      l23 = le[5];\n    const l31 = le[6],\n      l32 = le[7],\n      l33 = le[8];\n\n    const r11 = re[0],\n      r12 = re[1],\n      r13 = re[2];\n    const r21 = re[3],\n      r22 = re[4],\n      r23 = re[5];\n    const r31 = re[6],\n      r32 = re[7],\n      r33 = re[8];\n\n    oe[0] = l11 * r11 + l21 * r12 + l31 * r13;\n    oe[1] = l12 * r11 + l22 * r12 + l32 * r13;\n    oe[2] = l13 * r11 + l23 * r12 + l33 * r13;\n\n    oe[3] = l11 * r21 + l21 * r22 + l31 * r23;\n    oe[4] = l12 * r21 + l22 * r22 + l32 * r23;\n    oe[5] = l13 * r21 + l23 * r22 + l33 * r23;\n\n    oe[6] = l11 * r31 + l21 * r32 + l31 * r33;\n    oe[7] = l12 * r31 + l22 * r32 + l32 * r33;\n    oe[8] = l13 * r31 + l23 * r32 + l33 * r33;\n  }\n\n  /**\n   * Determines whether the specified matrices are equals.\n   * @param left - The first matrix to compare\n   * @param right - The second matrix to compare\n   * @returns True if the specified matrices are equals, false otherwise\n   */\n  static equals(left: Matrix3x3, right: Matrix3x3): boolean {\n    const le = left.elements;\n    const re = right.elements;\n\n    return (\n      MathUtil.equals(le[0], re[0]) &&\n      MathUtil.equals(le[1], re[1]) &&\n      MathUtil.equals(le[2], re[2]) &&\n      MathUtil.equals(le[3], re[3]) &&\n      MathUtil.equals(le[4], re[4]) &&\n      MathUtil.equals(le[5], re[5]) &&\n      MathUtil.equals(le[6], re[6]) &&\n      MathUtil.equals(le[7], re[7]) &&\n      MathUtil.equals(le[8], re[8])\n    );\n  }\n\n  /**\n   * Performs a linear interpolation between two matrices.\n   * @param start - The first matrix\n   * @param end - The second matrix\n   * @param t - The blend amount where 0 returns start and 1 end\n   * @param out - The result of linear blending between two matrices\n   */\n  static lerp(start: Matrix3x3, end: Matrix3x3, t: number, out: Matrix3x3): void {\n    const se = start.elements;\n    const ee = end.elements;\n    const oe = out.elements;\n    const inv = 1.0 - t;\n\n    oe[0] = se[0] * inv + ee[0] * t;\n    oe[1] = se[1] * inv + ee[1] * t;\n    oe[2] = se[2] * inv + ee[2] * t;\n\n    oe[3] = se[3] * inv + ee[3] * t;\n    oe[4] = se[4] * inv + ee[4] * t;\n    oe[5] = se[5] * inv + ee[5] * t;\n\n    oe[6] = se[6] * inv + ee[6] * t;\n    oe[7] = se[7] * inv + ee[7] * t;\n    oe[8] = se[8] * inv + ee[8] * t;\n  }\n\n  /**\n   * Calculate a rotation matrix from a quaternion.\n   * @param quaternion - The quaternion used to calculate the matrix\n   * @param out - The calculated rotation matrix\n   */\n  static rotationQuaternion(quaternion: Quaternion, out: Matrix3x3): void {\n    const oe = out.elements;\n    const { x, y, z, w } = quaternion;\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n    const xx = x * x2;\n    const yx = y * x2;\n    const yy = y * y2;\n    const zx = z * x2;\n    const zy = z * y2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n\n    oe[0] = 1 - yy - zz;\n    oe[3] = yx - wz;\n    oe[6] = zx + wy;\n\n    oe[1] = yx + wz;\n    oe[4] = 1 - xx - zz;\n    oe[7] = zy - wx;\n\n    oe[2] = zx - wy;\n    oe[5] = zy + wx;\n    oe[8] = 1 - xx - yy;\n  }\n\n  /**\n   * Calculate a matrix from scale vector.\n   * @param s - The scale vector\n   * @param out - The calculated matrix\n   */\n  static scaling(s: Vector2, out: Matrix3x3): void {\n    const oe = out.elements;\n\n    oe[0] = s.x;\n    oe[1] = 0;\n    oe[2] = 0;\n\n    oe[3] = 0;\n    oe[4] = s.y;\n    oe[5] = 0;\n\n    oe[6] = 0;\n    oe[7] = 0;\n    oe[8] = 1;\n  }\n\n  /**\n   * Calculate a matrix from translation vector.\n   * @param translation - The translation vector\n   * @param out - The calculated matrix\n   */\n  static translation(translation: Vector2, out: Matrix3x3): void {\n    const oe = out.elements;\n\n    oe[0] = 1;\n    oe[1] = 0;\n    oe[2] = 0;\n\n    oe[3] = 0;\n    oe[4] = 1;\n    oe[5] = 0;\n\n    oe[6] = translation.x;\n    oe[7] = translation.y;\n    oe[8] = 1;\n  }\n\n  /**\n   * Calculate the inverse of the specified matrix.\n   * @param a - The matrix whose inverse is to be calculated\n   * @param out - The inverse of the specified matrix\n   */\n  static invert(a: Matrix3x3, out: Matrix3x3): void {\n    const ae = a.elements;\n    const oe = out.elements;\n\n    const a11 = ae[0],\n      a12 = ae[1],\n      a13 = ae[2];\n    const a21 = ae[3],\n      a22 = ae[4],\n      a23 = ae[5];\n    const a31 = ae[6],\n      a32 = ae[7],\n      a33 = ae[8];\n\n    const b12 = a33 * a22 - a23 * a32;\n    const b22 = -a33 * a21 + a23 * a31;\n    const b32 = a32 * a21 - a22 * a31;\n\n    let det = a11 * b12 + a12 * b22 + a13 * b32;\n    if (!det) {\n      return;\n    }\n    det = 1.0 / det;\n\n    oe[0] = b12 * det;\n    oe[1] = (-a33 * a12 + a13 * a32) * det;\n    oe[2] = (a23 * a12 - a13 * a22) * det;\n\n    oe[3] = b22 * det;\n    oe[4] = (a33 * a11 - a13 * a31) * det;\n    oe[5] = (-a23 * a11 + a13 * a21) * det;\n\n    oe[6] = b32 * det;\n    oe[7] = (-a32 * a11 + a12 * a31) * det;\n    oe[8] = (a22 * a11 - a12 * a21) * det;\n  }\n\n  /**\n   * Calculate a 3x3 normal matrix from a 4x4 matrix.\n   * @remarks The calculation process is the transpose matrix of the inverse matrix.\n   * @param mat4 - The 4x4 matrix\n   * @param out - THe 3x3 normal matrix\n   */\n  static normalMatrix(mat4: Matrix, out: Matrix3x3): void {\n    const ae = mat4.elements;\n    const oe = out.elements;\n\n    const a11 = ae[0],\n      a12 = ae[1],\n      a13 = ae[2],\n      a14 = ae[3];\n    const a21 = ae[4],\n      a22 = ae[5],\n      a23 = ae[6],\n      a24 = ae[7];\n    const a31 = ae[8],\n      a32 = ae[9],\n      a33 = ae[10],\n      a34 = ae[11];\n    const a41 = ae[12],\n      a42 = ae[13],\n      a43 = ae[14],\n      a44 = ae[15];\n\n    const b00 = a11 * a22 - a12 * a21;\n    const b01 = a11 * a23 - a13 * a21;\n    const b02 = a11 * a24 - a14 * a21;\n    const b03 = a12 * a23 - a13 * a22;\n    const b04 = a12 * a24 - a14 * a22;\n    const b05 = a13 * a24 - a14 * a23;\n    const b06 = a31 * a42 - a32 * a41;\n    const b07 = a31 * a43 - a33 * a41;\n    const b08 = a31 * a44 - a34 * a41;\n    const b09 = a32 * a43 - a33 * a42;\n    const b10 = a32 * a44 - a34 * a42;\n    const b11 = a33 * a44 - a34 * a43;\n\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    if (!det) {\n      return null;\n    }\n    det = 1.0 / det;\n\n    oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;\n    oe[1] = (a23 * b08 - a21 * b11 - a24 * b07) * det;\n    oe[2] = (a21 * b10 - a22 * b08 + a24 * b06) * det;\n\n    oe[3] = (a13 * b10 - a12 * b11 - a14 * b09) * det;\n    oe[4] = (a11 * b11 - a13 * b08 + a14 * b07) * det;\n    oe[5] = (a12 * b08 - a11 * b10 - a14 * b06) * det;\n\n    oe[6] = (a42 * b05 - a43 * b04 + a44 * b03) * det;\n    oe[7] = (a43 * b02 - a41 * b05 - a44 * b01) * det;\n    oe[8] = (a41 * b04 - a42 * b02 + a44 * b00) * det;\n  }\n\n  /**\n   * The specified matrix rotates around an angle.\n   * @param a - The specified matrix\n   * @param r - The rotation angle in radians\n   * @param out - The rotated matrix\n   */\n  static rotate(a: Matrix3x3, r: number, out: Matrix3x3): void {\n    const ae = a.elements;\n    const oe = out.elements;\n    const s = Math.sin(r);\n    const c = Math.cos(r);\n\n    const a11 = ae[0],\n      a12 = ae[1],\n      a13 = ae[2];\n    const a21 = ae[3],\n      a22 = ae[4],\n      a23 = ae[5];\n    const a31 = ae[6],\n      a32 = ae[7],\n      a33 = ae[8];\n\n    oe[0] = c * a11 + s * a21;\n    oe[1] = c * a12 + s * a22;\n    oe[2] = c * a13 + s * a23;\n\n    oe[3] = c * a21 - s * a11;\n    oe[4] = c * a22 - s * a12;\n    oe[5] = c * a23 - s * a13;\n\n    oe[6] = a31;\n    oe[7] = a32;\n    oe[8] = a33;\n  }\n\n  /**\n   * Scale a matrix by a given vector.\n   * @param m - The matrix\n   * @param s - The given vector\n   * @param out - The scaled matrix\n   */\n  static scale(m: Matrix3x3, s: Vector2, out: Matrix3x3): void {\n    const { x, y } = s;\n    const ae = m.elements;\n    const oe = out.elements;\n\n    oe[0] = x * ae[0];\n    oe[1] = x * ae[1];\n    oe[2] = x * ae[2];\n\n    oe[3] = y * ae[3];\n    oe[4] = y * ae[4];\n    oe[5] = y * ae[5];\n\n    oe[6] = ae[6];\n    oe[7] = ae[7];\n    oe[8] = ae[8];\n  }\n\n  /**\n   * Translate a matrix by a given vector.\n   * @param m - The matrix\n   * @param translation - The given vector\n   * @param out - The translated matrix\n   */\n  static translate(m: Matrix3x3, translation: Vector2, out: Matrix3x3): void {\n    const { x, y } = translation;\n    const ae = m.elements;\n    const oe = out.elements;\n\n    const a11 = ae[0],\n      a12 = ae[1],\n      a13 = ae[2];\n    const a21 = ae[3],\n      a22 = ae[4],\n      a23 = ae[5];\n    const a31 = ae[6],\n      a32 = ae[7],\n      a33 = ae[8];\n\n    oe[0] = a11;\n    oe[1] = a12;\n    oe[2] = a13;\n\n    oe[3] = a21;\n    oe[4] = a22;\n    oe[5] = a23;\n\n    oe[6] = x * a11 + y * a21 + a31;\n    oe[7] = x * a12 + y * a22 + a32;\n    oe[8] = x * a13 + y * a23 + a33;\n  }\n\n  /**\n   * Calculate the transpose of the specified matrix.\n   * @param a - The specified matrix\n   * @param out - The transpose of the specified matrix\n   */\n  static transpose(a: Matrix3x3, out: Matrix3x3): void {\n    const ae = a.elements;\n    const oe = out.elements;\n\n    if (out === a) {\n      const a12 = ae[1];\n      const a13 = ae[2];\n      const a23 = ae[5];\n      oe[1] = ae[3];\n      oe[2] = ae[6];\n      oe[3] = a12;\n      oe[5] = ae[7];\n      oe[6] = a13;\n      oe[7] = a23;\n    } else {\n      oe[0] = ae[0];\n      oe[1] = ae[3];\n      oe[2] = ae[6];\n\n      oe[3] = ae[1];\n      oe[4] = ae[4];\n      oe[5] = ae[7];\n\n      oe[6] = ae[2];\n      oe[7] = ae[5];\n      oe[8] = ae[8];\n    }\n  }\n\n  /**\n   * An array containing the elements of the matrix (column matrix).\n   * @remarks\n   * elements[0] first column and first row value m11\n   * elements[1] first column and second row value m12\n   * elements[2] first column and third row value m13\n   * elements[3] second column and first row value m21\n   * and so on\n   */\n  elements: Float32Array = new Float32Array(9);\n\n  /**\n   * Constructor of 3*3 matrix.\n   * @param m11 - Default 1 column 1, row 1\n   * @param m12 - Default 0 column 1, row 2\n   * @param m13 - Default 0 column 1, row 3\n   * @param m21 - Default 0 column 2, row 1\n   * @param m22 - Default 1 column 2, row 2\n   * @param m23 - Default 0 column 2, row 3\n   * @param m31 - Default 0 column 3, row 1\n   * @param m32 - Default 0 column 3, row 2\n   * @param m33 - Default 1 column 3, row 3\n   */\n  constructor(\n    m11: number = 1,\n    m12: number = 0,\n    m13: number = 0,\n    m21: number = 0,\n    m22: number = 1,\n    m23: number = 0,\n    m31: number = 0,\n    m32: number = 0,\n    m33: number = 1\n  ) {\n    const e: Float32Array = this.elements;\n\n    e[0] = m11;\n    e[1] = m12;\n    e[2] = m13;\n\n    e[3] = m21;\n    e[4] = m22;\n    e[5] = m23;\n\n    e[6] = m31;\n    e[7] = m32;\n    e[8] = m33;\n  }\n\n  /**\n   * Set the value of this matrix, and return this matrix.\n   * @param m11\n   * @param m12\n   * @param m13\n   * @param m21\n   * @param m22\n   * @param m23\n   * @param m31\n   * @param m32\n   * @param m33\n   * @returns This matrix\n   */\n  setValue(\n    m11: number,\n    m12: number,\n    m13: number,\n    m21: number,\n    m22: number,\n    m23: number,\n    m31: number,\n    m32: number,\n    m33: number\n  ): Matrix3x3 {\n    const e: Float32Array = this.elements;\n\n    e[0] = m11;\n    e[1] = m12;\n    e[2] = m13;\n\n    e[3] = m21;\n    e[4] = m22;\n    e[5] = m23;\n\n    e[6] = m31;\n    e[7] = m32;\n    e[8] = m33;\n\n    return this;\n  }\n\n  /**\n   * Set the value of this matrix by an array.\n   * @param array - The array\n   * @param offset - The start offset of the array\n   * @returns This matrix\n   */\n  setValueByArray(array: ArrayLike<number>, offset: number = 0): Matrix3x3 {\n    const srce = this.elements;\n    for (let i = 0; i < 12; i++) {\n      srce[i] = array[i + offset];\n    }\n    return this;\n  }\n\n  /**\n   * Set the value of this 3x3 matrix by the specified 4x4 matrix.\n   * upper-left principle\n   * @param a - The specified 4x4 matrix\n   * @returns This 3x3 matrix\n   */\n  setValueByMatrix(a: Matrix): Matrix3x3 {\n    const ae = a.elements;\n    const e = this.elements;\n\n    e[0] = ae[0];\n    e[1] = ae[1];\n    e[2] = ae[2];\n\n    e[3] = ae[4];\n    e[4] = ae[5];\n    e[5] = ae[6];\n\n    e[6] = ae[8];\n    e[7] = ae[9];\n    e[8] = ae[10];\n\n    return this;\n  }\n\n  /**\n   * Clone the value of this matrix to an array.\n   * @param out - The array\n   * @param outOffset - The start offset of the array\n   */\n  toArray(out: number[] | Float32Array | Float64Array, outOffset: number = 0) {\n    const e = this.elements;\n\n    out[outOffset] = e[0];\n    out[outOffset + 1] = e[1];\n    out[outOffset + 2] = e[2];\n    out[outOffset + 3] = e[3];\n    out[outOffset + 4] = e[4];\n    out[outOffset + 5] = e[5];\n    out[outOffset + 6] = e[6];\n    out[outOffset + 7] = e[7];\n    out[outOffset + 8] = e[8];\n  }\n\n  /**\n   * Creates a clone of this matrix.\n   * @returns A clone of this matrix\n   */\n  clone(): Matrix3x3 {\n    const e = this.elements;\n    let ret = new Matrix3x3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);\n    return ret;\n  }\n\n  /**\n   * Clones this matrix to the specified matrix.\n   * @param out - The specified matrix\n   * @returns The specified matrix\n   */\n  cloneTo(out: Matrix3x3): Matrix3x3 {\n    const e = this.elements;\n    const oe = out.elements;\n\n    oe[0] = e[0];\n    oe[1] = e[1];\n    oe[2] = e[2];\n\n    oe[3] = e[3];\n    oe[4] = e[4];\n    oe[5] = e[5];\n\n    oe[6] = e[6];\n    oe[7] = e[7];\n    oe[8] = e[8];\n\n    return out;\n  }\n\n  /**\n   * Determines the sum of this matrix and the specified matrix.\n   * @param right - The specified matrix\n   * @returns This matrix that store the sum of the two matrices\n   */\n  add(right: Matrix3x3): Matrix3x3 {\n    Matrix3x3.add(this, right, this);\n    return this;\n  }\n\n  /**\n   * Determines the difference between this matrix and the specified matrix.\n   * @param right - The specified matrix\n   * @returns This matrix that store the difference between the two matrices\n   */\n  subtract(right: Matrix3x3): Matrix3x3 {\n    Matrix3x3.subtract(this, right, this);\n    return this;\n  }\n\n  /**\n   * Determines the product of this matrix and the specified matrix.\n   * @param right - The specified matrix\n   * @returns This matrix that store the product of the two matrices\n   */\n  multiply(right: Matrix3x3): Matrix3x3 {\n    Matrix3x3.multiply(this, right, this);\n    return this;\n  }\n\n  /**\n   * Calculate a determinant of this matrix.\n   * @returns The determinant of this matrix\n   */\n  determinant(): number {\n    const e = this.elements;\n\n    const a11 = e[0],\n      a12 = e[1],\n      a13 = e[2];\n    const a21 = e[3],\n      a22 = e[4],\n      a23 = e[5];\n    const a31 = e[6],\n      a32 = e[7],\n      a33 = e[8];\n\n    const b12 = a33 * a22 - a23 * a32;\n    const b22 = -a33 * a21 + a23 * a31;\n    const b32 = a32 * a21 - a22 * a31;\n\n    return a11 * b12 + a12 * b22 + a13 * b32;\n  }\n\n  /**\n   * Identity this matrix.\n   * @returns This matrix after identity\n   */\n  identity(): Matrix3x3 {\n    const e = this.elements;\n\n    e[0] = 1;\n    e[1] = 0;\n    e[2] = 0;\n\n    e[3] = 0;\n    e[4] = 1;\n    e[5] = 0;\n\n    e[6] = 0;\n    e[7] = 0;\n    e[8] = 1;\n\n    return this;\n  }\n\n  /**\n   * Invert the matrix.\n   * @returns The matrix after invert\n   */\n  invert(): Matrix3x3 {\n    Matrix3x3.invert(this, this);\n    return this;\n  }\n\n  /**\n   * This matrix rotates around an angle.\n   * @param r - The rotation angle in radians\n   * @returns This matrix after rotate\n   */\n  rotate(r: number): Matrix3x3 {\n    Matrix3x3.rotate(this, r, this);\n    return this;\n  }\n\n  /**\n   * Scale this matrix by a given vector.\n   * @param s - The given vector\n   * @returns This matrix after scale\n   */\n  scale(s: Vector2): Matrix3x3 {\n    Matrix3x3.scale(this, s, this);\n    return this;\n  }\n\n  /**\n   * Translate this matrix by a given vector.\n   * @param translation - The given vector\n   * @returns This matrix after translate\n   */\n  translate(translation: Vector2): Matrix3x3 {\n    Matrix3x3.translate(this, translation, this);\n    return this;\n  }\n\n  /**\n   * Calculate the transpose of this matrix.\n   * @returns This matrix after transpose\n   */\n  transpose(): Matrix3x3 {\n    Matrix3x3.transpose(this, this);\n    return this;\n  }\n}\n", "import { IClone } from \"@oasis-engine/design\";\nimport { MathUtil } from \"./MathUtil\";\nimport { Matrix3x3 } from \"./Matrix3x3\";\nimport { Vector3 } from \"./Vector3\";\n\n/**\n * Represents a four dimensional mathematical quaternion.\n */\nexport class Quaternion implements IClone {\n  /** @internal */\n  static readonly _tempVector3 = new Vector3();\n  /** @internal */\n  static readonly _tempQuat1 = new Quaternion();\n\n  /**\n   * Determines the sum of two quaternions.\n   * @param left - The first quaternion to add\n   * @param right - The second quaternion to add\n   * @param out - The sum of two quaternions\n   */\n  static add(left: Quaternion, right: Quaternion, out: Quaternion): void {\n    out.x = left.x + right.x;\n    out.y = left.y + right.y;\n    out.z = left.z + right.z;\n    out.w = left.w + right.w;\n  }\n\n  /**\n   * Determines the product of two quaternions.\n   * @param left - The first quaternion to multiply\n   * @param right - The second quaternion to multiply\n   * @param out - The product of two quaternions\n   */\n  static multiply(left: Quaternion, right: Quaternion, out: Quaternion): void {\n    const ax = left.x,\n      ay = left.y,\n      az = left.z,\n      aw = left.w;\n    const bx = right.x,\n      by = right.y,\n      bz = right.z,\n      bw = right.w;\n\n    out.x = ax * bw + aw * bx + ay * bz - az * by;\n    out.y = ay * bw + aw * by + az * bx - ax * bz;\n    out.z = az * bw + aw * bz + ax * by - ay * bx;\n    out.w = aw * bw - ax * bx - ay * by - az * bz;\n  }\n\n  /**\n   * Calculate quaternion that contains conjugated version of the specified quaternion.\n   * @param a - The specified quaternion\n   * @param out - The conjugate version of the specified quaternion\n   */\n  static conjugate(a: Quaternion, out: Quaternion): void {\n    out.x = -a.x;\n    out.y = -a.y;\n    out.z = -a.z;\n    out.w = a.w;\n  }\n\n  /**\n   * Determines the dot product of two quaternions.\n   * @param left - The first quaternion to dot\n   * @param right - The second quaternion to dot\n   * @returns The dot product of two quaternions\n   */\n  static dot(left: Quaternion, right: Quaternion): number {\n    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n  }\n\n  /**\n   * Determines whether the specified quaternions are equals.\n   * @param left - The first quaternion to compare\n   * @param right - The second quaternion to compare\n   * @returns True if the specified quaternions are equals, false otherwise\n   */\n  static equals(left: Quaternion, right: Quaternion): boolean {\n    return (\n      MathUtil.equals(left.x, right.x) &&\n      MathUtil.equals(left.y, right.y) &&\n      MathUtil.equals(left.z, right.z) &&\n      MathUtil.equals(left.w, right.w)\n    );\n  }\n\n  /**\n   * Calculate a quaternion rotates around an arbitrary axis.\n   * @param axis - The axis\n   * @param rad - The rotation angle in radians\n   * @param out - The quaternion after rotate\n   */\n  static rotationAxisAngle(axis: Vector3, rad: number, out: Quaternion): void {\n    const normalAxis = Quaternion._tempVector3;\n    Vector3.normalize(axis, normalAxis);\n    rad *= 0.5;\n    const s = Math.sin(rad);\n    out.x = normalAxis.x * s;\n    out.y = normalAxis.y * s;\n    out.z = normalAxis.z * s;\n    out.w = Math.cos(rad);\n  }\n\n  /**\n   * Calculate a quaternion rotates around x, y, z axis (pitch/yaw/roll).\n   * @param x - The radian of rotation around X (pitch)\n   * @param y - The radian of rotation around Y (yaw)\n   * @param z - The radian of rotation around Z (roll)\n   * @param out - The calculated quaternion\n   */\n  static rotationEuler(x: number, y: number, z: number, out: Quaternion): void {\n    Quaternion.rotationYawPitchRoll(y, x, z, out);\n  }\n\n  /**\n   * Calculate a quaternion from the specified yaw, pitch and roll angles.\n   * @param yaw - Yaw around the y axis in radians\n   * @param pitch - Pitch around the x axis in radians\n   * @param roll - Roll around the z axis in radians\n   * @param out - The calculated quaternion\n   */\n  static rotationYawPitchRoll(yaw: number, pitch: number, roll: number, out: Quaternion): void {\n    const halfRoll = roll * 0.5;\n    const halfPitch = pitch * 0.5;\n    const halfYaw = yaw * 0.5;\n\n    const sinRoll = Math.sin(halfRoll);\n    const cosRoll = Math.cos(halfRoll);\n    const sinPitch = Math.sin(halfPitch);\n    const cosPitch = Math.cos(halfPitch);\n    const sinYaw = Math.sin(halfYaw);\n    const cosYaw = Math.cos(halfYaw);\n\n    const cosYawPitch = cosYaw * cosPitch;\n    const sinYawPitch = sinYaw * sinPitch;\n\n    out.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;\n    out.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;\n    out.z = cosYawPitch * sinRoll - sinYawPitch * cosRoll;\n    out.w = cosYawPitch * cosRoll + sinYawPitch * sinRoll;\n  }\n\n  /**\n   * Calculate a quaternion from the specified 3x3 matrix.\n   * @param m - The specified 3x3 matrix\n   * @param out - The calculated quaternion\n   */\n  static rotationMatrix3x3(m: Matrix3x3, out: Quaternion): void {\n    const me = m.elements;\n    const m11 = me[0],\n      m12 = me[1],\n      m13 = me[2];\n    const m21 = me[3],\n      m22 = me[4],\n      m23 = me[5];\n    const m31 = me[6],\n      m32 = me[7],\n      m33 = me[8];\n    const scale = m11 + m22 + m33;\n    let sqrt, half;\n\n    if (scale > 0) {\n      sqrt = Math.sqrt(scale + 1.0);\n      out.w = sqrt * 0.5;\n      sqrt = 0.5 / sqrt;\n\n      out.x = (m23 - m32) * sqrt;\n      out.y = (m31 - m13) * sqrt;\n      out.z = (m12 - m21) * sqrt;\n    } else if (m11 >= m22 && m11 >= m33) {\n      sqrt = Math.sqrt(1.0 + m11 - m22 - m33);\n      half = 0.5 / sqrt;\n\n      out.x = 0.5 * sqrt;\n      out.y = (m12 + m21) * half;\n      out.z = (m13 + m31) * half;\n      out.w = (m23 - m32) * half;\n    } else if (m22 > m33) {\n      sqrt = Math.sqrt(1.0 + m22 - m11 - m33);\n      half = 0.5 / sqrt;\n\n      out.x = (m21 + m12) * half;\n      out.y = 0.5 * sqrt;\n      out.z = (m32 + m23) * half;\n      out.w = (m31 - m13) * half;\n    } else {\n      sqrt = Math.sqrt(1.0 + m33 - m11 - m22);\n      half = 0.5 / sqrt;\n\n      out.x = (m13 + m31) * half;\n      out.y = (m23 + m32) * half;\n      out.z = 0.5 * sqrt;\n      out.w = (m12 - m21) * half;\n    }\n  }\n\n  /**\n   * Calculate the inverse of the specified quaternion.\n   * @param a - The quaternion whose inverse is to be calculated\n   * @param out - The inverse of the specified quaternion\n   */\n  static invert(a: Quaternion, out: Quaternion): void {\n    const { x, y, z, w } = a;\n    const dot = x * x + y * y + z * z + w * w;\n    if (dot > MathUtil.zeroTolerance) {\n      const invDot = 1.0 / dot;\n      out.x = -x * invDot;\n      out.y = -y * invDot;\n      out.z = -z * invDot;\n      out.w = w * invDot;\n    }\n  }\n\n  /**\n   * Performs a linear blend between two quaternions.\n   * @param start - The first quaternion\n   * @param end - The second quaternion\n   * @param t - The blend amount where 0 returns start and 1 end\n   * @param out - The result of linear blending between two quaternions\n   */\n  static lerp(start: Quaternion, end: Quaternion, t: number, out: Quaternion): void {\n    const inv = 1.0 - t;\n    if (Quaternion.dot(start, end) >= 0) {\n      out.x = start.x * inv + end.x * t;\n      out.y = start.y * inv + end.y * t;\n      out.z = start.z * inv + end.z * t;\n      out.w = start.w * inv + end.w * t;\n    } else {\n      out.x = start.x * inv - end.x * t;\n      out.y = start.y * inv - end.y * t;\n      out.z = start.z * inv - end.z * t;\n      out.w = start.w * inv - end.w * t;\n    }\n\n    out.normalize();\n  }\n\n  /**\n   * Performs a spherical linear blend between two quaternions.\n   * @param start - The first quaternion\n   * @param end - The second quaternion\n   * @param t - The blend amount where 0 returns start and 1 end\n   * @param out - The result of spherical linear blending between two quaternions\n   */\n  static slerp(start: Quaternion, end: Quaternion, t: number, out: Quaternion): void {\n    const ax = start.x;\n    const ay = start.y;\n    const az = start.z;\n    const aw = start.w;\n    let bx = end.x;\n    let by = end.y;\n    let bz = end.z;\n    let bw = end.w;\n\n    let scale0, scale1;\n    // calc cosine\n    let cosom = ax * bx + ay * by + az * bz + aw * bw;\n    // adjust signs (if necessary)\n    if (cosom < 0.0) {\n      cosom = -cosom;\n      bx = -bx;\n      by = -by;\n      bz = -bz;\n      bw = -bw;\n    }\n    // calculate coefficients\n    if (1.0 - cosom > MathUtil.zeroTolerance) {\n      // standard case (slerp)\n      const omega = Math.acos(cosom);\n      const sinom = Math.sin(omega);\n      scale0 = Math.sin((1.0 - t) * omega) / sinom;\n      scale1 = Math.sin(t * omega) / sinom;\n    } else {\n      // \"from\" and \"to\" quaternions are very close\n      //  ... so we can do a linear interpolation\n      scale0 = 1.0 - t;\n      scale1 = t;\n    }\n    // calculate final values\n    out.x = scale0 * ax + scale1 * bx;\n    out.y = scale0 * ay + scale1 * by;\n    out.z = scale0 * az + scale1 * bz;\n    out.w = scale0 * aw + scale1 * bw;\n  }\n\n  /**\n   * Scales the specified quaternion magnitude to unit length.\n   * @param a - The specified quaternion\n   * @param out - The normalized quaternion\n   */\n  static normalize(a: Quaternion, out: Quaternion): void {\n    const { x, y, z, w } = a;\n    let len: number = Math.sqrt(x * x + y * y + z * z + w * w);\n    if (len > MathUtil.zeroTolerance) {\n      len = 1 / len;\n      out.x = x * len;\n      out.y = y * len;\n      out.z = z * len;\n      out.w = w * len;\n    }\n  }\n\n  /**\n   * Calculate a quaternion rotate around X axis.\n   * @param rad - The rotation angle in radians\n   * @param out - The calculated quaternion\n   */\n  static rotationX(rad: number, out: Quaternion): void {\n    rad *= 0.5;\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n\n    out.x = s;\n    out.y = 0;\n    out.z = 0;\n    out.w = c;\n  }\n\n  /**\n   * Calculate a quaternion rotate around Y axis.\n   * @param rad - The rotation angle in radians\n   * @param out - The calculated quaternion\n   */\n  static rotationY(rad: number, out: Quaternion): void {\n    rad *= 0.5;\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n\n    out.x = 0;\n    out.y = s;\n    out.z = 0;\n    out.w = c;\n  }\n\n  /**\n   * Calculate a quaternion rotate around Z axis.\n   * @param rad - The rotation angle in radians\n   * @param out - The calculated quaternion\n   */\n  static rotationZ(rad: number, out: Quaternion): void {\n    rad *= 0.5;\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n\n    out.x = 0;\n    out.y = 0;\n    out.z = s;\n    out.w = c;\n  }\n\n  /**\n   * Calculate a quaternion that the specified quaternion rotate around X axis.\n   * @param quaternion - The specified quaternion\n   * @param rad - The rotation angle in radians\n   * @param out - The calculated quaternion\n   */\n  static rotateX(quaternion: Quaternion, rad: number, out: Quaternion): void {\n    const { x, y, z, w } = quaternion;\n    rad *= 0.5;\n    const bx = Math.sin(rad);\n    const bw = Math.cos(rad);\n\n    out.x = x * bw + w * bx;\n    out.y = y * bw + z * bx;\n    out.z = z * bw - y * bx;\n    out.w = w * bw - x * bx;\n  }\n\n  /**\n   * Calculate a quaternion that the specified quaternion rotate around Y axis.\n   * @param quaternion - The specified quaternion\n   * @param rad - The rotation angle in radians\n   * @param out - The calculated quaternion\n   */\n  static rotateY(quaternion: Quaternion, rad: number, out: Quaternion): void {\n    const { x, y, z, w } = quaternion;\n    rad *= 0.5;\n    const by = Math.sin(rad);\n    const bw = Math.cos(rad);\n\n    out.x = x * bw - z * by;\n    out.y = y * bw + w * by;\n    out.z = z * bw + x * by;\n    out.w = w * bw - y * by;\n  }\n\n  /**\n   * Calculate a quaternion that the specified quaternion rotate around Z axis.\n   * @param quaternion - The specified quaternion\n   * @param rad - The rotation angle in radians\n   * @param out - The calculated quaternion\n   */\n  static rotateZ(quaternion: Quaternion, rad: number, out: Quaternion): void {\n    const { x, y, z, w } = quaternion;\n    rad *= 0.5;\n    const bz = Math.sin(rad);\n    const bw = Math.cos(rad);\n\n    out.x = x * bw + y * bz;\n    out.y = y * bw - x * bz;\n    out.z = z * bw + w * bz;\n    out.w = w * bw - z * bz;\n  }\n\n  /**\n   * Scale a quaternion by a given number.\n   * @param a - The quaternion\n   * @param s - The given number\n   * @param out - The scaled quaternion\n   */\n  static scale(a: Quaternion, s: number, out: Quaternion): void {\n    out.x = a.x * s;\n    out.y = a.y * s;\n    out.z = a.z * s;\n    out.w = a.w * s;\n  }\n\n  /** The x component of the quaternion. */\n  x: number;\n  /** The y component of the quaternion. */\n  y: number;\n  /** The z component of the quaternion. */\n  z: number;\n  /** The w component of the quaternion. */\n  w: number;\n\n  /**\n   * Constructor of Quaternion.\n   * @param x - The x component of the quaternion, default 0\n   * @param y - The y component of the quaternion, default 0\n   * @param z - The z component of the quaternion, default 0\n   * @param w - The w component of the quaternion, default 1\n   */\n  constructor(x: number = 0, y: number = 0, z: number = 0, w: number = 1) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n\n  /**\n   * Set the value of this quaternion, and return this quaternion.\n   * @param x - The x component of the quaternion\n   * @param y - The y component of the quaternion\n   * @param z - The z component of the quaternion\n   * @param w - The w component of the quaternion\n   * @returns This quaternion\n   */\n  setValue(x: number, y: number, z: number, w: number): Quaternion {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n\n    return this;\n  }\n\n  /**\n   * Set the value of this quaternion by an array.\n   * @param array - The array\n   * @param offset - The start offset of the array\n   * @returns This quaternion\n   */\n  setValueByArray(array: ArrayLike<number>, offset: number = 0): Quaternion {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    this.w = array[offset + 3];\n    return this;\n  }\n\n  /**\n   * Transforms this quaternion into its conjugated version.\n   * @returns This quaternion\n   */\n  conjugate(): Quaternion {\n    this.x *= -1;\n    this.y *= -1;\n    this.z *= -1;\n\n    return this;\n  }\n\n  /**\n   * Get the rotation axis and rotation angle of the quaternion (unit: radians).\n   * @param out - The axis as an output parameter\n   * @returns The rotation angle (unit: radians)\n   */\n  getAxisAngle(out: Vector3): number {\n    const { x, y, z } = this;\n    const length = x * x + y * y + z * z;\n\n    if (length < MathUtil.zeroTolerance) {\n      out.x = 1;\n      out.y = 0;\n      out.z = 0;\n\n      return 0;\n    } else {\n      const inv = 1.0 / length;\n      out.x = this.x * inv;\n      out.y = this.y * inv;\n      out.z = this.z * inv;\n\n      return Math.acos(this.w) * 2.0;\n    }\n  }\n\n  /**\n   * Identity this quaternion.\n   * @returns This quaternion after identity\n   */\n  identity(): Quaternion {\n    this.x = 0;\n    this.y = 0;\n    this.z = 0;\n    this.w = 1;\n    return this;\n  }\n\n  /**\n   * Calculate the length of this quaternion.\n   * @returns The length of this quaternion\n   */\n  length(): number {\n    const { x, y, z, w } = this;\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n  }\n\n  /**\n   * Calculates the squared length of this quaternion.\n   * @returns The squared length of this quaternion\n   */\n  lengthSquared(): number {\n    const { x, y, z, w } = this;\n    return x * x + y * y + z * z + w * w;\n  }\n\n  /**\n   * Converts this quaternion into a unit quaternion.\n   * @returns This quaternion\n   */\n  normalize(): Quaternion {\n    Quaternion.normalize(this, this);\n    return this;\n  }\n\n  /**\n   * Get the euler of this quaternion.\n   * @param out - The euler (in radians) as an output parameter\n   * @returns Euler x->pitch y->yaw z->roll\n   */\n  toEuler(out: Vector3): Vector3 {\n    this.toYawPitchRoll(out);\n    const t = out.x;\n    out.x = out.y;\n    out.y = t;\n    return out;\n  }\n\n  /**\n   * Get the euler of this quaternion.\n   * @param out - The euler (in radians) as an output parameter\n   * @returns Euler x->yaw y->pitch z->roll\n   */\n  toYawPitchRoll(out: Vector3): Vector3 {\n    const { x, y, z, w } = this;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const xy = x * y;\n    const zw = z * w;\n    const zx = z * x;\n    const yw = y * w;\n    const yz = y * z;\n    const xw = x * w;\n\n    out.y = Math.asin(2.0 * (xw - yz));\n    if (Math.cos(out.y) > MathUtil.zeroTolerance) {\n      out.z = Math.atan2(2.0 * (xy + zw), 1.0 - 2.0 * (zz + xx));\n      out.x = Math.atan2(2.0 * (zx + yw), 1.0 - 2.0 * (yy + xx));\n    } else {\n      out.z = Math.atan2(-2.0 * (xy - zw), 1.0 - 2.0 * (yy + zz));\n      out.x = 0.0;\n    }\n\n    return out;\n  }\n\n  /**\n   * Clone the value of this quaternion to an array.\n   * @param out - The array\n   * @param outOffset - The start offset of the array\n   */\n  toArray(out: number[] | Float32Array | Float64Array, outOffset: number = 0) {\n    out[outOffset] = this.x;\n    out[outOffset + 1] = this.y;\n    out[outOffset + 2] = this.z;\n    out[outOffset + 3] = this.w;\n  }\n\n  /**\n   * Creates a clone of this quaternion.\n   * @returns A clone of this quaternion\n   */\n  clone(): Quaternion {\n    return new Quaternion(this.x, this.y, this.z, this.w);\n  }\n\n  /**\n   * Clones this quaternion to the specified quaternion.\n   * @param out - The specified quaternion\n   * @returns The specified quaternion\n   */\n  cloneTo(out: Quaternion): Quaternion {\n    out.x = this.x;\n    out.y = this.y;\n    out.z = this.z;\n    out.w = this.w;\n    return out;\n  }\n\n  /**\n   * Calculate this quaternion rotate around X axis.\n   * @param rad - The rotation angle in radians\n   * @returns This quaternion\n   */\n  rotateX(rad: number): Quaternion {\n    Quaternion.rotateX(this, rad, this);\n    return this;\n  }\n\n  /**\n   * Calculate this quaternion rotate around Y axis.\n   * @param rad - The rotation angle in radians\n   * @returns This quaternion\n   */\n  rotateY(rad: number): Quaternion {\n    Quaternion.rotateY(this, rad, this);\n    return this;\n  }\n\n  /**\n   * Calculate this quaternion rotate around Z axis.\n   * @param rad - The rotation angle in radians\n   * @returns This quaternion\n   */\n  rotateZ(rad: number): Quaternion {\n    Quaternion.rotateZ(this, rad, this);\n    return this;\n  }\n\n  /**\n   * Calculate this quaternion rotates around an arbitrary axis.\n   * @param axis - The axis\n   * @param rad - The rotation angle in radians\n   * @returns This quaternion\n   */\n  rotationAxisAngle(axis: Vector3, rad: number): Quaternion {\n    Quaternion.rotationAxisAngle(axis, rad, this);\n    return this;\n  }\n\n  /**\n   * Determines the product of this quaternion and the specified quaternion.\n   * @param quat - The specified quaternion\n   * @returns The product of the two quaternions\n   */\n  multiply(quat: Quaternion): Quaternion {\n    Quaternion.multiply(this, quat, this);\n    return this;\n  }\n\n  /**\n   * Invert this quaternion.\n   * @returns This quaternion after invert\n   */\n  invert(): Quaternion {\n    Quaternion.invert(this, this);\n    return this;\n  }\n\n  /**\n   * Determines the dot product of this quaternion and the specified quaternion.\n   * @param quat - The specified quaternion\n   * @returns The dot product of two quaternions\n   */\n  dot(quat: Quaternion): number {\n    return Quaternion.dot(this, quat);\n  }\n\n  /**\n   * Performs a linear blend between this quaternion and the specified quaternion.\n   * @param quat - The specified quaternion\n   * @param t - The blend amount where 0 returns this and 1 quat\n   * @returns - The result of linear blending between two quaternions\n   */\n  lerp(quat: Quaternion, t: number): Quaternion {\n    Quaternion.lerp(this, quat, t, this);\n    return this;\n  }\n\n  /**\n   * Calculate this quaternion rotation around an arbitrary axis.\n   * @param axis - The axis\n   * @param rad - The rotation angle in radians\n   * @returns This quaternion\n   */\n  rotateAxisAngle(axis: Vector3, rad: number): Quaternion {\n    Quaternion._tempQuat1.rotationAxisAngle(axis, rad);\n    this.multiply(Quaternion._tempQuat1);\n    return this;\n  }\n}\n", "import { IClone } from \"@oasis-engine/design\";\nimport { MathUtil } from \"./MathUtil\";\nimport { Matrix3x3 } from \"./Matrix3x3\";\nimport { Quaternion } from \"./Quaternion\";\nimport { Vector3 } from \"./Vector3\";\n\n/**\n * Represents a 4x4 mathematical matrix.\n */\nexport class Matrix implements IClone {\n  private static readonly _tempVec30: Vector3 = new Vector3();\n  private static readonly _tempVec31: Vector3 = new Vector3();\n  private static readonly _tempVec32: Vector3 = new Vector3();\n  private static readonly _tempMat30: Matrix3x3 = new Matrix3x3();\n\n  /** @internal Identity matrix. */\n  static readonly _identity: Matrix = new Matrix(\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0\n  );\n\n  /**\n   * Determines the product of two matrices.\n   * @param left - The first matrix to multiply\n   * @param right - The second matrix to multiply\n   * @param out - The product of the two matrices\n   */\n  static multiply(left: Matrix, right: Matrix, out: Matrix): void {\n    const le = left.elements;\n    const re = right.elements;\n    const oe = out.elements;\n\n    const l11 = le[0],\n      l12 = le[1],\n      l13 = le[2],\n      l14 = le[3];\n    const l21 = le[4],\n      l22 = le[5],\n      l23 = le[6],\n      l24 = le[7];\n    const l31 = le[8],\n      l32 = le[9],\n      l33 = le[10],\n      l34 = le[11];\n    const l41 = le[12],\n      l42 = le[13],\n      l43 = le[14],\n      l44 = le[15];\n\n    const r11 = re[0],\n      r12 = re[1],\n      r13 = re[2],\n      r14 = re[3];\n    const r21 = re[4],\n      r22 = re[5],\n      r23 = re[6],\n      r24 = re[7];\n    const r31 = re[8],\n      r32 = re[9],\n      r33 = re[10],\n      r34 = re[11];\n    const r41 = re[12],\n      r42 = re[13],\n      r43 = re[14],\n      r44 = re[15];\n\n    oe[0] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;\n    oe[1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;\n    oe[2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;\n    oe[3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;\n\n    oe[4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;\n    oe[5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;\n    oe[6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;\n    oe[7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;\n\n    oe[8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;\n    oe[9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;\n    oe[10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;\n    oe[11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;\n\n    oe[12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;\n    oe[13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;\n    oe[14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;\n    oe[15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;\n  }\n\n  /**\n   * Determines whether the specified matrices are equals.\n   * @param left - The first matrix to compare\n   * @param right - The second matrix to compare\n   * @returns True if the specified matrices are equals, false otherwise\n   */\n  static equals(left: Matrix, right: Matrix): boolean {\n    const le = left.elements;\n    const re = right.elements;\n\n    return (\n      MathUtil.equals(le[0], re[0]) &&\n      MathUtil.equals(le[1], re[1]) &&\n      MathUtil.equals(le[2], re[2]) &&\n      MathUtil.equals(le[3], re[3]) &&\n      MathUtil.equals(le[4], re[4]) &&\n      MathUtil.equals(le[5], re[5]) &&\n      MathUtil.equals(le[6], re[6]) &&\n      MathUtil.equals(le[7], re[7]) &&\n      MathUtil.equals(le[8], re[8]) &&\n      MathUtil.equals(le[9], re[9]) &&\n      MathUtil.equals(le[10], re[10]) &&\n      MathUtil.equals(le[11], re[11]) &&\n      MathUtil.equals(le[12], re[12]) &&\n      MathUtil.equals(le[13], re[13]) &&\n      MathUtil.equals(le[14], re[14]) &&\n      MathUtil.equals(le[15], re[15])\n    );\n  }\n\n  /**\n   * Performs a linear interpolation between two matrices.\n   * @param start - The first matrix\n   * @param end - The second matrix\n   * @param t - The blend amount where 0 returns start and 1 end\n   * @param out - The result of linear blending between two matrices\n   */\n  static lerp(start: Matrix, end: Matrix, t: number, out: Matrix): void {\n    const se = start.elements;\n    const ee = end.elements;\n    const oe = out.elements;\n    const inv = 1.0 - t;\n\n    oe[0] = se[0] * inv + ee[0] * t;\n    oe[1] = se[1] * inv + ee[1] * t;\n    oe[2] = se[2] * inv + ee[2] * t;\n    oe[3] = se[3] * inv + ee[3] * t;\n\n    oe[4] = se[4] * inv + ee[4] * t;\n    oe[5] = se[5] * inv + ee[5] * t;\n    oe[6] = se[6] * inv + ee[6] * t;\n    oe[7] = se[7] * inv + ee[7] * t;\n\n    oe[8] = se[8] * inv + ee[8] * t;\n    oe[9] = se[9] * inv + ee[9] * t;\n    oe[10] = se[10] * inv + ee[10] * t;\n    oe[11] = se[11] * inv + ee[11] * t;\n\n    oe[12] = se[12] * inv + ee[12] * t;\n    oe[13] = se[13] * inv + ee[13] * t;\n    oe[14] = se[14] * inv + ee[14] * t;\n    oe[15] = se[15] * inv + ee[15] * t;\n  }\n\n  /**\n   * Calculate a rotation matrix from a quaternion.\n   * @param quaternion - The quaternion used to calculate the matrix\n   * @param out - The calculated rotation matrix\n   */\n  static rotationQuaternion(quaternion: Quaternion, out: Matrix): void {\n    const oe = out.elements;\n    const { x, y, z, w } = quaternion;\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n\n    let xx = x * x2;\n    let yx = y * x2;\n    let yy = y * y2;\n    let zx = z * x2;\n    let zy = z * y2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n\n    oe[0] = 1 - yy - zz;\n    oe[1] = yx + wz;\n    oe[2] = zx - wy;\n    oe[3] = 0;\n\n    oe[4] = yx - wz;\n    oe[5] = 1 - xx - zz;\n    oe[6] = zy + wx;\n    oe[7] = 0;\n\n    oe[8] = zx + wy;\n    oe[9] = zy - wx;\n    oe[10] = 1 - xx - yy;\n    oe[11] = 0;\n\n    oe[12] = 0;\n    oe[13] = 0;\n    oe[14] = 0;\n    oe[15] = 1;\n  }\n\n  /**\n   * Calculate a matrix rotates around an arbitrary axis.\n   * @param axis - The axis\n   * @param r - The rotation angle in radians\n   * @param out - The matrix after rotate\n   */\n  static rotationAxisAngle(axis: Vector3, r: number, out: Matrix): void {\n    const oe = out.elements;\n    let { x, y, z } = axis;\n    let len = Math.sqrt(x * x + y * y + z * z);\n    let s, c, t;\n\n    if (Math.abs(len) < MathUtil.zeroTolerance) {\n      return;\n    }\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    s = Math.sin(r);\n    c = Math.cos(r);\n    t = 1 - c;\n\n    // Perform rotation-specific matrix multiplication\n    oe[0] = x * x * t + c;\n    oe[1] = y * x * t + z * s;\n    oe[2] = z * x * t - y * s;\n    oe[3] = 0;\n\n    oe[4] = x * y * t - z * s;\n    oe[5] = y * y * t + c;\n    oe[6] = z * y * t + x * s;\n    oe[7] = 0;\n\n    oe[8] = x * z * t + y * s;\n    oe[9] = y * z * t - x * s;\n    oe[10] = z * z * t + c;\n    oe[11] = 0;\n\n    oe[12] = 0;\n    oe[13] = 0;\n    oe[14] = 0;\n    oe[15] = 1;\n  }\n\n  /**\n   * Calculate a matrix from a quaternion and a translation.\n   * @param quaternion - The quaternion used to calculate the matrix\n   * @param translation - The translation used to calculate the matrix\n   * @param out - The calculated matrix\n   */\n  static rotationTranslation(quaternion: Quaternion, translation: Vector3, out: Matrix): void {\n    Matrix.rotationQuaternion(quaternion, out);\n\n    const oe = out.elements;\n    oe[12] = translation.x;\n    oe[13] = translation.y;\n    oe[14] = translation.z;\n  }\n\n  /**\n   * Calculate an affine matrix.\n   * @param scale - The scale used to calculate matrix\n   * @param rotation - The rotation used to calculate matrix\n   * @param translation - The translation used to calculate matrix\n   * @param out - The calculated matrix\n   */\n  static affineTransformation(scale: Vector3, rotation: Quaternion, translation: Vector3, out: Matrix): void {\n    const oe = out.elements;\n    const { x, y, z, w } = rotation;\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n\n    let xx = x * x2;\n    let xy = x * y2;\n    let xz = x * z2;\n    let yy = y * y2;\n    let yz = y * z2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n    let sx = scale.x;\n    let sy = scale.y;\n    let sz = scale.z;\n\n    oe[0] = (1 - (yy + zz)) * sx;\n    oe[1] = (xy + wz) * sx;\n    oe[2] = (xz - wy) * sx;\n    oe[3] = 0;\n\n    oe[4] = (xy - wz) * sy;\n    oe[5] = (1 - (xx + zz)) * sy;\n    oe[6] = (yz + wx) * sy;\n    oe[7] = 0;\n\n    oe[8] = (xz + wy) * sz;\n    oe[9] = (yz - wx) * sz;\n    oe[10] = (1 - (xx + yy)) * sz;\n    oe[11] = 0;\n\n    oe[12] = translation.x;\n    oe[13] = translation.y;\n    oe[14] = translation.z;\n    oe[15] = 1;\n  }\n\n  /**\n   * Calculate a matrix from scale vector.\n   * @param s - The scale vector\n   * @param out - The calculated matrix\n   */\n  static scaling(s: Vector3, out: Matrix): void {\n    const oe = out.elements;\n    oe[0] = s.x;\n    oe[1] = 0;\n    oe[2] = 0;\n    oe[3] = 0;\n\n    oe[4] = 0;\n    oe[5] = s.y;\n    oe[6] = 0;\n    oe[7] = 0;\n\n    oe[8] = 0;\n    oe[9] = 0;\n    oe[10] = s.z;\n    oe[11] = 0;\n\n    oe[12] = 0;\n    oe[13] = 0;\n    oe[14] = 0;\n    oe[15] = 1;\n  }\n\n  /**\n   * Calculate a matrix from translation vector.\n   * @param translation - The translation vector\n   * @param out - The calculated matrix\n   */\n  static translation(translation: Vector3, out: Matrix): void {\n    const oe = out.elements;\n    oe[0] = 1;\n    oe[1] = 0;\n    oe[2] = 0;\n    oe[3] = 0;\n\n    oe[4] = 0;\n    oe[5] = 1;\n    oe[6] = 0;\n    oe[7] = 0;\n\n    oe[8] = 0;\n    oe[9] = 0;\n    oe[10] = 1;\n    oe[11] = 0;\n\n    oe[12] = translation.x;\n    oe[13] = translation.y;\n    oe[14] = translation.z;\n    oe[15] = 1;\n  }\n\n  /**\n   * Calculate the inverse of the specified matrix.\n   * @param a - The matrix whose inverse is to be calculated\n   * @param out - The inverse of the specified matrix\n   */\n  static invert(a: Matrix, out: Matrix): void {\n    const ae = a.elements;\n    const oe = out.elements;\n\n    const a11 = ae[0],\n      a12 = ae[1],\n      a13 = ae[2],\n      a14 = ae[3];\n    const a21 = ae[4],\n      a22 = ae[5],\n      a23 = ae[6],\n      a24 = ae[7];\n    const a31 = ae[8],\n      a32 = ae[9],\n      a33 = ae[10],\n      a34 = ae[11];\n    const a41 = ae[12],\n      a42 = ae[13],\n      a43 = ae[14],\n      a44 = ae[15];\n\n    const b00 = a11 * a22 - a12 * a21;\n    const b01 = a11 * a23 - a13 * a21;\n    const b02 = a11 * a24 - a14 * a21;\n    const b03 = a12 * a23 - a13 * a22;\n    const b04 = a12 * a24 - a14 * a22;\n    const b05 = a13 * a24 - a14 * a23;\n    const b06 = a31 * a42 - a32 * a41;\n    const b07 = a31 * a43 - a33 * a41;\n    const b08 = a31 * a44 - a34 * a41;\n    const b09 = a32 * a43 - a33 * a42;\n    const b10 = a32 * a44 - a34 * a42;\n    const b11 = a33 * a44 - a34 * a43;\n\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    if (!det) {\n      return null;\n    }\n    det = 1.0 / det;\n\n    oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;\n    oe[1] = (a13 * b10 - a12 * b11 - a14 * b09) * det;\n    oe[2] = (a42 * b05 - a43 * b04 + a44 * b03) * det;\n    oe[3] = (a33 * b04 - a32 * b05 - a34 * b03) * det;\n\n    oe[4] = (a23 * b08 - a21 * b11 - a24 * b07) * det;\n    oe[5] = (a11 * b11 - a13 * b08 + a14 * b07) * det;\n    oe[6] = (a43 * b02 - a41 * b05 - a44 * b01) * det;\n    oe[7] = (a31 * b05 - a33 * b02 + a34 * b01) * det;\n\n    oe[8] = (a21 * b10 - a22 * b08 + a24 * b06) * det;\n    oe[9] = (a12 * b08 - a11 * b10 - a14 * b06) * det;\n    oe[10] = (a41 * b04 - a42 * b02 + a44 * b00) * det;\n    oe[11] = (a32 * b02 - a31 * b04 - a34 * b00) * det;\n\n    oe[12] = (a22 * b07 - a21 * b09 - a23 * b06) * det;\n    oe[13] = (a11 * b09 - a12 * b07 + a13 * b06) * det;\n    oe[14] = (a42 * b01 - a41 * b03 - a43 * b00) * det;\n    oe[15] = (a31 * b03 - a32 * b01 + a33 * b00) * det;\n  }\n\n  /**\n   * Calculate a right-handed look-at matrix.\n   * @param eye - The position of the viewer's eye\n   * @param target - The camera look-at target\n   * @param up - The camera's up vector\n   * @param out - The calculated look-at matrix\n   */\n  static lookAt(eye: Vector3, target: Vector3, up: Vector3, out: Matrix): void {\n    const oe = out.elements;\n    const xAxis: Vector3 = Matrix._tempVec30;\n    const yAxis: Vector3 = Matrix._tempVec31;\n    const zAxis: Vector3 = Matrix._tempVec32;\n\n    Vector3.subtract(eye, target, zAxis);\n    zAxis.normalize();\n    Vector3.cross(up, zAxis, xAxis);\n    xAxis.normalize();\n    Vector3.cross(zAxis, xAxis, yAxis);\n\n    oe[0] = xAxis.x;\n    oe[1] = yAxis.x;\n    oe[2] = zAxis.x;\n    oe[3] = 0;\n\n    oe[4] = xAxis.y;\n    oe[5] = yAxis.y;\n    oe[6] = zAxis.y;\n    oe[7] = 0;\n\n    oe[8] = xAxis.z;\n    oe[9] = yAxis.z;\n    oe[10] = zAxis.z;\n    oe[11] = 0;\n\n    oe[12] = -Vector3.dot(xAxis, eye);\n    oe[13] = -Vector3.dot(yAxis, eye);\n    oe[14] = -Vector3.dot(zAxis, eye);\n    oe[15] = 1;\n  }\n\n  /**\n   * Calculate an orthographic projection matrix.\n   * @param left - The left edge of the viewing\n   * @param right - The right edge of the viewing\n   * @param bottom - The bottom edge of the viewing\n   * @param top - The top edge of the viewing\n   * @param near - The depth of the near plane\n   * @param far - The depth of the far plane\n   * @param out - The calculated orthographic projection matrix\n   */\n  static ortho(left: number, right: number, bottom: number, top: number, near: number, far: number, out: Matrix): void {\n    const oe = out.elements;\n    const lr = 1 / (left - right);\n    const bt = 1 / (bottom - top);\n    const nf = 1 / (near - far);\n\n    oe[0] = -2 * lr;\n    oe[1] = 0;\n    oe[2] = 0;\n    oe[3] = 0;\n\n    oe[4] = 0;\n    oe[5] = -2 * bt;\n    oe[6] = 0;\n    oe[7] = 0;\n\n    oe[8] = 0;\n    oe[9] = 0;\n    oe[10] = 2 * nf;\n    oe[11] = 0;\n\n    oe[12] = (left + right) * lr;\n    oe[13] = (top + bottom) * bt;\n    oe[14] = (far + near) * nf;\n    oe[15] = 1;\n  }\n\n  /**\n   * Calculate a perspective projection matrix.\n   * @param fovy - Field of view in the y direction, in radians\n   * @param aspect - Aspect ratio, defined as view space width divided by height\n   * @param near - The depth of the near plane\n   * @param far - The depth of the far plane\n   * @param out - The calculated perspective projection matrix\n   */\n  static perspective(fovy: number, aspect: number, near: number, far: number, out: Matrix): void {\n    const oe = out.elements;\n    const f = 1.0 / Math.tan(fovy / 2);\n    const nf = 1 / (near - far);\n\n    oe[0] = f / aspect;\n    oe[1] = 0;\n    oe[2] = 0;\n    oe[3] = 0;\n\n    oe[4] = 0;\n    oe[5] = f;\n    oe[6] = 0;\n    oe[7] = 0;\n\n    oe[8] = 0;\n    oe[9] = 0;\n    oe[10] = (far + near) * nf;\n    oe[11] = -1;\n\n    oe[12] = 0;\n    oe[13] = 0;\n    oe[14] = 2 * far * near * nf;\n    oe[15] = 0;\n  }\n\n  /**\n   * The specified matrix rotates around an arbitrary axis.\n   * @param m - The specified matrix\n   * @param axis - The axis\n   * @param r - The rotation angle in radians\n   * @param out - The rotated matrix\n   */\n  static rotateAxisAngle(m: Matrix, axis: Vector3, r: number, out: Matrix): void {\n    let { x, y, z } = axis;\n    let len = Math.sqrt(x * x + y * y + z * z);\n\n    if (Math.abs(len) < MathUtil.zeroTolerance) {\n      return;\n    }\n\n    const me = m.elements;\n    const oe = out.elements;\n    let s, c, t;\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    s = Math.sin(r);\n    c = Math.cos(r);\n    t = 1 - c;\n\n    let a11 = me[0],\n      a12 = me[1],\n      a13 = me[2],\n      a14 = me[3];\n    let a21 = me[4],\n      a22 = me[5],\n      a23 = me[6],\n      a24 = me[7];\n    let a31 = me[8],\n      a32 = me[9],\n      a33 = me[10],\n      a34 = me[11];\n\n    // Construct the elements of the rotation matrix\n    let b11 = x * x * t + c;\n    let b12 = y * x * t + z * s;\n    let b13 = z * x * t - y * s;\n    let b21 = x * y * t - z * s;\n    let b22 = y * y * t + c;\n    let b23 = z * y * t + x * s;\n    let b31 = x * z * t + y * s;\n    let b32 = y * z * t - x * s;\n    let b33 = z * z * t + c;\n\n    // Perform rotation-specific matrix multiplication\n    oe[0] = a11 * b11 + a21 * b12 + a31 * b13;\n    oe[1] = a12 * b11 + a22 * b12 + a32 * b13;\n    oe[2] = a13 * b11 + a23 * b12 + a33 * b13;\n    oe[3] = a14 * b11 + a24 * b12 + a34 * b13;\n\n    oe[4] = a11 * b21 + a21 * b22 + a31 * b23;\n    oe[5] = a12 * b21 + a22 * b22 + a32 * b23;\n    oe[6] = a13 * b21 + a23 * b22 + a33 * b23;\n    oe[7] = a14 * b21 + a24 * b22 + a34 * b23;\n\n    oe[8] = a11 * b31 + a21 * b32 + a31 * b33;\n    oe[9] = a12 * b31 + a22 * b32 + a32 * b33;\n    oe[10] = a13 * b31 + a23 * b32 + a33 * b33;\n    oe[11] = a14 * b31 + a24 * b32 + a34 * b33;\n\n    if (m !== out) {\n      // If the source and destination differ, copy the unchanged last row\n      oe[12] = me[12];\n      oe[13] = me[13];\n      oe[14] = me[14];\n      oe[15] = me[15];\n    }\n  }\n\n  /**\n   * Scale a matrix by a given vector.\n   * @param m - The matrix\n   * @param s - The given vector\n   * @param out - The scaled matrix\n   */\n  static scale(m: Matrix, s: Vector3, out: Matrix): void {\n    const me = m.elements;\n    const oe = out.elements;\n    const { x, y, z } = s;\n\n    oe[0] = me[0] * x;\n    oe[1] = me[1] * x;\n    oe[2] = me[2] * x;\n    oe[3] = me[3] * x;\n\n    oe[4] = me[4] * y;\n    oe[5] = me[5] * y;\n    oe[6] = me[6] * y;\n    oe[7] = me[7] * y;\n\n    oe[8] = me[8] * z;\n    oe[9] = me[9] * z;\n    oe[10] = me[10] * z;\n    oe[11] = me[11] * z;\n\n    oe[12] = me[12];\n    oe[13] = me[13];\n    oe[14] = me[14];\n    oe[15] = me[15];\n  }\n\n  /**\n   * Translate a matrix by a given vector.\n   * @param m - The matrix\n   * @param v - The given vector\n   * @param out - The translated matrix\n   */\n  static translate(m: Matrix, v: Vector3, out: Matrix): void {\n    const me = m.elements;\n    const oe = out.elements;\n    const { x, y, z } = v;\n\n    if (m === out) {\n      oe[12] = me[0] * x + me[4] * y + me[8] * z + me[12];\n      oe[13] = me[1] * x + me[5] * y + me[9] * z + me[13];\n      oe[14] = me[2] * x + me[6] * y + me[10] * z + me[14];\n      oe[15] = me[3] * x + me[7] * y + me[11] * z + me[15];\n    } else {\n      const a11 = me[0],\n        a12 = me[1],\n        a13 = me[2],\n        a14 = me[3];\n      const a21 = me[4],\n        a22 = me[5],\n        a23 = me[6],\n        a24 = me[7];\n      const a31 = me[8],\n        a32 = me[9],\n        a33 = me[10],\n        a34 = me[11];\n\n      (oe[0] = a11), (oe[1] = a12), (oe[2] = a13), (oe[3] = a14);\n      (oe[4] = a21), (oe[5] = a22), (oe[6] = a23), (oe[7] = a24);\n      (oe[8] = a31), (oe[9] = a32), (oe[10] = a33), (oe[11] = a34);\n\n      oe[12] = a11 * x + a21 * y + a31 * z + me[12];\n      oe[13] = a12 * x + a22 * y + a32 * z + me[13];\n      oe[14] = a13 * x + a23 * y + a33 * z + me[14];\n      oe[15] = a14 * x + a24 * y + a34 * z + me[15];\n    }\n  }\n\n  /**\n   * Calculate the transpose of the specified matrix.\n   * @param a - The specified matrix\n   * @param out - The transpose of the specified matrix\n   */\n  static transpose(a: Matrix, out: Matrix): void {\n    const ae = a.elements;\n    const oe = out.elements;\n\n    if (out === a) {\n      const a12 = ae[1];\n      const a13 = ae[2];\n      const a14 = ae[3];\n      const a23 = ae[6];\n      const a24 = ae[7];\n      const a34 = ae[11];\n\n      oe[1] = ae[4];\n      oe[2] = ae[8];\n      oe[3] = ae[12];\n\n      oe[4] = a12;\n      oe[6] = ae[9];\n      oe[7] = ae[13];\n\n      oe[8] = a13;\n      oe[9] = a23;\n      oe[11] = ae[14];\n\n      oe[12] = a14;\n      oe[13] = a24;\n      oe[14] = a34;\n    } else {\n      oe[0] = ae[0];\n      oe[1] = ae[4];\n      oe[2] = ae[8];\n      oe[3] = ae[12];\n\n      oe[4] = ae[1];\n      oe[5] = ae[5];\n      oe[6] = ae[9];\n      oe[7] = ae[13];\n\n      oe[8] = ae[2];\n      oe[9] = ae[6];\n      oe[10] = ae[10];\n      oe[11] = ae[14];\n\n      oe[12] = ae[3];\n      oe[13] = ae[7];\n      oe[14] = ae[11];\n      oe[15] = ae[15];\n    }\n  }\n\n  /**\n   * An array containing the elements of the matrix (column matrix).\n   * @remarks\n   * elements[0] first column and first row value m11\n   * elements[1] first column and second row value m12\n   * elements[2] first column and third row value m13\n   * elements[3] first column and fourth row value m14\n   * elements[4] second column and first row value m21\n   * and so on\n   */\n  elements: Float32Array = new Float32Array(16);\n\n  /**\n   * Constructor of 4x4 Matrix.\n   * @param m11 - default 1, column 1, row 1\n   * @param m12 - default 0, column 1, row 2\n   * @param m13 - default 0, column 1, row 3\n   * @param m14 - default 0, column 1, row 4\n   * @param m21 - default 0, column 2, row 1\n   * @param m22 - default 1, column 2, row 2\n   * @param m23 - default 0, column 2, row 3\n   * @param m24 - default 0, column 2, row 4\n   * @param m31 - default 0, column 3, row 1\n   * @param m32 - default 0, column 3, row 2\n   * @param m33 - default 1, column 3, row 3\n   * @param m34 - default 0, column 3, row 4\n   * @param m41 - default 0, column 4, row 1\n   * @param m42 - default 0, column 4, row 2\n   * @param m43 - default 0, column 4, row 3\n   * @param m44 - default 1, column 4, row 4\n   */\n  constructor(\n    m11: number = 1,\n    m12: number = 0,\n    m13: number = 0,\n    m14: number = 0,\n    m21: number = 0,\n    m22: number = 1,\n    m23: number = 0,\n    m24: number = 0,\n    m31: number = 0,\n    m32: number = 0,\n    m33: number = 1,\n    m34: number = 0,\n    m41: number = 0,\n    m42: number = 0,\n    m43: number = 0,\n    m44: number = 1\n  ) {\n    const e: Float32Array = this.elements;\n\n    e[0] = m11;\n    e[1] = m12;\n    e[2] = m13;\n    e[3] = m14;\n\n    e[4] = m21;\n    e[5] = m22;\n    e[6] = m23;\n    e[7] = m24;\n\n    e[8] = m31;\n    e[9] = m32;\n    e[10] = m33;\n    e[11] = m34;\n\n    e[12] = m41;\n    e[13] = m42;\n    e[14] = m43;\n    e[15] = m44;\n  }\n\n  /**\n   * Set the value of this matrix, and return this matrix.\n   * @param m11 - column 1, row 1\n   * @param m12 - column 1, row 2\n   * @param m13 - column 1, row 3\n   * @param m14 - column 1, row 4\n   * @param m21 - column 2, row 1\n   * @param m22 - column 2, row 2\n   * @param m23 - column 2, row 3\n   * @param m24 - column 2, row 4\n   * @param m31 - column 3, row 1\n   * @param m32 - column 3, row 2\n   * @param m33 - column 3, row 3\n   * @param m34 - column 3, row 4\n   * @param m41 - column 4, row 1\n   * @param m42 - column 4, row 2\n   * @param m43 - column 4, row 3\n   * @param m44 - column 4, row 4\n   * @returns This matrix\n   */\n  setValue(\n    m11: number,\n    m12: number,\n    m13: number,\n    m14: number,\n    m21: number,\n    m22: number,\n    m23: number,\n    m24: number,\n    m31: number,\n    m32: number,\n    m33: number,\n    m34: number,\n    m41: number,\n    m42: number,\n    m43: number,\n    m44: number\n  ): Matrix {\n    const e = this.elements;\n\n    e[0] = m11;\n    e[1] = m12;\n    e[2] = m13;\n    e[3] = m14;\n\n    e[4] = m21;\n    e[5] = m22;\n    e[6] = m23;\n    e[7] = m24;\n\n    e[8] = m31;\n    e[9] = m32;\n    e[10] = m33;\n    e[11] = m34;\n\n    e[12] = m41;\n    e[13] = m42;\n    e[14] = m43;\n    e[15] = m44;\n\n    return this;\n  }\n\n  /**\n   * Set the value of this matrix by an array.\n   * @param array - The array\n   * @param offset - The start offset of the array\n   * @returns This matrix\n   */\n  setValueByArray(array: ArrayLike<number>, offset: number = 0): Matrix {\n    const srce = this.elements;\n    for (let i = 0; i < 16; i++) {\n      srce[i] = array[i + offset];\n    }\n    return this;\n  }\n\n  /**\n   * Clone the value of this matrix to an array.\n   * @param out - The array\n   * @param outOffset - The start offset of the array\n   */\n  toArray(out: number[] | Float32Array | Float64Array, outOffset: number = 0) {\n    const e = this.elements;\n\n    out[outOffset] = e[0];\n    out[outOffset + 1] = e[1];\n    out[outOffset + 2] = e[2];\n    out[outOffset + 3] = e[3];\n    out[outOffset + 4] = e[4];\n    out[outOffset + 5] = e[5];\n    out[outOffset + 6] = e[6];\n    out[outOffset + 7] = e[7];\n    out[outOffset + 8] = e[8];\n    out[outOffset + 9] = e[9];\n    out[outOffset + 10] = e[10];\n    out[outOffset + 11] = e[11];\n    out[outOffset + 12] = e[12];\n    out[outOffset + 13] = e[13];\n    out[outOffset + 14] = e[14];\n    out[outOffset + 15] = e[15];\n  }\n\n  /**\n   * Creates a clone of this matrix.\n   * @returns A clone of this matrix\n   */\n  clone(): Matrix {\n    const e = this.elements;\n    let ret = new Matrix(\n      e[0],\n      e[1],\n      e[2],\n      e[3],\n      e[4],\n      e[5],\n      e[6],\n      e[7],\n      e[8],\n      e[9],\n      e[10],\n      e[11],\n      e[12],\n      e[13],\n      e[14],\n      e[15]\n    );\n    return ret;\n  }\n\n  /**\n   * Clones this matrix to the specified matrix.\n   * @param out - The specified matrix\n   * @returns The specified matrix\n   */\n  cloneTo(out: Matrix): Matrix {\n    const e = this.elements;\n    const oe = out.elements;\n\n    oe[0] = e[0];\n    oe[1] = e[1];\n    oe[2] = e[2];\n    oe[3] = e[3];\n\n    oe[4] = e[4];\n    oe[5] = e[5];\n    oe[6] = e[6];\n    oe[7] = e[7];\n\n    oe[8] = e[8];\n    oe[9] = e[9];\n    oe[10] = e[10];\n    oe[11] = e[11];\n\n    oe[12] = e[12];\n    oe[13] = e[13];\n    oe[14] = e[14];\n    oe[15] = e[15];\n\n    return out;\n  }\n\n  /**\n   * Determines the product of this matrix and the specified matrix.\n   * @param right - The specified matrix\n   * @returns This matrix that store the product of the two matrices\n   */\n  multiply(right: Matrix): Matrix {\n    Matrix.multiply(this, right, this);\n    return this;\n  }\n\n  /**\n   * Calculate a determinant of this matrix.\n   * @returns The determinant of this matrix\n   */\n  determinant(): number {\n    const e = this.elements;\n\n    const a11 = e[0],\n      a12 = e[1],\n      a13 = e[2],\n      a14 = e[3];\n    const a21 = e[4],\n      a22 = e[5],\n      a23 = e[6],\n      a24 = e[7];\n    const a31 = e[8],\n      a32 = e[9],\n      a33 = e[10],\n      a34 = e[11];\n    const a41 = e[12],\n      a42 = e[13],\n      a43 = e[14],\n      a44 = e[15];\n\n    const b00 = a11 * a22 - a12 * a21;\n    const b01 = a11 * a23 - a13 * a21;\n    const b02 = a11 * a24 - a14 * a21;\n    const b03 = a12 * a23 - a13 * a22;\n    const b04 = a12 * a24 - a14 * a22;\n    const b05 = a13 * a24 - a14 * a23;\n    const b06 = a31 * a42 - a32 * a41;\n    const b07 = a31 * a43 - a33 * a41;\n    const b08 = a31 * a44 - a34 * a41;\n    const b09 = a32 * a43 - a33 * a42;\n    const b10 = a32 * a44 - a34 * a42;\n    const b11 = a33 * a44 - a34 * a43;\n\n    // Calculate the determinant\n    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  }\n\n  /**\n   * Decompose this matrix to translation, rotation and scale elements.\n   * @param translation - Translation vector as an output parameter\n   * @param rotation - Rotation quaternion as an output parameter\n   * @param scale - Scale vector as an output parameter\n   * @returns True if this matrix can be decomposed, false otherwise\n   */\n  decompose(translation: Vector3, rotation: Quaternion, scale: Vector3): boolean {\n    const rm: Matrix3x3 = Matrix._tempMat30;\n\n    const e = this.elements;\n    const rme = rm.elements;\n\n    const m11 = e[0];\n    const m12 = e[1];\n    const m13 = e[2];\n    const m14 = e[3];\n    const m21 = e[4];\n    const m22 = e[5];\n    const m23 = e[6];\n    const m24 = e[7];\n    const m31 = e[8];\n    const m32 = e[9];\n    const m33 = e[10];\n    const m34 = e[11];\n\n    translation.x = e[12];\n    translation.y = e[13];\n    translation.z = e[14];\n\n    const xs = Math.sign(m11 * m12 * m13 * m14) < 0 ? -1 : 1;\n    const ys = Math.sign(m21 * m22 * m23 * m24) < 0 ? -1 : 1;\n    const zs = Math.sign(m31 * m32 * m33 * m34) < 0 ? -1 : 1;\n\n    const sx = xs * Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);\n    const sy = ys * Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);\n    const sz = zs * Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);\n\n    scale.x = sx;\n    scale.y = sy;\n    scale.z = sz;\n\n    if (\n      Math.abs(sx) < MathUtil.zeroTolerance ||\n      Math.abs(sy) < MathUtil.zeroTolerance ||\n      Math.abs(sz) < MathUtil.zeroTolerance\n    ) {\n      rotation.identity();\n      return false;\n    } else {\n      const invSX = 1 / sx;\n      const invSY = 1 / sy;\n      const invSZ = 1 / sz;\n\n      rme[0] = m11 * invSX;\n      rme[1] = m12 * invSX;\n      rme[2] = m13 * invSX;\n      rme[3] = m21 * invSY;\n      rme[4] = m22 * invSY;\n      rme[5] = m23 * invSY;\n      rme[6] = m31 * invSZ;\n      rme[7] = m32 * invSZ;\n      rme[8] = m33 * invSZ;\n      Quaternion.rotationMatrix3x3(rm, rotation);\n      return true;\n    }\n  }\n\n  /**\n   * Get rotation from this matrix.\n   * @param out - Rotation quaternion as an output parameter\n   * @returns The out\n   */\n  getRotation(out: Quaternion): Quaternion {\n    const e = this.elements;\n    let trace = e[0] + e[5] + e[10];\n\n    if (trace > MathUtil.zeroTolerance) {\n      let S = Math.sqrt(trace + 1.0) * 2;\n      out.w = 0.25 * S;\n      out.x = (e[6] - e[9]) / S;\n      out.y = (e[8] - e[2]) / S;\n      out.z = (e[1] - e[4]) / S;\n    } else if (e[0] > e[5] && e[0] > e[10]) {\n      let S = Math.sqrt(1.0 + e[0] - e[5] - e[10]) * 2;\n      out.w = (e[6] - e[9]) / S;\n      out.x = 0.25 * S;\n      out.y = (e[1] + e[4]) / S;\n      out.z = (e[8] + e[2]) / S;\n    } else if (e[5] > e[10]) {\n      let S = Math.sqrt(1.0 + e[5] - e[0] - e[10]) * 2;\n      out.w = (e[8] - e[2]) / S;\n      out.x = (e[1] + e[4]) / S;\n      out.y = 0.25 * S;\n      out.z = (e[6] + e[9]) / S;\n    } else {\n      let S = Math.sqrt(1.0 + e[10] - e[0] - e[5]) * 2;\n      out.w = (e[1] - e[4]) / S;\n      out.x = (e[8] + e[2]) / S;\n      out.y = (e[6] + e[9]) / S;\n      out.z = 0.25 * S;\n    }\n\n    return out;\n  }\n\n  /**\n   * Get scale from this matrix.\n   * @param out - Scale vector as an output parameter\n   * @returns The out\n   */\n  getScaling(out: Vector3): Vector3 {\n    //getScale()\n    const e = this.elements;\n    const m11 = e[0],\n      m12 = e[1],\n      m13 = e[2];\n    const m21 = e[4],\n      m22 = e[5],\n      m23 = e[6];\n    const m31 = e[8],\n      m32 = e[9],\n      m33 = e[10];\n\n    out.x = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);\n    out.y = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);\n    out.z = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);\n\n    return out;\n  }\n\n  /**\n   * Get translation from this matrix.\n   * @param out - Translation vector as an output parameter\n   * @returns The out\n   */\n  getTranslation(out: Vector3): Vector3 {\n    const e = this.elements;\n\n    out.x = e[12];\n    out.y = e[13];\n    out.z = e[14];\n\n    return out;\n  }\n\n  /**\n   * Identity this matrix.\n   * @returns This matrix after identity\n   */\n  identity(): Matrix {\n    const e = this.elements;\n\n    e[0] = 1;\n    e[1] = 0;\n    e[2] = 0;\n    e[3] = 0;\n\n    e[4] = 0;\n    e[5] = 1;\n    e[6] = 0;\n    e[7] = 0;\n\n    e[8] = 0;\n    e[9] = 0;\n    e[10] = 1;\n    e[11] = 0;\n\n    e[12] = 0;\n    e[13] = 0;\n    e[14] = 0;\n    e[15] = 1;\n\n    return this;\n  }\n\n  /**\n   * Invert the matrix.\n   * @returns The matrix after invert\n   */\n  invert(): Matrix {\n    Matrix.invert(this, this);\n    return this;\n  }\n\n  /**\n   * This matrix rotates around an arbitrary axis.\n   * @param axis - The axis\n   * @param r - The rotation angle in radians\n   * @returns This matrix after rotate\n   */\n  rotateAxisAngle(axis: Vector3, r: number): Matrix {\n    Matrix.rotateAxisAngle(this, axis, r, this);\n    return this;\n  }\n\n  /**\n   * Scale this matrix by a given vector.\n   * @param s - The given vector\n   * @returns This matrix after scale\n   */\n  scale(s: Vector3): Matrix {\n    Matrix.scale(this, s, this);\n    return this;\n  }\n\n  /**\n   * Translate this matrix by a given vector.\n   * @param v - The given vector\n   * @returns This matrix after translate\n   */\n  translate(v: Vector3): Matrix {\n    Matrix.translate(this, v, this);\n    return this;\n  }\n\n  /**\n   * Calculate the transpose of this matrix.\n   * @returns This matrix after transpose\n   */\n  transpose(): Matrix {\n    Matrix.transpose(this, this);\n    return this;\n  }\n}\n", "import { BoundingBox } from \"./BoundingBox\";\nimport { BoundingSphere } from \"./BoundingSphere\";\nimport { CollisionUtil } from \"./CollisionUtil\";\nimport { Plane } from \"./Plane\";\nimport { Vector3 } from \"./Vector3\";\n\n/**\n * Represents a ray with an origin and a direction in 3D space.\n */\nexport class Ray {\n  /** The origin of the ray. */\n  readonly origin: Vector3 = new Vector3();\n  /** The normalized direction of the ray. */\n  readonly direction: Vector3 = new Vector3();\n\n  /**\n   * Constructor of Ray.\n   * @param origin - The origin vector\n   * @param direction - The direction vector\n   */\n  constructor(origin: Vector3 = null, direction: Vector3 = null) {\n    origin && origin.cloneTo(this.origin);\n    direction && direction.cloneTo(this.direction);\n  }\n\n  /**\n   * Check if this ray intersects the specified plane.\n   * @param plane - The specified plane\n   * @returns The distance from this ray to the specified plane if intersecting, -1 otherwise\n   */\n  intersectPlane(plane: Plane): number {\n    return CollisionUtil.intersectsRayAndPlane(this, plane);\n  }\n\n  /**\n   * Check if this ray intersects the specified sphere.\n   * @param sphere - The specified sphere\n   * @returns The distance from this ray to the specified sphere if intersecting, -1 otherwise\n   */\n  intersectSphere(sphere: BoundingSphere): number {\n    return CollisionUtil.intersectsRayAndSphere(this, sphere);\n  }\n\n  /**\n   * Check if this ray intersects the specified box (AABB).\n   * @param box - The specified box\n   * @returns The distance from this ray to the specified box if intersecting, -1 otherwise\n   */\n  intersectBox(box: BoundingBox): number {\n    return CollisionUtil.intersectsRayAndBox(this, box);\n  }\n\n  /**\n   * The coordinates of the specified distance from the origin in the ray direction.\n   * @param distance - The specified distance\n   * @param out - The coordinates as an output parameter\n   * @returns The out\n   */\n  getPoint(distance: number, out: Vector3): Vector3 {\n    Vector3.scale(this.direction, distance, out);\n    return out.add(this.origin);\n  }\n}\n", "import { IClone } from \"@oasis-engine/design\";\nimport { MathUtil } from \"./MathUtil\";\n\n/**\n * Describes a 2D-vector.\n */\nexport class Vector2 implements IClone {\n  /** @internal */\n  static readonly _zero = new Vector2(0.0, 0.0);\n  /** @internal */\n  static readonly _one = new Vector2(1.0, 1.0);\n\n  /**\n   * Determines the sum of two vectors.\n   * @param left - The first vector to add\n   * @param right - The second vector to add\n   * @param out - The sum of two vectors\n   */\n  static add(left: Vector2, right: Vector2, out: Vector2): void {\n    out.x = left.x + right.x;\n    out.y = left.y + right.y;\n  }\n\n  /**\n   * Determines the difference between two vectors.\n   * @param left - The first vector to subtract\n   * @param right - The second vector to subtract\n   * @param out - The difference between two vectors\n   */\n  static subtract(left: Vector2, right: Vector2, out: Vector2): void {\n    out.x = left.x - right.x;\n    out.y = left.y - right.y;\n  }\n\n  /**\n   * Determines the product of two vectors.\n   * @param left - The first vector to multiply\n   * @param right - The second vector to multiply\n   * @param out - The product of two vectors\n   */\n  static multiply(left: Vector2, right: Vector2, out: Vector2): void {\n    out.x = left.x * right.x;\n    out.y = left.y * right.y;\n  }\n\n  /**\n   * Determines the divisor of two vectors.\n   * @param left - The first vector to divide\n   * @param right - The second vector to divide\n   * @param out - The divisor of two vectors\n   */\n  static divide(left: Vector2, right: Vector2, out: Vector2): void {\n    out.x = left.x / right.x;\n    out.y = left.y / right.y;\n  }\n\n  /**\n   * Determines the dot product of two vectors.\n   * @param left - The first vector to dot\n   * @param right - The second vector to dot\n   * @returns The dot product of two vectors\n   */\n  static dot(left: Vector2, right: Vector2): number {\n    return left.x * right.x + left.y * right.y;\n  }\n\n  /**\n   * Determines the distance of two vectors.\n   * @param left - The first vector\n   * @param right - The second vector\n   * @returns The distance of two vectors\n   */\n  static distance(left: Vector2, right: Vector2): number {\n    const x = right.x - left.x;\n    const y = right.y - left.y;\n    return Math.sqrt(x * x + y * y);\n  }\n\n  /**\n   * Determines the squared distance of two vectors.\n   * @param left - The first vector\n   * @param right - The second vector\n   * @returns The squared distance of two vectors\n   */\n  static distanceSquared(left: Vector2, right: Vector2): number {\n    const x = right.x - left.x;\n    const y = right.y - left.y;\n    return x * x + y * y;\n  }\n\n  /**\n   * Determines whether the specified vectors are equals.\n   * @param left - The first vector to compare\n   * @param right - The second vector to compare\n   * @returns True if the specified vectors are equals, false otherwise\n   */\n  static equals(left: Vector2, right: Vector2): boolean {\n    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y);\n  }\n\n  /**\n   * Performs a linear interpolation between two vectors.\n   * @param left - The first vector\n   * @param right - The second vector\n   * @param t - The blend amount where 0 returns left and 1 right\n   * @param out - The result of linear blending between two vectors\n   */\n  static lerp(left: Vector2, right: Vector2, t: number, out: Vector2): void {\n    const { x, y } = left;\n    out.x = x + (right.x - x) * t;\n    out.y = y + (right.y - y) * t;\n  }\n\n  /**\n   * Calculate a vector containing the largest components of the specified vectors.\n   * @param left - The first vector\n   * @param right - The second vector\n   * @param out - The vector containing the largest components of the specified vectors\n   */\n  static max(left: Vector2, right: Vector2, out: Vector2): void {\n    out.x = Math.max(left.x, right.x);\n    out.y = Math.max(left.y, right.y);\n  }\n\n  /**\n   * Calculate a vector containing the smallest components of the specified vectors.\n   * @param left - The first vector\n   * @param right - The second vector\n   * @param out - The vector containing the smallest components of the specified vectors\n   */\n  static min(left: Vector2, right: Vector2, out: Vector2): void {\n    out.x = Math.min(left.x, right.x);\n    out.y = Math.min(left.y, right.y);\n  }\n\n  /**\n   * Reverses the direction of a given vector.\n   * @param left - The vector to negate\n   * @param out - The vector facing in the opposite direction\n   */\n  static negate(left: Vector2, out: Vector2): void {\n    out.x = -left.x;\n    out.y = -left.y;\n  }\n\n  /**\n   * Converts the vector into a unit vector.\n   * @param left - The vector to normalize\n   * @param out - The normalized vector\n   */\n  static normalize(left: Vector2, out: Vector2): void {\n    const { x, y } = left;\n    let len: number = Math.sqrt(x * x + y * y);\n    if (len > MathUtil.zeroTolerance) {\n      len = 1 / len;\n      out.x = x * len;\n      out.y = y * len;\n    }\n  }\n\n  /**\n   * Scale a vector by the given value.\n   * @param left - The vector to scale\n   * @param s - The amount by which to scale the vector\n   * @param out - The scaled vector\n   */\n  static scale(left: Vector2, s: number, out: Vector2): void {\n    out.x = left.x * s;\n    out.y = left.y * s;\n  }\n\n  /** The x component of the vector. */\n  x: number;\n  /** The y component of the vector. */\n  y: number;\n\n  /**\n   * Constructor of Vector2.\n   * @param x - The x component of the vector, default 0\n   * @param y - The y component of the vector, default 0\n   */\n  constructor(x: number = 0, y: number = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Set the value of this vector.\n   * @param x - The x component of the vector\n   * @param y - The y component of the vector\n   * @returns This vector\n   */\n  setValue(x: number, y: number): Vector2 {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  /**\n   * Set the value of this vector by an array.\n   * @param array - The array\n   * @param offset - The start offset of the array\n   * @returns This vector\n   */\n  setValueByArray(array: ArrayLike<number>, offset: number = 0): Vector2 {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    return this;\n  }\n\n  /**\n   * Determines the sum of this vector and the specified vector.\n   * @param right - The specified vector\n   * @returns This vector\n   */\n  add(right: Vector2): Vector2 {\n    this.x += right.x;\n    this.y += right.y;\n    return this;\n  }\n\n  /**\n   * Determines the difference of this vector and the specified vector.\n   * @param right - The specified vector\n   * @returns This vector\n   */\n  subtract(right: Vector2): Vector2 {\n    this.x -= right.x;\n    this.y -= right.y;\n    return this;\n  }\n\n  /**\n   * Determines the product of this vector and the specified vector.\n   * @param right - The specified vector\n   * @returns This vector\n   */\n  multiply(right: Vector2): Vector2 {\n    this.x *= right.x;\n    this.y *= right.y;\n    return this;\n  }\n\n  /**\n   * Determines the divisor of this vector and the specified vector.\n   * @param right - The specified vector\n   * @returns This vector\n   */\n  divide(right: Vector2): Vector2 {\n    this.x /= right.x;\n    this.y /= right.y;\n    return this;\n  }\n\n  /**\n   * Calculate the length of this vector.\n   * @returns The length of this vector\n   */\n  length(): number {\n    const { x, y } = this;\n    return Math.sqrt(x * x + y * y);\n  }\n\n  /**\n   * Calculate the squared length of this vector.\n   * @returns The squared length of this vector\n   */\n  lengthSquared(): number {\n    const { x, y } = this;\n    return x * x + y * y;\n  }\n\n  /**\n   * Reverses the direction of this vector.\n   * @returns This vector\n   */\n  negate(): Vector2 {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  }\n\n  /**\n   * Converts this vector into a unit vector.\n   * @returns This vector\n   */\n  normalize(): Vector2 {\n    Vector2.normalize(this, this);\n    return this;\n  }\n\n  /**\n   * Scale this vector by the given value.\n   * @param s - The amount by which to scale the vector\n   * @returns This vector\n   */\n  scale(s: number): Vector2 {\n    this.x *= s;\n    this.y *= s;\n    return this;\n  }\n\n  /**\n   * Clone the value of this vector to an array.\n   * @param out - The array\n   * @param outOffset - The start offset of the array\n   */\n  toArray(out: number[] | Float32Array | Float64Array, outOffset: number = 0) {\n    out[outOffset] = this.x;\n    out[outOffset + 1] = this.y;\n  }\n\n  /**\n   * Creates a clone of this vector.\n   * @returns A clone of this vector\n   */\n  clone(): Vector2 {\n    return new Vector2(this.x, this.y);\n  }\n\n  /**\n   * Clones this vector to the specified vector.\n   * @param out - The specified vector\n   * @returns The specified vector\n   */\n  cloneTo(out: Vector2): Vector2 {\n    out.x = this.x;\n    out.y = this.y;\n    return out;\n  }\n}\n", "import { IClone } from \"@oasis-engine/design\";\nimport { MathUtil } from \"./MathUtil\";\nimport { Matrix } from \"./Matrix\";\nimport { Quaternion } from \"./Quaternion\";\n\n/**\n * Describes a 4D-vector.\n */\nexport class Vector4 implements IClone {\n  /** @internal */\n  static readonly _zero = new Vector4(0.0, 0.0, 0.0, 0.0);\n  /** @internal */\n  static readonly _one = new Vector4(1.0, 1.0, 1.0, 1.0);\n\n  /**\n   * Determines the sum of two vectors.\n   * @param left - The first vector to add\n   * @param right - The second vector to add\n   * @param out - The sum of two vectors\n   */\n  static add(left: Vector4, right: Vector4, out: Vector4): void {\n    out.x = left.x + right.x;\n    out.y = left.y + right.y;\n    out.z = left.z + right.z;\n    out.w = left.w + right.w;\n  }\n\n  /**\n   * Determines the difference between two vectors.\n   * @param left - The first vector to subtract\n   * @param right - The second vector to subtract\n   * @param out - The difference between two vectors\n   */\n  static subtract(left: Vector4, right: Vector4, out: Vector4): void {\n    out.x = left.x - right.x;\n    out.y = left.y - right.y;\n    out.z = left.z - right.z;\n    out.w = left.w - right.w;\n  }\n\n  /**\n   * Determines the product of two vectors.\n   * @param left - The first vector to multiply\n   * @param right - The second vector to multiply\n   * @param out - The product of two vectors\n   */\n  static multiply(left: Vector4, right: Vector4, out: Vector4): void {\n    out.x = left.x * right.x;\n    out.y = left.y * right.y;\n    out.z = left.z * right.z;\n    out.w = left.w * right.w;\n  }\n\n  /**\n   * Determines the divisor of two vectors.\n   * @param left - The first vector to divide\n   * @param right - The second vector to divide\n   * @param out - The divisor of two vectors\n   */\n  static divide(left: Vector4, right: Vector4, out: Vector4): void {\n    out.x = left.x / right.x;\n    out.y = left.y / right.y;\n    out.z = left.z / right.z;\n    out.w = left.w / right.w;\n  }\n\n  /**\n   * Determines the dot product of two vectors.\n   * @param left - The first vector to dot\n   * @param right - The second vector to dot\n   * @returns The dot product of two vectors\n   */\n  static dot(left: Vector4, right: Vector4): number {\n    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n  }\n\n  /**\n   * Determines the distance of two vectors.\n   * @param a - The first vector\n   * @param b - The second vector\n   * @returns The distance of two vectors\n   */\n  static distance(a: Vector4, b: Vector4): number {\n    const x = b.x - a.x;\n    const y = b.y - a.y;\n    const z = b.z - a.z;\n    const w = b.w - a.w;\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n  }\n\n  /**\n   * Determines the squared distance of two vectors.\n   * @param a - The first vector\n   * @param b - The second vector\n   * @returns The squared distance of two vectors\n   */\n  static distanceSquared(a: Vector4, b: Vector4): number {\n    const x = b.x - a.x;\n    const y = b.y - a.y;\n    const z = b.z - a.z;\n    const w = b.w - a.w;\n    return x * x + y * y + z * z + w * w;\n  }\n\n  /**\n   * Determines whether the specified vectors are equals.\n   * @param left - The first vector to compare\n   * @param right - The second vector to compare\n   * @returns True if the specified vectors are equals, false otherwise\n   */\n  static equals(left: Vector4, right: Vector4): boolean {\n    return (\n      MathUtil.equals(left.x, right.x) &&\n      MathUtil.equals(left.y, right.y) &&\n      MathUtil.equals(left.z, right.z) &&\n      MathUtil.equals(left.w, right.w)\n    );\n  }\n\n  /**\n   * Performs a linear interpolation between two vectors.\n   * @param start - The first vector\n   * @param end - The second vector\n   * @param t - The blend amount where 0 returns start and 1 end\n   * @param out - The result of linear blending between two vectors\n   */\n  static lerp(start: Vector4, end: Vector4, t: number, out: Vector4): void {\n    const { x, y, z, w } = start;\n    out.x = x + (end.x - x) * t;\n    out.y = y + (end.y - y) * t;\n    out.z = z + (end.z - z) * t;\n    out.w = w + (end.w - w) * t;\n  }\n\n  /**\n   * Calculate a vector containing the largest components of the specified vectors.\n   * @param left - The first vector\n   * @param right - The second vector\n   * @param out - The vector containing the largest components of the specified vectors\n   */\n  static max(left: Vector4, right: Vector4, out: Vector4): void {\n    out.x = Math.max(left.x, right.x);\n    out.y = Math.max(left.y, right.y);\n    out.z = Math.max(left.z, right.z);\n    out.w = Math.max(left.w, right.w);\n  }\n\n  /**\n   * Calculate a vector containing the smallest components of the specified vectors.\n   * @param left - The first vector\n   * @param right - The second vector\n   * @param out - The vector containing the smallest components of the specified vectors\n   */\n  static min(left: Vector4, right: Vector4, out: Vector4): void {\n    out.x = Math.min(left.x, right.x);\n    out.y = Math.min(left.y, right.y);\n    out.z = Math.min(left.z, right.z);\n    out.w = Math.min(left.w, right.w);\n  }\n\n  /**\n   * Reverses the direction of a given vector.\n   * @param a - The vector to negate\n   * @param out - The vector facing in the opposite direction\n   */\n  static negate(a: Vector4, out: Vector4): void {\n    out.x = -a.x;\n    out.y = -a.y;\n    out.z = -a.z;\n    out.w = -a.w;\n  }\n\n  /**\n   * Converts the vector into a unit vector.\n   * @param a - The vector to normalize\n   * @param out - The normalized vector\n   */\n  static normalize(a: Vector4, out: Vector4): void {\n    const { x, y, z, w } = a;\n    let len: number = Math.sqrt(x * x + y * y + z * z + w * w);\n    if (len > MathUtil.zeroTolerance) {\n      len = 1 / len;\n      out.x = x * len;\n      out.y = y * len;\n      out.z = z * len;\n      out.w = w * len;\n    }\n  }\n\n  /**\n   * Scale a vector by the given value.\n   * @param a - The vector to scale\n   * @param s - The amount by which to scale the vector\n   * @param out - The scaled vector\n   */\n  static scale(a: Vector4, s: number, out: Vector4): void {\n    out.x = a.x * s;\n    out.y = a.y * s;\n    out.z = a.z * s;\n    out.w = a.w * s;\n  }\n\n  /**\n   * Performs a transformation using the given 4x4 matrix.\n   * @param v - The vector to transform\n   * @param m - The transform matrix\n   * @param out - The transformed vector3\n   */\n  static transform(v: Vector4, m: Matrix, out: Vector4): void {\n    const { x, y, z, w } = v;\n    const e = m.elements;\n    out.x = x * e[0] + y * e[4] + z * e[8] + w * e[12];\n    out.y = x * e[1] + y * e[5] + z * e[9] + w * e[13];\n    out.z = x * e[2] + y * e[6] + z * e[10] + w * e[14];\n    out.w = x * e[3] + y * e[7] + z * e[11] + w * e[15];\n  }\n\n  /**\n   * Performs a transformation using the given quaternion.\n   * @param v - The vector to transform\n   * @param q - The transform quaternion\n   * @param out - The transformed vector\n   */\n  static transformByQuat(v: Vector4, q: Quaternion, out: Vector4): void {\n    const { x, y, z, w } = v;\n    const qx = q.x;\n    const qy = q.y;\n    const qz = q.z;\n    const qw = q.w;\n\n    // calculate quat * vec\n    const ix = qw * x + qy * z - qz * y;\n    const iy = qw * y + qz * x - qx * z;\n    const iz = qw * z + qx * y - qy * x;\n    const iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n    out.x = ix * qw - iw * qx - iy * qz + iz * qy;\n    out.y = iy * qw - iw * qy - iz * qx + ix * qz;\n    out.z = iz * qw - iw * qz - ix * qy + iy * qx;\n    out.w = w;\n  }\n\n  /** The x component of the vector. */\n  x: number;\n  /** The y component of the vector. */\n  y: number;\n  /** The z component of the vector. */\n  z: number;\n  /** The w component of the vector. */\n  w: number;\n\n  /**\n   * Constructor of Vector4.\n   * @param x - The x component of the vector, default 0\n   * @param y - The y component of the vector, default 0\n   * @param z - The z component of the vector, default 0\n   * @param w - The w component of the vector, default 0\n   */\n  constructor(x: number = 0, y: number = 0, z: number = 0, w: number = 0) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n\n  /**\n   * Set the value of this vector.\n   * @param x - The x component of the vector\n   * @param y - The y component of the vector\n   * @param z - The z component of the vector\n   * @param w - The w component of the vector\n   * @returns This vector\n   */\n  setValue(x: number, y: number, z: number, w: number): Vector4 {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  }\n\n  /**\n   * Set the value of this vector by an array.\n   * @param array - The array\n   * @param offset - The start offset of the array\n   * @returns This vector\n   */\n  setValueByArray(array: ArrayLike<number>, offset: number = 0): Vector4 {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    this.w = array[offset + 3];\n    return this;\n  }\n\n  /**\n   * Determines the sum of this vector and the specified vector.\n   * @param right - The specified vector\n   * @returns This vector\n   */\n  add(right: Vector4): Vector4 {\n    this.x += right.x;\n    this.y += right.y;\n    this.z += right.z;\n    this.w += right.w;\n    return this;\n  }\n\n  /**\n   * Determines the difference of this vector and the specified vector.\n   * @param right - the specified vector\n   * @returns This vector\n   */\n  subtract(right: Vector4): Vector4 {\n    this.x -= right.x;\n    this.y -= right.y;\n    this.z -= right.z;\n    this.w -= right.w;\n    return this;\n  }\n\n  /**\n   * Determines the product of this vector and the specified vector.\n   * @param right - the specified vector\n   * @returns This vector\n   */\n  multiply(right: Vector4): Vector4 {\n    this.x *= right.x;\n    this.y *= right.y;\n    this.z *= right.z;\n    this.w *= right.w;\n    return this;\n  }\n\n  /**\n   * Determines the divisor of this vector and the specified vector.\n   * @param right - the specified vector\n   * @returns This vector\n   */\n  divide(right: Vector4): Vector4 {\n    this.x /= right.x;\n    this.y /= right.y;\n    this.z /= right.z;\n    this.w /= right.w;\n    return this;\n  }\n\n  /**\n   * Calculate the length of this vector.\n   * @returns The length of this vector\n   */\n  length(): number {\n    const { x, y, z, w } = this;\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n  }\n\n  /**\n   * Calculate the squared length of this vector.\n   * @returns The squared length of this vector\n   */\n  lengthSquared(): number {\n    const { x, y, z, w } = this;\n    return x * x + y * y + z * z + w * w;\n  }\n\n  /**\n   * Reverses the direction of this vector.\n   * @returns This vector\n   */\n  negate(): Vector4 {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    this.w = -this.w;\n    return this;\n  }\n\n  /**\n   * Converts this vector into a unit vector.\n   * @returns This vector\n   */\n  normalize(): Vector4 {\n    Vector4.normalize(this, this);\n    return this;\n  }\n\n  /**\n   * Scale this vector by the given value.\n   * @param s - The amount by which to scale the vector\n   * @returns This vector\n   */\n  scale(s: number): Vector4 {\n    this.x *= s;\n    this.y *= s;\n    this.z *= s;\n    this.w *= s;\n    return this;\n  }\n\n  /**\n   * Clone the value of this vector to an array.\n   * @param out - The array\n   * @param outOffset - The start offset of the array\n   */\n  toArray(out: number[] | Float32Array | Float64Array, outOffset: number = 0) {\n    out[outOffset] = this.x;\n    out[outOffset + 1] = this.y;\n    out[outOffset + 2] = this.z;\n    out[outOffset + 3] = this.w;\n  }\n\n  /**\n   * Creates a clone of this vector.\n   * @returns A clone of this vector\n   */\n  clone(): Vector4 {\n    let ret = new Vector4(this.x, this.y, this.z, this.w);\n    return ret;\n  }\n\n  /**\n   * Clones this vector to the specified vector.\n   * @param out - The specified vector\n   * @returns The specified vector\n   */\n  cloneTo(out: Vector4): Vector4 {\n    out.x = this.x;\n    out.y = this.y;\n    out.z = this.z;\n    out.w = this.w;\n    return out;\n  }\n}\n", "import { IClone } from \"@oasis-engine/design\";\nimport { MathUtil } from \"./MathUtil\";\n\n/**\n * Describes a color in the from of RGBA (in order: R, G, B, A).\n */\nexport class Color implements IClone {\n  /**\n   * Modify a value from the gamma space to the linear space.\n   * @param value - The value in gamma space\n   * @returns The value in linear space\n   */\n  static gammaToLinearSpace(value: number): number {\n    // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_sRGB.txt\n    // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_sRGB_decode.txt\n\n    if (value <= 0.0) return 0.0;\n    else if (value <= 0.04045) return value / 12.92;\n    else if (value < 1.0) return Math.pow((value + 0.055) / 1.055, 2.4);\n    else return Math.pow(value, 2.4);\n  }\n\n  /**\n   * Modify a value from the linear space to the gamma space.\n   * @param value - The value in linear space\n   * @returns The value in gamma space\n   */\n  static linearToGammaSpace(value: number): number {\n    // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_sRGB.txt\n    // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_sRGB_decode.txt\n\n    if (value <= 0.0) return 0.0;\n    else if (value < 0.0031308) return 12.92 * value;\n    else if (value < 1.0) return 1.055 * Math.pow(value, 0.41666) - 0.055;\n    else return Math.pow(value, 0.41666);\n  }\n\n  /**\n   * Determines whether the specified colors are equals.\n   * @param left - The first color to compare\n   * @param right - The second color to compare\n   * @returns True if the specified colors are equals, false otherwise\n   */\n  static equals(left: Color, right: Color): boolean {\n    return (\n      MathUtil.equals(left.r, right.r) &&\n      MathUtil.equals(left.g, right.g) &&\n      MathUtil.equals(left.b, right.b) &&\n      MathUtil.equals(left.a, right.a)\n    );\n  }\n\n  /**\n   * Determines the sum of two colors.\n   * @param left - The first color to add\n   * @param right - The second color to add\n   * @param out - The sum of two colors\n   * @returns The added color\n   */\n  static add(left: Color, right: Color, out: Color): Color {\n    out.r = left.r + right.r;\n    out.g = left.g + right.g;\n    out.b = left.b + right.b;\n    out.a = left.a + right.a;\n\n    return out;\n  }\n\n  /**\n   * Scale a color by the given value.\n   * @param left - The color to scale\n   * @param s - The amount by which to scale the color\n   * @param out - The scaled color\n   * @returns The scaled color\n   */\n  static scale(left: Color, s: number, out: Color): Color {\n    out.r = left.r * s;\n    out.g = left.g * s;\n    out.b = left.b * s;\n    out.a = left.a * s;\n\n    return out;\n  }\n\n  /** The red component of the color, 0~1. */\n  public r: number;\n  /** The green component of the color, 0~1. */\n  public g: number;\n  /** The blue component of the color, 0~1. */\n  public b: number;\n  /** The alpha component of the color, 0~1. */\n  public a: number;\n\n  /**\n   * Constructor of Color.\n   * @param r - The red component of the color\n   * @param g - The green component of the color\n   * @param b - The blue component of the color\n   * @param a - The alpha component of the color\n   */\n  constructor(r: number = 1, g: number = 1, b: number = 1, a: number = 1) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n  }\n\n  /**\n   * Set the value of this color.\n   * @param r - The red component of the color\n   * @param g - The green component of the color\n   * @param b - The blue component of the color\n   * @param a - The alpha component of the color\n   * @returns This color.\n   */\n  setValue(r: number, g: number, b: number, a: number): Color {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n    return this;\n  }\n\n  /**\n   * Determines the sum of this color and the specified color.\n   * @param color - The specified color\n   * @returns The added color\n   */\n  add(color: Color): Color {\n    this.r += color.r;\n    this.g += color.g;\n    this.b += color.b;\n    this.a += color.a;\n\n    return this;\n  }\n\n  /**\n   * Scale this color by the given value.\n   * @param s - The amount by which to scale the color\n   * @returns The scaled color\n   */\n  scale(s: number): Color {\n    this.r *= s;\n    this.g *= s;\n    this.b *= s;\n    this.a *= s;\n\n    return this;\n  }\n\n  /**\n   * Creates a clone of this color.\n   * @returns A clone of this color\n   */\n  clone(): Color {\n    const ret = new Color(this.r, this.g, this.b, this.a);\n    return ret;\n  }\n\n  /**\n   * Clones this color to the specified color.\n   * @param out - The specified color\n   * @returns The specified color\n   */\n  cloneTo(out: Color): Color {\n    out.r = this.r;\n    out.g = this.g;\n    out.b = this.b;\n    out.a = this.a;\n    return out;\n  }\n\n  /**\n   * Modify components (r, g, b) of this color from gamma space to linear space.\n   * @param out - The color in linear space\n   * @returns The color in linear space\n   */\n  toLinear(out: Color): Color {\n    out.r = Color.gammaToLinearSpace(this.r);\n    out.g = Color.gammaToLinearSpace(this.g);\n    out.b = Color.gammaToLinearSpace(this.b);\n    return out;\n  }\n\n  /**\n   * Modify components (r, g, b) of this color from linear space to gamma space.\n   * @param out - The color in gamma space\n   * @returns The color in gamma space\n   */\n  toGamma(out: Color): Color {\n    out.r = Color.linearToGammaSpace(this.r);\n    out.g = Color.linearToGammaSpace(this.g);\n    out.b = Color.linearToGammaSpace(this.b);\n    return out;\n  }\n}\n", "import { IClone } from \"@oasis-engine/design\";\n\n// A 2d rectangle defined by x and y position, width and height.\nexport class Rect implements IClone {\n  /** The x coordinate of the rectangle. */\n  public x: number;\n  /** The y coordinate of the rectangle. */\n  public y: number;\n  /** The width of the rectangle, measured from the x position. */\n  public width: number;\n  /** The height of the rectangle, measured from the y position. */\n  public height: number;\n\n  /**\n   * Constructor of Rect.\n   * @param x - The x coordinate of the rectangle, default 0\n   * @param y - The y coordinate of the rectangle, default 0\n   * @param width - The width of the rectangle, measured from the x position, default 0\n   * @param height - The height of the rectangle, measured from the y position, default 0\n   */\n  constructor(x: number = 0, y: number = 0, width: number = 0, height: number = 0) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * Set the value of this rectangle.\n   * @param x - The x coordinate of the rectangle\n   * @param y - The y coordinate of the rectangle\n   * @param width - The width of the rectangle, measured from the x position\n   * @param height - The height of the rectangle, measured from the y position\n   * @returns This rectangle\n   */\n  setValue(x: number, y: number, width: number, height: number): Rect {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    return this;\n  }\n\n  /**\n   * Creates a clone of this rect.\n   * @returns A clone of this rect\n   */\n  clone(): Rect {\n    return new Rect(this.x, this.y, this.width, this.height);\n  }\n\n  /**\n   * Clones this rect to the specified rect.\n   * @param out - The specified rect\n   * @returns The specified rect\n   */\n  cloneTo(out: Rect): Rect {\n    out.x = this.x;\n    out.y = this.y;\n    out.width = this.width;\n    out.height = this.height;\n    return out;\n  }\n}\n", "import { IClone } from \"@oasis-engine/design\";\nimport { Color } from \"./Color\";\nimport { Vector3 } from \"./Vector3\";\n\n/**\n * Use SH3 to represent irradiance environment maps efficiently, allowing for interactive rendering of diffuse objects under distant illumination.\n * @remarks\n * https://graphics.stanford.edu/papers/envmap/envmap.pdf\n * http://www.ppsloan.org/publications/StupidSH36.pdf\n * https://google.github.io/filament/Filament.md.html#annex/sphericalharmonics\n */\nexport class SphericalHarmonics3 implements IClone {\n  /** The coefficients of SphericalHarmonics3. */\n  coefficients: Float32Array = new Float32Array(27);\n\n  /**\n   * Add light to SphericalHarmonics3.\n   * @param direction - Light direction\n   * @param color - Light color\n   * @param deltaSolidAngle - The delta solid angle of the light\n   */\n  addLight(direction: Vector3, color: Color, deltaSolidAngle: number): void {\n    /**\n     * Implements `EvalSHBasis` from [Projection from Cube maps] in http://www.ppsloan.org/publications/StupidSH36.pdf.\n     *\n     * Basis constants\n     * 0: Math.sqrt(1/(4 * Math.PI))\n     *\n     * 1: -Math.sqrt(3 / (4 * Math.PI))\n     * 2: Math.sqrt(3 / (4 * Math.PI))\n     * 3: -Math.sqrt(3 / (4 * Math.PI))\n     *\n     * 4: Math.sqrt(15 / (4 * Math.PI))\n     * 5: -Math.sqrt(15 / (4 * Math.PI))\n     * 6: Math.sqrt(5 / (16 * Math.PI))\n     * 7: -Math.sqrt(15 / (4 * Math.PI)\uFF09\n     * 8: Math.sqrt(15 / (16 * Math.PI))\n     */\n\n    color.scale(deltaSolidAngle);\n\n    const coe = this.coefficients;\n\n    const { x, y, z } = direction;\n    const { r, g, b } = color;\n\n    const bv0 = 0.282095; // basis0 = 0.886227\n    const bv1 = -0.488603 * y; // basis1 = -0.488603\n    const bv2 = 0.488603 * z; // basis2 = 0.488603\n    const bv3 = -0.488603 * x; // basis3 = -0.488603\n    const bv4 = 1.092548 * (x * y); // basis4 = 1.092548\n    const bv5 = -1.092548 * (y * z); // basis5 = -1.092548\n    const bv6 = 0.315392 * (3 * z * z - 1); // basis6 = 0.315392\n    const bv7 = -1.092548 * (x * z); // basis7 = -1.092548\n    const bv8 = 0.546274 * (x * x - y * y); // basis8 = 0.546274\n\n    (coe[0] += r * bv0), (coe[1] += g * bv0), (coe[2] += b * bv0);\n\n    (coe[3] += r * bv1), (coe[4] += g * bv1), (coe[5] += b * bv1);\n    (coe[6] += r * bv2), (coe[7] += g * bv2), (coe[8] += b * bv2);\n    (coe[9] += r * bv3), (coe[10] += g * bv3), (coe[11] += b * bv3);\n\n    (coe[12] += r * bv4), (coe[13] += g * bv4), (coe[14] += b * bv4);\n    (coe[15] += r * bv5), (coe[16] += g * bv5), (coe[17] += b * bv5);\n    (coe[18] += r * bv6), (coe[19] += g * bv6), (coe[20] += b * bv6);\n    (coe[21] += r * bv7), (coe[22] += g * bv7), (coe[23] += b * bv7);\n    (coe[24] += r * bv8), (coe[25] += g * bv8), (coe[26] += b * bv8);\n  }\n\n  /**\n   * Evaluates the color for the specified direction.\n   * @param direction - Specified direction\n   * @param out - Out color\n   */\n  evaluate(direction: Vector3, out: Color): Color {\n    /**\n     * Equations based on data from: http://ppsloan.org/publications/StupidSH36.pdf\n     *\n     *\n     * Basis constants\n     * 0: Math.sqrt(1/(4 * Math.PI))\n     *\n     * 1: -Math.sqrt(3 / (4 * Math.PI))\n     * 2: Math.sqrt(3 / (4 * Math.PI))\n     * 3: -Math.sqrt(3 / (4 * Math.PI))\n     *\n     * 4: Math.sqrt(15 / (4 * Math.PI)\uFF09\n     * 5: -Math.sqrt(15 / (4 * Math.PI))\n     * 6: Math.sqrt(5 / (16 * Math.PI)\uFF09\n     * 7: -Math.sqrt(15 / (4 * Math.PI)\uFF09\n     * 8: Math.sqrt(15 / (16 * Math.PI)\uFF09\n     *\n     *\n     * Convolution kernel\n     * 0: Math.PI\n     * 1: (2 * Math.PI) / 3\n     * 2: Math.PI / 4\n     */\n\n    const coe = this.coefficients;\n    const { x, y, z } = direction;\n\n    const bv0 = 0.886227; // kernel0 * basis0 = 0.886227\n    const bv1 = -1.023327 * y; // kernel1 * basis1 = -1.023327\n    const bv2 = 1.023327 * z; // kernel1 * basis2 = 1.023327\n    const bv3 = -1.023327 * x; // kernel1 * basis3 = -1.023327\n    const bv4 = 0.858086 * y * x; // kernel2 * basis4 = 0.858086\n    const bv5 = -0.858086 * y * z; // kernel2 * basis5 = -0.858086\n    const bv6 = 0.247708 * (3 * z * z - 1); // kernel2 * basis6 = 0.247708\n    const bv7 = -0.858086 * z * x; // kernel2 * basis7 = -0.858086\n    const bv8 = 0.429042 * (x * x - y * y); // kernel2 * basis8 = 0.429042\n\n    // l0\n    let r = coe[0] * bv0;\n    let g = coe[1] * bv0;\n    let b = coe[2] * bv0;\n\n    // l1\n    r += coe[3] * bv1 + coe[6] * bv2 + coe[9] * bv3;\n    g += coe[4] * bv1 + coe[7] * bv2 + coe[10] * bv3;\n    b += coe[5] * bv1 + coe[8] * bv2 + coe[11] * bv3;\n\n    // l2\n    r += coe[12] * bv4 + coe[15] * bv5 + coe[18] * bv6 + coe[21] * bv7 + coe[24] * bv8;\n    g += coe[13] * bv4 + coe[16] * bv5 + coe[19] * bv6 + coe[22] * bv7 + coe[25] * bv8;\n    b += coe[14] * bv4 + coe[17] * bv5 + coe[20] * bv6 + coe[23] * bv7 + coe[26] * bv8;\n\n    out.setValue(r, g, b, 1.0);\n    return out;\n  }\n\n  /**\n   * Scale the coefficients.\n   * @param s - The amount by which to scale the SphericalHarmonics3\n   */\n  scale(s: number): void {\n    const src = this.coefficients;\n\n    (src[0] *= s), (src[1] *= s), (src[2] *= s);\n    (src[3] *= s), (src[4] *= s), (src[5] *= s);\n    (src[6] *= s), (src[7] *= s), (src[8] *= s);\n    (src[9] *= s), (src[10] *= s), (src[11] *= s);\n    (src[12] *= s), (src[13] *= s), (src[14] *= s);\n    (src[15] *= s), (src[16] *= s), (src[17] *= s);\n    (src[18] *= s), (src[19] *= s), (src[20] *= s);\n    (src[21] *= s), (src[22] *= s), (src[23] *= s);\n    (src[24] *= s), (src[25] *= s), (src[26] *= s);\n  }\n\n  /**\n   * Set the value of this spherical harmonics by an array.\n   * @param array - The array\n   * @param offset - The start offset of the array\n   */\n  setValueByArray(array: ArrayLike<number>, offset: number = 0): void {\n    const s = this.coefficients;\n\n    (s[0] = array[offset]), (s[1] = array[1 + offset]), (s[2] = array[2 + offset]);\n    (s[3] = array[3 + offset]), (s[4] = array[4 + offset]), (s[5] = array[5 + offset]);\n    (s[6] = array[6 + offset]), (s[7] = array[7 + offset]), (s[8] = array[8 + offset]);\n    (s[9] = array[9 + offset]), (s[10] = array[10 + offset]), (s[11] = array[11 + offset]);\n    (s[12] = array[12 + offset]), (s[13] = array[13 + offset]), (s[14] = array[14 + offset]);\n    (s[15] = array[15 + offset]), (s[16] = array[16 + offset]), (s[17] = array[17 + offset]);\n    (s[18] = array[18 + offset]), (s[19] = array[19 + offset]), (s[20] = array[20 + offset]);\n    (s[21] = array[21 + offset]), (s[22] = array[22 + offset]), (s[23] = array[23 + offset]);\n    (s[24] = array[24 + offset]), (s[25] = array[25 + offset]), (s[26] = array[26 + offset]);\n  }\n\n  /**\n   * Clone the value of this spherical harmonics to an array.\n   * @param out - The array\n   * @param outOffset - The start offset of the array\n   */\n  toArray(out: number[] | Float32Array | Float64Array, outOffset: number = 0): void {\n    const s = this.coefficients;\n\n    (out[0 + outOffset] = s[0]), (out[1 + outOffset] = s[1]), (out[2 + outOffset] = s[2]);\n\n    (out[3 + outOffset] = s[3]), (out[4 + outOffset] = s[4]), (out[5 + outOffset] = s[5]);\n    (out[6 + outOffset] = s[6]), (out[7 + outOffset] = s[7]), (out[8 + outOffset] = s[8]);\n    (out[9 + outOffset] = s[9]), (out[10 + outOffset] = s[10]), (out[11 + outOffset] = s[11]);\n\n    (out[12 + outOffset] = s[12]), (out[13 + outOffset] = s[13]), (out[14 + outOffset] = s[14]);\n    (out[15 + outOffset] = s[15]), (out[16 + outOffset] = s[16]), (out[17 + outOffset] = s[17]);\n    (out[18 + outOffset] = s[18]), (out[19 + outOffset] = s[19]), (out[20 + outOffset] = s[20]);\n    (out[21 + outOffset] = s[21]), (out[22 + outOffset] = s[22]), (out[23 + outOffset] = s[23]);\n    (out[24 + outOffset] = s[24]), (out[25 + outOffset] = s[25]), (out[26 + outOffset] = s[26]);\n  }\n\n  /**\n   * Creates a clone of this SphericalHarmonics3.\n   * @returns A clone of this SphericalHarmonics3\n   */\n  clone(): SphericalHarmonics3 {\n    const v = new SphericalHarmonics3();\n    this.cloneTo(v);\n\n    return v;\n  }\n\n  /**\n   * Clones this SphericalHarmonics3 to the specified SphericalHarmonics3.\n   * @param out - The specified SphericalHarmonics3\n   * @returns The specified SphericalHarmonics3\n   */\n  cloneTo(out: SphericalHarmonics3): void {\n    this.toArray(out.coefficients);\n  }\n}\n", "type PromiseNotifier = (progress: number) => void;\n\n/**\n * Asset Promise Status\n */\nexport enum AssetPromiseStatus {\n  /** Success. */\n  Success,\n  /** Pending. */\n  Pending,\n  /** Failed. */\n  Failed\n}\n/**\n * Asset Loading Promise.\n */\nexport class AssetPromise<T> extends Promise<T> {\n  static all<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n    values: readonly [\n      T1 | PromiseLike<T1>,\n      T2 | PromiseLike<T2>,\n      T3 | PromiseLike<T3>,\n      T4 | PromiseLike<T4>,\n      T5 | PromiseLike<T5>,\n      T6 | PromiseLike<T6>,\n      T7 | PromiseLike<T7>,\n      T8 | PromiseLike<T8>,\n      T9 | PromiseLike<T9>,\n      T10 | PromiseLike<T10>\n    ]\n  ): AssetPromise<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;\n\n  static all<T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n    values: readonly [\n      T1 | PromiseLike<T1>,\n      T2 | PromiseLike<T2>,\n      T3 | PromiseLike<T3>,\n      T4 | PromiseLike<T4>,\n      T5 | PromiseLike<T5>,\n      T6 | PromiseLike<T6>,\n      T7 | PromiseLike<T7>,\n      T8 | PromiseLike<T8>,\n      T9 | PromiseLike<T9>\n    ]\n  ): AssetPromise<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;\n\n  static all<T1, T2, T3, T4, T5, T6, T7, T8>(\n    values: readonly [\n      T1 | PromiseLike<T1>,\n      T2 | PromiseLike<T2>,\n      T3 | PromiseLike<T3>,\n      T4 | PromiseLike<T4>,\n      T5 | PromiseLike<T5>,\n      T6 | PromiseLike<T6>,\n      T7 | PromiseLike<T7>,\n      T8 | PromiseLike<T8>\n    ]\n  ): AssetPromise<[T1, T2, T3, T4, T5, T6, T7, T8]>;\n\n  static all<T1, T2, T3, T4, T5, T6, T7>(\n    values: readonly [\n      T1 | PromiseLike<T1>,\n      T2 | PromiseLike<T2>,\n      T3 | PromiseLike<T3>,\n      T4 | PromiseLike<T4>,\n      T5 | PromiseLike<T5>,\n      T6 | PromiseLike<T6>,\n      T7 | PromiseLike<T7>\n    ]\n  ): AssetPromise<[T1, T2, T3, T4, T5, T6, T7]>;\n\n  static all<T1, T2, T3, T4, T5, T6>(\n    values: readonly [\n      T1 | PromiseLike<T1>,\n      T2 | PromiseLike<T2>,\n      T3 | PromiseLike<T3>,\n      T4 | PromiseLike<T4>,\n      T5 | PromiseLike<T5>,\n      T6 | PromiseLike<T6>\n    ]\n  ): AssetPromise<[T1, T2, T3, T4, T5, T6]>;\n\n  static all<T1, T2, T3, T4, T5>(\n    values: readonly [\n      T1 | PromiseLike<T1>,\n      T2 | PromiseLike<T2>,\n      T3 | PromiseLike<T3>,\n      T4 | PromiseLike<T4>,\n      T5 | PromiseLike<T5>\n    ]\n  ): AssetPromise<[T1, T2, T3, T4, T5]>;\n\n  static all<T1, T2, T3, T4>(\n    values: readonly [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>]\n  ): AssetPromise<[T1, T2, T3, T4]>;\n\n  static all<T1, T2, T3>(\n    values: readonly [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]\n  ): AssetPromise<[T1, T2, T3]>;\n\n  static all<T1, T2>(values: readonly [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): AssetPromise<[T1, T2]>;\n\n  static all<T>(values: readonly (T | PromiseLike<T>)[]): AssetPromise<T[]>;\n\n  /**\n   * Return a new resource Promise through the provided asset promise collection.\n   * The resolved of the new AssetPromise will be triggered when all the Promises in the provided set are completed.\n   * @param - AssetPromise Collection\n   * @returns AssetPromise\n   */\n  static all<T>(promises: T | PromiseLike<T>[]): AssetPromise<T[]> {\n    return new AssetPromise((resolve, reject, setProgress) => {\n      if (!Array.isArray(promises)) {\n        return resolve([promises]);\n      }\n\n      let completed = 0;\n      let total = promises.length;\n      let results = new Array<T>(total);\n\n      promises.forEach((value, index) => {\n        Promise.resolve(value)\n          .then((result) => {\n            results[index] = result;\n\n            completed += 1;\n            setProgress(completed / total);\n\n            if (completed == total) {\n              resolve(results);\n            }\n          })\n          .catch((err) => reject(err));\n      });\n    });\n  }\n\n  private _status: AssetPromiseStatus;\n  private _progress: number;\n  private _reject: (reason?: any) => void;\n  private _listeners: Set<PromiseNotifier>;\n\n  /**\n   * Current promise state.\n   */\n  get status(): AssetPromiseStatus {\n    return this._status;\n  }\n\n  /**\n   * Loading progress.\n   */\n  get progress(): number {\n    return this._progress;\n  }\n\n  /**\n   * Progress callback.\n   * @param callback - Progress callback\n   * @returns Asset Promise\n   */\n  onProgress(callback: (progress?: number) => any): AssetPromise<T> {\n    this._listeners.add(callback);\n    return this;\n  }\n\n  /**\n   * Cancel promise request.\n   * @returns Asset promise\n   */\n  cancel(): AssetPromise<T> {\n    if (this._status !== AssetPromiseStatus.Pending) {\n      return this;\n    }\n    this._reject(\"Promise Canceled\");\n    return this;\n  }\n\n  /**\n   * Create an asset loading Promise.\n   * @param executor - A callback used to initialize the promise. This callback is passed two arguments:\n   * a resolve callback used to resolve the promise with a value or the result of another promise,\n   * and a reject callback used to reject the promise with a provided reason or error.\n   * and a setProgress callback used to set promise progress with a percent.\n   */\n  constructor(\n    executor: (\n      resolve: (value?: T | PromiseLike<T>) => void,\n      reject?: (reason?: any) => void,\n      setProgress?: PromiseNotifier\n    ) => void\n  ) {\n    let newReject: (reason?: any) => void;\n\n    const setProgress = (progress: number) => {\n      if (progress <= this._progress) {\n        return;\n      }\n      this._progress = progress;\n\n      for (const listener of this._listeners) {\n        listener(progress);\n      }\n    };\n\n    super((resolve, reject) => {\n      newReject = (reason?: any) => {\n        // Add it to the micro task to avoid reporting an error when calling this directly.\n        Promise.resolve().then(() => {\n          this._status = AssetPromiseStatus.Failed;\n          reject(reason);\n        });\n      };\n      executor(\n        (value: T) => {\n          // Add it to the micro task to avoid reporting an error when calling this directly.\n          Promise.resolve().then(() => {\n            setProgress(1);\n            this._status = AssetPromiseStatus.Success;\n            resolve(value);\n          });\n        },\n        newReject,\n        (progress: number) => {\n          // Add it to the micro task to avoid reporting an error when calling this directly\n          Promise.resolve().then(() => {\n            setProgress(progress);\n          });\n        }\n      );\n    });\n    this._reject = newReject;\n    this._listeners = new Set();\n    this._progress = 0;\n    this._status = AssetPromiseStatus.Pending;\n  }\n}\n", "export const Util = {\n  isArray:\n    \"isArray\" in Array\n      ? Array.isArray\n      : (value: any): boolean => {\n          return toString.call(value) === \"[object Array]\";\n        },\n  isArrayLike(x: any): boolean {\n    return !!x && typeof x.length === \"number\" && typeof x !== \"function\";\n  },\n  clone<T>(obj: T): T {\n    if (typeof obj !== \"object\" || obj === null) {\n      return obj;\n    }\n    let rst;\n    if (Util.isArrayLike(obj)) {\n      rst = (obj as any).slice();\n      for (let i = 0, l = (obj as any).length; i < l; i++) {\n        rst[i] = Util.clone(obj[i]);\n      }\n    } else {\n      rst = {};\n      for (const k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          rst[k] = Util.clone(obj[k]);\n        }\n      }\n    }\n\n    return rst;\n  },\n\n  downloadBlob(blob: Blob, fileName: string = \"\") {\n    if (navigator && navigator.msSaveBlob) {\n      navigator.msSaveBlob(blob, fileName);\n      return;\n    }\n\n    let url = window.URL.createObjectURL(blob);\n    let a = document.createElement(\"a\");\n    document.body.appendChild(a);\n    a.style.display = \"none\";\n    a.href = url;\n    a.download = fileName;\n    a.addEventListener(\"click\", () => {\n      if (a.parentElement) {\n        a.parentElement.removeChild(a);\n      }\n    });\n    a.click();\n    window.URL.revokeObjectURL(url);\n  }\n};\n\nexport const isArrayLike = <T>(x: any): x is ArrayLike<T> =>\n  x && typeof x.length === \"number\" && typeof x !== \"function\";\n\n/**\n * Fastly remove an element from array.\n * @param array - Array\n * @param item - Element\n */\nexport function removeFromArray(array: any[], item: any): boolean {\n  const index = array.indexOf(item);\n  if (index < 0) {\n    return false;\n  }\n  const last = array.length - 1;\n  if (index !== last) {\n    const end = array[last];\n    array[index] = end;\n  }\n  array.length--;\n  return true;\n}\n\nexport function ObjectValues(obj: any) {\n  return Object.keys(obj).map((key: any) => obj[key]);\n}\n", "import { AssetPromise } from \"./AssetPromise\";\nimport { LoadItem } from \"./LoadItem\";\nimport { RefObject } from \"./RefObject\";\nimport { Engine } from \"..\";\nimport { Loader } from \"./Loader\";\nimport { AssetType } from \"./AssetType\";\nimport { ObjectValues } from \"../base/Util\";\n\n/**\n * ResourceManager\n */\nexport class ResourceManager {\n  /** Loader collection. */\n  private static _loaders: { [key: number]: Loader<any> } = {};\n  private static _extTypeMapping: { [key: string]: string } = {};\n\n  /**\n   * @internal\n   */\n  static _addLoader(type: string, loader: Loader<any>, extnames: string[]) {\n    this._loaders[type] = loader;\n    for (let i = 0, len = extnames.length; i < len; i++) {\n      this._extTypeMapping[extnames[i]] = type;\n    }\n  }\n\n  private static _getTypeByUrl(url: string): string {\n    const path = url.split(\"?\")[0];\n    return this._extTypeMapping[path.substring(path.lastIndexOf(\".\") + 1)];\n  }\n\n  /** The number of retries after failing to load assets. */\n  retryCount: number = 1;\n  /** Retry delay time after failed to load assets, in milliseconds. */\n  retryInterval: number = 0;\n  /** The default timeout period for loading assets, in milliseconds. */\n  timeout: number = 20000;\n\n  /** Asset path pool, key is asset ID, value is asset path */\n  private _assetPool: { [key: number]: string } = Object.create(null);\n  /** Asset pool, the key is the asset path and the value is the asset. */\n  private _assetUrlPool: { [key: string]: Object } = Object.create(null);\n  /** Reference counted object pool, key is the object ID, and reference counted objects are put into this pool. */\n  private _refObjectPool: { [key: number]: RefObject } = Object.create(null);\n  /** Loading assets. */\n  private _loadingPromises: { [url: string]: AssetPromise<any> } = {};\n\n  /**\n   * Create a ResourceManager.\n   * @param engine - Engine to which the current ResourceManager belongs\n   */\n  constructor(public readonly engine: Engine) {}\n\n  /**\n   * Load asset asynchronously through the path.\n   * @param path - Path\n   * @returns Asset promise\n   */\n  load<T>(path: string): AssetPromise<T>;\n\n  /**\n   * Load asset collection asynchronously through urls.\n   * @param paths - Path collections\n   * @returns Asset Promise\n   */\n  load(paths: string[]): AssetPromise<Object[]>;\n\n  /**\n   * Load the asset asynchronously by asset item information.\n   * @param assetItem - AssetItem\n   * @returns AssetPromise\n   */\n  load<T>(assetItem: LoadItem): AssetPromise<T>;\n\n  /**\n   * Load the asset collection asynchronously by loading the information collection.\n   * @param assetItems - Asset collection\n   * @returns AssetPromise\n   */\n  load(assetItems: LoadItem[]): AssetPromise<Object[]>;\n\n  load<T>(assetInfo: string | LoadItem | (LoadItem | string)[]): AssetPromise<T | Object[]> {\n    // single item\n    if (!Array.isArray(assetInfo)) {\n      return this._loadSingleItem(assetInfo);\n    }\n    // multi items\n    const promises = assetInfo.map((item) => this._loadSingleItem<T>(item));\n    return AssetPromise.all(promises);\n  }\n\n  /**\n   * Cancel all assets that have not finished loading.\n   */\n  cancelNotLoaded(): void;\n\n  /**\n   * Cancel assets whose url has not finished loading.\n   * @param url - Resource url\n   */\n  cancelNotLoaded(url: string): void;\n\n  /**\n   * Cancel the incompletely loaded assets in urls.\n   * @param urls - Resource urls\n   */\n  cancelNotLoaded(urls: string[]): void;\n\n  cancelNotLoaded(url?: string | string[]): void {\n    if (!url) {\n      ObjectValues(this._loadingPromises).forEach((promise) => {\n        promise.cancel();\n      });\n    } else if (typeof url === \"string\") {\n      this._loadingPromises[url]?.cancel();\n    } else {\n      url.forEach((p) => {\n        this._loadingPromises[p]?.cancel();\n      });\n    }\n  }\n\n  /**\n   * Garbage collection will release resource objects managed by reference counting.\n   * @remarks The release principle is that it is not referenced by the components, including direct and indirect reference.\n   */\n  gc(): void {\n    const objects = ObjectValues(this._refObjectPool);\n    for (let i = 0, len = objects.length; i < len; i++) {\n      if (!objects[i].isGCIgnored) {\n        objects[i].destroy();\n      }\n    }\n  }\n\n  /**\n   * Get asset url from instanceId.\n   * @param instanceId - Engine instance id\n   * @returns Asset url\n   */\n  getAssetPath(instanceId: number): string {\n    return this._assetPool[instanceId];\n  }\n\n  /**\n   * @internal\n   */\n  _addAsset(path: string, asset: RefObject): void {\n    this._assetPool[asset.instanceId] = path;\n    this._assetUrlPool[path] = asset;\n  }\n\n  /**\n   * @internal\n   */\n  _deleteAsset(asset: RefObject): void {\n    const id = asset.instanceId;\n    const path = this._assetPool[id];\n    if (path) {\n      delete this._assetPool[id];\n      delete this._assetUrlPool[path];\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _addRefObject(id: number, asset: RefObject): void {\n    this._refObjectPool[id] = asset;\n  }\n\n  /**\n   * @internal\n   */\n  _deleteRefObject(id: number): void {\n    delete this._refObjectPool[id];\n  }\n\n  private _assignDefaultOptions(assetInfo: LoadItem): LoadItem | never {\n    assetInfo.type = assetInfo.type ?? ResourceManager._getTypeByUrl(assetInfo.url);\n    if (assetInfo.type === undefined) {\n      throw `asset type should be specified: ${assetInfo.url}`;\n    }\n    assetInfo.retryCount = assetInfo.retryCount ?? this.retryCount;\n    assetInfo.timeout = assetInfo.timeout ?? this.timeout;\n    assetInfo.retryInterval = assetInfo.retryInterval ?? this.retryInterval;\n    assetInfo.url = assetInfo.url ?? assetInfo.urls.join(\",\");\n    return assetInfo;\n  }\n\n  private _loadSingleItem<T>(item: LoadItem | string): AssetPromise<T> {\n    const info = this._assignDefaultOptions(typeof item === \"string\" ? { url: item } : item);\n    const url = info.url;\n    // has cache\n    if (this._assetUrlPool[url]) {\n      return new AssetPromise((resolve) => {\n        resolve(this._assetUrlPool[url] as T);\n      });\n    }\n    // loading\n    if (this._loadingPromises[url]) {\n      return this._loadingPromises[info.url];\n    }\n    const loader = ResourceManager._loaders[info.type];\n    const promise = loader.load(info, this);\n    this._loadingPromises[url] = promise;\n    promise\n      .then((res) => {\n        if (loader.useCache) this._addAsset(url, res);\n        delete this._loadingPromises[url];\n      })\n      .catch(() => {});\n    return promise;\n  }\n}\n\n/**\n * Declare ResourceLoader's decorator.\n * @param assetType - Type of asset\n * @param extnames - Name of file extension\n */\nexport function resourceLoader(assetType: string, extnames: string[], useCache: boolean = true) {\n  return <T extends Loader<any>>(Target: { new (useCache: boolean): T }) => {\n    const loader = new Target(useCache);\n    ResourceManager._addLoader(assetType, loader, extnames);\n  };\n}\n", "import { EventDispatcher } from \"./EventDispatcher\";\n\nexport type Listener = ((e: Event) => any) & { once?: boolean };\n\n/** Event Object. * @class */\nexport class Event {\n  get propagationStopped(): boolean {\n    return this._propagationStopped;\n  }\n\n  get target(): EventDispatcher {\n    return this._target;\n  }\n\n  set target(t) {\n    this._target = t;\n  }\n\n  get timeStamp(): number {\n    return this._timeStamp;\n  }\n\n  get currentTarget(): EventDispatcher {\n    return this._currentTarget;\n  }\n\n  set currentTarget(t) {\n    this._currentTarget = t;\n  }\n\n  get bubbles(): boolean {\n    return this._bubbles;\n  }\n\n  get type(): string | number {\n    return this._type;\n  }\n\n  public data: any;\n\n  private _timeStamp: number;\n\n  private _target: EventDispatcher;\n\n  private _currentTarget: any;\n\n  private _bubbles: boolean;\n\n  private _propagationStopped: boolean;\n\n  private _type: string | number;\n\n  constructor(type: string | number, target: EventDispatcher = null, data: any = {}, bubbles: boolean = true) {\n    this._timeStamp = new Date().getTime();\n    this._target = target;\n    this.data = data;\n    this._currentTarget = null;\n    this._bubbles = bubbles;\n    this._propagationStopped = false;\n    this._type = type;\n  }\n\n  public stopPropagation(): void {\n    this._propagationStopped = true;\n  }\n}\n", "/**\n * Clone mode.\n */\nexport enum CloneMode {\n  /** Ignore clone. */\n  Ignore,\n  /** Assignment clone. */\n  Assignment,\n  /** Shallow clone. */\n  Shallow,\n  /** Deep clone. */\n  Deep\n}\n", "import { IClone } from \"@oasis-engine/design\";\nimport { CloneMode } from \"./enums/CloneMode\";\n\ntype TypeArray =\n  | Uint8Array\n  | Uint16Array\n  | Uint32Array\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | Float32Array\n  | Float64Array;\n\n/**\n * Property decorator, ignore the property when cloning.\n */\nexport function ignoreClone(target: Object, propertyKey: string): void {\n  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Ignore);\n}\n\n/**\n * Property decorator, assign value to the property when cloning.\n *\n * @remarks\n * If it's a primitive type, the value will be copied.\n * If it's a class type, the reference will be copied.\n */\nexport function assignmentClone(target: Object, propertyKey: string): void {\n  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Assignment);\n}\n\n/**\n * Property decorator, shallow clone the property when cloning.\n * After cloning, it will keep its own reference independent, and use the method of assignment to clone all its internal properties.\n * if the internal property is a primitive type, the value will be copied, if the internal property is a reference type, its reference address will be copied.\u3002\n *\n * @remarks\n * Applicable to Object, Array, TypedArray and Class types.\n */\nexport function shallowClone(target: Object, propertyKey: string): void {\n  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Shallow);\n}\n\n/**\n * Property decorator, deep clone the property when cloning.\n * After cloning, it will maintain its own reference independence, and all its internal deep properties will remain completely independent.\n *\n * @remarks\n * Applicable to Object, Array, TypedArray and Class types.\n * If Class is encountered during the deep cloning process, the custom cloning function of the object will be called first.\n * Custom cloning requires the object to implement the IClone interface.\n */\nexport function deepClone(target: Object, propertyKey: string): void {\n  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Deep);\n}\n\n/**\n * @internal\n * Clone manager.\n */\nexport class CloneManager {\n  /** @internal */\n  static _subCloneModeMap = new Map<Object, Object>();\n  /** @internal */\n  static _cloneModeMap = new Map<Object, Object>();\n\n  private static _objectType = Object.getPrototypeOf(Object);\n\n  /**\n   * Register clone mode.\n   * @param target - Clone target\n   * @param propertyKey - Clone property name\n   * @param mode - Clone mode\n   */\n  static registerCloneMode(target: Object, propertyKey: string, mode: CloneMode): void {\n    let targetMap = CloneManager._subCloneModeMap.get(target.constructor);\n    if (!targetMap) {\n      targetMap = Object.create(null);\n      CloneManager._subCloneModeMap.set(target.constructor, targetMap);\n    }\n    targetMap[propertyKey] = mode;\n  }\n\n  /**\n   * Get the clone mode according to the prototype chain.\n   */\n  static getCloneMode(type: Function): Object {\n    let cloneModes = CloneManager._cloneModeMap.get(type);\n    if (!cloneModes) {\n      cloneModes = Object.create(null);\n      CloneManager._cloneModeMap.set(type, cloneModes);\n      const objectType = CloneManager._objectType;\n      const cloneModeMap = CloneManager._subCloneModeMap;\n      while (type !== objectType) {\n        const subCloneModes = cloneModeMap.get(type);\n        if (subCloneModes) {\n          Object.assign(cloneModes, subCloneModes);\n        }\n        type = Object.getPrototypeOf(type);\n      }\n    }\n    return cloneModes;\n  }\n\n  /**\n   * Deep clone the object.\n   * @param source - Clone source\n   * @param target - Clone target\n   */\n  static deepCloneObject(source: Object, target: Object): void {\n    const type = source.constructor;\n    switch (type) {\n      case Uint8Array:\n      case Uint16Array:\n      case Uint32Array:\n      case Int8Array:\n      case Int16Array:\n      case Int32Array:\n      case Float32Array:\n      case Float64Array:\n        // Type array clone.\n        (<TypeArray>target).set(<TypeArray>source);\n        break;\n      case Array:\n        // Array clone.\n        for (let i = 0, n = (<[]>source).length; i < n; i++) {\n          CloneManager._deepCloneObjectItem(source, target, i);\n        }\n        break;\n      default:\n        const customSource = <IClone>source;\n        if (customSource.clone && customSource.cloneTo) {\n          // Custom clone.\n          customSource.cloneTo(target);\n        } else {\n          // Object or other class not implements custom clone.\n          const keys = Object.keys(source);\n          for (let i = 0, n = keys.length; i < n; i++) {\n            CloneManager._deepCloneObjectItem(source, target, keys[i]);\n          }\n        }\n    }\n  }\n\n  private static _deepCloneObjectItem(source: object, target: object, k: number | string): void {\n    const sourceItem = source[k];\n    if (sourceItem instanceof Object) {\n      const itemType = (<Object>sourceItem).constructor;\n      switch (itemType) {\n        case Uint8Array:\n        case Uint16Array:\n        case Uint32Array:\n        case Int8Array:\n        case Int16Array:\n        case Int32Array:\n        case Float32Array:\n        case Float64Array:\n          // Type array clone.\n          const sourceTypeArrayItem = <TypeArray>sourceItem;\n          let targetTypeArrayItem = <TypeArray>target[k];\n          if (targetTypeArrayItem == null) {\n            target[k] = sourceTypeArrayItem.slice();\n          } else {\n            targetTypeArrayItem.set(sourceTypeArrayItem);\n          }\n          break;\n        case Array:\n          // Array clone.\n          const sourceArrayItem = <[]>sourceItem;\n          let targetArrayItem = <[]>target[k];\n          if (targetArrayItem == null) {\n            target[k] = new Array(sourceArrayItem.length);\n          } else {\n            targetArrayItem.length = sourceArrayItem.length;\n          }\n          CloneManager.deepCloneObject(sourceArrayItem, targetArrayItem);\n          break;\n        default:\n          if (sourceItem.clone && sourceItem.cloneTo) {\n            // Custom clone.\n            let sourceCustomItem = <IClone>sourceItem;\n            let targetCustomItem = <IClone>target[k];\n            if (targetCustomItem) {\n              sourceCustomItem.cloneTo(targetCustomItem);\n            } else {\n              target[k] = sourceCustomItem.clone();\n            }\n          } else {\n            // Object or other class not implements custom clone.\n            let targetItem = <Object>target[k];\n            targetItem == null && (target[k] = targetItem = new sourceItem.constructor());\n            CloneManager.deepCloneObject(sourceItem, targetItem);\n            break;\n          }\n      }\n    } else {\n      // Null or undefined and primitive type.\n      target[k] = sourceItem;\n    }\n  }\n}\n", "import { ignoreClone } from \"../clone/CloneManager\";\nimport { Engine } from \"../Engine\";\n\n/**\n * EngineObject.\n */\nexport abstract class EngineObject {\n  private static _instanceIdCounter: number = 0;\n\n  /** Engine unique id. */\n  @ignoreClone\n  readonly instanceId: number = ++EngineObject._instanceIdCounter;\n\n  /** Engine to which the object belongs. */\n  @ignoreClone\n  protected _engine: Engine;\n\n  /**\n   * Get the engine which the object belongs.\n   */\n  get engine(): Engine {\n    return this._engine;\n  }\n\n  constructor(engine: Engine) {\n    this._engine = engine;\n  }\n}\n", "import { EngineObject } from \"./EngineObject\";\nimport { Event } from \"./Event\";\nimport { ignoreClone } from \"../clone/CloneManager\";\n\n/**\n * EventDispatcher, which can be inherited as a base class.\n */\nexport class EventDispatcher extends EngineObject {\n  @ignoreClone\n  private _evts = Object.create(null);\n  private _evtCount = 0;\n\n  /**\n   * Determine whether there is event listening.\n   * @param event - Event name\n   * @returns Returns whether there is a corresponding event\n   */\n  hasEvent(event: string): boolean {\n    return this._evts[event] != null;\n  }\n\n  /**\n   * Returns the names of all registered events.\n   * @returns All event names\n   */\n  eventNames(): string[] {\n    if (this._evtCount === 0) return [];\n    return Object.keys(this._evts);\n  }\n\n  /**\n   * Returns the number of listeners with the specified event name.\n   * @param event - Event name\n   * @returns The count of listeners\n   */\n  listenerCount(event: string): number {\n    const listeners = this._evts[event];\n\n    if (!listeners) return 0;\n    if (listeners.fn) return 1;\n    return listeners.length;\n  }\n\n  /**\n   * Dispatch the event with the specified event name.\n   * @param event - Event name\n   * @param data - Data\n   * @returns - Whether the dispatching is successful\n   */\n  dispatch(event: string, data?: any): boolean {\n    if (!this._evts[event]) {\n      return false;\n    }\n\n    const listeners = this._evts[event];\n\n    if (listeners.fn) {\n      if (listeners.once) this.removeEventListener(event, listeners.fn);\n      listeners.fn(data);\n    } else {\n      const l = listeners.length;\n      for (let i = 0; i < l; i++) {\n        if (listeners[i].once) this.removeEventListener(event, listeners[i].fn);\n        listeners[i].fn(data);\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Add a listener/\n   * @param event - Event name\n   * @param fn - Function\n   * @returns This\n   */\n  on(event: string, fn: Function): EventDispatcher {\n    return this.addEventListener(event, fn);\n  }\n\n  /**\n   * Add a one-time listener.\n   * @param event - Event name\n   * @param fn - Function\n   * @returns This\n   */\n  once(event: string, fn: Function): EventDispatcher {\n    return this.addEventListener(event, fn, true);\n  }\n\n  /**\n   * @deprecated Use `on/once` instead.\n   * Add a listener function with the specified event name.\n   * @param event - Event name\n   * @param fn - Function\n   * @param once - Is it a one-time listener\n   * @returns this\n   */\n  addEventListener(event: string, fn: Function, once?: boolean): EventDispatcher {\n    const listener = { fn, once };\n    const events = this._evts;\n    if (!events[event]) {\n      events[event] = listener;\n      this._evtCount++;\n    } else if (!events[event].fn) {\n      events[event].push(listener);\n    } else {\n      events[event] = [events[event], listener];\n    }\n    return this;\n  }\n\n  /**\n   * Remove the event listener(s) of the specified event name.\n   * @param event - Event name\n   * @param fn - Function, If is undefined, delete all corresponding event listeners.\n   */\n  off(event: string, fn?: Function): EventDispatcher {\n    if (!this._evts[event]) return this;\n    if (!fn) {\n      this._clearEvent(event);\n      return this;\n    }\n\n    const listeners = this._evts[event];\n\n    if (listeners.fn && listeners.fn === fn) {\n      this._clearEvent(event);\n    } else {\n      const index = listeners.indexOf(fn);\n      if (index > -1) {\n        const temp = listeners[listeners.length - 1];\n        listeners[index] = temp;\n        listeners.length--;\n        if (listeners.length === 1) {\n          this._evts[event] = listeners[0];\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * @deprecated Use `off` instead.\n   * Remove the event listener(s) of the specified event name.\n   * @param event - Event name\n   * @param fn - Function, If is undefined, delete all corresponding event listeners.\n   */\n  removeEventListener(event: string, fn?: Function): EventDispatcher {\n    return this.off(event, fn);\n  }\n\n  /**\n   * Remove all event listeners.\n   * @param event - Event name, delete all events if not passed\n   */\n  removeAllEventListeners(event?: string): void {\n    if (event) {\n      if (this._evts[event]) this._clearEvent(event);\n    } else {\n      this._evts = Object.create(null);\n      this._evtCount = 0;\n    }\n  }\n\n  /**\n   * @deprecated Use `dispatch` instead.\n   */\n  trigger(e: Event) {\n    this.dispatch(e.type as string, e.data);\n  }\n\n  private _clearEvent(event: string) {\n    if (--this._evtCount === 0) {\n      this._evts = Object.create(null);\n    } else {\n      delete this._evts[event];\n    }\n  }\n}\n", "/**\n * @class\n * @private\n */\n/* tslint:disable */\nconst noop = (message?: any, ...optionalParams: any[]) => {};\nconst debug = console.log.bind(console);\nconst info = console.info.bind(console);\nconst warn = console.warn.bind(console);\nconst error = console.error.bind(console);\n\nexport const Logger = {\n  debug: noop,\n  info: noop,\n  warn: noop,\n  error: noop,\n  isEnabled: false,\n\n  /** Turn on log */\n  enable() {\n    this.debug = debug;\n    this.info = info;\n    this.warn = warn;\n    this.error = error;\n    this.isEnabled = true;\n  },\n\n  /** Turn off log */\n  disable() {\n    this.debug = noop;\n    this.info = noop;\n    this.warn = noop;\n    this.error = noop;\n    this.isEnabled = false;\n  }\n};\n", "/**\n * Tools for calculating the time per frame.\n */\nexport class Time {\n  private _clock: { now: () => number };\n\n  private _timeScale: number;\n\n  private _deltaTime: number;\n\n  private _startTime: number;\n\n  private _lastTickTime: number;\n  /**\n   * Constructor of the Time.\n   */\n  constructor() {\n    this._clock = performance ? performance : Date;\n\n    this._timeScale = 1.0;\n    this._deltaTime = 0.0001;\n\n    const now = this._clock.now();\n    this._startTime = now;\n    this._lastTickTime = now;\n  }\n\n  reset() {\n    this._lastTickTime = this._clock.now();\n  }\n\n  /**\n   * Current Time\n   */\n  get nowTime(): number {\n    return this._clock.now();\n  }\n\n  /**\n   * Time between two ticks\n   */\n  get deltaTime(): number {\n    return this._deltaTime;\n  }\n\n  /**\n   * Scaled delta time.\n   */\n  get timeScale(): number {\n    return this._timeScale;\n  }\n  set timeScale(s) {\n    this._timeScale = s;\n  }\n\n  /**\n   * Unscaled delta time.\n   */\n  get unscaledDeltaTime(): number {\n    return this._deltaTime / this._timeScale;\n  }\n\n  /**\n   * The elapsed time, after the clock is initialized.\n   */\n  get timeSinceStartup(): number {\n    return this.nowTime - this._startTime;\n  }\n\n  /**\n   * Call every frame, update delta time and other data.\n   */\n  public tick(): void {\n    const now = this.nowTime;\n    this._deltaTime = (now - this._lastTickTime) * this._timeScale;\n    this._lastTickTime = now;\n  }\n}\n", "/**\n * Data type enumeration\n */\nexport enum DataType {\n  /** Float */\n  FLOAT = 5126, // gl.FLOAT\n  /** Floating-point two-dimensional vector */\n  FLOAT_VEC2 = 35664, // gl.FLOAT_VEC2\n  /** Floating-point three-dimensional vector */\n  FLOAT_VEC3 = 35665, // gl.FLOAT_VEC3\n  /** Floating-point four-dimensional vector */\n  FLOAT_VEC4 = 35666, // gl.FLOAT_VEC4\n\n  /** Integer */\n  INT = 5124, // gl.INT\n  /** Integer two-dimensional vector */\n  INT_VEC2 = 35667, // gl.INT_VEC2\n  /** Integer three-dimensional vector */\n  INT_VEC3 = 35668, // gl.INT_VEC3\n  /** Integer four-dimensional vector */\n  INT_VEC4 = 35669, // gl.INT_VEC4\n\n  /** Boolean */\n  BOOL = 35670, // gl.BOOL\n  /** Boolean two-dimensional vector */\n  BOOL_VEC2 = 35671, // gl.BOOL_VEC2\n  /** Boolean three-dimensional vector */\n  BOOL_VEC3 = 35672, // gl.BOOL_VEC3\n  /** Boolean four-dimensional vector */\n  BOOL_VEC4 = 35673, // gl.BOOL_VEC4\n\n  /** Second-order matrix */\n  FLOAT_MAT2 = 35674, // gl.FLOAT_MAT2\n  /** Third-order matrix */\n  FLOAT_MAT3 = 35675, // gl.FLOAT_MAT3\n  /** Fourth-order matrix */\n  FLOAT_MAT4 = 35676, // gl.FLOAT_MAT4\n\n  /** Float array */\n  FLOAT_ARRAY = 35677, // gl.FLOAT_ARRAY\n  /** Floating-point two-dimensional vector array */\n  FLOAT_VEC2_ARRAY = 100000,\n  /** Floating-point three-dimensional vector array */\n  FLOAT_VEC3_ARRAY,\n  /** Floating-point four-dimensional vector array */\n  FLOAT_VEC4_ARRAY,\n\n  /** Integer array */\n  INT_ARRAY,\n  /** Integer two-dimensional vector array */\n  INT_VEC2_ARRAY,\n  /** Integer three-dimensional vector array */\n  INT_VEC3_ARRAY,\n  /** Integer four-dimensional vector array */\n  INT_VEC4_ARRAY,\n\n  /** Second-order matrix array */\n  FLOAT_MAT2_ARRAY,\n  /** Third-order matrix array */\n  FLOAT_MAT3_ARRAY,\n  /** Fourth-order matrix array */\n  FLOAT_MAT4_ARRAY,\n\n  /** 2D texture sampler array */\n  SAMPLER_2D_ARRAY,\n  /** Cube map texture sampler array */\n  SAMPLER_CUBE_ARRAY,\n\n  /** 2D sampler */\n  SAMPLER_2D = 35678, // gl.SAMPLER_2D\n  /** Cube map Texture sampler */\n  SAMPLER_CUBE = 35680, // gl.SAMPLER_CUBE\n\n  /** Byte */\n  BYTE = 5120, // gl.BYTE\n  /** Unsigned byte */\n  UNSIGNED_BYTE = 5121, // gl.UNSIGNED_BYTE\n  /** Short */\n  SHORT = 5122, // gl.SHORT\n  /** Unsigned short */\n  UNSIGNED_SHORT = 5123, // gl.UNSIGNED_SHORT\n  /** Unsigned int */\n  UNSIGNED_INT = 5125 // gl.UNSIGNED_INT\n}\n\n/**\n * GL Capabilities\n * Some capabilities can be smoothed out by extension, and some capabilities must use WebGL 2.0.\n * */\nexport enum GLCapabilityType {\n  shaderVertexID = \"shaderVertexID\",\n  standardDerivatives = \"OES_standard_derivatives\",\n  shaderTextureLod = \"EXT_shader_texture_lod\",\n  elementIndexUint = \"OES_element_index_uint\",\n  depthTexture = \"WEBGL_depth_texture\",\n  drawBuffers = \"WEBGL_draw_buffers\",\n  vertexArrayObject = \"OES_vertex_array_object\",\n  instancedArrays = \"ANGLE_instanced_arrays\",\n  multipleSample = \"multipleSampleOnlySupportedInWebGL2\",\n  textureFloat = \"OES_texture_float\",\n  textureFloatLinear = \"OES_texture_float_linear\",\n  textureHalfFloat = \"OES_texture_half_float\",\n  textureHalfFloatLinear = \"OES_texture_half_float_linear\",\n  WEBGL_colorBufferFloat = \"WEBGL_color_buffer_float\",\n  colorBufferFloat = \"EXT_color_buffer_float\",\n  colorBufferHalfFloat = \"EXT_color_buffer_half_float\",\n  textureFilterAnisotropic = \"EXT_texture_filter_anisotropic\",\n  blendMinMax = \"EXT_blend_minmax\",\n\n  astc = \"WEBGL_compressed_texture_astc\",\n  astc_webkit = \"WEBKIT_WEBGL_compressed_texture_astc\",\n  etc = \"WEBGL_compressed_texture_etc\",\n  etc_webkit = \"WEBKIT_WEBGL_compressed_texture_etc\",\n  etc1 = \"WEBGL_compressed_texture_etc1\",\n  etc1_webkit = \"WEBKIT_WEBGL_compressed_texture_etc1\",\n  pvrtc = \"WEBGL_compressed_texture_pvrtc\",\n  pvrtc_webkit = \"WEBKIT_WEBGL_compressed_texture_pvrtc\",\n  s3tc = \"WEBGL_compressed_texture_s3tc\",\n  s3tc_webkit = \"WEBKIT_WEBGL_compressed_texture_s3tc\"\n  // atc = \"WEBGL_compressed_texture_atc\",\n  // s3tc_srgb = \"WEBGL_compressed_texture_s3tc_srgb\"\n}\n\nexport type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Uint8ClampedArray\n  | Float32Array\n  | Float64Array;\n", "/**\n * High-performance unordered array, delete uses exchange method to improve performance, internal capacity only increases.\n */\nexport class DisorderedArray<T> {\n  _elements: T[];\n\n  length: number = 0;\n\n  constructor(count: number = 0) {\n    this._elements = new Array<T>(count);\n  }\n\n  add(element: T): void {\n    if (this.length === this._elements.length) this._elements.push(element);\n    else this._elements[this.length] = element;\n    this.length++;\n  }\n\n  delete(element: T): void {\n    //TODO: It can be optimized for custom binary search and other algorithms, currently this._elements>=this.length wastes performance.\n    const index = this._elements.indexOf(element);\n    this.deleteByIndex(index);\n  }\n\n  get(index: number): T {\n    if (index >= this.length) {\n      throw \"Index is out of range.\";\n    }\n    return this._elements[index];\n  }\n\n  /**\n   *\n   * @param index\n   * @returns The replaced item is used to reset its index.\n   */\n  deleteByIndex(index: number): T {\n    var elements: T[] = this._elements;\n    let end: T = null;\n    const lastIndex = this.length - 1;\n    if (index !== lastIndex) {\n      end = elements[lastIndex];\n      elements[index] = end;\n    }\n    this.length--;\n    return end;\n  }\n\n  garbageCollection(): void {\n    this._elements.length = this.length;\n  }\n}\n", "import { ShaderMacro } from \"./ShaderMacro\";\n\n/**\n * Shader macro collection.\n * @internal\n */\nexport class ShaderMacroCollection {\n  /**\n   * Union of two macro collection.\n   * @param left - input macro collection\n   * @param right - input macro collection\n   * @param out - union output macro collection\n   */\n  static unionCollection(left: ShaderMacroCollection, right: ShaderMacroCollection, out: ShaderMacroCollection): void {\n    const outMask = out._mask;\n    let minSize: number, maxSize: number;\n    let minMask: number[], maxMask: number[];\n    if (left._length < right._length) {\n      minSize = left._length;\n      maxSize = right._length;\n      minMask = left._mask;\n      maxMask = right._mask;\n    } else {\n      minSize = right._length;\n      maxSize = left._length;\n      minMask = right._mask;\n      maxMask = left._mask;\n    }\n\n    let i = 0;\n    outMask.length < maxSize && (outMask.length = maxSize);\n    for (; i < minSize; i++) {\n      outMask[i] = minMask[i] | maxMask[i];\n    }\n    for (; i < maxSize; i++) {\n      outMask[i] = maxMask[i];\n    }\n    out._length = maxSize;\n  }\n\n  /** @internal */\n  _mask: number[] = [];\n  /** @internal */\n  _length: number = 0;\n\n  /**\n   * Enable one macro in this macro collection.\n   * @param macro - ShaderMacro\n   */\n  enable(macro: ShaderMacro): void {\n    const index = macro._index;\n    const size = index + 1;\n    const mask = this._mask;\n    let maskStart = this._length; // must from this._length because this._length maybe less than mask.length and have dirty data should clear.\n    if (maskStart < size) {\n      mask.length < size && (mask.length = size); // mask.length maybe small than size,maybe not.\n      for (; maskStart < index; maskStart++) {\n        mask[maskStart] = 0;\n      }\n      mask[index] = macro._value;\n      this._length = size;\n    } else {\n      mask[index] |= macro._value;\n    }\n  }\n\n  /**\n   * Disable one macro in this macro collection.\n   * @param macro - ShaderMacro\n   */\n  disable(macro: ShaderMacro): void {\n    const index = macro._index;\n    const mask = this._mask;\n    const endIndex = this._length - 1;\n    if (index > endIndex) {\n      return;\n    }\n    const newValue = mask[index] & ~macro._value;\n    if (index == endIndex && newValue === 0) {\n      this._length--;\n    } else {\n      mask[index] = newValue;\n    }\n  }\n\n  /**\n   * Union of this and other macro collection.\n   * @param macroCollection - macro collection\n   */\n  unionCollection(macroCollection: ShaderMacroCollection): void {\n    const addMask = macroCollection._mask;\n    const addSize = macroCollection._length;\n    const mask = this._mask;\n    const maskSize = this._length;\n    if (maskSize < addSize) {\n      mask.length < addSize && (mask.length = addSize);\n      let i = 0;\n      for (; i < maskSize; i++) {\n        mask[i] |= addMask[i];\n      }\n      for (; i < addSize; i++) {\n        mask[i] = addMask[i];\n      }\n      this._length = addSize;\n    } else {\n      for (let i = 0; i < addSize; i++) {\n        mask[i] |= addMask[i];\n      }\n    }\n  }\n\n  /**\n   * Complementarity of this and other macro collection.\n   * @param macroCollection - macro collection\n   */\n  complementaryCollection(macroCollection: ShaderMacroCollection): void {\n    const removeMask = macroCollection._mask;\n    const mask = this._mask;\n    let endIndex = this._length - 1;\n    let i = Math.min(macroCollection._length - 1, endIndex);\n    for (; i >= 0; i--) {\n      const newValue = mask[i] & ~removeMask[i];\n      if (i == endIndex && newValue === 0) {\n        endIndex--;\n        this._length--;\n      } else {\n        mask[i] = newValue;\n      }\n    }\n  }\n\n  /**\n   * Intersection of this and other macro collection.\n   * @param macroCollection - macro collection\n   */\n  intersectionCollection(macroCollection: ShaderMacroCollection): void {\n    const unionMask = macroCollection._mask;\n    const mask = this._mask;\n    for (let i = this._length - 1; i >= 0; i--) {\n      const value = mask[i] & unionMask[i];\n      if (value == 0 && i == this._length - 1) {\n        this._length--;\n      } else {\n        mask[i] = value;\n      }\n    }\n  }\n\n  /**\n   * Whether macro is enabled in this macro collection.\n   * @param macro - ShaderMacro\n   */\n  isEnable(macro: ShaderMacro): boolean {\n    const index = macro._index;\n    if (index >= this._length) {\n      return false;\n    }\n    return (this._mask[index] & macro._value) !== 0;\n  }\n\n  /**\n   * Clear this macro collection.\n   */\n  clear(): void {\n    this._length = 0;\n  }\n}\n", "import { Camera } from \"./Camera\";\nimport { DisorderedArray } from \"./DisorderedArray\";\nimport { Component } from \"./Component\";\nimport { Renderer } from \"./Renderer\";\nimport { Script } from \"./Script\";\nimport { ShaderMacroCollection } from \"./shader/ShaderMacroCollection\";\nimport { RenderContext } from \"./RenderPipeline/RenderContext\";\nimport { Vector3 } from \"@oasis-engine/math\";\n\n/**\n * The manager of the components.\n */\nexport class ComponentsManager {\n  private static _tempVector0 = new Vector3();\n  private static _tempVector1 = new Vector3();\n\n  // Script\n  private _onStartScripts: DisorderedArray<Script> = new DisorderedArray();\n  private _onUpdateScripts: DisorderedArray<Script> = new DisorderedArray();\n  private _onLateUpdateScripts: DisorderedArray<Script> = new DisorderedArray();\n  private _destroyComponents: Script[] = [];\n\n  // Animation\n  private _onUpdateAnimations: DisorderedArray<Component> = new DisorderedArray();\n\n  // Render\n  private _renderers: DisorderedArray<Renderer> = new DisorderedArray();\n  private _onUpdateRenderers: DisorderedArray<Renderer> = new DisorderedArray();\n\n  // Delay dispose active/inActive Pool\n  private _componentsContainerPool: Component[][] = [];\n\n  addRenderer(renderer: Renderer) {\n    renderer._rendererIndex = this._renderers.length;\n    this._renderers.add(renderer);\n  }\n\n  removeRenderer(renderer: Renderer) {\n    const replaced = this._renderers.deleteByIndex(renderer._rendererIndex);\n    replaced && (replaced._rendererIndex = renderer._rendererIndex);\n    renderer._rendererIndex = -1;\n  }\n\n  addOnStartScript(script: Script) {\n    script._onStartIndex = this._onStartScripts.length;\n    this._onStartScripts.add(script);\n  }\n\n  removeOnStartScript(script: Script): void {\n    const replaced = this._onStartScripts.deleteByIndex(script._onStartIndex);\n    replaced && (replaced._onStartIndex = script._onStartIndex);\n    script._onStartIndex = -1;\n  }\n\n  addOnUpdateScript(script: Script) {\n    script._onUpdateIndex = this._onUpdateScripts.length;\n    this._onUpdateScripts.add(script);\n  }\n\n  removeOnUpdateScript(script: Script): void {\n    const replaced = this._onUpdateScripts.deleteByIndex(script._onUpdateIndex);\n    replaced && (replaced._onUpdateIndex = script._onUpdateIndex);\n    script._onUpdateIndex = -1;\n  }\n\n  addOnLateUpdateScript(script: Script): void {\n    script._onLateUpdateIndex = this._onLateUpdateScripts.length;\n    this._onLateUpdateScripts.add(script);\n  }\n\n  removeOnLateUpdateScript(script: Script): void {\n    const replaced = this._onLateUpdateScripts.deleteByIndex(script._onLateUpdateIndex);\n    replaced && (replaced._onLateUpdateIndex = script._onLateUpdateIndex);\n    script._onLateUpdateIndex = -1;\n  }\n\n  addOnUpdateAnimations(animation: Component): void {\n    //@ts-ignore\n    animation._onUpdateIndex = this._onUpdateAnimations.length;\n    this._onUpdateAnimations.add(animation);\n  }\n\n  removeOnUpdateAnimations(animation: Component): void {\n    //@ts-ignore\n    const replaced = this._onUpdateAnimations.deleteByIndex(animation._onUpdateIndex);\n    //@ts-ignore\n    replaced && (replaced._onUpdateIndex = animation._onUpdateIndex);\n    //@ts-ignore\n    animation._onUpdateIndex = -1;\n  }\n\n  addOnUpdateRenderers(renderer: Renderer): void {\n    renderer._onUpdateIndex = this._onUpdateRenderers.length;\n    this._onUpdateRenderers.add(renderer);\n  }\n\n  removeOnUpdateRenderers(renderer: Renderer): void {\n    const replaced = this._onUpdateRenderers.deleteByIndex(renderer._onUpdateIndex);\n    replaced && (replaced._onUpdateIndex = renderer._onUpdateIndex);\n    renderer._onUpdateIndex = -1;\n  }\n\n  addDestroyComponent(component): void {\n    this._destroyComponents.push(component);\n  }\n\n  callScriptOnStart(): void {\n    const onStartScripts = this._onStartScripts;\n    if (onStartScripts.length > 0) {\n      const elements = onStartScripts._elements;\n      // The 'onStartScripts.length' maybe add if you add some Script with addComponent() in some Script's onStart()\n      for (let i = 0; i < onStartScripts.length; i++) {\n        const script = elements[i];\n        script._started = true;\n        script._onStartIndex = -1;\n        script.onStart();\n      }\n      onStartScripts.length = 0;\n    }\n  }\n\n  callScriptOnUpdate(deltaTime): void {\n    const elements = this._onUpdateScripts._elements;\n    for (let i = this._onUpdateScripts.length - 1; i >= 0; --i) {\n      const element = elements[i];\n      if (element._started) {\n        element.onUpdate(deltaTime);\n      }\n    }\n  }\n\n  callScriptOnLateUpdate(deltaTime): void {\n    const elements = this._onLateUpdateScripts._elements;\n    for (let i = this._onLateUpdateScripts.length - 1; i >= 0; --i) {\n      const element = elements[i];\n      if (element._started) {\n        element.onLateUpdate(deltaTime);\n      }\n    }\n  }\n\n  callAnimationUpdate(deltaTime): void {\n    const elements = this._onUpdateAnimations._elements;\n    for (let i = this._onUpdateAnimations.length - 1; i >= 0; --i) {\n      //@ts-ignore\n      elements[i].update(deltaTime);\n    }\n  }\n\n  callRendererOnUpdate(deltaTime: number): void {\n    const elements = this._onUpdateRenderers._elements;\n    for (let i = this._onUpdateRenderers.length - 1; i >= 0; --i) {\n      elements[i].update(deltaTime);\n    }\n  }\n\n  callRender(context: RenderContext): void {\n    const camera = context._camera;\n    const elements = this._renderers._elements;\n    for (let i = this._renderers.length - 1; i >= 0; --i) {\n      const element = elements[i];\n\n      // filter by camera culling mask.\n      if (!(camera.cullingMask & element._entity.layer)) {\n        continue;\n      }\n\n      // filter by camera frustum.\n      if (camera.enableFrustumCulling) {\n        element.isCulled = !camera._frustum.intersectsBox(element.bounds);\n        if (element.isCulled) {\n          continue;\n        }\n      }\n\n      const transform = camera.entity.transform;\n      const position = transform.worldPosition;\n      const center = element.bounds.getCenter(ComponentsManager._tempVector0);\n      if (camera.isOrthographic) {\n        const forward = transform.getWorldForward(ComponentsManager._tempVector1);\n        Vector3.subtract(center, position, center);\n        element._distanceForSort = Vector3.dot(center, forward);\n      } else {\n        element._distanceForSort = Vector3.distanceSquared(center, position);\n      }\n\n      element._updateShaderData(context);\n\n      element._render(camera);\n\n      // union camera global macro and renderer macro.\n      ShaderMacroCollection.unionCollection(\n        camera._globalShaderMacro,\n        element.shaderData._macroCollection,\n        element._globalShaderMacro\n      );\n    }\n  }\n\n  callComponentDestroy(): void {\n    const destroyComponents = this._destroyComponents;\n    const length = destroyComponents.length;\n    if (length > 0) {\n      for (let i = length - 1; i >= 0; --i) {\n        destroyComponents[i].onDestroy();\n      }\n      destroyComponents.length = 0;\n    }\n  }\n\n  callCameraOnBeginRender(camera: Camera) {\n    const camComps = camera.entity._components;\n    for (let i = camComps.length - 1; i >= 0; --i) {\n      const camComp = camComps[i];\n      (camComp as any).onBeginRender && (camComp as any).onBeginRender(camera);\n    }\n  }\n\n  callCameraOnEndRender(camera: Camera) {\n    const camComps = camera.entity._components;\n    for (let i = camComps.length - 1; i >= 0; --i) {\n      const camComp = camComps[i];\n      (camComp as any).onBeginRender && (camComp as any).onEndRender(camera);\n    }\n  }\n\n  getActiveChangedTempList(): Component[] {\n    return this._componentsContainerPool.length ? this._componentsContainerPool.pop() : [];\n  }\n\n  putActiveChangedTempList(componentContainer: Component[]): void {\n    componentContainer.length = 0;\n    this._componentsContainerPool.push(componentContainer);\n  }\n}\n", "import { Component } from \"../Component\";\nimport { CloneManager } from \"./CloneManager\";\nimport { CloneMode } from \"./enums/CloneMode\";\n\n/**\n * Custom clone interface.\n */\nexport interface ICustomClone {\n  /**\n   * @internal\n   */\n  _cloneTo(target: ICustomClone): void;\n}\n\nexport class ComponentCloner {\n  /**\n   * Clone component.\n   * @param source - Clone source\n   * @param target - Clone target\n   */\n  static cloneComponent(source: Component, target: Component): void {\n    const cloneModes = CloneManager.getCloneMode(source.constructor);\n    const keys = Object.keys(source);\n    for (let i = 0, n = keys.length; i < n; i++) {\n      const k = keys[i];\n      const cloneMode = cloneModes[k];\n      switch (cloneMode) {\n        case undefined:\n        case CloneMode.Assignment:\n          target[k] = source[k];\n          break;\n        case CloneMode.Shallow:\n          const sourcePropS: Object = source[k];\n          if (sourcePropS instanceof Object) {\n            let tarProp = <Object>target[k];\n            tarProp == null && (tarProp = target[k] = sourcePropS.constructor());\n            Object.assign(tarProp, sourcePropS);\n          } else {\n            // Null or undefined and primitive type.\n            target[k] = sourcePropS;\n          }\n          break;\n        case CloneMode.Deep:\n          const sourcePropD: Object = source[k];\n          if (sourcePropD instanceof Object) {\n            let tarProp = <Object>target[k];\n            tarProp == null && (tarProp = target[k] = sourcePropD.constructor());\n            CloneManager.deepCloneObject(sourcePropD, tarProp);\n          } else {\n            // Null or undefined and primitive type.\n            target[k] = sourcePropD;\n          }\n          break;\n      }\n    }\n    if ((<any>source)._cloneTo) {\n      (<any>source)._cloneTo(target);\n    }\n  }\n}\n", "import { Component } from \"./Component\";\nimport { Entity } from \"./Entity\";\n\ntype ComponentConstructor = new (entity: Entity) => Component;\n\n/**\n * Used for component dependency registration.\n */\nexport class ComponentsDependencies {\n  /**\n   * @internal\n   */\n  private static _dependenciesMap = new Map<ComponentConstructor, ComponentConstructor[]>();\n  private static _invDependenciesMap = new Map<ComponentConstructor, ComponentConstructor[]>();\n\n  /**\n   * Register component dependencies.\n   * @param currentComponent - The component you want to be register.\n   * @param dependentComponent - The component's dependencies.\n   */\n  static register(currentComponent: ComponentConstructor, dependentComponent: ComponentConstructor) {\n    this._addDependency(currentComponent, dependentComponent, this._dependenciesMap);\n    this._addDependency(dependentComponent, currentComponent, this._invDependenciesMap);\n  }\n\n  /**\n   * @internal\n   */\n  static _addCheck(entity: Entity, type: ComponentConstructor) {\n    // Check if there are dependent components.\n    const dependencies = ComponentsDependencies._dependenciesMap.get(type);\n    if (dependencies) {\n      for (let i = 0, len = dependencies.length; i < len; i++) {\n        if (!entity.getComponent(dependencies[i])) {\n          throw `you should add ${dependencies[i]} before adding ${type}`;\n        }\n      }\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static _removeCheck(entity: Entity, type: ComponentConstructor) {\n    const invDependencies = ComponentsDependencies._invDependenciesMap.get(type);\n    if (invDependencies) {\n      for (let i = 0, len = invDependencies.length; i < len; i++) {\n        if (entity.getComponent(invDependencies[i])) {\n          throw `you should remove ${invDependencies[i]} before adding ${type}`;\n        }\n      }\n    }\n  }\n\n  private static _addDependency(\n    currentComponent: ComponentConstructor,\n    dependentComponent: ComponentConstructor,\n    map: Map<any, any>\n  ) {\n    let components = map.get(currentComponent);\n    if (!components) {\n      components = [];\n      map.set(currentComponent, components);\n    }\n    if (components.indexOf(dependentComponent) === -1) {\n      components.push(dependentComponent);\n    }\n  }\n\n  private constructor() {}\n}\n\nexport function dependencies(...abilityClass: ComponentConstructor[]) {\n  return function <T extends ComponentConstructor>(target: T): void {\n    abilityClass.forEach((ability) => ComponentsDependencies.register(target, ability));\n  };\n}\n", "/**\n * Layer, used for bit operations.\n */\nexport enum Layer {\n  /** Layer 0. */\n  Layer0 = 0x1,\n  /** Layer 1. */\n  Layer1 = 0x2,\n  /** Layer 2. */\n  Layer2 = 0x4,\n  /** Layer 3. */\n  Layer3 = 0x8,\n  /** Layer 4. */\n  Layer4 = 0x10,\n  /** Layer 5. */\n  Layer5 = 0x20,\n  /** Layer 6. */\n  Layer6 = 0x40,\n  /** Layer 7. */\n  Layer7 = 0x80,\n  /** Layer 8. */\n  Layer8 = 0x100,\n  /** Layer 9. */\n  Layer9 = 0x200,\n  /** Layer 10. */\n  Layer10 = 0x400,\n  /** Layer 11. */\n  Layer11 = 0x800,\n  /** Layer 12. */\n  Layer12 = 0x1000,\n  /** Layer 13. */\n  Layer13 = 0x2000,\n  /** Layer 14. */\n  Layer14 = 0x4000,\n  /** Layer 15. */\n  Layer15 = 0x8000,\n  /** Layer 16. */\n  Layer16 = 0x10000,\n  /** Layer 17. */\n  Layer17 = 0x20000,\n  /** Layer 18. */\n  Layer18 = 0x40000,\n  /** Layer 19. */\n  Layer19 = 0x80000,\n  /** Layer 20. */\n  Layer20 = 0x100000,\n  /** Layer 21. */\n  Layer21 = 0x200000,\n  /** Layer 22. */\n  Layer22 = 0x400000,\n  /** Layer 23. */\n  Layer23 = 0x800000,\n  /** Layer 24. */\n  Layer24 = 0x1000000,\n  /** Layer 25. */\n  Layer25 = 0x2000000,\n  /** Layer 26. */\n  Layer26 = 0x4000000,\n  /** Layer 27. */\n  Layer27 = 0x8000000,\n  /** Layer 28. */\n  Layer28 = 0x10000000,\n  /** Layer 29. */\n  Layer29 = 0x20000000,\n  /** Layer 30. */\n  Layer30 = 0x40000000,\n  /** Layer 31. */\n  Layer31 = 0x80000000,\n  /** All layers. */\n  Everything = 0xffffffff,\n  /** None layer. */\n  Nothing = 0x0\n}\n", "import { EngineObject } from \"./base\";\nimport { assignmentClone, ignoreClone } from \"./clone/CloneManager\";\nimport { Engine } from \"./Engine\";\nimport { Entity } from \"./Entity\";\nimport { Scene } from \"./Scene\";\n\n/**\n * The base class of the components.\n */\nexport abstract class Component extends EngineObject {\n  /** @internal */\n  @ignoreClone\n  _entity: Entity;\n  /** @internal */\n  @ignoreClone\n  _destroyed: boolean = false;\n\n  @assignmentClone\n  private _enabled: boolean = true;\n  @ignoreClone\n  private _awoken: boolean = false;\n\n  /**\n   * Indicates whether the component is enabled.\n   */\n  get enabled(): boolean {\n    return this._enabled;\n  }\n\n  set enabled(value: boolean) {\n    if (value === this._enabled) {\n      return;\n    }\n    this._enabled = value;\n    if (value) {\n      this._entity.isActiveInHierarchy && this._onEnable();\n    } else {\n      this._entity.isActiveInHierarchy && this._onDisable();\n    }\n  }\n\n  /**\n   * Indicates whether the component is destroyed.\n   */\n  get destroyed(): boolean {\n    return this._destroyed;\n  }\n\n  /**\n   * The entity which the component belongs to.\n   */\n  get entity(): Entity {\n    return this._entity;\n  }\n\n  /**\n   * The scene which the component's entity belongs to.\n   */\n  get scene(): Scene {\n    return this._entity.scene;\n  }\n\n  constructor(entity: Entity) {\n    super(entity.engine);\n    this._entity = entity;\n  }\n\n  /**\n   * Destroy this instance.\n   */\n  destroy(): void {\n    if (this._destroyed) {\n      return;\n    }\n    this._entity._removeComponent(this);\n    if (this._entity.isActiveInHierarchy) {\n      this._enabled && this._onDisable();\n      this._onInActive();\n    }\n    this._destroyed = true;\n    this._onDestroy();\n  }\n\n  /**\n   * @internal\n   */\n  _onAwake(): void {}\n\n  /**\n   * @internal\n   */\n  _onEnable(): void {}\n\n  /**\n   * @internal\n   */\n  _onDisable(): void {}\n\n  /**\n   * @internal\n   */\n  _onDestroy(): void {}\n\n  /**\n   * @internal\n   */\n  _onActive(): void {}\n\n  /**\n   * @internal\n   */\n  _onInActive(): void {}\n\n  /**\n   * @internal\n   */\n  _setActive(value: boolean): void {\n    if (value) {\n      if (!this._awoken) {\n        this._awoken = true;\n        this._onAwake();\n      }\n      // You can do isActive = false in onAwake function.\n      if (this._entity._isActiveInHierarchy) {\n        this._onActive();\n        this._enabled && this._onEnable();\n      }\n    } else {\n      this._enabled && this._onDisable();\n      this._onInActive();\n    }\n  }\n}\n", "import { removeFromArray } from \"./base/Util\";\n\n/**\n * Used to update tags.\n */\nexport class UpdateFlag {\n  /** Flag. */\n  flag = true;\n\n  constructor(private _flags: UpdateFlag[] = []) {\n    this._flags.push(this);\n  }\n\n  /**\n   * Destroy.\n   */\n  destroy(): void {\n    const flags = this._flags;\n    removeFromArray(flags, this);\n    this._flags = null;\n  }\n}\n", "import { UpdateFlag } from \"./UpdateFlag\";\n\n/**\n * @internal\n */\nexport class UpdateFlagManager {\n  private _updateFlags: UpdateFlag[] = [];\n\n  register(): UpdateFlag {\n    return new UpdateFlag(this._updateFlags);\n  }\n\n  distribute(): void {\n    const updateFlags = this._updateFlags;\n    for (let i = updateFlags.length - 1; i >= 0; i--) {\n      updateFlags[i].flag = true;\n    }\n  }\n}\n", "import { MathUtil, Matrix, Matrix3x3, Quaternion, Vector3 } from \"@oasis-engine/math\";\nimport { deepClone, ignoreClone } from \"./clone/CloneManager\";\nimport { Component } from \"./Component\";\nimport { UpdateFlag } from \"./UpdateFlag\";\nimport { UpdateFlagManager } from \"./UpdateFlagManager\";\n\n/**\n * Used to implement transformation related functions.\n */\nexport class Transform extends Component {\n  private static _tempQuat0: Quaternion = new Quaternion();\n  private static _tempVec3: Vector3 = new Vector3();\n  private static _tempMat30: Matrix3x3 = new Matrix3x3();\n  private static _tempMat31: Matrix3x3 = new Matrix3x3();\n  private static _tempMat32: Matrix3x3 = new Matrix3x3();\n  private static _tempMat40: Matrix = new Matrix();\n  private static _tempMat41: Matrix = new Matrix();\n  private static _tempMat42: Matrix = new Matrix();\n  private static _tempMat43: Matrix = new Matrix();\n\n  @deepClone\n  private _position: Vector3 = new Vector3();\n  @deepClone\n  private _rotation: Vector3 = new Vector3();\n  @deepClone\n  private _rotationQuaternion: Quaternion = new Quaternion();\n  @deepClone\n  private _scale: Vector3 = new Vector3(1, 1, 1);\n  @deepClone\n  private _worldPosition: Vector3 = new Vector3();\n  @deepClone\n  private _worldRotation: Vector3 = new Vector3();\n  @deepClone\n  private _worldRotationQuaternion: Quaternion = new Quaternion();\n  @deepClone\n  private _lossyWorldScale: Vector3 = new Vector3(1, 1, 1);\n  @deepClone\n  private _localMatrix: Matrix = new Matrix();\n  @deepClone\n  private _worldMatrix: Matrix = new Matrix();\n  @ignoreClone\n  private _updateFlagManager: UpdateFlagManager = new UpdateFlagManager();\n  @ignoreClone\n  private _isParentDirty: boolean = true;\n  @ignoreClone\n  private _parentTransformCache: Transform = null;\n\n  private _dirtyFlag: number = TransformFlag.WmWpWeWqWs;\n\n  /**\n   * Local position.\n   * @remarks Need to re-assign after modification to ensure that the modification takes effect.\n   */\n  get position(): Vector3 {\n    return this._position;\n  }\n\n  set position(value: Vector3) {\n    if (this._position !== value) {\n      value.cloneTo(this._position);\n    }\n    this._setDirtyFlagTrue(TransformFlag.LocalMatrix);\n    this._updateWorldPositionFlag();\n  }\n\n  /**\n   * World position.\n   * @remarks Need to re-assign after modification to ensure that the modification takes effect.\n   */\n  get worldPosition(): Vector3 {\n    if (this._isContainDirtyFlag(TransformFlag.WorldPosition)) {\n      if (this._getParentTransform()) {\n        this.worldMatrix.getTranslation(this._worldPosition);\n      } else {\n        this._position.cloneTo(this._worldPosition);\n      }\n      this._setDirtyFlagFalse(TransformFlag.WorldPosition);\n    }\n    return this._worldPosition;\n  }\n\n  set worldPosition(value: Vector3) {\n    if (this._worldPosition !== value) {\n      value.cloneTo(this._worldPosition);\n    }\n    const parent = this._getParentTransform();\n    if (parent) {\n      Matrix.invert(parent.worldMatrix, Transform._tempMat41);\n      Vector3.transformCoordinate(value, Transform._tempMat41, this._position);\n    } else {\n      value.cloneTo(this._position);\n    }\n    this.position = this._position;\n    this._setDirtyFlagFalse(TransformFlag.WorldPosition);\n  }\n\n  /**\n   * Local rotation, defining the rotation value in degrees.\n   * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.\n   * @remarks Need to re-assign after modification to ensure that the modification takes effect.\n   */\n  get rotation(): Vector3 {\n    if (this._isContainDirtyFlag(TransformFlag.LocalEuler)) {\n      this._rotationQuaternion.toEuler(this._rotation);\n      this._rotation.scale(MathUtil.radToDegreeFactor); // radians to degrees\n\n      this._setDirtyFlagFalse(TransformFlag.LocalEuler);\n    }\n    return this._rotation;\n  }\n\n  set rotation(value: Vector3) {\n    if (this._rotation !== value) {\n      value.cloneTo(this._rotation);\n    }\n    this._setDirtyFlagTrue(TransformFlag.LocalMatrix | TransformFlag.LocalQuat);\n    this._setDirtyFlagFalse(TransformFlag.LocalEuler);\n    this._updateWorldRotationFlag();\n  }\n\n  /**\n   * World rotation, defining the rotation value in degrees.\n   * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.\n   * @remarks Need to re-assign after modification to ensure that the modification takes effect.\n   */\n  get worldRotation(): Vector3 {\n    if (this._isContainDirtyFlag(TransformFlag.WorldEuler)) {\n      this.worldRotationQuaternion.toEuler(this._worldRotation);\n      this._worldRotation.scale(MathUtil.radToDegreeFactor); // Radian to angle\n      this._setDirtyFlagFalse(TransformFlag.WorldEuler);\n    }\n    return this._worldRotation;\n  }\n\n  set worldRotation(value: Vector3) {\n    if (this._worldRotation !== value) {\n      value.cloneTo(this._worldRotation);\n    }\n    Quaternion.rotationEuler(\n      MathUtil.degreeToRadian(value.x),\n      MathUtil.degreeToRadian(value.y),\n      MathUtil.degreeToRadian(value.z),\n      this._worldRotationQuaternion\n    );\n    this.worldRotationQuaternion = this._worldRotationQuaternion;\n    this._setDirtyFlagFalse(TransformFlag.WorldEuler);\n  }\n\n  /**\n   * Local rotation, defining the rotation by using a unit quaternion.\n   * @remarks Need to re-assign after modification to ensure that the modification takes effect.\n   */\n  get rotationQuaternion(): Quaternion {\n    if (this._isContainDirtyFlag(TransformFlag.LocalQuat)) {\n      Quaternion.rotationEuler(\n        MathUtil.degreeToRadian(this._rotation.x),\n        MathUtil.degreeToRadian(this._rotation.y),\n        MathUtil.degreeToRadian(this._rotation.z),\n        this._rotationQuaternion\n      );\n      this._setDirtyFlagFalse(TransformFlag.LocalQuat);\n    }\n    return this._rotationQuaternion;\n  }\n\n  set rotationQuaternion(value: Quaternion) {\n    if (this._rotationQuaternion !== value) {\n      value.cloneTo(this._rotationQuaternion);\n    }\n    this._setDirtyFlagTrue(TransformFlag.LocalMatrix | TransformFlag.LocalEuler);\n    this._setDirtyFlagFalse(TransformFlag.LocalQuat);\n    this._updateWorldRotationFlag();\n  }\n\n  /**\n   * World rotation, defining the rotation by using a unit quaternion.\n   * @remarks Need to re-assign after modification to ensure that the modification takes effect.\n   */\n  get worldRotationQuaternion(): Quaternion {\n    if (this._isContainDirtyFlag(TransformFlag.WorldQuat)) {\n      const parent = this._getParentTransform();\n      if (parent != null) {\n        Quaternion.multiply(parent.worldRotationQuaternion, this.rotationQuaternion, this._worldRotationQuaternion);\n      } else {\n        this.rotationQuaternion.cloneTo(this._worldRotationQuaternion);\n      }\n      this._setDirtyFlagFalse(TransformFlag.WorldQuat);\n    }\n    return this._worldRotationQuaternion;\n  }\n\n  set worldRotationQuaternion(value: Quaternion) {\n    if (this._worldRotationQuaternion !== value) {\n      value.cloneTo(this._worldRotationQuaternion);\n    }\n    const parent = this._getParentTransform();\n    if (parent) {\n      Quaternion.invert(parent.worldRotationQuaternion, Transform._tempQuat0);\n      Quaternion.multiply(value, Transform._tempQuat0, this._rotationQuaternion);\n    } else {\n      value.cloneTo(this._rotationQuaternion);\n    }\n    this.rotationQuaternion = this._rotationQuaternion;\n    this._setDirtyFlagFalse(TransformFlag.WorldQuat);\n  }\n\n  /**\n   * Local scaling.\n   * @remarks Need to re-assign after modification to ensure that the modification takes effect.\n   */\n  get scale(): Vector3 {\n    return this._scale;\n  }\n\n  set scale(value: Vector3) {\n    if (this._scale !== value) {\n      value.cloneTo(this._scale);\n    }\n    this._setDirtyFlagTrue(TransformFlag.LocalMatrix);\n    this._updateWorldScaleFlag();\n  }\n\n  /**\n   * Local lossy scaling.\n   * @remarks The value obtained may not be correct under certain conditions(for example, the parent node has scaling,\n   * and the child node has a rotation), the scaling will be tilted. Vector3 cannot be used to correctly represent the scaling. Must use Matrix3x3.\n   */\n  get lossyWorldScale(): Vector3 {\n    if (this._isContainDirtyFlag(TransformFlag.WorldScale)) {\n      if (this._getParentTransform()) {\n        const scaleMat = this._getScaleMatrix();\n        const e = scaleMat.elements;\n        this._lossyWorldScale.setValue(e[0], e[4], e[8]);\n      } else {\n        this._scale.cloneTo(this._lossyWorldScale);\n      }\n      this._setDirtyFlagFalse(TransformFlag.WorldScale);\n    }\n    return this._lossyWorldScale;\n  }\n\n  /**\n   * Local matrix.\n   * @remarks Need to re-assign after modification to ensure that the modification takes effect.\n   */\n  get localMatrix(): Matrix {\n    if (this._isContainDirtyFlag(TransformFlag.LocalMatrix)) {\n      Matrix.affineTransformation(this._scale, this.rotationQuaternion, this._position, this._localMatrix);\n      this._setDirtyFlagFalse(TransformFlag.LocalMatrix);\n    }\n    return this._localMatrix;\n  }\n\n  set localMatrix(value: Matrix) {\n    if (this._localMatrix !== value) {\n      value.cloneTo(this._localMatrix);\n    }\n    this._localMatrix.decompose(this._position, this._rotationQuaternion, this._scale);\n    this._setDirtyFlagTrue(TransformFlag.LocalEuler);\n    this._setDirtyFlagFalse(TransformFlag.LocalMatrix);\n    this._updateAllWorldFlag();\n  }\n\n  /**\n   * World matrix.\n   * @remarks Need to re-assign after modification to ensure that the modification takes effect.\n   */\n  get worldMatrix(): Matrix {\n    if (this._isContainDirtyFlag(TransformFlag.WorldMatrix)) {\n      const parent = this._getParentTransform();\n      if (parent) {\n        Matrix.multiply(parent.worldMatrix, this.localMatrix, this._worldMatrix);\n      } else {\n        this.localMatrix.cloneTo(this._worldMatrix);\n      }\n      this._setDirtyFlagFalse(TransformFlag.WorldMatrix);\n    }\n    return this._worldMatrix;\n  }\n\n  set worldMatrix(value: Matrix) {\n    if (this._worldMatrix !== value) {\n      value.cloneTo(this._worldMatrix);\n    }\n    const parent = this._getParentTransform();\n    if (parent) {\n      Matrix.invert(parent.worldMatrix, Transform._tempMat42);\n      Matrix.multiply(value, Transform._tempMat42, this._localMatrix);\n    } else {\n      value.cloneTo(this._localMatrix);\n    }\n    this.localMatrix = this._localMatrix;\n    this._setDirtyFlagFalse(TransformFlag.WorldMatrix);\n  }\n\n  /**\n   * Set local position by X, Y, Z value.\n   * @param x - X coordinate\n   * @param y - Y coordinate\n   * @param z - Z coordinate\n   */\n  setPosition(x: number, y: number, z: number): void {\n    this._position.setValue(x, y, z);\n    this.position = this._position;\n  }\n\n  /**\n   * Set local rotation by the X, Y, Z components of the euler angle, unit in degrees.\n   * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.\n   * @param x - The angle of rotation around the X axis\n   * @param y - The angle of rotation around the Y axis\n   * @param z - The angle of rotation around the Z axis\n   */\n  setRotation(x: number, y: number, z: number): void {\n    this._rotation.setValue(x, y, z);\n    this.rotation = this._rotation;\n  }\n\n  /**\n   * Set local rotation by the X, Y, Z, and W components of the quaternion.\n   * @param x - X component of quaternion\n   * @param y - Y component of quaternion\n   * @param z - Z component of quaternion\n   * @param w - W component of quaternion\n   */\n  setRotationQuaternion(x: number, y: number, z: number, w: number): void {\n    this._rotationQuaternion.setValue(x, y, z, w);\n    this.rotationQuaternion = this._rotationQuaternion;\n  }\n\n  /**\n   * Set local scaling by scaling values along X, Y, Z axis.\n   * @param x - Scaling along X axis\n   * @param y - Scaling along Y axis\n   * @param z - Scaling along Z axis\n   */\n  setScale(x: number, y: number, z: number): void {\n    this._scale.setValue(x, y, z);\n    this.scale = this._scale;\n  }\n\n  /**\n   * Set world position by X, Y, Z value.\n   * @param x - X coordinate\n   * @param y - Y coordinate\n   * @param z - Z coordinate\n   */\n  setWorldPosition(x: number, y: number, z: number): void {\n    this._worldPosition.setValue(x, y, z);\n    this.worldPosition = this._worldPosition;\n  }\n\n  /**\n   * Set world rotation by the X, Y, Z components of the euler angle, unit in degrees, Yaw/Pitch/Roll sequence.\n   * @param x - The angle of rotation around the X axis\n   * @param y - The angle of rotation around the Y axis\n   * @param z - The angle of rotation around the Z axis\n   */\n  setWorldRotation(x: number, y: number, z: number): void {\n    this._worldRotation.setValue(x, y, z);\n    this.worldRotation = this._worldRotation;\n  }\n\n  /**\n   * Set local rotation by the X, Y, Z, and W components of the quaternion.\n   * @param x - X component of quaternion\n   * @param y - Y component of quaternion\n   * @param z - Z component of quaternion\n   * @param w - W component of quaternion\n   */\n  setWorldRotationQuaternion(x: number, y: number, z: number, w: number): void {\n    this._worldRotationQuaternion.setValue(x, y, z, w);\n    this.worldRotationQuaternion = this._worldRotationQuaternion;\n  }\n\n  /**\n   * Get the forward direction in world space.\n   * @param forward - Forward vector\n   * @returns Forward vector\n   */\n  getWorldForward(forward: Vector3): Vector3 {\n    const e = this.worldMatrix.elements;\n    forward.setValue(-e[8], -e[9], -e[10]);\n    return forward.normalize();\n  }\n\n  /**\n   * Get the right direction in world space.\n   * @param right - Right vector\n   * @returns Right vector\n   */\n  getWorldRight(right: Vector3): Vector3 {\n    const e = this.worldMatrix.elements;\n    right.setValue(e[0], e[1], e[2]);\n    return right.normalize();\n  }\n\n  /**\n   * Get the up direction in world space.\n   * @param up - Up vector\n   * @returns Up vector\n   */\n  getWorldUp(up: Vector3): Vector3 {\n    const e = this.worldMatrix.elements;\n    up.setValue(e[4], e[5], e[6]);\n    return up.normalize();\n  }\n\n  /**\n   * Translate along the passed Vector3.\n   * @param translation - Direction and distance of translation\n   * @param relativeToLocal - Relative to local space\n   */\n  translate(translation: Vector3, relativeToLocal?: boolean): void;\n\n  /**\n   * Translate along the passed X, Y, Z value.\n   * @param x - Translate direction and distance along x axis\n   * @param y - Translate direction and distance along y axis\n   * @param z - Translate direction and distance along z axis\n   * @param relativeToLocal - Relative to local space\n   */\n  translate(x: number, y: number, z: number, relativeToLocal?: boolean): void;\n\n  translate(\n    translationOrX: Vector3 | number,\n    relativeToLocalOrY?: boolean | number,\n    z?: number,\n    relativeToLocal?: boolean\n  ): void {\n    if (typeof translationOrX === \"number\") {\n      const translate = Transform._tempVec3;\n      translate.setValue(translationOrX, <number>relativeToLocalOrY, z);\n      this._translate(translate, relativeToLocal);\n    } else {\n      this._translate(translationOrX, <boolean>relativeToLocalOrY);\n    }\n  }\n\n  /**\n   * Rotate around the passed Vector3.\n   * @param rotation - Euler angle in degrees\n   * @param relativeToLocal - Relative to local space\n   */\n  rotate(rotation: Vector3, relativeToLocal?: boolean): void;\n\n  /**\n   * Rotate around the passed Vector3.\n   * @param x - Rotation along x axis, in degrees\n   * @param y - Rotation along y axis, in degrees\n   * @param z - Rotation along z axis, in degrees\n   * @param relativeToLocal - Relative to local space\n   */\n  rotate(x: number, y: number, z: number, relativeToLocal?: boolean): void;\n\n  rotate(\n    rotationOrX: Vector3 | number,\n    relativeToLocalOrY?: boolean | number,\n    z?: number,\n    relativeToLocal?: boolean\n  ): void {\n    if (typeof rotationOrX === \"number\") {\n      this._rotateXYZ(rotationOrX, <number>relativeToLocalOrY, z, relativeToLocal);\n    } else {\n      this._rotateXYZ(rotationOrX.x, rotationOrX.y, rotationOrX.z, <boolean>relativeToLocalOrY);\n    }\n  }\n\n  /**\n   * Rotate around the specified axis according to the specified angle.\n   * @param axis - Rotate axis\n   * @param angle - Rotate angle in degrees\n   * @param relativeToLocal - Relative to local space\n   */\n  rotateByAxis(axis: Vector3, angle: number, relativeToLocal: boolean = true): void {\n    const rad = angle * MathUtil.degreeToRadFactor;\n    Quaternion.rotationAxisAngle(axis, rad, Transform._tempQuat0);\n    this._rotateByQuat(Transform._tempQuat0, relativeToLocal);\n  }\n\n  /**\n   * Rotate and ensure that the world front vector points to the target world position.\n   * @param worldPosition - Target world position\n   * @param worldUp - Up direction in world space, default is Vector3(0, 1, 0)\n   */\n  lookAt(worldPosition: Vector3, worldUp?: Vector3): void {\n    const position = this.worldPosition;\n    const EPSILON = MathUtil.zeroTolerance;\n    if (\n      Math.abs(position.x - worldPosition.x) < EPSILON &&\n      Math.abs(position.y - worldPosition.y) < EPSILON &&\n      Math.abs(position.z - worldPosition.z) < EPSILON\n    ) {\n      return;\n    }\n    const rotMat = Transform._tempMat43;\n    const worldRotationQuaternion = this._worldRotationQuaternion;\n\n    worldUp = worldUp ?? Transform._tempVec3.setValue(0, 1, 0);\n    Matrix.lookAt(position, worldPosition, worldUp, rotMat);\n    rotMat.getRotation(worldRotationQuaternion).invert();\n    this.worldRotationQuaternion = worldRotationQuaternion;\n  }\n\n  /**\n   * Register world transform change flag.\n   * @returns Change flag\n   */\n  registerWorldChangeFlag(): UpdateFlag {\n    return this._updateFlagManager.register();\n  }\n\n  /**\n   * @internal\n   */\n  _parentChange(): void {\n    this._isParentDirty = true;\n    this._updateAllWorldFlag();\n  }\n\n  /**\n   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.\n   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.\n   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.\n   */\n  private _updateWorldPositionFlag(): void {\n    if (!this._isContainDirtyFlags(TransformFlag.WmWp)) {\n      this._worldAssociatedChange(TransformFlag.WmWp);\n      const nodeChildren = this._entity._children;\n      for (let i: number = 0, n: number = nodeChildren.length; i < n; i++) {\n        nodeChildren[i].transform?._updateWorldPositionFlag();\n      }\n    }\n  }\n\n  /**\n   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.\n   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.\n   * Get worldRotationQuaternion: Will trigger the world rotation (in quaternion) update of itself and all parent entities.\n   * Get worldRotation: Will trigger the world rotation(in euler and quaternion) update of itself and world rotation(in quaternion) update of all parent entities.\n   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.\n   */\n  private _updateWorldRotationFlag() {\n    if (!this._isContainDirtyFlags(TransformFlag.WmWeWq)) {\n      this._worldAssociatedChange(TransformFlag.WmWeWq);\n      const nodeChildren = this._entity._children;\n      for (let i: number = 0, n: number = nodeChildren.length; i < n; i++) {\n        nodeChildren[i].transform?._updateWorldPositionAndRotationFlag(); // Rotation update of parent entity will trigger world position and rotation update of all child entity.\n      }\n    }\n  }\n\n  /**\n   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.\n   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.\n   * Get worldRotationQuaternion: Will trigger the world rotation (in quaternion) update of itself and all parent entities.\n   * Get worldRotation: Will trigger the world rotation(in euler and quaternion) update of itself and world rotation(in quaternion) update of all parent entities.\n   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.\n   */\n  private _updateWorldPositionAndRotationFlag() {\n    if (!this._isContainDirtyFlags(TransformFlag.WmWpWeWq)) {\n      this._worldAssociatedChange(TransformFlag.WmWpWeWq);\n      const nodeChildren = this._entity._children;\n      for (let i: number = 0, n: number = nodeChildren.length; i < n; i++) {\n        nodeChildren[i].transform?._updateWorldPositionAndRotationFlag();\n      }\n    }\n  }\n\n  /**\n   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.\n   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.\n   * Get worldScale: Will trigger the scaling update of itself and all parent entities.\n   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix) to be false.\n   */\n  private _updateWorldScaleFlag() {\n    if (!this._isContainDirtyFlags(TransformFlag.WmWs)) {\n      this._worldAssociatedChange(TransformFlag.WmWs);\n      const nodeChildren = this._entity._children;\n      for (let i: number = 0, n: number = nodeChildren.length; i < n; i++) {\n        nodeChildren[i].transform?._updateWorldPositionAndScaleFlag();\n      }\n    }\n  }\n\n  /**\n   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.\n   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.\n   * Get worldScale: Will trigger the scaling update of itself and all parent entities.\n   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix) to be false.\n   */\n  private _updateWorldPositionAndScaleFlag(): void {\n    if (!this._isContainDirtyFlags(TransformFlag.WmWpWs)) {\n      this._worldAssociatedChange(TransformFlag.WmWpWs);\n      const nodeChildren = this._entity._children;\n      for (let i: number = 0, n: number = nodeChildren.length; i < n; i++) {\n        nodeChildren[i].transform?._updateWorldPositionAndScaleFlag();\n      }\n    }\n  }\n\n  /**\n   * Update all world transform property dirty flag, the principle is the same as above.\n   */\n  private _updateAllWorldFlag(): void {\n    if (!this._isContainDirtyFlags(TransformFlag.WmWpWeWqWs)) {\n      this._worldAssociatedChange(TransformFlag.WmWpWeWqWs);\n      const nodeChildren = this._entity._children;\n      for (let i: number = 0, n: number = nodeChildren.length; i < n; i++) {\n        nodeChildren[i].transform?._updateAllWorldFlag();\n      }\n    }\n  }\n\n  private _getParentTransform(): Transform | null {\n    if (!this._isParentDirty) {\n      return this._parentTransformCache;\n    }\n    let parentCache: Transform = null;\n    let parent = this._entity.parent;\n    while (parent) {\n      const transform = parent.transform;\n      if (transform) {\n        parentCache = transform;\n        break;\n      } else {\n        parent = parent.parent;\n      }\n    }\n    this._parentTransformCache = parentCache;\n    this._isParentDirty = false;\n    return parentCache;\n  }\n\n  private _getScaleMatrix(): Matrix3x3 {\n    const invRotation = Transform._tempQuat0;\n    const invRotationMat = Transform._tempMat30;\n    const worldRotScaMat = Transform._tempMat31;\n    const scaMat = Transform._tempMat32;\n    worldRotScaMat.setValueByMatrix(this.worldMatrix);\n    Quaternion.invert(this.worldRotationQuaternion, invRotation);\n    Matrix3x3.rotationQuaternion(invRotation, invRotationMat);\n    Matrix3x3.multiply(invRotationMat, worldRotScaMat, scaMat);\n    return scaMat;\n  }\n\n  private _isContainDirtyFlags(targetDirtyFlags: number): boolean {\n    return (this._dirtyFlag & targetDirtyFlags) === targetDirtyFlags;\n  }\n\n  private _isContainDirtyFlag(type: number): boolean {\n    return (this._dirtyFlag & type) != 0;\n  }\n\n  private _setDirtyFlagTrue(type: number) {\n    this._dirtyFlag |= type;\n  }\n\n  private _setDirtyFlagFalse(type: number) {\n    this._dirtyFlag &= ~type;\n  }\n\n  private _worldAssociatedChange(type: number): void {\n    this._dirtyFlag |= type;\n    this._updateFlagManager.distribute();\n  }\n\n  private _rotateByQuat(rotateQuat: Quaternion, relativeToLocal: boolean) {\n    if (relativeToLocal) {\n      Quaternion.multiply(this.rotationQuaternion, rotateQuat, this._rotationQuaternion);\n      this.rotationQuaternion = this._rotationQuaternion;\n    } else {\n      Quaternion.multiply(this.worldRotationQuaternion, rotateQuat, this._worldRotationQuaternion);\n      this.worldRotationQuaternion = this._worldRotationQuaternion;\n    }\n  }\n\n  private _translate(translation: Vector3, relativeToLocal: boolean = true): void {\n    if (relativeToLocal) {\n      this.position = this._position.add(translation);\n    } else {\n      this.worldPosition = this._worldPosition.add(translation);\n    }\n  }\n\n  private _rotateXYZ(x: number, y: number, z: number, relativeToLocal: boolean = true): void {\n    const radFactor = MathUtil.degreeToRadFactor;\n    const rotQuat = Transform._tempQuat0;\n    Quaternion.rotationEuler(x * radFactor, y * radFactor, z * radFactor, rotQuat);\n    this._rotateByQuat(rotQuat, relativeToLocal);\n  }\n}\n\n/**\n * Dirty flag of transform.\n */\nenum TransformFlag {\n  LocalEuler = 0x1,\n  LocalQuat = 0x2,\n  WorldPosition = 0x4,\n  WorldEuler = 0x8,\n  WorldQuat = 0x10,\n  WorldScale = 0x20,\n  LocalMatrix = 0x40,\n  WorldMatrix = 0x80,\n\n  /** WorldMatrix | WorldPosition */\n  WmWp = 0x84,\n  /** WorldMatrix | WorldEuler | WorldQuat */\n  WmWeWq = 0x98,\n  /** WorldMatrix | WorldPosition | WorldEuler | WorldQuat */\n  WmWpWeWq = 0x9c,\n  /** WorldMatrix | WorldScale */\n  WmWs = 0xa0,\n  /** WorldMatrix | WorldPosition | WorldScale */\n  WmWpWs = 0xa4,\n  /** WorldMatrix | WorldPosition | WorldEuler | WorldQuat | WorldScale */\n  WmWpWeWqWs = 0xbc\n}\n", "import { Matrix, Quaternion, Vector3 } from \"@oasis-engine/math\";\nimport { EngineObject } from \"./base\";\nimport { ComponentCloner } from \"./clone/ComponentCloner\";\nimport { Component } from \"./Component\";\nimport { Script } from \"./Script\";\nimport { ComponentsDependencies } from \"./ComponentsDependencies\";\nimport { Engine } from \"./Engine\";\nimport { Layer } from \"./Layer\";\nimport { Scene } from \"./Scene\";\nimport { Transform } from \"./Transform\";\nimport { UpdateFlag } from \"./UpdateFlag\";\nimport { DisorderedArray } from \"./DisorderedArray\";\n\n/**\n * Entity, be used as components container.\n */\nexport class Entity extends EngineObject {\n  /**\n   * @internal\n   */\n  static _findChildByName(root: Entity, name: string): Entity {\n    const children = root._children;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      if (child.name === name) {\n        return child;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @internal\n   */\n  static _traverseSetOwnerScene(entity: Entity, scene: Scene): void {\n    entity._scene = scene;\n    const children = entity._children;\n    for (let i = entity.childCount - 1; i >= 0; i--) {\n      this._traverseSetOwnerScene(children[i], scene);\n    }\n  }\n\n  /** The name of entity. */\n  name: string;\n  /** The layer the entity belongs to. */\n  layer: Layer = Layer.Layer0;\n  /** Transform component. */\n  readonly transform: Transform;\n\n  /** @internal */\n  _isActiveInHierarchy: boolean = false;\n  /** @internal */\n  _components: Component[] = [];\n  /** @internal */\n  _scripts: DisorderedArray<Script> = new DisorderedArray<Script>();\n  /** @internal */\n  _children: Entity[] = [];\n  /** @internal */\n  _scene: Scene;\n  /** @internal */\n  _isRoot: boolean = false;\n  /** @internal */\n  _isActive: boolean = true;\n\n  private _parent: Entity = null;\n  private _activeChangedComponents: Component[];\n\n  /**\n   * Whether to activate locally.\n   */\n  get isActive(): boolean {\n    return this._isActive;\n  }\n\n  set isActive(value: boolean) {\n    if (value !== this._isActive) {\n      this._isActive = value;\n      if (value) {\n        const parent = this._parent;\n        if (parent?._isActiveInHierarchy || (this._isRoot && this._scene._isActiveInEngine)) {\n          this._processActive();\n        }\n      } else {\n        if (this._isActiveInHierarchy) {\n          this._processInActive();\n        }\n      }\n    }\n  }\n\n  /**\n   * Whether it is active in the hierarchy.\n   */\n  get isActiveInHierarchy(): boolean {\n    return this._isActiveInHierarchy;\n  }\n\n  /**\n   * The parent entity.\n   */\n  get parent(): Entity {\n    return this._parent;\n  }\n\n  set parent(entity: Entity) {\n    if (entity !== this._parent) {\n      const oldParent = this._removeFromParent();\n      const newParent = (this._parent = entity);\n      if (newParent) {\n        newParent._children.push(this);\n        const parentScene = newParent._scene;\n        if (this._scene !== parentScene) {\n          Entity._traverseSetOwnerScene(this, parentScene);\n        }\n\n        if (newParent._isActiveInHierarchy) {\n          !this._isActiveInHierarchy && this._isActive && this._processActive();\n        } else {\n          this._isActiveInHierarchy && this._processInActive();\n        }\n      } else {\n        this._isActiveInHierarchy && this._processInActive();\n        if (oldParent) {\n          Entity._traverseSetOwnerScene(this, null);\n        }\n      }\n      this._setTransformDirty();\n    }\n  }\n\n  /**\n   * The children entities\n   */\n  get children(): Readonly<Entity[]> {\n    return this._children;\n  }\n\n  /**\n   * Number of the children entities\n   */\n  get childCount(): number {\n    return this._children.length;\n  }\n\n  /**\n   * The scene the entity belongs to.\n   */\n  get scene(): Scene {\n    return this._scene;\n  }\n\n  /**\n   * Create a entity.\n   * @param engine - The engine the entity belongs to.\n   */\n  constructor(engine: Engine, name?: string) {\n    super(engine);\n    this.name = name;\n    this.transform = this.addComponent(Transform);\n    this._inverseWorldMatFlag = this.transform.registerWorldChangeFlag();\n  }\n\n  /**\n   * Add component based on the component type.\n   * @param type - The type of the component.\n   * @returns\tThe component which has been added.\n   */\n  addComponent<T extends Component>(type: new (entity: Entity) => T): T {\n    ComponentsDependencies._addCheck(this, type);\n    const component = new type(this);\n    this._components.push(component);\n    if (this._isActiveInHierarchy) {\n      component._setActive(true);\n    }\n    return component;\n  }\n\n  /**\n   * Get component which match the type.\n   * @param type - The type of the component.\n   * @returns\tThe first component which match type.\n   */\n  getComponent<T extends Component>(type: new (entity: Entity) => T): T {\n    for (let i = this._components.length - 1; i >= 0; i--) {\n      const component = this._components[i];\n      if (component instanceof type) {\n        return component;\n      }\n    }\n  }\n\n  /**\n   * Get components which match the type.\n   * @param type - The type of the component.\n   * @param results - The components which match type.\n   * @returns\tThe components which match type.\n   */\n  getComponents<T extends Component>(type: new (entity: Entity) => T, results: T[]): T[] {\n    results.length = 0;\n    for (let i = this._components.length - 1; i >= 0; i--) {\n      const component = this._components[i];\n      if (component instanceof type) {\n        results.push(component);\n      }\n    }\n    return results;\n  }\n\n  /**\n   * Get the components which match the type of the entity and it's children.\n   * @param type - The component type.\n   * @param results - The components collection.\n   * @returns\tThe components collection which match the type.\n   */\n  getComponentsIncludeChildren<T extends Component>(type: new (entity: Entity) => T, results: T[]): T[] {\n    results.length = 0;\n    this._getComponentsInChildren<T>(type, results);\n    return results;\n  }\n\n  /**\n   * Add child entity.\n   * @param child - The child entity which want to be added.\n   */\n  addChild(child: Entity): void {\n    child.parent = this;\n  }\n\n  /**\n   * Remove child entity.\n   * @param child - The child entity which want to be removed.\n   */\n  removeChild(child: Entity): void {\n    child.parent = null;\n  }\n\n  /**\n   * Find child entity by index.\n   * @param index - The index of the child entity.\n   * @returns\tThe component which be found.\n   */\n  getChild(index: number): Entity {\n    return this._children[index];\n  }\n\n  /**\n   * Find child entity by name.\n   * @param name - The name of the entity which want to be found.\n   * @returns The component which be found.\n   */\n  findByName(name: string): Entity {\n    const children = this._children;\n    const child = Entity._findChildByName(this, name);\n    if (child) return child;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      const grandson = child.findByName(name);\n      if (grandson) {\n        return grandson;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Find the entity by path.\n   * @param path - The path fo the entity eg: /entity.\n   * @returns The component which be found.\n   */\n  findByPath(path: string): Entity {\n    const splits = path.split(\"/\");\n    let entity: Entity = this;\n    for (let i = 0, length = splits.length; i < length; ++i) {\n      const split = splits[i];\n      if (split) {\n        entity = Entity._findChildByName(entity, split);\n        if (!entity) {\n          return null;\n        }\n      }\n    }\n    return entity;\n  }\n\n  /**\n   * Create child entity.\n   * @param name - The child entity's name.\n   * @returns The child entity.\n   */\n  createChild(name?: string): Entity {\n    const child = new Entity(this.engine, name);\n    child.layer = this.layer;\n    child.parent = this;\n    return child;\n  }\n\n  /**\n   * Clear children entities.\n   */\n  clearChildren(): void {\n    const children = this._children;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      child._parent = null;\n      child._isActiveInHierarchy && child._processInActive();\n      Entity._traverseSetOwnerScene(child, null); // Must after child._processInActive().\n    }\n    children.length = 0;\n  }\n\n  /**\n   * Clone\n   * @returns Cloned entity.\n   */\n  clone(): Entity {\n    const cloneEntity = new Entity(this._engine, this.name);\n\n    cloneEntity._isActive = this._isActive;\n    cloneEntity.transform.localMatrix = this.transform.localMatrix;\n\n    const children = this._children;\n    for (let i = 0, len = this._children.length; i < len; i++) {\n      const child = children[i];\n      cloneEntity.addChild(child.clone());\n    }\n\n    const components = this._components;\n    for (let i = 0, n = components.length; i < n; i++) {\n      const sourceComp = components[i];\n      if (!(sourceComp instanceof Transform)) {\n        const targetComp = cloneEntity.addComponent(<new (entity: Entity) => Component>sourceComp.constructor);\n        ComponentCloner.cloneComponent(sourceComp, targetComp);\n      }\n    }\n\n    return cloneEntity;\n  }\n\n  /**\n   * Destroy self.\n   */\n  destroy(): void {\n    const abilityArray = this._components;\n    for (let i = abilityArray.length - 1; i >= 0; i--) {\n      abilityArray[i].destroy();\n    }\n    this._components.length = 0;\n\n    const children = this._children;\n    for (let i = children.length - 1; i >= 0; i--) {\n      children[i].destroy();\n    }\n    this._children.length = 0;\n\n    if (this._parent != null) {\n      const parentChildren = this._parent._children;\n      parentChildren.splice(parentChildren.indexOf(this), 1);\n    }\n    this._parent = null;\n  }\n\n  /**\n   * @internal\n   */\n  _removeComponent(component: Component): void {\n    ComponentsDependencies._removeCheck(this, component.constructor as any);\n    const components = this._components;\n    components.splice(components.indexOf(component), 1);\n  }\n\n  /**\n   * @internal\n   */\n  _addScript(script: Script) {\n    script._entityCacheIndex = this._scripts.length;\n    this._scripts.add(script);\n  }\n\n  /**\n   * @internal\n   */\n  _removeScript(script: Script): void {\n    const replaced = this._scripts.deleteByIndex(script._entityCacheIndex);\n    replaced && (replaced._entityCacheIndex = script._entityCacheIndex);\n    script._entityCacheIndex = -1;\n  }\n\n  /**\n   * @internal\n   */\n  _removeFromParent(): Entity {\n    const oldParent = this._parent;\n    if (oldParent != null) {\n      const oldParentChildren = oldParent._children;\n      oldParentChildren.splice(oldParentChildren.indexOf(this), 1);\n      this._parent = null;\n    }\n    return oldParent;\n  }\n\n  /**\n   * @internal\n   */\n  _processActive(): void {\n    if (this._activeChangedComponents) {\n      throw \"Note: can't set the 'main inActive entity' active in hierarchy, if the operation is in main inActive entity or it's children script's onDisable Event.\";\n    }\n    this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();\n    this._setActiveInHierarchy(this._activeChangedComponents);\n    this._setActiveComponents(true);\n  }\n\n  /**\n   * @internal\n   */\n  _processInActive(): void {\n    if (this._activeChangedComponents) {\n      throw \"Note: can't set the 'main active entity' inActive in hierarchy, if the operation is in main active entity or it's children script's onEnable Event.\";\n    }\n    this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();\n    this._setInActiveInHierarchy(this._activeChangedComponents);\n    this._setActiveComponents(false);\n  }\n\n  private _getComponentsInChildren<T extends Component>(type: new (entity: Entity) => T, results: T[]): void {\n    for (let i = this._components.length - 1; i >= 0; i--) {\n      const component = this._components[i];\n      if (component instanceof type) {\n        results.push(component);\n      }\n    }\n    for (let i = this._children.length - 1; i >= 0; i--) {\n      this._children[i]._getComponentsInChildren<T>(type, results);\n    }\n  }\n\n  private _setActiveComponents(isActive: boolean): void {\n    const activeChangedComponents = this._activeChangedComponents;\n    for (let i = 0, length = activeChangedComponents.length; i < length; ++i) {\n      activeChangedComponents[i]._setActive(isActive);\n    }\n    this._engine._componentsManager.putActiveChangedTempList(activeChangedComponents);\n    this._activeChangedComponents = null;\n  }\n\n  private _setActiveInHierarchy(activeChangedComponents: Component[]): void {\n    this._isActiveInHierarchy = true;\n    const components = this._components;\n    for (let i = components.length - 1; i >= 0; i--) {\n      activeChangedComponents.push(components[i]);\n    }\n    const children = this._children;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child: Entity = children[i];\n      child.isActive && child._setActiveInHierarchy(activeChangedComponents);\n    }\n  }\n\n  private _setInActiveInHierarchy(activeChangedComponents: Component[]): void {\n    this._isActiveInHierarchy = false;\n    const components = this._components;\n    for (let i = components.length - 1; i >= 0; i--) {\n      activeChangedComponents.push(components[i]);\n    }\n    const children = this._children;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child: Entity = children[i];\n      child.isActive && child._setInActiveInHierarchy(activeChangedComponents);\n    }\n  }\n\n  private _setTransformDirty() {\n    if (this.transform) {\n      this.transform._parentChange();\n    } else {\n      for (let i = 0, len = this._children.length; i < len; i++) {\n        this._children[i]._setTransformDirty();\n      }\n    }\n  }\n\n  //--------------------------------------------------------------deprecated----------------------------------------------------------------\n  private _invModelMatrix: Matrix = new Matrix();\n  private _inverseWorldMatFlag: UpdateFlag;\n\n  /**\n   * @deprecated\n   * Use transform.position instead.\n   */\n  get position(): Vector3 {\n    return this.transform.position;\n  }\n\n  set position(val: Vector3) {\n    this.transform.position = val;\n  }\n\n  /**\n   * @deprecated\n   * Use transform.worldPosition instead.\n   */\n  get worldPosition(): Vector3 {\n    return this.transform.worldPosition;\n  }\n\n  set worldPosition(val: Vector3) {\n    this.transform.worldPosition = val;\n  }\n\n  /**\n   * @deprecated\n   * Use transform.rotationQuaternion instead.\n   */\n  get rotation(): Quaternion {\n    return this.transform.rotationQuaternion;\n  }\n\n  set rotation(val: Quaternion) {\n    this.transform.rotationQuaternion = val;\n  }\n\n  /**\n   * @deprecated\n   * Use transform.scale instead.\n   */\n  get scale(): Vector3 {\n    return this.transform.scale;\n  }\n\n  set scale(val: Vector3) {\n    this.transform.scale = val;\n  }\n\n  /**\n   * @deprecated\n   */\n  getInvModelMatrix(): Matrix {\n    if (this._inverseWorldMatFlag.flag) {\n      Matrix.invert(this.transform.worldMatrix, this._invModelMatrix);\n      this._inverseWorldMatFlag.flag = false;\n    }\n    return this._invModelMatrix;\n  }\n}\n", "import { SceneFeature } from \"./SceneFeature\";\nimport { EngineFeature } from \"./EngineFeature\";\nimport { Scene } from \"./Scene\";\nimport { Engine } from \"./Engine\";\n\n/**\n * Manage a set of feature objects.\n */\nexport class FeatureManager<T extends EngineFeature | SceneFeature> {\n  private _features: Array<new (engine: Engine) => T> = [];\n\n  private _objects = [];\n\n  /**\n   * Register a feature.\n   * @param {SceneFeature|EngineFeature} IFeature\n   */\n  public registerFeature(IFeature: new () => T): void {\n    const featureArray = this._features;\n\n    // Search by type, avoid adding\n    for (let i = 0, len = featureArray.length; i < len; i++) {\n      if (featureArray[i] === IFeature) {\n        return;\n      }\n    }\n\n    // Add to global array\n    featureArray.push(IFeature);\n\n    // Add to existing scene\n    const objectArray = this._objects;\n    for (let i = 0, len = objectArray.length; i < len; i++) {\n      objectArray[i].features.push(new IFeature());\n    }\n  }\n\n  /**\n   * Add an feature with functional characteristics.\n   * @param {Scene|Engine} obj - Scene or engine\n   */\n  public addObject(obj: Scene | Engine): void {\n    obj.features = [];\n    for (let i = 0, len = this._features.length; i < len; i++) {\n      obj.features.push(new this._features[i]((<any>obj).engine ?? <any>obj) as any);\n    }\n    this._objects.push(obj);\n  }\n\n  /**\n   * Call the specified method of the feature.\n   * @param obj - Scene or engine\n   * @param method - Method name\n   * @param args - Function args\n   */\n  public callFeatureMethod(obj: Scene | Engine, method: string, args: any[]): void {\n    const features = obj.features;\n    const count = features.length;\n\n    for (let i = 0; i < count; i++) {\n      const feature = features[i];\n      if (feature[method]) {\n        feature[method].apply(feature, args);\n      }\n    }\n  }\n\n  /**\n   * Find feature.\n   * @param obj - Scene or engine\n   * @param IFeature - plug-in\n   */\n\n  public findFeature(obj: Scene | Engine, IFeature: new () => T): T {\n    const features = obj.features;\n    const count = features.length;\n\n    for (let i = 0; i < count; i++) {\n      const feature = features[i];\n      if (feature.constructor === (IFeature as any)) {\n        return feature as any;\n      }\n    }\n    return undefined;\n  }\n}\n", "/**\n * Render queue type.\n */\nexport enum RenderQueueType {\n  /** Opaque queue. */\n  Opaque = 1000,\n  /** Opaque queue, alpha cutoff. */\n  AlphaTest = 2000,\n  /** Transparent queue, rendering from back to front to ensure correct rendering of transparent objects. */\n  Transparent = 3000\n}\n", "import { EngineObject } from \"../base/EngineObject\";\nimport { Engine } from \"../Engine\";\nimport { IRefObject } from \"./IRefObject\";\n\n/**\n * The base class of assets, with reference counting capability.\n */\nexport abstract class RefObject extends EngineObject implements IRefObject {\n  /** Whether to ignore the garbage collection check, if it is true, it will not be affected by ResourceManager.gc(). */\n  isGCIgnored: boolean = false;\n\n  private _refCount: number = 0;\n  private _destroyed: boolean = false;\n\n  /**\n   * Counted by valid references.\n   */\n  get refCount(): number {\n    return this._refCount;\n  }\n\n  /**\n   * Whether it has been destroyed.\n   */\n  get destroyed(): boolean {\n    return this._destroyed;\n  }\n\n  protected constructor(engine: Engine) {\n    super(engine);\n    engine.resourceManager._addRefObject(this.instanceId, this);\n  }\n\n  /**\n   * Destroy self.\n   * @param force - Whether to force the destruction, if it is false, refCount = 0 can be released successfully.\n   * @returns Whether the release was successful.\n   */\n  destroy(force: boolean = false): boolean {\n    if (this._destroyed) return true;\n    if (!force && this._refCount !== 0) return false;\n    const resourceManager = this._engine.resourceManager;\n    // resourceManager maybe null,because engine has destroyed.\n    // TODO:the right way to fix this is to ensure destroy all when call engine.destroy,thus don't need to add this project.\n    if (resourceManager) {\n      resourceManager._deleteAsset(this);\n      resourceManager._deleteRefObject(this.instanceId);\n    }\n\n    const refCount = this._getRefCount();\n    if (refCount > 0) {\n      this._addRefCount(-refCount);\n    }\n    this._engine = null;\n    this._onDestroy();\n    this._destroyed = true;\n    return true;\n  }\n\n  /**\n   * @internal\n   */\n  _getRefCount(): number {\n    return this._refCount;\n  }\n\n  /**\n   * @internal\n   * Add reference resource.\n   */\n  _addRefCount(value: number): void {\n    this._refCount += value;\n  }\n\n  /**\n   * @internal\n   * Remove reference resource.\n   */\n  _addToResourceManager(path: string): void {\n    this._engine.resourceManager._addAsset(path, this);\n  }\n\n  /**\n   * Called when the resource is destroyed.\n   * Subclasses can override this function.\n   */\n  protected abstract _onDestroy(): void;\n}\n", "/**\n * Shader data grouping.\n */\nexport enum ShaderDataGroup {\n  /** Scene group. */\n  Scene,\n  /** Camera group. */\n  Camera,\n  /** Renderer group. */\n  Renderer,\n  /** material group. */\n  Material\n}\n", "import { RefObject } from \"../asset/RefObject\";\nimport { Logger } from \"../base/Logger\";\nimport { IPlatformTexture } from \"../renderingHardwareInterface\";\nimport { TextureFilterMode } from \"./enums/TextureFilterMode\";\nimport { TextureWrapMode } from \"./enums/TextureWrapMode\";\n\n/**\n * The base class of texture, contains some common functions of texture-related classes.\n */\nexport abstract class Texture extends RefObject {\n  name: string;\n\n  /** @internal */\n  _platformTexture: IPlatformTexture;\n  /** @internal */\n  _mipmap: boolean;\n\n  protected _width: number;\n  protected _height: number;\n  protected _mipmapCount: number;\n\n  private _wrapModeU: TextureWrapMode;\n  private _wrapModeV: TextureWrapMode;\n  private _filterMode: TextureFilterMode;\n  private _anisoLevel: number = 1;\n\n  /**\n   * The width of the texture.\n   */\n  get width(): number {\n    return this._width;\n  }\n\n  /**\n   * The height of the texture.\n   */\n  get height(): number {\n    return this._height;\n  }\n\n  /**\n   * Wrapping mode for texture coordinate S.\n   */\n  get wrapModeU(): TextureWrapMode {\n    return this._wrapModeU;\n  }\n\n  set wrapModeU(value: TextureWrapMode) {\n    if (value === this._wrapModeU) return;\n    this._wrapModeU = value;\n\n    this._platformTexture.wrapModeU = value;\n  }\n\n  /**\n   * Wrapping mode for texture coordinate T.\n   */\n  get wrapModeV(): TextureWrapMode {\n    return this._wrapModeV;\n  }\n\n  set wrapModeV(value: TextureWrapMode) {\n    if (value === this._wrapModeV) return;\n    this._wrapModeV = value;\n\n    this._platformTexture.wrapModeV = value;\n  }\n\n  /**\n   * Texture mipmapping count.\n   */\n  get mipmapCount(): number {\n    return this._mipmapCount;\n  }\n\n  /**\n   * Filter mode for texture.\n   */\n  get filterMode(): TextureFilterMode {\n    return this._filterMode;\n  }\n\n  set filterMode(value: TextureFilterMode) {\n    if (value === this._filterMode) return;\n    this._filterMode = value;\n\n    this._platformTexture.filterMode = value;\n  }\n\n  /**\n   * Anisotropic level for texture.\n   */\n  get anisoLevel(): number {\n    return this._anisoLevel;\n  }\n\n  set anisoLevel(value: number) {\n    const max = this._engine._hardwareRenderer.capability.maxAnisoLevel;\n\n    if (value > max) {\n      Logger.warn(`anisoLevel:${value}, exceeds the limit and is automatically downgraded to:${max}`);\n      value = max;\n    }\n\n    if (value < 1) {\n      Logger.warn(`anisoLevel:${value}, must be greater than 0, and is automatically downgraded to 1`);\n      value = 1;\n    }\n\n    if (value === this._anisoLevel) return;\n\n    this._anisoLevel = value;\n\n    this._platformTexture.anisoLevel = value;\n  }\n\n  /**\n   * Generate multi-level textures based on the 0th level data.\n   */\n  generateMipmaps(): void {\n    if (!this._mipmap) return;\n\n    this._platformTexture.generateMipmaps();\n  }\n\n  /**\n   * @override\n   */\n  _onDestroy() {\n    this._platformTexture.destroy();\n    this._platformTexture = null;\n  }\n\n  /**\n   * Get the maximum mip level of the corresponding size:rounding down.\n   * @remarks http://download.nvidia.com/developer/Papers/2005/NP2_Mipmapping/NP2_Mipmap_Creation.pdf\n   */\n  protected _getMaxMiplevel(size: number): number {\n    return Math.floor(Math.log2(size));\n  }\n\n  protected _getMipmapCount(): number {\n    return this._mipmap ? Math.floor(Math.log2(Math.max(this._width, this._height))) + 1 : 1;\n  }\n}\n", "import pbr_common_frag_define from \"./common_frag_define.glsl\";\nimport pbr_util_frag_define from \"./util_frag_define.glsl\";\n\n/** IBL define */\nimport pbr_envmap_light_frag_define from \"./envmap_light_frag_define.glsl\";\n\n/** prop & texture */\nimport pbr_base_frag_define from \"./base_frag_define.glsl\";\nimport pbr_texture_frag_define from \"./texture_frag_define.glsl\";\n\n/** runtime context */\nimport pbr_runtime_frag_define from \"./runtime_frag_define.glsl\";\n\n// todo: BxDF\nimport pbr_brdf_cook_torrance_frag_define from \"./brdf_cook_torrance_frag_define.glsl\";\n\n/** direct + IBL */\nimport pbr_direct_irradiance_frag_define from \"./direct_irradiance_frag_define.glsl\";\nimport pbr_ibl_specular_frag_define from \"./ibl_specular_frag_define.glsl\";\nimport pbr_ibl_diffuse_frag_define from \"./ibl_diffuse_frag_define.glsl\";\n\nimport pbr_begin_frag from \"./begin_frag.glsl\";\nimport pbr_direct_irradiance_frag from \"./direct_irradiance_frag.glsl\";\nimport pbr_ibl_diffuse_frag from \"./ibl_diffuse_frag.glsl\";\nimport pbr_ibl_specular_frag from \"./ibl_specular_frag.glsl\";\nimport pbr_end_frag from \"./end_frag.glsl\";\n\nexport default {\n  pbr_common_frag_define,\n  pbr_util_frag_define,\n\n  pbr_envmap_light_frag_define,\n\n  pbr_base_frag_define,\n  pbr_texture_frag_define,\n\n  pbr_runtime_frag_define,\n\n  pbr_brdf_cook_torrance_frag_define,\n\n  pbr_direct_irradiance_frag_define,\n  pbr_ibl_specular_frag_define,\n  pbr_ibl_diffuse_frag_define,\n\n  pbr_begin_frag,\n  pbr_direct_irradiance_frag,\n  pbr_ibl_diffuse_frag,\n  pbr_ibl_specular_frag,\n  pbr_end_frag\n};\n", "import common from \"./common.glsl\";\nimport common_vert from \"./common_vert.glsl\";\nimport common_frag from \"./common_frag.glsl\";\n\nimport color_share from \"./color_share.glsl\";\nimport normal_share from \"./normal_share.glsl\";\nimport uv_share from \"./uv_share.glsl\";\nimport worldpos_share from \"./worldpos_share.glsl\";\nimport shadow_share from \"./shadow_share.glsl\";\nimport fog_share from \"./fog_share.glsl\";\n\nimport begin_normal_vert from \"./begin_normal_vert.glsl\";\nimport begin_position_vert from \"./begin_position_vert.glsl\";\n\nimport position_vert from \"./position_vert.glsl\";\nimport color_vert from \"./color_vert.glsl\";\nimport normal_vert from \"./normal_vert.glsl\";\nimport skinning_vert from \"./skinning_vert.glsl\";\nimport blendShape_input from \"./blendShape_input.glsl\";\nimport blendShape_vert from \"./blendShape_vert.glsl\";\nimport uv_vert from \"./uv_vert.glsl\";\nimport worldpos_vert from \"./worldpos_vert.glsl\";\nimport shadow_vert from \"./shadow_vert.glsl\";\nimport fog_vert from \"./fog_vert.glsl\";\n\nimport direct_light_frag from \"./direct_light_frag.glsl\";\nimport point_light_frag from \"./point_light_frag.glsl\";\nimport spot_light_frag from \"./spot_light_frag.glsl\";\nimport mobile_material_frag from \"./mobile_material_frag.glsl\";\nimport fog_frag from \"./fog_frag.glsl\";\n\nimport begin_mobile_frag from \"./begin_mobile_frag.glsl\";\nimport begin_viewdir_frag from \"./begin_viewdir_frag.glsl\";\n\nimport mobile_blinnphong_frag from \"./mobile_blinnphong_frag.glsl\";\n\nimport noise_common from \"./noise_common.glsl\";\nimport noise_cellular_2D from \"./noise_cellular_2D.glsl\";\nimport noise_cellular_2x2 from \"./noise_cellular_2x2.glsl\";\nimport noise_cellular_2x2x2 from \"./noise_cellular_2x2x2.glsl\";\nimport noise_cellular_3D from \"./noise_cellular_3D.glsl\";\nimport noise_cellular from \"./noise_cellular.glsl\";\nimport noise_perlin_2D from \"./noise_perlin_2D.glsl\";\nimport noise_perlin_3D from \"./noise_perlin_3D.glsl\";\nimport noise_perlin_4D from \"./noise_perlin_4D.glsl\";\nimport noise_perlin from \"./noise_perlin.glsl\";\nimport noise_psrd_2D from \"./noise_psrd_2D.glsl\";\nimport noise_simplex_2D from \"./noise_simplex_2D.glsl\";\nimport noise_simplex_3D_grad from \"./noise_simplex_3D_grad.glsl\";\nimport noise_simplex_3D from \"./noise_simplex_3D.glsl\";\nimport noise_simplex_4D from \"./noise_simplex_4D.glsl\";\nimport noise_simplex from \"./noise_simplex.glsl\";\n\nimport gamma_frag from \"./gamma_frag.glsl\";\n\nimport PBRShaderLib from \"./pbr\";\n\nimport normal_get from \"./normal_get.glsl\";\n\nexport const ShaderLib = {\n  common,\n  common_vert,\n  common_frag,\n\n  color_share,\n  normal_share,\n  uv_share,\n  worldpos_share,\n  shadow_share,\n  fog_share,\n\n  begin_normal_vert,\n  begin_position_vert,\n\n  position_vert,\n  color_vert,\n  normal_vert,\n  skinning_vert,\n  blendShape_input,\n  blendShape_vert,\n  uv_vert,\n  worldpos_vert,\n  shadow_vert,\n  fog_vert,\n\n  direct_light_frag,\n  point_light_frag,\n  spot_light_frag,\n  mobile_material_frag,\n  fog_frag,\n\n  begin_mobile_frag,\n  begin_viewdir_frag,\n\n  mobile_blinnphong_frag,\n\n  noise_common,\n  noise_cellular_2D,\n  noise_cellular_2x2,\n  noise_cellular_2x2x2,\n  noise_cellular_3D,\n  noise_cellular,\n  noise_perlin_2D,\n  noise_perlin_3D,\n  noise_perlin_4D,\n  noise_perlin,\n  noise_psrd_2D,\n  noise_simplex_2D,\n  noise_simplex_3D_grad,\n  noise_simplex_3D,\n  noise_simplex_4D,\n  noise_simplex,\n\n  gamma_frag,\n\n  ...PBRShaderLib,\n  normal_get\n};\n", "import { ShaderLib } from \"./ShaderLib\";\nimport { Logger } from \"../base/Logger\";\n\nclass ShaderFactory {\n  static parseCustomMacros(macros: string[]) {\n    return (\n      macros.map((m) => `#define ${m}\\n`).join(\"\")\n    );\n  }\n\n  static parseIncludes(src: string) {\n    const regex = /^[ \\t]*#include +<([\\w\\d.]+)>/gm;\n\n    function replace(match, slice) {\n      var replace = ShaderLib[slice];\n\n      if (replace === undefined) {\n        Logger.error(`Shader slice \"${match.trim()}\" not founded.`);\n        return \"\";\n      }\n\n      return ShaderFactory.parseIncludes(replace);\n    }\n\n    return src.replace(regex, replace);\n  }\n\n  /**\n   * GLSL extension.\n   * @param {string[]} extensions - such as [\"GL_EXT_shader_texture_lod\"]\n   * */\n  static parseExtension(extensions: string[]) {\n    return (\n      extensions.map((e) => `#extension ${e} : enable\\n`).join(\"\")\n    );\n  }\n\n  /**\n   * Convert lower GLSL version to GLSL 300 es.\n   * @param shader - code\n   * @param isFrag - Whether it is a fragment shader.\n   * */\n  static convertTo300(shader: string, isFrag?: boolean) {\n    /** replace attribute and in */\n    shader = shader.replace(/\\battribute\\b/g, \"in\");\n    shader = shader.replace(/\\bvarying\\b/g, isFrag ? \"in\" : \"out\");\n\n    /** replace api */\n    shader = shader.replace(/\\btexture(2D|Cube)\\b/g, \"texture\");\n    shader = shader.replace(/\\btexture(2D|Cube)LodEXT\\b/g, \"textureLod\");\n    if (isFrag) {\n      const isMRT = /\\bgl_FragData\\[.+?\\]/g.test(shader);\n      if (isMRT) {\n        shader = shader.replace(/\\bgl_FragColor\\b/g, \"gl_FragData[0]\");\n        const result = shader.match(/\\bgl_FragData\\[.+?\\]/g);\n        shader = this._replaceMRTShader(shader, result);\n      } else {\n        shader = shader.replace(/void\\s+?main\\s*\\(/g, `out vec4 glFragColor;\\nvoid main(`);\n        shader = shader.replace(/\\bgl_FragColor\\b/g, \"glFragColor\");\n      }\n    }\n\n    return shader;\n  }\n\n  private static _replaceMRTShader(shader: string, result: string[]): string {\n    let declaration = \"\";\n    const mrtIndexSet = new Set();\n\n    for (let i = 0; i < result.length; i++) {\n      const res = result[i].match(/\\bgl_FragData\\[(.+?)\\]/);\n      mrtIndexSet.add(res[1]);\n    }\n\n    mrtIndexSet.forEach((index) => {\n      declaration += `layout(location=${index}) out vec4 fragOutColor${index};\\n`;\n    });\n    declaration += `void main(`;\n\n    shader = shader.replace(/\\bgl_FragData\\[(.+?)\\]/g, \"fragOutColor$1\");\n\n    shader = shader.replace(/void\\s+?main\\s*\\(/g, declaration);\n    return shader;\n  }\n}\n\nexport { ShaderFactory };\n", "/**\n * Shader macro\u3002\n */\nexport class ShaderMacro {\n  /** name */\n  readonly name: string;\n\n  /** @internal */\n  _index: number;\n  /** @internal */\n  _value: number;\n\n  /**\n   * @internal\n   */\n  constructor(name: string, index: number, value: number) {\n    this.name = name;\n    this._index = index;\n    this._value = value;\n  }\n}\n", "import { Color, Matrix, Vector2, Vector3, Vector4 } from \"@oasis-engine/math\";\nimport { Engine } from \"../Engine\";\nimport { IHardwareRenderer } from \"../renderingHardwareInterface/IHardwareRenderer\";\nimport { Texture } from \"../texture/Texture\";\nimport { ShaderPropertyValueType } from \"./ShaderData\";\n\n/**\n * Shader uniform\u3002\n * @internal\n */\nexport class ShaderUniform {\n  name: string;\n  propertyId: number;\n  location: WebGLUniformLocation;\n  applyFunc: (shaderUniform: ShaderUniform, value: ShaderPropertyValueType) => void;\n  cacheValue: number | Vector2 | Vector3 | Vector4;\n  textureIndex: GLenum | GLenum[];\n  textureDefault: Texture | Texture[];\n\n  private _rhi: IHardwareRenderer;\n  private _gl: WebGLRenderingContext;\n\n  constructor(engine: Engine) {\n    const rhi = engine._hardwareRenderer;\n    this._rhi = rhi;\n    this._gl = rhi.gl;\n  }\n\n  upload1f(shaderUniform: ShaderUniform, value: number): void {\n    if (this.cacheValue !== value) {\n      this._gl.uniform1f(shaderUniform.location, value);\n      this.cacheValue = value;\n    }\n  }\n\n  upload1fv(shaderUniform: ShaderUniform, value: Float32Array): void {\n    this._gl.uniform1fv(shaderUniform.location, value);\n  }\n\n  upload2f(shaderUniform: ShaderUniform, value: Vector2 | Vector3 | Vector4 | Color): void {\n    const cacheValue = <Vector2>this.cacheValue;\n    if ((<Color>value).r !== undefined) {\n      if (cacheValue.x !== (<Color>value).r || cacheValue.y !== (<Color>value).g) {\n        this._gl.uniform2f(shaderUniform.location, (<Color>value).r, (<Color>value).g);\n        cacheValue.x = (<Color>value).r;\n        cacheValue.y = (<Color>value).g;\n      }\n    } else {\n      if (cacheValue.x !== (<Vector2>value).x || cacheValue.y !== (<Vector2>value).y) {\n        this._gl.uniform2f(shaderUniform.location, (<Vector2>value).x, (<Vector2>value).y);\n        cacheValue.x = (<Vector2>value).x;\n        cacheValue.y = (<Vector2>value).y;\n      }\n    }\n  }\n\n  upload2fv(shaderUniform: ShaderUniform, value: Float32Array): void {\n    this._gl.uniform2fv(shaderUniform.location, value);\n  }\n\n  upload3f(shaderUniform: ShaderUniform, value: Vector3 | Vector4 | Color): void {\n    const cacheValue = <Vector3>this.cacheValue;\n    if ((<Color>value).r !== undefined) {\n      if (cacheValue.x !== (<Color>value).r || cacheValue.y !== (<Color>value).g || cacheValue.z !== (<Color>value).b) {\n        this._gl.uniform3f(shaderUniform.location, (<Color>value).r, (<Color>value).g, (<Color>value).b);\n        cacheValue.x = (<Color>value).r;\n        cacheValue.y = (<Color>value).g;\n        cacheValue.z = (<Color>value).b;\n      }\n    } else {\n      if (\n        cacheValue.x !== (<Vector3>value).x ||\n        cacheValue.y !== (<Vector3>value).y ||\n        cacheValue.z !== (<Vector3>value).z\n      ) {\n        this._gl.uniform3f(shaderUniform.location, (<Vector3>value).x, (<Vector3>value).y, (<Vector3>value).z);\n        cacheValue.x = (<Vector3>value).x;\n        cacheValue.y = (<Vector3>value).y;\n        cacheValue.z = (<Vector3>value).z;\n      }\n    }\n  }\n\n  upload3fv(shaderUniform: ShaderUniform, value: Float32Array): void {\n    this._gl.uniform3fv(shaderUniform.location, value);\n  }\n\n  upload4f(shaderUniform: ShaderUniform, value: Vector4 | Color): void {\n    const cacheValue = <Vector4>this.cacheValue;\n    if ((<Color>value).r !== undefined) {\n      if (\n        cacheValue.x !== (<Color>value).r ||\n        cacheValue.y !== (<Color>value).g ||\n        cacheValue.z !== (<Color>value).b ||\n        cacheValue.w !== (<Color>value).a\n      ) {\n        this._gl.uniform4f(\n          shaderUniform.location,\n          (<Color>value).r,\n          (<Color>value).g,\n          (<Color>value).b,\n          (<Color>value).a\n        );\n        cacheValue.x = (<Color>value).r;\n        cacheValue.y = (<Color>value).g;\n        cacheValue.z = (<Color>value).b;\n        cacheValue.w = (<Color>value).a;\n      }\n    } else {\n      if (\n        cacheValue.x !== (<Vector4>value).x ||\n        cacheValue.y !== (<Vector4>value).y ||\n        cacheValue.z !== (<Vector4>value).z ||\n        cacheValue.w !== (<Vector4>value).w\n      ) {\n        this._gl.uniform4f(\n          shaderUniform.location,\n          (<Vector4>value).x,\n          (<Vector4>value).y,\n          (<Vector4>value).z,\n          (<Vector4>value).w\n        );\n        cacheValue.x = (<Vector4>value).x;\n        cacheValue.y = (<Vector4>value).y;\n        cacheValue.z = (<Vector4>value).z;\n        cacheValue.w = (<Vector4>value).w;\n      }\n    }\n  }\n\n  upload4fv(shaderUniform: ShaderUniform, value: Float32Array): void {\n    this._gl.uniform4fv(shaderUniform.location, value);\n  }\n\n  upload1i(shaderUniform: ShaderUniform, value: number): void {\n    if (this.cacheValue !== value) {\n      this._gl.uniform1i(shaderUniform.location, value);\n      this.cacheValue = value;\n    }\n  }\n\n  upload1iv(shaderUniform: ShaderUniform, value: Int32Array): void {\n    this._gl.uniform1iv(shaderUniform.location, value);\n  }\n\n  upload2i(shaderUniform: ShaderUniform, value: Vector2 | Vector3 | Vector4 | Color): void {\n    const cacheValue = <Vector2>this.cacheValue;\n    if ((<Color>value).r !== undefined) {\n      if (cacheValue.x !== (<Color>value).r || cacheValue.y !== (<Color>value).g) {\n        this._gl.uniform2i(shaderUniform.location, (<Color>value).r, (<Color>value).g);\n        cacheValue.x = (<Color>value).r;\n        cacheValue.y = (<Color>value).g;\n      }\n    } else {\n      if (cacheValue.x !== (<Vector2>value).x || cacheValue.y !== (<Vector2>value).y) {\n        this._gl.uniform2i(shaderUniform.location, (<Vector2>value).x, (<Vector2>value).y);\n        cacheValue.x = (<Vector2>value).x;\n        cacheValue.y = (<Vector2>value).y;\n      }\n    }\n  }\n\n  upload2iv(shaderUniform: ShaderUniform, value: Int32Array): void {\n    this._gl.uniform2iv(shaderUniform.location, value);\n  }\n\n  upload3i(shaderUniform: ShaderUniform, value: Vector3 | Vector4 | Color): void {\n    const cacheValue = <Vector3>this.cacheValue;\n    if ((<Color>value).r !== undefined) {\n      if (cacheValue.x !== (<Color>value).r || cacheValue.y !== (<Color>value).g || cacheValue.z !== (<Color>value).b) {\n        this._gl.uniform3i(shaderUniform.location, (<Color>value).r, (<Color>value).g, (<Color>value).b);\n        cacheValue.x = (<Color>value).r;\n        cacheValue.y = (<Color>value).g;\n        cacheValue.z = (<Color>value).b;\n      }\n    } else {\n      if (\n        cacheValue.x !== (<Vector3>value).x ||\n        cacheValue.y !== (<Vector3>value).y ||\n        cacheValue.z !== (<Vector3>value).z\n      ) {\n        this._gl.uniform3i(shaderUniform.location, (<Vector3>value).x, (<Vector3>value).y, (<Vector3>value).z);\n        cacheValue.x = (<Vector3>value).x;\n        cacheValue.y = (<Vector3>value).y;\n        cacheValue.z = (<Vector3>value).z;\n      }\n    }\n  }\n  upload3iv(shaderUniform: ShaderUniform, value: Int32Array): void {\n    this._gl.uniform3iv(shaderUniform.location, value);\n  }\n  upload4i(shaderUniform: ShaderUniform, value: Vector4 | Color): void {\n    const cacheValue = <Vector4>this.cacheValue;\n    if ((<Color>value).r !== undefined) {\n      if (\n        cacheValue.x !== (<Color>value).r ||\n        cacheValue.y !== (<Color>value).g ||\n        cacheValue.z !== (<Color>value).b ||\n        cacheValue.w !== (<Color>value).a\n      ) {\n        this._gl.uniform4i(\n          shaderUniform.location,\n          (<Color>value).r,\n          (<Color>value).g,\n          (<Color>value).b,\n          (<Color>value).a\n        );\n        cacheValue.x = (<Color>value).r;\n        cacheValue.y = (<Color>value).g;\n        cacheValue.z = (<Color>value).b;\n        cacheValue.w = (<Color>value).a;\n      }\n    } else {\n      if (\n        cacheValue.x !== (<Vector4>value).x ||\n        cacheValue.y !== (<Vector4>value).y ||\n        cacheValue.z !== (<Vector4>value).z ||\n        cacheValue.w !== (<Vector4>value).w\n      ) {\n        this._gl.uniform4i(\n          shaderUniform.location,\n          (<Vector4>value).x,\n          (<Vector4>value).y,\n          (<Vector4>value).z,\n          (<Vector4>value).w\n        );\n        cacheValue.x = (<Vector4>value).x;\n        cacheValue.y = (<Vector4>value).y;\n        cacheValue.z = (<Vector4>value).z;\n        cacheValue.w = (<Vector4>value).w;\n      }\n    }\n  }\n\n  upload4iv(shaderUniform: ShaderUniform, value: Int32Array): void {\n    this._gl.uniform4iv(shaderUniform.location, value);\n  }\n\n  uploadMat4(shaderUniform: ShaderUniform, value: Matrix): void {\n    this._gl.uniformMatrix4fv(shaderUniform.location, false, value.elements);\n  }\n\n  uploadMat4v(shaderUniform: ShaderUniform, value: Float32Array): void {\n    this._gl.uniformMatrix4fv(shaderUniform.location, false, value);\n  }\n\n  uploadTexture(shaderUniform: ShaderUniform, value: Texture): void {\n    const rhi = this._rhi;\n    rhi.activeTexture(shaderUniform.textureIndex as GLenum);\n    rhi.bindTexture(value._platformTexture);\n  }\n\n  uploadTextureArray(shaderUniform: ShaderUniform, value: Texture[]): void {\n    const rhi = this._rhi;\n    const textureIndices = shaderUniform.textureIndex as GLenum[];\n    for (let i = 0; i < value.length; i++) {\n      const texture = value[i];\n      rhi.activeTexture(textureIndices[i]);\n      rhi.bindTexture(texture._platformTexture);\n    }\n  }\n}\n", "import { ShaderUniform } from \"./ShaderUniform\";\n\n/**\n * Shader uniform block.\n * @internal\n */\nexport class ShaderUniformBlock {\n  readonly constUniforms: ShaderUniform[] = [];\n  readonly textureUniforms: ShaderUniform[] = [];\n}\n", "import { Vector2, Vector3, Vector4 } from \"@oasis-engine/math\";\nimport { Logger } from \"../base/Logger\";\nimport { Camera } from \"../Camera\";\nimport { Engine } from \"../Engine\";\nimport { Material } from \"../material/Material\";\nimport { Renderer } from \"../Renderer\";\nimport { IHardwareRenderer } from \"../renderingHardwareInterface/IHardwareRenderer\";\nimport { Texture } from \"../texture\";\nimport { ShaderDataGroup } from \"./enums/ShaderDataGroup\";\nimport { Shader } from \"./Shader\";\nimport { ShaderData } from \"./ShaderData\";\nimport { ShaderUniform } from \"./ShaderUniform\";\nimport { ShaderUniformBlock } from \"./ShaderUniformBlock\";\n\n/**\n * Shader program, corresponding to the GPU shader program.\n * @internal\n */\nexport class ShaderProgram {\n  private static _counter: number = 0;\n\n  private static _addLineNum(str: string) {\n    const lines = str.split(\"\\n\");\n    const limitLength = (lines.length + 1).toString().length + 6;\n    let prefix;\n    return lines\n      .map((line, index) => {\n        prefix = `0:${index + 1}`;\n        if (prefix.length >= limitLength) return prefix.substring(0, limitLength) + line;\n\n        for (let i = 0; i < limitLength - prefix.length; i++) prefix += \" \";\n\n        return prefix + line;\n      })\n      .join(\"\\n\");\n  }\n\n  id: number;\n\n  readonly sceneUniformBlock: ShaderUniformBlock = new ShaderUniformBlock();\n  readonly cameraUniformBlock: ShaderUniformBlock = new ShaderUniformBlock();\n  readonly rendererUniformBlock: ShaderUniformBlock = new ShaderUniformBlock();\n  readonly materialUniformBlock: ShaderUniformBlock = new ShaderUniformBlock();\n  readonly otherUniformBlock: ShaderUniformBlock = new ShaderUniformBlock();\n\n  /** @internal */\n  _uploadRenderCount: number = -1;\n  /** @internal */\n  _uploadCamera: Camera;\n  /** @internal */\n  _uploadRenderer: Renderer;\n  /** @internal */\n  _uploadMaterial: Material;\n\n  attributeLocation: Record<string, GLint> = Object.create(null);\n\n  // @todo: move to RHI.\n  private _isValid: boolean;\n  private _engine: Engine;\n  private _gl: WebGLRenderingContext;\n  private _vertexShader: WebGLShader;\n  private _fragmentShader: WebGLShader;\n  private _glProgram: WebGLProgram;\n  private _activeTextureUint: number = 0;\n\n  /**\n   * Whether this shader program is valid.\n   */\n  get isValid(): boolean {\n    return this._isValid;\n  }\n\n  constructor(engine: Engine, vertexSource: string, fragmentSource: string) {\n    this._engine = engine;\n    this._gl = engine._hardwareRenderer.gl;\n    this._glProgram = this._createProgram(vertexSource, fragmentSource);\n\n    if (this._glProgram) {\n      this._isValid = true;\n      this._recordLocation();\n    } else {\n      this._isValid = false;\n    }\n\n    this.id = ShaderProgram._counter++;\n  }\n\n  /**\n   * Upload all shader data in shader uniform block.\n   * @param uniformBlock - shader Uniform block\n   * @param shaderData - shader data\n   */\n  uploadAll(uniformBlock: ShaderUniformBlock, shaderData: ShaderData): void {\n    this.uploadUniforms(uniformBlock, shaderData);\n    this.uploadTextures(uniformBlock, shaderData);\n  }\n\n  /**\n   * Upload constant shader data in shader uniform block.\n   * @param uniformBlock - shader Uniform block\n   * @param shaderData - shader data\n   */\n  uploadUniforms(uniformBlock: ShaderUniformBlock, shaderData: ShaderData): void {\n    const properties = shaderData._properties;\n    const constUniforms = uniformBlock.constUniforms;\n\n    for (let i = 0, n = constUniforms.length; i < n; i++) {\n      const uniform = constUniforms[i];\n      const data = properties[uniform.propertyId];\n      data != null && uniform.applyFunc(uniform, data);\n    }\n  }\n\n  /**\n   * Upload texture shader data in shader uniform block.\n   * @param uniformBlock - shader Uniform block\n   * @param shaderData - shader data\n   */\n  uploadTextures(uniformBlock: ShaderUniformBlock, shaderData: ShaderData): void {\n    const properties = shaderData._properties;\n    const textureUniforms = uniformBlock.textureUniforms;\n    // textureUniforms property maybe null if ShaderUniformBlock not contain any texture.\n    if (textureUniforms) {\n      for (let i = 0, n = textureUniforms.length; i < n; i++) {\n        const uniform = textureUniforms[i];\n        const texture = properties[uniform.propertyId];\n        if (texture) {\n          uniform.applyFunc(uniform, texture);\n        } else {\n          uniform.applyFunc(uniform, uniform.textureDefault);\n        }\n      }\n    }\n  }\n\n  /**\n   * Upload ungroup texture shader data in shader uniform block.\n   */\n  uploadUngroupTextures(): void {\n    const textureUniforms = this.otherUniformBlock.textureUniforms;\n    // textureUniforms property maybe null if ShaderUniformBlock not contain any texture.\n    if (textureUniforms) {\n      for (let i = 0, n = textureUniforms.length; i < n; i++) {\n        const uniform = textureUniforms[i];\n        uniform.applyFunc(uniform, uniform.textureDefault);\n      }\n    }\n  }\n\n  /**\n   * Grouping other data.\n   */\n  groupingOtherUniformBlock() {\n    const { constUniforms, textureUniforms } = this.otherUniformBlock;\n    constUniforms.length > 0 && this._groupingSubOtherUniforms(constUniforms, false);\n    textureUniforms.length > 0 && this._groupingSubOtherUniforms(textureUniforms, true);\n  }\n\n  /**\n   * Bind this shader program.\n   * @returns Whether the shader program is switched.\n   */\n  bind(): boolean {\n    const rhi: IHardwareRenderer = this._engine._hardwareRenderer;\n    if (rhi._currentBind !== this) {\n      this._gl.useProgram(this._glProgram);\n      rhi._currentBind = this;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Destroy this shader program.\n   */\n  destroy(): void {\n    const gl = this._gl;\n    this._vertexShader && gl.deleteShader(this._vertexShader);\n    this._fragmentShader && gl.deleteShader(this._fragmentShader);\n    this._glProgram && gl.deleteProgram(this._glProgram);\n  }\n\n  private _groupingSubOtherUniforms(uniforms: ShaderUniform[], isTexture: boolean): void {\n    for (let i = uniforms.length - 1; i >= 0; i--) {\n      const uniform = uniforms[i];\n      const group = Shader._getShaderPropertyGroup(uniform.name);\n      if (group !== undefined) {\n        uniforms.splice(uniforms.indexOf(uniform), 1);\n        this._groupingUniform(uniform, group, isTexture);\n      }\n    }\n  }\n\n  private _groupingUniform(uniform: ShaderUniform, group: ShaderDataGroup, isTexture: boolean): void {\n    switch (group) {\n      case ShaderDataGroup.Scene:\n        if (isTexture) {\n          this.sceneUniformBlock.textureUniforms.push(uniform);\n        } else {\n          this.sceneUniformBlock.constUniforms.push(uniform);\n        }\n        break;\n      case ShaderDataGroup.Camera:\n        if (isTexture) {\n          this.cameraUniformBlock.textureUniforms.push(uniform);\n        } else {\n          this.cameraUniformBlock.constUniforms.push(uniform);\n        }\n        break;\n      case ShaderDataGroup.Renderer:\n        if (isTexture) {\n          this.rendererUniformBlock.textureUniforms.push(uniform);\n        } else {\n          this.rendererUniformBlock.constUniforms.push(uniform);\n        }\n        break;\n      case ShaderDataGroup.Material:\n        if (isTexture) {\n          this.materialUniformBlock.textureUniforms.push(uniform);\n        } else {\n          this.materialUniformBlock.constUniforms.push(uniform);\n        }\n        break;\n      default:\n        if (isTexture) {\n          this.otherUniformBlock.textureUniforms.push(uniform);\n        } else {\n          this.otherUniformBlock.constUniforms.push(uniform);\n        }\n    }\n  }\n\n  /**\n   * init and link program with shader.\n   */\n  private _createProgram(vertexSource: string, fragmentSource: string): WebGLProgram | null {\n    const gl = this._gl;\n\n    // create and compile shader\n    const vertexShader = this._createShader(gl.VERTEX_SHADER, vertexSource);\n    if (!vertexShader) {\n      return null;\n    }\n\n    const fragmentShader = this._createShader(gl.FRAGMENT_SHADER, fragmentSource);\n    if (!fragmentShader) {\n      return null;\n    }\n\n    // link program and shader\n    const program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    gl.validateProgram(program);\n\n    if (gl.isContextLost()) {\n      Logger.error(\"Context lost while linking program.\");\n      gl.deleteShader(vertexShader);\n      gl.deleteShader(fragmentShader);\n      return null;\n    }\n\n    if (Logger.isEnabled && !gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      Logger.error(\"Could not link WebGL program. \\n\" + gl.getProgramInfoLog(program));\n      gl.deleteProgram(program);\n      return null;\n    }\n\n    this._vertexShader = vertexShader;\n    this._fragmentShader = fragmentShader;\n    return program;\n  }\n\n  private _createShader(shaderType: number, shaderSource: string): WebGLShader | null {\n    const gl = this._gl;\n    const shader = gl.createShader(shaderType);\n\n    if (!shader) {\n      Logger.error(\"Context lost while create shader.\");\n      return null;\n    }\n\n    gl.shaderSource(shader, shaderSource);\n    gl.compileShader(shader);\n\n    if (gl.isContextLost()) {\n      Logger.error(\"Context lost while compiling shader.\");\n      gl.deleteShader(shader);\n      return null;\n    }\n\n    if (Logger.isEnabled && !gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      Logger.error(\n        `Could not compile WebGL shader.\\n${gl.getShaderInfoLog(shader)}`,\n        ShaderProgram._addLineNum(shaderSource)\n      );\n      gl.deleteShader(shader);\n      return null;\n    }\n\n    return shader;\n  }\n\n  /**\n   * record the location of uniform/attribute.\n   */\n  private _recordLocation() {\n    const gl = this._gl;\n    const program = this._glProgram;\n    const uniformInfos = this._getUniformInfos();\n    const attributeInfos = this._getAttributeInfos();\n\n    uniformInfos.forEach(({ name, size, type }) => {\n      const shaderUniform = new ShaderUniform(this._engine);\n      let isArray = false;\n      let isTexture = false;\n\n      if (name.indexOf(\"[0]\") > 0) {\n        name = name.substr(0, name.length - 3);\n        isArray = true;\n      }\n\n      const group = Shader._getShaderPropertyGroup(name);\n      const location = gl.getUniformLocation(program, name);\n      shaderUniform.name = name;\n      shaderUniform.propertyId = Shader.getPropertyByName(name)._uniqueId;\n      shaderUniform.location = location;\n\n      switch (type) {\n        case gl.FLOAT:\n          if (isArray) {\n            shaderUniform.applyFunc = shaderUniform.upload1fv;\n          } else {\n            shaderUniform.applyFunc = shaderUniform.upload1f;\n            shaderUniform.cacheValue = 0;\n          }\n          break;\n        case gl.FLOAT_VEC2:\n          if (isArray) {\n            shaderUniform.applyFunc = shaderUniform.upload2fv;\n          } else {\n            shaderUniform.applyFunc = shaderUniform.upload2f;\n            shaderUniform.cacheValue = new Vector2(0, 0);\n          }\n          break;\n        case gl.FLOAT_VEC3:\n          if (isArray) {\n            shaderUniform.applyFunc = shaderUniform.upload3fv;\n          } else {\n            shaderUniform.applyFunc = shaderUniform.upload3f;\n            shaderUniform.cacheValue = new Vector3(0, 0, 0);\n          }\n          break;\n        case gl.FLOAT_VEC4:\n          if (isArray) {\n            shaderUniform.applyFunc = shaderUniform.upload4fv;\n          } else {\n            shaderUniform.applyFunc = shaderUniform.upload4f;\n            shaderUniform.cacheValue = new Vector4(0, 0, 0, 0);\n          }\n          break;\n        case gl.BOOL:\n        case gl.INT:\n          if (isArray) {\n            shaderUniform.applyFunc = shaderUniform.upload1iv;\n          } else {\n            shaderUniform.applyFunc = shaderUniform.upload1i;\n            shaderUniform.cacheValue = 0;\n          }\n          break;\n        case gl.BOOL_VEC2:\n        case gl.INT_VEC2:\n          if (isArray) {\n            shaderUniform.applyFunc = shaderUniform.upload2iv;\n          } else {\n            shaderUniform.applyFunc = shaderUniform.upload2i;\n            shaderUniform.cacheValue = new Vector2(0, 0);\n          }\n          break;\n        case gl.BOOL_VEC3:\n        case gl.INT_VEC3:\n          if (isArray) {\n          } else {\n          }\n          shaderUniform.applyFunc = isArray ? shaderUniform.upload3iv : shaderUniform.upload3i;\n          shaderUniform.cacheValue = new Vector3(0, 0, 0);\n          break;\n        case gl.BOOL_VEC4:\n        case gl.INT_VEC4:\n          if (isArray) {\n            shaderUniform.applyFunc = shaderUniform.upload4iv;\n          } else {\n            shaderUniform.applyFunc = shaderUniform.upload4i;\n            shaderUniform.cacheValue = new Vector4(0, 0, 0);\n          }\n          break;\n        case gl.FLOAT_MAT4:\n          shaderUniform.applyFunc = isArray ? shaderUniform.uploadMat4v : shaderUniform.uploadMat4;\n          break;\n        case gl.SAMPLER_2D:\n        case gl.SAMPLER_CUBE:\n          const defaultTexture = type === gl.SAMPLER_2D ? this._engine._whiteTexture2D : this._engine._whiteTextureCube;\n\n          isTexture = true;\n          if (isArray) {\n            const defaultTextures = new Array<Texture>(size);\n            const textureIndices = new Int32Array(size);\n            const glTextureIndices = new Array<number>(size);\n\n            for (let i = 0; i < size; i++) {\n              defaultTextures[i] = defaultTexture;\n              textureIndices[i] = this._activeTextureUint;\n              glTextureIndices[i] = gl.TEXTURE0 + this._activeTextureUint++;\n            }\n            shaderUniform.textureDefault = defaultTextures;\n            shaderUniform.textureIndex = glTextureIndices;\n            shaderUniform.applyFunc = shaderUniform.uploadTextureArray;\n            this.bind();\n            gl.uniform1iv(location, textureIndices);\n            shaderUniform.uploadTextureArray(shaderUniform, defaultTextures);\n          } else {\n            const textureIndex = gl.TEXTURE0 + this._activeTextureUint;\n\n            shaderUniform.textureDefault = defaultTexture;\n            shaderUniform.textureIndex = textureIndex;\n            shaderUniform.applyFunc = shaderUniform.uploadTexture;\n            this.bind();\n            gl.uniform1i(location, this._activeTextureUint++);\n            shaderUniform.uploadTexture(shaderUniform, defaultTexture);\n          }\n          break;\n      }\n      this._groupingUniform(shaderUniform, group, isTexture);\n    });\n\n    attributeInfos.forEach(({ name }) => {\n      this.attributeLocation[name] = gl.getAttribLocation(program, name);\n    });\n  }\n\n  private _getUniformInfos(): WebGLActiveInfo[] {\n    const gl = this._gl;\n    const program = this._glProgram;\n    const uniformInfos: WebGLActiveInfo[] = [];\n\n    const uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n    for (let i = 0; i < uniformCount; ++i) {\n      const info = gl.getActiveUniform(program, i);\n      uniformInfos[i] = info;\n    }\n\n    return uniformInfos;\n  }\n\n  private _getAttributeInfos(): WebGLActiveInfo[] {\n    const gl = this._gl;\n    const program = this._glProgram;\n    const attributeInfos: WebGLActiveInfo[] = [];\n\n    const attributeCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n    for (let i = 0; i < attributeCount; ++i) {\n      const info = gl.getActiveAttrib(program, i);\n      attributeInfos[i] = info;\n    }\n\n    return attributeInfos;\n  }\n}\n", "import { ShaderDataGroup } from \"./enums/ShaderDataGroup\";\n\n/**\n * Shader property.\n */\nexport class ShaderProperty {\n  private static _propertyNameCounter: number = 0;\n\n  /** @internal */\n  _uniqueId: number;\n  /** @internal */\n  _group: ShaderDataGroup;\n\n  /** Shader property name. */\n  readonly name: string;\n\n  /**\n   * @internal\n   */\n  constructor(name: string) {\n    this.name = name;\n    this._uniqueId = ShaderProperty._propertyNameCounter++;\n  }\n}\n", "import { GLCapabilityType } from \"../base/Constant\";\nimport { Engine } from \"../Engine\";\nimport { ShaderFactory } from \"../shaderlib/ShaderFactory\";\nimport { ShaderDataGroup } from \"./enums/ShaderDataGroup\";\nimport { ShaderMacro } from \"./ShaderMacro\";\nimport { ShaderMacroCollection } from \"./ShaderMacroCollection\";\nimport { ShaderProgram } from \"./ShaderProgram\";\nimport { ShaderProperty } from \"./ShaderProperty\";\n\n/**\n * Shader containing vertex and fragment source.\n */\nexport class Shader {\n  /** @internal */\n  static readonly _compileMacros: ShaderMacroCollection = new ShaderMacroCollection();\n\n  private static _shaderCounter: number = 0;\n  private static _shaderMap: Record<string, Shader> = Object.create(null);\n  private static _propertyNameMap: Record<string, ShaderProperty> = Object.create(null);\n  private static _macroMaskMap: string[][] = [];\n  private static _macroCounter: number = 0;\n  private static _macroMap: Record<string, ShaderMacro> = Object.create(null);\n  private static _shaderExtension = [\"GL_EXT_shader_texture_lod\", \"GL_OES_standard_derivatives\", \"GL_EXT_draw_buffers\"];\n\n  /**\n   * Create a shader.\n   * @param name - Name of the shader\n   * @param vertexSource - Vertex source code\n   * @param fragmentSource - Fragment source code\n   */\n  static create(name: string, vertexSource: string, fragmentSource: string): Shader {\n    const shaderMap = Shader._shaderMap;\n    if (shaderMap[name]) {\n      throw `Shader named \"${name}\" already exists.`;\n    }\n    return (shaderMap[name] = new Shader(name, vertexSource, fragmentSource));\n  }\n\n  /**\n   * Find a shader by name.\n   * @param name - Name of the shader\n   */\n  static find(name: string): Shader {\n    return Shader._shaderMap[name];\n  }\n\n  /**\n   * Get shader macro by name.\n   * @param name - Name of the shader macro\n   * @returns Shader macro\n   */\n  static getMacroByName(name: string): ShaderMacro {\n    let macro = Shader._macroMap[name];\n    if (!macro) {\n      const maskMap = Shader._macroMaskMap;\n      const counter = Shader._macroCounter;\n      const index = Math.floor(counter / 32);\n      const bit = counter % 32;\n      macro = new ShaderMacro(name, index, 1 << bit);\n      Shader._macroMap[name] = macro;\n      if (index == maskMap.length) {\n        maskMap.length++;\n        maskMap[index] = new Array<string>(32);\n      }\n      maskMap[index][bit] = name;\n      Shader._macroCounter++;\n    }\n    return macro;\n  }\n\n  /**\n   * Get shader property by name.\n   * @param name - Name of the shader property\n   * @returns Shader property\n   */\n  static getPropertyByName(name: string): ShaderProperty {\n    const propertyNameMap = Shader._propertyNameMap;\n    if (propertyNameMap[name] != null) {\n      return propertyNameMap[name];\n    } else {\n      const property = new ShaderProperty(name);\n      propertyNameMap[name] = property;\n      return property;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static _getShaderPropertyGroup(propertyName: string): ShaderDataGroup | null {\n    const shaderProperty = Shader._propertyNameMap[propertyName];\n    return shaderProperty?._group;\n  }\n\n  private static _getNamesByMacros(macros: ShaderMacroCollection, out: string[]): void {\n    const maskMap = Shader._macroMaskMap;\n    const mask = macros._mask;\n    out.length = 0;\n    for (let i = 0, n = macros._length; i < n; i++) {\n      const subMaskMap = maskMap[i];\n      const subMask = mask[i];\n      const n = subMask < 0 ? 32 : Math.floor(Math.log2(subMask)) + 1; // if is negative must contain 1 << 31.\n      for (let j = 0; j < n; j++) {\n        if (subMask & (1 << j)) {\n          out.push(subMaskMap[j]);\n        }\n      }\n    }\n  }\n\n  /** The name of shader. */\n  readonly name: string;\n\n  /** @internal */\n  _shaderId: number = 0;\n\n  private _vertexSource: string;\n  private _fragmentSource: string;\n\n  private constructor(name: string, vertexSource: string, fragmentSource: string) {\n    this._shaderId = Shader._shaderCounter++;\n    this.name = name;\n    this._vertexSource = vertexSource;\n    this._fragmentSource = fragmentSource;\n  }\n\n  /**\n   * Compile shader variant by macro name list.\n   *\n   * @remarks\n   * Usually a shader contains some macros,any combination of macros is called shader variant.\n   *\n   * @param engine - Engine to which the shader variant belongs\n   * @param macros - Macro name list\n   * @returns Is the compiled shader variant valid\n   */\n  compileVariant(engine: Engine, macros: string[]): boolean {\n    const compileMacros = Shader._compileMacros;\n    compileMacros.clear();\n    for (let i = 0, n = macros.length; i < n; i++) {\n      compileMacros.enable(Shader.getMacroByName(macros[i]));\n    }\n    return this._getShaderProgram(engine, compileMacros).isValid;\n  }\n\n  /**\n   * @internal\n   */\n  _getShaderProgram(engine: Engine, macroCollection: ShaderMacroCollection): ShaderProgram {\n    const shaderProgramPool = engine._getShaderProgramPool(this);\n    let shaderProgram = shaderProgramPool.get(macroCollection);\n    if (shaderProgram) {\n      return shaderProgram;\n    }\n\n    const isWebGL2: boolean = engine._hardwareRenderer.isWebGL2;\n    const macroNameList = [];\n    Shader._getNamesByMacros(macroCollection, macroNameList);\n    const macroNameStr = ShaderFactory.parseCustomMacros(macroNameList);\n    const versionStr = isWebGL2 ? \"#version 300 es\" : \"#version 100\";\n    let precisionStr = `\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      precision highp int;\n      #define O3_VERTEX_PRECISION highp\n      #define O3_FRAGMENT_PRECISION highp\n    #else\n      precision mediump float;\n      precision mediump int;\n      #define O3_VERTEX_PRECISION mediump\n      #define O3_FRAGMENT_PRECISION mediump\n    #endif\n    `;\n\n    if (engine._hardwareRenderer.canIUse(GLCapabilityType.shaderTextureLod)) {\n      precisionStr += \"#define HAS_TEX_LOD\\n\";\n    }\n    if (engine._hardwareRenderer.canIUse(GLCapabilityType.standardDerivatives)) {\n      precisionStr += \"#define HAS_DERIVATIVES\\n\";\n    }\n\n    let vertexSource = ShaderFactory.parseIncludes(\n      ` ${versionStr}\n        ${precisionStr}\n        ${macroNameStr}\n        ` + this._vertexSource\n    );\n\n    let fragmentSource = ShaderFactory.parseIncludes(\n      ` ${versionStr}\n        ${isWebGL2 ? \"\" : ShaderFactory.parseExtension(Shader._shaderExtension)}\n        ${precisionStr}\n        ${macroNameStr}\n      ` + this._fragmentSource\n    );\n\n    if (isWebGL2) {\n      vertexSource = ShaderFactory.convertTo300(vertexSource);\n      fragmentSource = ShaderFactory.convertTo300(fragmentSource, true);\n    }\n\n    shaderProgram = new ShaderProgram(engine, vertexSource, fragmentSource);\n\n    shaderProgramPool.cache(shaderProgram);\n    return shaderProgram;\n  }\n}\n", "import { IClone } from \"@oasis-engine/design\";\nimport { Color, Matrix, Vector2, Vector3, Vector4 } from \"@oasis-engine/math\";\nimport { IRefObject } from \"../asset/IRefObject\";\nimport { CloneManager } from \"../clone/CloneManager\";\nimport { Texture } from \"../texture/Texture\";\nimport { ShaderDataGroup } from \"./enums/ShaderDataGroup\";\nimport { Shader } from \"./Shader\";\nimport { ShaderMacro } from \"./ShaderMacro\";\nimport { ShaderMacroCollection } from \"./ShaderMacroCollection\";\nimport { ShaderProperty } from \"./ShaderProperty\";\n\nexport type ShaderPropertyValueType =\n  | number\n  | Vector2\n  | Vector3\n  | Vector4\n  | Color\n  | Matrix\n  | Texture\n  | Texture[]\n  | Int32Array\n  | Float32Array;\n\n/**\n * Shader data collection,Correspondence includes shader properties data and macros data.\n */\nexport class ShaderData implements IRefObject, IClone {\n  /** @internal */\n  _group: ShaderDataGroup;\n  /** @internal */\n  _properties: Record<number, ShaderPropertyValueType> = Object.create(null);\n  /** @internal */\n  _macroCollection: ShaderMacroCollection = new ShaderMacroCollection();\n\n  private _variableMacros: Record<string, string> = Object.create(null);\n  private _refCount: number = 0;\n\n  /**\n   * @internal\n   */\n  constructor(group: ShaderDataGroup) {\n    this._group = group;\n  }\n\n  /**\n   * Get float by shader property name.\n   * @param propertyName - Shader property name\n   * @returns Float\n   */\n  getFloat(propertyName: string): number;\n\n  /**\n   * Get float by shader property.\n   * @param property - Shader property\n   * @returns Float\n   */\n  getFloat(property: ShaderProperty): number;\n\n  getFloat(property: string | ShaderProperty): number {\n    return this._getData(property);\n  }\n\n  /**\n   * Set float by shader property name.\n   * @remarks Corresponding float shader property type.\n   * @param propertyName - Shader property name\n   * @param value - Float\n   */\n  setFloat(propertyName: string, value: number): void;\n\n  /**\n   * Set float by shader property.\n   * @remarks Corresponding float shader property type.\n   * @param property - Shader property\n   * @param value - Float\n   */\n  setFloat(property: ShaderProperty, value: number): void;\n\n  setFloat(property: string | ShaderProperty, value: number): void {\n    this._setData(property, value);\n  }\n\n  /**\n   * Get int by shader property name.\n   * @param propertyName - Shader property name\n   * @returns Int\n   */\n  getInt(propertyName: string): number;\n\n  /**\n   * Get int by shader property.\n   * @param property - Shader property\n   * @returns Int\n   */\n  getInt(property: ShaderProperty): number;\n\n  getInt(property: string | ShaderProperty): number {\n    return this._getData(property);\n  }\n\n  /**\n   * Set int by shader property name.\n   * @remarks Correspondence includes int and bool shader property type.\n   * @param propertyName - Shader property name\n   * @param value - Int\n   */\n  setInt(propertyName: string, value: number): void;\n\n  /**\n   * Set int by shader property.\n   * @remarks Correspondence includes int and bool shader property type.\n   * @param property - Shader property\n   * @param value - Int\n   */\n  setInt(property: ShaderProperty, value: number): void;\n\n  setInt(property: string | ShaderProperty, value: number): void {\n    this._setData(property, value);\n  }\n\n  /**\n   * Get float array by shader property name.\n   * @param propertyName - Shader property name\n   * @returns Float array\n   */\n  getFloatArray(propertyName: string): Float32Array;\n\n  /**\n   * Get float array by shader property.\n   * @param property - Shader property\n   * @returns Float array\n   */\n  getFloatArray(property: ShaderProperty): Float32Array;\n\n  getFloatArray(property: string | ShaderProperty): Float32Array {\n    return this._getData(property);\n  }\n\n  /**\n   * Set float array by shader property name.\n   * @remarks Correspondence includes float array\u3001vec2 array\u3001vec3 array\u3001vec4 array and matrix array shader property type.\n   * @param propertyName - Shader property name\n   * @param value - Float array\n   */\n  setFloatArray(propertyName: string, value: Float32Array): void;\n\n  /**\n   * Set float array by shader property.\n   * @remarks Correspondence includes float array\u3001vec2 array\u3001vec3 array\u3001vec4 array and matrix array shader property type.\n   * @param property - Shader property\n   * @param value - Float array\n   */\n  setFloatArray(property: ShaderProperty, value: Float32Array): void;\n\n  setFloatArray(property: string | ShaderProperty, value: Float32Array): void {\n    this._setData(property, value);\n  }\n\n  /**\n   * Get int array by shader property name.\n   * @param propertyName - Shader property name\n   * @returns Int Array\n   */\n  getIntArray(propertyName: string): Int32Array;\n\n  /**\n   * Get int array by shader property.\n   * @param property - Shader property\n   * @returns Int Array\n   */\n  getIntArray(property: ShaderProperty): Int32Array;\n\n  getIntArray(property: string | ShaderProperty): Int32Array {\n    return this._getData(property);\n  }\n\n  /**\n   * Set int array by shader property name.\n   * @remarks Correspondence includes bool array\u3001int array\u3001bvec2 array\u3001bvec3 array\u3001bvec4 array\u3001ivec2 array\u3001ivec3 array and ivec4 array shader property type.\n   * @param propertyName - Shader property name\n   * @param value - Int Array\n   */\n  setIntArray(propertyName: string, value: Int32Array): void;\n\n  /**\n   * Set int array by shader property.\n   * @remarks Correspondence includes bool array\u3001int array\u3001bvec2 array\u3001bvec3 array\u3001bvec4 array\u3001ivec2 array\u3001ivec3 array and ivec4 array shader property type.\n   * @param property - Shader property\n   * @param value - Int Array\n   */\n  setIntArray(property: ShaderProperty, value: Int32Array): void;\n\n  setIntArray(property: string | ShaderProperty, value: Int32Array): void {\n    this._setData(property, value);\n  }\n\n  /**\n   * Get two-dimensional from shader property name.\n   * @param propertyName - Shader property name\n   * @returns Two-dimensional vector\n   */\n  getVector2(propertyName: string): Vector2;\n\n  /**\n   * Get two-dimensional from shader property.\n   * @param property - Shader property\n   * @returns Two-dimensional vector\n   */\n  getVector2(property: ShaderProperty): Vector2;\n\n  getVector2(property: string | ShaderProperty): Vector2 {\n    return this._getData(property);\n  }\n\n  /**\n   * Set two-dimensional vector from shader property name.\n   * @remarks Correspondence includes vec2\u3001ivec2 and bvec2 shader property type.\n   * @param property - Shader property name\n   * @param value - Two-dimensional vector\n   */\n  setVector2(property: string, value: Vector2): void;\n\n  /**\n   * Set two-dimensional vector from shader property.\n   * @remarks Correspondence includes vec2\u3001ivec2 and bvec2 shader property type.\n   * @param property - Shader property\n   * @param value - Two-dimensional vector\n   */\n  setVector2(property: ShaderProperty, value: Vector2): void;\n\n  setVector2(property: string | ShaderProperty, value: Vector2): void {\n    this._setData(property, value);\n  }\n\n  /**\n   * Get vector3 by shader property name.\n   * @param propertyName - Shader property name\n   * @returns Three-dimensional vector\n   */\n  getVector3(propertyName: string): Vector3;\n\n  /**\n   * Get vector3 by shader property.\n   * @param property - Shader property\n   * @returns Three-dimensional vector\n   */\n  getVector3(property: ShaderProperty): Vector3;\n\n  getVector3(property: string | ShaderProperty): Vector3 {\n    return this._getData(property);\n  }\n\n  /**\n   * Set three dimensional vector by shader property name.\n   * @remarks Correspondence includes vec3\u3001ivec3 and bvec3 shader property type.\n   * @param property - Shader property name\n   * @param value - Three-dimensional vector\n   */\n  setVector3(property: string, value: Vector3): void;\n\n  /**\n   * Set three dimensional vector by shader property.\n   * @remarks Correspondence includes vec3\u3001ivec3 and bvec3 shader property type.\n   * @param property - Shader property\n   * @param value - Three-dimensional vector\n   */\n  setVector3(property: ShaderProperty, value: Vector3): void;\n\n  setVector3(property: string | ShaderProperty, value: Vector3): void {\n    this._setData(property, value);\n  }\n\n  /**\n   * Get vector4 by shader property name.\n   * @param propertyName - Shader property name\n   * @returns Four-dimensional vector\n   */\n  getVector4(propertyName: string): Vector4;\n\n  /**\n   * Get vector4 by shader property.\n   * @param property - Shader property\n   * @returns Four-dimensional vector\n   */\n  getVector4(property: ShaderProperty): Vector4;\n\n  getVector4(property: string | ShaderProperty): Vector4 {\n    return this._getData(property);\n  }\n\n  /**\n   * Set four-dimensional vector by shader property name.\n   * @remarks Correspondence includes vec4\u3001ivec4 and bvec4 shader property type.\n   * @param property - Shader property name\n   * @param value - Four-dimensional vector\n   */\n  setVector4(property: string, value: Vector4): void;\n\n  /**\n   * Set four-dimensional vector by shader property.\n   * @remarks Correspondence includes vec4\u3001ivec4 and bvec4 shader property type.\n   * @param property - Shader property\n   * @param value - Four-dimensional vector\n   */\n  setVector4(property: ShaderProperty, value: Vector4): void;\n\n  setVector4(property: string | ShaderProperty, value: Vector4): void {\n    this._setData(property, value);\n  }\n\n  /**\n   * Get matrix by shader property name.\n   * @param propertyName - Shader property name\n   * @returns Matrix\n   */\n  getMatrix(propertyName: string): Matrix;\n\n  /**\n   * Get matrix by shader property.\n   * @param property - Shader property\n   * @returns Matrix\n   */\n  getMatrix(property: ShaderProperty): Matrix;\n\n  getMatrix(property: string | ShaderProperty): Matrix {\n    return this._getData(property);\n  }\n\n  /**\n   * Set matrix by shader property name.\n   * @remarks Correspondence includes matrix shader property type.\n   * @param propertyName - Shader property name\n   * @param value - Matrix\n   */\n  setMatrix(propertyName: string, value: Matrix);\n\n  /**\n   * Set matrix by shader property.\n   * @remarks Correspondence includes matrix shader property type.\n   * @param property - Shader property\n   * @param value - Matrix\n   */\n  setMatrix(property: ShaderProperty, value: Matrix);\n\n  setMatrix(property: string | ShaderProperty, value: Matrix): void {\n    this._setData(property, value);\n  }\n\n  /**\n   * Get color by shader property name.\n   * @param propertyName - Shader property name\n   * @returns Color\n   */\n  getColor(propertyName: string): Color;\n\n  /**\n   * Get color by shader property.\n   * @param property - Shader property\n   * @returns Color\n   */\n  getColor(property: ShaderProperty): Color;\n\n  getColor(property: string | ShaderProperty): Color {\n    return this._getData(property);\n  }\n\n  /**\n   * Set color by shader property name.\n   * @remarks Correspondence includes vec4 shader property type.\n   * @param propertyName - Shader property name\n   * @param value - Color\n   */\n  setColor(propertyName: string, value: Color): void;\n\n  /**\n   * Set color by shader property.\n   * @remarks Correspondence includes vec4 shader property type.\n   * @param property - Shader property\n   * @param value - Color\n   */\n  setColor(property: ShaderProperty, value: Color): void;\n\n  setColor(property: string | ShaderProperty, value: Color): void {\n    this._setData(property, value);\n  }\n\n  /**\n   * Get texture by shader property name.\n   * @param propertyName - Shader property name\n   * @returns Texture\n   */\n  getTexture(propertyName: string): Texture;\n\n  /**\n   * Get texture by shader property.\n   * @param property - Shader property\n   * @returns Texture\n   */\n  getTexture(property: ShaderProperty): Texture;\n\n  getTexture(property: string | ShaderProperty): Texture {\n    return this._getData(property);\n  }\n\n  /**\n   * Set texture by shader property name.\n   * @param propertyName - Shader property name\n   * @param value - Texture\n   */\n  setTexture(propertyName: string, value: Texture): void;\n\n  /**\n   * Set texture by shader property.\n   * @param property - Shader property\n   * @param value - Texture\n   */\n  setTexture(property: ShaderProperty, value: Texture): void;\n\n  setTexture(property: string | ShaderProperty, value: Texture): void {\n    if (this._getRefCount() > 0) {\n      const lastValue = this._getData<Texture>(property);\n      lastValue && lastValue._addRefCount(-1);\n      value && value._addRefCount(1);\n    }\n    this._setData(property, value);\n  }\n\n  /**\n   * Get texture array by shader property name.\n   * @param propertyName - Shader property name\n   * @returns Texture array\n   */\n  getTextureArray(propertyName: string): Texture[];\n\n  /**\n   * Get texture array by shader property.\n   * @param property - Shader property\n   * @returns Texture array\n   */\n  getTextureArray(property: ShaderProperty): Texture[];\n\n  getTextureArray(property: string | ShaderProperty): Texture[] {\n    return this._getData(property);\n  }\n\n  /**\n   * Set texture array by shader property name.\n   * @param propertyName - Shader property name\n   * @param value - Texture array\n   */\n  setTextureArray(propertyName: string, value: Texture[]): void;\n\n  /**\n   * Set texture array by shader property.\n   * @param property - Shader property\n   * @param value - Texture array\n   */\n  setTextureArray(property: ShaderProperty, value: Texture[]): void;\n\n  setTextureArray(property: string | ShaderProperty, value: Texture[]): void {\n    if (this._getRefCount() > 0) {\n      const lastValue = this._getData<Texture[]>(property);\n      if (lastValue) {\n        for (let i = 0, n = lastValue.length; i < n; i++) {\n          lastValue[i]._addRefCount(-1);\n        }\n      }\n      if (value) {\n        for (let i = 0, n = value.length; i < n; i++) {\n          value[i]._addRefCount(1);\n        }\n      }\n    }\n    this._setData(property, value);\n  }\n\n  /**\n   * Enable macro.\n   * @param macroName - Macro name\n   */\n  enableMacro(macroName: string): void;\n\n  /**\n   * Enable macro.\n   * @param macro - Shader macro\n   */\n  enableMacro(macro: ShaderMacro): void;\n\n  /**\n   * Enable macro.\n   * @remarks Name and value will combine one macro, it's equal the macro of \"name value\".\n   * @param name - Macro name\n   * @param value - Macro value\n   */\n  enableMacro(name: string, value: string): void;\n\n  enableMacro(macro: string | ShaderMacro, value: string = null): void {\n    if (value) {\n      this._enableVariableMacro(<string>macro, value);\n    } else {\n      if (typeof macro === \"string\") {\n        macro = Shader.getMacroByName(macro);\n      }\n      this._macroCollection.enable(macro);\n    }\n  }\n\n  /**\n   * Disable macro\n   * @param macroName - Macro name\n   */\n  disableMacro(macroName: string): void;\n\n  /**\n   * Disable macro\n   * @param macro - Shader macro\n   */\n  disableMacro(macro: ShaderMacro): void;\n\n  disableMacro(macro: string | ShaderMacro): void {\n    if (typeof macro === \"string\") {\n      // @todo: should optimization variable macros disable performance\n      const variableValue = this._variableMacros[macro];\n      if (variableValue) {\n        this._disableVariableMacro(macro, variableValue);\n      } else {\n        macro = Shader.getMacroByName(macro);\n        this._macroCollection.disable(macro);\n      }\n    } else {\n      this._macroCollection.disable(macro);\n    }\n  }\n\n  clone(): ShaderData {\n    const shaderData = new ShaderData(this._group);\n    this.cloneTo(shaderData);\n    return shaderData;\n  }\n\n  cloneTo(target: ShaderData): void {\n    CloneManager.deepCloneObject(this._macroCollection, target._macroCollection);\n    Object.assign(target._variableMacros, this._variableMacros);\n\n    const properties = this._properties;\n    const targetProperties = target._properties;\n    const keys = Object.keys(properties);\n    for (let i = 0, n = keys.length; i < n; i++) {\n      const k = keys[i];\n      const property: ShaderPropertyValueType = properties[k];\n      if (property != null) {\n        if (typeof property === \"number\") {\n          targetProperties[k] = property;\n        } else if (property instanceof Texture) {\n          targetProperties[k] = property;\n        } else if (property instanceof Array || property instanceof Float32Array || property instanceof Int32Array) {\n          targetProperties[k] = property.slice();\n        } else {\n          const targetProperty = targetProperties[k];\n          if (targetProperty) {\n            property.cloneTo(targetProperty);\n          } else {\n            targetProperties[k] = property.clone();\n          }\n        }\n      } else {\n        targetProperties[k] = property;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _getData<T extends ShaderPropertyValueType>(property: string | ShaderProperty): T {\n    if (typeof property === \"string\") {\n      property = Shader.getPropertyByName(property);\n    }\n    return this._properties[property._uniqueId] as T;\n  }\n\n  /**\n   * @internal\n   */\n  _setData<T extends ShaderPropertyValueType>(property: string | ShaderProperty, value: T): void {\n    if (typeof property === \"string\") {\n      property = Shader.getPropertyByName(property);\n    }\n\n    if (property._group !== this._group) {\n      if (property._group === undefined) {\n        property._group = this._group;\n      } else {\n        throw `Shader property ${property.name} has been used as ${ShaderDataGroup[property._group]} property.`;\n      }\n    }\n\n    this._properties[property._uniqueId] = value;\n  }\n\n  /**\n   * @internal\n   */\n  _getRefCount(): number {\n    return this._refCount;\n  }\n\n  /**\n   * @internal\n   */\n  _addRefCount(value: number): void {\n    this._refCount += value;\n    const properties = this._properties;\n    for (const k in properties) {\n      const property = properties[k];\n      // @todo: Separate array to speed performance.\n      if (property && property instanceof Texture) {\n        property._addRefCount(value);\n      }\n    }\n  }\n\n  private _enableVariableMacro(name: string, value: string): void {\n    const variableMacro = this._variableMacros;\n    const variableValue = variableMacro[name];\n    if (variableValue !== value) {\n      variableValue && this._disableVariableMacro(name, variableValue);\n\n      const macro = Shader.getMacroByName(`${name} ${value}`);\n      this._macroCollection.enable(macro);\n      variableMacro[name] = value;\n    }\n  }\n\n  private _disableVariableMacro(name: string, value: string): void {\n    const oldMacro = Shader.getMacroByName(`${name} ${value}`);\n    this._macroCollection.disable(oldMacro);\n    delete this._variableMacros[name];\n  }\n}\n", "/**\n * Blend factor.\n * @remarks defines which function is used for blending pixel arithmetic\n */\nexport enum BlendFactor {\n  /** (0, 0, 0, 0)*/\n  Zero,\n  /** (1, 1, 1, 1)*/\n  One,\n  /** (Rs, Gs, Bs, As) */\n  SourceColor,\n  /** (1 - Rs, 1 - Gs, 1 - Bs, 1 - As)*/\n  OneMinusSourceColor,\n  /** (Rd, Gd, Bd, Ad)*/\n  DestinationColor,\n  /** (1 - Rd, 1 - Gd, 1 - Bd, 1 - Ad)*/\n  OneMinusDestinationColor,\n  /** (As, As, As, As)*/\n  SourceAlpha,\n  /** (1 - As, 1 - As, 1 - As, 1 - As)*/\n  OneMinusSourceAlpha,\n  /** (Ad, Ad, Ad, Ad)*/\n  DestinationAlpha,\n  /** (1 - Ad, 1 - Ad, 1 - Ad, 1 - Ad)*/\n  OneMinusDestinationAlpha,\n  /** (min(As, 1 - Ad), min(As, 1 - Ad), min(As, 1 - Ad), 10)*/\n  SourceAlphaSaturate,\n  /** (Rc, Gc, Bc, Ac)*/\n  BlendColor,\n  /** (1 - Rc, 1 - Gc, 1 - Bc, 1 - Ac)*/\n  OneMinusBlendColor\n}\n", "/**\n * Blend operation function.\n * @remarks defines how a new pixel is combined with a pixel.\n */\nexport enum BlendOperation {\n  /** src + dst. */\n  Add,\n  /** src - dst. */\n  Subtract,\n  /** dst - src. */\n  ReverseSubtract,\n  /** Minimum of source and destination. */\n  Min,\n  /** Maximum of source and destination. */\n  Max\n}\n", "/**\n * Set which color channels can be rendered to frame buffer.\n * @remarks enumeration can be combined using bit operations.\n */\nexport enum ColorWriteMask {\n  /** Do not write to any channel. */\n  None = 0,\n  /** Write to the red channel. */\n  Red = 0x1,\n  /** Write to the green channel. */\n  Green = 0x2,\n  /** Write to the blue channel. */\n  Blue = 0x4,\n  /** Write to the alpha channel. */\n  Alpha = 0x8,\n  /** Write to all channel. */\n  All = 0xf\n}\n", "import { BlendOperation } from \"../enums/BlendOperation\";\nimport { BlendFactor } from \"../enums/BlendFactor\";\nimport { ColorWriteMask } from \"../enums/ColorWriteMask\";\n\n/**\n * The blend state of the render target.\n */\nexport class RenderTargetBlendState {\n  /** Whether to enable blend. */\n  enabled: boolean = false;\n  /** color (RGB) blend operation. */\n  colorBlendOperation: BlendOperation = BlendOperation.Add;\n  /** alpha (A) blend operation. */\n  alphaBlendOperation: BlendOperation = BlendOperation.Add;\n  /** color blend factor (RGB) for source. */\n  sourceColorBlendFactor: BlendFactor = BlendFactor.One;\n  /** alpha blend factor (A) for source. */\n  sourceAlphaBlendFactor: BlendFactor = BlendFactor.One;\n  /** color blend factor (RGB) for destination. */\n  destinationColorBlendFactor: BlendFactor = BlendFactor.Zero;\n  /** alpha blend factor (A) for destination. */\n  destinationAlphaBlendFactor: BlendFactor = BlendFactor.Zero;\n  /** color mask. */\n  colorWriteMask: ColorWriteMask = ColorWriteMask.All;\n}\n", "import { Color } from \"@oasis-engine/math\";\nimport { GLCapabilityType } from \"../../base/Constant\";\nimport { IHardwareRenderer } from \"../../renderingHardwareInterface/IHardwareRenderer\";\nimport { BlendFactor } from \"../enums/BlendFactor\";\nimport { BlendOperation } from \"../enums/BlendOperation\";\nimport { ColorWriteMask } from \"../enums/ColorWriteMask\";\nimport { RenderState } from \"./RenderState\";\nimport { RenderTargetBlendState } from \"./RenderTargetBlendState\";\n\n/**\n * Blend state.\n */\nexport class BlendState {\n  private static _getGLBlendFactor(rhi: IHardwareRenderer, blendFactor: BlendFactor): number {\n    const gl = rhi.gl;\n\n    switch (blendFactor) {\n      case BlendFactor.Zero:\n        return gl.ZERO;\n      case BlendFactor.One:\n        return gl.ONE;\n      case BlendFactor.SourceColor:\n        return gl.SRC_COLOR;\n      case BlendFactor.OneMinusSourceColor:\n        return gl.ONE_MINUS_SRC_COLOR;\n      case BlendFactor.DestinationColor:\n        return gl.DST_COLOR;\n      case BlendFactor.OneMinusDestinationColor:\n        return gl.ONE_MINUS_DST_COLOR;\n      case BlendFactor.SourceAlpha:\n        return gl.SRC_ALPHA;\n      case BlendFactor.OneMinusSourceAlpha:\n        return gl.ONE_MINUS_SRC_ALPHA;\n      case BlendFactor.DestinationAlpha:\n        return gl.DST_ALPHA;\n      case BlendFactor.OneMinusDestinationAlpha:\n        return gl.ONE_MINUS_DST_ALPHA;\n      case BlendFactor.SourceAlphaSaturate:\n        return gl.SRC_ALPHA_SATURATE;\n      case BlendFactor.BlendColor:\n        return gl.CONSTANT_COLOR;\n      case BlendFactor.OneMinusBlendColor:\n        return gl.ONE_MINUS_CONSTANT_COLOR;\n    }\n  }\n\n  private static _getGLBlendOperation(rhi: IHardwareRenderer, blendOperation: BlendOperation): number {\n    const gl = rhi.gl;\n\n    switch (blendOperation) {\n      case BlendOperation.Add:\n        return gl.FUNC_ADD;\n      case BlendOperation.Subtract:\n        return gl.FUNC_SUBTRACT;\n      case BlendOperation.ReverseSubtract:\n        return gl.FUNC_REVERSE_SUBTRACT;\n      case BlendOperation.Min:\n        if (!rhi.canIUse(GLCapabilityType.blendMinMax)) {\n          throw new Error(\"BlendOperation.Min is not supported in this context\");\n        }\n        return gl.MIN; // in webgl1.0 is an extension\n      case BlendOperation.Max:\n        if (!rhi.canIUse(GLCapabilityType.blendMinMax)) {\n          throw new Error(\"BlendOperation.Max is not supported in this context\");\n        }\n        return gl.MAX; // in webgl1.0 is an extension\n    }\n  }\n\n  /** The blend state of the render target. */\n  readonly targetBlendState: RenderTargetBlendState = new RenderTargetBlendState();\n  /** Constant blend color. */\n  readonly blendColor: Color = new Color(0, 0, 0, 0);\n  /** Whether to use (Alpha-to-Coverage) technology. */\n  alphaToCoverage: boolean = false;\n\n  /**\n   * @internal\n   * Apply the current blend state by comparing with the last blend state.\n   */\n  _apply(hardwareRenderer: IHardwareRenderer, lastRenderState: RenderState): void {\n    this._platformApply(hardwareRenderer, lastRenderState.blendState);\n  }\n\n  private _platformApply(rhi: IHardwareRenderer, lastState: BlendState): void {\n    const gl = <WebGLRenderingContext>rhi.gl;\n    const lastTargetBlendState = lastState.targetBlendState;\n\n    const {\n      enabled,\n      colorBlendOperation,\n      alphaBlendOperation,\n      sourceColorBlendFactor,\n      destinationColorBlendFactor,\n      sourceAlphaBlendFactor,\n      destinationAlphaBlendFactor,\n      colorWriteMask\n    } = this.targetBlendState;\n\n    if (enabled !== lastTargetBlendState.enabled) {\n      if (enabled) {\n        gl.enable(gl.BLEND);\n      } else {\n        gl.disable(gl.BLEND);\n      }\n      lastTargetBlendState.enabled = enabled;\n    }\n\n    if (enabled) {\n      // apply blend factor.\n      if (\n        sourceColorBlendFactor !== lastTargetBlendState.sourceColorBlendFactor ||\n        destinationColorBlendFactor !== lastTargetBlendState.destinationColorBlendFactor ||\n        sourceAlphaBlendFactor !== lastTargetBlendState.sourceAlphaBlendFactor ||\n        destinationAlphaBlendFactor !== lastTargetBlendState.destinationAlphaBlendFactor\n      ) {\n        gl.blendFuncSeparate(\n          BlendState._getGLBlendFactor(rhi, sourceColorBlendFactor),\n          BlendState._getGLBlendFactor(rhi, destinationColorBlendFactor),\n          BlendState._getGLBlendFactor(rhi, sourceAlphaBlendFactor),\n          BlendState._getGLBlendFactor(rhi, destinationAlphaBlendFactor)\n        );\n        lastTargetBlendState.sourceColorBlendFactor = sourceColorBlendFactor;\n        lastTargetBlendState.destinationColorBlendFactor = destinationColorBlendFactor;\n        lastTargetBlendState.sourceAlphaBlendFactor = sourceAlphaBlendFactor;\n        lastTargetBlendState.destinationAlphaBlendFactor = destinationAlphaBlendFactor;\n      }\n\n      // apply blend operation.\n      if (\n        colorBlendOperation !== lastTargetBlendState.colorBlendOperation ||\n        alphaBlendOperation !== lastTargetBlendState.alphaBlendOperation\n      ) {\n        gl.blendEquationSeparate(\n          BlendState._getGLBlendOperation(rhi, colorBlendOperation),\n          BlendState._getGLBlendOperation(rhi, alphaBlendOperation)\n        );\n        lastTargetBlendState.colorBlendOperation = colorBlendOperation;\n        lastTargetBlendState.alphaBlendOperation = alphaBlendOperation;\n      }\n\n      // apply blend color.\n      const blendColor = this.blendColor;\n      if (!Color.equals(lastState.blendColor, blendColor)) {\n        gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendColor.a);\n        blendColor.cloneTo(lastState.blendColor);\n      }\n    }\n\n    // apply color mask.\n    if (colorWriteMask !== lastTargetBlendState.colorWriteMask) {\n      gl.colorMask(\n        (colorWriteMask & ColorWriteMask.Red) !== 0,\n        (colorWriteMask & ColorWriteMask.Green) !== 0,\n        (colorWriteMask & ColorWriteMask.Blue) !== 0,\n        (colorWriteMask & ColorWriteMask.Alpha) !== 0\n      );\n      lastTargetBlendState.colorWriteMask = colorWriteMask;\n    }\n\n    // apply alpha to coverage.\n    const alphaToCoverage = this.alphaToCoverage;\n    if (alphaToCoverage !== lastState.alphaToCoverage) {\n      if (alphaToCoverage) {\n        gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n      } else {\n        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n      }\n      lastState.alphaToCoverage = alphaToCoverage;\n    }\n  }\n}\n", "/**\n * Depth/Stencil comparison function.\n * @remarks Specifies a function that compares incoming pixel depth/stencil to the current depth/stencil buffer value.\n */\nexport enum CompareFunction {\n  /** never pass. */\n  Never,\n  /** pass if the incoming value is less than the depth/stencil buffer value. */\n  Less,\n  /** pass if the incoming value equals the depth/stencil buffer value. */\n  Equal,\n  /** pass if the incoming value is less than or equal to the depth/stencil buffer value. */\n  LessEqual,\n  /** pass if the incoming value is greater than the depth/stencil buffer value. */\n  Greater,\n  /** pass if the incoming value is not equal to the depth/stencil buffer value. */\n  NotEqual,\n  /** pass if the incoming value is greater than or equal to the depth/stencil buffer value. */\n  GreaterEqual,\n  /** always pass. */\n  Always\n}\n", "import { IHardwareRenderer } from \"../../renderingHardwareInterface/IHardwareRenderer\";\nimport { CompareFunction } from \"../enums/CompareFunction\";\nimport { RenderState } from \"./RenderState\";\n\n/**\n * Depth state.\n */\nexport class DepthState {\n  private static _getGLCompareFunction(rhi: IHardwareRenderer, compareFunction: CompareFunction): number {\n    const gl = rhi.gl;\n\n    switch (compareFunction) {\n      case CompareFunction.Never:\n        return gl.NEVER;\n      case CompareFunction.Less:\n        return gl.LESS;\n      case CompareFunction.Equal:\n        return gl.EQUAL;\n      case CompareFunction.LessEqual:\n        return gl.LEQUAL;\n      case CompareFunction.Greater:\n        return gl.GREATER;\n      case CompareFunction.NotEqual:\n        return gl.NOTEQUAL;\n      case CompareFunction.GreaterEqual:\n        return gl.GEQUAL;\n      case CompareFunction.Always:\n        return gl.ALWAYS;\n    }\n  }\n\n  /** Whether to enable the depth test. */\n  enabled: boolean = true;\n  /** Whether the depth value can be written.*/\n  writeEnabled: boolean = true;\n  /** Depth comparison function. */\n  compareFunction: CompareFunction = CompareFunction.Less;\n\n  /**\n   * @internal\n   * Apply the current depth state by comparing with the last depth state.\n   */\n  _apply(hardwareRenderer: IHardwareRenderer, lastRenderState: RenderState): void {\n    this._platformApply(hardwareRenderer, lastRenderState.depthState);\n  }\n\n  private _platformApply(rhi: IHardwareRenderer, lastState: DepthState): void {\n    const gl = <WebGLRenderingContext>rhi.gl;\n    const { enabled, compareFunction, writeEnabled } = this;\n\n    if (enabled != lastState.enabled) {\n      if (enabled) {\n        gl.enable(gl.DEPTH_TEST);\n      } else {\n        gl.disable(gl.DEPTH_TEST);\n      }\n      lastState.enabled = enabled;\n    }\n\n    if (enabled) {\n      // apply compare func.\n      if (compareFunction != lastState.compareFunction) {\n        gl.depthFunc(DepthState._getGLCompareFunction(rhi, compareFunction));\n        lastState.compareFunction = compareFunction;\n      }\n\n      // apply write enabled.\n      if (writeEnabled != lastState.writeEnabled) {\n        gl.depthMask(writeEnabled);\n        lastState.writeEnabled = writeEnabled;\n      }\n    }\n  }\n}\n", "/**\n * Culling mode.\n * @remarks specifies whether or not front- and/or back-facing polygons can be culled.\n */\nexport enum CullMode {\n  /** Disable culling. */\n  Off,\n  /** cut the front-face of the polygons. */\n  Front,\n  /** cut the back-face of the polygons. */\n  Back\n}\n", "import { IHardwareRenderer } from \"../../renderingHardwareInterface/IHardwareRenderer\";\nimport { CullMode } from \"../enums/CullMode\";\nimport { RenderState } from \"./RenderState\";\n\n/**\n * Raster state.\n */\nexport class RasterState {\n  /** Specifies whether or not front- and/or back-facing polygons can be culled. */\n  cullMode: CullMode = CullMode.Back;\n  /** The multiplier by which an implementation-specific value is multiplied with to create a constant depth offset. */\n  depthBias: number = 0;\n  /** The scale factor for the variable depth offset for each polygon. */\n  slopeScaledDepthBias: number = 0;\n\n  /** @internal */\n  _cullFaceEnable: boolean = true;\n\n  /**\n   * @internal\n   */\n  _apply(hardwareRenderer: IHardwareRenderer, lastRenderState: RenderState): void {\n    this._platformApply(hardwareRenderer, lastRenderState.rasterState);\n  }\n\n  private _platformApply(rhi: IHardwareRenderer, lastState: RasterState): void {\n    const gl = <WebGLRenderingContext>rhi.gl;\n    const { cullMode, depthBias, slopeScaledDepthBias } = this;\n\n    const cullFaceEnable = cullMode !== CullMode.Off;\n    if (cullFaceEnable !== lastState._cullFaceEnable) {\n      if (cullFaceEnable) {\n        gl.enable(gl.CULL_FACE);\n      } else {\n        gl.disable(gl.CULL_FACE);\n      }\n      lastState._cullFaceEnable = cullFaceEnable;\n    }\n\n    // apply front face.\n    if (cullFaceEnable) {\n      if (cullMode !== lastState.cullMode) {\n        if (cullMode == CullMode.Back) {\n          gl.cullFace(gl.BACK);\n        } else {\n          gl.cullFace(gl.FRONT);\n        }\n        lastState.cullMode = cullMode;\n      }\n    }\n\n    // apply polygonOffset.\n    if (depthBias !== lastState.depthBias || slopeScaledDepthBias !== lastState.slopeScaledDepthBias) {\n      if (depthBias !== 0 || slopeScaledDepthBias !== 0) {\n        gl.enable(gl.POLYGON_OFFSET_FILL);\n        gl.polygonOffset(slopeScaledDepthBias, depthBias);\n      } else {\n        gl.disable(gl.POLYGON_OFFSET_FILL);\n      }\n      lastState.depthBias = depthBias;\n      lastState.slopeScaledDepthBias = slopeScaledDepthBias;\n    }\n  }\n}\n", "/**\n * Stencil operation mode.\n * @remarks sets the front and/or back-facing stencil test actions.\n */\nexport enum StencilOperation {\n  /** Keeps the current value. */\n  Keep,\n  /** Sets the stencil buffer value to 0. */\n  Zero,\n  /** Sets the stencil buffer value to the reference value. */\n  Replace,\n  /** Increments the current stencil buffer value. Clamps to the maximum representable unsigned value. */\n  IncrementSaturate,\n  /** Decrements the current stencil buffer value. Clamps to 0. */\n  DecrementSaturate,\n  /** Inverts the current stencil buffer value bitwise. */\n  Invert,\n  /** Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value. */\n  IncrementWrap,\n  /** Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of 0. */\n  DecrementWrap\n}\n", "import { IHardwareRenderer } from \"../../renderingHardwareInterface/IHardwareRenderer\";\nimport { CompareFunction } from \"../enums/CompareFunction\";\nimport { StencilOperation } from \"../enums/StencilOperation\";\nimport { RenderState } from \"./RenderState\";\n\n/**\n * Stencil state.\n */\nexport class StencilState {\n  private static _getGLCompareFunction(rhi: IHardwareRenderer, compareFunction: CompareFunction): number {\n    const gl = rhi.gl;\n\n    switch (compareFunction) {\n      case CompareFunction.Never:\n        return gl.NEVER;\n      case CompareFunction.Less:\n        return gl.LESS;\n      case CompareFunction.Equal:\n        return gl.EQUAL;\n      case CompareFunction.LessEqual:\n        return gl.LEQUAL;\n      case CompareFunction.Greater:\n        return gl.GREATER;\n      case CompareFunction.NotEqual:\n        return gl.NOTEQUAL;\n      case CompareFunction.GreaterEqual:\n        return gl.GEQUAL;\n      case CompareFunction.Always:\n        return gl.ALWAYS;\n    }\n  }\n\n  private static _getGLStencilOperation(rhi: IHardwareRenderer, compareFunction: StencilOperation): number {\n    const gl = rhi.gl;\n\n    switch (compareFunction) {\n      case StencilOperation.Keep:\n        return gl.KEEP;\n      case StencilOperation.Zero:\n        return gl.ZERO;\n      case StencilOperation.Replace:\n        return gl.REPLACE;\n      case StencilOperation.IncrementSaturate:\n        return gl.INCR;\n      case StencilOperation.DecrementSaturate:\n        return gl.DECR;\n      case StencilOperation.Invert:\n        return gl.INVERT;\n      case StencilOperation.IncrementWrap:\n        return gl.INCR_WRAP;\n      case StencilOperation.DecrementWrap:\n        return gl.DECR_WRAP;\n    }\n  }\n\n  /** Whether to enable stencil test. */\n  enabled: boolean = false;\n  /** Write the reference value of the stencil buffer. */\n  referenceValue: number = 0;\n  /** Specifying a bit-wise mask that is used to AND the reference value and the stored stencil value when the test is done. */\n  mask: number = 0xff;\n  /** Specifying a bit mask to enable or disable writing of individual bits in the stencil planes. */\n  writeMask: number = 0xff;\n  /** The comparison function of the reference value of the front face of the geometry and the current buffer storage value. */\n  compareFunctionFront: CompareFunction = CompareFunction.Always;\n  /** The comparison function of the reference value of the back of the geometry and the current buffer storage value. */\n  compareFunctionBack: CompareFunction = CompareFunction.Always;\n  /** specifying the function to use for front face when both the stencil test and the depth test pass. */\n  passOperationFront: StencilOperation = StencilOperation.Keep;\n  /** specifying the function to use for back face when both the stencil test and the depth test pass. */\n  passOperationBack: StencilOperation = StencilOperation.Keep;\n  /** specifying the function to use for front face when the stencil test fails. */\n  failOperationFront: StencilOperation = StencilOperation.Keep;\n  /** specifying the function to use for back face when the stencil test fails. */\n  failOperationBack: StencilOperation = StencilOperation.Keep;\n  /** specifying the function to use for front face when the stencil test passes, but the depth test fails. */\n  zFailOperationFront: StencilOperation = StencilOperation.Keep;\n  /** specifying the function to use for back face when the stencil test passes, but the depth test fails. */\n  zFailOperationBack: StencilOperation = StencilOperation.Keep;\n\n  /**\n   * @internal\n   */\n  _apply(hardwareRenderer: IHardwareRenderer, lastRenderState: RenderState): void {\n    this._platformApply(hardwareRenderer, lastRenderState.stencilState);\n  }\n\n  private _platformApply(rhi: IHardwareRenderer, lastState: StencilState): void {\n    const gl = <WebGLRenderingContext>rhi.gl;\n    const {\n      enabled,\n      referenceValue,\n      mask,\n      compareFunctionFront,\n      compareFunctionBack,\n      failOperationFront,\n      zFailOperationFront,\n      passOperationFront,\n      failOperationBack,\n      zFailOperationBack,\n      passOperationBack,\n      writeMask\n    } = this;\n\n    if (enabled != lastState.enabled) {\n      if (enabled) {\n        gl.enable(gl.STENCIL_TEST);\n      } else {\n        gl.disable(gl.STENCIL_TEST);\n      }\n      lastState.enabled = enabled;\n    }\n\n    if (enabled) {\n      // apply stencil func.\n      const referenceOrMaskChange = referenceValue !== lastState.referenceValue || mask !== lastState.mask;\n      if (referenceOrMaskChange || compareFunctionFront !== lastState.compareFunctionFront) {\n        gl.stencilFuncSeparate(\n          gl.FRONT,\n          StencilState._getGLCompareFunction(rhi, compareFunctionFront),\n          referenceValue,\n          mask\n        );\n        lastState.compareFunctionFront = compareFunctionFront;\n      }\n\n      if (referenceOrMaskChange || compareFunctionBack !== lastState.compareFunctionBack) {\n        gl.stencilFuncSeparate(gl.BACK, StencilState._getGLCompareFunction(rhi, compareFunctionBack), referenceValue, mask);\n        lastState.compareFunctionBack = this.compareFunctionBack;\n      }\n      if (referenceOrMaskChange) {\n        lastState.referenceValue = this.referenceValue;\n        lastState.mask = this.mask;\n      }\n\n      // apply stencil operation.\n      if (\n        failOperationFront !== lastState.failOperationFront ||\n        zFailOperationFront !== lastState.zFailOperationFront ||\n        passOperationFront !== lastState.passOperationFront\n      ) {\n        gl.stencilOpSeparate(\n          gl.FRONT,\n          StencilState._getGLStencilOperation(rhi, failOperationFront),\n          StencilState._getGLStencilOperation(rhi, zFailOperationFront),\n          StencilState._getGLStencilOperation(rhi, passOperationFront)\n        );\n        lastState.failOperationFront = failOperationFront;\n        lastState.zFailOperationFront = zFailOperationFront;\n        lastState.passOperationFront = passOperationFront;\n      }\n\n      if (\n        failOperationBack !== lastState.failOperationBack ||\n        zFailOperationBack !== lastState.zFailOperationBack ||\n        passOperationBack !== lastState.passOperationBack\n      ) {\n        gl.stencilOpSeparate(\n          gl.BACK,\n          StencilState._getGLStencilOperation(rhi, failOperationBack),\n          StencilState._getGLStencilOperation(rhi, zFailOperationBack),\n          StencilState._getGLStencilOperation(rhi, passOperationBack)\n        );\n        lastState.failOperationBack = failOperationBack;\n        lastState.zFailOperationBack = zFailOperationBack;\n        lastState.passOperationBack = passOperationBack;\n      }\n\n      // apply write mask.\n      if (writeMask !== lastState.writeMask) {\n        gl.stencilMask(writeMask);\n        lastState.writeMask = writeMask;\n      }\n    }\n  }\n}\n", "import { Engine } from \"../../Engine\";\nimport { BlendState } from \"./BlendState\";\nimport { DepthState } from \"./DepthState\";\nimport { RasterState } from \"./RasterState\";\nimport { StencilState } from \"./StencilState\";\n\n/**\n * Render state.\n */\nexport class RenderState {\n  /** Blend state. */\n  readonly blendState: BlendState = new BlendState();\n  /** Depth state. */\n  readonly depthState: DepthState = new DepthState();\n  /** Stencil state. */\n  readonly stencilState: StencilState = new StencilState();\n  /** Raster state. */\n  readonly rasterState: RasterState = new RasterState();\n\n  /** @internal */\n  _apply(engine: Engine): void {\n    const hardwareRenderer = engine._hardwareRenderer;\n    const lastRenderState = engine._lastRenderState;\n    this.blendState._apply(hardwareRenderer, lastRenderState);\n    this.depthState._apply(hardwareRenderer, lastRenderState);\n    this.stencilState._apply(hardwareRenderer, lastRenderState);\n    this.rasterState._apply(hardwareRenderer, lastRenderState);\n  }\n}\n", "import { IClone } from \"@oasis-engine/design\";\nimport { RefObject } from \"../asset/RefObject\";\nimport { CloneManager } from \"../clone/CloneManager\";\nimport { Engine } from \"../Engine\";\nimport { RenderElement } from \"../RenderPipeline/RenderElement\";\nimport { ShaderDataGroup } from \"../shader/enums/ShaderDataGroup\";\nimport { Shader } from \"../shader/Shader\";\nimport { ShaderData } from \"../shader/ShaderData\";\nimport { RenderState } from \"../shader/state/RenderState\";\nimport { RenderQueueType } from \"./enums/RenderQueueType\";\n\n/**\n * Material.\n */\nexport class Material extends RefObject implements IClone {\n  /** Name. */\n  name: string;\n  /** Shader used by the material. */\n  shader: Shader;\n  /** Render queue type. */\n  renderQueueType: RenderQueueType = RenderQueueType.Opaque;\n  /** Shader data. */\n  readonly shaderData: ShaderData = new ShaderData(ShaderDataGroup.Material);\n  /** Render state. */\n  readonly renderState: RenderState = new RenderState(); // todo: later will as a part of shaderData when shader effect frame is OK, that is more powerful and flexible.\n\n  /**\n   * Create a material instance.\n   * @param engine - Engine to which the material belongs\n   * @param shader - Shader used by the material\n   */\n  constructor(engine: Engine, shader: Shader) {\n    super(engine);\n    this.shader = shader;\n  }\n\n  /**\n   * Clone and return the instance.\n   */\n  clone(): Material {\n    const dest = new Material(this._engine, this.shader);\n    this.cloneTo(dest);\n    return dest;\n  }\n\n  /**\n   * Clone to the target material.\n   * @param target - target material\n   */\n  cloneTo(target: Material): void {\n    target.shader = this.shader;\n    target.renderQueueType = this.renderQueueType;\n    this.shaderData.cloneTo(target.shaderData);\n    CloneManager.deepCloneObject(this.renderState, target.renderState);\n  }\n\n  /**\n   * @override\n   */\n  _addRefCount(value: number): void {\n    super._addRefCount(value);\n    this.shaderData._addRefCount(value);\n  }\n\n  /**\n   * @internal\n   * @todo:temporary solution\n   */\n  _preRender(renderElement: RenderElement) {}\n\n  /**\n   * @override\n   */\n  protected _onDestroy(): void {}\n}\n", "/**\n * Class pool utils.\n */\nexport class ClassPool<T> {\n  private _elementPoolIndex: number = 0;\n  private _elementPool: T[] = [];\n  private _type: new () => T;\n\n  constructor(type: new () => T) {\n    this._type = type;\n  }\n\n  /**\n   * Get element from pool.\n   */\n  getFromPool(): T {\n    const { _elementPoolIndex: index, _elementPool: pool } = this;\n    this._elementPoolIndex++;\n    if (pool.length === index) {\n      const element = new this._type();\n      pool.push(element);\n      return element;\n    } else {\n      return pool[index];\n    }\n  }\n\n  /**\n   * Reset pool.\n   */\n  resetPool(): void {\n    this._elementPoolIndex = 0;\n  }\n}\n", "import { Matrix } from \"@oasis-engine/math\";\nimport { Camera } from \"../Camera\";\n\n/**\n * Rendering context.\n */\nexport class RenderContext {\n  /** @internal */\n  _camera: Camera;\n  /** @internal */\n  _viewProjectMatrix: Matrix = new Matrix();\n\n  /**\n   * @internal\n   */\n  _setContext(camera: Camera): void {\n    this._camera = camera;\n    Matrix.multiply(camera.projectionMatrix, camera.viewMatrix, this._viewProjectMatrix);\n  }\n}\n", "import { Mesh } from \"../graphic/Mesh\";\nimport { SubMesh } from \"../graphic/SubMesh\";\nimport { Material } from \"../material/Material\";\nimport { Renderer } from \"../Renderer\";\n\n/**\n * Render element.\n */\nexport class RenderElement {\n  /** Render component. */\n  component: Renderer;\n  /** Mesh. */\n  mesh: Mesh;\n  /** Sub mesh. */\n  subMesh: SubMesh;\n  /** Material. */\n  material: Material;\n\n  setValue(component: Renderer, mesh: Mesh, subMesh: SubMesh, material: Material): void {\n    this.component = component;\n    this.mesh = mesh;\n    this.subMesh = subMesh;\n    this.material = material;\n  }\n}\n", "import { Color, Vector2, Vector3 } from \"@oasis-engine/math\";\nimport { Camera } from \"../Camera\";\nimport { Material } from \"../material/Material\";\nimport { Renderer } from \"../Renderer\";\n\nexport class SpriteElement {\n  component: Renderer;\n  positions: Vector3[];\n  uv: Vector2[];\n  triangles: number[];\n  color: Color;\n  material: Material;\n  camera: Camera;\n\n  setValue(\n    component: Renderer,\n    positions: Vector3[],\n    uv: Vector2[],\n    triangles: number[],\n    color: Color,\n    material: Material,\n    camera: Camera\n  ): void {\n    this.component = component;\n    this.positions = positions;\n    this.uv = uv;\n    this.triangles = triangles;\n    this.color = color;\n    this.material = material;\n    this.camera = camera;\n  }\n}\n", "import { Vector2, Vector3 } from \"@oasis-engine/math\";\nimport { Camera } from \"../Camera\";\nimport { Component } from \"../Component\";\nimport { Material } from \"../material/Material\";\n\nexport class SpriteMaskElement {\n  component: Component;\n  positions: Vector3[];\n  uv: Vector2[];\n  triangles: number[];\n  material: Material;\n  isAdd: boolean = true;\n  camera: Camera;\n\n  setValue(component: Component, positions: Vector3[], uv: Vector2[], triangles: number[], material: Material): void {\n    this.component = component;\n    this.positions = positions;\n    this.uv = uv;\n    this.triangles = triangles;\n    this.material = material;\n  }\n}\n", "/**\n * Sprite mask interaction.\n */\nexport enum SpriteMaskInteraction {\n  /** The sprite will not interact with the masking system. */\n  None,\n  /** The sprite will be visible only in areas where a mask is present. */\n  VisibleInsideMask,\n  /** The sprite will be visible only in areas where no mask is present. */\n  VisibleOutsideMask\n}\n", "import { BoundingBox, Matrix, Vector3 } from \"@oasis-engine/math\";\nimport { Camera } from \"./Camera\";\nimport { deepClone, ignoreClone, shallowClone } from \"./clone/CloneManager\";\nimport { Component } from \"./Component\";\nimport { Entity } from \"./Entity\";\nimport { Material } from \"./material/Material\";\nimport { RenderContext } from \"./RenderPipeline/RenderContext\";\nimport { Shader } from \"./shader\";\nimport { ShaderDataGroup } from \"./shader/enums/ShaderDataGroup\";\nimport { ShaderData } from \"./shader/ShaderData\";\nimport { ShaderMacroCollection } from \"./shader/ShaderMacroCollection\";\nimport { UpdateFlag } from \"./UpdateFlag\";\n\n/**\n * Renderable component.\n */\nexport abstract class Renderer extends Component {\n  private static _localMatrixProperty = Shader.getPropertyByName(\"u_localMat\");\n  private static _worldMatrixProperty = Shader.getPropertyByName(\"u_modelMat\");\n  private static _mvMatrixProperty = Shader.getPropertyByName(\"u_MVMat\");\n  private static _mvpMatrixProperty = Shader.getPropertyByName(\"u_MVPMat\");\n  private static _mvInvMatrixProperty = Shader.getPropertyByName(\"u_MVInvMat\");\n  private static _normalMatrixProperty = Shader.getPropertyByName(\"u_normalMat\");\n\n  /** ShaderData related to renderer. */\n  @deepClone\n  readonly shaderData: ShaderData = new ShaderData(ShaderDataGroup.Renderer);\n  /** Whether it is clipped by the frustum, needs to be turned on camera.enableFrustumCulling. */\n  @ignoreClone\n  isCulled: boolean = false;\n\n  /** @internal */\n  @ignoreClone\n  _distanceForSort: number;\n  /** @internal */\n  @ignoreClone\n  _onUpdateIndex: number = -1;\n  /** @internal */\n  @ignoreClone\n  _rendererIndex: number = -1;\n  /** @internal */\n  @ignoreClone\n  _globalShaderMacro: ShaderMacroCollection = new ShaderMacroCollection();\n\n  /** @internal temp solution. */\n  @ignoreClone\n  _renderSortId: number = 0;\n\n  @ignoreClone\n  protected _overrideUpdate: boolean = false;\n  @shallowClone\n  protected _materials: Material[] = [];\n\n  @ignoreClone\n  private _transformChangeFlag: UpdateFlag;\n  @deepClone\n  private _bounds: BoundingBox = new BoundingBox(new Vector3(), new Vector3());\n  @ignoreClone\n  private _mvMatrix: Matrix = new Matrix();\n  @ignoreClone\n  private _mvpMatrix: Matrix = new Matrix();\n  @ignoreClone\n  private _mvInvMatrix: Matrix = new Matrix();\n  @ignoreClone\n  private _normalMatrix: Matrix = new Matrix();\n  @ignoreClone\n  private _materialsInstanced: boolean[] = [];\n\n  /**\n   * Material count.\n   */\n  get materialCount(): number {\n    return this._materials.length;\n  }\n\n  set materialCount(value: number) {\n    const materials = this._materials;\n    const materialsInstanced = this._materialsInstanced;\n\n    materials.length !== value && (materials.length = value);\n    materialsInstanced.length > value && (materialsInstanced.length = value);\n  }\n\n  /**\n   * The bounding volume of the renderer.\n   */\n  get bounds(): BoundingBox {\n    const changeFlag = this._transformChangeFlag;\n    if (changeFlag.flag) {\n      this._updateBounds(this._bounds);\n      changeFlag.flag = false;\n    }\n    return this._bounds;\n  }\n\n  /**\n   * @internal\n   */\n  constructor(entity: Entity) {\n    super(entity);\n    const prototype = Renderer.prototype;\n    this._overrideUpdate = this.update !== prototype.update;\n    this._transformChangeFlag = this.entity.transform.registerWorldChangeFlag();\n    this.shaderData._addRefCount(1);\n  }\n\n  /**\n   * Get the first instance material.\n   * @returns The first instance material\n   */\n  getInstanceMaterial(): Material | null;\n\n  /**\n   * Get the first instance material by index.\n   * @remarks Calling this function for the first time after the material is set will create an instance material to ensure that it is unique to the renderer.\n   * @param index - Material index\n   * @returns Instance material\n   */\n  getInstanceMaterial(index: number): Material | null;\n\n  getInstanceMaterial(index: number = 0): Material | null {\n    const materials = this._materials;\n    if (materials.length > index) {\n      const material = materials[index];\n      if (material) {\n        if (this._materialsInstanced[index]) {\n          return material;\n        } else {\n          return this._createInstanceMaterial(material, index);\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get the first material.\n   * @returns The first material\n   */\n  getMaterial(): Material | null;\n\n  /**\n   * Get the first material by index.\n   * @param index - Material index\n   * @returns Material\n   */\n  getMaterial(index: number): Material | null;\n\n  getMaterial(index: number = 0): Material | null {\n    return this._materials[index] || null;\n  }\n\n  /**\n   * Set the first material.\n   * @param material - The first material\n   */\n  setMaterial(material: Material): void;\n\n  /**\n   * Set material by index.\n   * @param index - Material index\n   * @param material - The material\n   */\n  setMaterial(index: number, material: Material): void;\n\n  setMaterial(indexOrMaterial: number | Material, material: Material = null): void {\n    let index;\n    if (typeof indexOrMaterial === \"number\") {\n      index = indexOrMaterial;\n    } else {\n      index = 0;\n      material = indexOrMaterial;\n    }\n\n    const materials = this._materials;\n    if (index >= materials.length) {\n      materials.length = index + 1;\n    }\n\n    const materialsInstance = this._materialsInstanced;\n    const internalMaterial = materials[index];\n    if (internalMaterial !== material) {\n      materials[index] = material;\n      index < materialsInstance.length && (materialsInstance[index] = false);\n      internalMaterial && internalMaterial._addRefCount(-1);\n      material && material._addRefCount(1);\n    }\n  }\n\n  /**\n   * Get all instance materials.\n   * @remarks Calling this function for the first time after the material is set will create an instance material to ensure that it is unique to the renderer.\n   * @returns All instance materials\n   */\n  getInstanceMaterials(): Readonly<Material[]> {\n    const materials = this._materials;\n    const materialsInstance = this._materialsInstanced;\n    for (let i = 0, n = materials.length; i < n; i++) {\n      if (!materialsInstance[i]) {\n        this._createInstanceMaterial(this._materials[i], i);\n      }\n    }\n    return materials;\n  }\n\n  /**\n   * Get all materials.\n   * @returns All materials\n   */\n  getMaterials(): Readonly<Material[]> {\n    return this._materials;\n  }\n\n  /**\n   * Set all materials.\n   * @param materials - All materials\n   */\n  setMaterials(materials: Material[]): void {\n    const count = materials.length;\n    const internalMaterials = this._materials;\n    const materialsInstanced = this._materialsInstanced;\n\n    for (let i = count, n = internalMaterials.length; i < n; i++) {\n      const internalMaterial = internalMaterials[i];\n      internalMaterial && internalMaterial._addRefCount(-1);\n    }\n\n    internalMaterials.length !== count && (internalMaterials.length = count);\n    materialsInstanced.length !== 0 && (materialsInstanced.length = 0);\n\n    for (let i = 0; i < count; i++) {\n      const internalMaterial = internalMaterials[i];\n      const material = materials[i];\n      if (internalMaterial !== material) {\n        internalMaterials[i] = material;\n        internalMaterial && internalMaterial._addRefCount(-1);\n        material && material._addRefCount(1);\n      }\n    }\n  }\n\n  update(deltaTime: number): void {}\n\n  /**\n   * @internal\n   */\n  _updateShaderData(context: RenderContext): void {\n    const shaderData = this.shaderData;\n    const worldMatrix = this.entity.transform.worldMatrix;\n    const mvMatrix = this._mvMatrix;\n    const mvpMatrix = this._mvpMatrix;\n    const mvInvMatrix = this._mvInvMatrix;\n    const normalMatrix = this._normalMatrix;\n\n    Matrix.multiply(context._camera.viewMatrix, worldMatrix, mvMatrix);\n    Matrix.multiply(context._viewProjectMatrix, worldMatrix, mvpMatrix);\n    Matrix.invert(mvMatrix, mvInvMatrix);\n    Matrix.invert(worldMatrix, normalMatrix);\n    normalMatrix.transpose();\n\n    shaderData.setMatrix(Renderer._localMatrixProperty, this.entity.transform.localMatrix);\n    shaderData.setMatrix(Renderer._worldMatrixProperty, worldMatrix);\n    shaderData.setMatrix(Renderer._mvMatrixProperty, mvMatrix);\n    shaderData.setMatrix(Renderer._mvpMatrixProperty, mvpMatrix);\n    shaderData.setMatrix(Renderer._mvInvMatrixProperty, mvInvMatrix);\n    shaderData.setMatrix(Renderer._normalMatrixProperty, normalMatrix);\n  }\n\n  _onEnable(): void {\n    const componentsManager = this.engine._componentsManager;\n    if (this._overrideUpdate) {\n      componentsManager.addOnUpdateRenderers(this);\n    }\n    componentsManager.addRenderer(this);\n  }\n\n  _onDisable(): void {\n    const componentsManager = this.engine._componentsManager;\n    if (this._overrideUpdate) {\n      componentsManager.removeOnUpdateRenderers(this);\n    }\n    componentsManager.removeRenderer(this);\n  }\n\n  /**\n   * @internal\n   */\n  abstract _render(camera: Camera): void;\n\n  /**\n   * @internal\n   */\n  _onDestroy(): void {\n    const flag = this._transformChangeFlag;\n    if (flag) {\n      flag.destroy();\n      this._transformChangeFlag = null;\n    }\n\n    this.shaderData._addRefCount(-1);\n\n    for (let i = 0, n = this._materials.length; i < n; i++) {\n      this._materials[i]._addRefCount(-1);\n    }\n  }\n\n  protected _updateBounds(worldBounds: BoundingBox): void {}\n\n  private _createInstanceMaterial(material: Material, index: number): Material {\n    const insMaterial: Material = material.clone();\n    insMaterial.name = insMaterial.name + \"(Instance)\";\n    material._addRefCount(-1);\n    insMaterial._addRefCount(1);\n    this._materialsInstanced[index] = true;\n    this._materials[index] = insMaterial;\n    return insMaterial;\n  }\n}\n", "/**\n * Sprite mask layer.\n */\nexport enum SpriteMaskLayer {\n  /** Mask layer 0. */\n  Layer0 = 0x1,\n  /** Mask layer 1. */\n  Layer1 = 0x2,\n  /** Mask layer 2. */\n  Layer2 = 0x4,\n  /** Mask layer 3. */\n  Layer3 = 0x8,\n  /** Mask layer 4. */\n  Layer4 = 0x10,\n  /** Mask layer 5. */\n  Layer5 = 0x20,\n  /** Mask layer 6. */\n  Layer6 = 0x40,\n  /** Mask layer 7. */\n  Layer7 = 0x80,\n  /** Mask layer 8. */\n  Layer8 = 0x100,\n  /** Mask layer 9. */\n  Layer9 = 0x200,\n  /** Mask layer 10. */\n  Layer10 = 0x400,\n  /** Mask layer 11. */\n  Layer11 = 0x800,\n  /** Mask layer 12. */\n  Layer12 = 0x1000,\n  /** Mask layer 13. */\n  Layer13 = 0x2000,\n  /** Mask layer 14. */\n  Layer14 = 0x4000,\n  /** Mask layer 15. */\n  Layer15 = 0x8000,\n  /** Mask layer 16. */\n  Layer16 = 0x10000,\n  /** Mask layer 17. */\n  Layer17 = 0x20000,\n  /** Mask layer 18. */\n  Layer18 = 0x40000,\n  /** Mask layer 19. */\n  Layer19 = 0x80000,\n  /** Mask layer 20. */\n  Layer20 = 0x100000,\n  /** Mask layer 21. */\n  Layer21 = 0x200000,\n  /** Mask layer 22. */\n  Layer22 = 0x400000,\n  /** Mask layer 23. */\n  Layer23 = 0x800000,\n  /** Mask layer 24. */\n  Layer24 = 0x1000000,\n  /** Mask layer 25. */\n  Layer25 = 0x2000000,\n  /** Mask layer 26. */\n  Layer26 = 0x4000000,\n  /** Mask layer 27. */\n  Layer27 = 0x8000000,\n  /** Mask layer 28. */\n  Layer28 = 0x10000000,\n  /** Mask layer 29. */\n  Layer29 = 0x20000000,\n  /** Mask layer 30. */\n  Layer30 = 0x40000000,\n  /** Mask layer 31. */\n  Layer31 = 0x80000000,\n  /** All mask layers. */\n  Everything = 0xffffffff\n}\n", "import { Vector3 } from \"@oasis-engine/math\";\nimport { Camera } from \"../../Camera\";\nimport { assignmentClone, deepClone, ignoreClone } from \"../../clone/CloneManager\";\nimport { Entity } from \"../../Entity\";\nimport { Renderer } from \"../../Renderer\";\nimport { SpriteMaskElement } from \"../../RenderPipeline/SpriteMaskElement\";\nimport { Shader } from \"../../shader/Shader\";\nimport { ShaderProperty } from \"../../shader/ShaderProperty\";\nimport { UpdateFlag } from \"../../UpdateFlag\";\nimport { SpriteMaskLayer } from \"../enums/SpriteMaskLayer\";\nimport { Sprite } from \"./Sprite\";\n\n/**\n * A component for masking Sprites.\n */\nexport class SpriteMask extends Renderer {\n  /** @internal */\n  static _textureProperty: ShaderProperty = Shader.getPropertyByName(\"u_maskTexture\");\n  /** @internal */\n  static _alphaCutoffProperty: ShaderProperty = Shader.getPropertyByName(\"u_maskAlphaCutoff\");\n\n  private static _tempVec3: Vector3 = new Vector3();\n\n  /** @internal */\n  _maskElement: SpriteMaskElement;\n\n  @deepClone\n  private _positions: Vector3[] = [new Vector3(), new Vector3(), new Vector3(), new Vector3()];\n  @ignoreClone\n  private _isSpriteDirty: boolean = true;\n  @ignoreClone\n  private _worldMatrixDirtyFlag: UpdateFlag;\n  @assignmentClone\n  private _sprite: Sprite = null;\n  @assignmentClone\n  private _alphaCutoff: number = 0.5;\n\n  /** The mask layers the sprite mask influence to. */\n  @assignmentClone\n  influenceLayers: number = SpriteMaskLayer.Everything;\n\n  /**\n   * The Sprite used to define the mask.\n   */\n  get sprite(): Sprite {\n    return this._sprite;\n  }\n\n  set sprite(value: Sprite) {\n    if (this._sprite !== value) {\n      this._sprite = value;\n      this._isSpriteDirty = true;\n    }\n  }\n\n  /**\n   * The minimum alpha value used by the mask to select the area of influence defined over the mask's sprite. Value between 0 and 1.\n   */\n  get alphaCutoff(): number {\n    return this._alphaCutoff;\n  }\n\n  set alphaCutoff(value: number) {\n    if (this._alphaCutoff !== value) {\n      this._alphaCutoff = value;\n      this.shaderData.setFloat(SpriteMask._alphaCutoffProperty, value);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  constructor(entity: Entity) {\n    super(entity);\n    this._worldMatrixDirtyFlag = entity.transform.registerWorldChangeFlag();\n    this.setMaterial(this._engine._spriteMaskDefaultMaterial);\n    this.shaderData.setFloat(SpriteMask._alphaCutoffProperty, this._alphaCutoff);\n  }\n\n  /**\n   * @override\n   * @inheritdoc\n   */\n  _onDestroy(): void {\n    this._worldMatrixDirtyFlag.destroy();\n    super._onDestroy();\n  }\n\n  /**\n   * @override\n   * @inheritdoc\n   */\n  _render(camera: Camera): void {\n    const sprite = this.sprite;\n    if (!sprite) {\n      return null;\n    }\n    const texture = sprite.texture;\n    if (!texture) {\n      return null;\n    }\n\n    const positions = this._positions;\n    const transform = this.entity.transform;\n\n    // Update sprite data.\n    const localDirty = sprite._updateMeshData();\n\n    if (this._worldMatrixDirtyFlag.flag || localDirty || this._isSpriteDirty) {\n      const localPositions = sprite._positions;\n      const localVertexPos = SpriteMask._tempVec3;\n      const worldMatrix = transform.worldMatrix;\n\n      for (let i = 0, n = positions.length; i < n; i++) {\n        const curVertexPos = localPositions[i];\n        localVertexPos.setValue(curVertexPos.x, curVertexPos.y, 0);\n        Vector3.transformToVec3(localVertexPos, worldMatrix, positions[i]);\n      }\n\n      this._isSpriteDirty = false;\n      this._worldMatrixDirtyFlag.flag = false;\n    }\n\n    this.shaderData.setTexture(SpriteMask._textureProperty, texture);\n    const spriteMaskElementPool = this._engine._spriteMaskElementPool;\n    const maskElement = spriteMaskElementPool.getFromPool();\n    maskElement.setValue(this, positions, sprite._uv, sprite._triangles, this.getMaterial());\n    maskElement.camera = camera;\n\n    camera._renderPipeline._allSpriteMasks.add(this);\n    this._maskElement = maskElement;\n  }\n}\n", "/**\n * Vertex element format.\n */\nexport enum VertexElementFormat {\n  /** 32-bit float */\n  Float,\n  /** Two-dimensional 32-bit float */\n  Vector2,\n  /** Three-dimensional 32-bit float */\n  Vector3,\n  /** Four-dimensional 32-bit float */\n  Vector4,\n  /** Four-dimensional 8-bit integer,range is [-128,127] */\n  Byte4,\n  /** Four-dimensional 8-bit Unsigned integer, range is [0,255] */\n  UByte4,\n  /** Four-dimensional 8-bit Normalized integer, range is [-1,1] */\n  NormalizedByte4,\n  /** Four-dimensional 8-bit Normalized unsigned integer, range is [0,1] */\n  NormalizedUByte4,\n  /** Two-dimensional 16-bit integer, range is[-32768, 32767] */\n  Short2,\n  /** Two-dimensional 16-bit Unsigned integer, range is [0, 65535] */\n  UShort2,\n  /** Two-dimensional 16-bit Unsigned integer, range is [-1, 1] */\n  NormalizedShort2,\n  /** Two-dimensional 16-bit Normalized unsigned integer, range is [0, 1] */\n  NormalizedUShort2,\n  /** Four-dimensional 16-bit integer, range is [-32768, 32767] */\n  Short4,\n  /** Four-dimensional 16-bit Unsigned integer, range is [0, 65535] */\n  UShort4,\n  /** Four-dimensional 16-bit Normalized integer, range is[-1, 1] */\n  NormalizedShort4,\n  /** Four-dimensional 16-bit Normalized unsigned integer, range is [0, 1] */\n  NormalizedUShort4\n}\n", "/**\n * Buffer usage.\n */\nexport enum BufferUsage {\n  /** The buffer content are intended to be specified once, and used many times */\n  Static,\n  /** The buffer contents are intended to be respecified repeatedly, and used many times */\n  Dynamic,\n  /** The buffer contents are intended to be specified once, and used at most a few times */\n  Stream\n}\n", "/**\n * Index format.\n */\nexport enum IndexFormat {\n  /** 8 bit */\n  UInt8,\n  /** 16 bit */\n  UInt16,\n  /** 32 bit */\n  UInt32\n}\n", "import { BufferUsage } from \"./enums/BufferUsage\";\nimport { VertexElementFormat } from \"./enums/VertexElementFormat\";\nimport { DataType } from \"../base/Constant\";\nimport { IndexFormat } from \"./enums/IndexFormat\";\n\nexport interface ElementInfo {\n  size: number;\n  type: DataType;\n  normalized: boolean;\n}\n\nexport class BufferUtil {\n  /**\n   * @internal\n   */\n  static _getGLBufferUsage(gl: WebGLRenderingContext, bufferUsage: BufferUsage): number {\n    switch (bufferUsage) {\n      case BufferUsage.Static:\n        return gl.STATIC_DRAW;\n      case BufferUsage.Dynamic:\n        return gl.DYNAMIC_DRAW;\n      case BufferUsage.Stream:\n        return gl.STREAM_DRAW;\n    }\n  }\n\n  static _getGLIndexType(indexFormat: IndexFormat): DataType {\n    switch (indexFormat) {\n      case IndexFormat.UInt8:\n        return DataType.UNSIGNED_BYTE;\n      case IndexFormat.UInt16:\n        return DataType.UNSIGNED_SHORT;\n      case IndexFormat.UInt32:\n        return DataType.UNSIGNED_INT;\n    }\n  }\n\n  static _getGLIndexByteCount(indexFormat: IndexFormat): DataType {\n    switch (indexFormat) {\n      case IndexFormat.UInt8:\n        return 1;\n      case IndexFormat.UInt16:\n        return 2;\n      case IndexFormat.UInt32:\n        return 4;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static _getElementInfo(format: VertexElementFormat): ElementInfo {\n    let size: number;\n    let type: DataType;\n    let normalized: boolean = false;\n\n    switch (format) {\n      case VertexElementFormat.Float:\n        size = 1;\n        type = DataType.FLOAT;\n        break;\n      case VertexElementFormat.Vector2:\n        size = 2;\n        type = DataType.FLOAT;\n        break;\n      case VertexElementFormat.Vector3:\n        size = 3;\n        type = DataType.FLOAT;\n        break;\n      case VertexElementFormat.Vector4:\n        size = 4;\n        type = DataType.FLOAT;\n        break;\n      case VertexElementFormat.Byte4:\n        size = 4;\n        type = DataType.BYTE;\n        break;\n      case VertexElementFormat.UByte4:\n        size = 4;\n        type = DataType.UNSIGNED_BYTE;\n        break;\n      case VertexElementFormat.NormalizedByte4:\n        size = 4;\n        type = DataType.BYTE;\n        normalized = true;\n        break;\n      case VertexElementFormat.NormalizedUByte4:\n        size = 4;\n        type = DataType.UNSIGNED_BYTE;\n        normalized = true;\n        break;\n      case VertexElementFormat.Short2:\n        size = 2;\n        type = DataType.SHORT;\n        break;\n      case VertexElementFormat.UShort2:\n        size = 2;\n        type = DataType.UNSIGNED_SHORT;\n        break;\n      case VertexElementFormat.NormalizedShort2:\n        size = 2;\n        type = DataType.SHORT;\n        normalized = true;\n        break;\n      case VertexElementFormat.NormalizedUShort2:\n        size = 2;\n        type = DataType.UNSIGNED_SHORT;\n        normalized = true;\n        break;\n      case VertexElementFormat.Short4:\n        size = 4;\n        type = DataType.SHORT;\n        break;\n      case VertexElementFormat.UShort4:\n        size = 4;\n        type = DataType.UNSIGNED_SHORT;\n        break;\n      case VertexElementFormat.NormalizedShort4:\n        size = 4;\n        type = DataType.SHORT;\n        normalized = true;\n        break;\n      case VertexElementFormat.NormalizedUShort4:\n        size = 4;\n        type = DataType.UNSIGNED_SHORT;\n        normalized = true;\n        break;\n      default:\n        break;\n    }\n    return { size, type, normalized };\n  }\n}\n", "import { VertexElementFormat } from \"./enums/VertexElementFormat\";\nimport { ElementInfo, BufferUtil } from \"./BufferUtil\";\n\n/**\n * Vertex element.\n */\nexport class VertexElement {\n  _glElementInfo: ElementInfo;\n\n  private _semantic: string;\n  private _offset: number;\n  private _format: VertexElementFormat;\n  private _bindingIndex: number;\n  private _instanceStepRate: number;\n\n  /**\n   * Vertex semantic.\n   */\n  get semantic(): string {\n    return this._semantic;\n  }\n\n  /**\n   * Vertex data byte offset.\n   */\n  get offset(): number {\n    return this._offset;\n  }\n\n  /**\n   * Vertex data format.\n   */\n  get format(): VertexElementFormat {\n    return this._format;\n  }\n\n  /**\n   * Vertex buffer binding index.\n   */\n  get bindingIndex(): number {\n    return this._bindingIndex;\n  }\n\n  /**\n   * Instance cadence, the number of instances drawn for each vertex in the buffer, non-instance elements must be 0.\n   */\n  get instanceStepRate(): number {\n    return this._instanceStepRate;\n  }\n\n  /**\n   * Create vertex element.\n   * @param semantic - Input vertex semantic\n   * @param offset - Vertex data byte offset\n   * @param format - Vertex data format\n   * @param bindingIndex - Vertex buffer binding index\n   * @param instanceStepRate - Instance cadence, the number of instances drawn for each vertex in the buffer, non-instance elements must be 0.\n   */\n  constructor(\n    semantic: string,\n    offset: number,\n    format: VertexElementFormat,\n    bindingIndex: number,\n    instanceStepRate: number = 0\n  ) {\n    this._semantic = semantic;\n    this._offset = offset;\n    this._format = format;\n    this._bindingIndex = bindingIndex;\n    this._glElementInfo = BufferUtil._getElementInfo(this.format);\n    this._instanceStepRate = Math.floor(instanceStepRate);\n  }\n}\n", "/**\n * Buffer binding flag.\n */\nexport enum BufferBindFlag {\n  /** Vertex buffer binding flag */\n  VertexBuffer,\n  /** Index buffer binding flag */\n  IndexBuffer\n}\n", "/**\n * Define update strategy when call bufferData/bufferSubData func.\n */\nexport enum SetDataOptions {\n  /** Can overwrite part of used buffer data and ensure correct rendering */\n  None,\n  /** Discard old buffer and create a new buffer, and won't affect the previous rendering */\n  Discard\n  ///** Need to ensure that the buffer data will not be overwritten, and won't interrupting rendering if setData immediately */\n  //NoOverwrite\n}\n", "import { RefObject } from \"../asset/RefObject\";\nimport { Engine } from \"../Engine\";\nimport { IHardwareRenderer } from \"../renderingHardwareInterface/IHardwareRenderer\";\nimport { BufferUtil } from \"./BufferUtil\";\nimport { BufferBindFlag } from \"./enums/BufferBindFlag\";\nimport { BufferUsage } from \"./enums/BufferUsage\";\nimport { SetDataOptions } from \"./enums/SetDataOptions\";\n\n/**\n * Buffer.\n */\nexport class Buffer extends RefObject {\n  _glBindTarget: number;\n  _glBufferUsage: number;\n  _nativeBuffer: WebGLBuffer;\n\n  private _hardwareRenderer: IHardwareRenderer;\n  private _type: BufferBindFlag;\n  private _byteLength: number;\n  private _bufferUsage: BufferUsage;\n\n  /**\n   * Buffer binding flag.\n   */\n  get type(): BufferBindFlag {\n    return this._type;\n  }\n\n  /**\n   * Byte length.\n   */\n  get byteLength(): number {\n    return this._byteLength;\n  }\n\n  /**\n   * Buffer usage.\n   */\n  get bufferUsage(): BufferUsage {\n    return this._bufferUsage;\n  }\n\n  /**\n   * Create Buffer.\n   * @param engine - Engine\n   * @param type - Buffer binding flag\n   * @param byteLength - Byte length\n   * @param bufferUsage - Buffer usage\n   */\n  constructor(engine: Engine, type: BufferBindFlag, byteLength: number, bufferUsage?: BufferUsage);\n\n  /**\n   * Create Buffer.\n   * @param engine - Engine\n   * @param type - Buffer binding flag\n   * @param data - Byte\n   * @param bufferUsage - Buffer usage\n   */\n  constructor(engine: Engine, type: BufferBindFlag, data: ArrayBuffer | ArrayBufferView, bufferUsage?: BufferUsage);\n\n  constructor(\n    engine: Engine,\n    type: BufferBindFlag,\n    byteLengthOrData: number | ArrayBuffer | ArrayBufferView,\n    bufferUsage: BufferUsage = BufferUsage.Static\n  ) {\n    super(engine);\n    this._engine = engine;\n    this._type = type;\n    this._bufferUsage = bufferUsage;\n\n    const hardwareRenderer = engine._hardwareRenderer;\n    const gl: WebGLRenderingContext & WebGL2RenderingContext = hardwareRenderer.gl;\n    const glBufferUsage = BufferUtil._getGLBufferUsage(gl, bufferUsage);\n    const glBindTarget = type === BufferBindFlag.VertexBuffer ? gl.ARRAY_BUFFER : gl.ELEMENT_ARRAY_BUFFER;\n\n    this._nativeBuffer = gl.createBuffer();\n    this._hardwareRenderer = hardwareRenderer;\n    this._glBufferUsage = glBufferUsage;\n    this._glBindTarget = glBindTarget;\n\n    this.bind();\n    if (typeof byteLengthOrData === \"number\") {\n      this._byteLength = byteLengthOrData;\n      gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);\n    } else {\n      this._byteLength = byteLengthOrData.byteLength;\n      gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);\n    }\n    gl.bindBuffer(glBindTarget, null);\n  }\n\n  /**\n   * Bind buffer.\n   */\n  bind(): void {\n    const gl: WebGLRenderingContext & WebGL2RenderingContext = this._hardwareRenderer.gl;\n    gl.bindBuffer(this._glBindTarget, this._nativeBuffer);\n  }\n\n  /**\n   * Set buffer data.\n   * @param data - Input buffer data\n   */\n  setData(data: ArrayBuffer | ArrayBufferView): void;\n\n  /**\n   * Set buffer data.\n   * @param data - Input buffer data\n   * @param bufferByteOffset - buffer byte offset\n   */\n  setData(data: ArrayBuffer | ArrayBufferView, bufferByteOffset: number): void;\n\n  /**\n   * Set buffer data.\n   * @param data - Input buffer data\n   * @param bufferByteOffset - Buffer byte offset\n   * @param dataOffset - Buffer byte offset\n   * @param dataLength - Data length\n   */\n  setData(data: ArrayBuffer | ArrayBufferView, bufferByteOffset: number, dataOffset: number, dataLength?: number): void;\n\n  /**\n   * Set buffer data.\n   * @param data - Input buffer data\n   * @param bufferByteOffset - Buffer byte offset\n   * @param dataOffset - Buffer byte offset\n   * @param dataLength - Data length\n   * @param options - Update strategy: None/Discard/NoOverwrite\n   */\n  setData(\n    data: ArrayBuffer | ArrayBufferView,\n    bufferByteOffset: number,\n    dataOffset: number,\n    dataLength: number,\n    options: SetDataOptions\n  ): void;\n\n  setData(\n    data: ArrayBuffer | ArrayBufferView,\n    bufferByteOffset: number = 0,\n    dataOffset: number = 0,\n    dataLength?: number,\n    options: SetDataOptions = SetDataOptions.None\n  ): void {\n    const gl: WebGLRenderingContext & WebGL2RenderingContext = this._hardwareRenderer.gl;\n    const isWebGL2: boolean = this._hardwareRenderer.isWebGL2;\n    const glBindTarget: number = this._glBindTarget;\n    this.bind();\n\n    if (options === SetDataOptions.Discard) {\n      gl.bufferData(glBindTarget, this._byteLength, this._glBufferUsage);\n    }\n\n    // TypeArray is BYTES_PER_ELEMENT, unTypeArray is 1\n    const byteSize = (<Uint8Array>data).BYTES_PER_ELEMENT || 1;\n    const dataByteLength = dataLength ? byteSize * dataLength : data.byteLength;\n\n    if (dataOffset !== 0 || dataByteLength < data.byteLength) {\n      const isArrayBufferView = (<ArrayBufferView>data).byteOffset !== undefined;\n      if (isWebGL2 && isArrayBufferView) {\n        gl.bufferSubData(glBindTarget, bufferByteOffset, <ArrayBufferView>data, dataOffset, dataByteLength / byteSize);\n      } else {\n        const subData = new Uint8Array(\n          isArrayBufferView ? (<ArrayBufferView>data).buffer : <ArrayBuffer>data,\n          dataOffset * byteSize,\n          dataByteLength\n        );\n        gl.bufferSubData(glBindTarget, bufferByteOffset, subData);\n      }\n    } else {\n      gl.bufferSubData(glBindTarget, bufferByteOffset, data);\n    }\n    gl.bindBuffer(glBindTarget, null);\n  }\n\n  /**\n   * Get buffer data.\n   * @param data - Output buffer data\n   */\n  getData(data: ArrayBufferView): void;\n\n  /**\n   * Get buffer data.\n   * @param data - Output buffer data\n   * @param bufferByteOffset - Buffer byte offset\n   */\n  getData(data: ArrayBufferView, bufferByteOffset: number): void;\n\n  /**\n   * Get buffer data.\n   * @param data - Output buffer data\n   * @param bufferByteOffset - Buffer byte offset\n   * @param dataOffset - Output data offset\n   * @param dataLength - Output data length\n   */\n  getData(data: ArrayBufferView, bufferByteOffset: number, dataOffset: number, dataLength: number): void;\n\n  getData(data: ArrayBufferView, bufferByteOffset: number = 0, dataOffset: number = 0, dataLength?: number): void {\n    const isWebGL2: boolean = this._hardwareRenderer.isWebGL2;\n\n    if (isWebGL2) {\n      const gl: WebGLRenderingContext & WebGL2RenderingContext = this._hardwareRenderer.gl;\n      this.bind();\n      gl.getBufferSubData(this._glBindTarget, bufferByteOffset, data, dataOffset, dataLength);\n    } else {\n      throw \"Buffer is write-only on WebGL1.0 platforms.\";\n    }\n  }\n\n  /**\n   * @override\n   * Destroy.\n   */\n  _onDestroy() {\n    const gl: WebGLRenderingContext & WebGL2RenderingContext = this._hardwareRenderer.gl;\n    gl.deleteBuffer(this._nativeBuffer);\n    this._nativeBuffer = null;\n    this._hardwareRenderer = null;\n  }\n\n  /**\n   * @deprecated\n   */\n  resize(dataLength: number) {\n    this.bind();\n    const gl: WebGLRenderingContext & WebGL2RenderingContext = this._hardwareRenderer.gl;\n    gl.bufferData(this._glBindTarget, dataLength, this._glBufferUsage);\n    this._byteLength = dataLength;\n  }\n}\n", "/**\n * Mesh topology.\n */\nexport enum MeshTopology {\n  /** Draws a single dot */\n  Points = 0,\n  /** Draws a line between a pair of vertices */\n  Lines = 1,\n  /** Draws a straight line to the next vertex, and connects the last vertex back to the first */\n  LineLoop = 2,\n  /** Draws a straight line to the next vertex. */\n  LineStrip = 3,\n  /** Draws a triangle for a group of three vertices */\n  Triangles = 4,\n  /** Draws a triangle strip */\n  TriangleStrip = 5,\n  /** Draws a triangle fan */\n  TriangleFan = 6\n}\n", "import { IndexFormat } from \"./enums/IndexFormat\";\nimport { Buffer } from \"./Buffer\";\n\n/**\n * Index buffer binding.\n */\nexport class IndexBufferBinding {\n  /** @internal */\n  _buffer: Buffer;\n  /** @internal */\n  _format: IndexFormat;\n\n  /**\n   * Index buffer.\n   */\n  get buffer(): Buffer {\n    return this._buffer;\n  }\n\n  /**\n   * Index buffer format.\n   */\n  get format(): IndexFormat {\n    return this._format;\n  }\n\n  /**\n   * Create index buffer binding.\n   * @param buffer - Index buffer\n   * @param format - Index buffer format\n   */\n  constructor(buffer: Buffer, format: IndexFormat) {\n    this._buffer = buffer;\n    this._format = format;\n  }\n}\n", "import { MeshTopology } from \"./enums/MeshTopology\";\n\n/**\n * Sub-mesh, mainly contains drawing information.\n */\nexport class SubMesh {\n  /** Start drawing offset. */\n  start: number;\n  /** Drawing count. */\n  count: number;\n  /** Drawing topology. */\n  topology: MeshTopology;\n\n  /**\n   * Create a sub-mesh.\n   * @param start - Start drawing offset\n   * @param count - Drawing count\n   * @param topology - Drawing topology\n   */\n  constructor(start: number = 0, count: number = 0, topology: MeshTopology = MeshTopology.Triangles) {\n    this.start = start;\n    this.count = count;\n    this.topology = topology;\n  }\n}\n", "import { IPlatformPrimitive } from \"@oasis-engine/design/types/renderingHardwareInterface/IPlatformPrimitive\";\nimport { BoundingBox } from \"@oasis-engine/math\";\nimport { RefObject } from \"../asset/RefObject\";\nimport { Engine } from \"../Engine\";\nimport { BufferUtil } from \"../graphic/BufferUtil\";\nimport { MeshTopology } from \"../graphic/enums/MeshTopology\";\nimport { IndexBufferBinding } from \"../graphic/IndexBufferBinding\";\nimport { SubMesh } from \"../graphic/SubMesh\";\nimport { VertexBufferBinding } from \"../graphic/VertexBufferBinding\";\nimport { VertexElement } from \"../graphic/VertexElement\";\nimport { ShaderProgram } from \"../shader/ShaderProgram\";\nimport { UpdateFlag } from \"../UpdateFlag\";\nimport { UpdateFlagManager } from \"../UpdateFlagManager\";\n\n/**\n * Mesh.\n */\nexport abstract class Mesh extends RefObject {\n  /** Name. */\n  name: string;\n  /** The bounding volume of the mesh. */\n  readonly bounds: BoundingBox = new BoundingBox();\n\n  _vertexElementMap: Record<string, VertexElement> = {};\n  _glIndexType: number;\n  _glIndexByteCount: number;\n  _platformPrimitive: IPlatformPrimitive;\n\n  /** @internal */\n  _instanceCount: number = 0;\n  /** @internal */\n  _vertexBufferBindings: VertexBufferBinding[] = [];\n  /** @internal */\n  _indexBufferBinding: IndexBufferBinding = null;\n  /** @internal */\n  _vertexElements: VertexElement[] = [];\n\n  private _subMeshes: SubMesh[] = [];\n  private _updateFlagManager: UpdateFlagManager = new UpdateFlagManager();\n\n  /**\n   * First sub-mesh. Rendered using the first material.\n   */\n  get subMesh(): SubMesh | null {\n    return this._subMeshes[0] || null;\n  }\n\n  /**\n   * A collection of sub-mesh, each sub-mesh can be rendered with an independent material.\n   */\n  get subMeshes(): Readonly<SubMesh[]> {\n    return this._subMeshes;\n  }\n\n  /**\n   * Create mesh.\n   * @param engine - Engine\n   * @param name - Mesh name\n   */\n  constructor(engine: Engine, name?: string) {\n    super(engine);\n    this.name = name;\n    this._platformPrimitive = this._engine._hardwareRenderer.createPlatformPrimitive(this);\n  }\n\n  /**\n   * Add sub-mesh, each sub-mesh can correspond to an independent material.\n   * @param subMesh - Start drawing offset, if the index buffer is set, it means the offset in the index buffer, if not set, it means the offset in the vertex buffer\n   * @returns Sub-mesh\n   */\n  addSubMesh(subMesh: SubMesh): SubMesh;\n\n  /**\n   * Add sub-mesh, each sub-mesh can correspond to an independent material.\n   * @param start - Start drawing offset, if the index buffer is set, it means the offset in the index buffer, if not set, it means the offset in the vertex buffer\n   * @param count - Drawing count, if the index buffer is set, it means the count in the index buffer, if not set, it means the count in the vertex buffer\n   * @param topology - Drawing topology, default is MeshTopology.Triangles\n   * @returns Sub-mesh\n   */\n  addSubMesh(start: number, count: number, topology?: MeshTopology): SubMesh;\n\n  addSubMesh(\n    startOrSubMesh: number | SubMesh,\n    count?: number,\n    topology: MeshTopology = MeshTopology.Triangles\n  ): SubMesh {\n    if (typeof startOrSubMesh === \"number\") {\n      startOrSubMesh = new SubMesh(startOrSubMesh, count, topology);\n    }\n    this._subMeshes.push(startOrSubMesh);\n    return startOrSubMesh;\n  }\n\n  /**\n   * Remove sub-mesh.\n   * @param subMesh - Sub-mesh needs to be removed\n   */\n  removeSubMesh(subMesh: SubMesh): void {\n    const subMeshes = this._subMeshes;\n    const index = subMeshes.indexOf(subMesh);\n    if (index !== -1) {\n      subMeshes.splice(index, 1);\n    }\n  }\n\n  /**\n   * Clear all sub-mesh.\n   */\n  clearSubMesh(): void {\n    this._subMeshes.length = 0;\n  }\n\n  /**\n   * Register update flag, update flag will be true if the vertex element changes.\n   * @returns Update flag\n   */\n  registerUpdateFlag(): UpdateFlag {\n    return this._updateFlagManager.register();\n  }\n\n  /**\n   * @internal\n   */\n  _draw(shaderProgram: ShaderProgram, subMesh: SubMesh): void {\n    this._platformPrimitive.draw(shaderProgram, subMesh);\n  }\n\n  /**\n   * @override\n   */\n  _addRefCount(value: number): void {\n    super._addRefCount(value);\n    const vertexBufferBindings = this._vertexBufferBindings;\n    for (let i = 0, n = vertexBufferBindings.length; i < n; i++) {\n      vertexBufferBindings[i]._buffer._addRefCount(value);\n    }\n  }\n\n  /**\n   * @override\n   * Destroy.\n   */\n  _onDestroy(): void {\n    this._vertexBufferBindings = null;\n    this._indexBufferBinding = null;\n    this._vertexElements = null;\n    this._vertexElementMap = null;\n    this._platformPrimitive.destroy();\n  }\n\n  protected _setVertexElements(elements: VertexElement[]): void {\n    this._clearVertexElements();\n    for (let i = 0, n = elements.length; i < n; i++) {\n      this._addVertexElement(elements[i]);\n    }\n  }\n\n  protected _setVertexBufferBinding(index: number, binding: VertexBufferBinding): void {\n    if (this._getRefCount() > 0) {\n      const lastBinding = this._vertexBufferBindings[index];\n      lastBinding && lastBinding._buffer._addRefCount(-1);\n      binding._buffer._addRefCount(1);\n    }\n    this._vertexBufferBindings[index] = binding;\n  }\n\n  protected _setIndexBufferBinding(binding: IndexBufferBinding | null): void {\n    if (binding) {\n      this._indexBufferBinding = binding;\n      this._glIndexType = BufferUtil._getGLIndexType(binding.format);\n      this._glIndexByteCount = BufferUtil._getGLIndexByteCount(binding.format);\n    } else {\n      this._indexBufferBinding = null;\n      this._glIndexType = undefined;\n    }\n  }\n\n  private _clearVertexElements(): void {\n    this._vertexElements.length = 0;\n    const vertexElementMap = this._vertexElementMap;\n    for (const k in vertexElementMap) {\n      delete vertexElementMap[k];\n    }\n  }\n\n  private _addVertexElement(element: VertexElement): void {\n    const { semantic } = element;\n    this._vertexElementMap[semantic] = element;\n    this._vertexElements.push(element);\n    this._updateFlagManager.distribute();\n  }\n}\n", "import { Buffer } from \"./Buffer\";\n\n/**\n * Vertex buffer binding.\n */\nexport class VertexBufferBinding {\n  /** @internal */\n  _buffer: Buffer;\n  /** @internal */\n  _stride: number;\n\n  /**\n   * Vertex buffer.\n   */\n  get buffer(): Buffer {\n    return this._buffer;\n  }\n\n  /**\n   * Vertex buffer stride.\n   */\n  get stride(): number {\n    return this._stride;\n  }\n\n  /**\n   * Create vertex buffer.\n   * @param buffer - Vertex buffer\n   * @param stride - Vertex buffer stride\n   */\n  constructor(buffer: Buffer, stride: number) {\n    this._buffer = buffer;\n    this._stride = stride;\n  }\n}\n", "/**\n * The filter mode of the texture.\n */\nexport enum TextureFilterMode {\n  /** Point filtering. */\n  Point = 0,\n  /** Bilinear filtering. */\n  Bilinear = 1,\n  /** Trilinear filtering. */\n  Trilinear = 2\n}\n", "/**\n * Texture format enumeration.\n */\nexport enum TextureFormat {\n  /** RGB format,8 bits per channel. */\n  R8G8B8,\n  /** RGBA format,8 bits per channel. */\n  R8G8B8A8,\n  /** RGBA format,4 bits per channel. */\n  R4G4B4A4,\n  /** RGBA format,5 bits in R channel,5 bits in G channel,5 bits in B channel, 1 bit in A channel. */\n  R5G5B5A1,\n  /** RGB format,5 bits in R channel,6 bits in G channel,5 bits in B channel. */\n  R5G6B5,\n  /** Transparent format,8 bits. */\n  Alpha8,\n  /** Luminance/alpha in RGB channel, alpha in A channel. */\n  LuminanceAlpha,\n  /** RGBA format,32 bits per channel. */\n  R32G32B32A32,\n  /** RGB compressed format\u3002*/\n  DXT1,\n  /** RGBA compressed format\u3002*/\n  DXT5,\n  /** RGB compressed format,4 bits per pixel\u3002*/\n  ETC1_RGB,\n  /** RGB compressed format,4 bits per pixel\u3002*/\n  ETC2_RGB,\n  /** RGBA compressed format,5 bits per pixel,4 bit in RGB, 1 bit in A. */\n  ETC2_RGBA5,\n  /** RGB compressed format,8 bits per pixel. */\n  ETC2_RGBA8,\n  /** RGB compressed format,2 bits per pixel. */\n  PVRTC_RGB2,\n  /** RGBA compressed format,2 bits per pixel. */\n  PVRTC_RGBA2,\n  /** RGB compressed format,4 bits per pixel. */\n  PVRTC_RGB4,\n  /** RGBA compressed format,4 bits per pixel. */\n  PVRTC_RGBA4,\n  /** RGB(A) compressed format,128 bits per 4x4 pixel block. */\n  ASTC_4x4,\n  /** RGB(A) compressed format,128 bits per 5x5 pixel block. */\n  ASTC_5x5,\n  /** RGB(A) compressed format,128 bits per 6x6 pixel block. */\n  ASTC_6x6,\n  /** RGB(A) compressed format,128 bits per 8x8 pixel block. */\n  ASTC_8x8,\n  /** RGB(A) compressed format,128 bits per 10x10 pixel block. */\n  ASTC_10x10,\n  /** RGB(A) compressed format,128 bits per 12x12 pixel block. */\n  ASTC_12x12\n}\n", "/**\n * Wrapping mode of the texture.\n */\nexport enum TextureWrapMode {\n  /** Clamping mode. use the color of edge pixels beyond the texture boundary. */\n  Clamp = 0,\n  /** Repeating mode. tiling will be repeated if it exceeds the texture boundary. */\n  Repeat = 1,\n  /** Mirror repeat mode. tiling will be mirrored and repeated if it exceeds the texture boundary. */\n  Mirror = 2\n}\n", "import { Engine } from \"../Engine\";\nimport { IPlatformTexture2D } from \"../renderingHardwareInterface\";\nimport { TextureFilterMode } from \"./enums/TextureFilterMode\";\nimport { TextureFormat } from \"./enums/TextureFormat\";\nimport { TextureWrapMode } from \"./enums/TextureWrapMode\";\nimport { Texture } from \"./Texture\";\n\n/**\n * Two-dimensional texture.\n */\nexport class Texture2D extends Texture {\n  private _format: TextureFormat;\n\n  /**\n   * Texture format.\n   */\n  get format(): TextureFormat {\n    return this._format;\n  }\n\n  /**\n   * Create Texture2D.\n   * @param engine - Define the engine to use to render this texture\n   * @param width - Texture width\n   * @param height - Texture height\n   * @param format - Texture format. default  `TextureFormat.R8G8B8A8`\n   * @param mipmap - Whether to use multi-level texture\n   */\n  constructor(\n    engine: Engine,\n    width: number,\n    height: number,\n    format: TextureFormat = TextureFormat.R8G8B8A8,\n    mipmap: boolean = true\n  ) {\n    super(engine);\n    this._mipmap = mipmap;\n    this._width = width;\n    this._height = height;\n    this._format = format;\n    this._mipmapCount = this._getMipmapCount();\n\n    this._platformTexture = engine._hardwareRenderer.createPlatformTexture2D(this);\n\n    this.filterMode = TextureFilterMode.Bilinear;\n    this.wrapModeU = this.wrapModeV = TextureWrapMode.Repeat;\n  }\n\n  /**\n   * Setting pixels data through color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.\n   * @remarks If it is the WebGL1.0 platform and the texture format is compressed, the first upload must be filled with textures.\n   * @param colorBuffer - Color buffer data\n   * @param mipLevel - Texture mipmapping level\n   * @param x - X coordinate of area start\n   * @param y - Y coordinate of area start\n   * @param width - Data width. if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)\n   * @param height - Data height. if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)\n   */\n  setPixelBuffer(\n    colorBuffer: ArrayBufferView,\n    mipLevel: number = 0,\n    x?: number,\n    y?: number,\n    width?: number,\n    height?: number\n  ): void {\n    (this._platformTexture as IPlatformTexture2D).setPixelBuffer(colorBuffer, mipLevel, x, y, width, height);\n  }\n\n  /**\n   * Setting pixels data through TexImageSource, designated area and texture mipmapping level.\n   * @param imageSource - The source of texture\n   * @param mipLevel - Texture mipmapping level\n   * @param flipY - Whether to flip the Y axis\n   * @param premultiplyAlpha - Whether to premultiply the transparent channel\n   * @param x - X coordinate of area start\n   * @param y - Y coordinate of area start\n   */\n  setImageSource(\n    imageSource: TexImageSource,\n    mipLevel: number = 0,\n    flipY: boolean = false,\n    premultiplyAlpha: boolean = false,\n    x?: number,\n    y?: number\n  ): void {\n    (this._platformTexture as IPlatformTexture2D).setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y);\n  }\n\n  /**\n   * Get the pixel color buffer according to the specified area.\n   * @param x - X coordinate of area start\n   * @param y - Y coordinate of area start\n   * @param width - Area width\n   * @param height - Area height\n   * @param out - Color buffer\n   */\n  getPixelBuffer(x: number, y: number, width: number, height: number, out: ArrayBufferView): void {\n    (this._platformTexture as IPlatformTexture2D).getPixelBuffer(x, y, width, height, out);\n  }\n}\n", "/**\n * The rendering buffer color format enumeration.\n */\nexport enum RenderBufferColorFormat {\n  /** RGB format,8 bits per channel. */\n  R8G8B8,\n  /** RGBA format,8 bits per channel. */\n  R8G8B8A8,\n  /** RGBA format,4 bits per channel. */\n  R4G4B4A4,\n  /** RGBA format,5 bits in R channel, 5 bits in G channel, 5 bits in B channel, 1 bit in A channel. */\n  R5G5B5A1,\n  /** RGB format,5 bits in R channel, 6 bits in G channel, 5 bits in B channel. */\n  R5G6B5,\n  /** transparent format, 8 bits. */\n  Alpha8,\n  /** RGBA format,16 bits per channel. */\n  R16G16B16A16,\n  /** RGBA format,32 bits per channel. */\n  R32G32B32A32\n}\n", "/**\n * Render buffer depth format enumeration.\n */\nexport enum RenderBufferDepthFormat {\n  /** Render to depth buffer,engine will automatically select the supported precision. */\n  Depth = 0,\n  /** Render to depth stencil buffer, engine will automatically select the supported precision. */\n  DepthStencil = 1,\n  /** Render to stencil buffer. */\n  Stencil = 2,\n\n  /** Force 16-bit depth buffer. */\n  Depth16 = 3,\n  /** Force 24-bit depth buffer. */\n  Depth24 = 4,\n  /** Force 32-bit depth buffer. */\n  Depth32 = 5,\n  /** Force 16-bit depth + 8-bit stencil buffer. */\n  Depth24Stencil8 = 6,\n  /** Force 32-bit depth + 8-bit stencil buffer. */\n  Depth32Stencil8 = 7\n}\n", "/**\n * Define the face of the cube texture.\n */\nexport enum TextureCubeFace {\n  /** Positive X face for a cube-mapped texture. */\n  PositiveX = 0,\n  /** Negative X face for a cube-mapped texture. */\n  NegativeX = 1,\n  /** Positive Y face for a cube-mapped texture. */\n  PositiveY = 2,\n  /** Negative Y face for a cube-mapped texture. */\n  NegativeY = 3,\n  /** Positive Z face for a cube-mapped texture. */\n  PositiveZ = 4,\n  /** Negative Z face for a cube-mapped texture. */\n  NegativeZ = 5\n}\n", "import { Engine } from \"../Engine\";\nimport { IPlatformTextureCubeMap } from \"../renderingHardwareInterface\";\nimport { TextureCubeFace } from \"./enums/TextureCubeFace\";\nimport { TextureFilterMode } from \"./enums/TextureFilterMode\";\nimport { TextureFormat } from \"./enums/TextureFormat\";\nimport { TextureWrapMode } from \"./enums/TextureWrapMode\";\nimport { Texture } from \"./Texture\";\n\n/**\n * Cube texture.\n */\nexport class TextureCubeMap extends Texture {\n  private _format: TextureFormat;\n\n  /**\n   * Texture format.\n   */\n  get format(): TextureFormat {\n    return this._format;\n  }\n\n  /**\n   * Create TextureCube.\n   * @param engine - Define the engine to use to render this texture\n   * @param size - Texture size. texture width must be equal to height in cube texture\n   * @param format - Texture format,default TextureFormat.R8G8B8A8\n   * @param mipmap - Whether to use multi-level texture\n   */\n  constructor(engine: Engine, size: number, format: TextureFormat = TextureFormat.R8G8B8A8, mipmap: boolean = true) {\n    super(engine);\n\n    this._mipmap = mipmap;\n    this._width = size;\n    this._height = size;\n    this._format = format;\n    this._mipmapCount = this._getMipmapCount();\n\n    this._platformTexture = engine._hardwareRenderer.createPlatformTextureCubeMap(this);\n\n    this.filterMode = TextureFilterMode.Bilinear;\n    this.wrapModeU = this.wrapModeV = TextureWrapMode.Clamp;\n  }\n\n  /**\n   * Setting pixels data through cube face,color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.\n   * @remarks When compressed texture is in WebGL1, the texture must be filled first before writing the sub-region\n   * @param face - Cube face\n   * @param colorBuffer - Color buffer data\n   * @param mipLevel - Texture mipmapping level\n   * @param x - X coordinate of area start\n   * @param y -  Y coordinate of area start\n   * @param width - Data width.if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)\n   * @param height - Data height.if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)\n   */\n  setPixelBuffer(\n    face: TextureCubeFace,\n    colorBuffer: ArrayBufferView,\n    mipLevel: number = 0,\n    x?: number,\n    y?: number,\n    width?: number,\n    height?: number\n  ): void {\n    (this._platformTexture as IPlatformTextureCubeMap).setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height);\n  }\n\n  /**\n   * Setting pixels data through cube face, TexImageSource, designated area and texture mipmapping level.\n   * @param face - Cube face\n   * @param imageSource - The source of texture\n   * @param mipLevel - Texture mipmapping level\n   * @param flipY - Whether to flip the Y axis\n   * @param premultiplyAlpha - Whether to premultiply the transparent channel\n   * @param x - X coordinate of area start\n   * @param y - Y coordinate of area start\n   */\n  setImageSource(\n    face: TextureCubeFace,\n    imageSource: TexImageSource,\n    mipLevel: number = 0,\n    flipY: boolean = false,\n    premultiplyAlpha: boolean = false,\n    x?: number,\n    y?: number\n  ): void {\n    (this._platformTexture as IPlatformTextureCubeMap).setImageSource(\n      face,\n      imageSource,\n      mipLevel,\n      flipY,\n      premultiplyAlpha,\n      x,\n      y\n    );\n  }\n\n  /**\n   * Get the pixel color buffer according to the specified cube face and area.\n   * @param face - You can choose which cube face to read\n   * @param x - X coordinate of area start\n   * @param y - Y coordinate of area start\n   * @param width - Area width\n   * @param height - Area height\n   * @param out - Color buffer\n   */\n  getPixelBuffer(\n    face: TextureCubeFace,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    out: ArrayBufferView\n  ): void {\n    (this._platformTexture as IPlatformTextureCubeMap).getPixelBuffer(face, x, y, width, height, out);\n  }\n}\n", "import { Engine } from \"../Engine\";\nimport { RenderBufferDepthFormat } from \"./enums/RenderBufferDepthFormat\";\nimport { TextureFilterMode } from \"./enums/TextureFilterMode\";\nimport { TextureWrapMode } from \"./enums/TextureWrapMode\";\nimport { Texture } from \"./Texture\";\n\n/**\n * The texture is used for the output of depth information in off-screen rendering.\n */\nexport class RenderDepthTexture extends Texture {\n  private _autoMipmap: boolean = false;\n  private _format: RenderBufferDepthFormat;\n  private _isCube: boolean = false;\n\n  /**\n   * Texture format.\n   */\n  get format(): RenderBufferDepthFormat {\n    return this._format;\n  }\n\n  /**\n   * Whether to render to a cube texture.\n   */\n  get isCube(): boolean {\n    return this._isCube;\n  }\n\n  /**\n   * Whether to automatically generate multi-level textures.\n   */\n  get autoGenerateMipmaps(): boolean {\n    return this._autoMipmap;\n  }\n\n  set autoGenerateMipmaps(value: boolean) {\n    this._autoMipmap = value;\n  }\n\n  /**\n   * Create RenderDepthTexture.\n   * @param engine - Define the engine to use to render this depth texture\n   * @param width - Texture width\n   * @param height - Texture height\n   * @param format - Texture format. default RenderBufferDepthFormat.Depth, engine will automatically select the supported precision\n   * @param mipmap - Whether to use multi-level texture\n   * @param isCube - Whether it's cube texture\n   */\n  constructor(\n    engine: Engine,\n    width: number,\n    height: number,\n    format: RenderBufferDepthFormat = RenderBufferDepthFormat.Depth,\n    mipmap: boolean = false,\n    isCube: boolean = false\n  ) {\n    super(engine);\n\n    this._isCube = isCube;\n    this._mipmap = mipmap;\n    this._width = width;\n    this._height = height;\n    this._format = format;\n    this._mipmapCount = this._getMipmapCount();\n\n    this._platformTexture = engine._hardwareRenderer.createPlatformRenderDepthTexture(this);\n\n    this.filterMode = TextureFilterMode.Bilinear;\n    this.wrapModeU = this.wrapModeV = TextureWrapMode.Clamp;\n  }\n}\n", "import { EngineObject } from \"../base\";\nimport { Engine } from \"../Engine\";\nimport { IPlatformRenderTarget } from \"../renderingHardwareInterface\";\nimport { RenderBufferDepthFormat } from \"./enums/RenderBufferDepthFormat\";\nimport { TextureCubeFace } from \"./enums/TextureCubeFace\";\nimport { RenderColorTexture } from \"./RenderColorTexture\";\nimport { RenderDepthTexture } from \"./RenderDepthTexture\";\n\n/**\n * The render target used for off-screen rendering.\n */\nexport class RenderTarget extends EngineObject {\n  /** @internal */\n  _platformRenderTarget: IPlatformRenderTarget;\n  /** @internal */\n  _colorTextures: RenderColorTexture[];\n  /** @internal */\n  _depth: RenderDepthTexture | RenderBufferDepthFormat | null;\n  /** @internal */\n  _antiAliasing: number;\n\n  private _width: number;\n  private _height: number;\n  private _depthTexture: RenderDepthTexture | null;\n\n  /**\n   * Render target width.\n   */\n  get width(): number {\n    return this._width;\n  }\n\n  /**\n   * Render target height.\n   */\n  get height(): number {\n    return this._height;\n  }\n\n  /**\n   * Render color texture count.\n   */\n  get colorTextureCount(): number {\n    return this._colorTextures.length;\n  }\n\n  /**\n   * Depth texture.\n   */\n  get depthTexture(): RenderDepthTexture | null {\n    return this._depthTexture;\n  }\n\n  /**\n   * Anti-aliasing level.\n   * @remarks If the anti-aliasing level set is greater than the maximum level supported by the hardware, the maximum level of the hardware will be used.\n   */\n  get antiAliasing(): number {\n    return this._antiAliasing;\n  }\n\n  /**\n   * Create a render target through color texture and depth format.\n   * @param engine - Define the engine to use for this off-screen rendering\n   * @param width - Render target width\n   * @param height - Render target height\n   * @param colorTexture - Render color texture\n   * @param depthFormat - Depth format. default RenderBufferDepthFormat.Depth, engine will automatically select the supported precision\n   * @param antiAliasing - Anti-aliasing level, default is 1\n   */\n  constructor(\n    engine: Engine,\n    width: number,\n    height: number,\n    colorTexture: RenderColorTexture,\n    depthFormat?: RenderBufferDepthFormat | null,\n    antiAliasing?: number\n  );\n\n  /**\n   * Create a render target through color texture and depth format.\n   * @remarks If the color texture is not transmitted, only the depth texture is generated.\n   * @param engine - Define the engine to use for this off-screen rendering\n   * @param width - Render target width\n   * @param height - Render target height\n   * @param colorTexture - Render color texture\n   * @param depthTexture - Render depth texture\n   * @param antiAliasing - Anti-aliasing level, default is 1\n   */\n  constructor(\n    engine: Engine,\n    width: number,\n    height: number,\n    colorTexture: RenderColorTexture | null,\n    depthTexture: RenderDepthTexture,\n    antiAliasing?: number\n  );\n\n  /**\n   * Create a render target with color texture array and depth format.\n   * @param engine - Define the engine to use for this off-screen rendering\n   * @param width - Render target width\n   * @param height - Render target height\n   * @param colorTextures - Render color texture array\n   * @param depthFormat - Depth format. default RenderBufferDepthFormat.Depth,engine will automatically select the supported precision\n   * @param antiAliasing - Anti-aliasing level, default is 1\n   */\n  constructor(\n    engine: Engine,\n    width: number,\n    height: number,\n    colorTextures: RenderColorTexture[],\n    depthFormat?: RenderBufferDepthFormat | null,\n    antiAliasing?: number\n  );\n\n  /**\n   * Create a render target with color texture array and depth texture.\n   * @param engine - Define the engine to use for this off-screen rendering\n   * @param width - Render target width\n   * @param height - Render target height\n   * @param colorTextures - Render color texture array\n   * @param depthTexture - Depth texture\n   * @param antiAliasing - Anti-aliasing level, default is 1\n   */\n  constructor(\n    engine: Engine,\n    width: number,\n    height: number,\n    colorTextures: RenderColorTexture[],\n    depthTexture: RenderDepthTexture,\n    antiAliasing?: number\n  );\n\n  /**\n   * @internal\n   */\n  constructor(\n    engine: Engine,\n    width: number,\n    height: number,\n    renderTexture: RenderColorTexture | Array<RenderColorTexture> | null,\n    depth: RenderDepthTexture | RenderBufferDepthFormat | null = RenderBufferDepthFormat.Depth,\n    antiAliasing: number = 1\n  ) {\n    super(engine);\n\n    this._width = width;\n    this._height = height;\n    this._antiAliasing = antiAliasing;\n    this._depth = depth;\n\n    if (renderTexture) {\n      this._colorTextures = renderTexture instanceof Array ? renderTexture.slice() : [renderTexture];\n    } else {\n      this._colorTextures = [];\n    }\n\n    if (depth instanceof RenderDepthTexture) {\n      this._depthTexture = depth;\n    }\n\n    this._platformRenderTarget = engine._hardwareRenderer.createPlatformRenderTarget(this);\n  }\n\n  /**\n   *\n   * Get the render color texture by index.\n   * @param index\n   */\n  getColorTexture(index: number = 0): RenderColorTexture | null {\n    return this._colorTextures[index];\n  }\n\n  /**\n   * Generate the mipmap of each attachment texture of the renderTarget according to the configuration.\n   */\n  generateMipmaps(): void {\n    const colorTextureCount = this.colorTextureCount;\n\n    if (this._depthTexture?.autoGenerateMipmaps) {\n      this._depthTexture.generateMipmaps();\n    }\n\n    for (let i = 0; i < colorTextureCount; i++) {\n      const colorTexture = this._colorTextures[i];\n      if (colorTexture.autoGenerateMipmaps) {\n        colorTexture.generateMipmaps();\n      }\n    }\n  }\n\n  /**\n   * Destroy render target.\n   */\n  destroy() {\n    this._platformRenderTarget.destroy();\n    this._colorTextures.length = 0;\n    this._depthTexture = null;\n    this._depth = null;\n  }\n\n  /**\n   * @internal\n   */\n  _setRenderTargetFace(faceIndex: TextureCubeFace): void {\n    this._platformRenderTarget.setRenderTargetFace(faceIndex);\n  }\n\n  /**\n   * @internal\n   */\n  _blitRenderTarget(): void {\n    this._platformRenderTarget.blitRenderTarget();\n  }\n}\n", "import { Engine } from \"../Engine\";\nimport { IPlatformRenderColorTexture } from \"../renderingHardwareInterface\";\nimport { RenderBufferColorFormat } from \"./enums/RenderBufferColorFormat\";\nimport { TextureCubeFace } from \"./enums/TextureCubeFace\";\nimport { TextureFilterMode } from \"./enums/TextureFilterMode\";\nimport { TextureWrapMode } from \"./enums/TextureWrapMode\";\nimport { Texture } from \"./Texture\";\n\n/**\n * The texture is used for the output of color information in off-screen rendering.\n */\nexport class RenderColorTexture extends Texture {\n  private _autoMipmap: boolean = false;\n  private _format: RenderBufferColorFormat;\n  private _isCube: boolean = false;\n\n  /**\n   * Texture format.\n   */\n  get format(): RenderBufferColorFormat {\n    return this._format;\n  }\n\n  /**\n   * Whether to render to a cube texture.\n   */\n  get isCube(): boolean {\n    return this._isCube;\n  }\n\n  /**\n   * Whether to automatically generate multi-level textures.\n   */\n  get autoGenerateMipmaps(): boolean {\n    return this._autoMipmap;\n  }\n\n  set autoGenerateMipmaps(value: boolean) {\n    this._autoMipmap = value;\n  }\n\n  /**\n   * Create RenderColorTexture.\n   * @param engine - Define the engine to use to render this color texture\n   * @param width - Texture width\n   * @param height - Texture height\n   * @param format - Texture format. default RenderBufferColorFormat.R8G8B8A8\n   * @param mipmap - Whether to use multi-level texture\n   * @param isCube - Whether it's cube texture\n   */\n  constructor(\n    engine: Engine,\n    width: number,\n    height: number,\n    format: RenderBufferColorFormat = RenderBufferColorFormat.R8G8B8A8,\n    mipmap: boolean = false,\n    isCube: boolean = false\n  ) {\n    super(engine);\n\n    this._isCube = isCube;\n    this._mipmap = mipmap;\n    this._width = width;\n    this._height = height;\n    this._format = format;\n    this._mipmapCount = this._getMipmapCount();\n\n    this._platformTexture = engine._hardwareRenderer.createPlatformRenderColorTexture(this);\n\n    this.filterMode = TextureFilterMode.Bilinear;\n    this.wrapModeU = this.wrapModeV = TextureWrapMode.Clamp;\n  }\n\n  /**\n   * Get the pixel color buffer according to the specified cube face and area.\n   * @param face - You can choose which cube face to read if it's cube texture\n   * @param x - X coordinate of area start\n   * @param y - Y coordinate of area start\n   * @param width - Area width\n   * @param height - Area height\n   * @param out - Color buffer\n   */\n  public getPixelBuffer(\n    face: TextureCubeFace | null,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    out: ArrayBufferView\n  ): void {\n    (this._platformTexture as IPlatformRenderColorTexture).getPixelBuffer(face, x, y, width, height, out);\n  }\n}\n", "import { Color, Vector2, Vector3, Vector4 } from \"@oasis-engine/math\";\nimport { Mesh } from \"../graphic/Mesh\";\nimport { Buffer } from \"../graphic/Buffer\";\nimport { Engine } from \"../Engine\";\nimport { IndexFormat } from \"../graphic/enums/IndexFormat\";\nimport { VertexElementFormat } from \"../graphic/enums/VertexElementFormat\";\nimport { VertexElement } from \"../graphic/VertexElement\";\nimport { BufferUsage } from \"../graphic/enums/BufferUsage\";\nimport { BufferBindFlag } from \"../graphic/enums/BufferBindFlag\";\nimport { VertexBufferBinding } from \"../graphic/VertexBufferBinding\";\nimport { IndexBufferBinding } from \"../graphic\";\nimport { BlendShape } from \"./BlendShape\";\nimport { UpdateFlag } from \"../UpdateFlag\";\nimport { Texture2D } from \"../texture/Texture2D\";\nimport { TextureFilterMode, TextureFormat } from \"../texture\";\n\n/**\n * Mesh containing common vertex elements of the model.\n */\nexport class ModelMesh extends Mesh {\n  /** @internal */\n  _hasBlendShape: boolean = false;\n  /** @internal */\n  _useBlendShapeNormal: boolean = false;\n  /** @internal */\n  _useBlendShapeTangent: boolean = false;\n  /** @internal */\n  _blendShapeTexture: Texture2D;\n\n  private _vertexCount: number = 0;\n  private _accessible: boolean = true;\n  private _verticesFloat32: Float32Array | null = null;\n  private _verticesUint8: Uint8Array | null = null;\n  private _indices: Uint8Array | Uint16Array | Uint32Array | null = null;\n  private _indicesFormat: IndexFormat = null;\n  private _vertexSlotChanged: boolean = true;\n  private _vertexChangeFlag: number = 0;\n  private _indicesChangeFlag: boolean = false;\n  private _elementCount: number = 0;\n  private _vertexElementsCache: VertexElement[] = [];\n\n  private _positions: Vector3[] = [];\n  private _normals: Vector3[] | null = null;\n  private _colors: Color[] | null = null;\n  private _tangents: Vector4[] | null = null;\n  private _uv: Vector2[] | null = null;\n  private _uv1: Vector2[] | null = null;\n  private _uv2: Vector2[] | null = null;\n  private _uv3: Vector2[] | null = null;\n  private _uv4: Vector2[] | null = null;\n  private _uv5: Vector2[] | null = null;\n  private _uv6: Vector2[] | null = null;\n  private _uv7: Vector2[] | null = null;\n  private _boneWeights: Vector4[] | null = null;\n  private _boneIndices: Vector4[] | null = null;\n  private _blendShapes: BlendShape[] = [];\n  private _blendShapeUpdateFlags: UpdateFlag[] = [];\n\n  /**\n   * Whether to access data of the mesh.\n   */\n  get accessible(): boolean {\n    return this._accessible;\n  }\n\n  /**\n   * Vertex count of current mesh.\n   */\n  get vertexCount(): number {\n    return this._vertexCount;\n  }\n\n  /**\n   * BlendShape count of this ModelMesh.\n   */\n  get blendShapes(): Readonly<BlendShape[]> {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n    return this._blendShapes;\n  }\n\n  /**\n   * Create a model mesh.\n   * @param engine - Engine to which the mesh belongs\n   * @param name - Mesh name\n   */\n  constructor(engine: Engine, name?: string) {\n    super(engine);\n    this.name = name;\n  }\n\n  /**\n   * Set positions for the mesh.\n   * @param positions - The positions for the mesh.\n   */\n  setPositions(positions: Vector3[]): void {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n\n    const count = positions.length;\n    this._positions = positions;\n    this._vertexChangeFlag |= ValueChanged.Position;\n\n    if (this._vertexCount !== count) {\n      this._vertexCount = count;\n    }\n  }\n\n  /**\n   * Get positions for the mesh.\n   * @remarks Please call the setPositions() method after modification to ensure that the modification takes effect.\n   */\n  getPositions(): Vector3[] | null {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n\n    return this._positions;\n  }\n\n  /**\n   * Set per-vertex normals for the mesh.\n   * @param normals - The normals for the mesh.\n   */\n  setNormals(normals: Vector3[] | null): void {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n\n    if (normals.length !== this._vertexCount) {\n      throw \"The array provided needs to be the same size as vertex count.\";\n    }\n\n    this._vertexSlotChanged = !!this._normals !== !!normals;\n    this._vertexChangeFlag |= ValueChanged.Normal;\n    this._normals = normals;\n  }\n\n  /**\n   * Get normals for the mesh.\n   * @remarks Please call the setNormals() method after modification to ensure that the modification takes effect.\n   */\n  getNormals(): Vector3[] | null {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n    return this._normals;\n  }\n\n  /**\n   * Set per-vertex colors for the mesh.\n   * @param colors - The colors for the mesh.\n   */\n  setColors(colors: Color[] | null): void {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n\n    if (colors.length !== this._vertexCount) {\n      throw \"The array provided needs to be the same size as vertex count.\";\n    }\n\n    this._vertexSlotChanged = !!this._colors !== !!colors;\n    this._vertexChangeFlag |= ValueChanged.Color;\n    this._colors = colors;\n  }\n\n  /**\n   * Get colors for the mesh.\n   * @remarks Please call the setColors() method after modification to ensure that the modification takes effect.\n   */\n  getColors(): Color[] | null {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n    return this._colors;\n  }\n\n  /**\n   * Set per-vertex bone weights for the mesh.\n   * @param boneWeights - The bone weights for the mesh.\n   */\n  setBoneWeights(boneWeights: Vector4[] | null): void {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n\n    if (boneWeights.length !== this._vertexCount) {\n      throw \"The array provided needs to be the same size as vertex count.\";\n    }\n\n    this._vertexSlotChanged = boneWeights != null;\n    this._vertexChangeFlag |= ValueChanged.BoneWeight;\n    this._boneWeights = boneWeights;\n  }\n\n  /**\n   * Get weights for the mesh.\n   * @remarks Please call the setWeights() method after modification to ensure that the modification takes effect.\n   */\n  getBoneWeights(): Vector4[] | null {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n    return this._boneWeights;\n  }\n\n  /**\n   * Set per-vertex bone indices for the mesh.\n   * @param boneIndices - The bone indices for the mesh.\n   */\n  setBoneIndices(boneIndices: Vector4[] | null): void {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n\n    if (boneIndices.length !== this._vertexCount) {\n      throw \"The array provided needs to be the same size as vertex count.\";\n    }\n\n    this._vertexSlotChanged = !!this._boneIndices !== !!boneIndices;\n    this._vertexChangeFlag |= ValueChanged.BoneIndex;\n    this._boneIndices = boneIndices;\n  }\n\n  /**\n   * Get joints for the mesh.\n   * @remarks Please call the setBoneIndices() method after modification to ensure that the modification takes effect.\n   */\n  getBoneIndices(): Vector4[] | null {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n    return this._boneIndices;\n  }\n\n  /**\n   * Set per-vertex tangents for the mesh.\n   * @param tangents - The tangents for the mesh.\n   */\n  setTangents(tangents: Vector4[] | null): void {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n\n    if (tangents.length !== this._vertexCount) {\n      throw \"The array provided needs to be the same size as vertex count.\";\n    }\n\n    this._vertexSlotChanged = !!this._tangents !== !!tangents;\n    this._vertexChangeFlag |= ValueChanged.Tangent;\n    this._tangents = tangents;\n  }\n\n  /**\n   * Get tangents for the mesh.\n   * @remarks Please call the setTangents() method after modification to ensure that the modification takes effect.\n   */\n  getTangents(): Vector4[] | null {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n    return this._tangents;\n  }\n\n  /**\n   * Set per-vertex uv for the mesh.\n   * @param uv - The uv for the mesh.\n   */\n  setUVs(uv: Vector2[] | null): void;\n  /**\n   * Set per-vertex uv for the mesh by channelIndex.\n   * @param uv - The uv for the mesh.\n   * @param channelIndex - The index of uv channels, in [0 ~ 7] range.\n   */\n  setUVs(uv: Vector2[] | null, channelIndex: number): void;\n  setUVs(uv: Vector2[] | null, channelIndex?: number): void {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n\n    if (uv.length !== this._vertexCount) {\n      throw \"The array provided needs to be the same size as vertex count.\";\n    }\n\n    channelIndex = channelIndex ?? 0;\n    switch (channelIndex) {\n      case 0:\n        this._vertexSlotChanged = !!this._uv !== !!uv;\n        this._vertexChangeFlag |= ValueChanged.UV;\n        this._uv = uv;\n        break;\n      case 1:\n        this._vertexSlotChanged = !!this._uv1 !== !!uv;\n        this._vertexChangeFlag |= ValueChanged.UV1;\n        this._uv1 = uv;\n        break;\n      case 2:\n        this._vertexSlotChanged = !!this._uv2 !== !!uv;\n        this._vertexChangeFlag |= ValueChanged.UV2;\n        this._uv2 = uv;\n        break;\n      case 3:\n        this._vertexSlotChanged = !!this._uv3 !== !!uv;\n        this._vertexChangeFlag |= ValueChanged.UV3;\n        this._uv3 = uv;\n        break;\n      case 4:\n        this._vertexSlotChanged = !!this._uv4 !== !!uv;\n        this._vertexChangeFlag |= ValueChanged.UV4;\n        this._uv4 = uv;\n        break;\n      case 5:\n        this._vertexSlotChanged = !!this._uv5 !== !!uv;\n        this._vertexChangeFlag |= ValueChanged.UV5;\n        this._uv5 = uv;\n        break;\n      case 6:\n        this._vertexSlotChanged = !!this._uv6 !== !!uv;\n        this._vertexChangeFlag |= ValueChanged.UV6;\n        this._uv6 = uv;\n        break;\n      case 7:\n        this._vertexSlotChanged = !!this._uv7 !== !!uv;\n        this._vertexChangeFlag |= ValueChanged.UV7;\n        this._uv7 = uv;\n        break;\n      default:\n        throw \"The index of channel needs to be in range [0 - 7].\";\n    }\n  }\n\n  /**\n   * Get uv for the mesh.\n   * @remarks Please call the setUV() method after modification to ensure that the modification takes effect.\n   */\n  getUVs(): Vector2[] | null;\n  /**\n   * Get uv for the mesh by channelIndex.\n   * @param channelIndex - The index of uv channels, in [0 ~ 7] range.\n   * @remarks Please call the setUV() method after modification to ensure that the modification takes effect.\n   */\n  getUVs(channelIndex: number): Vector2[] | null;\n  getUVs(channelIndex?: number): Vector2[] | null {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n    channelIndex = channelIndex ?? 0;\n    switch (channelIndex) {\n      case 0:\n        return this._uv;\n      case 1:\n        return this._uv1;\n      case 2:\n        return this._uv2;\n      case 3:\n        return this._uv3;\n      case 4:\n        return this._uv4;\n      case 5:\n        return this._uv5;\n      case 6:\n        return this._uv6;\n      case 7:\n        return this._uv7;\n    }\n    throw \"The index of channel needs to be in range [0 - 7].\";\n  }\n\n  /**\n   * Set indices for the mesh.\n   * @param indices - The indices for the mesh.\n   */\n  setIndices(indices: Uint8Array | Uint16Array | Uint32Array): void {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n\n    if (this._indices !== indices) {\n      this._indices = indices;\n      if (indices instanceof Uint8Array) {\n        this._indicesFormat = IndexFormat.UInt8;\n      } else if (indices instanceof Uint16Array) {\n        this._indicesFormat = IndexFormat.UInt16;\n      } else if (indices instanceof Uint32Array) {\n        this._indicesFormat = IndexFormat.UInt32;\n      }\n    }\n\n    this._indicesChangeFlag = true;\n  }\n\n  /**\n   * Get indices for the mesh.\n   */\n  getIndices(): Uint8Array | Uint16Array | Uint32Array {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n    return this._indices;\n  }\n\n  /**\n   * Add a BlendShape for this ModelMesh.\n   * @param blendShape - The BlendShape\n   */\n  addBlendShape(blendShape: BlendShape): void {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n\n    this._vertexChangeFlag |= ValueChanged.BlendShape;\n    this._useBlendShapeNormal = this._useBlendShapeNormal || blendShape._useBlendShapeNormal;\n    this._useBlendShapeTangent = this._useBlendShapeTangent || blendShape._useBlendShapeTangent;\n    this._blendShapes.push(blendShape);\n    this._blendShapeUpdateFlags.push(blendShape._registerChangeFlag());\n    this._hasBlendShape = true;\n  }\n\n  /**\n   * Clear all BlendShapes.\n   */\n  clearBlendShapes(): void {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n    this._vertexChangeFlag |= ValueChanged.BlendShape;\n    this._useBlendShapeNormal = false;\n    this._useBlendShapeTangent = false;\n    this._blendShapes.length = 0;\n    const blendShapeUpdateFlags = this._blendShapeUpdateFlags;\n    for (let i = 0, n = blendShapeUpdateFlags.length; i < n; i++) {\n      blendShapeUpdateFlags[i].destroy();\n    }\n    blendShapeUpdateFlags.length = 0;\n    this._hasBlendShape = false;\n  }\n\n  /**\n   * Upload Mesh Data to the graphics API.\n   * @param noLongerAccessible - Whether to access data later. If true, you'll never access data anymore (free memory cache)\n   */\n  uploadData(noLongerAccessible: boolean): void {\n    if (!this._accessible) {\n      throw \"Not allowed to access data while accessible is false.\";\n    }\n\n    const { _indices } = this;\n\n    // Vertex element change.\n    if (this._vertexSlotChanged) {\n      const vertexElements = this._updateVertexElements();\n      this._setVertexElements(vertexElements);\n      this._vertexChangeFlag = ValueChanged.All;\n      this._vertexSlotChanged = false;\n    }\n\n    // Vertex value change.\n    const vertexBufferBindings = this._vertexBufferBindings;\n    const elementCount = this._elementCount;\n    const vertexBuffer = vertexBufferBindings[0]?._buffer;\n    const vertexFloatCount = elementCount * this._vertexCount;\n    if (!vertexBuffer || this._verticesFloat32.length !== vertexFloatCount) {\n      vertexBuffer?.destroy();\n      const vertices = new Float32Array(vertexFloatCount);\n      this._verticesFloat32 = vertices;\n      this._verticesUint8 = new Uint8Array(vertices.buffer);\n\n      this._vertexChangeFlag = ValueChanged.All;\n      this._updateVertices(vertices);\n\n      const newVertexBuffer = new Buffer(\n        this._engine,\n        BufferBindFlag.VertexBuffer,\n        vertices,\n        noLongerAccessible ? BufferUsage.Static : BufferUsage.Dynamic\n      );\n\n      this._setVertexBufferBinding(0, new VertexBufferBinding(newVertexBuffer, elementCount * 4));\n    } else if (this._vertexChangeFlag & ValueChanged.All) {\n      const vertices = this._verticesFloat32;\n      this._updateVertices(vertices);\n      vertexBuffer.setData(vertices);\n    }\n\n    const indexBuffer = this._indexBufferBinding?._buffer;\n    if (_indices) {\n      if (!indexBuffer || _indices.byteLength != indexBuffer.byteLength) {\n        indexBuffer?.destroy();\n        const newIndexBuffer = new Buffer(this._engine, BufferBindFlag.IndexBuffer, _indices);\n        this._setIndexBufferBinding(new IndexBufferBinding(newIndexBuffer, this._indicesFormat));\n      } else if (this._indicesChangeFlag) {\n        this._indicesChangeFlag = false;\n        indexBuffer.setData(_indices);\n        if (this._indexBufferBinding._format !== this._indicesFormat) {\n          this._setIndexBufferBinding(new IndexBufferBinding(indexBuffer, this._indicesFormat));\n        }\n      }\n    } else if (indexBuffer) {\n      indexBuffer.destroy();\n      this._setIndexBufferBinding(null);\n    }\n\n    if (noLongerAccessible) {\n      this._accessible = false;\n      this._releaseCache();\n    }\n  }\n\n  /**\n   * @override\n   * @internal\n   */\n  _onDestroy(): void {\n    super._onDestroy();\n    this._accessible && this._releaseCache();\n  }\n\n  private _updateVertexElements(): VertexElement[] {\n    const vertexElements = this._vertexElementsCache;\n    vertexElements.length = 1;\n    vertexElements[0] = POSITION_VERTEX_ELEMENT;\n\n    let offset = 12;\n    let elementCount = 3;\n    if (this._normals) {\n      vertexElements.push(new VertexElement(\"NORMAL\", offset, VertexElementFormat.Vector3, 0));\n      offset += 12;\n      elementCount += 3;\n    }\n    if (this._colors) {\n      vertexElements.push(new VertexElement(\"COLOR_0\", offset, VertexElementFormat.Vector4, 0));\n      offset += 16;\n      elementCount += 4;\n    }\n    if (this._boneWeights) {\n      vertexElements.push(new VertexElement(\"WEIGHTS_0\", offset, VertexElementFormat.Vector4, 0));\n      offset += 16;\n      elementCount += 4;\n    }\n    if (this._boneIndices) {\n      vertexElements.push(new VertexElement(\"JOINTS_0\", offset, VertexElementFormat.UByte4, 0));\n      offset += 4;\n      elementCount += 1;\n    }\n    if (this._tangents) {\n      vertexElements.push(new VertexElement(\"TANGENT\", offset, VertexElementFormat.Vector4, 0));\n      offset += 16;\n      elementCount += 4;\n    }\n    if (this._uv) {\n      vertexElements.push(new VertexElement(\"TEXCOORD_0\", offset, VertexElementFormat.Vector2, 0));\n      offset += 8;\n      elementCount += 2;\n    }\n    if (this._uv1) {\n      vertexElements.push(new VertexElement(\"TEXCOORD_1\", offset, VertexElementFormat.Vector2, 0));\n      offset += 8;\n      elementCount += 2;\n    }\n    if (this._uv2) {\n      vertexElements.push(new VertexElement(\"TEXCOORD_2\", offset, VertexElementFormat.Vector2, 0));\n      offset += 8;\n      elementCount += 2;\n    }\n    if (this._uv3) {\n      vertexElements.push(new VertexElement(\"TEXCOORD_3\", offset, VertexElementFormat.Vector2, 0));\n      offset += 8;\n      elementCount += 2;\n    }\n    if (this._uv4) {\n      vertexElements.push(new VertexElement(\"TEXCOORD_4\", offset, VertexElementFormat.Vector2, 0));\n      offset += 8;\n      elementCount += 2;\n    }\n    if (this._uv5) {\n      vertexElements.push(new VertexElement(\"TEXCOORD_5\", offset, VertexElementFormat.Vector2, 0));\n      offset += 8;\n      elementCount += 2;\n    }\n    if (this._uv6) {\n      vertexElements.push(new VertexElement(\"TEXCOORD_6\", offset, VertexElementFormat.Vector2, 0));\n      offset += 8;\n      elementCount += 2;\n    }\n    if (this._uv7) {\n      vertexElements.push(new VertexElement(\"TEXCOORD_7\", offset, VertexElementFormat.Vector2, 0));\n      offset += 8;\n      elementCount += 2;\n    }\n\n    const blendShapeCount = Math.min(this._blendShapes.length, 4);\n    for (let i = 0, n = blendShapeCount; i < n; i++) {\n      vertexElements.push(new VertexElement(`POSITION_BS${i}`, offset, VertexElementFormat.Vector3, 0));\n      offset += 12;\n      elementCount += 3;\n      if (this._useBlendShapeNormal) {\n        vertexElements.push(new VertexElement(`NORMAL_BS${i}`, offset, VertexElementFormat.Vector3, 0));\n        offset += 12;\n        elementCount += 3;\n      }\n      if (this._useBlendShapeTangent) {\n        vertexElements.push(new VertexElement(`TANGENT_BS${i}`, offset, VertexElementFormat.Vector3, 0));\n        offset += 12;\n        elementCount += 3;\n      }\n    }\n\n    this._elementCount = elementCount;\n    return vertexElements;\n  }\n\n  private _updateVertices(vertices: Float32Array): void {\n    // prettier-ignore\n    const { _elementCount,_vertexCount, _positions, _normals, _colors, _vertexChangeFlag, _boneWeights, _boneIndices, _tangents, _uv, _uv1, _uv2, _uv3, _uv4, _uv5, _uv6, _uv7 } = this;\n\n    if (_vertexChangeFlag & ValueChanged.Position) {\n      for (let i = 0; i < _vertexCount; i++) {\n        const start = _elementCount * i;\n        const position = _positions[i];\n        vertices[start] = position.x;\n        vertices[start + 1] = position.y;\n        vertices[start + 2] = position.z;\n      }\n    }\n\n    let offset = 3;\n\n    if (_normals) {\n      if (_vertexChangeFlag & ValueChanged.Normal) {\n        for (let i = 0; i < _vertexCount; i++) {\n          const start = _elementCount * i + offset;\n          const normal = _normals[i];\n          if (normal) {\n            vertices[start] = normal.x;\n            vertices[start + 1] = normal.y;\n            vertices[start + 2] = normal.z;\n          }\n        }\n      }\n      offset += 3;\n    }\n\n    if (_colors) {\n      if (_vertexChangeFlag & ValueChanged.Color) {\n        for (let i = 0; i < _vertexCount; i++) {\n          const start = _elementCount * i + offset;\n          const color = _colors[i];\n          if (color) {\n            vertices[start] = color.r;\n            vertices[start + 1] = color.g;\n            vertices[start + 2] = color.b;\n            vertices[start + 3] = color.a;\n          }\n        }\n      }\n      offset += 4;\n    }\n\n    if (_boneWeights) {\n      if (_vertexChangeFlag & ValueChanged.BoneWeight) {\n        for (let i = 0; i < _vertexCount; i++) {\n          const start = _elementCount * i + offset;\n          const weight = _boneWeights[i];\n          if (weight) {\n            vertices[start] = weight.x;\n            vertices[start + 1] = weight.y;\n            vertices[start + 2] = weight.z;\n            vertices[start + 3] = weight.w;\n          }\n        }\n      }\n      offset += 4;\n    }\n\n    if (_boneIndices) {\n      if (_vertexChangeFlag & ValueChanged.BoneIndex) {\n        const { _verticesUint8 } = this;\n        for (let i = 0; i < _vertexCount; i++) {\n          const start = _elementCount * i + offset;\n          const joint = _boneIndices[i];\n          if (joint) {\n            const internalStart = start * 4;\n            _verticesUint8[internalStart] = joint.x;\n            _verticesUint8[internalStart + 1] = joint.y;\n            _verticesUint8[internalStart + 2] = joint.z;\n            _verticesUint8[internalStart + 3] = joint.w;\n          }\n        }\n      }\n      offset += 1;\n    }\n\n    if (_tangents) {\n      if (_vertexChangeFlag & ValueChanged.Tangent) {\n        for (let i = 0; i < _vertexCount; i++) {\n          const start = _elementCount * i + offset;\n          const tangent = _tangents[i];\n          if (tangent) {\n            vertices[start] = tangent.x;\n            vertices[start + 1] = tangent.y;\n            vertices[start + 2] = tangent.z;\n          }\n        }\n      }\n      offset += 4;\n    }\n    if (_uv) {\n      if (_vertexChangeFlag & ValueChanged.UV) {\n        for (let i = 0; i < _vertexCount; i++) {\n          const start = _elementCount * i + offset;\n          const uv = _uv[i];\n          if (uv) {\n            vertices[start] = uv.x;\n            vertices[start + 1] = uv.y;\n          }\n        }\n      }\n      offset += 2;\n    }\n    if (_uv1) {\n      if (_vertexChangeFlag & ValueChanged.UV1) {\n        for (let i = 0; i < _vertexCount; i++) {\n          const start = _elementCount * i + offset;\n          const uv = _uv1[i];\n          if (uv) {\n            vertices[start] = uv.x;\n            vertices[start + 1] = uv.y;\n          }\n        }\n      }\n      offset += 2;\n    }\n    if (_uv2) {\n      if (_vertexChangeFlag & ValueChanged.UV2) {\n        for (let i = 0; i < _vertexCount; i++) {\n          const start = _elementCount * i + offset;\n          const uv = _uv2[i];\n          if (uv) {\n            vertices[start] = uv.x;\n            vertices[start + 1] = uv.y;\n          }\n        }\n      }\n      offset += 2;\n    }\n    if (_uv3) {\n      if (_vertexChangeFlag & ValueChanged.UV3) {\n        for (let i = 0; i < _vertexCount; i++) {\n          const start = _elementCount * i + offset;\n          const uv = _uv3[i];\n          if (uv) {\n            vertices[start] = uv.x;\n            vertices[start + 1] = uv.y;\n          }\n        }\n      }\n      offset += 2;\n    }\n    if (_uv4) {\n      if (_vertexChangeFlag & ValueChanged.UV4) {\n        for (let i = 0; i < _vertexCount; i++) {\n          const start = _elementCount * i + offset;\n          const uv = _uv4[i];\n          if (uv) {\n            vertices[start] = uv.x;\n            vertices[start + 1] = uv.y;\n          }\n        }\n      }\n      offset += 2;\n    }\n    if (_uv5) {\n      if (_vertexChangeFlag & ValueChanged.UV5) {\n        for (let i = 0; i < _vertexCount; i++) {\n          const start = _elementCount * i + offset;\n          const uv = _uv5[i];\n          if (uv) {\n            vertices[start] = uv.x;\n            vertices[start + 1] = uv.y;\n          }\n        }\n      }\n      offset += 2;\n    }\n    if (_uv6) {\n      if (_vertexChangeFlag & ValueChanged.UV6) {\n        for (let i = 0; i < _vertexCount; i++) {\n          const start = _elementCount * i + offset;\n          const uv = _uv6[i];\n          if (uv) {\n            vertices[start] = uv.x;\n            vertices[start + 1] = uv.y;\n          }\n        }\n      }\n      offset += 2;\n    }\n    if (_uv7) {\n      if (_vertexChangeFlag & ValueChanged.UV7) {\n        for (let i = 0; i < _vertexCount; i++) {\n          const start = _elementCount * i + offset;\n          const uv = _uv7[i];\n          if (uv) {\n            vertices[start] = uv.x;\n            vertices[start + 1] = uv.y;\n          }\n        }\n      }\n      offset += 2;\n    }\n\n    // BlendShape.\n    if (_vertexChangeFlag & ValueChanged.BlendShape) {\n      const blendShapes = this._blendShapes;\n      const blendShapeUpdateFlags = this._blendShapeUpdateFlags;\n      const blendShapeCount = Math.min(blendShapes.length, 4);\n\n      const rhi = this.engine._hardwareRenderer;\n      if (/*rhi.canUseFloatTextureBlendShape*/ false) {\n        let stride = 1;\n        this._useBlendShapeNormal && stride++;\n        this._useBlendShapeTangent && stride++;\n\n        const maxTextureSize = rhi.renderStates.getParameter(rhi.gl.MAX_TEXTURE_SIZE);\n        const pixelCount = this._vertexCount * stride;\n        const height = Math.ceil(pixelCount / maxTextureSize);\n        const width = height > 1 ? maxTextureSize : pixelCount;\n\n        this._blendShapeTexture = new Texture2D(this.engine, 0, 0, TextureFormat.R32G32B32A32, false);\n        this._blendShapeTexture.filterMode = TextureFilterMode.Point;\n      } else {\n        for (let i = 0; i < blendShapeCount; i++) {\n          const blendShapeUpdateFlag = blendShapeUpdateFlags[i];\n          if (blendShapeUpdateFlag.flag) {\n            const blendShape = blendShapes[i];\n            const { frames } = blendShape;\n            const frameCount = frames.length;\n            const endFrame = frames[frameCount - 1];\n            if (frameCount > 0 && endFrame.deltaPositions.length !== this._vertexCount) {\n              throw \"BlendShape frame deltaPositions length must same with mesh vertexCount.\";\n            }\n\n            const { deltaPositions } = endFrame;\n            for (let j = 0; j < _vertexCount; j++) {\n              const start = _elementCount * j + offset;\n              const deltaPosition = deltaPositions[j];\n              if (deltaPosition) {\n                vertices[start] = deltaPosition.x;\n                vertices[start + 1] = deltaPosition.y;\n                vertices[start + 2] = deltaPosition.z;\n              }\n            }\n            offset += 3;\n\n            if (this._useBlendShapeNormal) {\n              const { deltaNormals } = endFrame;\n              if (deltaNormals) {\n                for (let j = 0; j < _vertexCount; j++) {\n                  const start = _elementCount * j + offset;\n                  const deltaNormal = deltaNormals[j];\n                  if (deltaNormal) {\n                    vertices[start] = deltaNormal.x;\n                    vertices[start + 1] = deltaNormal.y;\n                    vertices[start + 2] = deltaNormal.z;\n                  }\n                }\n              }\n              offset += 3;\n            }\n\n            if (this._useBlendShapeTangent) {\n              const { deltaTangents } = endFrame;\n              if (deltaTangents) {\n                for (let j = 0; j < _vertexCount; j++) {\n                  const start = _elementCount * j + offset;\n                  const deltaTangent = deltaTangents[j];\n                  if (deltaTangent) {\n                    vertices[start] = deltaTangent.x;\n                    vertices[start + 1] = deltaTangent.y;\n                    vertices[start + 2] = deltaTangent.z;\n                  }\n                }\n              }\n              offset += 3;\n            }\n            blendShapeUpdateFlag.flag = false;\n          }\n        }\n      }\n    }\n\n    this._vertexChangeFlag = 0;\n  }\n\n  private _releaseCache(): void {\n    const blendShapeUpdateFlags = this._blendShapeUpdateFlags;\n    for (let i = 0, n = blendShapeUpdateFlags.length; i < n; i++) {\n      blendShapeUpdateFlags[i].destroy();\n    }\n\n    this._verticesUint8 = null;\n    this._indices = null;\n    this._verticesFloat32 = null;\n    this._positions.length = 0;\n    this._tangents = null;\n    this._normals = null;\n    this._colors = null;\n    this._uv = null;\n    this._uv1 = null;\n    this._uv2 = null;\n    this._uv3 = null;\n    this._uv4 = null;\n    this._uv5 = null;\n    this._uv6 = null;\n    this._uv7 = null;\n    this._blendShapes = null;\n    this._blendShapeUpdateFlags = null;\n  }\n}\n\nconst POSITION_VERTEX_ELEMENT = new VertexElement(\"POSITION\", 0, VertexElementFormat.Vector3, 0);\n\nenum ValueChanged {\n  Position = 0x1,\n  Normal = 0x2,\n  Color = 0x4,\n  Tangent = 0x8,\n  BoneWeight = 0x10,\n  BoneIndex = 0x20,\n  UV = 0x40,\n  UV1 = 0x80,\n  UV2 = 0x100,\n  UV3 = 0x200,\n  UV4 = 0x400,\n  UV5 = 0x800,\n  UV6 = 0x1000,\n  UV7 = 0x2000,\n  BlendShape = 0x4000,\n  All = 0xffff\n}\n", "import { Matrix } from \"@oasis-engine/math\";\nimport { EngineObject } from \"../base/EngineObject\";\nimport { Entity } from \"../Entity\";\n\n/**\n * Mesh skin data, equal glTF skins define\n */\nexport class Skin extends EngineObject {\n  public inverseBindMatrices: Matrix[];\n  public joints: string[];\n  public skeleton: string;\n  /**\n   * Constructor of skin\n   * @param name - name\n   */\n  constructor(public name: string) {\n    super(null);\n    this.inverseBindMatrices = []; // inverse bind matrix array\n    this.joints = []; // joints name array, element type: string\n    this.skeleton = \"none\"; // root bone name\n  }\n}\n", "import { BoundingBox } from \"@oasis-engine/math\";\nimport { Logger } from \"../base/Logger\";\nimport { Camera } from \"../Camera\";\nimport { ignoreClone } from \"../clone/CloneManager\";\nimport { ICustomClone } from \"../clone/ComponentCloner\";\nimport { Entity } from \"../Entity\";\nimport { VertexElementFormat } from \"../graphic/enums/VertexElementFormat\";\nimport { Mesh } from \"../graphic/Mesh\";\nimport { Renderer } from \"../Renderer\";\nimport { Shader } from \"../shader/Shader\";\nimport { UpdateFlag } from \"../UpdateFlag\";\n\n/**\n * MeshRenderer Component.\n */\nexport class MeshRenderer extends Renderer implements ICustomClone {\n  private static _uvMacro = Shader.getMacroByName(\"O3_HAS_UV\");\n  private static _normalMacro = Shader.getMacroByName(\"O3_HAS_NORMAL\");\n  private static _tangentMacro = Shader.getMacroByName(\"O3_HAS_TANGENT\");\n  private static _vertexColorMacro = Shader.getMacroByName(\"O3_HAS_VERTEXCOLOR\");\n\n  @ignoreClone\n  private _mesh: Mesh;\n  @ignoreClone\n  private _meshUpdateFlag: UpdateFlag;\n\n  /**\n   * @internal\n   */\n  constructor(entity: Entity) {\n    super(entity);\n  }\n\n  /**\n   * Mesh assigned to the renderer.\n   */\n  get mesh() {\n    return this._mesh;\n  }\n\n  set mesh(mesh: Mesh) {\n    const lastMesh = this._mesh;\n    if (lastMesh !== mesh) {\n      if (lastMesh) {\n        lastMesh._addRefCount(-1);\n        this._meshUpdateFlag.destroy();\n      }\n      if (mesh) {\n        mesh._addRefCount(1);\n        this._meshUpdateFlag = mesh.registerUpdateFlag();\n      }\n      this._mesh = mesh;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _render(camera: Camera): void {\n    const mesh = this._mesh;\n    if (mesh) {\n      if (this._meshUpdateFlag.flag) {\n        const shaderData = this.shaderData;\n        const vertexElements = mesh._vertexElements;\n\n        shaderData.disableMacro(MeshRenderer._uvMacro);\n        shaderData.disableMacro(MeshRenderer._normalMacro);\n        shaderData.disableMacro(MeshRenderer._tangentMacro);\n        shaderData.disableMacro(MeshRenderer._vertexColorMacro);\n\n        for (let i = 0, n = vertexElements.length; i < n; i++) {\n          const { semantic } = vertexElements[i];\n          switch (semantic) {\n            case \"TEXCOORD_0\":\n              shaderData.enableMacro(MeshRenderer._uvMacro);\n              break;\n            case \"NORMAL\":\n              shaderData.enableMacro(MeshRenderer._normalMacro);\n              break;\n            case \"TANGENT\":\n              shaderData.enableMacro(MeshRenderer._tangentMacro);\n              break;\n            case \"COLOR_0\":\n              shaderData.enableMacro(MeshRenderer._vertexColorMacro);\n              break;\n          }\n        }\n        this._meshUpdateFlag.flag = false;\n      }\n\n      const subMeshes = mesh.subMeshes;\n      const renderPipeline = camera._renderPipeline;\n      const renderElementPool = this._engine._renderElementPool;\n      for (let i = 0, n = subMeshes.length; i < n; i++) {\n        const material = this._materials[i];\n        if (material) {\n          const element = renderElementPool.getFromPool();\n          element.setValue(this, mesh, subMeshes[i], material);\n          renderPipeline.pushPrimitive(element);\n        }\n      }\n    } else {\n      Logger.error(\"mesh is null.\");\n    }\n  }\n\n  /**\n   * @internal\n   * @override\n   */\n  _onDestroy() {\n    super._onDestroy();\n    const mesh = this._mesh;\n    if (mesh && !mesh.destroyed) {\n      mesh._addRefCount(-1);\n      this._mesh = null;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _cloneTo(target: MeshRenderer): void {\n    target.mesh = this._mesh;\n  }\n\n  /**\n   * @override\n   */\n  protected _updateBounds(worldBounds: BoundingBox): void {\n    const mesh = this._mesh;\n    if (mesh) {\n      const localBounds = mesh.bounds;\n      const worldMatrix = this._entity.transform.worldMatrix;\n      BoundingBox.transform(localBounds, worldMatrix, worldBounds);\n    } else {\n      worldBounds.min.setValue(0, 0, 0);\n      worldBounds.max.setValue(0, 0, 0);\n    }\n  }\n}\n", "import { Matrix } from \"@oasis-engine/math\";\nimport { Logger } from \"../base/Logger\";\nimport { ignoreClone } from \"../clone/CloneManager\";\nimport { Entity } from \"../Entity\";\nimport { RenderContext } from \"../RenderPipeline/RenderContext\";\nimport { Shader } from \"../shader\";\nimport { TextureFilterMode } from \"../texture/enums/TextureFilterMode\";\nimport { TextureFormat } from \"../texture/enums/TextureFormat\";\nimport { Texture2D } from \"../texture/Texture2D\";\nimport { MeshRenderer } from \"./MeshRenderer\";\nimport { ModelMesh } from \"./ModelMesh\";\nimport { Skin } from \"./Skin\";\n\n/**\n * SkinnedMeshRenderer.\n */\nexport class SkinnedMeshRenderer extends MeshRenderer {\n  private static _blendShapeMacro = Shader.getMacroByName(\"OASIS_BLENDSHAPE\");\n  private static _blendShapeNormalMacro = Shader.getMacroByName(\"OASIS_BLENDSHAPE_NORMAL\");\n  private static _blendShapeTangentMacro = Shader.getMacroByName(\"OASIS_BLENDSHAPE_TANGENT\");\n\n  private static _jointCountProperty = Shader.getPropertyByName(\"u_jointCount\");\n  private static _jointSamplerProperty = Shader.getPropertyByName(\"u_jointSampler\");\n  private static _jointMatrixProperty = Shader.getPropertyByName(\"u_jointMatrix\");\n  private static _blendShapeWeightsProperty = Shader.getPropertyByName(\"u_blendShapeWeights\");\n\n  private static _maxJoints: number = 0;\n\n  @ignoreClone\n  public matrixPalette: Float32Array;\n  @ignoreClone\n  public jointNodes: Entity[];\n  @ignoreClone\n  public jointTexture: Texture2D;\n\n  @ignoreClone\n  private _hasInitJoints: boolean = false;\n  @ignoreClone\n  private _mat: Matrix;\n  @ignoreClone\n  /** Whether to use joint texture. Automatically used when the device can't support the maximum number of bones. */\n  private _useJointTexture: boolean = false;\n  private _skin: Skin;\n  private _blendShapeWeights: Float32Array;\n\n  /**\n   * The weights of the BlendShapes.\n   * @remarks Array index is BlendShape index.\n   */\n  get blendShapeWeights(): Float32Array {\n    return this._blendShapeWeights;\n  }\n\n  set blendShapeWeights(value: Float32Array) {\n    this._blendShapeWeights = value;\n  }\n\n  /**\n   * Constructor of SkinnedMeshRenderer\n   * @param entity - Entity\n   */\n  constructor(entity: Entity) {\n    super(entity);\n    this._mat = new Matrix();\n    this._skin = null;\n  }\n\n  /**\n   * @internal\n   */\n  _updateShaderData(context: RenderContext) {\n    super._updateShaderData(context);\n\n    const shaderData = this.shaderData;\n    if (!this._useJointTexture && this.matrixPalette) {\n      shaderData.setFloatArray(SkinnedMeshRenderer._jointMatrixProperty, this.matrixPalette);\n    }\n\n    const mesh = <ModelMesh>this.mesh;\n    if (mesh._hasBlendShape) {\n      shaderData.setFloatArray(SkinnedMeshRenderer._blendShapeWeightsProperty, this._blendShapeWeights);\n      shaderData.enableMacro(SkinnedMeshRenderer._blendShapeMacro);\n\n      if (mesh._useBlendShapeNormal) {\n        shaderData.enableMacro(SkinnedMeshRenderer._blendShapeNormalMacro);\n      } else {\n        shaderData.disableMacro(SkinnedMeshRenderer._blendShapeNormalMacro);\n      }\n      if (mesh._useBlendShapeTangent) {\n        shaderData.enableMacro(SkinnedMeshRenderer._blendShapeTangentMacro);\n      } else {\n        shaderData.disableMacro(SkinnedMeshRenderer._blendShapeTangentMacro);\n      }\n    } else {\n      shaderData.disableMacro(SkinnedMeshRenderer._blendShapeMacro);\n    }\n  }\n\n  /**\n   * Skin Object.\n   */\n  get skin() {\n    return this._skin;\n  }\n\n  set skin(skin) {\n    this._skin = skin;\n  }\n\n  _initJoints() {\n    if (!this._skin) return;\n    const skin = this._skin;\n\n    const joints = skin.joints;\n    const jointNodes = [];\n    for (let i = joints.length - 1; i >= 0; i--) {\n      jointNodes[i] = this.findByNodeName(this.entity, joints[i]);\n    } // end of for\n    this.matrixPalette = new Float32Array(jointNodes.length * 16);\n    this.jointNodes = jointNodes;\n\n    /** Whether to use a skeleton texture */\n    const rhi = this.entity.engine._hardwareRenderer;\n    if (!rhi) return;\n    const maxAttribUniformVec4 = rhi.renderStates.getParameter(rhi.gl.MAX_VERTEX_UNIFORM_VECTORS);\n    const maxJoints = Math.floor((maxAttribUniformVec4 - 20) / 4);\n    const shaderData = this.shaderData;\n    const jointCount = this.jointNodes?.length;\n    if (jointCount) {\n      shaderData.enableMacro(\"O3_HAS_SKIN\");\n      shaderData.setInt(SkinnedMeshRenderer._jointCountProperty, jointCount);\n      if (joints.length > maxJoints) {\n        if (rhi.canIUseMoreJoints) {\n          this._useJointTexture = true;\n        } else {\n          Logger.error(\n            `component's joints count(${joints}) greater than device's MAX_VERTEX_UNIFORM_VECTORS number ${maxAttribUniformVec4}, and don't support jointTexture in this device. suggest joint count less than ${maxJoints}.`,\n            this\n          );\n        }\n      } else {\n        const maxJoints = Math.max(SkinnedMeshRenderer._maxJoints, joints.length);\n        SkinnedMeshRenderer._maxJoints = maxJoints;\n        shaderData.disableMacro(\"O3_USE_JOINT_TEXTURE\");\n        shaderData.enableMacro(\"O3_JOINTS_NUM\", maxJoints.toString());\n      }\n    } else {\n      shaderData.disableMacro(\"O3_HAS_SKIN\");\n    }\n  }\n\n  private findByNodeName(entity: Entity, nodeName: string) {\n    if (!entity) return null;\n\n    const n = entity.findByName(nodeName);\n\n    if (n) return n;\n\n    return this.findByNodeName(entity.parent, nodeName);\n  }\n\n  /**\n   * @internal\n   */\n  update() {\n    if (!this._hasInitJoints) {\n      this._initJoints();\n      this._hasInitJoints = true;\n    }\n    if (this._skin) {\n      const joints = this.jointNodes;\n      const ibms = this._skin.inverseBindMatrices;\n      const matrixPalette = this.matrixPalette;\n      const worldToLocal = this.entity.getInvModelMatrix();\n\n      const mat = this._mat;\n      for (let i = joints.length - 1; i >= 0; i--) {\n        mat.identity();\n        if (joints[i]) {\n          Matrix.multiply(joints[i].transform.worldMatrix, ibms[i], mat);\n        } else {\n          ibms[i].cloneTo(mat);\n        }\n        Matrix.multiply(worldToLocal, mat, mat);\n        matrixPalette.set(mat.elements, i * 16);\n      }\n      if (this._useJointTexture) {\n        this.createJointTexture();\n      }\n    }\n  }\n\n  /**\n   * Generate joint texture.\n   * Format: (4 * RGBA) * jointCont\n   */\n  createJointTexture() {\n    if (!this.jointTexture) {\n      const engine = this.engine;\n      const rhi = engine._hardwareRenderer;\n      if (!rhi) return;\n      this.jointTexture = new Texture2D(engine, 4, this.jointNodes.length, TextureFormat.R32G32B32A32, false);\n      this.jointTexture.filterMode = TextureFilterMode.Point;\n      this.shaderData.enableMacro(\"O3_USE_JOINT_TEXTURE\");\n      this.shaderData.setTexture(SkinnedMeshRenderer._jointSamplerProperty, this.jointTexture);\n    }\n    this.jointTexture.setPixelBuffer(this.matrixPalette);\n  }\n}\n", "import { Vector2, Vector3 } from \"@oasis-engine/math\";\nimport { GLCapabilityType } from \"../base/Constant\";\nimport { Engine } from \"../Engine\";\nimport { ModelMesh } from \"./ModelMesh\";\n\n/**\n * Used to generate common primitive meshes.\n */\nexport class PrimitiveMesh {\n  /**\n   * Create a sphere mesh.\n   * @param engine - Engine\n   * @param radius - Sphere radius\n   * @param segments - Number of segments\n   * @param noLongerAccessible - No longer access the vertices of the mesh after creation\n   * @returns Sphere model mesh\n   */\n  static createSphere(\n    engine: Engine,\n    radius: number = 0.5,\n    segments: number = 18,\n    noLongerAccessible: boolean = true\n  ): ModelMesh {\n    const mesh = new ModelMesh(engine);\n    segments = Math.max(2, Math.floor(segments));\n\n    const count = segments + 1;\n    const vertexCount = count * count;\n    const rectangleCount = segments * segments;\n    const indices = PrimitiveMesh._generateIndices(engine, vertexCount, rectangleCount * 6);\n    const thetaRange = Math.PI;\n    const alphaRange = thetaRange * 2;\n    const countReciprocal = 1.0 / count;\n    const segmentsReciprocal = 1.0 / segments;\n\n    const positions: Vector3[] = new Array(vertexCount);\n    const normals: Vector3[] = new Array(vertexCount);\n    const uvs: Vector2[] = new Array(vertexCount);\n\n    for (let i = 0; i < vertexCount; ++i) {\n      const x = i % count;\n      const y = (i * countReciprocal) | 0;\n      const u = x * segmentsReciprocal;\n      const v = y * segmentsReciprocal;\n      const alphaDelta = u * alphaRange;\n      const thetaDelta = v * thetaRange;\n      const sinTheta = Math.sin(thetaDelta);\n\n      let posX = -radius * Math.cos(alphaDelta) * sinTheta;\n      let posY = radius * Math.cos(thetaDelta);\n      let posZ = radius * Math.sin(alphaDelta) * sinTheta;\n\n      // Position\n      positions[i] = new Vector3(posX, posY, posZ);\n      // Normal\n      normals[i] = new Vector3(posX, posY, posZ);\n      // Texcoord\n      uvs[i] = new Vector2(u, v);\n    }\n\n    let offset = 0;\n    for (let i = 0; i < rectangleCount; ++i) {\n      const x = i % segments;\n      const y = (i * segmentsReciprocal) | 0;\n\n      const a = y * count + x;\n      const b = a + 1;\n      const c = a + count;\n      const d = c + 1;\n\n      indices[offset++] = b;\n      indices[offset++] = a;\n      indices[offset++] = d;\n      indices[offset++] = a;\n      indices[offset++] = c;\n      indices[offset++] = d;\n    }\n\n    const { bounds } = mesh;\n    bounds.min.setValue(-radius, -radius, -radius);\n    bounds.max.setValue(radius, radius, radius);\n\n    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);\n    return mesh;\n  }\n\n  /**\n   * Create a cuboid mesh.\n   * @param engine - Engine\n   * @param width - Cuboid width\n   * @param height - Cuboid height\n   * @param depth - Cuboid depth\n   * @param noLongerAccessible - No longer access the vertices of the mesh after creation\n   * @returns Cuboid model mesh\n   */\n  static createCuboid(\n    engine: Engine,\n    width: number = 1,\n    height: number = 1,\n    depth: number = 1,\n    noLongerAccessible: boolean = true\n  ): ModelMesh {\n    const mesh = new ModelMesh(engine);\n\n    const halfWidth: number = width / 2;\n    const halfHeight: number = height / 2;\n    const halfDepth: number = depth / 2;\n\n    const positions: Vector3[] = new Array(24);\n    const normals: Vector3[] = new Array(24);\n    const uvs: Vector2[] = new Array(24);\n\n    // Up\n    positions[0] = new Vector3(-halfWidth, halfHeight, -halfDepth);\n    positions[1] = new Vector3(halfWidth, halfHeight, -halfDepth);\n    positions[2] = new Vector3(halfWidth, halfHeight, halfDepth);\n    positions[3] = new Vector3(-halfWidth, halfHeight, halfDepth);\n    normals[0] = new Vector3(0, 1, 0);\n    normals[1] = new Vector3(0, 1, 0);\n    normals[2] = new Vector3(0, 1, 0);\n    normals[3] = new Vector3(0, 1, 0);\n    uvs[0] = new Vector2(0, 0);\n    uvs[1] = new Vector2(1, 0);\n    uvs[2] = new Vector2(1, 1);\n    uvs[3] = new Vector2(0, 1);\n    // Down\n    positions[4] = new Vector3(-halfWidth, -halfHeight, -halfDepth);\n    positions[5] = new Vector3(halfWidth, -halfHeight, -halfDepth);\n    positions[6] = new Vector3(halfWidth, -halfHeight, halfDepth);\n    positions[7] = new Vector3(-halfWidth, -halfHeight, halfDepth);\n    normals[4] = new Vector3(0, -1, 0);\n    normals[5] = new Vector3(0, -1, 0);\n    normals[6] = new Vector3(0, -1, 0);\n    normals[7] = new Vector3(0, -1, 0);\n    uvs[4] = new Vector2(0, 1);\n    uvs[5] = new Vector2(1, 1);\n    uvs[6] = new Vector2(1, 0);\n    uvs[7] = new Vector2(0, 0);\n    // Left\n    positions[8] = new Vector3(-halfWidth, halfHeight, -halfDepth);\n    positions[9] = new Vector3(-halfWidth, halfHeight, halfDepth);\n    positions[10] = new Vector3(-halfWidth, -halfHeight, halfDepth);\n    positions[11] = new Vector3(-halfWidth, -halfHeight, -halfDepth);\n    normals[8] = new Vector3(-1, 0, 0);\n    normals[9] = new Vector3(-1, 0, 0);\n    normals[10] = new Vector3(-1, 0, 0);\n    normals[11] = new Vector3(-1, 0, 0);\n    uvs[8] = new Vector2(0, 0);\n    uvs[9] = new Vector2(1, 0);\n    uvs[10] = new Vector2(1, 1);\n    uvs[11] = new Vector2(0, 1);\n    // Right\n    positions[12] = new Vector3(halfWidth, halfHeight, -halfDepth);\n    positions[13] = new Vector3(halfWidth, halfHeight, halfDepth);\n    positions[14] = new Vector3(halfWidth, -halfHeight, halfDepth);\n    positions[15] = new Vector3(halfWidth, -halfHeight, -halfDepth);\n    normals[12] = new Vector3(1, 0, 0);\n    normals[13] = new Vector3(1, 0, 0);\n    normals[14] = new Vector3(1, 0, 0);\n    normals[15] = new Vector3(1, 0, 0);\n    uvs[12] = new Vector2(1, 0);\n    uvs[13] = new Vector2(0, 0);\n    uvs[14] = new Vector2(0, 1);\n    uvs[15] = new Vector2(1, 1);\n    // Front\n    positions[16] = new Vector3(-halfWidth, halfHeight, halfDepth);\n    positions[17] = new Vector3(halfWidth, halfHeight, halfDepth);\n    positions[18] = new Vector3(halfWidth, -halfHeight, halfDepth);\n    positions[19] = new Vector3(-halfWidth, -halfHeight, halfDepth);\n    normals[16] = new Vector3(0, 0, 1);\n    normals[17] = new Vector3(0, 0, 1);\n    normals[18] = new Vector3(0, 0, 1);\n    normals[19] = new Vector3(0, 0, 1);\n    uvs[16] = new Vector2(0, 0);\n    uvs[17] = new Vector2(1, 0);\n    uvs[18] = new Vector2(1, 1);\n    uvs[19] = new Vector2(0, 1);\n    // Back\n    positions[20] = new Vector3(-halfWidth, halfHeight, -halfDepth);\n    positions[21] = new Vector3(halfWidth, halfHeight, -halfDepth);\n    positions[22] = new Vector3(halfWidth, -halfHeight, -halfDepth);\n    positions[23] = new Vector3(-halfWidth, -halfHeight, -halfDepth);\n    normals[20] = new Vector3(0, 0, -1);\n    normals[21] = new Vector3(0, 0, -1);\n    normals[22] = new Vector3(0, 0, -1);\n    normals[23] = new Vector3(0, 0, -1);\n    uvs[20] = new Vector2(1, 0);\n    uvs[21] = new Vector2(0, 0);\n    uvs[22] = new Vector2(0, 1);\n    uvs[23] = new Vector2(1, 1);\n\n    const indices = new Uint16Array(36);\n\n    // prettier-ignore\n    // Up\n    indices[0] = 0, indices[1] = 2, indices[2] = 1, indices[3] = 2, indices[4] = 0, indices[5] = 3,\n    // Down\n    indices[6] = 4, indices[7] = 6, indices[8] = 7, indices[9] = 6, indices[10] = 4, indices[11] = 5,\n    // Left\n    indices[12] = 8, indices[13] = 10, indices[14] = 9, indices[15] = 10, indices[16] = 8, indices[17] = 11,\n    // Right\n    indices[18] = 12, indices[19] = 14, indices[20] = 15, indices[21] = 14, indices[22] = 12, indices[23] = 13,\n    // Front\n    indices[24] = 16, indices[25] = 18, indices[26] = 17, indices[27] = 18, indices[28] = 16, indices[29] = 19,\n    // Back\n    indices[30] = 20, indices[31] = 22, indices[32] = 23, indices[33] = 22, indices[34] = 20, indices[35] = 21;\n\n    const { bounds } = mesh;\n    bounds.min.setValue(-halfWidth, -halfHeight, -halfDepth);\n    bounds.max.setValue(halfWidth, halfHeight, halfDepth);\n\n    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);\n    return mesh;\n  }\n\n  /**\n   * Create a plane mesh.\n   * @param engine - Engine\n   * @param width - Plane width\n   * @param height - Plane height\n   * @param horizontalSegments - Plane horizontal segments\n   * @param verticalSegments - Plane vertical segments\n   * @param noLongerAccessible - No longer access the vertices of the mesh after creation\n   * @returns Plane model mesh\n   */\n  static createPlane(\n    engine: Engine,\n    width: number = 1,\n    height: number = 1,\n    horizontalSegments: number = 1,\n    verticalSegments: number = 1,\n    noLongerAccessible: boolean = true\n  ): ModelMesh {\n    const mesh = new ModelMesh(engine);\n    horizontalSegments = Math.max(1, Math.floor(horizontalSegments));\n    verticalSegments = Math.max(1, Math.floor(verticalSegments));\n\n    const horizontalCount = horizontalSegments + 1;\n    const verticalCount = verticalSegments + 1;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const gridWidth = width / horizontalSegments;\n    const gridHeight = height / verticalSegments;\n    const vertexCount = horizontalCount * verticalCount;\n    const rectangleCount = verticalSegments * horizontalSegments;\n    const indices = PrimitiveMesh._generateIndices(engine, vertexCount, rectangleCount * 6);\n    const horizontalCountReciprocal = 1.0 / horizontalCount;\n    const horizontalSegmentsReciprocal = 1.0 / horizontalSegments;\n    const verticalSegmentsReciprocal = 1.0 / verticalSegments;\n\n    const positions: Vector3[] = new Array(vertexCount);\n    const normals: Vector3[] = new Array(vertexCount);\n    const uvs: Vector2[] = new Array(vertexCount);\n\n    for (let i = 0; i < vertexCount; ++i) {\n      const x = i % horizontalCount;\n      const y = (i * horizontalCountReciprocal) | 0;\n\n      // Position\n      positions[i] = new Vector3(x * gridWidth - halfWidth, y * gridHeight - halfHeight, 0);\n      // Normal\n      normals[i] = new Vector3(0, 0, 1);\n      // Texcoord\n      uvs[i] = new Vector2(x * horizontalSegmentsReciprocal, 1 - y * verticalSegmentsReciprocal);\n    }\n\n    let offset = 0;\n    for (let i = 0; i < rectangleCount; ++i) {\n      const x = i % horizontalSegments;\n      const y = (i * horizontalSegmentsReciprocal) | 0;\n\n      const a = y * horizontalCount + x;\n      const b = a + 1;\n      const c = a + horizontalCount;\n      const d = c + 1;\n\n      indices[offset++] = b;\n      indices[offset++] = c;\n      indices[offset++] = a;\n      indices[offset++] = b;\n      indices[offset++] = d;\n      indices[offset++] = c;\n    }\n\n    const { bounds } = mesh;\n    bounds.min.setValue(-halfWidth, -halfHeight, 0);\n    bounds.max.setValue(halfWidth, halfHeight, 0);\n\n    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);\n    return mesh;\n  }\n\n  /**\n   * Create a cylinder mesh.\n   * @param engine - Engine\n   * @param radiusTop - The radius of top cap\n   * @param radiusBottom - The radius of bottom cap\n   * @param height - The height of torso\n   * @param radialSegments - Cylinder radial segments\n   * @param heightSegments - Cylinder height segments\n   * @param noLongerAccessible - No longer access the vertices of the mesh after creation\n   * @returns Cylinder model mesh\n   */\n  static createCylinder(\n    engine: Engine,\n    radiusTop: number = 0.5,\n    radiusBottom: number = 0.5,\n    height: number = 2,\n    radialSegments: number = 20,\n    heightSegments: number = 1,\n    noLongerAccessible: boolean = true\n  ): ModelMesh {\n    const mesh = new ModelMesh(engine);\n    radialSegments = Math.floor(radialSegments);\n    heightSegments = Math.floor(heightSegments);\n\n    const radialCount = radialSegments + 1;\n    const verticalCount = heightSegments + 1;\n    const halfHeight = height * 0.5;\n    const unitHeight = height / heightSegments;\n    const torsoVertexCount = radialCount * verticalCount;\n    const torsoRectangleCount = radialSegments * heightSegments;\n    const capTriangleCount = radialSegments * 2;\n    const totalVertexCount = torsoVertexCount + 2 + capTriangleCount;\n    const indices = PrimitiveMesh._generateIndices(\n      engine,\n      totalVertexCount,\n      torsoRectangleCount * 6 + capTriangleCount * 3\n    );\n    const radialCountReciprocal = 1.0 / radialCount;\n    const radialSegmentsReciprocal = 1.0 / radialSegments;\n    const heightSegmentsReciprocal = 1.0 / heightSegments;\n\n    const positions: Vector3[] = new Array(totalVertexCount);\n    const normals: Vector3[] = new Array(totalVertexCount);\n    const uvs: Vector2[] = new Array(totalVertexCount);\n\n    let indicesOffset = 0;\n\n    // Create torso\n    const thetaStart = Math.PI;\n    const thetaRange = Math.PI * 2;\n    const radiusDiff = radiusBottom - radiusTop;\n    const slope = radiusDiff / height;\n    const radiusSlope = radiusDiff / heightSegments;\n\n    for (let i = 0; i < torsoVertexCount; ++i) {\n      const x = i % radialCount;\n      const y = (i * radialCountReciprocal) | 0;\n      const u = x * radialSegmentsReciprocal;\n      const v = y * heightSegmentsReciprocal;\n      const theta = thetaStart + u * thetaRange;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      const radius = radiusBottom - y * radiusSlope;\n\n      let posX = radius * sinTheta;\n      let posY = y * unitHeight - halfHeight;\n      let posZ = radius * cosTheta;\n\n      // Position\n      positions[i] = new Vector3(posX, posY, posZ);\n      // Normal\n      normals[i] = new Vector3(sinTheta, slope, cosTheta);\n      // Texcoord\n      uvs[i] = new Vector2(u, 1 - v);\n    }\n\n    for (let i = 0; i < torsoRectangleCount; ++i) {\n      const x = i % radialSegments;\n      const y = (i * radialSegmentsReciprocal) | 0;\n\n      const a = y * radialCount + x;\n      const b = a + 1;\n      const c = a + radialCount;\n      const d = c + 1;\n\n      indices[indicesOffset++] = b;\n      indices[indicesOffset++] = c;\n      indices[indicesOffset++] = a;\n      indices[indicesOffset++] = b;\n      indices[indicesOffset++] = d;\n      indices[indicesOffset++] = c;\n    }\n\n    // Bottom position\n    positions[torsoVertexCount] = new Vector3(0, -halfHeight, 0);\n    // Bottom normal\n    normals[torsoVertexCount] = new Vector3(0, -1, 0);\n    // Bottom texcoord\n    uvs[torsoVertexCount] = new Vector2(0.5, 0.5);\n\n    // Top position\n    positions[torsoVertexCount + 1] = new Vector3(0, halfHeight, 0);\n    // Top normal\n    normals[torsoVertexCount + 1] = new Vector3(0, 1, 0);\n    // Top texcoord\n    uvs[torsoVertexCount + 1] = new Vector2(0.5, 0.5);\n\n    // Add cap vertices\n    let offset = torsoVertexCount + 2;\n\n    const diameterTopReciprocal = 1.0 / (radiusTop * 2);\n    const diameterBottomReciprocal = 1.0 / (radiusBottom * 2);\n    const positionStride = radialCount * heightSegments;\n    for (let i = 0; i < radialSegments; ++i) {\n      const curPosBottom = positions[i];\n      let curPosX = curPosBottom.x;\n      let curPosZ = curPosBottom.z;\n\n      // Bottom position\n      positions[offset] = new Vector3(curPosX, -halfHeight, curPosZ);\n      // Bottom normal\n      normals[offset] = new Vector3(0, -1, 0);\n      // Bottom texcoord\n      uvs[offset++] = new Vector2(curPosX * diameterBottomReciprocal + 0.5, 0.5 - curPosZ * diameterBottomReciprocal);\n\n      const curPosTop = positions[i + positionStride];\n      curPosX = curPosTop.x;\n      curPosZ = curPosTop.z;\n\n      // Top position\n      positions[offset] = new Vector3(curPosX, halfHeight, curPosZ);\n      // Top normal\n      normals[offset] = new Vector3(0, 1, 0);\n      // Top texcoord\n      uvs[offset++] = new Vector2(curPosX * diameterTopReciprocal + 0.5, curPosZ * diameterTopReciprocal + 0.5);\n    }\n\n    // Add cap indices\n    const topCapIndex = torsoVertexCount + 1;\n    const bottomIndiceIndex = torsoVertexCount + 2;\n    const topIndiceIndex = bottomIndiceIndex + 1;\n    for (let i = 0; i < radialSegments; ++i) {\n      const firstStride = i * 2;\n      const secondStride = i === radialSegments - 1 ? 0 : firstStride + 2;\n\n      // Bottom\n      indices[indicesOffset++] = torsoVertexCount;\n      indices[indicesOffset++] = bottomIndiceIndex + secondStride;\n      indices[indicesOffset++] = bottomIndiceIndex + firstStride;\n\n      // Top\n      indices[indicesOffset++] = topCapIndex;\n      indices[indicesOffset++] = topIndiceIndex + firstStride;\n      indices[indicesOffset++] = topIndiceIndex + secondStride;\n    }\n\n    const { bounds } = mesh;\n    const radiusMax = Math.max(radiusTop, radiusBottom);\n    bounds.min.setValue(-radiusMax, -halfHeight, -radiusMax);\n    bounds.max.setValue(radiusMax, halfHeight, radiusMax);\n\n    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);\n    return mesh;\n  }\n\n  /**\n   * Create a torus mesh.\n   * @param engine - Engine\n   * @param radius - Torus radius\n   * @param tubeRadius - Torus tube\n   * @param radialSegments - Torus radial segments\n   * @param tubularSegments - Torus tubular segments\n   * @param arc - Central angle\n   * @param noLongerAccessible - No longer access the vertices of the mesh after creation\n   * @returns Torus model mesh\n   */\n  static createTorus(\n    engine: Engine,\n    radius: number = 0.5,\n    tubeRadius: number = 0.1,\n    radialSegments: number = 30,\n    tubularSegments: number = 30,\n    arc: number = 360,\n    noLongerAccessible: boolean = true\n  ): ModelMesh {\n    const mesh = new ModelMesh(engine);\n    radialSegments = Math.floor(radialSegments);\n    tubularSegments = Math.floor(tubularSegments);\n\n    const vertexCount = (radialSegments + 1) * (tubularSegments + 1);\n    const rectangleCount = radialSegments * tubularSegments;\n    const indices = PrimitiveMesh._generateIndices(engine, vertexCount, rectangleCount * 6);\n\n    const positions: Vector3[] = new Array(vertexCount);\n    const normals: Vector3[] = new Array(vertexCount);\n    const uvs: Vector2[] = new Array(vertexCount);\n\n    arc = (arc / 180) * Math.PI;\n\n    let offset = 0;\n\n    for (let i = 0; i <= radialSegments; i++) {\n      for (let j = 0; j <= tubularSegments; j++) {\n        const u = (j / tubularSegments) * arc;\n        const v = (i / radialSegments) * Math.PI * 2;\n        const cosV = Math.cos(v);\n        const sinV = Math.sin(v);\n        const cosU = Math.cos(u);\n        const sinU = Math.sin(u);\n\n        const position = new Vector3(\n          (radius + tubeRadius * cosV) * cosU,\n          (radius + tubeRadius * cosV) * sinU,\n          tubeRadius * sinV\n        );\n        positions[offset] = position;\n\n        const centerX = radius * cosU;\n        const centerY = radius * sinU;\n        normals[offset] = new Vector3(position.x - centerX, position.y - centerY, position.z).normalize();\n\n        uvs[offset++] = new Vector2(j / tubularSegments, i / radialSegments);\n      }\n    }\n\n    offset = 0;\n    for (let i = 1; i <= radialSegments; i++) {\n      for (let j = 1; j <= tubularSegments; j++) {\n        const a = (tubularSegments + 1) * i + j - 1;\n        const b = (tubularSegments + 1) * (i - 1) + j - 1;\n        const c = (tubularSegments + 1) * (i - 1) + j;\n        const d = (tubularSegments + 1) * i + j;\n\n        indices[offset++] = a;\n        indices[offset++] = b;\n        indices[offset++] = d;\n\n        indices[offset++] = b;\n        indices[offset++] = c;\n        indices[offset++] = d;\n      }\n    }\n\n    const { bounds } = mesh;\n    const outerRadius = radius + tubeRadius;\n    bounds.min.setValue(-outerRadius, -outerRadius, -tubeRadius);\n    bounds.max.setValue(outerRadius, outerRadius, tubeRadius);\n\n    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);\n    return mesh;\n  }\n\n  /**\n   * Create a cone mesh.\n   * @param engine - Engine\n   * @param radius - The radius of cap\n   * @param height - The height of torso\n   * @param radialSegments - Cylinder radial segments\n   * @param heightSegments - Cylinder height segments\n   * @param noLongerAccessible - No longer access the vertices of the mesh after creation\n   * @returns Cone model mesh\n   */\n  static createCone(\n    engine: Engine,\n    radius: number = 0.5,\n    height: number = 2,\n    radialSegments: number = 20,\n    heightSegments: number = 1,\n    noLongerAccessible: boolean = true\n  ): ModelMesh {\n    const mesh = new ModelMesh(engine);\n    radialSegments = Math.floor(radialSegments);\n    heightSegments = Math.floor(heightSegments);\n\n    const radialCount = radialSegments + 1;\n    const verticalCount = heightSegments + 1;\n    const halfHeight = height * 0.5;\n    const unitHeight = height / heightSegments;\n    const torsoVertexCount = radialCount * verticalCount;\n    const torsoRectangleCount = radialSegments * heightSegments;\n    const totalVertexCount = torsoVertexCount + 1 + radialSegments;\n    const indices = PrimitiveMesh._generateIndices(\n      engine,\n      totalVertexCount,\n      torsoRectangleCount * 6 + radialSegments * 3\n    );\n    const radialCountReciprocal = 1.0 / radialCount;\n    const radialSegmentsReciprocal = 1.0 / radialSegments;\n    const heightSegmentsReciprocal = 1.0 / heightSegments;\n\n    const positions: Vector3[] = new Array(totalVertexCount);\n    const normals: Vector3[] = new Array(totalVertexCount);\n    const uvs: Vector2[] = new Array(totalVertexCount);\n\n    let indicesOffset = 0;\n\n    // Create torso\n    const thetaStart = Math.PI;\n    const thetaRange = Math.PI * 2;\n    const slope = radius / height;\n\n    for (let i = 0; i < torsoVertexCount; ++i) {\n      const x = i % radialCount;\n      const y = (i * radialCountReciprocal) | 0;\n      const u = x * radialSegmentsReciprocal;\n      const v = y * heightSegmentsReciprocal;\n      const theta = thetaStart + u * thetaRange;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      const curRadius = radius - y * radius;\n\n      let posX = curRadius * sinTheta;\n      let posY = y * unitHeight - halfHeight;\n      let posZ = curRadius * cosTheta;\n\n      // Position\n      positions[i] = new Vector3(posX, posY, posZ);\n      // Normal\n      normals[i] = new Vector3(sinTheta, slope, cosTheta);\n      // Texcoord\n      uvs[i] = new Vector2(u, 1 - v);\n    }\n\n    for (let i = 0; i < torsoRectangleCount; ++i) {\n      const x = i % radialSegments;\n      const y = (i * radialSegmentsReciprocal) | 0;\n\n      const a = y * radialCount + x;\n      const b = a + 1;\n      const c = a + radialCount;\n      const d = c + 1;\n\n      indices[indicesOffset++] = b;\n      indices[indicesOffset++] = c;\n      indices[indicesOffset++] = a;\n      indices[indicesOffset++] = b;\n      indices[indicesOffset++] = d;\n      indices[indicesOffset++] = c;\n    }\n\n    // Bottom position\n    positions[torsoVertexCount] = new Vector3(0, -halfHeight, 0);\n    // Bottom normal\n    normals[torsoVertexCount] = new Vector3(0, -1, 0);\n    // Bottom texcoord\n    uvs[torsoVertexCount] = new Vector2(0.5, 0.5);\n\n    // Add bottom cap vertices\n    let offset = torsoVertexCount + 1;\n    const diameterBottomReciprocal = 1.0 / (radius * 2);\n    for (let i = 0; i < radialSegments; ++i) {\n      const curPos = positions[i];\n      let curPosX = curPos.x;\n      let curPosZ = curPos.z;\n\n      // Bottom position\n      positions[offset] = new Vector3(curPosX, -halfHeight, curPosZ);\n      // Bottom normal\n      normals[offset] = new Vector3(0, -1, 0);\n      // Bottom texcoord\n      uvs[offset++] = new Vector2(curPosX * diameterBottomReciprocal + 0.5, 0.5 - curPosZ * diameterBottomReciprocal);\n    }\n\n    const bottomIndiceIndex = torsoVertexCount + 1;\n    for (let i = 0; i < radialSegments; ++i) {\n      const firstStride = i;\n      const secondStride = i === radialSegments - 1 ? 0 : firstStride + 1;\n\n      // Bottom\n      indices[indicesOffset++] = torsoVertexCount;\n      indices[indicesOffset++] = bottomIndiceIndex + secondStride;\n      indices[indicesOffset++] = bottomIndiceIndex + firstStride;\n    }\n\n    const { bounds } = mesh;\n    bounds.min.setValue(-radius, -halfHeight, -radius);\n    bounds.max.setValue(radius, halfHeight, radius);\n\n    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);\n    return mesh;\n  }\n\n  private static _initialize(\n    mesh: ModelMesh,\n    positions: Vector3[],\n    normals: Vector3[],\n    uvs: Vector2[],\n    indices: Uint16Array | Uint32Array,\n    noLongerAccessible: boolean\n  ) {\n    mesh.setPositions(positions);\n    mesh.setNormals(normals);\n    mesh.setUVs(uvs);\n    mesh.setIndices(indices);\n\n    mesh.uploadData(noLongerAccessible);\n    mesh.addSubMesh(0, indices.length);\n  }\n\n  private static _generateIndices(engine: Engine, vertexCount: number, indexCount: number): Uint16Array | Uint32Array {\n    let indices: Uint16Array | Uint32Array = null;\n    if (vertexCount > 65535) {\n      if (engine._hardwareRenderer.canIUse(GLCapabilityType.elementIndexUint)) {\n        indices = new Uint32Array(indexCount);\n      } else {\n        throw Error(\"The vertex count is over limit.\");\n      }\n    } else {\n      indices = new Uint16Array(indexCount);\n    }\n    return indices;\n  }\n}\n", "import { IndexBufferBinding, IndexFormat, Mesh, Buffer, VertexBufferBinding, VertexElement } from \"../graphic\";\n\n/**\n * BufferMesh.\n */\nexport class BufferMesh extends Mesh {\n  /**\n   * Instanced count, disable instanced drawing when set zero.\n   */\n  get instanceCount(): number {\n    return this._instanceCount;\n  }\n\n  set instanceCount(value: number) {\n    this._instanceCount = value;\n  }\n\n  /**\n   * Vertex buffer binding collection.\n   */\n  get vertexBufferBindings(): Readonly<VertexBufferBinding[]> {\n    return this._vertexBufferBindings;\n  }\n\n  /**\n   * Index buffer binding.\n   */\n  get indexBufferBinding(): IndexBufferBinding {\n    return this._indexBufferBinding;\n  }\n\n  /**\n   * Vertex element collection.\n   */\n  get vertexElements(): Readonly<VertexElement[]> {\n    return this._vertexElements;\n  }\n\n  /**\n   * Set vertex elements.\n   * @param elements - Vertex element collection\n   */\n  setVertexElements(elements: VertexElement[]): void {\n    this._setVertexElements(elements);\n  }\n\n  /**\n   * Set vertex buffer binding.\n   * @param vertexBufferBindings - Vertex buffer binding\n   * @param index - Vertex buffer index, the default value is 0\n   */\n  setVertexBufferBinding(vertexBufferBindings: VertexBufferBinding, index?: number): void;\n\n  /**\n   * Set vertex buffer binding.\n   * @param vertexBuffer - Vertex buffer\n   * @param stride - Vertex buffer data stride\n   * @param index - Vertex buffer index, the default value is 0\n   */\n  setVertexBufferBinding(vertexBuffer: Buffer, stride: number, index?: number): void;\n\n  setVertexBufferBinding(\n    bufferOrBinding: Buffer | VertexBufferBinding,\n    strideOrFirstIndex: number = 0,\n    index: number = 0\n  ): void {\n    let binding = <VertexBufferBinding>bufferOrBinding;\n    const isBinding = binding.buffer !== undefined;\n    isBinding || (binding = new VertexBufferBinding(<Buffer>bufferOrBinding, strideOrFirstIndex));\n\n    const bindings = this._vertexBufferBindings;\n    bindings.length <= index && (bindings.length = index + 1);\n    this._setVertexBufferBinding(isBinding ? strideOrFirstIndex : index, binding);\n  }\n\n  /**\n   * Set vertex buffer binding.\n   * @param vertexBufferBindings - Vertex buffer binding\n   * @param firstIndex - First vertex buffer index, the default value is 0\n   */\n  setVertexBufferBindings(vertexBufferBindings: VertexBufferBinding[], firstIndex: number = 0): void {\n    const bindings = this._vertexBufferBindings;\n    const count = vertexBufferBindings.length;\n    const needLength = firstIndex + count;\n    bindings.length < needLength && (bindings.length = needLength);\n    for (let i = 0; i < count; i++) {\n      this._setVertexBufferBinding(firstIndex + i, vertexBufferBindings[i]);\n    }\n  }\n\n  /**\n   * Set index buffer binding.\n   * @param buffer - Index buffer\n   * @param format - Index buffer format\n   */\n  setIndexBufferBinding(buffer: Buffer, format: IndexFormat): void;\n\n  /**\n   * Set index buffer binding.\n   * @param bufferBinding - Index buffer binding\n   * @remarks When bufferBinding is null, it will clear IndexBufferBinding\n   */\n  setIndexBufferBinding(bufferBinding: IndexBufferBinding | null): void;\n\n  setIndexBufferBinding(bufferOrBinding: Buffer | IndexBufferBinding | null, format?: IndexFormat): void {\n    let binding = <IndexBufferBinding>bufferOrBinding;\n    if (binding) {\n      const isBinding = binding.buffer !== undefined;\n      isBinding || (binding = new IndexBufferBinding(<Buffer>bufferOrBinding, format));\n    }\n    this._setIndexBufferBinding(binding);\n  }\n}\n", "import { Vector3 } from \"@oasis-engine/math\";\n\n/**\n * BlendShapeFrame.\n */\nexport class BlendShapeFrame {\n  /** Weight of BlendShapeFrame. */\n  readonly weight: number;\n  /** Delta positions for the frame being added. */\n  readonly deltaPositions: Readonly<Readonly<Vector3>[]>;\n  /** Delta normals for the frame being added. */\n  readonly deltaNormals: Readonly<Readonly<Vector3[]> | null>;\n  /** Delta tangents for the frame being added. */\n  readonly deltaTangents: Readonly<Readonly<Vector3[]> | null>;\n\n  /**\n   * Create a BlendShapeFrame.\n   * @param weight - Weight of BlendShapeFrame\n   * @param deltaPositions - Delta positions for the frame being added\n   * @param deltaNormals - Delta normals for the frame being added\n   * @param deltaTangents - Delta tangents for the frame being added\n   */\n  constructor(\n    weight: number,\n    deltaPositions: Vector3[],\n    deltaNormals: Vector3[] = null,\n    deltaTangents: Vector3[] = null\n  ) {\n    if (deltaNormals && deltaNormals.length !== deltaPositions.length) {\n      throw \"deltaNormals length must same with deltaPositions length.\";\n    }\n\n    if (deltaTangents && deltaTangents.length !== deltaPositions.length) {\n      throw \"deltaTangents length must same with deltaPositions length.\";\n    }\n\n    this.weight = weight;\n    this.deltaPositions = deltaPositions;\n    this.deltaNormals = deltaNormals;\n    this.deltaTangents = deltaTangents;\n  }\n}\n", "import { BlendShapeFrame } from \"./BlendShapeFrame\";\nimport { Vector3 } from \"@oasis-engine/math\";\nimport { UpdateFlag } from \"../UpdateFlag\";\nimport { UpdateFlagManager } from \"../UpdateFlagManager\";\n\n/**\n * BlendShape.\n */\nexport class BlendShape {\n  /** Name of BlendShape. */\n  name: string;\n\n  /** @internal */\n  _useBlendShapeNormal: boolean = false;\n  /** @internal */\n  _useBlendShapeTangent: boolean = false;\n\n  private _frames: BlendShapeFrame[] = [];\n  private _updateFlagManager: UpdateFlagManager = new UpdateFlagManager();\n\n  /**\n   * Frames of BlendShape.\n   */\n  get frames(): Readonly<BlendShapeFrame[]> {\n    return this._frames;\n  }\n\n  /**\n   * Create a BlendShape.\n   * @param name - BlendShape name.\n   */\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Add a BlendShapeFrame by weight, deltaPositions, deltaNormals and deltaTangents.\n   * @param weight - Weight of BlendShapeFrame\n   * @param deltaPositions - Delta positions for the frame being added\n   * @param deltaNormals - Delta normals for the frame being added\n   * @param deltaTangents - Delta tangents for the frame being added\n   */\n  addFrame(\n    weight: number,\n    deltaPositions: Vector3[],\n    deltaNormals?: Vector3[],\n    deltaTangents?: Vector3[]\n  ): BlendShapeFrame;\n\n  /**\n   * Add a BlendShapeFrame.\n   * @param frame - The BlendShapeFrame.\n   */\n  addFrame(frame: BlendShapeFrame): void;\n\n  addFrame(\n    frameOrWeight: BlendShapeFrame | number,\n    deltaPositions?: Vector3[],\n    deltaNormals?: Vector3[],\n    deltaTangents?: Vector3[]\n  ): void | BlendShapeFrame {\n    if (typeof frameOrWeight === \"number\") {\n      const frame = new BlendShapeFrame(frameOrWeight, deltaPositions, deltaNormals, deltaTangents);\n      this._addFrame(frame);\n      return frame;\n    } else {\n      this._addFrame(frameOrWeight);\n    }\n    this._updateFlagManager.distribute();\n  }\n\n  /**\n   * Clear all frames.\n   */\n  clearFrames(): void {\n    this._frames.length = 0;\n    this._updateFlagManager.distribute();\n    this._useBlendShapeNormal = false;\n    this._useBlendShapeTangent = false;\n  }\n\n  /**\n   * @internal\n   */\n  _registerChangeFlag(): UpdateFlag {\n    return this._updateFlagManager.register();\n  }\n\n  private _addFrame(frame: BlendShapeFrame): void {\n    const frames = this._frames;\n    const frameCount = frames.length;\n    if (frameCount > 0 && frame.deltaPositions.length !== frames[frameCount - 1].deltaPositions.length) {\n      throw \"Frame's deltaPositions length must same with before frame deltaPositions length.\";\n    }\n\n    this._useBlendShapeNormal = this._useBlendShapeNormal || frame.deltaNormals !== null;\n    this._useBlendShapeTangent = this._useBlendShapeTangent || frame.deltaTangents !== null;\n    this._frames.push(frame);\n  }\n}\n", "import { Engine } from \"../Engine\";\nimport { Buffer, BufferBindFlag, BufferUsage, IndexFormat, MeshTopology, SubMesh, VertexElement } from \"../graphic\";\nimport { BufferMesh } from \"../mesh\";\nimport { SystemInfo } from \"../SystemInfo\";\nimport { ClassPool } from \"./ClassPool\";\nimport { SpriteElement } from \"./SpriteElement\";\nimport { SpriteMaskElement } from \"./SpriteMaskElement\";\n\ntype Element = SpriteElement | SpriteMaskElement;\n\nexport abstract class Basic2DBatcher {\n  /** The maximum number of vertex. */\n  static MAX_VERTEX_COUNT: number = 4096;\n  static _canUploadSameBuffer: boolean = true;\n\n  /** @internal */\n  _subMeshPool: ClassPool<SubMesh> = new ClassPool(SubMesh);\n  /** @internal */\n  _batchedQueue: Element[] = [];\n  /** @internal */\n  _meshes: BufferMesh[] = [];\n  /** @internal */\n  _meshCount: number = 1;\n  /** @internal */\n  _vertexBuffers: Buffer[] = [];\n  /** @internal */\n  _indiceBuffers: Buffer[] = [];\n  /** @internal */\n  _vertices: Float32Array;\n  /** @internal */\n  _indices: Uint16Array;\n  /** @internal */\n  _flushId: number = 0;\n  /** @internal */\n  _vertexCount: number = 0;\n  /** @internal */\n  _elementCount: number = 0;\n\n  constructor(engine: Engine) {\n    const { MAX_VERTEX_COUNT } = Basic2DBatcher;\n    this._vertices = new Float32Array(MAX_VERTEX_COUNT * 9);\n    this._indices = new Uint16Array(MAX_VERTEX_COUNT * 3);\n\n    const { _meshes, _meshCount } = this;\n    for (let i = 0; i < _meshCount; i++) {\n      _meshes[i] = this._createMesh(engine, i);\n    }\n  }\n\n  drawElement(element: Element): void {\n    const len = element.positions.length;\n    if (this._vertexCount + len > Basic2DBatcher.MAX_VERTEX_COUNT) {\n      this.flush(element.camera.engine);\n    }\n\n    this._vertexCount += len;\n    this._batchedQueue[this._elementCount++] = element;\n  }\n\n  flush(engine: Engine): void {\n    const batchedQueue = this._batchedQueue;\n\n    if (batchedQueue.length === 0) {\n      return;\n    }\n\n    this._updateData(engine);\n    this.drawBatches(engine);\n\n    if (!Basic2DBatcher._canUploadSameBuffer) {\n      this._flushId++;\n    }\n\n    batchedQueue.length = 0;\n    this._subMeshPool.resetPool();\n    this._vertexCount = 0;\n    this._elementCount = 0;\n  }\n\n  clear(): void {\n    this._flushId = 0;\n    this._vertexCount = 0;\n    this._elementCount = 0;\n    this._batchedQueue.length = 0;\n  }\n\n  destroy(): void {\n    this._batchedQueue = null;\n\n    const { _meshes: meshes, _vertexBuffers: vertexBuffers, _indiceBuffers: indiceBuffers } = this;\n\n    for (let i = 0, n = meshes.length; i < n; ++i) {\n      meshes[i].destroy();\n    }\n    this._meshes = null;\n\n    for (let i = 0, n = vertexBuffers.length; i < n; ++i) {\n      vertexBuffers[i].destroy();\n    }\n    this._vertexBuffers = null;\n\n    for (let i = 0, n = indiceBuffers.length; i < n; ++i) {\n      indiceBuffers[i].destroy();\n    }\n    this._indiceBuffers = null;\n  }\n\n  private _createMesh(engine: Engine, index: number): BufferMesh {\n    const { MAX_VERTEX_COUNT } = Basic2DBatcher;\n    const mesh = new BufferMesh(engine, `BufferMesh${index}`);\n\n    const vertexElements: VertexElement[] = [];\n    const vertexStride = this.createVertexElements(vertexElements);\n\n    // vertices\n    this._vertexBuffers[index] = new Buffer(\n      engine,\n      BufferBindFlag.VertexBuffer,\n      MAX_VERTEX_COUNT * 4 * vertexStride,\n      BufferUsage.Dynamic\n    );\n    // indices\n    this._indiceBuffers[index] = new Buffer(\n      engine,\n      BufferBindFlag.IndexBuffer,\n      MAX_VERTEX_COUNT * 3,\n      BufferUsage.Dynamic\n    );\n    mesh.setVertexBufferBinding(this._vertexBuffers[index], vertexStride);\n    mesh.setIndexBufferBinding(this._indiceBuffers[index], IndexFormat.UInt16);\n    mesh.setVertexElements(vertexElements);\n\n    return mesh;\n  }\n\n  private _updateData(engine: Engine): void {\n    const { _meshes, _flushId } = this;\n\n    if (!Basic2DBatcher._canUploadSameBuffer && this._meshCount <= _flushId) {\n      this._meshCount++;\n      _meshes[_flushId] = this._createMesh(engine, _flushId);\n    }\n\n    const { _batchedQueue: batchedQueue, _vertices: vertices, _indices: indices } = this;\n    const mesh = _meshes[_flushId];\n    mesh.clearSubMesh();\n\n    let vertexIndex = 0;\n    let indiceIndex = 0;\n    let vertexStartIndex = 0;\n    let vertexCount = 0;\n    let curIndiceStartIndex = 0;\n    let curMeshIndex = 0;\n    let preElement: Element = null;\n    for (let i = 0, len = batchedQueue.length; i < len; i++) {\n      const curElement = batchedQueue[i];\n\n      // Batch vertex\n      vertexIndex = this.updateVertices(curElement, vertices, vertexIndex);\n\n      // Batch indice\n      const { triangles } = curElement;\n      const triangleNum = triangles.length;\n      for (let j = 0; j < triangleNum; j++) {\n        indices[indiceIndex++] = triangles[j] + curIndiceStartIndex;\n      }\n\n      curIndiceStartIndex += curElement.positions.length;\n\n      if (preElement === null) {\n        vertexCount += triangleNum;\n      } else {\n        if (this.canBatch(preElement, curElement)) {\n          vertexCount += triangleNum;\n        } else {\n          mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex, vertexCount));\n          vertexStartIndex += vertexCount;\n          vertexCount = triangleNum;\n          batchedQueue[curMeshIndex++] = preElement;\n        }\n      }\n\n      preElement = curElement;\n    }\n\n    mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex, vertexCount));\n    batchedQueue[curMeshIndex] = preElement;\n\n    this._vertexBuffers[_flushId].setData(vertices, 0, 0, vertexIndex);\n    this._indiceBuffers[_flushId].setData(indices, 0, 0, indiceIndex);\n  }\n\n  private _getSubMeshFromPool(start: number, count: number): SubMesh {\n    const subMesh = this._subMeshPool.getFromPool();\n    subMesh.start = start;\n    subMesh.count = count;\n    subMesh.topology = MeshTopology.Triangles;\n    return subMesh;\n  }\n\n  /**\n   * @internal\n   */\n  abstract createVertexElements(vertexElements: VertexElement[]): number;\n\n  /**\n   * @internal\n   */\n  abstract canBatch(preElement: Element, curElement: Element): boolean;\n\n  /**\n   * @internal\n   */\n  abstract updateVertices(element: Element, vertices: Float32Array, vertexIndex: number): number;\n\n  /**\n   * @internal\n   */\n  abstract drawBatches(engine: Engine): void;\n}\n", "import { SpriteMask } from \"../2d/sprite/SpriteMask\";\nimport { Engine } from \"../Engine\";\nimport { VertexElementFormat } from \"../graphic/enums/VertexElementFormat\";\nimport { VertexElement } from \"../graphic/VertexElement\";\nimport { StencilOperation } from \"../shader/enums/StencilOperation\";\nimport { Shader } from \"../shader/Shader\";\nimport { ShaderMacroCollection } from \"../shader/ShaderMacroCollection\";\nimport { Basic2DBatcher } from \"./Basic2DBatcher\";\nimport { SpriteMaskElement } from \"./SpriteMaskElement\";\n\nexport class SpriteMaskBatcher extends Basic2DBatcher {\n  createVertexElements(vertexElements: VertexElement[]): number {\n    vertexElements[0] = new VertexElement(\"POSITION\", 0, VertexElementFormat.Vector3, 0);\n    vertexElements[1] = new VertexElement(\"TEXCOORD_0\", 12, VertexElementFormat.Vector2, 0);\n    return 20;\n  }\n\n  canBatch(preElement: SpriteMaskElement, curElement: SpriteMaskElement): boolean {\n    if (preElement.isAdd !== curElement.isAdd) {\n      return false;\n    }\n\n    // Compare renderer property\n    const preShaderData = (<SpriteMask>preElement.component).shaderData;\n    const curShaderData = (<SpriteMask>curElement.component).shaderData;\n    const textureProperty = SpriteMask._textureProperty;\n    const alphaCutoffProperty = SpriteMask._alphaCutoffProperty;\n\n    return (\n      preShaderData.getTexture(textureProperty) === curShaderData.getTexture(textureProperty) &&\n      preShaderData.getTexture(alphaCutoffProperty) === curShaderData.getTexture(alphaCutoffProperty)\n    );\n  }\n\n  updateVertices(element: SpriteMaskElement, vertices: Float32Array, vertexIndex: number): number {\n    const { positions, uv } = element;\n    const verticesNum = positions.length;\n    for (let i = 0; i < verticesNum; i++) {\n      const curPos = positions[i];\n      const curUV = uv[i];\n\n      vertices[vertexIndex++] = curPos.x;\n      vertices[vertexIndex++] = curPos.y;\n      vertices[vertexIndex++] = curPos.z;\n      vertices[vertexIndex++] = curUV.x;\n      vertices[vertexIndex++] = curUV.y;\n    }\n\n    return vertexIndex;\n  }\n\n  drawBatches(engine: Engine): void {\n    const mesh = this._meshes[this._flushId];\n    const subMeshes = mesh.subMeshes;\n    const batchedQueue = this._batchedQueue;\n\n    for (let i = 0, len = subMeshes.length; i < len; i++) {\n      const subMesh = subMeshes[i];\n      const spriteMaskElement = <SpriteMaskElement>batchedQueue[i];\n\n      if (!subMesh || !spriteMaskElement) {\n        return;\n      }\n\n      const renderer = <SpriteMask>spriteMaskElement.component;\n      const material = spriteMaskElement.material;\n\n      const compileMacros = Shader._compileMacros;\n      // union render global macro and material self macro.\n      ShaderMacroCollection.unionCollection(\n        renderer._globalShaderMacro,\n        material.shaderData._macroCollection,\n        compileMacros\n      );\n\n      // Update stencil state\n      const stencilState = material.renderState.stencilState;\n      const op = spriteMaskElement.isAdd ? StencilOperation.IncrementSaturate : StencilOperation.DecrementSaturate;\n      stencilState.passOperationFront = op;\n      stencilState.passOperationBack = op;\n\n      const program = material.shader._getShaderProgram(engine, compileMacros);\n      if (!program.isValid) {\n        return;\n      }\n\n      const camera = spriteMaskElement.camera;\n\n      program.bind();\n      program.groupingOtherUniformBlock();\n      program.uploadAll(program.sceneUniformBlock, camera.scene.shaderData);\n      program.uploadAll(program.cameraUniformBlock, camera.shaderData);\n      program.uploadAll(program.rendererUniformBlock, renderer.shaderData);\n      program.uploadAll(program.materialUniformBlock, material.shaderData);\n\n      material.renderState._apply(engine);\n\n      engine._hardwareRenderer.drawPrimitive(mesh, subMesh, program);\n    }\n  }\n}\n", "import { SpriteMaskInteraction } from \"../2d/enums/SpriteMaskInteraction\";\nimport { SpriteRenderer } from \"../2d/sprite/SpriteRenderer\";\nimport { Camera } from \"../Camera\";\nimport { Engine } from \"../Engine\";\nimport { SpriteMaskBatcher } from \"./SpriteMaskBatcher\";\n\n/**\n * @internal\n */\nexport class SpriteMaskManager {\n  _batcher: SpriteMaskBatcher;\n\n  private _preMaskLayer: number = 0;\n\n  constructor(engine: Engine) {\n    this._batcher = new SpriteMaskBatcher(engine);\n  }\n\n  clear(): void {\n    this._preMaskLayer = 0;\n    this._batcher.clear();\n  }\n\n  preRender(camera: Camera, renderer: SpriteRenderer): void {\n    if (renderer.maskInteraction === SpriteMaskInteraction.None) {\n      return;\n    }\n\n    this._batcher.clear();\n    this._processMasksDiff(camera, renderer);\n    this._batcher.flush(camera.engine);\n  }\n\n  postRender(renderer: SpriteRenderer): void {\n    if (renderer.maskInteraction === SpriteMaskInteraction.None) {\n      return;\n    }\n\n    this._preMaskLayer = renderer.maskLayer;\n  }\n\n  destroy(): void {\n    this._batcher.destroy();\n    this._batcher = null;\n  }\n\n  private _processMasksDiff(camera: Camera, renderer: SpriteRenderer): void {\n    const preMaskLayer = this._preMaskLayer;\n    const curMaskLayer = renderer.maskLayer;\n    if (preMaskLayer !== curMaskLayer) {\n      const allMasks = camera._renderPipeline._allSpriteMasks;\n      const commonLayer = preMaskLayer & curMaskLayer;\n      const addLayer = curMaskLayer & ~preMaskLayer;\n      const reduceLayer = preMaskLayer & ~curMaskLayer;\n\n      const allMaskElements = allMasks._elements;\n      for (let i = 0, n = allMasks.length; i < n; i++) {\n        const mask = allMaskElements[i];\n        const influenceLayers = mask.influenceLayers;\n\n        if (influenceLayers & commonLayer) {\n          continue;\n        }\n\n        if (influenceLayers & addLayer) {\n          const maskRenderElement = mask._maskElement;\n          maskRenderElement.isAdd = true;\n          this._batcher.drawElement(maskRenderElement);\n          continue;\n        }\n\n        if (influenceLayers & reduceLayer) {\n          const maskRenderElement = mask._maskElement;\n          maskRenderElement.isAdd = false;\n          this._batcher.drawElement(maskRenderElement);\n        }\n      }\n    }\n  }\n}\n", "/**\n * The Background mode enumeration.\n */\nexport enum BackgroundMode {\n  /* Solid color. */\n  SolidColor,\n  /* Sky. */\n  Sky,\n  /** Texture */\n  Texture\n}\n", "/**\n * Filling mode of background texture.\n */\nexport enum BackgroundTextureFillMode {\n  /* Maintain the aspect ratio and scale the texture to fit the width of the canvas. */\n  AspectFitWidth,\n  /* Maintain the aspect ratio and scale the texture to fit the height of the canvas. */\n  AspectFitHeight,\n  /* Scale the texture fully fills the canvas. */\n  Fill\n}\n", "import { Matrix } from \"@oasis-engine/math\";\nimport { Mesh } from \"../graphic\";\nimport { Material } from \"../material\";\n\n/**\n * Sky.\n */\nexport class Sky {\n  /** Material of the sky. */\n  material: Material;\n  /** Mesh of the sky. */\n  mesh: Mesh;\n  /** @internal */\n  _matrix: Matrix = new Matrix();\n}\n", "import { Color } from \"@oasis-engine/math\";\nimport { Engine } from \"./Engine\";\nimport { BackgroundMode } from \"./enums/BackgroundMode\";\nimport { BackgroundTextureFillMode } from \"./enums/BackgroundTextureFillMode\";\nimport { Sky } from \"./sky/Sky\";\nimport { Texture2D } from \"./texture\";\n\n/**\n * Background of scene.\n */\nexport class Background {\n  /**\n   * Background mode.\n   * @defaultValue `BackgroundMode.SolidColor`\n   * @remarks If using `BackgroundMode.Sky` mode and material or mesh of the `sky` is not defined, it will downgrade to `BackgroundMode.SolidColor`.\n   */\n  mode: BackgroundMode = BackgroundMode.SolidColor;\n\n  /**\n   * Background solid color.\n   * @defaultValue `new Color(0.25, 0.25, 0.25, 1.0)`\n   * @remarks When `mode` is `BackgroundMode.SolidColor`, the property will take effects.\n   */\n  solidColor: Color = new Color(0.25, 0.25, 0.25, 1.0);\n\n  /**\n   * Background sky.\n   * @remarks When `mode` is `BackgroundMode.Sky`, the property will take effects.\n   */\n  readonly sky: Sky = new Sky();\n\n  /** @internal */\n  _textureFillMode: BackgroundTextureFillMode = BackgroundTextureFillMode.AspectFitHeight;\n\n  private _texture: Texture2D = null;\n\n  /**\n   * Background texture.\n   * @remarks When `mode` is `BackgroundMode.Texture`, the property will take effects.\n   */\n  get texture(): Texture2D {\n    return this._texture;\n  }\n\n  set texture(value: Texture2D) {\n    if (this._texture !== value) {\n      this._texture = value;\n      this._engine._backgroundTextureMaterial.shaderData.setTexture(\"u_baseTexture\", value);\n    }\n  }\n\n  /**\n   * @internal\n   * Background texture fill mode.\n   * @remarks When `mode` is `BackgroundMode.Texture`, the property will take effects.\n   * @defaultValue `BackgroundTextureFillMode.FitHeight`\n   */\n  get textureFillMode(): BackgroundTextureFillMode {\n    return this._textureFillMode;\n  }\n\n  set textureFillMode(value: BackgroundTextureFillMode) {\n    if (value !== this._textureFillMode) {\n      this._textureFillMode = value;\n      this._resizeBackgroundTexture();\n    }\n  }\n\n  /**\n   * Constructor of Background.\n   * @param _engine Engine Which the background belongs to.\n   */\n  constructor(private _engine: Engine) {}\n\n  /**\n   * @internal\n   */\n  _resizeBackgroundTexture(): void {\n    if (!this._texture) {\n      return;\n    }\n    const { canvas } = this._engine;\n    const { width, height } = canvas;\n    const { _backgroundTextureMesh } = this._engine;\n    const positions = _backgroundTextureMesh.getPositions();\n\n    switch (this._textureFillMode) {\n      case BackgroundTextureFillMode.Fill:\n        positions[0].setValue(-1, -1, 1);\n        positions[1].setValue(1, -1, 1);\n        positions[2].setValue(-1, 1, 1);\n        positions[3].setValue(1, 1, 1);\n        break;\n      case BackgroundTextureFillMode.AspectFitWidth:\n        const fitWidthScale = (this._texture.height * width) / this.texture.width / height;\n        positions[0].setValue(-1, -fitWidthScale, 1);\n        positions[1].setValue(1, -fitWidthScale, 1);\n        positions[2].setValue(-1, fitWidthScale, 1);\n        positions[3].setValue(1, fitWidthScale, 1);\n        break;\n      case BackgroundTextureFillMode.AspectFitHeight:\n        const fitHeightScale = (this._texture.width * height) / this.texture.height / width;\n        positions[0].setValue(-fitHeightScale, -1, 1);\n        positions[1].setValue(fitHeightScale, -1, 1);\n        positions[2].setValue(-fitHeightScale, 1, 1);\n        positions[3].setValue(fitHeightScale, 1, 1);\n        break;\n    }\n    _backgroundTextureMesh.setPositions(positions);\n    _backgroundTextureMesh.uploadData(false);\n  }\n}\n", "/**\n * Diffuse mode.\n */\nexport enum DiffuseMode {\n  /** Solid color mode. */\n  SolidColor,\n\n  /**\n   * SH mode\n   * @remarks\n   * Use SH3 to represent irradiance environment maps efficiently, allowing for interactive rendering of diffuse objects under distant illumination.\n   */\n  SphericalHarmonics\n}\n", "import { Color, SphericalHarmonics3 } from \"@oasis-engine/math\";\nimport { Scene } from \"../Scene\";\nimport { Shader } from \"../shader\";\nimport { ShaderMacro } from \"../shader/ShaderMacro\";\nimport { ShaderProperty } from \"../shader/ShaderProperty\";\nimport { TextureCubeMap } from \"../texture\";\nimport { DiffuseMode } from \"./enums/DiffuseMode\";\n\n/**\n * Ambient light.\n */\nexport class AmbientLight {\n  private static _shMacro: ShaderMacro = Shader.getMacroByName(\"O3_USE_SH\");\n  private static _specularMacro: ShaderMacro = Shader.getMacroByName(\"O3_USE_SPECULAR_ENV\");\n\n  private static _diffuseColorProperty: ShaderProperty = Shader.getPropertyByName(\"u_envMapLight.diffuse\");\n  private static _diffuseSHProperty: ShaderProperty = Shader.getPropertyByName(\"u_env_sh\");\n  private static _diffuseIntensityProperty: ShaderProperty = Shader.getPropertyByName(\"u_envMapLight.diffuseIntensity\");\n  private static _specularTextureProperty: ShaderProperty = Shader.getPropertyByName(\"u_env_specularSampler\");\n  private static _specularIntensityProperty: ShaderProperty = Shader.getPropertyByName(\n    \"u_envMapLight.specularIntensity\"\n  );\n  private static _mipLevelProperty: ShaderProperty = Shader.getPropertyByName(\"u_envMapLight.mipMapLevel\");\n\n  private _scene: Scene;\n  private _diffuseSphericalHarmonics: SphericalHarmonics3;\n  private _diffuseSolidColor: Color = new Color(0.212, 0.227, 0.259);\n  private _diffuseIntensity: number = 1.0;\n  private _specularReflection: TextureCubeMap;\n  private _specularIntensity: number = 1.0;\n  private _diffuseMode: DiffuseMode = DiffuseMode.SolidColor;\n  private _shArray: Float32Array = new Float32Array(27);\n\n  /**\n   * Diffuse mode of ambient light.\n   */\n  get diffuseMode(): DiffuseMode {\n    return this._diffuseMode;\n  }\n\n  set diffuseMode(value: DiffuseMode) {\n    this._diffuseMode = value;\n    if (value === DiffuseMode.SphericalHarmonics) {\n      this._scene.shaderData.enableMacro(AmbientLight._shMacro);\n    } else {\n      this._scene.shaderData.disableMacro(AmbientLight._shMacro);\n    }\n  }\n\n  /**\n   * Diffuse reflection solid color.\n   * @remarks Effective when diffuse reflection mode is `DiffuseMode.SolidColor`.\n   */\n  get diffuseSolidColor(): Color {\n    return this._diffuseSolidColor;\n  }\n\n  set diffuseSolidColor(value: Color) {\n    if (value !== this._diffuseSolidColor) {\n      value.cloneTo(this._diffuseSolidColor);\n    }\n  }\n\n  /**\n   * Diffuse reflection spherical harmonics 3.\n   * @remarks Effective when diffuse reflection mode is `DiffuseMode.SphericalHarmonics`.\n   */\n  get diffuseSphericalHarmonics(): SphericalHarmonics3 {\n    return this._diffuseSphericalHarmonics;\n  }\n\n  set diffuseSphericalHarmonics(value: SphericalHarmonics3) {\n    this._diffuseSphericalHarmonics = value;\n    const shaderData = this._scene.shaderData;\n\n    if (value) {\n      shaderData.setFloatArray(AmbientLight._diffuseSHProperty, this._preComputeSH(value, this._shArray));\n    }\n  }\n\n  /**\n   * Diffuse reflection intensity.\n   */\n  get diffuseIntensity(): number {\n    return this._diffuseIntensity;\n  }\n\n  set diffuseIntensity(value: number) {\n    this._diffuseIntensity = value;\n    this._scene.shaderData.setFloat(AmbientLight._diffuseIntensityProperty, value);\n  }\n\n  /**\n   * Specular reflection texture.\n   */\n  get specularTexture(): TextureCubeMap {\n    return this._specularReflection;\n  }\n\n  set specularTexture(value: TextureCubeMap) {\n    this._specularReflection = value;\n\n    const shaderData = this._scene.shaderData;\n\n    if (value) {\n      shaderData.setTexture(AmbientLight._specularTextureProperty, value);\n      shaderData.setFloat(AmbientLight._mipLevelProperty, this._specularReflection.mipmapCount);\n      shaderData.enableMacro(AmbientLight._specularMacro);\n    } else {\n      shaderData.disableMacro(AmbientLight._specularMacro);\n    }\n  }\n\n  /**\n   * Specular reflection intensity.\n   */\n  get specularIntensity(): number {\n    return this._specularIntensity;\n  }\n\n  set specularIntensity(value: number) {\n    this._specularIntensity = value;\n    this._scene.shaderData.setFloat(AmbientLight._specularIntensityProperty, value);\n  }\n\n  constructor(scene: Scene) {\n    this._scene = scene;\n\n    const { shaderData } = this._scene;\n    shaderData.setColor(AmbientLight._diffuseColorProperty, this._diffuseSolidColor);\n    shaderData.setFloat(AmbientLight._diffuseIntensityProperty, this._diffuseIntensity);\n    shaderData.setFloat(AmbientLight._specularIntensityProperty, this._specularIntensity);\n  }\n\n  private _preComputeSH(sh: SphericalHarmonics3, out: Float32Array): Float32Array {\n    /**\n     * Basis constants\n     *\n     * 0: 1/2 * Math.sqrt(1 / Math.PI)\n     *\n     * 1: -1/2 * Math.sqrt(3 / Math.PI)\n     * 2: 1/2 * Math.sqrt(3 / Math.PI)\n     * 3: -1/2 * Math.sqrt(3 / Math.PI)\n     *\n     * 4: 1/2 * Math.sqrt(15 / Math.PI)\n     * 5: -1/2 * Math.sqrt(15 / Math.PI)\n     * 6: 1/4 * Math.sqrt(5 / Math.PI)\n     * 7: -1/2 * Math.sqrt(15 / Math.PI)\n     * 8: 1/4 * Math.sqrt(15 / Math.PI)\n     */\n\n    /**\n     * Convolution kernel\n     *\n     * 0: Math.PI\n     * 1: (2 * Math.PI) / 3\n     * 2: Math.PI / 4\n     */\n\n    const src = sh.coefficients;\n\n    // l0\n    out[0] = src[0] * 0.886227; // kernel0 * basis0 = 0.886227\n    out[1] = src[1] * 0.886227;\n    out[2] = src[2] * 0.886227;\n\n    // l1\n    out[3] = src[3] * -1.023327; // kernel1 * basis1 = -1.023327;\n    out[4] = src[4] * -1.023327;\n    out[5] = src[5] * -1.023327;\n    out[6] = src[6] * 1.023327; // kernel1 * basis2 = 1.023327\n    out[7] = src[7] * 1.023327;\n    out[8] = src[8] * 1.023327;\n    out[9] = src[9] * -1.023327; // kernel1 * basis3 = -1.023327\n    out[10] = src[10] * -1.023327;\n    out[11] = src[11] * -1.023327;\n\n    // l2\n    out[12] = src[12] * 0.858086; // kernel2 * basis4 = 0.858086\n    out[13] = src[13] * 0.858086;\n    out[14] = src[14] * 0.858086;\n    out[15] = src[15] * -0.858086; // kernel2 * basis5 = -0.858086\n    out[16] = src[16] * -0.858086;\n    out[17] = src[17] * -0.858086;\n    out[18] = src[18] * 0.247708; // kernel2 * basis6 = 0.247708\n    out[19] = src[19] * 0.247708;\n    out[20] = src[20] * 0.247708;\n    out[21] = src[21] * -0.858086; // kernel2 * basis7 = -0.858086\n    out[22] = src[22] * -0.858086;\n    out[23] = src[23] * -0.858086;\n    out[24] = src[24] * 0.429042; // kernel2 * basis8 = 0.429042\n    out[25] = src[25] * 0.429042;\n    out[26] = src[26] * 0.429042;\n\n    return out;\n  }\n}\n", "import { Camera } from \"./Camera\";\nimport { Scene } from \"./Scene\";\n\n/**\n * Scene feature plug-in.\n * @deprecated\n */\nexport abstract class SceneFeature {\n  /**\n   * Callback before every scene update.\n   * @param scene - Scene\n   */\n  public preUpdate(scene: Scene): void {}\n\n  /**\n   * Callback after every scene update.\n   * @param scene - Scene\n   */\n  public postUpdate(scene: Scene): void {}\n\n  /**\n   * Callback before scene rendering.\n   * @param scene - Scene\n   * @param camera - Camera\n   */\n  public preRender(scene: Scene, camera: Camera): void {}\n\n  /**\n   * Callback after scene rendering.\n   * @param scene - Scene\n   * @param camera - Camera\n   */\n  public postRender(scene: Scene, camera: Camera): void {}\n\n  /**\n   * Callback after the scene is destroyed.\n   * @param scene - Scene\n   */\n  public destroy(scene: Scene): void {}\n}\n", "import { Matrix } from \"@oasis-engine/math\";\nimport { Component } from \"../Component\";\nimport { LightFeature } from \"./LightFeature\";\n\n/**\n * Light base class.\n */\nexport class Light extends Component {\n  /**\n   * Each type of light source is at most 10, beyond which it will not take effect.\n   * */\n  protected static _maxLight: number = 10;\n\n  private _viewMat: Matrix;\n  private _inverseViewMat: Matrix;\n\n  /**\n   * Mount to the current Scene.\n   * @internal\n   * @override\n   */\n  _onEnable() {\n    this.scene.findFeature(LightFeature).attachRenderLight(this);\n  }\n\n  /**\n   * Unmount from the current Scene.\n   * @internal\n   * @override\n   */\n  _onDisable() {\n    this.scene.findFeature(LightFeature).detachRenderLight(this);\n  }\n\n  /**\n   * View matrix.\n   */\n  get viewMatrix() {\n    if (!this._viewMat) this._viewMat = new Matrix();\n    Matrix.invert(this.entity.transform.worldMatrix, this._viewMat);\n    return this._viewMat;\n  }\n\n  /**\n   * Inverse view matrix.\n   */\n  get inverseViewMatrix() {\n    if (!this._inverseViewMat) this._inverseViewMat = new Matrix();\n    Matrix.invert(this.viewMatrix, this._inverseViewMat);\n    return this._inverseViewMat;\n  }\n}\n", "import { Color, Vector3 } from \"@oasis-engine/math\";\nimport { Shader } from \"../shader\";\nimport { ShaderData } from \"../shader/ShaderData\";\nimport { ShaderProperty } from \"../shader/ShaderProperty\";\nimport { Light } from \"./Light\";\n\n/**\n * Directional light.\n */\nexport class DirectLight extends Light {\n  private static _colorProperty: ShaderProperty = Shader.getPropertyByName(\"u_directLightColor\");\n  private static _directionProperty: ShaderProperty = Shader.getPropertyByName(\"u_directLightDirection\");\n\n  private static _combinedData = {\n    color: new Float32Array(3 * Light._maxLight),\n    direction: new Float32Array(3 * Light._maxLight)\n  };\n\n  /**\n   * @internal\n   */\n  static _updateShaderData(shaderData: ShaderData): void {\n    const data = DirectLight._combinedData;\n\n    shaderData.setFloatArray(DirectLight._colorProperty, data.color);\n    shaderData.setFloatArray(DirectLight._directionProperty, data.direction);\n  }\n\n  color: Color = new Color(1, 1, 1, 1);\n  intensity: number = 1;\n\n  private _forward: Vector3 = new Vector3();\n  private _lightColor: Color = new Color(1, 1, 1, 1);\n  private _reverseDirection: Vector3 = new Vector3();\n\n  /**\n   * Get direction.\n   */\n  get direction(): Vector3 {\n    this.entity.transform.getWorldForward(this._forward);\n    return this._forward;\n  }\n\n  /**\n   * Get the final light color.\n   */\n  get lightColor(): Color {\n    this._lightColor.r = this.color.r * this.intensity;\n    this._lightColor.g = this.color.g * this.intensity;\n    this._lightColor.b = this.color.b * this.intensity;\n    this._lightColor.a = this.color.a * this.intensity;\n    return this._lightColor;\n  }\n\n  /**\n   * Get the opposite direction of the directional light direction.\n   */\n  get reverseDirection(): Vector3 {\n    Vector3.scale(this.direction, -1, this._reverseDirection);\n    return this._reverseDirection;\n  }\n\n  /**\n   * @internal\n   */\n  _appendData(lightIndex: number): void {\n    const colorStart = lightIndex * 3;\n    const directionStart = lightIndex * 3;\n    const lightColor = this.lightColor;\n    const direction = this.direction;\n\n    const data = DirectLight._combinedData;\n\n    data.color[colorStart] = lightColor.r;\n    data.color[colorStart + 1] = lightColor.g;\n    data.color[colorStart + 2] = lightColor.b;\n    data.direction[directionStart] = direction.x;\n    data.direction[directionStart + 1] = direction.y;\n    data.direction[directionStart + 2] = direction.z;\n  }\n}\n", "import { Color, Vector3 } from \"@oasis-engine/math\";\nimport { Shader } from \"../shader\";\nimport { ShaderData } from \"../shader/ShaderData\";\nimport { ShaderProperty } from \"../shader/ShaderProperty\";\nimport { Light } from \"./Light\";\n\n/**\n * Point light.\n */\nexport class PointLight extends Light {\n  private static _colorProperty: ShaderProperty = Shader.getPropertyByName(\"u_pointLightColor\");\n  private static _positionProperty: ShaderProperty = Shader.getPropertyByName(\"u_pointLightPosition\");\n  private static _distanceProperty: ShaderProperty = Shader.getPropertyByName(\"u_pointLightDistance\");\n\n  private static _combinedData = {\n    color: new Float32Array(3 * Light._maxLight),\n    position: new Float32Array(3 * Light._maxLight),\n    distance: new Float32Array(Light._maxLight)\n  };\n\n  /**\n   * @internal\n   */\n  static _updateShaderData(shaderData: ShaderData): void {\n    const data = PointLight._combinedData;\n\n    shaderData.setFloatArray(PointLight._colorProperty, data.color);\n    shaderData.setFloatArray(PointLight._positionProperty, data.position);\n    shaderData.setFloatArray(PointLight._distanceProperty, data.distance);\n  }\n  /** Light color. */\n  color: Color = new Color(1, 1, 1, 1);\n  /** Light intensity. */\n  intensity: number = 1.0;\n  /** Defines a distance cutoff at which the light's intensity must be considered zero. */\n  distance: number = 100;\n\n  private _lightColor: Color = new Color(1, 1, 1, 1);\n\n  /**\n   * Get light position.\n   */\n  get position(): Vector3 {\n    return this.entity.transform.worldPosition;\n  }\n\n  /**\n   * Get the final light color.\n   */\n  get lightColor(): Color {\n    this._lightColor.r = this.color.r * this.intensity;\n    this._lightColor.g = this.color.g * this.intensity;\n    this._lightColor.b = this.color.b * this.intensity;\n    this._lightColor.a = this.color.a * this.intensity;\n    return this._lightColor;\n  }\n\n  /**\n   * @internal\n   */\n  _appendData(lightIndex: number): void {\n    const colorStart = lightIndex * 3;\n    const positionStart = lightIndex * 3;\n    const distanceStart = lightIndex;\n\n    const lightColor = this.lightColor;\n    const lightPosition = this.position;\n\n    const data = PointLight._combinedData;\n\n    data.color[colorStart] = lightColor.r;\n    data.color[colorStart + 1] = lightColor.g;\n    data.color[colorStart + 2] = lightColor.b;\n    data.position[positionStart] = lightPosition.x;\n    data.position[positionStart + 1] = lightPosition.y;\n    data.position[positionStart + 2] = lightPosition.z;\n    data.distance[distanceStart] = this.distance;\n  }\n}\n", "import { Color, Vector3 } from \"@oasis-engine/math\";\nimport { Shader } from \"../shader\";\nimport { ShaderData } from \"../shader/ShaderData\";\nimport { ShaderProperty } from \"../shader/ShaderProperty\";\nimport { Light } from \"./Light\";\n\n/**\n * Spot light.\n */\nexport class SpotLight extends Light {\n  private static _colorProperty: ShaderProperty = Shader.getPropertyByName(\"u_spotLightColor\");\n  private static _positionProperty: ShaderProperty = Shader.getPropertyByName(\"u_spotLightPosition\");\n  private static _directionProperty: ShaderProperty = Shader.getPropertyByName(\"u_spotLightDirection\");\n  private static _distanceProperty: ShaderProperty = Shader.getPropertyByName(\"u_spotLightDistance\");\n  private static _angleCosProperty: ShaderProperty = Shader.getPropertyByName(\"u_spotLightAngleCos\");\n  private static _penumbraCosProperty: ShaderProperty = Shader.getPropertyByName(\"u_spotLightPenumbraCos\");\n\n  private static _combinedData = {\n    color: new Float32Array(3 * Light._maxLight),\n    position: new Float32Array(3 * Light._maxLight),\n    direction: new Float32Array(3 * Light._maxLight),\n    distance: new Float32Array(Light._maxLight),\n    angleCos: new Float32Array(Light._maxLight),\n    penumbraCos: new Float32Array(Light._maxLight)\n  };\n\n  /**\n   * @internal\n   */\n  static _updateShaderData(shaderData: ShaderData): void {\n    const data = SpotLight._combinedData;\n\n    shaderData.setFloatArray(SpotLight._colorProperty, data.color);\n    shaderData.setFloatArray(SpotLight._positionProperty, data.position);\n    shaderData.setFloatArray(SpotLight._directionProperty, data.direction);\n    shaderData.setFloatArray(SpotLight._distanceProperty, data.distance);\n    shaderData.setFloatArray(SpotLight._angleCosProperty, data.angleCos);\n    shaderData.setFloatArray(SpotLight._penumbraCosProperty, data.penumbraCos);\n  }\n\n  /** Light color. */\n  color: Color = new Color(1, 1, 1, 1);\n  /** Light intensity. */\n  intensity: number = 1.0;\n  /** Defines a distance cutoff at which the light's intensity must be considered zero. */\n  distance: number = 100;\n  /** Angle, in radians, from centre of spotlight where falloff begins. */\n  angle: number = Math.PI / 6;\n  /** Angle, in radians, from falloff begins to ends. */\n  penumbra: number = Math.PI / 12;\n\n  private _forward: Vector3 = new Vector3();\n  private _lightColor: Color = new Color(1, 1, 1, 1);\n  private _inverseDirection: Vector3 = new Vector3();\n\n  /**\n   * Get light position.\n   */\n  get position(): Vector3 {\n    return this.entity.transform.worldPosition;\n  }\n\n  /**\n   * Get light direction.\n   */\n  get direction(): Vector3 {\n    this.entity.transform.getWorldForward(this._forward);\n    return this._forward;\n  }\n\n  /**\n   * Get the opposite direction of the spotlight.\n   */\n  get reverseDirection(): Vector3 {\n    Vector3.scale(this.direction, -1, this._inverseDirection);\n    return this._inverseDirection;\n  }\n\n  /**\n   * Get the final light color.\n   */\n  get lightColor(): Color {\n    this._lightColor.r = this.color.r * this.intensity;\n    this._lightColor.g = this.color.g * this.intensity;\n    this._lightColor.b = this.color.b * this.intensity;\n    this._lightColor.a = this.color.a * this.intensity;\n    return this._lightColor;\n  }\n\n  /**\n   * @internal\n   */\n  _appendData(lightIndex: number): void {\n    const colorStart = lightIndex * 3;\n    const positionStart = lightIndex * 3;\n    const directionStart = lightIndex * 3;\n    const distanceStart = lightIndex;\n    const penumbraCosStart = lightIndex;\n    const angleCosStart = lightIndex;\n\n    const color = this.lightColor;\n    const position = this.position;\n    const direction = this.direction;\n\n    const data = SpotLight._combinedData;\n\n    data.color[colorStart] = color.r;\n    data.color[colorStart + 1] = color.g;\n    data.color[colorStart + 2] = color.b;\n    data.position[positionStart] = position.x;\n    data.position[positionStart + 1] = position.y;\n    data.position[positionStart + 2] = position.z;\n    data.direction[directionStart] = direction.x;\n    data.direction[directionStart + 1] = direction.y;\n    data.direction[directionStart + 2] = direction.z;\n    data.distance[distanceStart] = this.distance;\n    data.angleCos[angleCosStart] = Math.cos(this.angle);\n    data.penumbraCos[penumbraCosStart] = Math.cos(this.angle + this.penumbra);\n  }\n}\n", "import { Logger } from \"../base/Logger\";\nimport { SceneFeature } from \"../SceneFeature\";\nimport { ShaderData } from \"../shader/ShaderData\";\nimport { DirectLight } from \"./DirectLight\";\nimport { Light } from \"./Light\";\nimport { PointLight } from \"./PointLight\";\nimport { SpotLight } from \"./SpotLight\";\n\n/**\n * Determine whether there are lights in the scene.\n * @returns Has light\n */\nexport function hasLight(): boolean {\n  return this.findFeature(LightFeature).visibleLights.length > 0;\n}\n\n/**\n * Light plug-in.\n */\nexport class LightFeature extends SceneFeature {\n  visibleLights: Light[];\n\n  constructor() {\n    super();\n    this.visibleLights = [];\n  }\n\n  /**\n   * Register a light object to the current scene.\n   * @param light\n   */\n  attachRenderLight(light: Light): void {\n    const index = this.visibleLights.indexOf(light);\n    if (index == -1) {\n      this.visibleLights.push(light);\n    } else {\n      Logger.warn(\"Light already attached.\");\n    }\n  }\n\n  /**\n   * Remove a light object from the current scene.\n   * @param light\n   */\n  detachRenderLight(light: Light): void {\n    const index = this.visibleLights.indexOf(light);\n    if (index != -1) {\n      this.visibleLights.splice(index, 1);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _updateShaderData(shaderData: ShaderData) {\n    /**\n     * ambientLight and envMapLight only use the last one in the scene\n     * */\n    let directLightCount = 0;\n    let pointLightCount = 0;\n    let spotLightCount = 0;\n\n    let lights = this.visibleLights;\n    for (let i = 0, len = lights.length; i < len; i++) {\n      const light = lights[i];\n      if (light instanceof DirectLight) {\n        light._appendData(directLightCount++);\n      } else if (light instanceof PointLight) {\n        light._appendData(pointLightCount++);\n      } else if (light instanceof SpotLight) {\n        light._appendData(spotLightCount++);\n      }\n    }\n\n    if (directLightCount) {\n      DirectLight._updateShaderData(shaderData);\n      shaderData.enableMacro(\"O3_DIRECT_LIGHT_COUNT\", directLightCount.toString());\n    } else {\n      shaderData.disableMacro(\"O3_DIRECT_LIGHT_COUNT\");\n    }\n\n    if (pointLightCount) {\n      PointLight._updateShaderData(shaderData);\n      shaderData.enableMacro(\"O3_POINT_LIGHT_COUNT\", pointLightCount.toString());\n    } else {\n      shaderData.disableMacro(\"O3_POINT_LIGHT_COUNT\");\n    }\n\n    if (spotLightCount) {\n      SpotLight._updateShaderData(shaderData);\n      shaderData.enableMacro(\"O3_SPOT_LIGHT_COUNT\", spotLightCount.toString());\n    } else {\n      shaderData.disableMacro(\"O3_SPOT_LIGHT_COUNT\");\n    }\n  }\n}\n", "import { Vector3 } from \"@oasis-engine/math\";\nimport { Background } from \"./Background\";\nimport { EngineObject, GLCapabilityType, Logger } from \"./base\";\nimport { Camera } from \"./Camera\";\nimport { Engine } from \"./Engine\";\nimport { Entity } from \"./Entity\";\nimport { FeatureManager } from \"./FeatureManager\";\nimport { Layer } from \"./Layer\";\nimport { AmbientLight } from \"./lighting/AmbientLight\";\nimport { LightFeature } from \"./lighting/LightFeature\";\nimport { SceneFeature } from \"./SceneFeature\";\nimport { ShaderDataGroup } from \"./shader/enums/ShaderDataGroup\";\nimport { ShaderData } from \"./shader/ShaderData\";\n\n/**\n * Scene.\n */\nexport class Scene extends EngineObject {\n  static sceneFeatureManager = new FeatureManager<SceneFeature>();\n\n  /** Scene name. */\n  name: string;\n  /** The background of the scene. */\n  readonly background: Background = new Background(this._engine);\n  /** Ambient light. */\n  readonly ambientLight: AmbientLight;\n  /** Scene-related shader data. */\n  readonly shaderData: ShaderData = new ShaderData(ShaderDataGroup.Scene);\n\n  /** @internal */\n  _activeCameras: Camera[] = [];\n  /** @internal */\n  _isActiveInEngine: boolean = false;\n\n  private _destroyed: boolean = false;\n  private _rootEntities: Entity[] = [];\n\n  /**\n   * Count of root entities.\n   */\n  get rootEntitiesCount(): number {\n    return this._rootEntities.length;\n  }\n\n  /**\n   * Root entity collection.\n   */\n  get rootEntities(): Readonly<Entity[]> {\n    return this._rootEntities;\n  }\n\n  /**\n   * Whether it's destroyed.\n   */\n  get destroyed(): boolean {\n    return this._destroyed;\n  }\n\n  /**\n   * Create scene.\n   * @param engine - Engine\n   * @param name - Name\n   */\n  constructor(engine: Engine, name?: string) {\n    super(engine);\n    this.name = name || \"\";\n\n    const shaderData = this.shaderData;\n    Scene.sceneFeatureManager.addObject(this);\n    shaderData._addRefCount(1);\n    this.ambientLight = new AmbientLight(this);\n  }\n\n  /**\n   * Create root entity.\n   * @param name - Entity name\n   * @returns Entity\n   */\n  createRootEntity(name?: string): Entity {\n    const entity = new Entity(this._engine, name);\n    this.addRootEntity(entity);\n    return entity;\n  }\n\n  /**\n   * Append an entity.\n   * @param entity - The root entity to add\n   */\n  addRootEntity(entity: Entity): void {\n    const isRoot = entity._isRoot;\n\n    // let entity become root\n    if (!isRoot) {\n      entity._isRoot = true;\n      entity._removeFromParent();\n    }\n\n    // add or remove from scene's rootEntities\n    const oldScene = entity._scene;\n    if (oldScene !== this) {\n      if (oldScene && isRoot) {\n        oldScene._removeEntity(entity);\n      }\n      this._rootEntities.push(entity);\n      Entity._traverseSetOwnerScene(entity, this);\n    } else if (!isRoot) {\n      this._rootEntities.push(entity);\n    }\n\n    // process entity active/inActive\n    if (this._isActiveInEngine) {\n      !entity._isActiveInHierarchy && entity._isActive && entity._processActive();\n    } else {\n      entity._isActiveInHierarchy && entity._processInActive();\n    }\n  }\n\n  /**\n   * Remove an entity.\n   * @param entity - The root entity to remove\n   */\n  removeRootEntity(entity: Entity): void {\n    if (entity._isRoot && entity._scene == this) {\n      this._removeEntity(entity);\n      this._isActiveInEngine && entity._processInActive();\n      Entity._traverseSetOwnerScene(entity, null);\n    }\n  }\n\n  /**\n   * Get root entity from index.\n   * @param index - Index\n   * @returns Entity\n   */\n  getRootEntity(index: number = 0): Entity | null {\n    return this._rootEntities[index];\n  }\n\n  /**\n   * Find entity globally by name.\n   * @param name - Entity name\n   * @returns Entity\n   */\n  findEntityByName(name: string): Entity | null {\n    const children = this._rootEntities;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      if (child.name === name) {\n        return child;\n      }\n    }\n\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      const entity = child.findByName(name);\n      if (entity) {\n        return entity;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Find entity globally by name,use \u2018/\u2019 symbol as a path separator.\n   * @param path - Entity's path\n   * @returns Entity\n   */\n  findEntityByPath(path: string): Entity | null {\n    const splits = path.split(\"/\").filter(Boolean);\n    for (let i = 0, n = this.rootEntitiesCount; i < n; i++) {\n      let findEntity = this.getRootEntity(i);\n      if (findEntity.name != splits[0]) continue;\n      for (let j = 1, m = splits.length; j < m; ++j) {\n        findEntity = Entity._findChildByName(findEntity, splits[j]);\n        if (!findEntity) break;\n      }\n      return findEntity;\n    }\n    return null;\n  }\n\n  /**\n   * Destroy this scene.\n   */\n  destroy(): void {\n    if (this._destroyed) {\n      return;\n    }\n    this._isActiveInEngine && (this._engine.sceneManager.activeScene = null);\n    Scene.sceneFeatureManager.callFeatureMethod(this, \"destroy\", [this]);\n    for (let i = 0, n = this.rootEntitiesCount; i < n; i++) {\n      this._rootEntities[i].destroy();\n    }\n    this._rootEntities.length = 0;\n    this._activeCameras.length = 0;\n    (Scene.sceneFeatureManager as any)._objects = [];\n    this.shaderData._addRefCount(-1);\n    this._destroyed = true;\n  }\n\n  /**\n   * @internal\n   */\n  _attachRenderCamera(camera: Camera): void {\n    const index = this._activeCameras.indexOf(camera);\n    if (index === -1) {\n      this._activeCameras.push(camera);\n    } else {\n      Logger.warn(\"Camera already attached.\");\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _detachRenderCamera(camera: Camera): void {\n    const index = this._activeCameras.indexOf(camera);\n    if (index !== -1) {\n      this._activeCameras.splice(index, 1);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _processActive(active: boolean): void {\n    this._isActiveInEngine = active;\n    const rootEntities = this._rootEntities;\n    for (let i = rootEntities.length - 1; i >= 0; i--) {\n      const entity = rootEntities[i];\n      if (entity._isActive) {\n        active ? entity._processActive() : entity._processInActive();\n      }\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _updateShaderData() {\n    const lightMgr = this.findFeature(LightFeature);\n\n    lightMgr._updateShaderData(this.shaderData);\n  }\n\n  private _removeEntity(entity: Entity): void {\n    const oldRootEntities = this._rootEntities;\n    oldRootEntities.splice(oldRootEntities.indexOf(entity), 1);\n  }\n\n  //-----------------------------------------@deprecated-----------------------------------\n  static registerFeature(Feature: new () => SceneFeature) {\n    Scene.sceneFeatureManager.registerFeature(Feature);\n  }\n\n  findFeature<T extends SceneFeature>(Feature: { new (): T }): T {\n    return Scene.sceneFeatureManager.findFeature(this, Feature) as T;\n  }\n\n  features: SceneFeature[] = [];\n}\n", "import { AssetPromise } from \"./asset/AssetPromise\";\nimport { Engine } from \"./Engine\";\nimport { Scene } from \"./Scene\";\n\n/**\n * Scene manager.\n */\nexport class SceneManager {\n  _activeScene: Scene;\n\n  /**\n   * Get the activated scene.\n   */\n  get activeScene(): Scene {\n    return this._activeScene;\n  }\n\n  set activeScene(scene: Scene) {\n    const oldScene = this._activeScene;\n    if (oldScene !== scene) {\n      oldScene && oldScene._processActive(false);\n      scene && scene._processActive(true);\n      this._activeScene = scene;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  constructor(public readonly engine: Engine) {}\n\n  /**\n   * Load and activate scene.\n   * @param url - the path of the scene\n   * @param destroyOldScene - whether to destroy old scene information\n   * @returns scene promise\n   */\n  loadScene(url: string, destroyOldScene: boolean = true): AssetPromise<Scene> {\n    const scenePromise = this.engine.resourceManager.load<Scene>(url);\n    scenePromise.then((scene: Scene) => {\n      const oldScene: Scene = this._activeScene;\n      this.activeScene = scene;\n      if (oldScene && destroyOldScene) {\n        oldScene.destroy();\n      }\n    });\n    return scenePromise;\n  }\n\n  /**\n   * Merge the source scene into the target scene.\n   * @remarks the global information of destScene will be used after the merge, and the lightingMap information will be merged.\n   * @param sourceScene - source scene\n   * @param destScene - target scene\n   */\n  mergeScenes(sourceScene: Scene, destScene: Scene): void {\n    const oldRootEntities = sourceScene.rootEntities;\n    for (let i: number = 0, n: number = oldRootEntities.length; i < n; i++) {\n      destScene.addRootEntity(oldRootEntities[i]);\n    }\n  }\n}\n", "import blinnPhongFs from \"../shaderlib/extra/blinn-phong.fs.glsl\";\nimport blinnPhongVs from \"../shaderlib/extra/blinn-phong.vs.glsl\";\nimport particleFs from \"../shaderlib/extra/particle.fs.glsl\";\nimport particleVs from \"../shaderlib/extra/particle.vs.glsl\";\nimport pbrFs from \"../shaderlib/extra/pbr.fs.glsl\";\nimport pbrVs from \"../shaderlib/extra/pbr.vs.glsl\";\nimport shadowMapFs from \"../shaderlib/extra/shadow-map.fs.glsl\";\nimport shadowMapVs from \"../shaderlib/extra/shadow-map.vs.glsl\";\nimport shadowFs from \"../shaderlib/extra/shadow.fs.glsl\";\nimport skyboxFs from \"../shaderlib/extra/skybox.fs.glsl\";\nimport skyboxVs from \"../shaderlib/extra/skybox.vs.glsl\";\nimport spriteMaskFs from \"../shaderlib/extra/sprite-mask.fs.glsl\";\nimport spriteMaskVs from \"../shaderlib/extra/sprite-mask.vs.glsl\";\nimport spriteFs from \"../shaderlib/extra/sprite.fs.glsl\";\nimport spriteVs from \"../shaderlib/extra/sprite.vs.glsl\";\nimport unlitFs from \"../shaderlib/extra/unlit.fs.glsl\";\nimport unlitVs from \"../shaderlib/extra/unlit.vs.glsl\";\nimport backgroundTextureVs from \"../shaderlib/extra/background-texture.vs.glsl\";\nimport backgroundTextureFs from \"../shaderlib/extra/background-texture.fs.glsl\";\nimport { Shader } from \"./Shader\";\n\n/**\n * Internal shader pool.\n * @internal\n */\nexport class ShaderPool {\n  static init(): void {\n    Shader.create(\"blinn-phong\", blinnPhongVs, blinnPhongFs);\n    Shader.create(\"pbr\", pbrVs, pbrFs);\n    Shader.create(\"unlit\", unlitVs, unlitFs);\n    Shader.create(\"shadow-map\", shadowMapVs, shadowMapFs);\n    Shader.create(\"shadow\", shadowMapVs, shadowFs);\n    Shader.create(\"skybox\", skyboxVs, skyboxFs);\n    Shader.create(\"particle-shader\", particleVs, particleFs);\n    Shader.create(\"SpriteMask\", spriteMaskVs, spriteMaskFs);\n    Shader.create(\"Sprite\", spriteVs, spriteFs);\n    Shader.create(\"background-texture\", backgroundTextureVs, backgroundTextureFs);\n  }\n}\n", "import { ShaderMacroCollection } from \"./ShaderMacroCollection\";\nimport { ShaderProgram } from \"./ShaderProgram\";\n\n/**\n * Shader program pool.\n * @internal\n */\nexport class ShaderProgramPool {\n  private _cacheHierarchy: number = 1;\n  private _cacheMap: object = Object.create(null);\n  private _lastQueryMap: Record<number, ShaderProgram>;\n  private _lastQueryKey: number;\n\n  /**\n   * Get shader program by macro collection.\n   * @param macros - macro collection\n   * @returns shader program\n   */\n  get(macros: ShaderMacroCollection): ShaderProgram | null {\n    let cacheMap = this._cacheMap;\n    const maskLength = macros._length;\n    if (maskLength > this._cacheHierarchy) {\n      this._resizeCacheMapHierarchy(cacheMap, 0, maskLength);\n    }\n\n    const mask = macros._mask;\n    const endIndex = macros._length - 1;\n    const maxEndIndex = this._cacheHierarchy - 1;\n    for (let i = 0; i < maxEndIndex; i++) {\n      const subMask = endIndex < i ? 0 : mask[i];\n      let subCacheShaders: object = cacheMap[subMask];\n      subCacheShaders || (cacheMap[subMask] = subCacheShaders = Object.create(null));\n      cacheMap = subCacheShaders;\n    }\n\n    const cacheKey = endIndex < maxEndIndex ? 0 : mask[maxEndIndex];\n    const shader = (<Record<number, ShaderProgram>>cacheMap)[cacheKey];\n    if (!shader) {\n      this._lastQueryKey = cacheKey;\n      this._lastQueryMap = <Record<number, ShaderProgram>>cacheMap;\n    }\n    return shader;\n  }\n\n  /**\n   * Cache the shader program.\n   *\n   * @remarks\n   * The method must return an empty value after calling get() to run normally.\n   *\n   * @param shaderProgram - shader program\n   */\n  cache(shaderProgram: ShaderProgram): void {\n    this._lastQueryMap[this._lastQueryKey] = shaderProgram;\n  }\n\n  private _resizeCacheMapHierarchy(cacheMap: object, hierarchy: number, resizeLength: number): void {\n    // only expand but not shrink.\n    const end = this._cacheHierarchy - 1;\n    if (hierarchy == end) {\n      for (let k in cacheMap) {\n        const shader: ShaderProgram = cacheMap[k];\n        for (let i = 0, n = resizeLength - end; i < n; i++) {\n          if (i == n - 1) {\n            cacheMap[0] = shader;\n          } else {\n            cacheMap = cacheMap[i == 0 ? k : 0] = Object.create(null);\n          }\n        }\n      }\n      this._cacheHierarchy = resizeLength;\n    } else {\n      for (let k in cacheMap) {\n        this._resizeCacheMapHierarchy(cacheMap[k], ++hierarchy, resizeLength);\n      }\n    }\n  }\n}\n", "import { SceneFeature } from \"../SceneFeature\";\nimport { Collider } from \"./Collider\";\n\nexport class ColliderFeature extends SceneFeature {\n  colliders: Collider[];\n  constructor() {\n    super();\n\n    this.colliders = [];\n  }\n\n  /**\n   * Add a collider component.\n   * @param collider - The collider component to add\n   */\n  attachCollider(collider: Collider) {\n    this.colliders.push(collider);\n  }\n\n  /**\n   * Remove a collider component.\n   * @param collider - The collider component to remove\n   */\n  detachCollider(collider: Collider) {\n    const index = this.colliders.indexOf(collider);\n    if (index != -1) {\n      this.colliders.splice(index, 1);\n    }\n  }\n}\n", "import { Component } from \"../Component\";\nimport { Entity } from \"../Entity\";\nimport { ColliderFeature } from \"./ColliderFeature\";\nimport { Ray, Vector3 } from \"@oasis-engine/math\";\nimport { HitResult } from \"../HitResult\";\n\n/**\n * Define collider data.\n */\nexport class Collider extends Component {\n  private static _ray = new Ray();\n\n  /**\n   * @param {Entity} entity\n   */\n  constructor(entity: Entity) {\n    super(entity);\n  }\n\n  _onEnable(): void {\n    this.scene.findFeature(ColliderFeature).attachCollider(this);\n  }\n\n  _onDisable(): void {\n    this.scene.findFeature(ColliderFeature).detachCollider(this);\n  }\n\n  protected _updateHitResult(\n    ray: Ray,\n    distance: number,\n    outHit: HitResult,\n    origin: Vector3,\n    isWorldRay: boolean = false\n  ) {\n    ray.getPoint(distance, outHit.point);\n    if (!isWorldRay) {\n      Vector3.transformCoordinate(outHit.point, this.entity.transform.worldMatrix, outHit.point);\n    }\n\n    outHit.distance = Vector3.distance(origin, outHit.point);\n    outHit.collider = this;\n  }\n\n  protected _getLocalRay(ray: Ray): Ray {\n    const worldToLocal = this.entity.getInvModelMatrix();\n    const outRay = Collider._ray;\n\n    Vector3.transformCoordinate(ray.origin, worldToLocal, outRay.origin);\n    Vector3.transformNormal(ray.direction, worldToLocal, outRay.direction);\n    outRay.direction.normalize();\n\n    return outRay;\n  }\n\n  /**\n   * @internal\n   */\n  _raycast(ray: Ray, hit: HitResult): boolean {\n    throw \"Error: use concrete type instead!\";\n  }\n}\n", "import { BoundingBox, Ray, Vector3 } from \"@oasis-engine/math\";\nimport { Entity } from \"../Entity\";\nimport { Collider } from \"./Collider\";\nimport { HitResult } from \"../HitResult\";\n\n/**\n * Axis Aligned Bound Box (AABB).\n * @extends Collider\n */\nexport class ABoxCollider extends Collider {\n  private static _tempVec3: Vector3 = new Vector3();\n  private static _tempBox: BoundingBox = new BoundingBox();\n\n  public boxMin: Vector3;\n  public boxMax: Vector3;\n\n  private _corners: Array<Vector3> = [];\n  private _cornerFlag: boolean = false;\n\n  /**\n   * Constructor of ABoxCollider.\n   * @param entity - Entity which the box belongs to\n   */\n  constructor(entity: Entity) {\n    super(entity);\n    this.boxMin = new Vector3(-0.5, -0.5, -0.5);\n    this.boxMax = new Vector3(0.5, 0.5, 0.5);\n  }\n\n  /**\n   * Set box from the minimum point of the box and the maximum point of the box.\n   * @param min - The minimum point of the box\n   * @param max - The maximum point of the box\n   */\n  setBoxMinMax(min: Vector3, max: Vector3) {\n    this.boxMin = min;\n    this.boxMax = max;\n\n    this._cornerFlag = true;\n  }\n\n  /**\n   * Set box from the center point and the size of the bounding box.\n   * @param center - The center point\n   * @param size - The size of the bounding box\n   */\n  setBoxCenterSize(center: Vector3, size: Vector3) {\n    const halfSize = ABoxCollider._tempVec3;\n    Vector3.scale(size, 0.5, halfSize);\n    Vector3.add(center, halfSize, this.boxMax);\n    Vector3.subtract(center, halfSize, this.boxMin);\n\n    this._cornerFlag = true;\n  }\n\n  /**\n   * Get the eight corners of this bounding box.\n   */\n  getCorners(): Vector3[] {\n    if (this._cornerFlag) {\n      const minX = this.boxMin.x;\n      const minY = this.boxMin.y;\n      const minZ = this.boxMin.z;\n      const w = this.boxMax.x - minX;\n      const h = this.boxMax.y - minY;\n      const d = this.boxMax.z - minZ;\n\n      if (this._corners.length === 0) {\n        for (let i = 0; i < 8; ++i) {\n          this._corners.push(new Vector3());\n        }\n      }\n\n      this._corners[0].setValue(minX + w, minY + h, minZ + d);\n      this._corners[1].setValue(minX, minY + h, minZ + d);\n      this._corners[2].setValue(minX, minY, minZ + d);\n      this._corners[3].setValue(minX + w, minY, minZ + d);\n      this._corners[4].setValue(minX + w, minY + h, minZ);\n      this._corners[5].setValue(minX, minY + h, minZ);\n      this._corners[6].setValue(minX, minY, minZ);\n      this._corners[7].setValue(minX + w, minY, minZ);\n\n      this._cornerFlag = false;\n    }\n\n    return this._corners;\n    // if (this._corners.length === 0) {\n    //   const minX = this.boxMin.x;\n    //   const minY = this.boxMin.y;\n    //   const minZ = this.boxMin.z;\n    //   const w = this.boxMax.x - minX;\n    //   const h = this.boxMax.y - minY;\n    //   const d = this.boxMax.z - minZ;\n\n    //   this._corners = [\n    //     new Vector3(minX + w, minY + h, minZ + d),\n    //     new Vector3(minX, minY + h, minZ + d),\n    //     new Vector3(minX, minY, minZ + d),\n    //     new Vector3(minX + w, minY, minZ + d),\n    //     new Vector3(minX + w, minY + h, minZ),\n    //     new Vector3(minX, minY + h, minZ),\n    //     new Vector3(minX, minY, minZ),\n    //     new Vector3(minX + w, minY, minZ)\n    //   ];\n    // }\n\n    // return this._corners;\n  }\n\n  /**\n   * @internal\n   */\n  _raycast(ray: Ray, hit: HitResult): boolean {\n    const localRay = this._getLocalRay(ray);\n\n    const boundingBox = ABoxCollider._tempBox;\n    this.boxMin.cloneTo(boundingBox.min);\n    this.boxMax.cloneTo(boundingBox.max);\n    const intersect = localRay.intersectBox(boundingBox);\n    if (intersect !== -1) {\n      this._updateHitResult(localRay, intersect, hit, ray.origin);\n      return true;\n    } else {\n      return false;\n    } // end of else\n  }\n}\n", "import { Collider } from \"./Collider\";\nimport { Plane, Ray, Vector3 } from \"@oasis-engine/math\";\nimport { Entity } from \"../Entity\";\nimport { HitResult } from \"../HitResult\";\n\n/**\n * Represents a plane in three dimensional space.\n */\nexport class PlaneCollider extends Collider {\n  private static _tempPlane: Plane = new Plane();\n\n  planePoint: Vector3;\n  normal: Vector3;\n\n  /**\n   * Constructor of PlaneCollider.\n   * @param entity - Entity which the plane belongs to\n   */\n  constructor(entity: Entity) {\n    super(entity);\n\n    /** The point through the plane. */\n    this.planePoint = new Vector3();\n\n    /** The normal direction of the plane. */\n    this.normal = new Vector3(0, 1, 0);\n  }\n\n  /**\n   * Set a plane from point and normal.\n   * @param  point - The point through the plane\n   * @param  normal - The normal direction of the plane\n   */\n  setPlane(point: Vector3, normal: Vector3) {\n    this.planePoint = point;\n    this.normal = normal;\n  }\n\n  /**\n   * @internal\n   */\n  _raycast(ray: Ray, hit: HitResult): boolean {\n    const localRay = this._getLocalRay(ray);\n\n    const boundingPlane = PlaneCollider._tempPlane;\n    this.normal.cloneTo(boundingPlane.normal);\n    boundingPlane.distance = -Vector3.dot(this.planePoint, boundingPlane.normal);\n    const intersect = localRay.intersectPlane(boundingPlane);\n    if (intersect !== -1) {\n      this._updateHitResult(localRay, intersect, hit, ray.origin);\n      return true;\n    } else {\n      return false;\n    } // end of else\n  }\n}\n", "import { Collider } from \"./Collider\";\nimport { BoundingSphere, Ray, Vector3 } from \"@oasis-engine/math\";\nimport { Entity } from \"../Entity\";\nimport { HitResult } from \"../HitResult\";\n\n/**\n * A bounding sphere.\n */\nexport class ASphereCollider extends Collider {\n  private static _tempSphere: BoundingSphere = new BoundingSphere();\n\n  center: Vector3;\n  radius: number;\n\n  /**\n   * Constructor of ASphereCollider.\n   * @param  entity - Entity which the sphere belongs to\n   */\n  constructor(entity: Entity) {\n    super(entity);\n\n    /** The center point of the sphere. */\n    this.center = new Vector3();\n\n    /** The radius of the sphere. */\n    this.radius = 1;\n  }\n\n  /**\n   * Set the center and radius of the sphere.\n   * @param center - The center point of the sphere\n   * @param radius - The radius of the sphere\n   */\n  setSphere(center: Vector3, radius: number) {\n    this.center = center;\n    this.radius = radius;\n  }\n\n  /**\n   * @internal\n   */\n  _raycast(ray: Ray, hit: HitResult): boolean {\n    const { transform } = this.entity;\n    const boundingSphere = ASphereCollider._tempSphere;\n    Vector3.transformCoordinate(this.center, transform.worldMatrix, boundingSphere.center);\n    const lossyScale = transform.lossyWorldScale;\n    boundingSphere.radius = this.radius * Math.max(lossyScale.x, lossyScale.y, lossyScale.z);\n    const intersect = ray.intersectSphere(boundingSphere);\n    if (intersect !== -1) {\n      this._updateHitResult(ray, intersect, hit, ray.origin, true);\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n", "import { Vector3 } from \"@oasis-engine/math\";\nimport { Entity } from \"../Entity\";\nimport { ABoxCollider } from \"./ABoxCollider\";\n\nexport class BoxCollider extends ABoxCollider {\n  private _center: Vector3 = new Vector3();\n  private _size: Vector3 = new Vector3();\n  private isShowCollider: boolean = true;\n\n  get center(): Vector3 {\n    return this._center;\n  }\n\n  set center(value: Vector3) {\n    this._center = value;\n    this.setBoxCenterSize(this._center, this._size);\n  }\n\n  get size(): Vector3 {\n    return this._size;\n  }\n\n  set size(value: Vector3) {\n    this._size = value;\n    this.setBoxCenterSize(this._center, this._size);\n  }\n\n  constructor(entity: Entity) {\n    super(entity);\n    this.center = this.center;\n    this.size = this.size;\n    this.isShowCollider = this.isShowCollider;\n  }\n}\n", "import { Vector3 } from \"@oasis-engine/math\";\nimport { Entity } from \"../Entity\";\nimport { ASphereCollider } from \"./ASphereCollider\";\n\nexport class SphereCollider extends ASphereCollider {\n  private __center: Vector3 = new Vector3();\n  private __radius: number = 1.0;\n  private isShowCollider: boolean = true;\n\n  get _center(): Vector3 {\n    return this.__center;\n  }\n\n  set _center(value: Vector3) {\n    this.__center = value;\n    this.setSphere(this.__center, this.__radius);\n  }\n\n  get _radius() {\n    return this.__radius;\n  }\n\n  set _radius(value: number) {\n    this.__radius = value;\n    this.setSphere(this.__center, this.__radius);\n  }\n\n  constructor(entity: Entity) {\n    super(entity);\n\n    this._center = this._center;\n    this._radius = this._radius;\n    this.isShowCollider = this.isShowCollider;\n  }\n}\n", "import { ColliderFeature } from \"./ColliderFeature\";\nimport { Scene } from \"../Scene\";\nScene.registerFeature(ColliderFeature);\n\n//-- colliders\nexport { ColliderFeature };\nexport { Collider as ACollider } from \"./Collider\";\nexport { ABoxCollider } from \"./ABoxCollider\";\nexport { PlaneCollider } from \"./PlaneCollider\";\nexport { ASphereCollider } from \"./ASphereCollider\";\nexport { BoxCollider } from \"./BoxCollider\";\nexport { SphereCollider } from \"./SphereCollider\";\n", "import { Collider } from \"./collider/Collider\";\nimport { Vector3 } from \"@oasis-engine/math\";\n\n/**\n * Structure used to get information back from a raycast or a sweep.\n */\nexport class HitResult {\n  /** The collider that was hit. */\n  collider: Collider = null;\n  /** The distance from the origin to the hit point. */\n  distance: number = 0;\n  /** The hit point of the collider that was hit in world space. */\n  point: Vector3 = new Vector3();\n  /** The hit normal of the collider that was hit in world space. */\n  normal: Vector3 = new Vector3();\n}\n", "import { Ray } from \"@oasis-engine/math\";\nimport { Layer } from \"./Layer\";\nimport { ColliderFeature } from \"./collider\";\nimport { Engine } from \"./Engine\";\nimport { HitResult } from \"./HitResult\";\n\n/*\n * Manager for physical scenes.\n */\nexport class PhysicsManager {\n  private static _currentHit: HitResult = new HitResult();\n\n  private _engine: Engine;\n\n  /**\n   * @internal\n   */\n  constructor(engine: Engine) {\n    this._engine = engine;\n  }\n\n  /**\n   * Casts a ray through the Scene and returns the first hit.\n   * @param ray - The ray\n   * @returns Returns true if the ray intersects with a Collider, otherwise false.\n   */\n  raycast(ray: Ray): Boolean;\n\n  /**\n   * Casts a ray through the Scene and returns the first hit.\n   * @param ray - The ray\n   * @param outHitResult - If true is returned, outHitResult will contain more detailed collision information\n   * @returns Returns true if the ray intersects with a Collider, otherwise false.\n   */\n  raycast(ray: Ray, outHitResult: HitResult): Boolean;\n\n  /**\n   * Casts a ray through the Scene and returns the first hit.\n   * @param ray - The ray\n   * @param distance - The max distance the ray should check\n   * @returns Returns true if the ray intersects with a Collider, otherwise false.\n   */\n  raycast(ray: Ray, distance: number): Boolean;\n\n  /**\n   * Casts a ray through the Scene and returns the first hit.\n   * @param ray - The ray\n   * @param distance - The max distance the ray should check\n   * @param outHitResult - If true is returned, outHitResult will contain more detailed collision information\n   * @returns Returns true if the ray intersects with a Collider, otherwise false.\n   */\n  raycast(ray: Ray, distance: number, outHitResult: HitResult): Boolean;\n\n  /**\n   * Casts a ray through the Scene and returns the first hit.\n   * @param ray - The ray\n   * @param distance - The max distance the ray should check\n   * @param layerMask - Layer mask that is used to selectively ignore Colliders when casting\n   * @returns Returns true if the ray intersects with a Collider, otherwise false.\n   */\n  raycast(ray: Ray, distance: number, layerMask: Layer): Boolean;\n\n  /**\n   * Casts a ray through the Scene and returns the first hit.\n   * @param ray - The ray\n   * @param distance - The max distance the ray should check\n   * @param layerMask - Layer mask that is used to selectively ignore Colliders when casting\n   * @param outHitResult - If true is returned, outHitResult will contain more detailed collision information\n   * @returns Returns true if the ray intersects with a Collider, otherwise false.\n   */\n  raycast(ray: Ray, distance: number, layerMask: Layer, outHitResult: HitResult): Boolean;\n\n  raycast(\n    ray: Ray,\n    distanceOrResult?: number | HitResult,\n    layerMaskOrResult?: Layer | HitResult,\n    outHitResult?: HitResult\n  ): Boolean {\n    const cf = this._engine.sceneManager.activeScene.findFeature(ColliderFeature);\n    const colliders = cf.colliders;\n\n    let hitResult: HitResult;\n\n    let distance = Number.MAX_VALUE;\n    if (typeof distanceOrResult === \"number\") {\n      distance = distanceOrResult;\n    } else if (distanceOrResult != undefined) {\n      hitResult = distanceOrResult;\n    }\n\n    let layerMask = Layer.Everything;\n    if (typeof layerMaskOrResult === \"number\") {\n      layerMask = layerMaskOrResult;\n    } else if (layerMaskOrResult != undefined) {\n      hitResult = layerMaskOrResult;\n    }\n\n    if (outHitResult) {\n      hitResult = outHitResult;\n    }\n\n    let isHit = false;\n    const curHit = PhysicsManager._currentHit;\n    for (let i = 0, len = colliders.length; i < len; i++) {\n      const collider = colliders[i];\n\n      if (!(collider.entity.layer & layerMask)) {\n        continue;\n      }\n\n      if (collider._raycast(ray, curHit)) {\n        isHit = true;\n        if (curHit.distance < distance) {\n          if (hitResult) {\n            curHit.normal.cloneTo(hitResult.normal);\n            curHit.point.cloneTo(hitResult.point);\n            hitResult.distance = curHit.distance;\n            hitResult.collider = curHit.collider;\n          } else {\n            return true;\n          }\n          distance = curHit.distance;\n        }\n      }\n    }\n\n    if (!isHit && hitResult) {\n      hitResult.collider = null;\n      hitResult.distance = 0;\n      hitResult.point.setValue(0, 0, 0);\n      hitResult.normal.setValue(0, 0, 0);\n    }\n    return isHit;\n  }\n}\n", "import { ResourceManager } from \"./asset/ResourceManager\";\nimport { Event, EventDispatcher, Logger, Time } from \"./base\";\nimport { Canvas } from \"./Canvas\";\nimport { ComponentsManager } from \"./ComponentsManager\";\nimport { EngineFeature } from \"./EngineFeature\";\nimport { Entity } from \"./Entity\";\nimport { FeatureManager } from \"./FeatureManager\";\nimport { RenderQueueType } from \"./material/enums/RenderQueueType\";\nimport { Material } from \"./material/Material\";\nimport { IHardwareRenderer } from \"./renderingHardwareInterface/IHardwareRenderer\";\nimport { ClassPool } from \"./RenderPipeline/ClassPool\";\nimport { RenderContext } from \"./RenderPipeline/RenderContext\";\nimport { RenderElement } from \"./RenderPipeline/RenderElement\";\nimport { SpriteElement } from \"./RenderPipeline/SpriteElement\";\nimport { SpriteMaskElement } from \"./RenderPipeline/SpriteMaskElement\";\nimport { SpriteMaskManager } from \"./RenderPipeline/SpriteMaskManager\";\nimport { Scene } from \"./Scene\";\nimport { SceneManager } from \"./SceneManager\";\nimport { BlendFactor } from \"./shader/enums/BlendFactor\";\nimport { BlendOperation } from \"./shader/enums/BlendOperation\";\nimport { ColorWriteMask } from \"./shader/enums/ColorWriteMask\";\nimport { CullMode } from \"./shader/enums/CullMode\";\nimport { Shader } from \"./shader/Shader\";\nimport { ShaderPool } from \"./shader/ShaderPool\";\nimport { ShaderProgramPool } from \"./shader/ShaderProgramPool\";\nimport { RenderState } from \"./shader/state/RenderState\";\nimport { Texture2D, TextureCubeFace, TextureCubeMap, TextureFormat } from \"./texture\";\nimport { PhysicsManager } from \"./PhysicsManager\";\nimport { ModelMesh, PrimitiveMesh } from \"./mesh\";\nimport { CompareFunction } from \"./shader\";\n\n/** TODO: delete */\nconst engineFeatureManager = new FeatureManager<EngineFeature>();\nShaderPool.init();\n\n/**\n * Engine.\n */\nexport class Engine extends EventDispatcher {\n  /** Physics manager of Engine. */\n  readonly physicsManager: PhysicsManager = new PhysicsManager(this);\n\n  _componentsManager: ComponentsManager = new ComponentsManager();\n  _hardwareRenderer: IHardwareRenderer;\n  _lastRenderState: RenderState = new RenderState();\n  _renderElementPool: ClassPool<RenderElement> = new ClassPool(RenderElement);\n  _spriteElementPool: ClassPool<SpriteElement> = new ClassPool(SpriteElement);\n  _spriteMaskElementPool: ClassPool<SpriteMaskElement> = new ClassPool(SpriteMaskElement);\n  _spriteDefaultMaterial: Material;\n  _spriteMaskDefaultMaterial: Material;\n  _renderContext: RenderContext = new RenderContext();\n\n  /* @internal */\n  _whiteTexture2D: Texture2D;\n  /* @internal */\n  _whiteTextureCube: TextureCubeMap;\n  /* @internal */\n  _backgroundTextureMaterial: Material;\n  /* @internal */\n  _backgroundTextureMesh: ModelMesh;\n  /* @internal */\n  _renderCount: number = 0;\n  /* @internal */\n  _shaderProgramPools: ShaderProgramPool[] = [];\n  /** @internal */\n  _spriteMaskManager: SpriteMaskManager;\n\n  protected _canvas: Canvas;\n  private _resourceManager: ResourceManager = new ResourceManager(this);\n  private _sceneManager: SceneManager = new SceneManager(this);\n  private _vSyncCount: number = 1;\n  private _targetFrameRate: number = 60;\n  private _time: Time = new Time();\n  private _isPaused: boolean = true;\n  private _requestId: number;\n  private _timeoutId: number;\n  private _vSyncCounter: number = 1;\n  private _targetFrameInterval: number = 1000 / 60;\n\n  private _animate = () => {\n    if (this._vSyncCount) {\n      this._requestId = requestAnimationFrame(this._animate);\n      if (this._vSyncCounter++ % this._vSyncCount === 0) {\n        this.update();\n        this._vSyncCounter = 1;\n      }\n    } else {\n      this._timeoutId = window.setTimeout(this._animate, this._targetFrameInterval);\n      this.update();\n    }\n  };\n\n  /**\n   * The canvas to use for rendering.\n   */\n  get canvas(): Canvas {\n    return this._canvas;\n  }\n\n  /**\n   * Get the resource manager.\n   */\n  get resourceManager(): ResourceManager {\n    return this._resourceManager;\n  }\n\n  /**\n   * Get the scene manager.\n   */\n  get sceneManager(): SceneManager {\n    return this._sceneManager;\n  }\n\n  /**\n   * Get the Time class.\n   */\n  get time(): Time {\n    return this._time;\n  }\n\n  /**\n   * Whether the engine is paused.\n   */\n  get isPaused(): boolean {\n    return this._isPaused;\n  }\n\n  /**\n   * The number of vertical synchronization means the number of vertical blanking for one frame.\n   * @remarks 0 means that the vertical synchronization is turned off.\n   */\n  get vSyncCount(): number {\n    return this._vSyncCount;\n  }\n\n  set vSyncCount(value: number) {\n    this._vSyncCount = Math.max(0, Math.floor(value));\n  }\n\n  /**\n   * Set the target frame rate you want to achieve.\n   * @remarks\n   * It only takes effect when vSyncCount = 0 (ie, vertical synchronization is turned off).\n   * The larger the value, the higher the target frame rate, Number.POSITIVE_INFINITY represents the infinite target frame rate.\n   */\n  get targetFrameRate(): number {\n    return this._targetFrameRate;\n  }\n\n  set targetFrameRate(value: number) {\n    value = Math.max(0.000001, value);\n    this._targetFrameRate = value;\n    this._targetFrameInterval = 1000 / value;\n  }\n\n  /**\n   * Create engine.\n   * @param canvas - The canvas to use for rendering\n   * @param hardwareRenderer - Graphics API renderer\n   */\n  constructor(canvas: Canvas, hardwareRenderer: IHardwareRenderer) {\n    super(null);\n    this._hardwareRenderer = hardwareRenderer;\n    this._hardwareRenderer.init(canvas);\n    this._canvas = canvas;\n    // @todo delete\n    engineFeatureManager.addObject(this);\n    this._sceneManager.activeScene = new Scene(this, \"DefaultScene\");\n\n    this._spriteMaskManager = new SpriteMaskManager(this);\n    this._spriteDefaultMaterial = this._createSpriteMaterial();\n    this._spriteMaskDefaultMaterial = this._createSpriteMaskMaterial();\n\n    const whitePixel = new Uint8Array([255, 255, 255, 255]);\n\n    const whiteTexture2D = new Texture2D(this, 1, 1, TextureFormat.R8G8B8A8, false);\n    whiteTexture2D.setPixelBuffer(whitePixel);\n    whiteTexture2D.isGCIgnored = true;\n\n    const whiteTextureCube = new TextureCubeMap(this, 1, TextureFormat.R8G8B8A8, false);\n    whiteTextureCube.setPixelBuffer(TextureCubeFace.PositiveX, whitePixel);\n    whiteTextureCube.setPixelBuffer(TextureCubeFace.NegativeX, whitePixel);\n    whiteTextureCube.setPixelBuffer(TextureCubeFace.PositiveY, whitePixel);\n    whiteTextureCube.setPixelBuffer(TextureCubeFace.NegativeY, whitePixel);\n    whiteTextureCube.setPixelBuffer(TextureCubeFace.PositiveZ, whitePixel);\n    whiteTextureCube.setPixelBuffer(TextureCubeFace.NegativeZ, whitePixel);\n    whiteTextureCube.isGCIgnored = true;\n\n    this._whiteTexture2D = whiteTexture2D;\n    this._whiteTextureCube = whiteTextureCube;\n\n    this._backgroundTextureMaterial = new Material(this, Shader.find(\"background-texture\"));\n    this._backgroundTextureMaterial.isGCIgnored = true;\n    this._backgroundTextureMaterial.renderState.depthState.compareFunction = CompareFunction.LessEqual;\n\n    this._backgroundTextureMesh = PrimitiveMesh.createPlane(this, 2, 2, 1, 1, false);\n    this._backgroundTextureMesh.isGCIgnored = true;\n  }\n\n  /**\n   * Create an entity.\n   * @param name - The name of the entity\n   * @returns Entity\n   */\n  createEntity(name?: string): Entity {\n    return new Entity(this, name);\n  }\n\n  /**\n   * Pause the engine.\n   */\n  pause(): void {\n    this._isPaused = true;\n    cancelAnimationFrame(this._requestId);\n    clearTimeout(this._timeoutId);\n  }\n\n  /**\n   * Resume the engine.\n   */\n  resume(): void {\n    if (!this._isPaused) return;\n    this._isPaused = false;\n    this.time.reset();\n    requestAnimationFrame(this._animate);\n  }\n\n  /**\n   * Update the engine loop manually. If you call engine.run(), you generally don't need to call this function.\n   */\n  update(): void {\n    const time = this._time;\n    const deltaTime = time.deltaTime;\n\n    time.tick();\n    this._renderElementPool.resetPool();\n    this._spriteElementPool.resetPool();\n    this._spriteMaskElementPool.resetPool();\n\n    engineFeatureManager.callFeatureMethod(this, \"preTick\", [this, this._sceneManager._activeScene]);\n\n    const scene = this._sceneManager._activeScene;\n    const componentsManager = this._componentsManager;\n    if (scene) {\n      componentsManager.callScriptOnStart();\n      componentsManager.callScriptOnUpdate(deltaTime);\n      componentsManager.callAnimationUpdate(deltaTime);\n      componentsManager.callScriptOnLateUpdate(deltaTime);\n\n      this._render(scene);\n    }\n\n    this._componentsManager.callComponentDestroy();\n\n    engineFeatureManager.callFeatureMethod(this, \"postTick\", [this, this._sceneManager._activeScene]);\n  }\n\n  /**\n   * Execution engine loop.\n   */\n  run(): void {\n    // @todo: delete\n    engineFeatureManager.callFeatureMethod(this, \"preLoad\", [this]);\n    this.resume();\n    this.trigger(new Event(\"run\", this));\n  }\n\n  /**\n   * Destroy engine.\n   */\n  destroy(): void {\n    if (this._sceneManager) {\n      this._whiteTexture2D.destroy(true);\n      this._whiteTextureCube.destroy(true);\n\n      this.trigger(new Event(\"shutdown\", this));\n      engineFeatureManager.callFeatureMethod(this, \"shutdown\", [this]);\n\n      // -- cancel animation\n      this.pause();\n\n      this._animate = null;\n\n      this._sceneManager._activeScene.destroy();\n      this._resourceManager.gc();\n      // If engine destroy, callComponentDestroy() maybe will not call anymore.\n      this._componentsManager.callComponentDestroy();\n      this._sceneManager = null;\n      this._resourceManager = null;\n\n      this._canvas = null;\n\n      this.features = [];\n      this._time = null;\n\n      // delete mask manager\n      this._spriteMaskManager.destroy();\n\n      // todo: delete\n      (engineFeatureManager as any)._objects = [];\n      this.removeAllEventListeners();\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _getShaderProgramPool(shader: Shader): ShaderProgramPool {\n    const index = shader._shaderId;\n    const shaderProgramPools = this._shaderProgramPools;\n    let pool = shaderProgramPools[index];\n    if (!pool) {\n      const length = index + 1;\n      if (length < shaderProgramPools.length) {\n        shaderProgramPools.length = length;\n      }\n      shaderProgramPools[index] = pool = new ShaderProgramPool();\n    }\n    return pool;\n  }\n\n  _render(scene: Scene): void {\n    const cameras = scene._activeCameras;\n    const componentsManager = this._componentsManager;\n    const deltaTime = this.time.deltaTime;\n    componentsManager.callRendererOnUpdate(deltaTime);\n\n    scene._updateShaderData();\n\n    if (cameras.length > 0) {\n      // Sort on priority\n      //@ts-ignore\n      cameras.sort((camera1, camera2) => camera1.priority - camera2.priority);\n      for (let i = 0, l = cameras.length; i < l; i++) {\n        const camera = cameras[i];\n        const cameraEntity = camera.entity;\n        if (camera.enabled && cameraEntity.isActiveInHierarchy) {\n          componentsManager.callCameraOnBeginRender(camera);\n          Scene.sceneFeatureManager.callFeatureMethod(scene, \"preRender\", [scene, camera]); //TODO: will be removed\n          camera.render();\n          Scene.sceneFeatureManager.callFeatureMethod(scene, \"postRender\", [scene, camera]); //TODO: will be removed\n          componentsManager.callCameraOnEndRender(camera);\n        }\n      }\n    } else {\n      Logger.debug(\"NO active camera.\");\n    }\n  }\n\n  private _createSpriteMaterial(): Material {\n    const material = new Material(this, Shader.find(\"Sprite\"));\n    const renderState = material.renderState;\n    const target = renderState.blendState.targetBlendState;\n    target.enabled = true;\n    target.sourceColorBlendFactor = BlendFactor.SourceAlpha;\n    target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;\n    target.sourceAlphaBlendFactor = BlendFactor.One;\n    target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;\n    target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;\n    renderState.depthState.writeEnabled = false;\n    renderState.rasterState.cullMode = CullMode.Off;\n    material.renderQueueType = RenderQueueType.Transparent;\n    material.isGCIgnored = true;\n    return material;\n  }\n\n  private _createSpriteMaskMaterial(): Material {\n    const material = new Material(this, Shader.find(\"SpriteMask\"));\n    const renderState = material.renderState;\n    renderState.blendState.targetBlendState.colorWriteMask = ColorWriteMask.None;\n    renderState.rasterState.cullMode = CullMode.Off;\n    renderState.stencilState.enabled = true;\n    renderState.depthState.enabled = false;\n    material.isGCIgnored = true;\n    return material;\n  }\n\n  //-----------------------------------------@deprecated-----------------------------------\n\n  findFeature(Feature) {\n    return engineFeatureManager.findFeature(this, Feature);\n  }\n\n  static registerFeature(Feature: new () => EngineFeature): void {\n    engineFeatureManager.registerFeature(Feature);\n  }\n\n  features: EngineFeature[] = [];\n}\n", "/**\n * System info.\n */\nexport class SystemInfo {\n  /**\n   * The pixel ratio of the device.\n   */\n  static get devicePixelRatio(): number {\n    return window.devicePixelRatio;\n  }\n\n  /**\n   * @internal\n   */\n  static _isIos(): boolean {\n    if (!window) {\n      return false;\n    }\n\n    const ua = window.navigator.userAgent.toLocaleLowerCase();\n    return /iphone|ipad|ipod/.test(ua);\n  }\n}\n", "import { Engine } from \"./Engine\";\nimport { Scene } from \"./Scene\";\n\n/**\n * Engine feature plug-in.\n * @deprecated\n */\nexport class EngineFeature {\n  /**\n   * Callback before the engine main loop runs,used to load resource.\n   * @param engine - Engine\n   */\n  public preLoad(engine: Engine): void {}\n\n  /**\n   * Callback before every engine tick.\n   * @param engine - Engine\n   * @param currentScene - Scene\n   */\n  public preTick(engine: Engine, currentScene: Scene): void {}\n\n  /**\n   * Callback after every engine tick.\n   * @param  engine - Engine\n   */\n  public postTick(engine: Engine, currentScene: Scene): void {}\n\n  /**\n   * Callback after the engine is destroyed.\n   * @param engine - Engine\n   */\n  public shutdown(engine: Engine): void {}\n}\n", "import { Camera } from \"./Camera\";\nimport { ignoreClone } from \"./clone/CloneManager\";\nimport { Component } from \"./Component\";\nimport { ACollider } from \"./collider\";\n/**\n * Script class, used for logic writing.\n */\nexport class Script extends Component {\n  /** @internal */\n  @ignoreClone\n  _started: boolean = false;\n  /** @internal */\n  @ignoreClone\n  _onStartIndex: number = -1;\n  /** @internal */\n  @ignoreClone\n  _onUpdateIndex: number = -1;\n  /** @internal */\n  @ignoreClone\n  _onLateUpdateIndex: number = -1;\n  /** @internal */\n  @ignoreClone\n  _onPreRenderIndex: number = -1;\n  /** @internal */\n  @ignoreClone\n  _onPostRenderIndex: number = -1;\n  @ignoreClone\n  _entityCacheIndex: number = -1;\n\n  /**\n   * Called when be enabled first time, only once.\n   */\n  onAwake(): void {}\n\n  /**\n   * Called when be enabled.\n   */\n  onEnable(): void {}\n\n  /**\n   * Called before the frame-level loop start for the first time, only once.\n   */\n  onStart(): void {}\n\n  /**\n   * The main loop, called frame by frame.\n   * @param deltaTime - The deltaTime when the script update.\n   */\n  onUpdate(deltaTime: number): void {}\n\n  /**\n   * Called after the onUpdate finished, called frame by frame.\n   * @param deltaTime - The deltaTime when the script update.\n   */\n  onLateUpdate(deltaTime: number): void {}\n\n  /**\n   * Called before camera rendering, called per camera.\n   * @param camera - Current camera.\n   */\n  onBeginRender(camera: Camera): void {}\n\n  /**\n   * Called after camera rendering, called per camera.\n   * @param camera - Current camera.\n   */\n  onEndRender(camera: Camera): void {}\n\n  /**\n   * Called when the collision enter.\n   * @param other Collider\n   */\n  onTriggerEnter(other: ACollider): void {}\n\n  /**\n   * Called when the collision stay.\n   * @remarks onTriggerStay is called every frame while the collision stay.\n   * @param other Collider\n   */\n  onTriggerStay(other: ACollider): void {}\n\n  /**\n   * Called when the collision exit.\n   * @param other Collider\n   */\n  onTriggerExit(other: ACollider): void {}\n\n  /**\n   * Called when the pointer is down while over the Collider.\n   */\n  onPointerDown(): void {}\n\n  /**\n   * Called when the pointer is up while over the Collider.\n   */\n  onPointerUp(): void {}\n\n  /**\n   * Called when the pointer is down and up with the same collider.\n   */\n  onPointerClick(): void {}\n\n  /**\n   * Called when the pointer is enters the Collider.\n   */\n  onPointerEnter(): void {}\n\n  /**\n   * Called when the pointer is no longer over the Collider.\n   */\n  onPointerExit(): void {}\n\n  /**\n   * Called when the pointer is down while over the Collider and is still holding down.\n   * @remarks onPointerDrag is called every frame while the pointer is down.\n   */\n  onPointerDrag(): void {}\n\n  /**\n   * Called when be disabled.\n   */\n  onDisable(): void {}\n\n  /**\n   * Called at the end of the destroyed frame.\n   */\n  onDestroy(): void {}\n\n  /**\n   * @internal\n   * @inheritDoc\n   * @override\n   */\n  _onAwake(): void {\n    this.onAwake();\n  }\n\n  /**\n   * @internal\n   * @inheritDoc\n   * @override\n   */\n  _onEnable(): void {\n    const componentsManager = this.engine._componentsManager;\n    const prototype = Script.prototype;\n    if (!this._started) {\n      componentsManager.addOnStartScript(this);\n    }\n    if (this.onUpdate !== prototype.onUpdate) {\n      componentsManager.addOnUpdateScript(this);\n    }\n    if (this.onLateUpdate !== prototype.onLateUpdate) {\n      componentsManager.addOnLateUpdateScript(this);\n    }\n    this._entity._addScript(this);\n    this.onEnable();\n  }\n\n  /**\n   * @internal\n   * @inheritDoc\n   * @override\n   */\n  _onDisable(): void {\n    const componentsManager = this.engine._componentsManager;\n    // Use \"xxIndex\" is more safe.\n    // When call onDisable it maybe it still not in script queue,for example write \"entity.isActive = false\" in onWake().\n    if (this._onStartIndex !== -1) {\n      componentsManager.removeOnStartScript(this);\n    }\n    if (this._onUpdateIndex !== -1) {\n      componentsManager.removeOnUpdateScript(this);\n    }\n    if (this._onLateUpdateIndex !== -1) {\n      componentsManager.removeOnLateUpdateScript(this);\n    }\n    if (this._entityCacheIndex !== -1) {\n      this._entity._removeScript(this);\n    }\n    this.onDisable();\n  }\n\n  /**\n   * @internal\n   * @inheritDoc\n   * @override\n   */\n  _onDestroy(): void {\n    this.engine._componentsManager.addDestroyComponent(this);\n  }\n}\n", "/**\n * Camera clear flags enumeration.\n */\nexport enum CameraClearFlags {\n  /* Clear depth and color from background. */\n  DepthColor,\n  /* Clear depth only. */\n  Depth,\n  /* Do nothing. */\n  None\n}\n", "import { Color } from \"@oasis-engine/math\";\nimport { Camera } from \"../Camera\";\nimport { CameraClearFlags } from \"../enums/CameraClearFlags\";\nimport { Layer } from \"../Layer\";\nimport { Material } from \"../material/Material\";\nimport { RenderTarget } from \"../texture/RenderTarget\";\nimport { RenderQueue } from \"./RenderQueue\";\n\nlet passNum = 0;\n\n/**\n * RenderPass.\n */\nclass RenderPass {\n  public name: string;\n  public enabled: boolean;\n  public priority: number;\n  public renderTarget: RenderTarget;\n  public replaceMaterial: Material;\n  public mask: Layer;\n  public renderOverride: boolean;\n  public clearFlags: CameraClearFlags | undefined;\n  public clearColor: Color | undefined;\n\n  /**\n   * Create a RenderPass.\n   * @param name - Pass name\n   * @param priority - Priority, less than 0 before the default pass, greater than 0 after the default pass\n   * @param renderTarget - The specified Render Target\n   * @param replaceMaterial -  Replaced material\n   * @param mask - Perform bit and operations with Entity.Layer to filter the objects that this Pass needs to render\n   */\n  constructor(\n    name = `RENDER_PASS${passNum++}`,\n    priority = 0,\n    renderTarget = null,\n    replaceMaterial = null,\n    mask = null\n  ) {\n    this.name = name;\n    this.enabled = true;\n    this.priority = priority;\n    this.renderTarget = renderTarget;\n    this.replaceMaterial = replaceMaterial;\n    this.mask = mask || Layer.Everything;\n    this.renderOverride = false; // If renderOverride is set to true, you need to implement the render method\n  }\n\n  /**\n   * Rendering callback, will be executed if renderOverride is set to true.\n   * @param camera - Camera\n   * @param opaqueQueue - Opaque queue\n   * @param alphaTestQueue - Alpha test queue\n   * @param transparentQueue - Transparent queue\n   */\n  render(camera: Camera, opaqueQueue: RenderQueue, alphaTestQueue: RenderQueue, transparentQueue: RenderQueue) {}\n\n  /**\n   * Post rendering callback.\n   * @param camera - Camera\n   * @param opaqueQueue - Opaque queue\n   * @param alphaTestQueue - Alpha test queue\n   * @param transparentQueue - Transparent queue\n   */\n  preRender(camera: Camera, opaqueQueue: RenderQueue, alphaTestQueue: RenderQueue, transparentQueue: RenderQueue) {}\n\n  /**\n   * Post rendering callback.\n   * @param camera - Camera\n   * @param opaqueQueue - Opaque queue\n   * @param alphaTestQueue - Alpha test queue\n   * @param transparentQueue - Transparent queue\n   */\n  postRender(camera: Camera, opaqueQueue: RenderQueue, alphaTestQueue: RenderQueue, transparentQueue: RenderQueue) {}\n}\n\nexport { RenderPass };\n", "import { SpriteMaskInteraction } from \"../2d/enums/SpriteMaskInteraction\";\nimport { SpriteRenderer } from \"../2d/sprite/SpriteRenderer\";\nimport { Engine } from \"../Engine\";\nimport { VertexElementFormat } from \"../graphic/enums/VertexElementFormat\";\nimport { VertexElement } from \"../graphic/VertexElement\";\nimport { Shader } from \"../shader/Shader\";\nimport { ShaderMacroCollection } from \"../shader/ShaderMacroCollection\";\nimport { ShaderProperty } from \"../shader/ShaderProperty\";\nimport { Basic2DBatcher } from \"./Basic2DBatcher\";\nimport { SpriteElement } from \"./SpriteElement\";\n\n/**\n * @internal\n */\nexport class SpriteBatcher extends Basic2DBatcher {\n  private static _textureProperty: ShaderProperty = Shader.getPropertyByName(\"u_spriteTexture\");\n\n  createVertexElements(vertexElements: VertexElement[]): number {\n    vertexElements[0] = new VertexElement(\"POSITION\", 0, VertexElementFormat.Vector3, 0);\n    vertexElements[1] = new VertexElement(\"TEXCOORD_0\", 12, VertexElementFormat.Vector2, 0);\n    vertexElements[2] = new VertexElement(\"COLOR_0\", 20, VertexElementFormat.Vector4, 0);\n    return 36;\n  }\n\n  canBatch(preElement: SpriteElement, curElement: SpriteElement): boolean {\n    const preRenderer = <SpriteRenderer>preElement.component;\n    const curRenderer = <SpriteRenderer>curElement.component;\n\n    // Compare mask\n    if (!this.checkBatchWithMask(preRenderer, curRenderer)) {\n      return false;\n    }\n\n    // Compare renderer property\n    const textureProperty = SpriteBatcher._textureProperty;\n    if (preRenderer.shaderData.getTexture(textureProperty) !== curRenderer.shaderData.getTexture(textureProperty)) {\n      return false;\n    }\n\n    // Compare material\n    return preElement.material === curElement.material;\n  }\n\n  checkBatchWithMask(left: SpriteRenderer, right: SpriteRenderer): boolean {\n    const leftMaskInteraction = left.maskInteraction;\n\n    if (leftMaskInteraction !== right.maskInteraction) {\n      return false;\n    }\n    if (leftMaskInteraction === SpriteMaskInteraction.None) {\n      return true;\n    }\n    return left.maskLayer === right.maskLayer;\n  }\n\n  updateVertices(element: SpriteElement, vertices: Float32Array, vertexIndex: number): number {\n    const { positions, uv, color } = element;\n    const verticesNum = positions.length;\n    for (let i = 0; i < verticesNum; i++) {\n      const curPos = positions[i];\n      const curUV = uv[i];\n\n      vertices[vertexIndex++] = curPos.x;\n      vertices[vertexIndex++] = curPos.y;\n      vertices[vertexIndex++] = curPos.z;\n      vertices[vertexIndex++] = curUV.x;\n      vertices[vertexIndex++] = curUV.y;\n      vertices[vertexIndex++] = color.r;\n      vertices[vertexIndex++] = color.g;\n      vertices[vertexIndex++] = color.b;\n      vertices[vertexIndex++] = color.a;\n    }\n\n    return vertexIndex;\n  }\n\n  drawBatches(engine: Engine): void {\n    const mesh = this._meshes[this._flushId];\n    const subMeshes = mesh.subMeshes;\n    const batchedQueue = this._batchedQueue;\n    const maskManager = engine._spriteMaskManager;\n\n    for (let i = 0, len = subMeshes.length; i < len; i++) {\n      const subMesh = subMeshes[i];\n      const spriteElement = <SpriteElement>batchedQueue[i];\n\n      if (!subMesh || !spriteElement) {\n        return;\n      }\n\n      const renderer = <SpriteRenderer>spriteElement.component;\n      const camera = spriteElement.camera;\n      const material = spriteElement.material;\n      maskManager.preRender(camera, renderer);\n\n      const compileMacros = Shader._compileMacros;\n      // union render global macro and material self macro.\n      ShaderMacroCollection.unionCollection(\n        renderer._globalShaderMacro,\n        material.shaderData._macroCollection,\n        compileMacros\n      );\n\n      const program = material.shader._getShaderProgram(engine, compileMacros);\n      if (!program.isValid) {\n        return;\n      }\n\n      program.bind();\n      program.groupingOtherUniformBlock();\n      program.uploadAll(program.sceneUniformBlock, camera.scene.shaderData);\n      program.uploadAll(program.cameraUniformBlock, camera.shaderData);\n      program.uploadAll(program.rendererUniformBlock, renderer.shaderData);\n      program.uploadAll(program.materialUniformBlock, material.shaderData);\n\n      material.renderState._apply(engine);\n\n      engine._hardwareRenderer.drawPrimitive(mesh, subMesh, program);\n\n      maskManager.postRender(renderer);\n    }\n  }\n\n  destroy(): void {\n    this._batchedQueue = null;\n\n    const { _meshes: meshes, _vertexBuffers: vertexBuffers, _indiceBuffers: indiceBuffers } = this;\n\n    for (let i = 0, n = meshes.length; i < n; ++i) {\n      meshes[i].destroy();\n    }\n    this._meshes = null;\n\n    for (let i = 0, n = vertexBuffers.length; i < n; ++i) {\n      vertexBuffers[i].destroy();\n    }\n    this._vertexBuffers = null;\n\n    for (let i = 0, n = indiceBuffers.length; i < n; ++i) {\n      indiceBuffers[i].destroy();\n    }\n    this._indiceBuffers = null;\n  }\n}\n", "import { Camera } from \"../Camera\";\nimport { Engine } from \"../Engine\";\nimport { Layer } from \"../Layer\";\nimport { Material } from \"../material/Material\";\nimport { Shader } from \"../shader\";\nimport { ShaderMacroCollection } from \"../shader/ShaderMacroCollection\";\nimport { RenderElement } from \"./RenderElement\";\nimport { SpriteBatcher } from \"./SpriteBatcher\";\nimport { SpriteElement } from \"./SpriteElement\";\n\ntype Item = RenderElement | SpriteElement;\n\n/**\n * Render queue.\n */\nexport class RenderQueue {\n  /**\n   * @internal\n   */\n  static _compareFromNearToFar(a: Item, b: Item): number {\n    return (\n      a.material.renderQueueType - b.material.renderQueueType ||\n      a.component._distanceForSort - b.component._distanceForSort ||\n      b.component._renderSortId - a.component._renderSortId\n    );\n  }\n\n  /**\n   * @internal\n   */\n  static _compareFromFarToNear(a: Item, b: Item): number {\n    return (\n      a.material.renderQueueType - b.material.renderQueueType ||\n      b.component._distanceForSort - a.component._distanceForSort ||\n      b.component._renderSortId - a.component._renderSortId\n    );\n  }\n\n  readonly items: Item[] = [];\n  private _spriteBatcher: SpriteBatcher;\n\n  constructor(engine: Engine) {\n    this._spriteBatcher = new SpriteBatcher(engine);\n  }\n\n  /**\n   * Push a render element.\n   */\n  pushPrimitive(element: RenderElement | SpriteElement): void {\n    this.items.push(element);\n  }\n\n  render(camera: Camera, replaceMaterial: Material, mask: Layer) {\n    const items = this.items;\n    if (items.length === 0) {\n      return;\n    }\n\n    const { engine, scene } = camera;\n    const renderCount = engine._renderCount;\n    const rhi = engine._hardwareRenderer;\n    const sceneData = scene.shaderData;\n    const cameraData = camera.shaderData;\n\n    for (let i = 0, n = items.length; i < n; i++) {\n      const item = items[i];\n      const renderPassFlag = item.component.entity.layer;\n\n      if (!(renderPassFlag & mask)) {\n        continue;\n      }\n\n      if (!!(item as RenderElement).mesh) {\n        this._spriteBatcher.flush(engine);\n\n        const compileMacros = Shader._compileMacros;\n        const element = <RenderElement>item;\n        const renderer = element.component;\n        const material = replaceMaterial ? replaceMaterial : element.material;\n        const rendererData = renderer.shaderData;\n        const materialData = material.shaderData;\n\n        // @todo: temporary solution\n        material._preRender(element);\n\n        // union render global macro and material self macro.\n        ShaderMacroCollection.unionCollection(\n          renderer._globalShaderMacro,\n          materialData._macroCollection,\n          compileMacros\n        );\n\n        const program = material.shader._getShaderProgram(engine, compileMacros);\n        if (!program.isValid) {\n          continue;\n        }\n\n        const switchProgram = program.bind();\n        const switchRenderCount = renderCount !== program._uploadRenderCount;\n\n        if (switchRenderCount) {\n          program.groupingOtherUniformBlock();\n          program.uploadAll(program.sceneUniformBlock, sceneData);\n          program.uploadAll(program.cameraUniformBlock, cameraData);\n          program.uploadAll(program.rendererUniformBlock, rendererData);\n          program.uploadAll(program.materialUniformBlock, materialData);\n          // Ungroup textures should upload default value, texture uint maybe change by logic of texture bind.\n          program.uploadUngroupTextures();\n          program._uploadCamera = camera;\n          program._uploadRenderer = renderer;\n          program._uploadMaterial = material;\n          program._uploadRenderCount = renderCount;\n        } else {\n          if (program._uploadCamera !== camera) {\n            program.uploadAll(program.cameraUniformBlock, cameraData);\n            program._uploadCamera = camera;\n          } else if (switchProgram) {\n            program.uploadTextures(program.cameraUniformBlock, cameraData);\n          }\n\n          if (program._uploadRenderer !== renderer) {\n            program.uploadAll(program.rendererUniformBlock, rendererData);\n            program._uploadRenderer = renderer;\n          } else if (switchProgram) {\n            program.uploadTextures(program.rendererUniformBlock, rendererData);\n          }\n\n          if (program._uploadMaterial !== material) {\n            program.uploadAll(program.materialUniformBlock, materialData);\n            program._uploadMaterial = material;\n          } else if (switchProgram) {\n            program.uploadTextures(program.materialUniformBlock, materialData);\n          }\n\n          // We only consider switchProgram case, because ungroup texture's value is always default.\n          if (switchProgram) {\n            program.uploadUngroupTextures();\n          }\n        }\n        material.renderState._apply(camera.engine);\n        rhi.drawPrimitive(element.mesh, element.subMesh, program);\n      } else {\n        const spriteElement = <SpriteElement>item;\n        this._spriteBatcher.drawElement(spriteElement);\n      }\n    }\n\n    this._spriteBatcher.flush(engine);\n  }\n\n  /**\n   * Clear collection.\n   */\n  clear(): void {\n    this.items.length = 0;\n    this._spriteBatcher.clear();\n  }\n\n  /**\n   * Destroy internal resources.\n   */\n  destroy(): void {\n    this._spriteBatcher.destroy();\n    this._spriteBatcher = null;\n  }\n\n  /**\n   * Sort the elements.\n   */\n  sort(compareFunc: Function): void {\n    this._quickSort(this.items, 0, this.items.length, compareFunc);\n  }\n\n  /**\n   * @remarks\n   * Modified based on v8.\n   * https://github.com/v8/v8/blob/7.2-lkgr/src/js/array.js\n   */\n  private _quickSort<T>(a: T[], from: number, to: number, compareFunc: Function): void {\n    while (true) {\n      // Insertion sort is faster for short arrays.\n      if (to - from <= 10) {\n        this._insertionSort(a, from, to, compareFunc);\n        return;\n      }\n      const third_index = (from + to) >> 1;\n      // Find a pivot as the median of first, last and middle element.\n      let v0 = a[from];\n      let v1 = a[to - 1];\n      let v2 = a[third_index];\n      const c01 = compareFunc(v0, v1);\n      if (c01 > 0) {\n        // v1 < v0, so swap them.\n        const tmp = v0;\n        v0 = v1;\n        v1 = tmp;\n      } // v0 <= v1.\n      const c02 = compareFunc(v0, v2);\n      if (c02 >= 0) {\n        // v2 <= v0 <= v1.\n        const tmp = v0;\n        v0 = v2;\n        v2 = v1;\n        v1 = tmp;\n      } else {\n        // v0 <= v1 && v0 < v2\n        const c12 = compareFunc(v1, v2);\n        if (c12 > 0) {\n          // v0 <= v2 < v1\n          const tmp = v1;\n          v1 = v2;\n          v2 = tmp;\n        }\n      }\n      // v0 <= v1 <= v2\n      a[from] = v0;\n      a[to - 1] = v2;\n      const pivot = v1;\n      let low_end = from + 1; // Upper bound of elements lower than pivot.\n      let high_start = to - 1; // Lower bound of elements greater than pivot.\n      a[third_index] = a[low_end];\n      a[low_end] = pivot;\n\n      // From low_end to i are elements equal to pivot.\n      // From i to high_start are elements that haven't been compared yet.\n      partition: for (let i = low_end + 1; i < high_start; i++) {\n        let element = a[i];\n        let order = compareFunc(element, pivot);\n        if (order < 0) {\n          a[i] = a[low_end];\n          a[low_end] = element;\n          low_end++;\n        } else if (order > 0) {\n          do {\n            high_start--;\n            if (high_start == i) break partition;\n            const top_elem = a[high_start];\n            order = compareFunc(top_elem, pivot);\n          } while (order > 0);\n          a[i] = a[high_start];\n          a[high_start] = element;\n          if (order < 0) {\n            element = a[i];\n            a[i] = a[low_end];\n            a[low_end] = element;\n            low_end++;\n          }\n        }\n      }\n      if (to - high_start < low_end - from) {\n        this._quickSort(a, high_start, to, compareFunc);\n        to = low_end;\n      } else {\n        this._quickSort(a, from, low_end, compareFunc);\n        from = high_start;\n      }\n    }\n  }\n\n  private _insertionSort<T>(a: T[], from: number, to: number, compareFunc: Function): void {\n    for (let i = from + 1; i < to; i++) {\n      let j;\n      const element = a[i];\n      for (j = i - 1; j >= from; j--) {\n        const tmp = a[j];\n        const order = compareFunc(tmp, element);\n        if (order > 0) {\n          a[j + 1] = tmp;\n        } else {\n          break;\n        }\n      }\n      a[j + 1] = element;\n    }\n  }\n}\n", "import { Matrix, Vector2 } from \"@oasis-engine/math\";\nimport { Background } from \"..\";\nimport { SpriteMask } from \"../2d/sprite/SpriteMask\";\nimport { Logger } from \"../base/Logger\";\nimport { Camera } from \"../Camera\";\nimport { DisorderedArray } from \"../DisorderedArray\";\nimport { Engine } from \"../Engine\";\nimport { BackgroundMode } from \"../enums/BackgroundMode\";\nimport { BackgroundTextureFillMode } from \"../enums/BackgroundTextureFillMode\";\nimport { CameraClearFlags } from \"../enums/CameraClearFlags\";\nimport { Layer } from \"../Layer\";\nimport { RenderQueueType } from \"../material/enums/RenderQueueType\";\nimport { Material } from \"../material/Material\";\nimport { Shader } from \"../shader/Shader\";\nimport { ShaderMacroCollection } from \"../shader/ShaderMacroCollection\";\nimport { Sky } from \"../sky/Sky\";\nimport { TextureCubeFace } from \"../texture/enums/TextureCubeFace\";\nimport { RenderTarget } from \"../texture/RenderTarget\";\nimport { RenderContext } from \"./RenderContext\";\nimport { RenderElement } from \"./RenderElement\";\nimport { RenderPass } from \"./RenderPass\";\nimport { RenderQueue } from \"./RenderQueue\";\nimport { SpriteElement } from \"./SpriteElement\";\n\n/**\n * Basic render pipeline.\n */\nexport class BasicRenderPipeline {\n  /** @internal */\n  _opaqueQueue: RenderQueue;\n  /** @internal */\n  _transparentQueue: RenderQueue;\n  /** @internal */\n  _alphaTestQueue: RenderQueue;\n  /** @internal */\n  _allSpriteMasks: DisorderedArray<SpriteMask> = new DisorderedArray();\n\n  private _camera: Camera;\n  private _defaultPass: RenderPass;\n  private _renderPassArray: Array<RenderPass>;\n  private _lastCanvasSize = new Vector2();\n\n  /**\n   * Create a basic render pipeline.\n   * @param camera - Camera\n   */\n  constructor(camera: Camera) {\n    this._camera = camera;\n    const { engine } = camera;\n    this._opaqueQueue = new RenderQueue(engine);\n    this._alphaTestQueue = new RenderQueue(engine);\n    this._transparentQueue = new RenderQueue(engine);\n\n    this._renderPassArray = [];\n    this._defaultPass = new RenderPass(\"default\", 0, null, null, 0);\n    this.addRenderPass(this._defaultPass);\n  }\n\n  /**\n   * Default render pass.\n   */\n  get defaultRenderPass() {\n    return this._defaultPass;\n  }\n\n  /**\n   * Add render pass.\n   * @param nameOrPass - The name of this Pass or RenderPass object. When it is a name, the following parameters need to be provided\n   * @param priority - Priority, less than 0 before the default pass, greater than 0 after the default pass\n   * @param renderTarget - The specified Render Target\n   * @param replaceMaterial -  Replaced material\n   * @param mask - Perform bit and operations with Entity.Layer to filter the objects that this Pass needs to render\n   */\n  addRenderPass(\n    nameOrPass: string | RenderPass,\n    priority: number = null,\n    renderTarget: RenderTarget = null,\n    replaceMaterial: Material = null,\n    mask: Layer = null\n  ) {\n    if (typeof nameOrPass === \"string\") {\n      const renderPass = new RenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask);\n      this._renderPassArray.push(renderPass);\n    } else if (nameOrPass instanceof RenderPass) {\n      this._renderPassArray.push(nameOrPass);\n    }\n\n    this._renderPassArray.sort(function (p1, p2) {\n      return p1.priority - p2.priority;\n    });\n  }\n\n  /**\n   * Remove render pass by name or render pass object.\n   * @param nameOrPass - Render pass name or render pass object\n   */\n  removeRenderPass(nameOrPass: string | RenderPass): void {\n    let pass: RenderPass;\n    if (typeof nameOrPass === \"string\") pass = this.getRenderPass(nameOrPass);\n    else if (nameOrPass instanceof RenderPass) pass = nameOrPass;\n    if (pass) {\n      const idx = this._renderPassArray.indexOf(pass);\n      this._renderPassArray.splice(idx, 1);\n    }\n  }\n\n  /**\n   * Get render pass by name.\n   * @param  name - Render pass name\n   */\n  getRenderPass(name: string) {\n    for (let i = 0, len = this._renderPassArray.length; i < len; i++) {\n      const pass = this._renderPassArray[i];\n      if (pass.name === name) return pass;\n    }\n\n    return null;\n  }\n\n  /**\n   * Destroy internal resources.\n   */\n  destroy(): void {\n    this._opaqueQueue.destroy();\n    this._alphaTestQueue.destroy();\n    this._transparentQueue.destroy();\n    this._allSpriteMasks = null;\n    this._renderPassArray = null;\n    this._defaultPass = null;\n    this._camera = null;\n  }\n\n  /**\n   * Perform scene rendering.\n   * @param context - Render context\n   * @param cubeFace - Render surface of cube texture\n   */\n  render(context: RenderContext, cubeFace?: TextureCubeFace) {\n    const camera = this._camera;\n    const opaqueQueue = this._opaqueQueue;\n    const alphaTestQueue = this._alphaTestQueue;\n    const transparentQueue = this._transparentQueue;\n\n    camera.engine._spriteMaskManager.clear();\n\n    opaqueQueue.clear();\n    alphaTestQueue.clear();\n    transparentQueue.clear();\n    this._allSpriteMasks.length = 0;\n\n    camera.engine._componentsManager.callRender(context);\n    opaqueQueue.sort(RenderQueue._compareFromNearToFar);\n    alphaTestQueue.sort(RenderQueue._compareFromNearToFar);\n    transparentQueue.sort(RenderQueue._compareFromFarToNear);\n\n    for (let i = 0, len = this._renderPassArray.length; i < len; i++) {\n      this._drawRenderPass(this._renderPassArray[i], camera, cubeFace);\n    }\n  }\n\n  private _drawRenderPass(pass: RenderPass, camera: Camera, cubeFace?: TextureCubeFace) {\n    pass.preRender(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);\n\n    if (pass.enabled) {\n      const { engine, scene } = camera;\n      const { background } = scene;\n      const rhi = engine._hardwareRenderer;\n      const renderTarget = camera.renderTarget || pass.renderTarget;\n      rhi.activeRenderTarget(renderTarget, camera);\n      renderTarget?._setRenderTargetFace(cubeFace);\n      const clearFlags = pass.clearFlags ?? camera.clearFlags;\n      const color = pass.clearColor ?? background.solidColor;\n      if (clearFlags !== CameraClearFlags.None) {\n        rhi.clearRenderTarget(camera.engine, clearFlags, color);\n      }\n\n      if (pass.renderOverride) {\n        pass.render(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);\n      } else {\n        this._opaqueQueue.render(camera, pass.replaceMaterial, pass.mask);\n        this._alphaTestQueue.render(camera, pass.replaceMaterial, pass.mask);\n        if (background.mode === BackgroundMode.Sky) {\n          this._drawSky(engine, camera, background.sky);\n        } else if (background.mode === BackgroundMode.Texture && background.texture) {\n          this._drawBackgroundTexture(engine, background);\n        }\n        this._transparentQueue.render(camera, pass.replaceMaterial, pass.mask);\n      }\n\n      renderTarget?._blitRenderTarget();\n      renderTarget?.generateMipmaps();\n    }\n\n    pass.postRender(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);\n  }\n\n  /**\n   * Push a render element to the render queue.\n   * @param element - Render element\n   */\n  pushPrimitive(element: RenderElement | SpriteElement) {\n    const renderQueueType = element.material.renderQueueType;\n\n    if (renderQueueType > (RenderQueueType.Transparent + RenderQueueType.AlphaTest) >> 1) {\n      this._transparentQueue.pushPrimitive(element);\n    } else if (renderQueueType > (RenderQueueType.AlphaTest + RenderQueueType.Opaque) >> 1) {\n      this._alphaTestQueue.pushPrimitive(element);\n    } else {\n      this._opaqueQueue.pushPrimitive(element);\n    }\n  }\n\n  private _drawBackgroundTexture(engine: Engine, background: Background) {\n    const rhi = engine._hardwareRenderer;\n    const { _backgroundTextureMaterial, _backgroundTextureMesh, canvas } = engine;\n\n    if (\n      (this._lastCanvasSize.x !== canvas.width || this._lastCanvasSize.y !== canvas.height) &&\n      background._textureFillMode !== BackgroundTextureFillMode.Fill\n    ) {\n      this._lastCanvasSize.setValue(canvas.width, canvas.height);\n      background._resizeBackgroundTexture();\n    }\n\n    const program = _backgroundTextureMaterial.shader._getShaderProgram(engine, Shader._compileMacros);\n    program.bind();\n    program.uploadAll(program.materialUniformBlock, _backgroundTextureMaterial.shaderData);\n    program.uploadUngroupTextures();\n\n    _backgroundTextureMaterial.renderState._apply(engine);\n    rhi.drawPrimitive(_backgroundTextureMesh, _backgroundTextureMesh.subMesh, program);\n  }\n\n  private _drawSky(engine: Engine, camera: Camera, sky: Sky): void {\n    const { material, mesh, _matrix } = sky;\n    if (!material) {\n      Logger.warn(\"The material of sky is not defined.\");\n      return;\n    }\n    if (!mesh) {\n      Logger.warn(\"The mesh of sky is not defined.\");\n      return;\n    }\n\n    const rhi = engine._hardwareRenderer;\n    const { shaderData, shader, renderState } = material;\n\n    const compileMacros = Shader._compileMacros;\n    ShaderMacroCollection.unionCollection(camera._globalShaderMacro, shaderData._macroCollection, compileMacros);\n\n    const { viewMatrix, projectionMatrix } = camera;\n    viewMatrix.cloneTo(_matrix);\n    const e = _matrix.elements;\n    e[12] = e[13] = e[14] = 0;\n    Matrix.multiply(projectionMatrix, _matrix, _matrix);\n    shaderData.setMatrix(\"u_mvpNoscale\", _matrix);\n\n    const program = shader._getShaderProgram(engine, compileMacros);\n    program.bind();\n    program.groupingOtherUniformBlock();\n    program.uploadAll(program.materialUniformBlock, shaderData);\n    program.uploadUngroupTextures();\n\n    renderState._apply(engine);\n    rhi.drawPrimitive(mesh, mesh.subMesh, program);\n  }\n}\n", "import { BoundingFrustum, MathUtil, Matrix, Ray, Vector2, Vector3, Vector4 } from \"@oasis-engine/math\";\nimport { deepClone, ignoreClone } from \"./clone/CloneManager\";\nimport { Component } from \"./Component\";\nimport { dependencies } from \"./ComponentsDependencies\";\nimport { Entity } from \"./Entity\";\nimport { CameraClearFlags } from \"./enums/CameraClearFlags\";\nimport { Layer } from \"./Layer\";\nimport { BasicRenderPipeline } from \"./RenderPipeline/BasicRenderPipeline\";\nimport { RenderContext } from \"./RenderPipeline/RenderContext\";\nimport { ShaderDataGroup } from \"./shader/enums/ShaderDataGroup\";\nimport { Shader } from \"./shader/Shader\";\nimport { ShaderData } from \"./shader/ShaderData\";\nimport { ShaderMacroCollection } from \"./shader/ShaderMacroCollection\";\nimport { TextureCubeFace } from \"./texture/enums/TextureCubeFace\";\nimport { RenderTarget } from \"./texture/RenderTarget\";\nimport { Transform } from \"./Transform\";\nimport { UpdateFlag } from \"./UpdateFlag\";\n\nclass MathTemp {\n  static tempMat4 = new Matrix();\n  static tempVec4 = new Vector4();\n  static tempVec3 = new Vector3();\n  static tempVec2 = new Vector2();\n}\n\n/**\n * Camera component, as the entrance to the three-dimensional world.\n */\n@dependencies(Transform)\nexport class Camera extends Component {\n  private static _viewMatrixProperty = Shader.getPropertyByName(\"u_viewMat\");\n  private static _projectionMatrixProperty = Shader.getPropertyByName(\"u_projMat\");\n  private static _vpMatrixProperty = Shader.getPropertyByName(\"u_VPMat\");\n  private static _inverseViewMatrixProperty = Shader.getPropertyByName(\"u_viewInvMat\");\n  private static _inverseProjectionMatrixProperty = Shader.getPropertyByName(\"u_projInvMat\");\n  private static _cameraPositionProperty = Shader.getPropertyByName(\"u_cameraPos\");\n\n  /** Shader data. */\n  readonly shaderData: ShaderData = new ShaderData(ShaderDataGroup.Camera);\n\n  /** Rendering priority - A Camera with higher priority will be rendered on top of a camera with lower priority. */\n  priority: number = 0;\n\n  /** Whether to enable frustum culling, it is enabled by default. */\n  enableFrustumCulling: boolean = true;\n\n  /**\n   * Determining what to clear when rendering by a Camera.\n   * @defaultValue `CameraClearFlags.DepthColor`\n   */\n  clearFlags: CameraClearFlags = CameraClearFlags.DepthColor;\n\n  /**\n   * Culling mask - which layers the camera renders.\n   * @remarks Support bit manipulation, corresponding to Entity's layer.\n   */\n  cullingMask: Layer = Layer.Everything;\n\n  /** @internal */\n  _globalShaderMacro: ShaderMacroCollection = new ShaderMacroCollection();\n  /** @internal */\n  @deepClone\n  _frustum: BoundingFrustum = new BoundingFrustum();\n  /** @internal */\n  @ignoreClone\n  _renderPipeline: BasicRenderPipeline;\n\n  private _isOrthographic: boolean = false;\n  private _isProjMatSetting = false;\n  private _nearClipPlane: number = 0.1;\n  private _farClipPlane: number = 100;\n  private _fieldOfView: number = 45;\n  private _orthographicSize: number = 10;\n  private _isProjectionDirty = true;\n  private _isInvProjMatDirty: boolean = true;\n  private _isFrustumProjectDirty: boolean = true;\n  private _customAspectRatio: number | undefined = undefined;\n  private _renderTarget: RenderTarget = null;\n\n  @ignoreClone\n  private _frustumViewChangeFlag: UpdateFlag;\n  @ignoreClone\n  private _transform: Transform;\n  @ignoreClone\n  private _isViewMatrixDirty: UpdateFlag;\n  @ignoreClone\n  private _isInvViewProjDirty: UpdateFlag;\n  @deepClone\n  private _projectionMatrix: Matrix = new Matrix();\n  @deepClone\n  private _viewMatrix: Matrix = new Matrix();\n  @deepClone\n  private _viewport: Vector4 = new Vector4(0, 0, 1, 1);\n  @deepClone\n  private _inverseProjectionMatrix: Matrix = new Matrix();\n  @deepClone\n  private _lastAspectSize: Vector2 = new Vector2(0, 0);\n  @deepClone\n  private _invViewProjMat: Matrix = new Matrix();\n\n  /**\n   * Near clip plane - the closest point to the camera when rendering occurs.\n   */\n  get nearClipPlane(): number {\n    return this._nearClipPlane;\n  }\n\n  set nearClipPlane(value: number) {\n    this._nearClipPlane = value;\n    this._projMatChange();\n  }\n\n  /**\n   * Far clip plane - the furthest point to the camera when rendering occurs.\n   */\n  get farClipPlane(): number {\n    return this._farClipPlane;\n  }\n\n  set farClipPlane(value: number) {\n    this._farClipPlane = value;\n    this._projMatChange();\n  }\n\n  /**\n   * The camera's view angle. activating when camera use perspective projection.\n   */\n  get fieldOfView(): number {\n    return this._fieldOfView;\n  }\n\n  set fieldOfView(value: number) {\n    this._fieldOfView = value;\n    this._projMatChange();\n  }\n\n  /**\n   * Aspect ratio. The default is automatically calculated by the viewport's aspect ratio. If it is manually set,\n   * the manual value will be kept. Call resetAspectRatio() to restore it.\n   */\n  get aspectRatio(): number {\n    const canvas = this._entity.engine.canvas;\n    return this._customAspectRatio ?? (canvas.width * this._viewport.z) / (canvas.height * this._viewport.w);\n  }\n\n  set aspectRatio(value: number) {\n    this._customAspectRatio = value;\n    this._projMatChange();\n  }\n\n  /**\n   * Viewport, normalized expression, the upper left corner is (0, 0), and the lower right corner is (1, 1).\n   * @remarks Re-assignment is required after modification to ensure that the modification takes effect.\n   */\n  get viewport(): Vector4 {\n    return this._viewport;\n  }\n\n  set viewport(value: Vector4) {\n    if (value !== this._viewport) {\n      value.cloneTo(this._viewport);\n    }\n    this._projMatChange();\n  }\n\n  /**\n   * Whether it is orthogonal, the default is false. True will use orthographic projection, false will use perspective projection.\n   */\n  get isOrthographic(): boolean {\n    return this._isOrthographic;\n  }\n\n  set isOrthographic(value: boolean) {\n    this._isOrthographic = value;\n    this._projMatChange();\n  }\n\n  /**\n   * Half the size of the camera in orthographic mode.\n   */\n  get orthographicSize(): number {\n    return this._orthographicSize;\n  }\n\n  set orthographicSize(value: number) {\n    this._orthographicSize = value;\n    this._projMatChange();\n  }\n\n  /**\n   * View matrix.\n   */\n  get viewMatrix(): Readonly<Matrix> {\n    // Remove scale\n    if (this._isViewMatrixDirty.flag) {\n      this._isViewMatrixDirty.flag = false;\n      Matrix.invert(this._transform.worldMatrix, this._viewMatrix);\n    }\n    return this._viewMatrix;\n  }\n\n  /**\n   * The projection matrix is \u200B\u200Bcalculated by the relevant parameters of the camera by default.\n   * If it is manually set, the manual value will be maintained. Call resetProjectionMatrix() to restore it.\n   */\n  set projectionMatrix(value: Matrix) {\n    this._projectionMatrix = value;\n    this._isProjMatSetting = true;\n    this._projMatChange();\n  }\n\n  get projectionMatrix(): Matrix {\n    const canvas = this._entity.engine.canvas;\n    if (\n      (!this._isProjectionDirty || this._isProjMatSetting) &&\n      this._lastAspectSize.x === canvas.width &&\n      this._lastAspectSize.y === canvas.height\n    ) {\n      return this._projectionMatrix;\n    }\n    this._isProjectionDirty = false;\n    this._lastAspectSize.x = canvas.width;\n    this._lastAspectSize.y = canvas.height;\n    const aspectRatio = this.aspectRatio;\n    if (!this._isOrthographic) {\n      Matrix.perspective(\n        MathUtil.degreeToRadian(this._fieldOfView),\n        aspectRatio,\n        this._nearClipPlane,\n        this._farClipPlane,\n        this._projectionMatrix\n      );\n    } else {\n      const width = this._orthographicSize * aspectRatio;\n      const height = this._orthographicSize;\n      Matrix.ortho(-width, width, -height, height, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);\n    }\n    return this._projectionMatrix;\n  }\n\n  /**\n   * Whether to enable HDR.\n   * @todo When render pipeline modification\n   */\n  get enableHDR(): boolean {\n    console.log(\"not implementation\");\n    return false;\n  }\n\n  set enableHDR(value: boolean) {\n    console.log(\"not implementation\");\n  }\n\n  /**\n   * RenderTarget. After setting, it will be rendered to the renderTarget. If it is empty, it will be rendered to the main canvas.\n   */\n  get renderTarget(): RenderTarget | null {\n    return this._renderTarget;\n  }\n\n  set renderTarget(value: RenderTarget | null) {\n    this._renderTarget = value;\n  }\n\n  /**\n   * Create the Camera component.\n   * @param entity - Entity\n   */\n  constructor(entity: Entity) {\n    super(entity);\n\n    const transform = this.entity.transform;\n    this._transform = transform;\n    this._isViewMatrixDirty = transform.registerWorldChangeFlag();\n    this._isInvViewProjDirty = transform.registerWorldChangeFlag();\n    this._frustumViewChangeFlag = transform.registerWorldChangeFlag();\n    this._renderPipeline = new BasicRenderPipeline(this);\n    this.shaderData._addRefCount(1);\n  }\n\n  /**\n   * Restore the automatic calculation of projection matrix through fieldOfView, nearClipPlane and farClipPlane.\n   */\n  resetProjectionMatrix(): void {\n    this._isProjMatSetting = false;\n    this._projMatChange();\n  }\n\n  /**\n   * Restore the automatic calculation of the aspect ratio through the viewport aspect ratio.\n   */\n  resetAspectRatio(): void {\n    this._customAspectRatio = undefined;\n    this._projMatChange();\n  }\n\n  /**\n   * Transform a point from world space to viewport space.\n   * @param point - Point in world space\n   * @param out - A point in the viewport space, X and Y are the viewport space coordinates, Z is the viewport depth, the near clipping plane is 0, the far clipping plane is 1, and W is the world unit distance from the camera\n   * @returns Point in viewport space\n   */\n  worldToViewportPoint(point: Vector3, out: Vector4): Vector4 {\n    Matrix.multiply(this.projectionMatrix, this.viewMatrix, MathTemp.tempMat4);\n    MathTemp.tempVec4.setValue(point.x, point.y, point.z, 1.0);\n    Vector4.transform(MathTemp.tempVec4, MathTemp.tempMat4, MathTemp.tempVec4);\n\n    const w = MathTemp.tempVec4.w;\n    const nx = MathTemp.tempVec4.x / w;\n    const ny = MathTemp.tempVec4.y / w;\n    const nz = MathTemp.tempVec4.z / w;\n\n    // Transform of coordinate axis.\n    out.x = (nx + 1.0) * 0.5;\n    out.y = (1.0 - ny) * 0.5;\n    out.z = nz;\n    out.w = w;\n    return out;\n  }\n\n  /**\n   * Transform a point from viewport space to world space.\n   * @param point - Point in viewport space, X and Y are the viewport space coordinates, Z is the viewport depth. The near clipping plane is 0, and the far clipping plane is 1\n   * @param out - Point in world space\n   * @returns Point in world space\n   */\n  viewportToWorldPoint(point: Vector3, out: Vector3): Vector3 {\n    const invViewProjMat = this.invViewProjMat;\n    return this._innerViewportToWorldPoint(point, invViewProjMat, out);\n  }\n\n  /**\n   * Generate a ray by a point in viewport.\n   * @param point - Point in viewport space, which is represented by normalization\n   * @param out - Ray\n   * @returns Ray\n   */\n  viewportPointToRay(point: Vector2, out: Ray): Ray {\n    const clipPoint = MathTemp.tempVec3;\n    // Use the intersection of the near clipping plane as the origin point.\n    clipPoint.setValue(point.x, point.y, 0);\n    const origin = this.viewportToWorldPoint(clipPoint, out.origin);\n    // Use the intersection of the far clipping plane as the origin point.\n    clipPoint.z = 1.0;\n    const farPoint: Vector3 = this._innerViewportToWorldPoint(clipPoint, this._invViewProjMat, clipPoint);\n    Vector3.subtract(farPoint, origin, out.direction);\n    out.direction.normalize();\n\n    return out;\n  }\n\n  /**\n   * Transform the X and Y coordinates of a point from screen space to viewport space\n   * @param point - Point in screen space\n   * @param out - Point in viewport space\n   * @returns Point in viewport space\n   */\n  screenToViewportPoint<T extends Vector2 | Vector3>(point: Vector3 | Vector2, out: T): T {\n    const canvas = this.engine.canvas;\n    const viewport = this.viewport;\n    out.x = (point.x / canvas.width - viewport.x) / viewport.z;\n    out.y = (point.y / canvas.height - viewport.y) / viewport.w;\n    return out;\n  }\n\n  /**\n   * Transform the X and Y coordinates of a point from viewport space to screen space.\n   * @param point - Point in viewport space\n   * @param out - Point in screen space\n   * @returns Point in screen space\n   */\n  viewportToScreenPoint<T extends Vector2 | Vector3 | Vector4>(point: T, out: T): T {\n    const canvas = this.engine.canvas;\n    const viewport = this.viewport;\n    out.x = (viewport.x + point.x * viewport.z) * canvas.width;\n    out.y = (viewport.y + point.y * viewport.w) * canvas.height;\n    return out;\n  }\n\n  /**\n   * Transform a point from world space to screen space.\n   * @param point - Point in world space\n   * @param out - Point of screen space\n   * @returns Point of screen space\n   */\n  worldToScreenPoint(point: Vector3, out: Vector4): Vector4 {\n    this.worldToViewportPoint(point, out);\n    return this.viewportToScreenPoint(out, out);\n  }\n\n  /**\n   * Transform a point from screen space to world space.\n   * @param point - Screen space point\n   * @param out - Point in world space\n   * @returns Point in world space\n   */\n  screenToWorldPoint(point: Vector3, out: Vector3): Vector3 {\n    this.screenToViewportPoint(point, out);\n    return this.viewportToWorldPoint(out, out);\n  }\n\n  /**\n   * Generate a ray by a point in screen.\n   * @param point - Point in screen space, the unit is pixel\n   * @param out - Ray\n   * @returns Ray\n   */\n  screenPointToRay(point: Vector2, out: Ray): Ray {\n    const viewportPoint = MathTemp.tempVec2;\n    this.screenToViewportPoint(point, viewportPoint);\n    return this.viewportPointToRay(viewportPoint, out);\n  }\n\n  /**\n   * Manually call the rendering of the camera.\n   * @param cubeFace - Cube rendering surface collection\n   */\n  render(cubeFace?: TextureCubeFace): void {\n    // compute cull frustum.\n    const context = this.engine._renderContext;\n    context._setContext(this);\n    if (this.enableFrustumCulling && (this._frustumViewChangeFlag.flag || this._isFrustumProjectDirty)) {\n      this._frustum.calculateFromMatrix(context._viewProjectMatrix);\n      this._frustumViewChangeFlag.flag = false;\n      this._isFrustumProjectDirty = false;\n    }\n\n    this._updateShaderData(context);\n\n    // union scene and camera macro.\n    ShaderMacroCollection.unionCollection(\n      this.scene.shaderData._macroCollection,\n      this.shaderData._macroCollection,\n      this._globalShaderMacro\n    );\n\n    this._renderPipeline.render(context, cubeFace);\n    this._engine._renderCount++;\n  }\n\n  /**\n   * @override\n   * @inheritdoc\n   */\n  _onActive() {\n    this.entity.scene._attachRenderCamera(this);\n  }\n\n  /**\n   * @override\n   * @inheritdoc\n   */\n  _onInActive() {\n    this.entity.scene._detachRenderCamera(this);\n  }\n\n  /**\n   * @override\n   * @inheritdoc\n   */\n  _onDestroy() {\n    this._renderPipeline?.destroy();\n    this._isInvViewProjDirty.destroy();\n    this._isViewMatrixDirty.destroy();\n    this.shaderData._addRefCount(-1);\n  }\n\n  private _projMatChange() {\n    this._isFrustumProjectDirty = true;\n    this._isProjectionDirty = true;\n    this._isInvProjMatDirty = true;\n    this._isInvViewProjDirty.flag = true;\n  }\n\n  private _innerViewportToWorldPoint(point: Vector3, invViewProjMat: Matrix, out: Vector3): Vector3 {\n    // Depth is a normalized value, 0 is nearPlane, 1 is farClipPlane.\n    const depth = point.z * 2 - 1;\n    // Transform to clipping space matrix\n    const clipPoint = MathTemp.tempVec4;\n    clipPoint.setValue(point.x * 2 - 1, 1 - point.y * 2, depth, 1);\n    Vector4.transform(clipPoint, invViewProjMat, clipPoint);\n    const invW = 1.0 / clipPoint.w;\n    out.x = clipPoint.x * invW;\n    out.y = clipPoint.y * invW;\n    out.z = clipPoint.z * invW;\n    return out;\n  }\n\n  private _updateShaderData(context: RenderContext) {\n    const shaderData = this.shaderData;\n    shaderData.setMatrix(Camera._viewMatrixProperty, this.viewMatrix);\n    shaderData.setMatrix(Camera._projectionMatrixProperty, this.projectionMatrix);\n    shaderData.setMatrix(Camera._vpMatrixProperty, context._viewProjectMatrix);\n    shaderData.setMatrix(Camera._inverseViewMatrixProperty, this._transform.worldMatrix);\n    shaderData.setMatrix(Camera._inverseProjectionMatrixProperty, this.inverseProjectionMatrix);\n    shaderData.setVector3(Camera._cameraPositionProperty, this._transform.worldPosition);\n  }\n\n  /**\n   * @private\n   * The inverse matrix of view projection matrix.\n   */\n  get invViewProjMat(): Matrix {\n    if (this._isInvViewProjDirty.flag) {\n      this._isInvViewProjDirty.flag = false;\n      Matrix.multiply(this._transform.worldMatrix, this.inverseProjectionMatrix, this._invViewProjMat);\n    }\n    return this._invViewProjMat;\n  }\n\n  /**\n   * @private\n   * The inverse of the projection matrix.\n   */\n  get inverseProjectionMatrix(): Readonly<Matrix> {\n    if (this._isInvProjMatDirty) {\n      this._isInvProjMatDirty = false;\n      Matrix.invert(this.projectionMatrix, this._inverseProjectionMatrix);\n    }\n    return this._inverseProjectionMatrix;\n  }\n}\n", "import { AssetPromise } from \"./AssetPromise\";\n\nconst mimeType = {\n  json: \"json\",\n  gltf: \"json\",\n  mtl: \"json\",\n  prefab: \"json\",\n  txt: \"text\",\n  bin: \"arraybuffer\",\n  png: \"image\",\n  webp: \"image\",\n  jpg: \"image\"\n};\n\nconst defaultRetryCount = 4;\nconst defaultTimeout = 15000;\nconst defaultInterval = 500;\n\nexport type RequestConfig = {\n  type?: XMLHttpRequestResponseType | \"image\";\n  retryCount?: number;\n  retryInterval?: number;\n  timeout?: number;\n} & RequestInit;\n\n/**\n * Web request.\n * @param url - The link\n * @param config - Load configuration\n */\nexport function request<T>(url: string, config: RequestConfig = {}): AssetPromise<T> {\n  return new AssetPromise((resolve, reject, setProgress) => {\n    const retryCount = config.retryCount ?? defaultRetryCount;\n    const retryInterval = config.retryInterval ?? defaultInterval;\n    config.timeout = config.timeout ?? defaultTimeout;\n    config.type = config.type ?? getMimeTypeFromUrl(url);\n    const realRequest = config.type === \"image\" ? requestImage : requestRes;\n    let lastError: Error;\n    const executor = new MultiExecutor(\n      () => {\n        return realRequest<T>(url, config)\n          .onProgress(setProgress)\n          .then((res) => {\n            resolve(res);\n            executor.stop();\n          })\n          .catch((err) => (lastError = err));\n      },\n      retryCount,\n      retryInterval\n    );\n    executor.start(() => {\n      reject(lastError);\n    });\n  });\n}\n\nfunction requestImage<T>(url: string, config: RequestConfig): AssetPromise<T> {\n  return new AssetPromise((resolve, reject) => {\n    const { timeout } = config;\n    const img = new Image();\n    const onerror = () => {\n      reject(new Error(`request ${url} fail`));\n    };\n    img.onerror = onerror;\n\n    img.onabort = onerror;\n\n    const timeoutId = setTimeout(() => {\n      reject(new Error(`request ${url} timeout`));\n    }, timeout);\n\n    img.onload = ((timeoutId) => {\n      return () => {\n        // Call requestAnimationFrame to avoid iOS's bug.\n        requestAnimationFrame(() => {\n          //@ts-ignore\n          resolve(img);\n          img.onload = null;\n          img.onerror = null;\n          img.onabort = null;\n        });\n        clearTimeout(timeoutId);\n      };\n    })(timeoutId);\n\n    img.crossOrigin = \"anonymous\";\n\n    img.src = url;\n  });\n}\n\nfunction requestRes<T>(url: string, config: RequestConfig): AssetPromise<T> {\n  return new AssetPromise((resolve, reject, setProgress) => {\n    const xhr = new XMLHttpRequest();\n    xhr.timeout = config.timeout;\n    config.method = config.method ?? \"get\";\n    xhr.onload = () => {\n      if (xhr.status < 200 || xhr.status >= 300) {\n        reject(new Error(`request failed from: ${url}`));\n        return;\n      }\n      const result = xhr.response ?? xhr.responseText;\n      resolve(result);\n    };\n    xhr.onerror = () => {\n      reject(new Error(`request failed from: ${url}`));\n    };\n    xhr.ontimeout = () => {\n      reject(new Error(`request timeout from: ${url}`));\n    };\n    xhr.onprogress = (e) => {\n      setProgress(e.loaded / e.total);\n    };\n    xhr.open(config.method, url, true);\n    xhr.withCredentials = config.credentials === \"include\";\n    //@ts-ignore\n    xhr.responseType = config.type;\n    const headers = config.headers;\n    if (headers) {\n      Object.keys(headers).forEach((name) => {\n        xhr.setRequestHeader(name, headers[name]);\n      });\n    }\n    xhr.send(config.body);\n  });\n}\n\nfunction getMimeTypeFromUrl(url: string) {\n  const extname = url.substring(url.lastIndexOf(\".\") + 1);\n  return mimeType[extname];\n}\n\nexport class MultiExecutor {\n  private _timeoutId: number = -100;\n  private _currentCount = 0;\n  constructor(\n    private execFunc: (count?: number) => Promise<any>,\n    private totalCount: number,\n    private interval: number\n  ) {\n    this.exec = this.exec.bind(this);\n  }\n\n  private done: Function;\n  start(done?: Function): void {\n    this.done = done;\n    this.exec();\n  }\n\n  stop(): void {\n    clearTimeout(this._timeoutId);\n  }\n\n  private exec(): void {\n    if (this._currentCount >= this.totalCount) {\n      this.done && this.done();\n      return;\n    }\n    this._currentCount++;\n    this.execFunc(this._currentCount).then(() => {\n      //@ts-ignore\n      this._timeoutId = setTimeout(this.exec, this.interval);\n    });\n  }\n}\n", "import { LoadItem } from \"./LoadItem\";\nimport { AssetPromise } from \"./AssetPromise\";\nimport { RequestConfig, request } from \"./request\";\nimport { ResourceManager } from \"./ResourceManager\";\n/**\n * Loader abstract class.\n */\nexport abstract class Loader<T> {\n  request: <U>(url: string, config: RequestConfig) => AssetPromise<U> = request;\n  abstract load(item: LoadItem, resourceManager: ResourceManager): AssetPromise<T>;\n  constructor(public readonly useCache: boolean) {}\n}\n", "/**\n * Asset Type.\n */\nexport enum AssetType {\n  /**\n   * Plain text.\n   * @remarks Will not be cached based on url in ResourceManager.\n   */\n  Text = \"text\",\n  /**\n   * JSON.\n   * @remarks Will not be cached based on url in ResourceManager.\n   */\n  JSON = \"json\",\n  /**\n   * ArrayBuffer.\n   * @remarks Will not be cached based on url in ResourceManager.\n   */\n  Buffer = \"buffer\",\n  /** 2D Texture. */\n  Texture2D = \"texture2d\",\n  /** Cube Texture. */\n  TextureCube = \"texture-cube\",\n  /** Material. */\n  Material = \"material\",\n  /** Mesh. */\n  Mesh = \"mesh\",\n  /** Animation Clip. */\n  AnimationClip = \"animation-clip\",\n  /** Prefab.*/\n  Prefab = \"prefab\",\n  /** Compress Texture. */\n  KTX = \"ktx\",\n  /** Cube Compress Texture. */\n  KTXCube = \"ktx-cube\",\n  /** Sprite Atlas. */\n  SpriteAtlas = \"sprite-atlas\"\n}\n", "/**\n * Set which face for render.\n */\nexport enum RenderFace {\n  /** Render front face. */\n  Front,\n  /** Render back face. */\n  Back,\n  /** Render double face. */\n  Double\n}\n", "/**\n * Alpha blend mode.\n */\nexport enum BlendMode {\n  /** SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST */\n  Normal,\n  /** SRC ALPHA * SRC + ONE * DEST */\n  Additive\n}\n", "import { Engine } from \"../Engine\";\nimport { BlendFactor, BlendOperation, CullMode, Shader } from \"../shader\";\nimport { ShaderMacro } from \"../shader/ShaderMacro\";\nimport { BlendMode } from \"./enums/BlendMode\";\nimport { RenderFace } from \"./enums/RenderFace\";\nimport { RenderQueueType } from \"./enums/RenderQueueType\";\nimport { Material } from \"./Material\";\n\nexport class BaseMaterial extends Material {\n  private static _alphaCutoffMacro: ShaderMacro = Shader.getMacroByName(\"ALPHA_CUTOFF\");\n  private static _alphaCutoffProp = Shader.getPropertyByName(\"u_alphaCutoff\");\n\n  private _renderFace: RenderFace = RenderFace.Front;\n  private _isTransparent: boolean = false;\n  private _blendMode: BlendMode;\n\n  /**\n   * Is this material transparent.\n   * @remarks\n   * If material is transparent, transparent blend mode will be affected by `blendMode`, default is `BlendMode.Normal`.\n   */\n  get isTransparent(): boolean {\n    return this._isTransparent;\n  }\n\n  set isTransparent(value: boolean) {\n    if (value === this._isTransparent) return;\n    this._isTransparent = value;\n\n    const {\n      depthState,\n      blendState: { targetBlendState }\n    } = this.renderState;\n\n    if (value) {\n      targetBlendState.enabled = true;\n      depthState.writeEnabled = false;\n      this.renderQueueType = RenderQueueType.Transparent;\n    } else {\n      targetBlendState.enabled = false;\n      depthState.writeEnabled = true;\n      this.renderQueueType = this.shaderData.getFloat(BaseMaterial._alphaCutoffProp)\n        ? RenderQueueType.AlphaTest\n        : RenderQueueType.Opaque;\n    }\n  }\n\n  /**\n   * Alpha cutoff value.\n   * @remarks\n   * Fragments with alpha channel lower than cutoff value will be discarded.\n   * `0` means no fragment will be discarded.\n   */\n  get alphaCutoff(): number {\n    return this.shaderData.getFloat(BaseMaterial._alphaCutoffProp);\n  }\n\n  set alphaCutoff(value: number) {\n    this.shaderData.setFloat(BaseMaterial._alphaCutoffProp, value);\n\n    if (value > 0) {\n      this.shaderData.enableMacro(BaseMaterial._alphaCutoffMacro);\n      this.renderQueueType = this._isTransparent ? RenderQueueType.Transparent : RenderQueueType.AlphaTest;\n    } else {\n      this.shaderData.disableMacro(BaseMaterial._alphaCutoffMacro);\n      this.renderQueueType = this._isTransparent ? RenderQueueType.Transparent : RenderQueueType.Opaque;\n    }\n  }\n\n  /**\n   * Set which face for render.\n   */\n  get renderFace(): RenderFace {\n    return this._renderFace;\n  }\n\n  set renderFace(value: RenderFace) {\n    if (value === this._renderFace) return;\n    this._renderFace = value;\n\n    switch (value) {\n      case RenderFace.Front:\n        this.renderState.rasterState.cullMode = CullMode.Back;\n        break;\n      case RenderFace.Back:\n        this.renderState.rasterState.cullMode = CullMode.Front;\n        break;\n      case RenderFace.Double:\n        this.renderState.rasterState.cullMode = CullMode.Off;\n        break;\n    }\n  }\n\n  /**\n   * Alpha blend mode.\n   * @remarks\n   * Only take effect when `isTransparent` is `true`.\n   */\n  get blendMode(): BlendMode {\n    return this._blendMode;\n  }\n\n  set blendMode(value: BlendMode) {\n    if (value === this._blendMode) return;\n    this._blendMode = value;\n\n    const {\n      blendState: { targetBlendState: target }\n    } = this.renderState;\n\n    switch (value) {\n      case BlendMode.Normal:\n        target.sourceColorBlendFactor = BlendFactor.SourceAlpha;\n        target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;\n        target.sourceAlphaBlendFactor = BlendFactor.One;\n        target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;\n        target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;\n        break;\n      case BlendMode.Additive:\n        target.sourceColorBlendFactor = BlendFactor.SourceAlpha;\n        target.destinationColorBlendFactor = BlendFactor.One;\n        target.sourceAlphaBlendFactor = BlendFactor.One;\n        target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;\n        target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;\n        break;\n    }\n  }\n\n  /**\n   * Create a BaseMaterial instance.\n   * @param engine - Engine to which the material belongs\n   * @param shader - Shader used by the material\n   */\n  constructor(engine: Engine, shader: Shader) {\n    super(engine, shader);\n    this.blendMode = BlendMode.Normal;\n    this.shaderData.setFloat(BaseMaterial._alphaCutoffProp, 0);\n  }\n\n  /**\n   * @override\n   * Clone and return the instance.\n   */\n  clone(): BaseMaterial {\n    const dest = new BaseMaterial(this._engine, this.shader);\n    this.cloneTo(dest);\n    return dest;\n  }\n\n  /**\n   * @override\n   * Clone to the target material.\n   * @param target - target material\n   */\n  cloneTo(target: BaseMaterial): void {\n    super.cloneTo(target);\n    target._renderFace = this._renderFace;\n    target._isTransparent = this._isTransparent;\n    target._blendMode = this._blendMode;\n  }\n}\n", "import { Color, Vector4 } from \"@oasis-engine/math\";\nimport { Engine } from \"../Engine\";\nimport { Shader } from \"../shader/Shader\";\nimport { Texture2D } from \"../texture/Texture2D\";\nimport { BaseMaterial } from \"./BaseMaterial\";\n\n/**\n * Blinn-phong Material.\n */\nexport class BlinnPhongMaterial extends BaseMaterial {\n  private static _diffuseColorProp = Shader.getPropertyByName(\"u_diffuseColor\");\n  private static _specularColorProp = Shader.getPropertyByName(\"u_specularColor\");\n  private static _emissiveColorProp = Shader.getPropertyByName(\"u_emissiveColor\");\n  private static _tilingOffsetProp = Shader.getPropertyByName(\"u_tilingOffset\");\n  private static _shininessProp = Shader.getPropertyByName(\"u_shininess\");\n  private static _normalIntensityProp = Shader.getPropertyByName(\"u_normalIntensity\");\n\n  private static _baseTextureProp = Shader.getPropertyByName(\"u_diffuseTexture\");\n  private static _specularTextureProp = Shader.getPropertyByName(\"u_specularTexture\");\n  private static _emissiveTextureProp = Shader.getPropertyByName(\"u_emissiveTexture\");\n  private static _normalTextureProp = Shader.getPropertyByName(\"u_normalTexture\");\n\n  /**\n   * Base color.\n   */\n  get baseColor(): Color {\n    return this.shaderData.getColor(BlinnPhongMaterial._diffuseColorProp);\n  }\n\n  set baseColor(value: Color) {\n    const baseColor = this.shaderData.getColor(BlinnPhongMaterial._diffuseColorProp);\n    if (value !== baseColor) {\n      value.cloneTo(baseColor);\n    }\n  }\n\n  /**\n   * Base texture.\n   */\n  get baseTexture(): Texture2D {\n    return <Texture2D>this.shaderData.getTexture(BlinnPhongMaterial._baseTextureProp);\n  }\n\n  set baseTexture(value: Texture2D) {\n    this.shaderData.setTexture(BlinnPhongMaterial._baseTextureProp, value);\n    if (value) {\n      this.shaderData.enableMacro(\"O3_DIFFUSE_TEXTURE\");\n    } else {\n      this.shaderData.disableMacro(\"O3_DIFFUSE_TEXTURE\");\n    }\n  }\n\n  /**\n   * Specular color.\n   */\n  get specularColor(): Color {\n    return this.shaderData.getColor(BlinnPhongMaterial._specularColorProp);\n  }\n\n  set specularColor(value: Color) {\n    const specularColor = this.shaderData.getColor(BlinnPhongMaterial._specularColorProp);\n    if (value !== specularColor) {\n      value.cloneTo(specularColor);\n    }\n  }\n\n  /**\n   * Specular texture.\n   */\n  get specularTexture(): Texture2D {\n    return <Texture2D>this.shaderData.getTexture(BlinnPhongMaterial._specularTextureProp);\n  }\n\n  set specularTexture(value: Texture2D) {\n    this.shaderData.setTexture(BlinnPhongMaterial._specularTextureProp, value);\n    if (value) {\n      this.shaderData.enableMacro(\"O3_SPECULAR_TEXTURE\");\n    } else {\n      this.shaderData.disableMacro(\"O3_SPECULAR_TEXTURE\");\n    }\n  }\n\n  /**\n   * Emissive color.\n   */\n  get emissiveColor(): Color {\n    return this.shaderData.getColor(BlinnPhongMaterial._emissiveColorProp);\n  }\n\n  set emissiveColor(value: Color) {\n    const emissiveColor = this.shaderData.getColor(BlinnPhongMaterial._emissiveColorProp);\n    if (value !== emissiveColor) {\n      value.cloneTo(emissiveColor);\n    }\n  }\n\n  /**\n   * Emissive texture.\n   */\n  get emissiveTexture(): Texture2D {\n    return <Texture2D>this.shaderData.getTexture(BlinnPhongMaterial._emissiveTextureProp);\n  }\n\n  set emissiveTexture(value: Texture2D) {\n    this.shaderData.setTexture(BlinnPhongMaterial._emissiveTextureProp, value);\n    if (value) {\n      this.shaderData.enableMacro(\"O3_EMISSIVE_TEXTURE\");\n    } else {\n      this.shaderData.disableMacro(\"O3_EMISSIVE_TEXTURE\");\n    }\n  }\n\n  /**\n   * Normal texture.\n   */\n  get normalTexture(): Texture2D {\n    return <Texture2D>this.shaderData.getTexture(BlinnPhongMaterial._normalTextureProp);\n  }\n\n  set normalTexture(value: Texture2D) {\n    this.shaderData.setTexture(BlinnPhongMaterial._normalTextureProp, value);\n    if (value) {\n      this.shaderData.enableMacro(\"O3_NORMAL_TEXTURE\");\n    } else {\n      this.shaderData.disableMacro(\"O3_NORMAL_TEXTURE\");\n    }\n  }\n\n  /**\n   * Normal texture intensity.\n   */\n  get normalIntensity(): number {\n    return this.shaderData.getFloat(BlinnPhongMaterial._normalIntensityProp);\n  }\n\n  set normalIntensity(value: number) {\n    this.shaderData.setFloat(BlinnPhongMaterial._normalIntensityProp, value);\n  }\n\n  /**\n   * Set the specular reflection coefficient, the larger the value, the more convergent the specular reflection effect.\n   */\n  get shininess(): number {\n    return this.shaderData.getFloat(BlinnPhongMaterial._shininessProp);\n  }\n\n  set shininess(value: number) {\n    this.shaderData.setFloat(BlinnPhongMaterial._shininessProp, value);\n  }\n\n  /**\n   * Tiling and offset of main textures.\n   */\n  get tilingOffset(): Vector4 {\n    return this.shaderData.getVector4(BlinnPhongMaterial._tilingOffsetProp);\n  }\n\n  set tilingOffset(value: Vector4) {\n    const tilingOffset = this.shaderData.getVector4(BlinnPhongMaterial._tilingOffsetProp);\n    if (value !== tilingOffset) {\n      value.cloneTo(tilingOffset);\n    }\n  }\n\n  constructor(engine: Engine) {\n    super(engine, Shader.find(\"blinn-phong\"));\n\n    const shaderData = this.shaderData;\n\n    shaderData.enableMacro(\"O3_NEED_WORLDPOS\");\n    shaderData.enableMacro(\"O3_NEED_TILINGOFFSET\");\n\n    shaderData.setColor(BlinnPhongMaterial._diffuseColorProp, new Color(1, 1, 1, 1));\n    shaderData.setColor(BlinnPhongMaterial._specularColorProp, new Color(1, 1, 1, 1));\n    shaderData.setColor(BlinnPhongMaterial._emissiveColorProp, new Color(0, 0, 0, 1));\n    shaderData.setVector4(BlinnPhongMaterial._tilingOffsetProp, new Vector4(1, 1, 0, 0));\n    shaderData.setFloat(BlinnPhongMaterial._shininessProp, 16);\n    shaderData.setFloat(BlinnPhongMaterial._normalIntensityProp, 1);\n  }\n\n  /**\n   * @override\n   */\n  clone(): BlinnPhongMaterial {\n    var dest: BlinnPhongMaterial = new BlinnPhongMaterial(this._engine);\n    this.cloneTo(dest);\n    return dest;\n  }\n}\n", "import { Color, Vector4 } from \"@oasis-engine/math\";\nimport { Engine } from \"../Engine\";\nimport { Shader } from \"../shader/Shader\";\nimport { Texture2D } from \"../texture/Texture2D\";\nimport { BaseMaterial } from \"./BaseMaterial\";\n\n/**\n * PBR (Physically-Based Rendering) Material.\n */\nexport abstract class PBRBaseMaterial extends BaseMaterial {\n  private static _baseColorProp = Shader.getPropertyByName(\"u_baseColor\");\n  private static _emissiveColorProp = Shader.getPropertyByName(\"u_emissiveColor\");\n  private static _tilingOffsetProp = Shader.getPropertyByName(\"u_tilingOffset\");\n  private static _baseTextureProp = Shader.getPropertyByName(\"u_baseColorSampler\");\n  private static _normalTextureProp = Shader.getPropertyByName(\"u_normalTexture\");\n  private static _normalTextureIntensityProp = Shader.getPropertyByName(\"u_normalIntensity\");\n  private static _occlusionTextureIntensityProp = Shader.getPropertyByName(\"u_occlusionStrength\");\n\n  private static _emissiveTextureProp = Shader.getPropertyByName(\"u_emissiveSampler\");\n  private static _occlusionTextureProp = Shader.getPropertyByName(\"u_occlusionSampler\");\n\n  /**\n   * Base color.\n   */\n  get baseColor(): Color {\n    return this.shaderData.getColor(PBRBaseMaterial._baseColorProp);\n  }\n\n  set baseColor(value: Color) {\n    const baseColor = this.shaderData.getColor(PBRBaseMaterial._baseColorProp);\n    if (value !== baseColor) {\n      value.cloneTo(baseColor);\n    }\n  }\n\n  /**\n   * Base texture.\n   */\n  get baseTexture(): Texture2D {\n    return <Texture2D>this.shaderData.getTexture(PBRBaseMaterial._baseTextureProp);\n  }\n\n  set baseTexture(value: Texture2D) {\n    this.shaderData.setTexture(PBRBaseMaterial._baseTextureProp, value);\n    if (value) {\n      this.shaderData.enableMacro(\"HAS_BASECOLORMAP\");\n    } else {\n      this.shaderData.disableMacro(\"HAS_BASECOLORMAP\");\n    }\n  }\n\n  /**\n   * Normal texture.\n   */\n  get normalTexture(): Texture2D {\n    return <Texture2D>this.shaderData.getTexture(PBRBaseMaterial._normalTextureProp);\n  }\n\n  set normalTexture(value: Texture2D) {\n    this.shaderData.setTexture(PBRBaseMaterial._normalTextureProp, value);\n    if (value) {\n      this.shaderData.enableMacro(\"O3_NORMAL_TEXTURE\");\n    } else {\n      this.shaderData.disableMacro(\"O3_NORMAL_TEXTURE\");\n    }\n  }\n\n  /**\n   * Normal texture intensity.\n   */\n  get normalTextureIntensity(): number {\n    return this.shaderData.getFloat(PBRBaseMaterial._normalTextureIntensityProp);\n  }\n\n  set normalTextureIntensity(value: number) {\n    this.shaderData.setFloat(PBRBaseMaterial._normalTextureIntensityProp, value);\n    this.shaderData.setFloat(\"u_normalIntensity\", value);\n  }\n\n  /**\n   * Emissive color.\n   */\n  get emissiveColor(): Color {\n    return this.shaderData.getColor(PBRBaseMaterial._emissiveColorProp);\n  }\n\n  set emissiveColor(value: Color) {\n    const emissiveColor = this.shaderData.getColor(PBRBaseMaterial._emissiveColorProp);\n    if (value !== emissiveColor) {\n      value.cloneTo(emissiveColor);\n    }\n  }\n\n  /**\n   * Emissive texture.\n   */\n  get emissiveTexture(): Texture2D {\n    return <Texture2D>this.shaderData.getTexture(PBRBaseMaterial._emissiveTextureProp);\n  }\n\n  set emissiveTexture(value: Texture2D) {\n    this.shaderData.setTexture(PBRBaseMaterial._emissiveTextureProp, value);\n    if (value) {\n      this.shaderData.enableMacro(\"HAS_EMISSIVEMAP\");\n    } else {\n      this.shaderData.disableMacro(\"HAS_EMISSIVEMAP\");\n    }\n  }\n\n  /**\n   * Occlusion texture.\n   */\n  get occlusionTexture(): Texture2D {\n    return <Texture2D>this.shaderData.getTexture(PBRBaseMaterial._occlusionTextureProp);\n  }\n\n  set occlusionTexture(value: Texture2D) {\n    this.shaderData.setTexture(PBRBaseMaterial._occlusionTextureProp, value);\n    if (value) {\n      this.shaderData.enableMacro(\"HAS_OCCLUSIONMAP\");\n    } else {\n      this.shaderData.disableMacro(\"HAS_OCCLUSIONMAP\");\n    }\n  }\n\n  /**\n   * Occlusion texture intensity.\n   */\n  get occlusionTextureIntensity(): number {\n    return this.shaderData.getFloat(PBRBaseMaterial._occlusionTextureIntensityProp);\n  }\n\n  set occlusionTextureIntensity(value: number) {\n    this.shaderData.setFloat(PBRBaseMaterial._occlusionTextureIntensityProp, value);\n  }\n\n  /**\n   * Tiling and offset of main textures.\n   */\n  get tilingOffset(): Vector4 {\n    return this.shaderData.getVector4(PBRBaseMaterial._tilingOffsetProp);\n  }\n\n  set tilingOffset(value: Vector4) {\n    const tilingOffset = this.shaderData.getVector4(PBRBaseMaterial._tilingOffsetProp);\n    if (value !== tilingOffset) {\n      value.cloneTo(tilingOffset);\n    }\n  }\n\n  /**\n   * Create a pbr base material instance.\n   * @param engine - Engine to which the material belongs\n   */\n  protected constructor(engine: Engine) {\n    super(engine, Shader.find(\"pbr\"));\n\n    const shaderData = this.shaderData;\n\n    shaderData.enableMacro(\"O3_NEED_WORLDPOS\");\n    shaderData.enableMacro(\"O3_NEED_TILINGOFFSET\");\n\n    shaderData.setColor(PBRBaseMaterial._baseColorProp, new Color(1, 1, 1, 1));\n    shaderData.setColor(PBRBaseMaterial._emissiveColorProp, new Color(0, 0, 0, 1));\n    shaderData.setVector4(PBRBaseMaterial._tilingOffsetProp, new Vector4(1, 1, 0, 0));\n\n    shaderData.setFloat(PBRBaseMaterial._normalTextureIntensityProp, 1);\n    shaderData.setFloat(PBRBaseMaterial._occlusionTextureIntensityProp, 1);\n  }\n}\n", "import { Engine } from \"../Engine\";\nimport { Shader } from \"../shader/Shader\";\nimport { Texture2D } from \"../texture/Texture2D\";\nimport { PBRBaseMaterial } from \"./PBRBaseMaterial\";\n\n/**\n * PBR (Metallic-Roughness Workflow) Material.\n */\nexport class PBRMaterial extends PBRBaseMaterial {\n  private static _metallicProp = Shader.getPropertyByName(\"u_metal\");\n  private static _roughnessProp = Shader.getPropertyByName(\"u_roughness\");\n  private static _metallicRoughnessTextureProp = Shader.getPropertyByName(\"u_metallicRoughnessSampler\");\n\n  /**\n   * Metallic.\n   */\n  get metallic(): number {\n    return this.shaderData.getFloat(PBRMaterial._metallicProp);\n  }\n\n  set metallic(value: number) {\n    this.shaderData.setFloat(PBRMaterial._metallicProp, value);\n  }\n\n  /**\n   * Roughness.\n   */\n  get roughness(): number {\n    return this.shaderData.getFloat(PBRMaterial._roughnessProp);\n  }\n\n  set roughness(value: number) {\n    this.shaderData.setFloat(PBRMaterial._roughnessProp, value);\n  }\n\n  /**\n   * Roughness metallic texture.\n   * @remarks G channel is roughness, B channel is metallic\n   */\n  get roughnessMetallicTexture(): Texture2D {\n    return <Texture2D>this.shaderData.getTexture(PBRMaterial._metallicRoughnessTextureProp);\n  }\n\n  set roughnessMetallicTexture(value: Texture2D) {\n    this.shaderData.setTexture(PBRMaterial._metallicRoughnessTextureProp, value);\n    if (value) {\n      this.shaderData.enableMacro(\"HAS_METALROUGHNESSMAP\");\n    } else {\n      this.shaderData.disableMacro(\"HAS_METALROUGHNESSMAP\");\n    }\n  }\n\n  /**\n   * Create a pbr metallic-roughness workflow material instance.\n   * @param engine - Engine to which the material belongs\n   */\n  constructor(engine: Engine) {\n    super(engine);\n    this.shaderData.enableMacro(\"IS_METALLIC_WORKFLOW\");\n    this.shaderData.setFloat(PBRMaterial._metallicProp, 1.0);\n    this.shaderData.setFloat(PBRMaterial._roughnessProp, 1.0);\n  }\n\n  /**\n   * @override\n   */\n  clone(): PBRMaterial {\n    const dest = new PBRMaterial(this._engine);\n    this.cloneTo(dest);\n    return dest;\n  }\n}\n", "import { Color } from \"@oasis-engine/math\";\nimport { Engine } from \"../Engine\";\nimport { Shader } from \"../shader/Shader\";\nimport { Texture2D } from \"../texture/Texture2D\";\nimport { PBRBaseMaterial } from \"./PBRBaseMaterial\";\n\n/**\n * PBR (Specular-Glossiness Workflow) Material.\n */\nexport class PBRSpecularMaterial extends PBRBaseMaterial {\n  private static _specularColorProp = Shader.getPropertyByName(\"u_specularColor\");\n  private static _glossinessProp = Shader.getPropertyByName(\"u_glossinessFactor\");\n  private static _specularGlossinessTextureProp = Shader.getPropertyByName(\"u_specularGlossinessSampler\");\n\n  /**\n   * Specular color.\n   */\n  get specularColor(): Color {\n    return this.shaderData.getColor(PBRSpecularMaterial._specularColorProp);\n  }\n\n  set specularColor(value: Color) {\n    const specularColor = this.shaderData.getColor(PBRSpecularMaterial._specularColorProp);\n    if (value !== specularColor) {\n      value.cloneTo(specularColor);\n    }\n  }\n\n  /**\n   * Glossiness.\n   */\n  get glossiness(): number {\n    return this.shaderData.getFloat(PBRSpecularMaterial._glossinessProp);\n  }\n\n  set glossiness(value: number) {\n    this.shaderData.setFloat(PBRSpecularMaterial._glossinessProp, value);\n  }\n\n  /**\n   * Specular glossiness texture.\n   * @remarks RGB is specular, A is glossiness\n   */\n  get specularGlossinessTexture(): Texture2D {\n    return <Texture2D>this.shaderData.getTexture(PBRSpecularMaterial._specularGlossinessTextureProp);\n  }\n\n  set specularGlossinessTexture(value: Texture2D) {\n    this.shaderData.setTexture(PBRSpecularMaterial._specularGlossinessTextureProp, value);\n    if (value) {\n      this.shaderData.enableMacro(\"HAS_SPECULARGLOSSINESSMAP\");\n    } else {\n      this.shaderData.disableMacro(\"HAS_SPECULARGLOSSINESSMAP\");\n    }\n  }\n\n  /**\n   * Create a pbr specular-glossiness workflow material instance.\n   * @param engine - Engine to which the material belongs\n   */\n  constructor(engine: Engine) {\n    super(engine);\n\n    this.shaderData.setColor(PBRSpecularMaterial._specularColorProp, new Color(1, 1, 1, 1));\n    this.shaderData.setFloat(PBRSpecularMaterial._glossinessProp, 1.0);\n  }\n\n  /**\n   * @override\n   */\n  clone(): PBRSpecularMaterial {\n    const dest = new PBRSpecularMaterial(this._engine);\n    this.cloneTo(dest);\n    return dest;\n  }\n}\n", "import { Color, Vector4 } from \"@oasis-engine/math\";\nimport { Engine } from \"../Engine\";\nimport { Shader } from \"../shader/Shader\";\nimport { Texture2D } from \"../texture/Texture2D\";\nimport { BaseMaterial } from \"./BaseMaterial\";\n\n/**\n * Unlit Material.\n */\nexport class UnlitMaterial extends BaseMaterial {\n  private static _baseColorProp = Shader.getPropertyByName(\"u_baseColor\");\n  private static _baseTextureProp = Shader.getPropertyByName(\"u_baseTexture\");\n  private static _tilingOffsetProp = Shader.getPropertyByName(\"u_tilingOffset\");\n\n  /**\n   * Base color.\n   */\n  get baseColor(): Color {\n    return this.shaderData.getColor(UnlitMaterial._baseColorProp);\n  }\n\n  set baseColor(value: Color) {\n    const baseColor = this.shaderData.getColor(UnlitMaterial._baseColorProp);\n    if (value !== baseColor) {\n      value.cloneTo(baseColor);\n    }\n  }\n\n  /**\n   * Base texture.\n   */\n  get baseTexture(): Texture2D {\n    return <Texture2D>this.shaderData.getTexture(UnlitMaterial._baseTextureProp);\n  }\n\n  set baseTexture(value: Texture2D) {\n    this.shaderData.setTexture(UnlitMaterial._baseTextureProp, value);\n    if (value) {\n      this.shaderData.enableMacro(\"O3_BASE_TEXTURE\");\n    } else {\n      this.shaderData.disableMacro(\"O3_BASE_TEXTURE\");\n    }\n  }\n\n  /**\n   * Tiling and offset of main textures.\n   */\n  get tilingOffset(): Vector4 {\n    return this.shaderData.getVector4(UnlitMaterial._tilingOffsetProp);\n  }\n\n  set tilingOffset(value: Vector4) {\n    const tilingOffset = this.shaderData.getVector4(UnlitMaterial._tilingOffsetProp);\n    if (value !== tilingOffset) {\n      value.cloneTo(tilingOffset);\n    }\n  }\n\n  /**\n   * Create a unlit material instance.\n   * @param engine - Engine to which the material belongs\n   */\n  constructor(engine: Engine) {\n    super(engine, Shader.find(\"unlit\"));\n\n    const shaderData = this.shaderData;\n\n    shaderData.enableMacro(\"OMIT_NORMAL\");\n    shaderData.enableMacro(\"O3_NEED_TILINGOFFSET\");\n\n    shaderData.setColor(UnlitMaterial._baseColorProp, new Color(1, 1, 1, 1));\n    shaderData.setVector4(UnlitMaterial._tilingOffsetProp, new Vector4(1, 1, 0, 0));\n  }\n\n  /**\n   * @override\n   */\n  clone(): UnlitMaterial {\n    const dest = new UnlitMaterial(this._engine);\n    this.cloneTo(dest);\n    return dest;\n  }\n}\n", "import { RefObject } from \"../../asset/RefObject\";\nimport { Engine } from \"../../Engine\";\nimport { Sprite } from \"../sprite/Sprite\";\n\n/**\n * Sprite Atlas.\n */\nexport class SpriteAtlas extends RefObject {\n  private _sprites: Sprite[] = new Array<Sprite>();\n  private _spriteNamesToIndex: Record<string, number> = {};\n\n  /**\n   * All the sprites in the atlas.\n   */\n  get sprites(): Readonly<Sprite[]> {\n    return this._sprites;\n  }\n\n  /**\n   * Get the last sprite named 'name' from the atlas.\n   * @param name - The name of the sprite you want to find\n   * @returns The sprite you want to find\n   */\n  getSprite(name: string): Sprite {\n    const sprite = this._sprites[this._spriteNamesToIndex[name]];\n    if (!sprite) {\n      console.warn(\"There is no sprite named \" + name + \" in the atlas.\");\n    }\n    return sprite;\n  }\n\n  /**\n   * Get all the sprite named 'name' from the atlas.\n   * @param name - The name of the sprites you want to find\n   * @param outSprites - This array holds the sprites found\n   * @returns The sprites you want to find\n   */\n  getSprites(name: string, outSprites: Sprite[]): Sprite[] {\n    outSprites.length = 0;\n    let i = this._spriteNamesToIndex[name];\n    if (i !== undefined) {\n      const { _sprites } = this;\n      for (; i >= 0; i--) {\n        const sprite = _sprites[i];\n        sprite.name === name && outSprites.push(sprite);\n      }\n    } else {\n      console.warn(\"The name of the sprite you want to find is not exit in SpriteAtlas.\");\n    }\n    return outSprites;\n  }\n\n  /**\n   * Constructor a SpriteAtlas.\n   * @param engine - Engine to which the SpriteAtlas belongs\n   */\n  constructor(engine: Engine) {\n    super(engine);\n  }\n\n  /**\n   * @internal\n   */\n  _addSprite(sprite: Sprite): void {\n    this._spriteNamesToIndex[sprite.name] = this._sprites.push(sprite) - 1;\n  }\n\n  /**\n   * @override\n   */\n  _onDestroy(): void {\n    this._sprites = null;\n    this._spriteNamesToIndex = null;\n  }\n}\n", "import { BoundingBox, MathUtil, Rect, Vector2, Vector4 } from \"@oasis-engine/math\";\nimport { RefObject } from \"../../asset/RefObject\";\nimport { Engine } from \"../../Engine\";\nimport { Texture2D } from \"../../texture/Texture2D\";\n\n/**\n * 2D sprite.\n */\nexport class Sprite extends RefObject {\n  private static _rectangleTriangles: number[] = [0, 2, 1, 2, 0, 3];\n\n  /** The name of sprite. */\n  name: string;\n\n  /** @internal */\n  _uv: Vector2[] = [new Vector2(), new Vector2(), new Vector2(), new Vector2()];\n  /** @internal */\n  _positions: Vector2[] = [new Vector2(), new Vector2(), new Vector2(), new Vector2()];\n  /** @internal */\n  _bounds: BoundingBox = new BoundingBox();\n  /** @internal */\n  _triangles: number[];\n  /** @internal temp solution. */\n  _assetID: number;\n\n  private _pixelsPerUnit: number;\n  private _texture: Texture2D = null;\n  private _atlasRotated: boolean = false;\n  private _region: Rect = new Rect(0, 0, 1, 1);\n  private _pivot: Vector2 = new Vector2(0.5, 0.5);\n  private _atlasRegion: Rect = new Rect(0, 0, 1, 1);\n  private _atlasRegionOffset: Vector4 = new Vector4(0, 0, 0, 0);\n  private _dirtyFlag: DirtyFlag = DirtyFlag.all;\n\n  /**\n   * The reference to the used texture.\n   */\n  get texture(): Texture2D {\n    return this._texture;\n  }\n\n  set texture(value: Texture2D) {\n    if (this._texture !== value) {\n      this._texture = value;\n      this._setDirtyFlagTrue(DirtyFlag.positions);\n    }\n  }\n\n  /**\n   *  Bounding volume of the sprite.\n   *  @remarks The returned bounds should be considered deep-read-only.\n   */\n  get bounds(): Readonly<BoundingBox> {\n    if (this._isContainDirtyFlag(DirtyFlag.positions) && this._texture) {\n      this._updatePositionsAndBounds();\n      this._setDirtyFlagFalse(DirtyFlag.positions);\n    }\n    return this._bounds;\n  }\n\n  /**\n   * Is it rotated 90 degrees clockwise when packing.\n   */\n  get atlasRotated(): boolean {\n    return this._atlasRotated;\n  }\n\n  set atlasRotated(value: boolean) {\n    if (this._atlasRotated != value) {\n      this._atlasRotated = value;\n      this._setDirtyFlagTrue(DirtyFlag.positions | DirtyFlag.uv);\n    }\n  }\n\n  /**\n   * The rectangle region of the original texture on its atlas texture, specified in normalized.\n   */\n  get atlasRegion(): Rect {\n    return this._atlasRegion;\n  }\n\n  set atlasRegion(value: Rect) {\n    const x = MathUtil.clamp(value.x, 0, 1);\n    const y = MathUtil.clamp(value.y, 0, 1);\n    this._atlasRegion.setValue(x, y, MathUtil.clamp(value.width, 0, 1 - x), MathUtil.clamp(value.height, 0, 1 - y));\n    this._setDirtyFlagTrue(DirtyFlag.positions | DirtyFlag.uv);\n  }\n\n  /**\n   * The rectangle region offset of the original texture on its atlas texture, specified in normalized.\n   */\n  get atlasRegionOffset(): Vector4 {\n    return this._atlasRegionOffset;\n  }\n\n  set atlasRegionOffset(value: Vector4) {\n    const x = MathUtil.clamp(value.x, 0, 1);\n    const y = MathUtil.clamp(value.y, 0, 1);\n    this._atlasRegionOffset.setValue(x, y, MathUtil.clamp(value.z, 0, 1 - x), MathUtil.clamp(value.w, 0, 1 - y));\n    this._setDirtyFlagTrue(DirtyFlag.positions | DirtyFlag.uv);\n  }\n\n  /**\n   * Location of the sprite's center point in the rectangle region, specified in normalized.\n   */\n  get pivot(): Vector2 {\n    return this._pivot;\n  }\n\n  set pivot(value: Vector2) {\n    this._pivot.setValue(MathUtil.clamp(value.x, 0, 1), MathUtil.clamp(value.y, 0, 1));\n    this._setDirtyFlagTrue(DirtyFlag.positions);\n  }\n\n  /**\n   * The rectangle region of the sprite, specified in normalized.\n   */\n  get region(): Rect {\n    return this._region;\n  }\n\n  set region(value: Rect) {\n    const region = this._region;\n    const x = MathUtil.clamp(value.x, 0, 1);\n    const y = MathUtil.clamp(value.y, 0, 1);\n    region.setValue(x, y, MathUtil.clamp(value.width, 0, 1 - x), MathUtil.clamp(value.height, 0, 1 - y));\n    this._setDirtyFlagTrue(DirtyFlag.positions | DirtyFlag.uv);\n  }\n\n  /**\n   * The number of pixels in the sprite that correspond to one unit in world space.\n   */\n  get pixelsPerUnit(): number {\n    return this._pixelsPerUnit;\n  }\n\n  set pixelsPerUnit(value: number) {\n    if (this._pixelsPerUnit !== value) {\n      this._pixelsPerUnit = value;\n      this._setDirtyFlagTrue(DirtyFlag.positions);\n    }\n  }\n\n  /**\n   * Constructor a Sprite.\n   * @param engine - Engine to which the sprite belongs\n   * @param texture - Texture from which to obtain the Sprite\n   * @param region - Rectangle region of the texture to use for the Sprite, specified in normalized\n   * @param pivot - Sprite's pivot point relative to its graphic rectangle, specified in normalized\n   * @param pixelsPerUnit - The number of pixels in the Sprite that correspond to one unit in world space\n   * @param name - The name of Sprite\n   */\n  constructor(\n    engine: Engine,\n    texture: Texture2D = null,\n    region: Rect = null,\n    pivot: Vector2 = null,\n    pixelsPerUnit: number = 128,\n    name: string = null\n  ) {\n    super(engine);\n\n    this.name = name;\n    this._texture = texture;\n    this._pixelsPerUnit = pixelsPerUnit;\n\n    region && region.cloneTo(this._region);\n    pivot && pivot.cloneTo(this._pivot);\n\n    this._triangles = Sprite._rectangleTriangles;\n  }\n\n  /**\n   * @override\n   */\n  _onDestroy(): void {\n    if (this._texture) {\n      this._texture = null;\n    }\n  }\n\n  /**\n   * Update positions and bounds.\n   */\n  private _updatePositionsAndBounds(): void {\n    const { _texture: texture, _bounds: bounds } = this;\n    if (texture) {\n      const { _atlasRegion: atlasRegion, _pivot: pivot, _atlasRegionOffset: atlasRegionOffset } = this;\n      const { x: regionX, y: regionY, width: regionW, height: regionH } = this._region;\n      const pPUReciprocal = 1.0 / this._pixelsPerUnit;\n      // Coordinates of the four boundaries.\n      let lx: number, ty: number, rx: number, by: number;\n      // TextureSize\n      let textureW: number, textureH: number;\n      if (this._atlasRotated) {\n        textureW = texture.height * atlasRegion.height * pPUReciprocal;\n        textureH = texture.width * atlasRegion.width * pPUReciprocal;\n      } else {\n        textureW = texture.width * atlasRegion.width * pPUReciprocal;\n        textureH = texture.height * atlasRegion.height * pPUReciprocal;\n      }\n      // Determine whether it has been trimmed.\n      if (\n        atlasRegionOffset.x == 0 &&\n        atlasRegionOffset.y == 0 &&\n        atlasRegionOffset.z == 0 &&\n        atlasRegionOffset.w == 0\n      ) {\n        // Real rendering size.\n        const realRenderW = textureW * regionW;\n        const realRenderH = textureH * regionH;\n        lx = -pivot.x * realRenderW;\n        by = -pivot.y * realRenderH;\n        rx = realRenderW + lx;\n        ty = realRenderH + by;\n      } else {\n        const { x: blankLeft, y: blankTop, z: blankRight, w: blankBottom } = atlasRegionOffset;\n        const oriWidth = textureW / (1 - blankRight - blankLeft);\n        const oriHeight = textureH / (1 - blankBottom - blankTop);\n        // The size of the real rendering.\n        lx = (-pivot.x * regionW + Math.max(blankLeft, regionX) - regionX) * oriWidth;\n        ty = (pivot.y * regionH - Math.max(blankTop, regionY) + regionY) * oriHeight;\n        rx = (-pivot.x * regionW + Math.min(1 - blankRight, regionX + regionW) - regionX) * oriWidth;\n        by = (pivot.y * regionH - Math.min(1 - blankBottom, regionY + regionH) + regionY) * oriHeight;\n      }\n\n      // Assign values \u200B\u200Bto _positions\n      const positions = this._positions;\n      // Top-left.\n      positions[0].setValue(lx, ty);\n      // Top-right.\n      positions[1].setValue(rx, ty);\n      // Bottom-right.\n      positions[2].setValue(rx, by);\n      // Bottom-left.\n      positions[3].setValue(lx, by);\n\n      // Update bounds.\n      bounds.min.setValue(lx, by, 0);\n      bounds.max.setValue(rx, ty, 0);\n    } else {\n      // Update bounds.\n      bounds.min.setValue(0, 0, 0);\n      bounds.max.setValue(0, 0, 0);\n    }\n  }\n\n  /**\n   * Update mesh.\n   */\n  private _updateMesh(): void {\n    if (this._isContainDirtyFlag(DirtyFlag.positions)) {\n      this._updatePositionsAndBounds();\n    }\n\n    if (this._isContainDirtyFlag(DirtyFlag.uv)) {\n      const { _atlasRegion, _uv: uv, _region: region, _atlasRotated, _atlasRegionOffset: atlasRegionOffset } = this;\n      let left: number, top: number, right: number, bottom: number;\n      // Determine whether it has been trimmed.\n      if (\n        atlasRegionOffset.x == 0 &&\n        atlasRegionOffset.y == 0 &&\n        atlasRegionOffset.z == 0 &&\n        atlasRegionOffset.w == 0\n      ) {\n        const { width: atlasRegionW, height: atlasRegionH } = _atlasRegion;\n        if (_atlasRotated) {\n          left = atlasRegionW * (1 - region.y - region.height) + _atlasRegion.x;\n          top = atlasRegionH * region.x + _atlasRegion.y;\n          right = atlasRegionW * region.height + left;\n          bottom = atlasRegionH * region.width + top;\n        } else {\n          left = atlasRegionW * region.x + _atlasRegion.x;\n          top = atlasRegionH * region.y + _atlasRegion.y;\n          right = atlasRegionW * region.width + left;\n          bottom = atlasRegionH * region.height + top;\n        }\n      } else {\n        const { x: regionX, y: regionY } = region;\n        const { x: atlasRegionX, y: atlasRegionY } = _atlasRegion;\n        const { x: blankLeft, y: blankTop, z: blankRight, w: blankBottom } = atlasRegionOffset;\n        // Proportion of the original sprite size in the atlas.\n        if (_atlasRotated) {\n          const textureW = _atlasRegion.width / (1 - blankBottom - blankTop);\n          const textureH = _atlasRegion.height / (1 - blankRight - blankLeft);\n          left = (Math.max(blankBottom, 1 - regionY - region.height) - blankBottom) * textureW + atlasRegionX;\n          top = (Math.max(blankLeft, regionX) - blankLeft) * textureH + atlasRegionY;\n          right = (Math.min(1 - blankTop, 1 - regionY) - blankBottom) * textureW + atlasRegionX;\n          bottom = (Math.min(1 - blankRight, regionX + region.width) - blankLeft) * textureH + atlasRegionY;\n        } else {\n          const textureW = _atlasRegion.width / (1 - blankRight - blankLeft);\n          const textureH = _atlasRegion.height / (1 - blankBottom - blankTop);\n          left = (Math.max(blankLeft, regionX) - blankLeft) * textureW + atlasRegionX;\n          top = (Math.max(blankTop, regionY) - blankTop) * textureH + atlasRegionY;\n          right = (Math.min(1 - blankRight, regionX + region.width) - blankLeft) * textureW + atlasRegionX;\n          bottom = (Math.min(1 - blankBottom, regionY + region.height) - blankTop) * textureH + atlasRegionY;\n        }\n      }\n\n      if (_atlasRotated) {\n        // If it is rotated, we need to rotate the UV 90 degrees counterclockwise to correct it.\n        // Top-right.\n        uv[0].setValue(right, top);\n        // Bottom-right.\n        uv[1].setValue(right, bottom);\n        // Bottom-left.\n        uv[2].setValue(left, bottom);\n        // Top-left.\n        uv[3].setValue(left, top);\n      } else {\n        // Top-left.\n        uv[0].setValue(left, top);\n        // Top-right.\n        uv[1].setValue(right, top);\n        // Bottom-right.\n        uv[2].setValue(right, bottom);\n        // Bottom-left.\n        uv[3].setValue(left, bottom);\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * Update mesh data of the sprite.\n   * @returns True if the data is refreshed, false otherwise.\n   */\n  _updateMeshData(): boolean {\n    if (this._isContainDirtyFlag(DirtyFlag.all)) {\n      this._updateMesh();\n      this._setDirtyFlagFalse(DirtyFlag.all);\n      return true;\n    }\n    return false;\n  }\n\n  private _isContainDirtyFlag(type: number): boolean {\n    return (this._dirtyFlag & type) != 0;\n  }\n\n  private _setDirtyFlagTrue(type: number): void {\n    this._dirtyFlag |= type;\n  }\n\n  private _setDirtyFlagFalse(type: number): void {\n    this._dirtyFlag &= ~type;\n  }\n}\n\nenum DirtyFlag {\n  positions = 0x1,\n  uv = 0x2,\n  all = 0x3\n}\n", "import { BoundingBox, Color, Vector3 } from \"@oasis-engine/math\";\nimport { Camera } from \"../../Camera\";\nimport { assignmentClone, deepClone, ignoreClone } from \"../../clone/CloneManager\";\nimport { Entity } from \"../../Entity\";\nimport { Renderer } from \"../../Renderer\";\nimport { CompareFunction } from \"../../shader/enums/CompareFunction\";\nimport { Shader } from \"../../shader/Shader\";\nimport { ShaderProperty } from \"../../shader/ShaderProperty\";\nimport { UpdateFlag } from \"../../UpdateFlag\";\nimport { SpriteMaskInteraction } from \"../enums/SpriteMaskInteraction\";\nimport { SpriteMaskLayer } from \"../enums/SpriteMaskLayer\";\nimport { Sprite } from \"./Sprite\";\n\n/**\n * Renders a Sprite for 2D graphics.\n */\nexport class SpriteRenderer extends Renderer {\n  private static _textureProperty: ShaderProperty = Shader.getPropertyByName(\"u_spriteTexture\");\n  private static _tempVec3: Vector3 = new Vector3();\n\n  /** @internal temp solution. */\n  @ignoreClone\n  _customLocalBounds: BoundingBox = null;\n  /** @internal temp solution. */\n  @ignoreClone\n  _customRootEntity: Entity = null;\n\n  @deepClone\n  private _positions: Vector3[] = [new Vector3(), new Vector3(), new Vector3(), new Vector3()];\n  @assignmentClone\n  private _sprite: Sprite = null;\n  @deepClone\n  private _color: Color = new Color(1, 1, 1, 1);\n  @assignmentClone\n  private _flipX: boolean = false;\n  @assignmentClone\n  private _flipY: boolean = false;\n  @assignmentClone\n  private _cacheFlipX: boolean = false;\n  @assignmentClone\n  private _cacheFlipY: boolean = false;\n  @ignoreClone\n  private _dirtyFlag: number = DirtyFlag.All;\n  @ignoreClone\n  private _isWorldMatrixDirty: UpdateFlag;\n  @assignmentClone\n  private _maskInteraction: SpriteMaskInteraction = SpriteMaskInteraction.None;\n  @assignmentClone\n  private _maskLayer: number = SpriteMaskLayer.Layer0;\n\n  /**\n   * The Sprite to render.\n   */\n  get sprite(): Sprite {\n    return this._sprite;\n  }\n\n  set sprite(value: Sprite | null) {\n    if (this._sprite !== value) {\n      this._sprite = value;\n      this._setDirtyFlagTrue(DirtyFlag.Sprite);\n    }\n  }\n\n  /**\n   * Rendering color for the Sprite graphic.\n   */\n  get color(): Color {\n    return this._color;\n  }\n\n  set color(value: Color) {\n    if (this._color !== value) {\n      value.cloneTo(this._color);\n    }\n  }\n\n  /**\n   * Flips the sprite on the X axis.\n   */\n  get flipX(): boolean {\n    return this._flipX;\n  }\n\n  set flipX(value: boolean) {\n    if (this._flipX !== value) {\n      this._flipX = value;\n      this._setDirtyFlagTrue(DirtyFlag.Flip);\n    }\n  }\n\n  /**\n   * Flips the sprite on the Y axis.\n   */\n  get flipY(): boolean {\n    return this._flipY;\n  }\n\n  set flipY(value: boolean) {\n    if (this._flipY !== value) {\n      this._flipY = value;\n      this._setDirtyFlagTrue(DirtyFlag.Flip);\n    }\n  }\n\n  /**\n   * Interacts with the masks.\n   */\n  get maskInteraction(): SpriteMaskInteraction {\n    return this._maskInteraction;\n  }\n\n  set maskInteraction(value: SpriteMaskInteraction) {\n    if (this._maskInteraction !== value) {\n      this._maskInteraction = value;\n      this._setDirtyFlagTrue(DirtyFlag.MaskInteraction);\n    }\n  }\n\n  /**\n   * The mask layer the sprite renderer belongs to.\n   */\n  get maskLayer(): number {\n    return this._maskLayer;\n  }\n\n  set maskLayer(value: number) {\n    this._maskLayer = value;\n  }\n\n  /**\n   * @internal\n   */\n  constructor(entity: Entity) {\n    super(entity);\n    this._isWorldMatrixDirty = entity.transform.registerWorldChangeFlag();\n    this.setMaterial(this._engine._spriteDefaultMaterial);\n  }\n\n  /**\n   * @internal\n   */\n  _render(camera: Camera): void {\n    const { sprite } = this;\n    if (!sprite) {\n      return;\n    }\n    const { texture } = sprite;\n    if (!texture) {\n      return;\n    }\n\n    const { _positions } = this;\n    const { transform } = this.entity;\n\n    // Update sprite data.\n    const localDirty = sprite._updateMeshData();\n\n    if (this._isWorldMatrixDirty.flag || localDirty || this._isContainDirtyFlag(DirtyFlag.Sprite)) {\n      const localPositions = sprite._positions;\n      const localVertexPos = SpriteRenderer._tempVec3;\n      const worldMatrix = transform.worldMatrix;\n      const { flipX, flipY } = this;\n\n      for (let i = 0, n = _positions.length; i < n; i++) {\n        const curVertexPos = localPositions[i];\n        localVertexPos.setValue(flipX ? -curVertexPos.x : curVertexPos.x, flipY ? -curVertexPos.y : curVertexPos.y, 0);\n        Vector3.transformToVec3(localVertexPos, worldMatrix, _positions[i]);\n      }\n\n      this._setDirtyFlagFalse(DirtyFlag.Flip);\n      this._setDirtyFlagFalse(DirtyFlag.Sprite);\n      this._isWorldMatrixDirty.flag = false;\n      this._cacheFlipX = flipX;\n      this._cacheFlipY = flipY;\n    } else if (this._isContainDirtyFlag(DirtyFlag.Flip)) {\n      const { flipX, flipY } = this;\n      const flipXChange = this._cacheFlipX !== flipX;\n      const flipYChange = this._cacheFlipY !== flipY;\n\n      if (flipXChange || flipYChange) {\n        const { x, y } = transform.worldPosition;\n\n        for (let i = 0, n = _positions.length; i < n; i++) {\n          const curPos = _positions[i];\n\n          if (flipXChange) {\n            curPos.x = x * 2 - curPos.x;\n          }\n          if (flipYChange) {\n            curPos.y = y * 2 - curPos.y;\n          }\n        }\n      }\n\n      this._setDirtyFlagFalse(DirtyFlag.Flip);\n      this._cacheFlipX = flipX;\n      this._cacheFlipY = flipY;\n    }\n\n    if (this._isContainDirtyFlag(DirtyFlag.MaskInteraction)) {\n      this._updateStencilState();\n      this._setDirtyFlagFalse(DirtyFlag.MaskInteraction);\n    }\n\n    this.shaderData.setTexture(SpriteRenderer._textureProperty, texture);\n    const material = this.getMaterial();\n\n    const spriteElementPool = this._engine._spriteElementPool;\n    const spriteElement = spriteElementPool.getFromPool();\n    spriteElement.setValue(this, _positions, sprite._uv, sprite._triangles, this.color, material, camera);\n    camera._renderPipeline.pushPrimitive(spriteElement);\n  }\n\n  /**\n   * @internal\n   */\n  _onDestroy(): void {\n    this._isWorldMatrixDirty.destroy();\n    super._onDestroy();\n  }\n\n  private _isContainDirtyFlag(type: number): boolean {\n    return (this._dirtyFlag & type) != 0;\n  }\n\n  private _setDirtyFlagTrue(type: number): void {\n    this._dirtyFlag |= type;\n  }\n\n  private _setDirtyFlagFalse(type: number): void {\n    this._dirtyFlag &= ~type;\n  }\n\n  /**\n   * @override\n   */\n  protected _updateBounds(worldBounds: BoundingBox): void {\n    const sprite = this._sprite;\n    if (sprite) {\n      if (this._customLocalBounds && this._customRootEntity) {\n        const worldMatrix = this._customRootEntity.transform.worldMatrix;\n        BoundingBox.transform(this._customLocalBounds, worldMatrix, worldBounds);\n      } else {\n        const localBounds = sprite.bounds;\n        const worldMatrix = this._entity.transform.worldMatrix;\n        BoundingBox.transform(localBounds, worldMatrix, worldBounds);\n      }\n    } else {\n      worldBounds.min.setValue(0, 0, 0);\n      worldBounds.max.setValue(0, 0, 0);\n    }\n  }\n\n  private _updateStencilState(): void {\n    // Update stencil.\n    const material = this.getInstanceMaterial();\n    const stencilState = material.renderState.stencilState;\n    const maskInteraction = this._maskInteraction;\n\n    if (maskInteraction === SpriteMaskInteraction.None) {\n      stencilState.enabled = false;\n      stencilState.writeMask = 0xff;\n      stencilState.referenceValue = 0;\n      stencilState.compareFunctionFront = stencilState.compareFunctionBack = CompareFunction.Always;\n    } else {\n      stencilState.enabled = true;\n      stencilState.writeMask = 0x00;\n      stencilState.referenceValue = 1;\n      const compare =\n        maskInteraction === SpriteMaskInteraction.VisibleInsideMask\n          ? CompareFunction.LessEqual\n          : CompareFunction.Greater;\n      stencilState.compareFunctionFront = compare;\n      stencilState.compareFunctionBack = compare;\n    }\n  }\n}\n\nenum DirtyFlag {\n  Flip = 0x1,\n  Sprite = 0x2,\n  All = 0x3,\n  MaskInteraction = 0x4\n}\n", "import { AnimationProperty } from \"./enums/AnimationProperty\";\nimport { Entity } from \"../Entity\";\nimport { Component } from \"../Component\";\nimport { AnimationCurve } from \"./AnimationCurve\";\n\n/**\n * Associate AnimationCurve and the Entity\n */\nexport class AnimationClipCurveBinding {\n  /** Path to the entity this curve applies to. The relativePath is formatted similar to a pathname,\n   * e.g. \"root/spine/leftArm\". If relativePath is empty it refers to the entity the animation clip is attached to. */\n  relativePath: string;\n  /** The class type of the component that is animated. */\n  type: new (entity: Entity) => Component;\n  /** The name or path to the property being animated. */\n  property: AnimationProperty;\n  /** The animation curve. */\n  curve: AnimationCurve;\n}\n", "export enum AnimationProperty {\n  Position,\n  Rotation,\n  Scale,\n  BlendShapeWeights\n}\n", "/**\n * Base class for AnimationClips and BlendTrees.\n */\nexport class Motion {}\n", "import { Quaternion, Vector3 } from \"@oasis-engine/math\";\nimport { Component } from \"../Component\";\nimport { Entity } from \"../Entity\";\nimport { Transform } from \"../Transform\";\nimport { AnimationClipCurveBinding } from \"./AnimationClipCurveBinding\";\nimport { AnimationCurve } from \"./AnimationCurve\";\nimport { AnimationEvent } from \"./AnimationEvent\";\nimport { AnimationProperty } from \"./enums/AnimationProperty\";\nimport { Motion } from \"./Motion\";\n\n/**\n * Stores keyframe based animations.\n */\nexport class AnimationClip extends Motion {\n  /** @internal */\n  _curveBindings: AnimationClipCurveBinding[] = [];\n\n  private _length: number = 0;\n  private _events: AnimationEvent[] = [];\n\n  /**\n   * Animation events for this animation clip.\n   */\n  get events(): Readonly<AnimationEvent[]> {\n    return this._events;\n  }\n\n  /**\n   * Animation curve bindings for this animation clip.\n   */\n  get curveBindings(): Readonly<AnimationClipCurveBinding[]> {\n    return this._curveBindings;\n  }\n\n  /**\n   * Animation length in seconds.\n   */\n  get length(): number {\n    return this._length;\n  }\n\n  /**\n   * @param name - The AnimationClip's name\n   */\n  constructor (public readonly name: string) {\n    super();\n  }\n\n  /**\n   * Adds an animation event to the clip.\n   * @param event - The animation event\n   */\n  addEvent(event: AnimationEvent): void {\n    this._events.push(event);\n    this._events.sort((a, b) => a.time - b.time);\n  }\n\n  /**\n   * Clears all events from the clip.\n   */\n  clearEvents(): void {\n    this._events.length = 0;\n  }\n\n  /**\n   * Add curve binding for the clip.\n   * @param relativePath - Path to the game object this curve applies to. The relativePath is formatted similar to a pathname, e.g. \"/root/spine/leftArm\"\n   * @param type- The class type of the component that is animated\n   * @param propertyName - The name to the property being animated\n   * @param curve - The animation curve\n   */\n  addCurveBinding<T extends Component>(\n    relativePath: string,\n    type: new (entity: Entity) => T,\n    propertyName: string,\n    curve: AnimationCurve\n  ): void {\n    let property: AnimationProperty;\n    switch (propertyName) {\n      case \"position\":\n        property = AnimationProperty.Position;\n        break;\n      case \"rotation\":\n        property = AnimationProperty.Rotation;\n        break;\n      case \"scale\":\n        property = AnimationProperty.Scale;\n        break;\n      case \"blendShapeWeights\":\n        property = AnimationProperty.BlendShapeWeights;\n        break;\n      default:\n    }\n    const curveBinding = new AnimationClipCurveBinding();\n    curveBinding.relativePath = relativePath;\n    curveBinding.type = type;\n    curveBinding.property = property;\n    curveBinding.curve = curve;\n    if (curve.length > this._length) {\n      this._length = curve.length;\n    }\n    this._curveBindings.push(curveBinding);\n  }\n\n  /**\n   * Clears all curve bindings from the clip.\n   */\n  clearCurveBindings(): void {\n    this._curveBindings.length = 0;\n    this._length = 0;\n  }\n\n  /**\n   * @internal\n   * Samples an animation at a given time.\n   * @param entity - The animated entity\n   * @param time - The time to sample an animation\n   */\n  _sampleAnimation(entity: Entity, time: number): void {\n    const { length } = this._curveBindings;\n    for (let i = length - 1; i >= 0; i--) {\n      const curveData = this._curveBindings[i];\n      const { curve, property, relativePath, type } = curveData;\n      const val = curve.evaluate(time);\n      const target = entity.findByName(relativePath);\n      const transform = (<Entity>target).transform;\n      if (type === Transform) {\n        switch (property) {\n          case AnimationProperty.Position:\n            transform.position = val as Vector3;\n            break;\n          case AnimationProperty.Rotation:\n            transform.rotationQuaternion = val as Quaternion;\n            break;\n          case AnimationProperty.Scale:\n            transform.scale = val as Vector3;\n            break;\n        }\n      }\n    }\n  }\n}\n", "import { Vector3, Quaternion } from \"@oasis-engine/math\";\n\n/**\n * @internal\n */\nexport class AnimatorUtils {\n  private static _tempVector30: Vector3 = new Vector3();\n  private static _tempVector31: Vector3 = new Vector3();\n\n  static scaleWeight(s: Vector3, w: number, out: Vector3): void {\n    const sX = s.x;\n    const sY = s.y;\n    const sZ = s.z;\n    out.x = sX > 0 ? Math.pow(Math.abs(sX), w) : -Math.pow(Math.abs(sX), w);\n    out.y = sY > 0 ? Math.pow(Math.abs(sY), w) : -Math.pow(Math.abs(sY), w);\n    out.z = sZ > 0 ? Math.pow(Math.abs(sZ), w) : -Math.pow(Math.abs(sZ), w);\n  }\n\n  static scaleBlend(sa: Vector3, sb: Vector3, w: number, out: Vector3): void {\n    const saw = AnimatorUtils._tempVector30;\n    const sbw = AnimatorUtils._tempVector31;\n    AnimatorUtils.scaleWeight(sa, 1.0 - w, saw);\n    AnimatorUtils.scaleWeight(sb, w, sbw);\n    const sng = w > 0.5 ? sb : sa;\n    out.x = sng.x > 0 ? Math.abs(saw.x * sbw.x) : -Math.abs(saw.x * sbw.x);\n    out.y = sng.y > 0 ? Math.abs(saw.y * sbw.y) : -Math.abs(saw.y * sbw.y);\n    out.z = sng.z > 0 ? Math.abs(saw.z * sbw.z) : -Math.abs(saw.z * sbw.z);\n  }\n\n  static quaternionWeight(s: Quaternion, w: number, out: Quaternion) {\n    out.x = s.x * w;\n    out.y = s.y * w;\n    out.z = s.z * w;\n    out.w = s.w;\n  }\n}\n", "export enum AnimatorLayerBlendingMode {\n  Override,\n  Additive\n}\n", "/**\n * Layer state.\n */\nexport enum LayerState {\n  /** Standby state. */\n  Standby,//CM: Standby \u4F18\u5316\n  /** Playing state. */\n  Playing,\n  /** CrossFading state. */\n  CrossFading,\n  /** FixedCrossFading state. */\n  FixedCrossFading\n}\n", "import { Quaternion, Vector3 } from \"@oasis-engine/math\";\nimport { Component } from \"../../Component\";\nimport { Entity } from \"../../Entity\";\nimport { SkinnedMeshRenderer } from \"../../mesh/SkinnedMeshRenderer\";\nimport { AnimationProperty } from \"../enums/AnimationProperty\";\nimport { InterpolableValue } from \"../KeyFrame\";\n\n/**\n * @internal\n */\nexport class AnimationCurveOwner {\n  crossCurveMark: number = 0;\n  crossCurveIndex: number;\n\n  readonly target: Entity;\n  readonly type: new (entity: Entity) => Component;\n  readonly property: AnimationProperty;\n  readonly component: Component;\n  readonly defaultValue: InterpolableValue;\n  readonly fixedPoseValue: InterpolableValue;\n\n  constructor(target: Entity, type: new (entity: Entity) => Component, property: AnimationProperty) {\n    this.target = target;\n    this.type = type;\n    this.property = property;\n    switch (property) {\n      case AnimationProperty.Position:\n        this.defaultValue = new Vector3();\n        this.fixedPoseValue = new Vector3();\n        this.component = target.transform;\n        break;\n      case AnimationProperty.Rotation:\n        this.defaultValue = new Quaternion();\n        this.fixedPoseValue = new Quaternion();\n        this.component = target.transform;\n        break;\n      case AnimationProperty.Scale:\n        this.defaultValue = new Vector3();\n        this.fixedPoseValue = new Vector3();\n        this.component = target.transform;\n        break;\n      case AnimationProperty.BlendShapeWeights:\n        this.defaultValue = new Float32Array(4);\n        this.fixedPoseValue = new Float32Array(4);\n        this.component = target.getComponent(SkinnedMeshRenderer);\n        break;\n    }\n  }\n\n  saveDefaultValue(): void {\n    switch (this.property) {\n      case AnimationProperty.Position:\n        this.target.transform.position.cloneTo(<Vector3>this.defaultValue);\n        break;\n      case AnimationProperty.Rotation:\n        this.target.transform.rotationQuaternion.cloneTo(<Quaternion>this.defaultValue);\n        break;\n      case AnimationProperty.Scale:\n        this.target.transform.scale.cloneTo(<Vector3>this.defaultValue);\n        break;\n    }\n  }\n\n  saveFixedPoseValue(): void {\n    switch (this.property) {\n      case AnimationProperty.Position:\n        this.target.transform.position.cloneTo(<Vector3>this.fixedPoseValue);\n        break;\n      case AnimationProperty.Rotation:\n        this.target.transform.rotationQuaternion.cloneTo(<Quaternion>this.fixedPoseValue);\n        break;\n      case AnimationProperty.Scale:\n        this.target.transform.scale.cloneTo(<Vector3>this.fixedPoseValue);\n        break;\n    }\n  }\n}\n", "import { AnimationEvent } from \"../AnimationEvent\";\n/**\n * @internal\n */\nexport class AnimationEventHandler {\n  event: AnimationEvent;\n  handlers: Function[] = [];\n}\n", "import { AnimatorState } from \"./AnimatorState\";\n\n/**\n * Transitions define when and how the state machine switch from on state to another. AnimatorTransition always originate from a StateMachine or a StateMachine entry.\n */\nexport class AnimatorStateTransition {\n  /** The duration of the transition. This is represented in normalized time. */\n  duration: number = 0;\n  /** The time at which the destination state will start. This is represented in normalized time. */\n  offset: number = 0;\n  /** ExitTime represents the exact time at which the transition can take effect. This is represented in normalized time. */\n  exitTime: number = 1;\n  /** The destination state of the transition. */\n  destinationState: AnimatorState;\n}\n", "/**\n * Animation wrap mode.\n */\nexport enum WrapMode {\n  /** Play once */\n  Once = 0,\n  /** Loop play */\n  Loop = 1\n}\n", "import { AnimatorState } from \"../AnimatorState\";\nimport { WrapMode } from \"../enums/WrapMode\";\nimport { AnimatorStateData } from \"./AnimatorStateData\";\n\n/**\n * @internal\n */\nexport class AnimatorStatePlayData {\n  state: AnimatorState;\n  stateData: AnimatorStateData;\n  frameTime: number;\n  finished: boolean;\n  clipTime: number;\n  currentEventIndex: number;\n\n  reset(state: AnimatorState, stateData: AnimatorStateData, offsetFrameTime: number): void {\n    this.state = state;\n    this.frameTime = offsetFrameTime;\n    this.stateData = stateData;\n    this.finished = false;\n    this.clipTime = this.state.clipStartTime;\n    this.currentEventIndex = 0;\n  }\n\n  update(): void {\n    const state = this.state;\n    let time = this.frameTime;\n    const duration = state.clipEndTime - state.clipStartTime;\n    if (time > duration) {\n      if (state.wrapMode === WrapMode.Loop) {\n        time = time % duration;\n      } else {\n        time = duration;\n        this.finished = true;\n      }\n    }\n    this.clipTime = time + this.state.clipStartTime;\n  }\n}\n", "import { AnimatorStateTransition } from \"../AnimatorTransition\";\nimport { LayerState } from \"../enums/LayerState\";\nimport { AnimatorStateData } from \"./AnimatorStateData\";\nimport { AnimatorStatePlayData } from \"./AnimatorStatePlayData\";\n\n/**\n * @internal\n */\nexport class AnimatorLayerData {\n  animatorStateDataMap: Record<string, AnimatorStateData> = {};\n  srcPlayData: AnimatorStatePlayData = new AnimatorStatePlayData();\n  destPlayData: AnimatorStatePlayData = new AnimatorStatePlayData();\n  layerState: LayerState = LayerState.Standby;\n  crossCurveMark: number = 0;\n  manuallyTransition: AnimatorStateTransition = new AnimatorStateTransition();\n  crossFadeTransition: AnimatorStateTransition;\n\n  switchPlayData(): void {\n    const srcPlayData = this.destPlayData;\n    const switchTemp = this.srcPlayData;\n    this.srcPlayData = srcPlayData;\n    this.destPlayData = switchTemp;\n  }\n}\n", "import { AnimationEventHandler } from \"./AnimationEventHandler\";\nimport { AnimationCurveOwner } from \"./AnimationCurveOwner\";\n\n/**\n * @internal\n */\nexport class AnimatorStateData {\n  curveOwners: AnimationCurveOwner[] = [];\n  eventHandlers: AnimationEventHandler[] = [];\n}\n", "import { AnimatorState } from \"../AnimatorState\";\n\n/**\n * @internal\n */\nexport class AnimatorStateInfo {\n  layerIndex: number;\n  state: AnimatorState;\n}\n", "import { AnimationCurveOwner } from \"./AnimationCurveOwner\";\n/**\n * @internal\n */\nexport class CrossCurveData {\n  curveOwner: AnimationCurveOwner;\n  srcCurveIndex: number;\n  destCurveIndex: number;\n}\n", "import { Quaternion, Vector3 } from \"@oasis-engine/math\";\nimport { assignmentClone, ignoreClone } from \"../clone/CloneManager\";\nimport { Component } from \"../Component\";\nimport { Entity } from \"../Entity\";\nimport { SkinnedMeshRenderer } from \"../mesh\";\nimport { ClassPool } from \"../RenderPipeline/ClassPool\";\nimport { Transform } from \"../Transform\";\nimport { UpdateFlag } from \"../UpdateFlag\";\nimport { AnimationCurve } from \"./AnimationCurve\";\nimport { AnimatorController } from \"./AnimatorController\";\nimport { AnimatorState } from \"./AnimatorState\";\nimport { AnimatorStateTransition } from \"./AnimatorTransition\";\nimport { AnimatorUtils } from \"./AnimatorUtils\";\nimport { AnimationProperty } from \"./enums/AnimationProperty\";\nimport { AnimatorLayerBlendingMode } from \"./enums/AnimatorLayerBlendingMode\";\nimport { LayerState } from \"./enums/LayerState\";\nimport { AnimationCurveOwner } from \"./internal/AnimationCurveOwner\";\nimport { AnimationEventHandler } from \"./internal/AnimationEventHandler\";\nimport { AnimatorLayerData } from \"./internal/AnimatorLayerData\";\nimport { AnimatorStateData } from \"./internal/AnimatorStateData\";\nimport { AnimatorStateInfo } from \"./internal/AnimatorStateInfo\";\nimport { AnimatorStatePlayData } from \"./internal/AnimatorStatePlayData\";\nimport { CrossCurveData } from \"./internal/CrossCurveData\";\nimport { InterpolableValue, UnionInterpolableKeyframe } from \"./KeyFrame\";\n\n/**\n * The controller of the animation system.\n */\nexport class Animator extends Component {\n  private static _tempVector3: Vector3 = new Vector3();\n  private static _tempQuaternion: Quaternion = new Quaternion();\n  private static _animatorInfo: AnimatorStateInfo = new AnimatorStateInfo();\n\n  protected _animatorController: AnimatorController;\n  @assignmentClone\n  protected _speed: number = 1.0;\n  @ignoreClone\n  protected _controllerUpdateFlag: UpdateFlag;\n\n  @ignoreClone\n  private _animatorLayersData: AnimatorLayerData[] = [];\n  @ignoreClone\n  private _crossCurveDataCollection: CrossCurveData[] = [];\n  @ignoreClone\n  private _animationCurveOwners: AnimationCurveOwner[][] = [];\n  @ignoreClone\n  private _crossCurveDataPool: ClassPool<CrossCurveData> = new ClassPool(CrossCurveData);\n  @ignoreClone\n  private _animationEventHandlerPool: ClassPool<AnimationEventHandler> = new ClassPool(AnimationEventHandler);\n\n  /**\n   * The playback speed of the Animator, 1.0 is normal playback speed.\n   */\n  get speed(): number {\n    return this._speed;\n  }\n\n  set speed(value: number) {\n    this._speed = value;\n  }\n\n  /**\n   * All layers from the AnimatorController which belongs this Animator.\n   */\n  get animatorController(): AnimatorController {\n    return this._animatorController;\n  }\n\n  set animatorController(animatorController: AnimatorController) {\n    if (animatorController !== this._animatorController) {\n      this._controllerUpdateFlag && this._controllerUpdateFlag.destroy();\n      this._controllerUpdateFlag = animatorController && animatorController._registerChangeFlag();\n      this._animatorController = animatorController;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  constructor(entity: Entity) {\n    super(entity);\n  }\n\n  /**\n   * Play a state by name.\n   * @param stateName - The state name\n   * @param layerIndex - The layer index(default -1). If layer is -1, play the first state with the given state name\n   * @param normalizedTimeOffset - The time offset between 0 and 1(default 0)\n   */\n  play(stateName: string, layerIndex: number = -1, normalizedTimeOffset: number = 0): void {\n    if (this._controllerUpdateFlag?.flag) {\n      this._clearPlayData();\n    }\n\n    const animatorInfo = this._getAnimatorStateInfo(stateName, layerIndex, Animator._animatorInfo);\n    const { state } = animatorInfo;\n\n    if (!state) {\n      return;\n    }\n    if (!state.clip) {\n      console.warn(`The state named ${stateName} has no AnimationClip data.`);\n      return;\n    }\n    const animatorLayerData = this._getAnimatorLayerData(animatorInfo.layerIndex);\n    const { srcPlayData } = animatorLayerData;\n    const { state: curState } = srcPlayData;\n    if (curState && curState !== state) {\n      this._revertDefaultValue(srcPlayData);\n    }\n\n    //CM: Not consider same stateName, but different animation\n    const animatorStateData = this._getAnimatorStateData(stateName, state, animatorLayerData);\n\n    animatorLayerData.layerState = LayerState.Playing;\n    srcPlayData.reset(state, animatorStateData, state._getDuration() * normalizedTimeOffset);\n\n    this._saveDefaultValues(animatorStateData);\n  }\n\n  /**\n   * Create a cross fade from the current state to another state.\n   * @param stateName - The state name\n   * @param normalizedTransitionDuration - The duration of the transition (normalized)\n   * @param layerIndex - The layer index(default -1). If layer is -1, play the first state with the given state name\n   * @param normalizedTimeOffset - The time offset between 0 and 1(default 0)\n   */\n  crossFade(\n    stateName: string,\n    normalizedTransitionDuration: number,\n    layerIndex: number = -1,\n    normalizedTimeOffset: number = 0\n  ): void {\n    if (this._controllerUpdateFlag?.flag) {\n      this._clearPlayData();\n    }\n\n    const { state } = this._getAnimatorStateInfo(stateName, layerIndex, Animator._animatorInfo);\n    const { manuallyTransition } = this._getAnimatorLayerData(layerIndex);\n    manuallyTransition.duration = normalizedTransitionDuration;\n    manuallyTransition.offset = normalizedTimeOffset;\n    manuallyTransition.destinationState = state;\n    this._crossFadeByTransition(manuallyTransition, layerIndex);\n  }\n\n  /**\n   * Evaluates the animator component based on deltaTime.\n   * @param deltaTime - The deltaTime when the animation update\n   */\n  update(deltaTime: number): void {\n    if (this.speed === 0) {\n      return;\n    }\n\n    const { _animatorController: animatorController } = this;\n    if (!animatorController) {\n      return;\n    }\n    if (this._controllerUpdateFlag?.flag) {\n      return;\n    }\n    deltaTime *= this.speed;\n    for (let i = 0, n = animatorController.layers.length; i < n; i++) {\n      const animatorLayerData = this._getAnimatorLayerData(i);\n      if (animatorLayerData.layerState === LayerState.Standby) {\n        continue;\n      }\n\n      this._updateLayer(i, i === 0, deltaTime / 1000);\n    }\n  }\n\n  /**\n   * @override\n   * @internal\n   */\n  _onEnable(): void {\n    this.engine._componentsManager.addOnUpdateAnimations(this);\n  }\n\n  /**\n   * @override\n   * @internal\n   */\n  _onDisable(): void {\n    this.engine._componentsManager.removeOnUpdateAnimations(this);\n  }\n\n  private _getAnimatorStateInfo(stateName: string, layerIndex: number, out: AnimatorStateInfo): AnimatorStateInfo {\n    let state: AnimatorState = null;\n    const { _animatorController: animatorController } = this;\n    if (animatorController) {\n      const layers = animatorController.layers;\n      if (layerIndex === -1) {\n        for (let i = 0, n = layers.length; i < n; i++) {\n          state = layers[i].stateMachine.findStateByName(stateName);\n          if (state) {\n            layerIndex = i;\n            break;\n          }\n        }\n      } else {\n        state = layers[layerIndex].stateMachine.findStateByName(stateName);\n      }\n    }\n    out.layerIndex = layerIndex;\n    out.state = state;\n    return out;\n  }\n\n  private _saveDefaultValues(stateData: AnimatorStateData): void {\n    const { curveOwners } = stateData;\n    for (let i = curveOwners.length - 1; i >= 0; i--) {\n      curveOwners[i].saveDefaultValue();\n    }\n  }\n\n  private _getAnimatorStateData(\n    stateName: string,\n    animatorState: AnimatorState,\n    animatorLayerData: AnimatorLayerData\n  ): AnimatorStateData {\n    const { animatorStateDataMap: animatorStateDataCollection } = animatorLayerData;\n    let animatorStateData = animatorStateDataCollection[stateName];\n    if (!animatorStateData) {\n      animatorStateData = new AnimatorStateData();\n      animatorStateDataCollection[stateName] = animatorStateData;\n      this._saveAnimatorStateData(animatorState, animatorStateData);\n      this._saveAnimatorEventHandlers(animatorState, animatorStateData);\n    }\n    return animatorStateData;\n  }\n\n  private _saveAnimatorStateData(animatorState: AnimatorState, animatorStateData: AnimatorStateData): void {\n    const { entity, _animationCurveOwners: animationCureOwners } = this;\n    const { curveOwners } = animatorStateData;\n    const { _curveBindings: curves } = animatorState.clip;\n    for (let i = curves.length - 1; i >= 0; i--) {\n      const curve = curves[i];\n      const targetEntity = curve.relativePath === \"\" ? entity : entity.findByPath(curve.relativePath);\n      const { property } = curve;\n      const { instanceId } = targetEntity;\n      const propertyOwners = animationCureOwners[instanceId] || (animationCureOwners[instanceId] = []);\n      curveOwners[i] =\n        propertyOwners[property] ||\n        (propertyOwners[property] = new AnimationCurveOwner(targetEntity, curve.type, property));\n    }\n  }\n\n  private _saveAnimatorEventHandlers(state: AnimatorState, animatorStateData: AnimatorStateData): void {\n    const eventHandlerPool = this._animationEventHandlerPool;\n    const scripts = this._entity._scripts;\n    const scriptCount = scripts.length;\n    const { eventHandlers } = animatorStateData;\n    const { events } = state.clip;\n\n    eventHandlerPool.resetPool();\n    eventHandlers.length = 0;\n    for (let i = 0, n = events.length; i < n; i++) {\n      const event = events[i];\n      const eventHandler = eventHandlerPool.getFromPool();\n      const funcName = event.functionName;\n      const { handlers } = eventHandler;\n\n      eventHandler.event = event;\n      handlers.length = 0;\n      for (let j = scriptCount - 1; j >= 0; j--) {\n        const handler = <Function>scripts.get(j)[funcName];\n        handler && handlers.push(handler);\n      }\n      eventHandlers.push(eventHandler);\n    }\n  }\n\n  private _clearCrossData(animatorLayerData: AnimatorLayerData): void {\n    animatorLayerData.crossCurveMark++;\n    this._crossCurveDataCollection.length = 0;\n    this._crossCurveDataPool.resetPool();\n  }\n\n  private _addCrossCurveData(\n    crossCurveData: CrossCurveData[],\n    owner: AnimationCurveOwner,\n    curCurveIndex: number,\n    nextCurveIndex: number\n  ): void {\n    const dataItem = this._crossCurveDataPool.getFromPool();\n    dataItem.curveOwner = owner;\n    dataItem.srcCurveIndex = curCurveIndex;\n    dataItem.destCurveIndex = nextCurveIndex;\n    crossCurveData.push(dataItem);\n  }\n\n  private _prepareCrossFading(animatorLayerData: AnimatorLayerData): void {\n    const crossCurveData = this._crossCurveDataCollection;\n    const { crossCurveMark } = animatorLayerData;\n\n    // Add src cross curve data.\n    this._prepareSrcCrossData(crossCurveData, animatorLayerData.srcPlayData, crossCurveMark, false);\n    // Add dest cross curve data.\n    this._prepareDestCrossData(crossCurveData, animatorLayerData.destPlayData, crossCurveMark, false);\n  }\n\n  private _prepareStandbyCrossFading(animatorLayerData: AnimatorLayerData): void {\n    const crossCurveData = this._crossCurveDataCollection;\n    const { srcPlayData, crossCurveMark } = animatorLayerData;\n\n    // Standby have two sub state, one is never play, one is finished, never play srcPlayData is null.\n    srcPlayData && this._prepareSrcCrossData(crossCurveData, srcPlayData, crossCurveMark, true);\n    // Add dest cross curve data.\n    this._prepareDestCrossData(crossCurveData, animatorLayerData.destPlayData, crossCurveMark, true);\n  }\n\n  private _prepareFixedPoseCrossFading(animatorLayerData: AnimatorLayerData): void {\n    const crossCurveData = this._crossCurveDataCollection;\n\n    // Save current cross curve data owner fixed pose.\n    for (let i = crossCurveData.length - 1; i >= 0; i--) {\n      const item = crossCurveData[i];\n      item.curveOwner.saveFixedPoseValue();\n      // Reset destCurveIndex When fixed pose crossFading again.\n      item.destCurveIndex = -1;\n    }\n    // prepare dest AnimatorState cross data.\n    this._prepareDestCrossData(crossCurveData, animatorLayerData.destPlayData, animatorLayerData.crossCurveMark, true);\n  }\n\n  private _prepareSrcCrossData(\n    crossCurveData: CrossCurveData[],\n    srcPlayData: AnimatorStatePlayData,\n    crossCurveMark: number,\n    saveFixed: boolean\n  ): void {\n    const { curveOwners } = srcPlayData.stateData;\n    for (let i = curveOwners.length - 1; i >= 0; i--) {\n      const owner = curveOwners[i];\n      owner.crossCurveMark = crossCurveMark;\n      owner.crossCurveIndex = crossCurveData.length;\n      saveFixed && owner.saveFixedPoseValue();\n      this._addCrossCurveData(crossCurveData, owner, i, -1);\n    }\n  }\n\n  private _prepareDestCrossData(\n    crossCurveData: CrossCurveData[],\n    destPlayData: AnimatorStatePlayData,\n    crossCurveMark: number,\n    saveFixed: boolean\n  ): void {\n    const { curveOwners } = destPlayData.stateData;\n    for (let i = curveOwners.length - 1; i >= 0; i--) {\n      const owner = curveOwners[i];\n      // Not include in previous AnimatorState.\n      if (owner.crossCurveMark === crossCurveMark) {\n        crossCurveData[owner.crossCurveIndex].destCurveIndex = i;\n      } else {\n        saveFixed && owner.saveFixedPoseValue();\n        owner.crossCurveMark = crossCurveMark;\n        owner.crossCurveIndex = crossCurveData.length;\n        this._addCrossCurveData(crossCurveData, owner, -1, i);\n      }\n    }\n  }\n\n  private _evaluateCurve(\n    property: AnimationProperty,\n    curve: AnimationCurve,\n    time: number,\n    additive: boolean\n  ): InterpolableValue {\n    const value = curve.evaluate(time);\n\n    if (additive) {\n      const baseValue = (<UnionInterpolableKeyframe>curve.keys[0]).value;\n      switch (property) {\n        case AnimationProperty.Position:\n          const pos = Animator._tempVector3;\n          Vector3.subtract(<Vector3>value, <Vector3>baseValue, pos);\n          return pos;\n        case AnimationProperty.Rotation:\n          const rot = Animator._tempQuaternion;\n          Quaternion.conjugate(<Quaternion>baseValue, rot);\n          Quaternion.multiply(rot, <Quaternion>value, <Quaternion>rot);\n          return rot;\n        case AnimationProperty.Scale:\n          const scale = Animator._tempVector3;\n          Vector3.divide(<Vector3>value, <Vector3>baseValue, <Vector3>scale);\n          return scale;\n      }\n    }\n    return value;\n  }\n\n  private _getAnimatorLayerData(layerIndex: number): AnimatorLayerData {\n    let animatorLayerData = this._animatorLayersData[layerIndex];\n    animatorLayerData || (this._animatorLayersData[layerIndex] = animatorLayerData = new AnimatorLayerData());\n    return animatorLayerData;\n  }\n\n  private _updateLayer(layerIndex: number, firstLayer: boolean, deltaTime: number): void {\n    const { blendingMode, weight } = this._animatorController.layers[layerIndex];\n    const animLayerData = this._animatorLayersData[layerIndex];\n    const { srcPlayData, destPlayData, crossFadeTransition: crossFadeTransitionInfo } = animLayerData;\n    const layerAdditive = blendingMode === AnimatorLayerBlendingMode.Additive;\n    const layerWeight = firstLayer ? 1.0 : weight;\n    this._checkTransition(srcPlayData, crossFadeTransitionInfo, layerIndex);\n    switch (animLayerData.layerState) {\n      case LayerState.Playing:\n        this._updatePlayingState(srcPlayData, animLayerData, layerWeight, deltaTime, layerAdditive);\n        break;\n      case LayerState.FixedCrossFading:\n        this._updateCrossFadeFromPose(destPlayData, animLayerData, layerWeight, deltaTime, layerAdditive);\n        break;\n      case LayerState.CrossFading:\n        this._updateCrossFade(srcPlayData, destPlayData, animLayerData, layerWeight, deltaTime, layerAdditive);\n        break;\n    }\n  }\n\n  private _updatePlayingState(\n    playData: AnimatorStatePlayData,\n    layerData: AnimatorLayerData,\n    weight: number,\n    delta: number,\n    additive: boolean\n  ): void {\n    const { curveOwners, eventHandlers } = playData.stateData;\n    const { state } = playData;\n    const { _curveBindings: curves } = state.clip;\n    const lastClipTime = playData.clipTime;\n\n    playData.update();\n\n    const clipTime = playData.clipTime;\n\n    eventHandlers.length && this._fireAnimationEvents(playData, eventHandlers, lastClipTime, clipTime);\n\n    for (let i = curves.length - 1; i >= 0; i--) {\n      const owner = curveOwners[i];\n      const value = this._evaluateCurve(owner.property, curves[i].curve, clipTime, additive);\n      if (additive) {\n        this._applyClipValueAdditive(owner, value, weight);\n      } else {\n        this._applyClipValue(owner, value, weight);\n      }\n    }\n    playData.frameTime += state.speed * delta;\n\n    if (playData.finished) {\n      layerData.layerState = LayerState.Standby;\n    }\n  }\n\n  private _updateCrossFade(\n    srcPlayData: AnimatorStatePlayData,\n    destPlayData: AnimatorStatePlayData,\n    layerData: AnimatorLayerData,\n    weight: number,\n    delta: number,\n    additive: boolean\n  ) {\n    const crossCurveDataCollection = this._crossCurveDataCollection;\n    const srcCurves = srcPlayData.state.clip._curveBindings;\n    const { state: destState } = destPlayData;\n    const destCurves = destState.clip._curveBindings;\n\n    let crossWeight = destPlayData.frameTime / (destState._getDuration() * layerData.crossFadeTransition.duration);\n    crossWeight >= 1.0 && (crossWeight = 1.0);\n    srcPlayData.update();\n    destPlayData.update();\n\n    const srcClipTime = srcPlayData.clipTime;\n    const destClipTime = destPlayData.clipTime;\n    for (let i = crossCurveDataCollection.length - 1; i >= 0; i--) {\n      const { curveOwner, srcCurveIndex, destCurveIndex } = crossCurveDataCollection[i];\n      const { property, defaultValue } = curveOwner;\n\n      const srcValue =\n        srcCurveIndex >= 0\n          ? this._evaluateCurve(property, srcCurves[srcCurveIndex].curve, srcClipTime, additive)\n          : defaultValue;\n      const destValue =\n        destCurveIndex >= 0\n          ? this._evaluateCurve(property, destCurves[destCurveIndex].curve, destClipTime, additive)\n          : defaultValue;\n\n      this._applyCrossClipValue(curveOwner, srcValue, destValue, crossWeight, weight, additive);\n    }\n\n    this._updateCrossFadeData(layerData, crossWeight, delta, false);\n  }\n\n  private _updateCrossFadeFromPose(\n    destPlayData: AnimatorStatePlayData,\n    layerData: AnimatorLayerData,\n    weight: number,\n    delta: number,\n    additive: boolean\n  ) {\n    const crossCurveDataCollection = this._crossCurveDataCollection;\n    const { state: destState } = destPlayData;\n    const curves = destState.clip._curveBindings;\n\n    let crossWeight = destPlayData.frameTime / (destState._getDuration() * layerData.crossFadeTransition.duration);\n    crossWeight >= 1.0 && (crossWeight = 1.0);\n    destPlayData.update();\n\n    const destClipTime = destPlayData.clipTime;\n    for (let i = crossCurveDataCollection.length - 1; i >= 0; i--) {\n      const { curveOwner, destCurveIndex } = crossCurveDataCollection[i];\n      const destValue =\n        destCurveIndex >= 0\n          ? this._evaluateCurve(curveOwner.property, curves[destCurveIndex].curve, destClipTime, additive)\n          : curveOwner.defaultValue;\n\n      this._applyCrossClipValue(curveOwner, curveOwner.fixedPoseValue, destValue, crossWeight, weight, additive);\n    }\n\n    this._updateCrossFadeData(layerData, crossWeight, delta, true);\n  }\n\n  private _updateCrossFadeData(layerData: AnimatorLayerData, crossWeight: number, delta: number, fixed: boolean): void {\n    const { destPlayData } = layerData;\n    destPlayData.frameTime += destPlayData.state.speed * delta;\n    if (crossWeight === 1.0) {\n      if (destPlayData.finished) {\n        layerData.layerState = LayerState.Standby;\n      } else {\n        layerData.layerState = LayerState.Playing;\n      }\n      layerData.switchPlayData();\n    } else {\n      fixed || (layerData.srcPlayData.frameTime += layerData.srcPlayData.state.speed * delta);\n    }\n  }\n\n  private _applyCrossClipValue(\n    owner: AnimationCurveOwner,\n    srcValue: InterpolableValue,\n    destValue: InterpolableValue,\n    crossWeight: number,\n    layerWeight: number,\n    additive: boolean\n  ): void {\n    let value: InterpolableValue;\n    if (owner.type === Transform) {\n      const transform = owner.target.transform;\n      switch (owner.property) {\n        case AnimationProperty.Position:\n          Vector3.lerp(srcValue as Vector3, destValue as Vector3, crossWeight, Animator._tempVector3);\n          value = Animator._tempVector3;\n          break;\n        case AnimationProperty.Rotation:\n          Quaternion.slerp(srcValue as Quaternion, destValue as Quaternion, crossWeight, Animator._tempQuaternion);\n          value = Animator._tempQuaternion;\n          break;\n        case AnimationProperty.Scale: {\n          const scale = transform.scale;\n          Vector3.lerp(srcValue as Vector3, destValue as Vector3, crossWeight, Animator._tempVector3);\n          transform.scale = scale;\n          value = Animator._tempVector3;\n          break;\n        }\n      }\n    }\n\n    if (additive) {\n      this._applyClipValueAdditive(owner, value, layerWeight);\n    } else {\n      this._applyClipValue(owner, value, layerWeight);\n    }\n  }\n\n  private _applyClipValue(owner: AnimationCurveOwner, value: InterpolableValue, weight: number): void {\n    if (owner.type === Transform) {\n      const transform = owner.target.transform;\n      switch (owner.property) {\n        case AnimationProperty.Position:\n          if (weight === 1.0) {\n            transform.position = <Vector3>value;\n          } else {\n            const position = transform.position;\n            Vector3.lerp(position, <Vector3>value, weight, position);\n            transform.position = position;\n          }\n          break;\n        case AnimationProperty.Rotation:\n          if (weight === 1.0) {\n            transform.rotationQuaternion = <Quaternion>value;\n          } else {\n            const rotationQuaternion = transform.rotationQuaternion;\n            Quaternion.slerp(rotationQuaternion, <Quaternion>value, weight, rotationQuaternion);\n            transform.rotationQuaternion = rotationQuaternion;\n          }\n          break;\n        case AnimationProperty.Scale:\n          if (weight === 1.0) {\n            transform.scale = <Vector3>value;\n          } else {\n            const scale = transform.scale;\n            Vector3.lerp(scale, <Vector3>value, weight, scale);\n            transform.scale = scale;\n          }\n          break;\n      }\n    } else if (owner.type === SkinnedMeshRenderer) {\n      switch (owner.property) {\n        case AnimationProperty.BlendShapeWeights:\n          (<SkinnedMeshRenderer>owner.component).blendShapeWeights = <Float32Array>value;\n          break;\n      }\n    }\n  }\n\n  private _applyClipValueAdditive(owner: AnimationCurveOwner, additiveValue: InterpolableValue, weight: number): void {\n    if (owner.type === Transform) {\n      const transform = (<Entity>owner.target).transform;\n      switch (owner.property) {\n        case AnimationProperty.Position:\n          const position = transform.position;\n          position.x += (<Vector3>additiveValue).x * weight;\n          position.y += (<Vector3>additiveValue).y * weight;\n          position.z += (<Vector3>additiveValue).z * weight;\n          transform.position = position;\n          break;\n        case AnimationProperty.Rotation:\n          const rotationQuaternion = transform.rotationQuaternion;\n          AnimatorUtils.quaternionWeight(<Quaternion>additiveValue, weight, <Quaternion>additiveValue);\n          (<Quaternion>additiveValue).normalize();\n          rotationQuaternion.multiply(<Quaternion>additiveValue);\n          transform.rotationQuaternion = rotationQuaternion;\n          break;\n        case AnimationProperty.Scale:\n          const scale = transform.scale;\n          AnimatorUtils.scaleWeight(scale, weight, scale);\n          Vector3.multiply(scale, <Vector3>additiveValue, scale);\n          transform.scale = scale;\n          break;\n      }\n    }\n  }\n\n  private _revertDefaultValue(playData: AnimatorStatePlayData) {\n    const { clip } = playData.state;\n    if (clip) {\n      const curves = clip._curveBindings;\n      const { curveOwners } = playData.stateData;\n      for (let i = curves.length - 1; i >= 0; i--) {\n        const owner = curveOwners[i];\n        const { transform } = owner.target;\n        switch (owner.property) {\n          case AnimationProperty.Position:\n            transform.position = <Vector3>owner.defaultValue;\n            break;\n          case AnimationProperty.Rotation:\n            transform.rotationQuaternion = <Quaternion>owner.defaultValue;\n            break;\n          case AnimationProperty.Scale:\n            transform.scale = <Vector3>owner.defaultValue;\n            break;\n        }\n      }\n    }\n  }\n\n  private _checkTransition(\n    stateData: AnimatorStatePlayData,\n    crossFadeTransition: AnimatorStateTransition,\n    layerIndex: number\n  ) {\n    const { state, clipTime } = stateData;\n    const duration = state._getDuration();\n    const { transitions } = state;\n    for (let i = 0, n = transitions.length; i < n; ++i) {\n      const transition = transitions[i];\n      if (duration * transition.exitTime <= clipTime) {\n        crossFadeTransition !== transition && this._crossFadeByTransition(transition, layerIndex);\n      }\n    }\n  }\n\n  private _crossFadeByTransition(transition: AnimatorStateTransition, layerIndex: number) {\n    const { name } = transition.destinationState;\n    const animatorStateInfo = this._getAnimatorStateInfo(name, layerIndex, Animator._animatorInfo);\n    const { state: crossState } = animatorStateInfo;\n    if (!crossState) {\n      return;\n    }\n    if (!crossState.clip) {\n      console.warn(`The state named ${name} has no AnimationClip data.`);\n      return;\n    }\n\n    const animatorLayerData = this._getAnimatorLayerData(animatorStateInfo.layerIndex);\n    const layerState = animatorLayerData.layerState;\n    const { destPlayData } = animatorLayerData;\n\n    const animatorStateData = this._getAnimatorStateData(name, crossState, animatorLayerData);\n    const duration = crossState._getDuration();\n    const offset = duration * transition.offset;\n    destPlayData.reset(crossState, animatorStateData, offset);\n\n    this._saveDefaultValues(animatorStateData);\n\n    switch (layerState) {\n      // Maybe not play, maybe end.\n      case LayerState.Standby:\n        animatorLayerData.layerState = LayerState.FixedCrossFading;\n        this._clearCrossData(animatorLayerData);\n        this._prepareStandbyCrossFading(animatorLayerData);\n        break;\n      case LayerState.Playing:\n        animatorLayerData.layerState = LayerState.CrossFading;\n        this._clearCrossData(animatorLayerData);\n        this._prepareCrossFading(animatorLayerData);\n        break;\n      case LayerState.CrossFading:\n        animatorLayerData.layerState = LayerState.FixedCrossFading;\n        this._prepareFixedPoseCrossFading(animatorLayerData);\n        break;\n      case LayerState.FixedCrossFading:\n        this._prepareFixedPoseCrossFading(animatorLayerData);\n        break;\n    }\n\n    animatorLayerData.crossFadeTransition = transition;\n  }\n\n  private _fireAnimationEvents(\n    playState: AnimatorStatePlayData,\n    eventHandlers: AnimationEventHandler[],\n    lastClipTime: number,\n    clipTime: number\n  ): void {\n    // TODO: If play backward, not work.\n    if (clipTime < lastClipTime) {\n      this._fireSubAnimationEvents(playState, eventHandlers, lastClipTime, playState.state.clipEndTime);\n      playState.currentEventIndex = 0;\n      this._fireSubAnimationEvents(playState, eventHandlers, playState.state.clipStartTime, clipTime);\n    } else {\n      this._fireSubAnimationEvents(playState, eventHandlers, lastClipTime, clipTime);\n    }\n  }\n\n  private _fireSubAnimationEvents(\n    playState: AnimatorStatePlayData,\n    eventHandlers: AnimationEventHandler[],\n    lastClipTime: number,\n    curClipTime: number\n  ): void {\n    for (let i = playState.currentEventIndex, n = eventHandlers.length; i < n; i++) {\n      const eventHandler = eventHandlers[i];\n      const { time, parameter } = eventHandler.event;\n\n      if (time > curClipTime) {\n        break;\n      }\n\n      const { handlers } = eventHandler;\n      if (time >= lastClipTime) {\n        for (let j = handlers.length - 1; j >= 0; j--) {\n          handlers[j](parameter);\n        }\n        playState.currentEventIndex = i + 1;\n      }\n    }\n  }\n\n  private _clearPlayData() {\n    this._animatorLayersData.length = 0;\n    this._crossCurveDataCollection.length = 0;\n    this._animationCurveOwners.length = 0;\n    this._controllerUpdateFlag.flag = false;\n  }\n}\n", "import { UpdateFlag } from \"../UpdateFlag\";\nimport { UpdateFlagManager } from \"../UpdateFlagManager\";\nimport { AnimatorControllerLayer } from \"./AnimatorControllerLayer\";\n\n/**\n * Store the data for Animator playback.\n */\nexport class AnimatorController {\n  private _updateFlagManager: UpdateFlagManager = new UpdateFlagManager();\n  private _layers: AnimatorControllerLayer[] = [];\n  private _layersMap: Record<string, AnimatorControllerLayer> = {};\n\n  /**\n   * The layers in the controller.\n   */\n  get layers(): Readonly<AnimatorControllerLayer[]> {\n    return this._layers;\n  }\n\n  /**\n   * Get the layer by name.\n   * @param name - The layer's name.\n   */\n  findLayerByName(name: string): AnimatorControllerLayer {\n    return this._layersMap[name];\n  }\n\n  /**\n   * Add a layer to the controller.\n   * @param layer - The layer to add\n   */\n  addLayer(layer: AnimatorControllerLayer): void {\n    this._layers.push(layer);\n    this._layersMap[layer.name] = layer;\n    this._distributeUpdateFlag();\n  }\n\n  /**\n   * Remove a layer from the controller.\n   * @param layerIndex - The index of the AnimatorLayer\n   */\n  removeLayer(layerIndex: number): void {\n    const theLayer = this.layers[layerIndex];\n    this._layers.splice(layerIndex, 1);\n    delete this._layersMap[theLayer.name];\n    this._distributeUpdateFlag();\n  }\n\n  /**\n   * Clear layers.\n   */\n  clearLayers(): void {\n    this._layers.length = 0;\n    for (let name in this._layersMap) {\n      delete this._layersMap[name];\n    }\n    this._distributeUpdateFlag();\n  }\n\n  /**\n   * @internal\n   */\n  _registerChangeFlag(): UpdateFlag {\n    return this._updateFlagManager.register();\n  }\n\n  private _distributeUpdateFlag(): void {\n    this._updateFlagManager.distribute();\n  }\n}\n", "import { AnimatorStateMachine } from \"./AnimatorStateMachine\";\nimport { AnimatorLayerBlendingMode } from \"./enums/AnimatorLayerBlendingMode\";\n\n/**\n * The Animation Layer contains a state machine that controls animations of a model or part of it.\n */\nexport class AnimatorControllerLayer {\n  /** The blending weight that the layers has. It is not taken into account for the first layer. */\n  weight: number = 1.0;\n  /** The blending mode used by the layer. It is not taken into account for the first layer. */\n  blendingMode: AnimatorLayerBlendingMode = AnimatorLayerBlendingMode.Override;\n  /** The state machine for the layer. */\n  stateMachine: AnimatorStateMachine;\n\n  /**\n   * @param name - The layer's name\n   */\n  constructor(public readonly name: string) {}\n}\n", "import { AnimationClip } from \"./AnimationClip\";\nimport { AnimatorStateTransition } from \"./AnimatorTransition\";\nimport { WrapMode } from \"./enums/WrapMode\";\n\n/**\n * States are the basic building blocks of a state machine. Each state contains a AnimationClip which will play while the character is in that state.\n */\nexport class AnimatorState {\n  /** The speed of the clip. 1 is normal speed, default 1. */\n  speed: number = 1.0;\n  /** The wrap mode used in the state. */\n  wrapMode: WrapMode = WrapMode.Loop;\n\n  private _clipStartTime: number = 0;\n  private _clipEndTime: number = Infinity;\n  private _clip: AnimationClip;\n  private _transitions: AnimatorStateTransition[] = [];\n\n  /**\n   * The transitions that are going out of the state.\n   */\n  get transitions(): Readonly<AnimatorStateTransition[]> {\n    return this._transitions;\n  }\n\n  /**\n   * \u0192The clip that is being played by this animator state.\n   */\n  get clip(): AnimationClip {\n    return this._clip;\n  }\n\n  set clip(clip: AnimationClip) {\n    this._clip = clip;\n    this._clipEndTime = Math.min(this._clipEndTime, clip.length);\n  }\n\n  /**\n   * The clip start time the user set , default is 0.\n   */\n  get clipStartTime() {\n    return this._clipStartTime;\n  }\n\n  set clipStartTime(time: number) {\n    this._clipStartTime = time < 0 ? 0 : time;\n  }\n\n  /**\n   * The clip end time the user set , default is the clip duration.\n   */\n  get clipEndTime() {\n    return this._clipEndTime;\n  }\n\n  set clipEndTime(time: number) {\n    const clip = this._clip;\n    if (clip) {\n      this._clipEndTime = Math.min(time, clip.length);\n    }\n  }\n\n  /**\n   * @param name - The state's name\n   */\n  constructor(public readonly name: string) {}\n\n  /**\n   * Add an outgoing transition to the destination state.\n   * @param transition - The transition\n   */\n  addTransition(transition: AnimatorStateTransition): void {\n    this._transitions.push(transition);\n  }\n\n  /**\n   * Remove a transition from the state.\n   * @param transition - The transition\n   */\n  removeTransition(transition: AnimatorStateTransition): void {\n    const index = this._transitions.indexOf(transition);\n    index !== -1 && this._transitions.splice(index, 1);\n  }\n\n  /**\n   * Clears all transitions from the state.\n   */\n  clearTransitions(): void {\n    this._transitions.length = 0;\n  }\n\n  /**\n   * @internal\n   */\n  _getDuration(): number {\n    return this._clipEndTime - this._clipStartTime;\n  }\n}\n", "import { AnimatorState } from \"./AnimatorState\";\nexport interface AnimatorStateMap {\n  [key: string]: AnimatorState;\n}\n\n/**\n * A graph controlling the interaction of states. Each state references a motion.\n */\nexport class AnimatorStateMachine {\n  /** The list of states. */\n  readonly states: AnimatorState[] = [];\n\n  /** @internal */\n  _statesMap: AnimatorStateMap = {};\n\n  /**\n   * Add a state to the state machine.\n   * @param name - The name of the new state\n   */\n  addState(name: string): AnimatorState {\n    let state = this.findStateByName(name);\n    if (!state) {\n      state = new AnimatorState(name);\n      this.states.push(state);\n      this._statesMap[name] = state;\n    } else {\n      console.warn(`The state named ${name} has existed.`);\n    }\n    return state;\n  }\n\n  /**\n   * Remove a state from the state machine.\n   * @param state - The state\n   */\n  removeState(state: AnimatorState): void {\n    const { name } = state;\n    const index = this.states.indexOf(state);\n    if (index > -1) {\n      this.states.splice(index, 1);\n    }\n    delete this._statesMap[name];\n  }\n\n  /**\n   * Get the state by name.\n   * @param name - The layer's name\n   */\n  findStateByName(name: string): AnimatorState {\n    return this._statesMap[name];\n  }\n\n  /**\n   * Makes a unique state name in the state machine.\n   * @param name - Desired name for the state.\n   * @returns Unique name.\n   */\n  makeUniqueStateName(name: string): string {\n    const { _statesMap } = this;\n    const originName = name;\n    let index = 0;\n    while (_statesMap[name]) {\n      name = `${originName} ${index}`;\n      index++;\n    }\n    return name;\n  }\n}\n", "export enum InterpolableValueType {\n  Float,\n  FloatArray,\n  Vector2,\n  Vector3,\n  Vector4,\n  Quaternion\n}\n", "/**\n * Animation interpolation method.\n */\nexport enum InterpolationType {\n  /** Linear interpolation */\n  Linear,\n  /** Cubic spline interpolation */\n  CubicSpine,\n  /** Stepped interpolation */\n  Step,\n  /** Hermite interpolation */\n  Hermite\n}\n", "import { Quaternion, Vector2, Vector3, Vector4 } from \"@oasis-engine/math\";\nimport { InterpolableValueType } from \"./enums/InterpolableValueType\";\nimport { InterpolationType } from \"./enums/InterpolationType\";\nimport {\n  FloatArrayKeyframe,\n  FloatKeyframe,\n  InterpolableValue,\n  QuaternionKeyframe,\n  UnionInterpolableKeyframe,\n  Vector2Keyframe,\n  Vector3Keyframe\n} from \"./KeyFrame\";\n\n/**\n * Store a collection of Keyframes that can be evaluated over time.\n */\nexport class AnimationCurve {\n  /** All keys defined in the animation curve. */\n  keys: UnionInterpolableKeyframe[] = [];\n  /** The interpolationType of the animation curve. */\n  interpolation: InterpolationType;\n\n  /** @internal */\n  _valueSize: number;\n  /** @internal */\n  _valueType: InterpolableValueType;\n\n  private _currentValue: InterpolableValue;\n  private _length: number = 0;\n  private _currentIndex: number = 0;\n\n  /**\n   * Animation curve length in seconds.\n   */\n  get length(): number {\n    return this._length;\n  }\n\n  /**\n   * Add a new key to the curve.\n   * @param key - The keyframe\n   */\n  addKey(key: UnionInterpolableKeyframe): void {\n    const { time } = key;\n    this.keys.push(key);\n    if (time > this._length) {\n      this._length = time;\n    }\n\n    if (!this._valueSize) {\n      //CM: It's not reasonable to write here.\n      if (typeof key.value == \"number\") {\n        this._valueSize = 1;\n        this._valueType = InterpolableValueType.Float;\n        this._currentValue = 0;\n      }\n      if (key.value instanceof Vector2) {\n        this._valueSize = 2;\n        this._valueType = InterpolableValueType.Vector2;\n        this._currentValue = new Vector2();\n      }\n      if (key.value instanceof Vector3) {\n        this._valueSize = 3;\n        this._valueType = InterpolableValueType.Vector3;\n        this._currentValue = new Vector3();\n      }\n      if (key.value instanceof Vector4) {\n        this._valueSize = 4;\n        this._valueType = InterpolableValueType.Vector4;\n        this._currentValue = new Vector4();\n      }\n      if (key.value instanceof Quaternion) {\n        this._valueSize = 4;\n        this._valueType = InterpolableValueType.Quaternion;\n        this._currentValue = new Quaternion();\n      }\n\n      if (key.value instanceof Float32Array) {\n        const size = key.value.length;\n        this._valueSize = size;\n        this._valueType = InterpolableValueType.FloatArray;\n        this._currentValue = new Float32Array(size);\n      }\n    }\n    this.keys.sort((a, b) => a.time - b.time);\n  }\n\n  /**\n   * Evaluate the curve at time.\n   * @param time - The time within the curve you want to evaluate\n   */\n  evaluate(time: number): InterpolableValue {\n    const { keys, interpolation } = this;\n    const { length } = this.keys;\n\n    // Compute curIndex and nextIndex.\n    let curIndex = this._currentIndex;\n\n    // Reset loop.\n    if (curIndex !== -1 && time < keys[curIndex].time) {\n      curIndex = -1;\n    }\n\n    let nextIndex = curIndex + 1;\n    while (nextIndex < length) {\n      if (time < keys[nextIndex].time) {\n        break;\n      }\n      curIndex++;\n      nextIndex++;\n    }\n    this._currentIndex = curIndex;\n    // Evaluate value.\n    let value: InterpolableValue;\n    if (curIndex === -1) {\n      value = (<UnionInterpolableKeyframe>keys[0]).value;\n    } else if (nextIndex === length) {\n      value = (<UnionInterpolableKeyframe>keys[curIndex]).value;\n    } else {\n      // Time between first frame and end frame.\n      const curFrameTime = keys[curIndex].time;\n      const duration = keys[nextIndex].time - curFrameTime;\n      const t = (time - curFrameTime) / duration;\n      const dur = duration;\n\n      switch (interpolation) {\n        case InterpolationType.Linear:\n          value = this._evaluateLinear(curIndex, nextIndex, t);\n          break;\n        case InterpolationType.Step:\n          value = this._evaluateStep(nextIndex);\n          break;\n        case InterpolationType.CubicSpine:\n        case InterpolationType.Hermite:\n          value = this._evaluateHermite(curIndex, nextIndex, t, dur);\n      }\n    }\n    return value;\n  }\n\n  /**\n   * Removes the keyframe at index and inserts key.\n   * @param index - The index of the key to move\n   * @param key - The key to insert\n   */\n  moveKey(index: number, key: UnionInterpolableKeyframe): void {\n    this.keys[index] = key;\n  }\n\n  /**\n   * Removes a key.\n   * @param index - The index of the key to remove\n   */\n  removeKey(index: number): void {\n    this.keys.splice(index, 1);\n    const { keys } = this;\n    const count = this.keys.length;\n    let newLength = 0;\n    for (let i = count - 1; i >= 0; i--) {\n      if (keys[i].time > length) {\n        newLength = keys[i].time;\n      }\n    }\n    this._length = newLength;\n  }\n\n  private _evaluateLinear(frameIndex: number, nextFrameIndex: number, t: number): InterpolableValue {\n    const { _valueType, keys } = this;\n    switch (_valueType) {\n      case InterpolableValueType.Float:\n        return (<FloatKeyframe>keys[frameIndex]).value * (1 - t) + (<FloatKeyframe>keys[nextFrameIndex]).value * t;\n      case InterpolableValueType.FloatArray:\n        const curValue = this._currentValue;\n        const value = (<FloatArrayKeyframe>keys[frameIndex]).value;\n        const nextValue = (<FloatArrayKeyframe>keys[nextFrameIndex]).value;\n        for (let i = 0, n = value.length; i < n; i++) {\n          curValue[i] = value[i] * (1 - t) + nextValue[i] * t;\n        }\n        return curValue;\n      case InterpolableValueType.Vector2:\n        Vector2.lerp(\n          (<Vector2Keyframe>keys[frameIndex]).value,\n          (<Vector2Keyframe>keys[nextFrameIndex]).value,\n          t,\n          <Vector2>this._currentValue\n        );\n        return this._currentValue;\n      case InterpolableValueType.Vector3:\n        Vector3.lerp(\n          (<Vector3Keyframe>keys[frameIndex]).value,\n          (<Vector3Keyframe>keys[nextFrameIndex]).value,\n          t,\n          <Vector3>this._currentValue\n        );\n        return this._currentValue;\n      case InterpolableValueType.Quaternion:\n        Quaternion.slerp(\n          (<QuaternionKeyframe>keys[frameIndex]).value,\n          (<QuaternionKeyframe>keys[nextFrameIndex]).value,\n          t,\n          <Quaternion>this._currentValue\n        );\n        return this._currentValue;\n    }\n  }\n\n  private _evaluateStep(nextFrameIndex: number): InterpolableValue {\n    const { _valueSize, keys } = this;\n    if (_valueSize === 1) {\n      return (<UnionInterpolableKeyframe>keys[nextFrameIndex]).value;\n    } else {\n      return (<UnionInterpolableKeyframe>keys[nextFrameIndex]).value;\n    }\n  }\n\n  private _evaluateHermite(frameIndex: number, nextFrameIndex: number, t: number, dur: number): InterpolableValue {\n    const { _valueSize, keys } = this;\n    const curKey = keys[frameIndex];\n    const nextKey = keys[nextFrameIndex];\n    switch (_valueSize) {\n      case 1: {\n        const t0 = (<FloatKeyframe>curKey).outTangent,\n          t1 = (<FloatKeyframe>nextKey).inTangent,\n          p0 = (<FloatKeyframe>curKey).value,\n          p1 = (<FloatKeyframe>nextKey).value;\n        if (Number.isFinite(t0) && Number.isFinite(t1)) {\n          const t2 = t * t;\n          const t3 = t2 * t;\n          const a = 2.0 * t3 - 3.0 * t2 + 1.0;\n          const b = t3 - 2.0 * t2 + t;\n          const c = t3 - t2;\n          const d = -2.0 * t3 + 3.0 * t2;\n          return a * p0 + b * t0 * dur + c * t1 * dur + d * p1;\n        } else {\n          return (<FloatKeyframe>curKey).value;\n        }\n      }\n      case 2: {\n        const p0 = (<Vector2Keyframe>curKey).value;\n        const tan0 = (<Vector2Keyframe>curKey).outTangent;\n        const p1 = (<Vector2Keyframe>nextKey).value;\n        const tan1 = (<Vector2Keyframe>nextKey).inTangent;\n\n        const t2 = t * t;\n        const t3 = t2 * t;\n        const a = 2.0 * t3 - 3.0 * t2 + 1.0;\n        const b = t3 - 2.0 * t2 + t;\n        const c = t3 - t2;\n        const d = -2.0 * t3 + 3.0 * t2;\n\n        let t0 = tan0.x,\n          t1 = tan1.x;\n        if (Number.isFinite(t0) && Number.isFinite(t1)) {\n          (<Vector2>this._currentValue).x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;\n        } else {\n          (<Vector2>this._currentValue).x = p0.x;\n        }\n\n        (t0 = tan0.y), (t1 = tan1.y);\n        if (Number.isFinite(t0) && Number.isFinite(t1))\n          (<Vector2>this._currentValue).y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;\n        else {\n          (<Vector2>this._currentValue).y = p0.y;\n        }\n        return this._currentValue;\n      }\n      case 3: {\n        const p0 = (<Vector3Keyframe>curKey).value;\n        const tan0 = (<Vector3Keyframe>curKey).outTangent;\n        const p1 = (<Vector3Keyframe>nextKey).value;\n        const tan1 = (<Vector3Keyframe>nextKey).inTangent;\n\n        const t2 = t * t;\n        const t3 = t2 * t;\n        const a = 2.0 * t3 - 3.0 * t2 + 1.0;\n        const b = t3 - 2.0 * t2 + t;\n        const c = t3 - t2;\n        const d = -2.0 * t3 + 3.0 * t2;\n\n        let t0 = tan0.x,\n          t1 = tan1.x;\n        if (Number.isFinite(t0) && Number.isFinite(t1)) {\n          (<Vector3>this._currentValue).x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;\n        } else {\n          (<Vector3>this._currentValue).x = p0.x;\n        }\n\n        (t0 = tan0.y), (t1 = tan1.y);\n        if (Number.isFinite(t0) && Number.isFinite(t1)) {\n          (<Vector3>this._currentValue).y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;\n        } else {\n          (<Vector3>this._currentValue).y = p0.y;\n        }\n\n        (t0 = tan0.z), (t1 = tan1.z);\n        if (Number.isFinite(t0) && Number.isFinite(t1)) {\n          (<Vector3>this._currentValue).z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;\n        } else {\n          (<Vector3>this._currentValue).z = p0.z;\n        }\n        return <Vector3>this._currentValue;\n      }\n      case 4: {\n        const p0 = (<QuaternionKeyframe>curKey).value;\n        const tan0 = (<QuaternionKeyframe>curKey).outTangent;\n        const p1 = (<QuaternionKeyframe>nextKey).value;\n        const tan1 = (<QuaternionKeyframe>nextKey).inTangent;\n\n        const t2 = t * t;\n        const t3 = t2 * t;\n        const a = 2.0 * t3 - 3.0 * t2 + 1.0;\n        const b = t3 - 2.0 * t2 + t;\n        const c = t3 - t2;\n        const d = -2.0 * t3 + 3.0 * t2;\n\n        let t0 = tan0.x,\n          t1 = tan1.x;\n        if (Number.isFinite(t0) && Number.isFinite(t1)) {\n          (<Quaternion>this._currentValue).x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;\n        } else {\n          (<Quaternion>this._currentValue).x = p0.x;\n        }\n\n        (t0 = tan0.y), (t1 = tan1.y);\n        if (Number.isFinite(t0) && Number.isFinite(t1)) {\n          (<Quaternion>this._currentValue).y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;\n        } else {\n          (<Quaternion>this._currentValue).y = p0.y;\n        }\n\n        (t0 = tan0.z), (t1 = tan1.z);\n        if (Number.isFinite(t0) && Number.isFinite(t1)) {\n          (<Quaternion>this._currentValue).z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;\n        } else {\n          (<Quaternion>this._currentValue).z = p0.z;\n        }\n\n        (t0 = tan0.w), (t1 = tan1.w);\n        if (Number.isFinite(t0) && Number.isFinite(t1)) {\n          (<Quaternion>this._currentValue).w = a * p0.w + b * t0 * dur + c * t1 * dur + d * p1.w;\n        } else {\n          (<Quaternion>this._currentValue).w = p0.w;\n        }\n        return <Quaternion>this._currentValue;\n      }\n    }\n  }\n}\n", "import { Vector2, Vector3, Vector4, Quaternion } from \"@oasis-engine/math\";\n\n/**\n * Keyframe.\n * @typeParam V - Type of Keyframe value\n */\nexport class Keyframe<V> {\n  /** The time of the Keyframe. */\n  time: number;\n  /** The value of the Keyframe. */\n  value: V;\n}\n\n/**\n * InterpolableKeyframe.\n * @typeParam T - Type of Tangent value\n * @typeParam V - Type of Keyframe value\n */\nexport class InterpolableKeyframe<T, V> extends Keyframe<V> {\n  /** Sets the incoming tangent for this key. The incoming tangent affects the slope of the curve from the previous key to this key. */\n  inTangent?: T;\n  /** Sets the outgoing tangent for this key. The outgoing tangent affects the slope of the curve from this key to the next key. */\n  outTangent?: T;\n}\n\nexport type ObjectKeyframe = Keyframe<Object>;\nexport type FloatKeyframe = InterpolableKeyframe<number, number>;\nexport type FloatArrayKeyframe = InterpolableKeyframe<Float32Array, Float32Array>;\nexport type Vector2Keyframe = InterpolableKeyframe<Vector2, Vector2>;\nexport type Vector3Keyframe = InterpolableKeyframe<Vector3, Vector3>;\nexport type Vector4Keyframe = InterpolableKeyframe<Vector4, Vector4>;\nexport type QuaternionKeyframe = InterpolableKeyframe<Vector4, Quaternion>;\n\nexport type UnionInterpolableKeyframe =\n  | FloatKeyframe\n  | FloatArrayKeyframe\n  | Vector2Keyframe\n  | Vector3Keyframe\n  | Vector4Keyframe\n  | QuaternionKeyframe;\n\nexport type InterpolableValue = number | Vector2 | Vector3 | Vector4 | Quaternion | Float32Array | Object;\n", "/**\n * AnimationEvent lets you call a script function similar to SendMessage as part of playing back an animation.\n */\nexport class AnimationEvent {\n  /** The time when the event be triggered. */\n  time: number;\n  /** The name of the method called in the script. */\n  functionName: string;\n  /** The parameter that is stored in the event and will be sent to the function. */\n  parameter: Object;\n}\n", "export enum AnimatorConditionMode {\n  If,\n  IfNot,\n  Greater,\n  Less,\n  Equals,\n  NotEquals\n}\n", "import { Engine } from \"../Engine\";\nimport { Material } from \"../material/Material\";\nimport { CompareFunction } from \"../shader/enums/CompareFunction\";\nimport { CullMode } from \"../shader/enums/CullMode\";\nimport { Shader } from \"../shader/Shader\";\nimport { TextureCubeMap } from \"../texture\";\n\n/**\n * SkyboxMaterial\n */\nexport class SkyBoxMaterial extends Material {\n  constructor(engine: Engine) {\n    super(engine, Shader.find(\"skybox\"));\n\n    this.renderState.rasterState.cullMode = CullMode.Off;\n    this.renderState.depthState.compareFunction = CompareFunction.LessEqual;\n  }\n\n  /** Texture cube map of the sky box material. */\n  get textureCubeMap(): TextureCubeMap {\n    return this.shaderData.getTexture(\"u_cube\") as TextureCubeMap;\n  }\n\n  set textureCubeMap(v: TextureCubeMap) {\n    this.shaderData.setTexture(\"u_cube\", v);\n  }\n}\n", "import { MathUtil, Vector3, Color } from \"@oasis-engine/math\";\nimport { Buffer } from \"../graphic/Buffer\";\nimport { BufferBindFlag } from \"../graphic/enums/BufferBindFlag\";\nimport { BufferUsage } from \"../graphic/enums/BufferUsage\";\nimport { IndexFormat } from \"../graphic/enums/IndexFormat\";\nimport { VertexElementFormat } from \"../graphic/enums/VertexElementFormat\";\nimport { VertexElement } from \"../graphic/VertexElement\";\nimport { Material } from \"../material/Material\";\nimport { BlendFactor } from \"../shader/enums/BlendFactor\";\nimport { RenderQueueType } from \"../material/enums/RenderQueueType\";\nimport { Shader, CullMode } from \"../shader\";\nimport { Texture } from \"../texture\";\nimport { MeshRenderer } from \"../mesh/MeshRenderer\";\nimport { GLCapabilityType } from \"../base/Constant\";\nimport { BufferMesh } from \"../mesh/BufferMesh\";\n\nenum DirtyFlagType {\n  Position = 0x1,\n  Velocity = 0x2,\n  Acceleration = 0x4,\n  Color = 0x8,\n  Alpha = 0x10,\n  Size = 0x20,\n  StartAngle = 0x40,\n  StartTime = 0x80,\n  LifeTime = 0x100,\n  RotateVelocity = 0x200,\n  Scale = 0x400,\n  Everything = 0xffffffff\n}\n\n/**\n * Blend mode enums of the particle renderer's material.\n */\nexport enum ParticleRendererBlendMode {\n  Transparent = 0,\n  Additive = 1\n}\n\n/**\n * Particle Renderer Component.\n */\nexport class ParticleRenderer extends MeshRenderer {\n  /** The max number of indices that Uint16Array can support. */\n  private static _uint16VertexLimit: number = 65535;\n\n  private static _getRandom(): number {\n    return Math.random() - 0.5;\n  }\n\n  private _vertexStride: number;\n  private _vertices: Float32Array;\n  private _vertexBuffer: Buffer;\n  private _maxCount: number = 1000;\n  private _position: Vector3 = new Vector3();\n  private _positionRandomness: Vector3 = new Vector3();\n  private _positionArray: Vector3[];\n  private _velocity: Vector3 = new Vector3();\n  private _velocityRandomness: Vector3 = new Vector3();\n  private _acceleration: Vector3 = new Vector3();\n  private _accelerationRandomness: Vector3 = new Vector3();\n  private _color: Color = new Color(1, 1, 1, 1);\n  private _colorRandomness: number = 0;\n  private _size: number = 1;\n  private _sizeRandomness: number = 0;\n  private _alpha: number = 1;\n  private _alphaRandomness: number = 0;\n  private _startAngle: number = 0;\n  private _startAngleRandomness: number = 0;\n  private _rotateVelocity: number = 0;\n  private _rotateVelocityRandomness: number = 0;\n  private _lifetime: number = 5;\n  private _startTimeRandomness: number = 0;\n  private _scale: number = 1;\n  private _isOnce: boolean = false;\n  private _onceTime: number = 0;\n  private _time: number = 0;\n  private _isInit: boolean = false;\n  private _isStart: boolean = false;\n  private _updateDirtyFlag: number = DirtyFlagType.Everything;\n  private _isRotateToVelocity: boolean = false;\n  private _isUseOriginColor: boolean = false;\n  private _isScaleByLifetime: boolean = false;\n  private _is2d: boolean = true;\n  private _isFadeIn: boolean = false;\n  private _isFadeOut: boolean = false;\n  private _playOnEnable: boolean = true;\n  private _blendMode: ParticleRendererBlendMode = ParticleRendererBlendMode.Transparent;\n\n  /**\n   * Sprite sheet of texture.\n   */\n  public spriteSheet: { x: number; y: number; w: number; h: number }[];\n\n  /**\n   * Texture of particle.\n   */\n  get texture(): Texture {\n    return this.getMaterial().shaderData.getTexture(\"u_texture\");\n  }\n\n  set texture(texture: Texture) {\n    if (texture) {\n      this.shaderData.enableMacro(\"particleTexture\");\n      this.getMaterial().shaderData.setTexture(\"u_texture\", texture);\n    } else {\n      this.shaderData.disableMacro(\"particleTexture\");\n    }\n  }\n\n  /**\n   * Position of particles.\n   */\n  get position(): Vector3 {\n    return this._position;\n  }\n\n  set position(value: Vector3) {\n    this._updateDirtyFlag |= DirtyFlagType.Position;\n    this._position = value;\n  }\n\n  /**\n   * Random range of positions.\n   */\n  get positionRandomness(): Vector3 {\n    return this._positionRandomness;\n  }\n\n  set positionRandomness(value: Vector3) {\n    this._updateDirtyFlag |= DirtyFlagType.Position;\n    this._positionRandomness = value;\n  }\n\n  /**\n   * Array of fixed positions.\n   */\n  get positionArray(): Vector3[] {\n    return this._positionArray;\n  }\n\n  set positionArray(value: Vector3[]) {\n    this._updateDirtyFlag |= DirtyFlagType.Position;\n    this._positionArray = value;\n  }\n\n  /**\n   * Velocity of particles.\n   */\n  get velocity(): Vector3 {\n    return this._velocity;\n  }\n\n  set velocity(value: Vector3) {\n    this._updateDirtyFlag |= DirtyFlagType.Velocity;\n    this._velocity = value;\n  }\n\n  /**\n   * Random range of velocity.\n   */\n  get velocityRandomness(): Vector3 {\n    return this._velocityRandomness;\n  }\n\n  set velocityRandomness(value: Vector3) {\n    this._updateDirtyFlag |= DirtyFlagType.Velocity;\n    this._velocityRandomness = value;\n  }\n\n  /**\n   * Acceleration of particles.\n   */\n  get acceleration(): Vector3 {\n    return this._acceleration;\n  }\n\n  set acceleration(value: Vector3) {\n    this._updateDirtyFlag |= DirtyFlagType.Acceleration;\n    this._acceleration = value;\n  }\n\n  /**\n   * Random range of acceleration.\n   */\n  get accelerationRandomness(): Vector3 {\n    return this._accelerationRandomness;\n  }\n\n  set accelerationRandomness(value: Vector3) {\n    this._updateDirtyFlag |= DirtyFlagType.Acceleration;\n    this._accelerationRandomness = value;\n  }\n\n  /**\n   * Color of particles.\n   */\n  get color(): Color {\n    return this._color;\n  }\n\n  set color(value: Color) {\n    this._updateDirtyFlag |= DirtyFlagType.Color;\n    this._color = value;\n  }\n\n  /**\n   * Random range of color.\n   */\n  get colorRandomness(): number {\n    return this._colorRandomness;\n  }\n\n  set colorRandomness(value: number) {\n    this._updateDirtyFlag |= DirtyFlagType.Color;\n    this._colorRandomness = value;\n  }\n\n  /**\n   * Size of particles.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  set size(value: number) {\n    this._updateDirtyFlag |= DirtyFlagType.Size;\n    this._size = value;\n  }\n\n  /**\n   * Random range of size.\n   */\n  get sizeRandomness(): number {\n    return this._sizeRandomness;\n  }\n\n  set sizeRandomness(value: number) {\n    this._updateDirtyFlag |= DirtyFlagType.Size;\n    this._sizeRandomness = value;\n  }\n\n  /**\n   * Alpha of particles.\n   */\n  get alpha(): number {\n    return this._alpha;\n  }\n\n  set alpha(value: number) {\n    this._updateDirtyFlag |= DirtyFlagType.Alpha;\n    this._alpha = value;\n  }\n\n  /**\n   * Random range of alpha.\n   */\n  get alphaRandomness(): number {\n    return this._alphaRandomness;\n  }\n\n  set alphaRandomness(value: number) {\n    this._updateDirtyFlag |= DirtyFlagType.Alpha;\n    this._alphaRandomness = value;\n  }\n\n  /**\n   * Angle of particles.\n   */\n  get angle(): number {\n    return this._startAngle;\n  }\n\n  set angle(value: number) {\n    this._updateDirtyFlag |= DirtyFlagType.StartAngle;\n    this._startAngle = value;\n  }\n\n  /**\n   * Random range of angle.\n   */\n  get angleRandomness(): number {\n    return this._startAngleRandomness;\n  }\n\n  set angleRandomness(value: number) {\n    this._updateDirtyFlag |= DirtyFlagType.StartAngle;\n    this._startAngleRandomness = value;\n  }\n\n  /**\n   * Rotate velocity of particles.\n   */\n  get rotateVelocity(): number {\n    return this._rotateVelocity;\n  }\n\n  set rotateVelocity(value: number) {\n    this._updateDirtyFlag |= DirtyFlagType.RotateVelocity;\n    this._rotateVelocity = value;\n  }\n\n  /**\n   * Random range of rotate velocity.\n   */\n  get rotateVelocityRandomness(): number {\n    return this._rotateVelocityRandomness;\n  }\n\n  set rotateVelocityRandomness(value: number) {\n    this._updateDirtyFlag |= DirtyFlagType.RotateVelocity;\n    this._rotateVelocityRandomness = value;\n  }\n\n  /**\n   * Lifetime of particles.\n   */\n  get lifetime(): number {\n    return this._lifetime;\n  }\n\n  set lifetime(value: number) {\n    this._updateDirtyFlag |= DirtyFlagType.LifeTime;\n    this._lifetime = value;\n    this._onceTime = 0;\n  }\n\n  /**\n   * Random range of start time.\n   */\n  get startTimeRandomness(): number {\n    return this._startTimeRandomness;\n  }\n\n  set startTimeRandomness(value: number) {\n    this._updateDirtyFlag |= DirtyFlagType.StartTime;\n    this._startTimeRandomness = value;\n    this._onceTime = 0;\n  }\n\n  /**\n   * Scale factor of particles.\n   */\n  get scale(): number {\n    return this._scale;\n  }\n\n  set scale(value: number) {\n    this._updateDirtyFlag |= DirtyFlagType.Scale;\n    this._scale = value;\n  }\n\n  /**\n   * Max count of particles.\n   */\n  get maxCount(): number {\n    return this._maxCount;\n  }\n\n  set maxCount(value: number) {\n    this._isStart = false;\n    this._isInit = false;\n    this._maxCount = value;\n    this._updateDirtyFlag = DirtyFlagType.Everything;\n    this.mesh = this._createMesh();\n\n    this._updateBuffer();\n\n    this._isInit = true;\n    this.shaderData.setFloat(\"u_time\", 0);\n  }\n\n  /**\n   * Whether play once.\n   */\n  get isOnce(): boolean {\n    return this._isOnce;\n  }\n\n  set isOnce(value: boolean) {\n    this._time = 0;\n    this.shaderData.setInt(\"u_once\", value ? 1 : 0);\n    this._isOnce = value;\n  }\n\n  /**\n   * Whether follow the direction of velocity.\n   */\n  get isRotateToVelocity(): boolean {\n    return this._isRotateToVelocity;\n  }\n\n  set isRotateToVelocity(value: boolean) {\n    if (value) {\n      this.shaderData.enableMacro(\"rotateToVelocity\");\n    } else {\n      this.shaderData.disableMacro(\"rotateToVelocity\");\n    }\n\n    this._isRotateToVelocity = value;\n  }\n\n  /**\n   * Whether use origin color.\n   */\n  get isUseOriginColor(): boolean {\n    return this._isUseOriginColor;\n  }\n\n  set isUseOriginColor(value: boolean) {\n    if (value) {\n      this.shaderData.enableMacro(\"useOriginColor\");\n    } else {\n      this.shaderData.disableMacro(\"useOriginColor\");\n    }\n\n    this._isUseOriginColor = value;\n  }\n\n  /**\n   * Whether scale by lifetime.\n   */\n  get isScaleByLifetime(): boolean {\n    return this._isScaleByLifetime;\n  }\n\n  set isScaleByLifetime(value: boolean) {\n    if (value) {\n      this.shaderData.enableMacro(\"isScaleByLifetime\");\n    } else {\n      this.shaderData.disableMacro(\"isScaleByLifetime\");\n    }\n\n    this._isScaleByLifetime = value;\n  }\n\n  /**\n   * Whether 2D rendering.\n   */\n  get is2d(): boolean {\n    return this._is2d;\n  }\n\n  set is2d(value: boolean) {\n    if (value) {\n      this.shaderData.enableMacro(\"is2d\");\n    } else {\n      this.shaderData.disableMacro(\"is2d\");\n      this.getMaterial().renderState.rasterState.cullMode = CullMode.Off;\n    }\n\n    this._is2d = value;\n  }\n\n  /**\n   * Whether fade in.\n   */\n  get isFadeIn(): boolean {\n    return this._isFadeIn;\n  }\n\n  set isFadeIn(value: boolean) {\n    if (value) {\n      this.shaderData.enableMacro(\"fadeIn\");\n    } else {\n      this.shaderData.disableMacro(\"fadeIn\");\n    }\n\n    this._isFadeIn = value;\n  }\n\n  /**\n   * Whether fade out.\n   */\n  get isFadeOut(): boolean {\n    return this._isFadeOut;\n  }\n\n  set isFadeOut(value: boolean) {\n    if (value) {\n      this.shaderData.enableMacro(\"fadeOut\");\n    } else {\n      this.shaderData.disableMacro(\"fadeOut\");\n    }\n\n    this._isFadeOut = value;\n  }\n\n  /**\n   * Whether play on enable.\n   */\n  get playOnEnable(): boolean {\n    return this._playOnEnable;\n  }\n\n  set playOnEnable(value: boolean) {\n    this._playOnEnable = value;\n\n    if (value) {\n      this.start();\n    } else {\n      this.stop();\n    }\n  }\n\n  /**\n   * Blend mode of the particle renderer's material.\n   */\n  get blendMode(): ParticleRendererBlendMode {\n    return this._blendMode;\n  }\n\n  set blendMode(value: ParticleRendererBlendMode) {\n    const blendState = this.getMaterial().renderState.blendState;\n    const target = blendState.targetBlendState;\n\n    if (value === ParticleRendererBlendMode.Transparent) {\n      target.enabled = true;\n      target.sourceColorBlendFactor = BlendFactor.SourceAlpha;\n      target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;\n      target.sourceAlphaBlendFactor = BlendFactor.One;\n      target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;\n    } else if (value === ParticleRendererBlendMode.Additive) {\n      target.enabled = true;\n      target.sourceColorBlendFactor = BlendFactor.SourceAlpha;\n      target.destinationColorBlendFactor = BlendFactor.One;\n      target.sourceAlphaBlendFactor = BlendFactor.One;\n      target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;\n    }\n\n    this._blendMode = value;\n  }\n\n  constructor(props) {\n    super(props);\n\n    this.setMaterial(this._createMaterial());\n  }\n\n  /**\n   * @override\n   * @internal\n   */\n  update(deltaTime: number): void {\n    if (!this._isInit || !this._isStart) {\n      return;\n    }\n\n    // Stop after play once\n    if (this._isOnce && this._time > this._onceTime) {\n      return this.stop();\n    }\n\n    if (this._updateDirtyFlag) {\n      this._updateBuffer();\n      this._updateDirtyFlag = 0;\n    }\n\n    this._time += deltaTime / 1000;\n    this.shaderData.setFloat(\"u_time\", this._time);\n  }\n\n  /**\n   * @override\n   * @internal\n   */\n  _onEnable(): void {\n    super._onEnable();\n\n    if (this._playOnEnable) {\n      this.start();\n    }\n  }\n\n  /**\n   * Start emitting.\n   */\n  start(): void {\n    this._isStart = true;\n    this._time = 0;\n  }\n\n  /**\n   * Stop emitting.\n   */\n  stop(): void {\n    this._isStart = false;\n  }\n\n  private _createMaterial(): Material {\n    const material = new Material(this.engine, Shader.find(\"particle-shader\"));\n    const { renderState } = material;\n    const target = renderState.blendState.targetBlendState;\n\n    target.enabled = true;\n    target.sourceColorBlendFactor = BlendFactor.SourceAlpha;\n    target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;\n    target.sourceAlphaBlendFactor = BlendFactor.One;\n    target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;\n\n    renderState.depthState.writeEnabled = false;\n\n    material.renderQueueType = RenderQueueType.Transparent;\n\n    this.isUseOriginColor = true;\n    this.is2d = true;\n    this.isFadeOut = true;\n\n    return material;\n  }\n\n  private _createMesh(): BufferMesh {\n    const mesh = new BufferMesh(this._entity.engine, \"particleMesh\");\n    const vertexStride = 96;\n    const vertexCount = this._maxCount * 4;\n    const vertexFloatCount = vertexCount * vertexStride;\n    const vertices = new Float32Array(vertexFloatCount);\n    let indices: Uint16Array | Uint32Array = null;\n    let useUint32: boolean = false;\n    if (vertexCount > ParticleRenderer._uint16VertexLimit) {\n      if (this.engine._hardwareRenderer.canIUse(GLCapabilityType.elementIndexUint)) {\n        useUint32 = true;\n        indices = new Uint32Array(6 * this._maxCount);\n      } else {\n        throw Error(\"The vertex count is over limit.\");\n      }\n    } else {\n      indices = new Uint16Array(6 * this._maxCount);\n    }\n\n    for (let i = 0, idx = 0; i < this._maxCount; ++i) {\n      let startIndex = i * 4;\n      indices[idx++] = startIndex;\n      indices[idx++] = startIndex + 1;\n      indices[idx++] = startIndex + 2;\n      indices[idx++] = startIndex;\n      indices[idx++] = startIndex + 2;\n      indices[idx++] = startIndex + 3;\n    }\n\n    const vertexElements = [\n      new VertexElement(\"a_position\", 0, VertexElementFormat.Vector3, 0),\n      new VertexElement(\"a_velocity\", 12, VertexElementFormat.Vector3, 0),\n      new VertexElement(\"a_acceleration\", 24, VertexElementFormat.Vector3, 0),\n      new VertexElement(\"a_color\", 36, VertexElementFormat.Vector4, 0),\n      new VertexElement(\"a_lifeAndSize\", 52, VertexElementFormat.Vector4, 0),\n      new VertexElement(\"a_rotation\", 68, VertexElementFormat.Vector2, 0),\n      new VertexElement(\"a_uv\", 76, VertexElementFormat.Vector3, 0),\n      new VertexElement(\"a_normalizedUv\", 88, VertexElementFormat.Vector2, 0)\n    ];\n\n    const vertexBuffer = new Buffer(\n      this.engine,\n      BufferBindFlag.VertexBuffer,\n      vertexFloatCount * 4,\n      BufferUsage.Dynamic\n    );\n\n    const indexBuffer = new Buffer(this.engine, BufferBindFlag.IndexBuffer, indices, BufferUsage.Dynamic);\n\n    mesh.setVertexBufferBinding(vertexBuffer, vertexStride);\n    mesh.setIndexBufferBinding(indexBuffer, useUint32 ? IndexFormat.UInt32 : IndexFormat.UInt16);\n    mesh.setVertexElements(vertexElements);\n    mesh.addSubMesh(0, indices.length);\n\n    this._vertexBuffer = vertexBuffer;\n    this._vertexStride = vertexStride / 4;\n    this._vertices = vertices;\n    return mesh;\n  }\n\n  private _updateBuffer(): void {\n    for (let x = 0; x < this._maxCount; x++) {\n      this._updateSingleBuffer(x);\n    }\n\n    this._vertexBuffer.setData(this._vertices);\n  }\n\n  private _updateSingleBuffer(i: number): void {\n    const { _updateDirtyFlag, _vertices: vertices, _vertexStride: vertexStride } = this;\n    const { _getRandom: getRandom } = ParticleRenderer;\n    const offset = i * 4;\n\n    const k0 = offset * vertexStride;\n    const k1 = (offset + 1) * vertexStride;\n    const k2 = (offset + 2) * vertexStride;\n    const k3 = (offset + 3) * vertexStride;\n\n    if (_updateDirtyFlag & DirtyFlagType.Position) {\n      let { x, y, z } = this._position;\n      const { _positionArray, _positionRandomness } = this;\n\n      if (_positionArray) {\n        if (_positionArray.length !== this._maxCount) {\n          throw Error(\"The length of positionArray must be equal to maxCount.\");\n        }\n        const pos = _positionArray[i];\n\n        x += pos.x;\n        y += pos.y;\n        z += pos.z;\n      } else {\n        x += getRandom() * _positionRandomness.x;\n        y += getRandom() * _positionRandomness.y;\n        z += getRandom() * _positionRandomness.z;\n      }\n\n      vertices[k0] = vertices[k1] = vertices[k2] = vertices[k3] = x;\n      vertices[k0 + 1] = vertices[k1 + 1] = vertices[k2 + 1] = vertices[k3 + 1] = y;\n      vertices[k0 + 2] = vertices[k1 + 2] = vertices[k2 + 2] = vertices[k3 + 2] = z;\n    }\n\n    if (_updateDirtyFlag & DirtyFlagType.Velocity) {\n      const { _velocity, _velocityRandomness } = this;\n\n      vertices[k0 + 3] =\n        vertices[k1 + 3] =\n        vertices[k2 + 3] =\n        vertices[k3 + 3] =\n          _velocity.x + getRandom() * _velocityRandomness.x;\n      vertices[k0 + 4] =\n        vertices[k1 + 4] =\n        vertices[k2 + 4] =\n        vertices[k3 + 4] =\n          _velocity.y + getRandom() * _velocityRandomness.y;\n      vertices[k0 + 5] =\n        vertices[k1 + 5] =\n        vertices[k2 + 5] =\n        vertices[k3 + 5] =\n          _velocity.z + getRandom() * _velocityRandomness.z;\n    }\n\n    if (_updateDirtyFlag & DirtyFlagType.Acceleration) {\n      const { _acceleration, _accelerationRandomness } = this;\n\n      vertices[k0 + 6] =\n        vertices[k1 + 6] =\n        vertices[k2 + 6] =\n        vertices[k3 + 6] =\n          _acceleration.x + getRandom() * _accelerationRandomness.x;\n      vertices[k0 + 7] =\n        vertices[k1 + 7] =\n        vertices[k2 + 7] =\n        vertices[k3 + 7] =\n          _acceleration.y + getRandom() * _accelerationRandomness.y;\n      vertices[k0 + 8] =\n        vertices[k1 + 8] =\n        vertices[k2 + 8] =\n        vertices[k3 + 8] =\n          _acceleration.z + getRandom() * _accelerationRandomness.z;\n    }\n\n    if (_updateDirtyFlag & DirtyFlagType.Color) {\n      const { _color, _colorRandomness } = this;\n\n      vertices[k0 + 9] =\n        vertices[k1 + 9] =\n        vertices[k2 + 9] =\n        vertices[k3 + 9] =\n          MathUtil.clamp(_color.r + getRandom() * _colorRandomness, 0, 1);\n\n      vertices[k0 + 10] =\n        vertices[k1 + 10] =\n        vertices[k2 + 10] =\n        vertices[k3 + 10] =\n          MathUtil.clamp(_color.g + getRandom() * _colorRandomness, 0, 1);\n      vertices[k0 + 11] =\n        vertices[k1 + 11] =\n        vertices[k2 + 11] =\n        vertices[k3 + 11] =\n          MathUtil.clamp(_color.b + getRandom() * _colorRandomness, 0, 1);\n    }\n\n    if (_updateDirtyFlag & DirtyFlagType.Alpha) {\n      vertices[k0 + 12] =\n        vertices[k1 + 12] =\n        vertices[k2 + 12] =\n        vertices[k3 + 12] =\n          MathUtil.clamp(this._alpha + getRandom() * this._alphaRandomness, 0, 1);\n    }\n\n    if (_updateDirtyFlag & DirtyFlagType.StartTime) {\n      vertices[k0 + 13] =\n        vertices[k1 + 13] =\n        vertices[k2 + 13] =\n        vertices[k3 + 13] =\n          Math.random() * this._startTimeRandomness;\n    }\n\n    if (_updateDirtyFlag & DirtyFlagType.LifeTime) {\n      const { _lifetime } = this;\n\n      vertices[k0 + 14] =\n        vertices[k1 + 14] =\n        vertices[k2 + 14] =\n        vertices[k3 + 14] =\n          _lifetime + getRandom() * _lifetime;\n    }\n\n    // Update the duration of play once when startTime or lifetime changes.\n    if (_updateDirtyFlag & DirtyFlagType.StartTime || _updateDirtyFlag & DirtyFlagType.LifeTime) {\n      this._onceTime = Math.max(this._onceTime, vertices[k0 + 13] + vertices[k0 + 14]);\n    }\n\n    if (_updateDirtyFlag & DirtyFlagType.Size) {\n      const { _size } = this;\n\n      vertices[k0 + 15] =\n        vertices[k1 + 15] =\n        vertices[k2 + 15] =\n        vertices[k3 + 15] =\n          Math.max(_size + getRandom() * this._sizeRandomness * _size * 2, 0);\n    }\n\n    if (_updateDirtyFlag & DirtyFlagType.Scale) {\n      vertices[k0 + 16] = vertices[k1 + 16] = vertices[k2 + 16] = vertices[k3 + 16] = this._scale;\n    }\n\n    if (_updateDirtyFlag & DirtyFlagType.StartAngle) {\n      vertices[k0 + 17] =\n        vertices[k1 + 17] =\n        vertices[k2 + 17] =\n        vertices[k3 + 17] =\n          this._startAngle + getRandom() * Math.PI * this._startAngleRandomness * 2;\n    }\n\n    if (_updateDirtyFlag & DirtyFlagType.RotateVelocity) {\n      vertices[k0 + 18] =\n        vertices[k1 + 18] =\n        vertices[k2 + 18] =\n        vertices[k3 + 18] =\n          this._rotateVelocity + getRandom() * this._rotateVelocityRandomness;\n    }\n\n    this._updateSingleUv(i, k0, k1, k2, k3);\n  }\n\n  private _updateSingleUv(i: number, k0: number, k1: number, k2: number, k3: number): void {\n    const { spriteSheet } = this;\n    const texture = this.getMaterial().shaderData.getTexture(\"u_texture\");\n    const vertices = this._vertices;\n\n    if (texture) {\n      const width = texture.width;\n      const height = texture.height;\n\n      if (spriteSheet) {\n        const { x, y, w, h } = spriteSheet[i % spriteSheet.length];\n\n        const u = x / width;\n        const v = y / height;\n        const p = u + w / width;\n        const q = v + h / height;\n        const ratio = h / w;\n\n        // left bottom\n        vertices[k0 + 19] = u;\n        vertices[k0 + 20] = q;\n        vertices[k0 + 21] = ratio;\n\n        // right bottom\n        vertices[k1 + 19] = p;\n        vertices[k1 + 20] = q;\n        vertices[k1 + 21] = ratio;\n\n        // right top\n        vertices[k2 + 19] = p;\n        vertices[k2 + 20] = v;\n        vertices[k2 + 21] = ratio;\n\n        // left top\n        vertices[k3 + 19] = u;\n        vertices[k3 + 20] = v;\n        vertices[k3 + 21] = ratio;\n      } else {\n        const ratio = height / width;\n\n        // left bottom\n        vertices[k0 + 19] = 0;\n        vertices[k0 + 20] = 1;\n        vertices[k0 + 21] = ratio;\n\n        // right bottom\n        vertices[k1 + 19] = 1;\n        vertices[k1 + 20] = 1;\n        vertices[k1 + 21] = ratio;\n\n        // right top\n        vertices[k2 + 19] = 1;\n        vertices[k2 + 20] = 0;\n        vertices[k2 + 21] = ratio;\n\n        // left top\n        vertices[k3 + 19] = 0;\n        vertices[k3 + 20] = 0;\n        vertices[k3 + 21] = ratio;\n      }\n    } else {\n      // left bottom\n      vertices[k0 + 19] = 0;\n      vertices[k0 + 20] = 0;\n      vertices[k0 + 21] = 1;\n\n      // right bottom\n      vertices[k1 + 19] = 1;\n      vertices[k1 + 20] = 0;\n      vertices[k1 + 21] = 1;\n\n      // right top\n      vertices[k2 + 19] = 1;\n      vertices[k2 + 20] = 1;\n      vertices[k2 + 21] = 1;\n\n      // left top\n      vertices[k3 + 19] = 0;\n      vertices[k3 + 20] = 1;\n      vertices[k3 + 21] = 1;\n    }\n\n    vertices[k0 + 22] = -0.5;\n    vertices[k0 + 23] = -0.5;\n    vertices[k1 + 22] = 0.5;\n    vertices[k1 + 23] = -0.5;\n    vertices[k2 + 22] = 0.5;\n    vertices[k2 + 23] = 0.5;\n    vertices[k3 + 22] = -0.5;\n    vertices[k3 + 23] = 0.5;\n  }\n}\n", "import { Engine } from \"../Engine\";\nimport { Material } from \"../material/Material\";\nimport { BlendFactor, Shader } from \"../shader\";\nimport FRAG_SHADER from \"./trail.fs.glsl\";\nimport VERT_SHADER from \"./trail.vs.glsl\";\n\nShader.create(\"trail\", VERT_SHADER, FRAG_SHADER);\n\nexport class TrailMaterial extends Material {\n  constructor(engine: Engine) {\n    super(engine, Shader.find(\"trail\"));\n\n    const target = this.renderState.blendState.targetBlendState;\n    target.enabled = true;\n    target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.SourceAlpha;\n    target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.One;\n\n    this.renderState.depthState.writeEnabled = false;\n  }\n}\n", "import { Matrix, Quaternion, Vector3 } from \"@oasis-engine/math\";\nimport { Camera } from \"../Camera\";\nimport { Entity } from \"../Entity\";\nimport { Buffer } from \"../graphic/Buffer\";\nimport { BufferUsage } from \"../graphic/enums/BufferUsage\";\nimport { MeshTopology } from \"../graphic/enums/MeshTopology\";\nimport { VertexElementFormat } from \"../graphic/enums/VertexElementFormat\";\nimport { VertexElement } from \"../graphic/VertexElement\";\nimport { BufferMesh } from \"../mesh/BufferMesh\";\nimport { MeshRenderer } from \"../mesh/MeshRenderer\";\nimport { Texture2D } from \"../texture\";\nimport { TrailMaterial } from \"./TrailMaterial\";\n\nconst _tempVector3 = new Vector3();\n\n/**\n * @deprecated\n */\nexport class TrailRenderer extends MeshRenderer {\n  private _vertexStride: number;\n  private _vertices: Float32Array;\n  private _vertexBuffer: Buffer;\n  private _stroke;\n  private _minSeg;\n  private _lifetime;\n  private _maxPointNum;\n  private _points: Array<Vector3>;\n  private _pointStates: Array<number>;\n  private _strapPoints: Array<Vector3>;\n  private _curPointNum;\n  private _prePointsNum;\n  /**\n   * @deprecated\n   */\n  constructor(entity: Entity, props: any) {\n    super(entity);\n\n    this._stroke = props.stroke || 0.2;\n    this._minSeg = props.minSeg || 0.02;\n    this._lifetime = props.lifetime || 1000;\n    this._maxPointNum = (this._lifetime / 1000.0) * entity.engine.targetFrameRate;\n\n    this._points = [];\n    this._pointStates = [];\n    this._strapPoints = [];\n    for (let i = 0; i < this._maxPointNum; i++) {\n      this._points.push(new Vector3());\n      this._pointStates.push(this._lifetime);\n\n      this._strapPoints.push(new Vector3());\n      this._strapPoints.push(new Vector3());\n    }\n    this._curPointNum = 0;\n\n    const mtl = props.material || new TrailMaterial(this.engine);\n    this.setMaterial(mtl);\n\n    this.setTexture(props.texture);\n    this._initGeometry();\n  }\n\n  /**\n   * @internal\n   */\n  update(deltaTime: number) {\n    let mov = 0,\n      newIdx = 0;\n    for (let i = 0; i < this._curPointNum; i++) {\n      this._pointStates[i] -= deltaTime;\n      if (this._pointStates[i] < 0) {\n        mov++;\n      } else if (mov > 0) {\n        newIdx = i - mov;\n\n        // Move data\n        this._pointStates[newIdx] = this._pointStates[i];\n\n        // Move point\n        this._points[i].cloneTo(this._points[newIdx]);\n      }\n    }\n    this._curPointNum -= mov;\n\n    let appendNewPoint = true;\n    if (this._curPointNum === this._maxPointNum) {\n      appendNewPoint = false;\n    } else if (this._curPointNum > 0) {\n      const lastPoint = this._points[this._points.length - 1];\n      if (Vector3.distance(this.entity.worldPosition, lastPoint) < this._minSeg) {\n        appendNewPoint = false;\n      } else {\n        // debugger\n      }\n    }\n\n    if (appendNewPoint) {\n      this._pointStates[this._curPointNum] = this._lifetime;\n      this.entity.worldPosition.cloneTo(this._points[this._curPointNum]);\n\n      this._curPointNum++;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _render(camera: Camera): void {\n    this._updateStrapVertices(camera, this._points);\n    this._updateStrapCoords();\n    this._vertexBuffer.setData(this._vertices);\n\n    super._render(camera);\n  }\n\n  /**\n   * @deprecated\n   * Set trail texture.\n   * @param texture\n   */\n  setTexture(texture: Texture2D) {\n    if (texture) {\n      this.getMaterial().shaderData.setTexture(\"u_texture\", texture);\n    }\n  }\n\n  private _initGeometry() {\n    const mesh = new BufferMesh(this._entity.engine);\n\n    const vertexStride = 20;\n    const vertexCount = this._maxPointNum * 2;\n    const vertexFloatCount = vertexCount * vertexStride;\n    const vertices = new Float32Array(vertexFloatCount);\n    const vertexElements = [\n      new VertexElement(\"POSITION\", 0, VertexElementFormat.Vector3, 0),\n      new VertexElement(\"TEXCOORD_0\", 12, VertexElementFormat.Vector2, 0)\n    ];\n    const vertexBuffer = new Buffer(this.engine, vertexFloatCount * 4, BufferUsage.Dynamic);\n\n    mesh.setVertexBufferBinding(vertexBuffer, vertexStride);\n    mesh.setVertexElements(vertexElements);\n    mesh.addSubMesh(0, vertexCount, MeshTopology.TriangleStrip);\n\n    this._vertexBuffer = vertexBuffer;\n    this._vertexStride = vertexStride;\n    this._vertices = vertices;\n    this.mesh = mesh;\n  }\n\n  private _updateStrapVertices(camera, points: Array<Vector3>) {\n    const m: Matrix = camera.viewMatrix;\n    const e = m.elements;\n    const vx = new Vector3(e[0], e[4], e[8]);\n    const vy = new Vector3(e[1], e[5], e[9]);\n    const vz = new Vector3(e[2], e[6], e[10]);\n    const s = this._stroke;\n\n    vy.scale(s);\n\n    const up = new Vector3();\n    const down = new Vector3();\n\n    const rotation = new Quaternion();\n\n    Vector3.transformByQuat(vx, rotation, vx);\n    Vector3.transformByQuat(vy, rotation, vy);\n\n    const dy = new Vector3();\n    const cross = new Vector3();\n    const perpVector = new Vector3();\n\n    vx.normalize();\n\n    const vertices = this._vertices;\n    //-- quad pos\n    for (let i = 0; i < this._maxPointNum; i++) {\n      //-- center pos\n      if (i < this._curPointNum) {\n        const p = points[i];\n\n        if (i === this._curPointNum - 1 && i !== 0) {\n          Vector3.subtract(p, points[i - 1], perpVector);\n        } else {\n          Vector3.subtract(points[i + 1], p, perpVector);\n        }\n\n        this._projectOnPlane(perpVector, vz, perpVector);\n        perpVector.normalize();\n\n        // Calculate angle between vectors\n        let angle = Math.acos(Vector3.dot(vx, perpVector));\n        Vector3.cross(vx, perpVector, cross);\n        if (Vector3.dot(cross, vz) <= 0) {\n          angle = Math.PI * 2 - angle;\n        }\n        Quaternion.rotationAxisAngle(vz, angle, rotation);\n        Vector3.transformByQuat(vy, rotation, dy);\n\n        Vector3.add(p, dy, up);\n        Vector3.subtract(p, dy, down);\n      }\n\n      const p0 = (i * 2 * this._vertexStride) / 4;\n      const p1 = ((i * 2 + 1) * this._vertexStride) / 4;\n      vertices[p0] = up.x;\n      vertices[p0 + 1] = up.y;\n      vertices[p0 + 2] = up.z;\n\n      vertices[p1] = down.x;\n      vertices[p1 + 1] = down.y;\n      vertices[p1 + 2] = down.z;\n    }\n  }\n\n  private _updateStrapCoords() {\n    if (this._prePointsNum === this._curPointNum) {\n      return;\n    }\n\n    this._prePointsNum = this._curPointNum;\n\n    const count = this._curPointNum;\n    const texDelta = 1.0 / count;\n    const vertices = this._vertices;\n    for (let i = 0; i < count; i++) {\n      const d = 1.0 - i * texDelta;\n      const p0 = (i * 2 * this._vertexStride) / 4;\n      const p1 = ((i * 2 + 1) * this._vertexStride) / 4;\n\n      vertices[p0] = 0;\n      vertices[p0 + 1] = d;\n\n      vertices[p1] = 1.0;\n      vertices[p1 + 1] = d;\n    }\n  }\n\n  private _projectOnVector(a: Vector3, p: Vector3, out: Vector3): void {\n    const n_p = p.clone();\n    Vector3.normalize(n_p, n_p);\n    const cosine = Vector3.dot(a, n_p);\n    out.x = n_p.x * cosine;\n    out.y = n_p.y * cosine;\n    out.z = n_p.z * cosine;\n  }\n\n  private _projectOnPlane(a: Vector3, n: Vector3, out: Vector3) {\n    this._projectOnVector(a, n, _tempVector3);\n    Vector3.subtract(a, _tempVector3, out);\n  }\n}\n", "import { Vector3 } from \"@oasis-engine/math\";\n\n/**\n * AABBox = {\n *  min: [-1,-1,-1],\n *  max: [1,1,1]\n * };\n *\n * Sphere = {\n *  center: [0,0,0],\n *  radius: 1\n * };\n */\n\n/**\n * Check whether the boxes intersect.\n * @param boxA - The first box to check\n * @param boxB - The second box to check\n * @returns True if the boxes intersect, false otherwise\n */\nexport function intersectBox2Box(boxA, boxB) {\n  return (\n    boxA.min.x <= boxB.max.x &&\n    boxA.max.x >= boxB.min.x &&\n    boxA.min.y <= boxB.max.y &&\n    boxA.max.y >= boxB.min.y &&\n    boxA.min.z <= boxB.max.z &&\n    boxA.max.z >= boxB.min.z\n  );\n}\n\n/**\n * Check whether the spheres intersect.\n * @param sphereA - The first sphere to check\n * @param sphereB - The second sphere to check\n * @returns True if the spheres intersect, false otherwise\n */\nexport function intersectSphere2Sphere(sphereA, sphereB) {\n  const distance = Vector3.distance(sphereA.center, sphereB.center);\n  return distance < sphereA.radius + sphereA.radius;\n}\n\n/**\n * Check whether the sphere and the box intersect.\n * @param sphere - The sphere to check\n * @param box - The box to check\n * @returns True if the sphere and the box intersect, false otherwise\n */\nexport function intersectSphere2Box(sphere, box) {\n  const center: Vector3 = sphere.center;\n\n  const closestPoint: Vector3 = new Vector3(\n    Math.max(box.min.x, Math.min(center.x, box.max.x)),\n    Math.max(box.min.y, Math.min(center.y, box.max.y)),\n    Math.max(box.min.z, Math.min(center.z, box.max.z))\n  );\n\n  const distance = Vector3.distance(center, closestPoint);\n  return distance < sphere.radius;\n}\n", "import { BoundingBox, Vector3 } from \"@oasis-engine/math\";\nimport { ACollider, ABoxCollider, ASphereCollider, ColliderFeature } from \"../collider\";\nimport { Script } from \"../Script\";\nimport { intersectBox2Box, intersectSphere2Box, intersectSphere2Sphere } from \"./intersect\";\n\n/**\n * Detect collisions between the Collider on the current entity and other Colliders in the scene.\n */\nexport class CollisionDetection extends Script {\n  private static _tempBox1: BoundingBox = new BoundingBox();\n  private static _tempBox2: BoundingBox = new BoundingBox();\n\n  private _colliderManager;\n  private _myCollider;\n  private _overlappedCollider;\n  private _sphere;\n  private _box: BoundingBox = new BoundingBox();\n\n  /**\n   * Constructor of the collision detection.\n   * @param entity - Entity to which the collision detection belong\n   */\n  constructor(entity) {\n    super(entity);\n  }\n\n  /**\n   * The collider that intersects with the collider on the current Entity.\n   */\n  get overlappedCollider() {\n    return this._overlappedCollider;\n  }\n\n  /**\n   * When every frame is updated, calculate the collision with other collider.\n   */\n  onUpdate(deltaTime) {\n    super.onUpdate(deltaTime);\n\n    let overlappedCollider = null;\n\n    if (this._colliderManager && this._myCollider) {\n      const colliders = this._colliderManager.colliders;\n\n      if (this._myCollider instanceof ABoxCollider) {\n        this._updateWorldBox(this._myCollider, this._box);\n        for (let i = 0, len = colliders.length; i < len; i++) {\n          const collider = colliders[i];\n          if (collider != this._myCollider && this._boxCollision(collider)) {\n            overlappedCollider = collider;\n            let scripts = this.entity._scripts;\n            for (let i = 0, len = scripts.length; i < len; i++) {\n              scripts.get(i).onTriggerStay(collider);\n            }\n          }\n        } // end of for\n      } else if (this._myCollider instanceof ASphereCollider) {\n        this._sphere = this._getWorldSphere(this._myCollider);\n        for (let i = 0, len = colliders.length; i < len; i++) {\n          const collider = colliders[i];\n          if (collider != this._myCollider && this._sphereCollision(collider)) {\n            overlappedCollider = collider;\n            let scripts = this.entity._scripts;\n            for (let i = 0, len = scripts.length; i < len; i++) {\n              scripts.get(i).onTriggerStay(collider);\n            }\n          }\n        } // end of for\n      }\n    } // end of if\n\n    //-- overlap events\n    if (overlappedCollider != null && this._overlappedCollider != overlappedCollider) {\n      let scripts = this.entity._scripts;\n      for (let i = 0, len = scripts.length; i < len; i++) {\n        scripts.get(i).onTriggerEnter(overlappedCollider);\n      }\n    }\n\n    if (this._overlappedCollider != null && this._overlappedCollider != overlappedCollider) {\n      let scripts = this.entity._scripts;\n      for (let i = 0, len = scripts.length; i < len; i++) {\n        scripts.get(i).onTriggerExit(this._overlappedCollider);\n      }\n    }\n\n    this._overlappedCollider = overlappedCollider;\n  }\n\n  /**\n   * Calculate the boundingbox in world space from boxCollider.\n   * @param boxCollider - The boxCollider to calculate\n   * @param out - The calculated boundingBox\n   */\n  _updateWorldBox(boxCollider, out: BoundingBox): void {\n    const mat = boxCollider.entity.transform.worldMatrix;\n    const source = CollisionDetection._tempBox1;\n    boxCollider.boxMax.cloneTo(source.max);\n    boxCollider.boxMin.cloneTo(source.min);\n    BoundingBox.transform(source, mat, out);\n  }\n\n  /**\n   * Get the sphere info of the given sphere collider in world space.\n   * @param sphereCollider - The given sphere collider\n   */\n  _getWorldSphere(sphereCollider) {\n    const center: Vector3 = new Vector3();\n    Vector3.transformCoordinate(sphereCollider.center, sphereCollider.entity.transform.worldMatrix, center);\n    return {\n      radius: sphereCollider.radius,\n      center\n    };\n  }\n\n  /**\n   * Collider and another collider do collision detection.\n   * @param other - The another collider to collision detection\n   */\n  _boxCollision(other) {\n    if (other instanceof ABoxCollider) {\n      const box = CollisionDetection._tempBox2;\n      this._updateWorldBox(other, box);\n      return intersectBox2Box(box, this._box);\n    } else if (other instanceof ASphereCollider) {\n      const sphere = this._getWorldSphere(other);\n      return intersectSphere2Box(sphere, this._box);\n    }\n    return false;\n  }\n\n  /**\n   * Collider and another collider do collision detection.\n   * @param other - The another collider to collision detection\n   */\n  _sphereCollision(other) {\n    if (other instanceof ABoxCollider) {\n      const box = CollisionDetection._tempBox2;\n      this._updateWorldBox(other, box);\n      return intersectSphere2Box(this._sphere, box);\n    } else if (other instanceof ASphereCollider) {\n      const sphere = this._getWorldSphere(other);\n      return intersectSphere2Sphere(sphere, this._sphere);\n    }\n    return false;\n  }\n\n  onAwake() {\n    this._colliderManager = this.scene.findFeature(ColliderFeature);\n    this._myCollider = this.entity.getComponent(ACollider);\n  }\n}\n", "import { Color } from \"@oasis-engine/math\";\nimport { Component } from \"../Component\";\nimport { Entity } from \"../Entity\";\nimport { Shader } from \"../shader/Shader\";\n\n/**\n * Fog.\n */\nexport class Fog extends Component {\n  protected static _colorProperty = Shader.getPropertyByName(\"u_fogColor\");\n\n  /**\n   * Fog color.\n   */\n  get color(): Color {\n    return this._color;\n  }\n\n  set color(value: Color) {\n    this._color = value;\n    this.scene.shaderData.setColor(Fog._colorProperty, value);\n  }\n\n  private _color: Color = new Color(1, 0, 0, 1);\n\n  constructor(entity: Entity) {\n    super(entity);\n    this.color = this._color;\n  }\n\n  /**\n   * @internal\n   * @override\n   */\n  _onEnable() {\n    this.scene.shaderData.enableMacro(\"O3_HAS_FOG\");\n  }\n\n  /**\n   * @internal\n   * @override\n   */\n  _onDisable() {\n    this.scene.shaderData.disableMacro(\"O3_HAS_FOG\");\n  }\n}\n", "import { Entity } from \"../Entity\";\nimport { Shader } from \"../shader\";\nimport { Fog } from \"./Fog\";\n\n/**\n * Exponential fog.\n */\nexport class EXP2Fog extends Fog {\n  private static _densityProperty = Shader.getPropertyByName(\"u_fogDensity\");\n\n  /**\n   * Density of fog.\n   */\n  get density(): number {\n    return this._density;\n  }\n\n  set density(value: number) {\n    this._density = value;\n    this.scene.shaderData.setFloat(EXP2Fog._densityProperty, value);\n  }\n\n  private _density: number = 0.0025;\n\n  constructor(entity: Entity) {\n    super(entity);\n    this.density = this._density;\n  }\n  /**\n   * @internal\n   * @override\n   */\n  _onEnable() {\n    this.scene.shaderData.enableMacro(\"O3_FOG_EXP2\");\n  }\n\n  /**\n   * @internal\n   * @override\n   */\n  _onDisable() {\n    this.scene.shaderData.disableMacro(\"O3_FOG_EXP2\");\n  }\n}\n", "import { Entity } from \"../Entity\";\nimport { Shader } from \"../shader\";\nimport { Fog } from \"./Fog\";\n\n/**\n * Linear fog, according to the distance of the camera linear difference fog density.\n */\nexport class LinearFog extends Fog {\n  private static _nearProperty = Shader.getPropertyByName(\"u_fogNear\");\n  private static _farProperty = Shader.getPropertyByName(\"u_fogFar\");\n\n  /**\n   * Start of fog.\n   */\n  get near(): number {\n    return this._near;\n  }\n\n  set near(value: number) {\n    this._near = value;\n    this.scene.shaderData.setFloat(LinearFog._nearProperty, value);\n  }\n\n  /**\n   * End of fog.\n   */\n  get far(): number {\n    return this._far;\n  }\n\n  set far(value: number) {\n    this._far = value;\n    this.scene.shaderData.setFloat(LinearFog._farProperty, value);\n  }\n\n  private _near: number = 1;\n  private _far: number = 1000;\n\n  constructor(entity: Entity) {\n    super(entity);\n    this.near = this._near;\n    this.far = this._far;\n  }\n}\n", "import { Camera } from \"../Camera\";\nimport { Layer } from \"../Layer\";\nimport { Script } from \"../Script\";\nimport { RenderBufferDepthFormat } from \"../texture/enums/RenderBufferDepthFormat\";\nimport { RenderColorTexture } from \"../texture/RenderColorTexture\";\nimport { RenderTarget } from \"../texture/RenderTarget\";\n\n/**\n * Environmental probes, providing necessary capabilities such as reflection and refraction.\n * @example\n * ```ts\n * const probe = cameraEntity.addComponent( CubeProbe )\n * probe.onTextureChange = cubeTexture => {\n *   envLight.specularTexture = cubeTexture;\n *   skybox.specularTexture = cubeTexture;\n * }\n * ```\n */\nexport abstract class Probe extends Script {\n  /**\n   * Probe's layer, render everything by default.\n   */\n  probeLayer: Layer = Layer.Everything;\n\n  /**\n   * The width of the probe rendering target.\n   */\n  width: number = 1024;\n\n  /**\n   * The height of the probe rendering target.\n   */\n  height: number = 1024;\n\n  /**\n   * When using WebGL2, you can turn on MSAA at the hardware layer.\n   */\n  antiAliasing: number = 1;\n\n  /**\n   * Whether the probe is rendered to the cube color texture.\n   */\n  protected readonly _isCube: boolean = false;\n\n  private _oriCameraRenderTarget: RenderTarget;\n  private _renderTarget: RenderTarget;\n  private _renderTargetSwap: RenderTarget;\n  private _activeRenderTarget: RenderTarget;\n  private _camera: Camera;\n  private _oriCameraCullingMask: Layer;\n\n  private get _texture(): RenderColorTexture {\n    return this._activeRenderTarget?.getColorTexture();\n  }\n\n  /**\n   * Provide hooks for users to exchange Texture.\n   * @remarks Prevent issue: Feedback Loops Between Textures and the Framebuffer.\n   */\n  onTextureChange(renderColorTexture: RenderColorTexture) {}\n\n  /**\n   * @override\n   */\n  onBeginRender(camera: Camera): void {\n    if (!this.enabled) return;\n    this._camera = camera;\n    this._oriCameraCullingMask = camera.cullingMask;\n    camera.cullingMask = this.probeLayer;\n    if (\n      !this._activeRenderTarget ||\n      this._activeRenderTarget.width !== this.width ||\n      this._activeRenderTarget.height !== this.height ||\n      this._activeRenderTarget.antiAliasing !== this.antiAliasing\n    ) {\n      this._renderTarget = new RenderTarget(\n        this.engine,\n        this.width,\n        this.height,\n        new RenderColorTexture(this.engine, this.width, this.height, undefined, undefined, this._isCube),\n        RenderBufferDepthFormat.Depth,\n        this.antiAliasing\n      );\n\n      this._renderTargetSwap = new RenderTarget(\n        this.engine,\n        this.width,\n        this.height,\n        new RenderColorTexture(this.engine, this.width, this.height, undefined, undefined, this._isCube),\n        RenderBufferDepthFormat.Depth,\n        this.antiAliasing\n      );\n\n      this._activeRenderTarget = this._renderTarget;\n    }\n\n    this._oriCameraRenderTarget = camera.renderTarget;\n    camera.renderTarget = this._activeRenderTarget;\n  }\n\n  /**\n   * @override\n   */\n  onEndRender(camera: Camera): void {\n    if (!this.enabled) return;\n\n    this.onTextureChange && this.onTextureChange(this._texture);\n\n    this._activeRenderTarget =\n      this._activeRenderTarget === this._renderTarget ? this._renderTargetSwap : this._renderTarget;\n  }\n\n  protected _reset(): void {\n    if (!this.enabled) return;\n    this._camera.renderTarget = this._oriCameraRenderTarget;\n    this._camera.cullingMask = this._oriCameraCullingMask;\n  }\n}\n", "import { Matrix, Vector3 } from \"@oasis-engine/math\";\nimport { Camera } from \"../Camera\";\nimport { TextureCubeFace } from \"../texture\";\nimport { Probe } from \"./Probe\";\n\nconst cacheTarget: Vector3 = new Vector3();\nconst cacheUp: Vector3 = new Vector3();\nconst cacheDir: Vector3 = new Vector3();\n\n/**\n * Cube probe, generate cubeTexture, used for dynamic environment reflection and other effects.\n */\nexport class CubeProbe extends Probe {\n  /**\n   * The position of the probe can be set, the default is the origin [0,0,0].\n   */\n  position: Vector3 = new Vector3(0, 0, 0);\n\n  /**\n   * @override\n   */\n  protected readonly _isCube: boolean = true;\n\n  private oriViewMatrix = new Matrix();\n  private _oriFieldOfView: number;\n\n  /**\n   * @override\n   */\n  onBeginRender(camera: Camera): void {\n    if (!this.enabled) return;\n    super.onBeginRender(camera);\n    this._storeCamera(camera);\n\n    // Render 6 faces\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      // Change camera parameters\n      this._setCamera(faceIndex, camera);\n      camera.render(TextureCubeFace.PositiveX + faceIndex);\n    }\n\n    this._restoreCamera(camera);\n    super._reset();\n  }\n\n  /**\n   * Store original camera parameters.\n   */\n  private _storeCamera(camera: Camera) {\n    camera.viewMatrix.cloneTo(this.oriViewMatrix);\n    this._oriFieldOfView = camera.fieldOfView;\n  }\n\n  /**\n   * Restore camera parameters.\n   */\n  private _restoreCamera(camera: Camera) {\n    this.oriViewMatrix.cloneTo(camera.viewMatrix);\n    camera.fieldOfView = this._oriFieldOfView;\n  }\n\n  /**\n   * Set camera parameters according to the rendering surface.\n   */\n  private _setCamera(faceIndex: number, camera: Camera) {\n    switch (faceIndex) {\n      // positive_x\n      case 0:\n        cacheUp.setValue(0, -1, 0);\n        cacheDir.setValue(1, 0, 0);\n        break;\n      // negative_x\n      case 1:\n        cacheUp.setValue(0, -1, 0);\n        cacheDir.setValue(-1, 0, 0);\n        break;\n      // positive_y\n      case 2:\n        cacheUp.setValue(0, 0, 1);\n        cacheDir.setValue(0, 1, 0);\n        break;\n      // negative_y\n      case 3:\n        cacheUp.setValue(0, 0, -1);\n        cacheDir.setValue(0, -1, 0);\n        break;\n      // positive_z\n      case 4:\n        cacheUp.setValue(0, -1, 0);\n        cacheDir.setValue(0, 0, 1);\n        break;\n      // negative_z\n      case 5:\n        cacheUp.setValue(0, -1, 0);\n        cacheDir.setValue(0, 0, -1);\n        break;\n    }\n\n    Vector3.add(this.position, cacheDir, cacheTarget);\n    Matrix.lookAt(this.position, cacheTarget, cacheUp, camera.viewMatrix);\n    camera.fieldOfView = 90;\n  }\n}\n", "import { MathUtil, Matrix, Vector2 } from \"@oasis-engine/math\";\nimport { DirectLight } from \"../lighting/DirectLight\";\nimport { Light } from \"../lighting/Light\";\nimport { PointLight } from \"../lighting/PointLight\";\nimport { SpotLight } from \"../lighting/SpotLight\";\nimport { Shader } from \"../shader/Shader\";\nimport { ShaderData } from \"../shader/ShaderData\";\nimport { RenderColorTexture } from \"../texture/RenderColorTexture\";\nimport { RenderTarget } from \"../texture/RenderTarget\";\n\n/**\n * Shadow manager.\n */\nexport class LightShadow {\n  private static _viewMatFromLightProperty = Shader.getPropertyByName(\"u_viewMatFromLight\");\n  private static _projMatFromLightProperty = Shader.getPropertyByName(\"u_projMatFromLight\");\n  private static _shadowBiasProperty = Shader.getPropertyByName(\"u_shadowBias\");\n  private static _shadowIntensityProperty = Shader.getPropertyByName(\"u_shadowIntensity\");\n  private static _shadowRadiusProperty = Shader.getPropertyByName(\"u_shadowRadius\");\n  private static _shadowMapSizeProperty = Shader.getPropertyByName(\"u_shadowMapSize\");\n  private static _shadowMapsProperty = Shader.getPropertyByName(\"u_shadowMaps\");\n\n  /**\n   * @internal\n   */\n  static _updateShaderData(shaderData: ShaderData) {\n    const data = LightShadow._combinedData;\n\n    shaderData.setFloatArray(LightShadow._viewMatFromLightProperty, data.viewMatrix);\n    shaderData.setFloatArray(LightShadow._projMatFromLightProperty, data.projectionMatrix);\n    shaderData.setFloatArray(LightShadow._shadowBiasProperty, data.bias);\n    shaderData.setFloatArray(LightShadow._shadowIntensityProperty, data.intensity);\n    shaderData.setFloatArray(LightShadow._shadowRadiusProperty, data.radius);\n    shaderData.setFloatArray(LightShadow._shadowMapSizeProperty, data.mapSize);\n    shaderData.setTextureArray(LightShadow._shadowMapsProperty, data.map);\n  }\n\n  /**\n   * Clear all shadow maps.\n   */\n  static clearMap() {\n    LightShadow._combinedData.map.length = 0;\n  }\n\n  private static _maxLight = 3;\n\n  private static _combinedData = {\n    viewMatrix: new Float32Array(16 * LightShadow._maxLight),\n    projectionMatrix: new Float32Array(16 * LightShadow._maxLight),\n    bias: new Float32Array(LightShadow._maxLight),\n    intensity: new Float32Array(LightShadow._maxLight),\n    radius: new Float32Array(LightShadow._maxLight),\n    mapSize: new Float32Array(2 * LightShadow._maxLight),\n    map: []\n  };\n\n  private _mapSize: Vector2;\n  private _renderTarget: RenderTarget;\n\n  /**\n   * Shadow's light.\n   */\n  readonly light: Light;\n\n  /**\n   * Shadow bias.\n   */\n  bias: number = 0.005;\n\n  /**\n   * Shadow intensity, the larger the value, the clearer and darker the shadow.\n   */\n  intensity: number = 0.2;\n\n  /**\n   * Pixel range used for shadow PCF interpolation.\n   */\n  radius: number = 1;\n\n  /**\n   * Generate the projection matrix used by the shadow map.\n   */\n  projectionMatrix: Matrix = new Matrix();\n\n  constructor(light: Light, props = { engine: null, width: 512, height: 512 }) {\n    this.light = light;\n    const { engine, width, height } = props;\n\n    this._mapSize = new Vector2(width, height);\n    this._renderTarget = new RenderTarget(engine, width, height, new RenderColorTexture(engine, width, height));\n  }\n\n  /**\n   * The RenderTarget corresponding to the shadow map.\n   */\n  get renderTarget(): RenderTarget {\n    return this._renderTarget;\n  }\n\n  /**\n   * Shadow map's color render texture.\n   */\n  get map(): RenderColorTexture {\n    return this._renderTarget.getColorTexture();\n  }\n\n  /**\n   * Shadow map size.\n   */\n  get mapSize(): Vector2 {\n    return this._mapSize;\n  }\n\n  /**\n   * Initialize the projection matrix for lighting.\n   * @param light - The light to generate shadow\n   */\n  initShadowProjectionMatrix(light: Light) {\n    /**\n     * Directional light projection matrix, the default coverage area is left: -5, right: 5, bottom: -5, up: 5, near: 0.5, far: 50.\n     */\n    if (light instanceof DirectLight) {\n      Matrix.ortho(-5, 5, -5, 5, 0.1, 50, this.projectionMatrix);\n    }\n\n    /**\n     * Point light projection matrix, default configuration: fov: 50, aspect: 1, near: 0.5, far: 50.\n     */\n    if (light instanceof PointLight) {\n      Matrix.perspective(MathUtil.degreeToRadian(50), 1, 0.5, 50, this.projectionMatrix);\n    }\n\n    /**\n     * Spotlight projection matrix, the default configuration: fov: this.angle * 2 * Math.sqrt(2), aspect: 1, near: 0.1, far: this.distance + 5\n     */\n    if (light instanceof SpotLight) {\n      const fov = Math.min(Math.PI / 2, light.angle * 2 * Math.sqrt(2));\n      Matrix.perspective(fov, 1, 0.1, light.distance + 5, this.projectionMatrix);\n    }\n  }\n\n  appendData(lightIndex: number): void {\n    const viewStart = lightIndex * 16;\n    const projectionStart = lightIndex * 16;\n    const biasStart = lightIndex;\n    const intensityStart = lightIndex;\n    const radiusStart = lightIndex;\n    const mapSizeStart = lightIndex * 2;\n    const mapStart = lightIndex;\n\n    const data = LightShadow._combinedData;\n\n    data.viewMatrix.set(this.light.viewMatrix.elements, viewStart);\n    data.projectionMatrix.set(this.projectionMatrix.elements, projectionStart);\n    data.bias[biasStart] = this.bias;\n    data.intensity[intensityStart] = this.intensity;\n    data.radius[radiusStart] = this.radius;\n    data.mapSize[mapSizeStart] = this.mapSize.x;\n    data.mapSize[mapSizeStart + 1] = this.mapSize.y;\n    data.map[mapStart] = this.map;\n  }\n}\n", "import { Logger } from \"../base/Logger\";\nimport { AmbientLight } from \"../lighting/AmbientLight\";\nimport { Light } from \"../lighting/Light\";\nimport { LightShadow } from \"./LightShadow\";\nimport { Component } from \"../Component\";\n\n/**\n * Set whether the light to generate shadows.\n */\nObject.defineProperty(Light.prototype, \"enableShadow\", {\n  get: function () {\n    return this._enableShadow;\n  },\n  set: function (enabled) {\n    this._enableShadow = enabled;\n\n    if (this._enableShadow) {\n      if (this instanceof AmbientLight) {\n        this._enableShadow = false;\n        Logger.warn(\"Has no shadow!\");\n        return;\n      }\n\n      this.shadow = this.shadow || new LightShadow(this, { engine: this.engine, width: 512, height: 512 });\n      this.shadow.initShadowProjectionMatrix(this);\n    }\n  }\n});\n\n/**\n * Set whether the renderer to receive shadows.\n */\nObject.defineProperty(Component.prototype, \"receiveShadow\", {\n  get: function () {\n    return this._recieveShadow;\n  },\n  set: function (enabled) {\n    this._recieveShadow = enabled;\n  }\n});\n\n/**\n * Set whether the renderer to cast shadows.\n */\nObject.defineProperty(Component.prototype, \"castShadow\", {\n  get: function () {\n    return this._castShadow;\n  },\n  set: function (enabled) {\n    this._castShadow = enabled;\n  }\n});\n", "import { Engine } from \"../Engine\";\nimport { Material } from \"../material/Material\";\nimport { Shader } from \"../shader/Shader\";\n\n/**\n * Shadow Map material.\n */\nexport class ShadowMapMaterial extends Material {\n  constructor(engine: Engine) {\n    super(engine, Shader.find(\"shadow-map\"));\n    this.shaderData.enableMacro(\"O3_GENERATE_SHADOW_MAP\");\n  }\n}\n", "import { Color } from \"@oasis-engine/math\";\nimport { Camera } from \"../Camera\";\nimport { Layer } from \"../Layer\";\nimport { Light } from \"../lighting/Light\";\nimport { Material } from \"../material/Material\";\nimport { RenderPass } from \"../RenderPipeline/RenderPass\";\nimport { RenderQueue } from \"../RenderPipeline/RenderQueue\";\nimport { Shader } from \"../shader/Shader\";\nimport { RenderTarget } from \"../texture/RenderTarget\";\n\n/**\n * RenderPass for rendering shadow map.\n */\nexport class ShadowMapPass extends RenderPass {\n  private static _viewMatFromLightProperty = Shader.getPropertyByName(\"u_viewMatFromLight\");\n  private static _projMatFromLightProperty = Shader.getPropertyByName(\"u_projMatFromLight\");\n\n  readonly light: Light;\n\n  /**\n   * Constructor.\n   * @param light  - The light that the shadow belongs to\n   */\n  constructor(\n    name: string,\n    priority: number,\n    renderTarget: RenderTarget,\n    replaceMaterial: Material,\n    mask: Layer,\n    light: Light\n  ) {\n    super(name, priority, renderTarget, replaceMaterial, mask);\n    this.light = light;\n    this.clearColor = new Color(1, 1, 1, 1);\n  }\n\n  /**\n   * @override\n   */\n  preRender(camera: Camera, queue: RenderQueue) {\n    // The viewProjection matrix from the light.\n    const shaderData = this.replaceMaterial.shaderData;\n    shaderData.setMatrix(ShadowMapPass._viewMatFromLightProperty, this.light.viewMatrix);\n    shaderData.setMatrix(ShadowMapPass._projMatFromLightProperty, (this.light as any).shadow.projectionMatrix);\n  }\n}\n", "import { Engine } from \"../Engine\";\nimport { RenderQueueType } from \"../material\";\nimport { Material } from \"../material/Material\";\nimport { BlendFactor } from \"../shader/enums/BlendFactor\";\nimport { CompareFunction } from \"../shader/enums/CompareFunction\";\nimport { Shader } from \"../shader/Shader\";\n\n/**\n * Shadow material.\n */\nexport class ShadowMaterial extends Material {\n  constructor(engine: Engine) {\n    super(engine, Shader.find(\"shadow\"));\n\n    const targetBlendState = this.renderState.blendState.targetBlendState;\n    targetBlendState.enabled = true;\n    targetBlendState.sourceColorBlendFactor = targetBlendState.sourceAlphaBlendFactor = BlendFactor.DestinationColor;\n    targetBlendState.destinationColorBlendFactor = targetBlendState.destinationAlphaBlendFactor = BlendFactor.Zero;\n    this.renderState.depthState.compareFunction = CompareFunction.LessEqual;\n\n    this.renderQueueType = RenderQueueType.Transparent;\n  }\n}\n", "import { Camera } from \"../Camera\";\nimport { CameraClearFlags } from \"../enums/CameraClearFlags\";\nimport { LightFeature } from \"../lighting/LightFeature\";\nimport { RenderPass } from \"../RenderPipeline/RenderPass\";\nimport { RenderQueue } from \"../RenderPipeline/RenderQueue\";\nimport { LightShadow } from \"./LightShadow\";\n\n/**\n * RenderPass for rendering shadow.\n */\nexport class ShadowPass extends RenderPass {\n  constructor(...args) {\n    super(...args);\n    this.clearFlags = CameraClearFlags.None;\n  }\n\n  /**\n   * @override\n   */\n  preRender(camera: Camera, queue: RenderQueue) {\n    this.enabled = false;\n    const lightMgr = camera.scene.findFeature(LightFeature);\n    const lights = lightMgr.visibleLights;\n    const shaderData = this.replaceMaterial.shaderData;\n\n    // keep render based on default render pass\n    const pass = camera._renderPipeline.defaultRenderPass;\n    this.renderTarget = pass.renderTarget;\n\n    let shadowMapCount = 0;\n\n    LightShadow.clearMap();\n    for (let i = 0, len = lights.length; i < len; i++) {\n      const lgt: any = lights[i];\n      if (lgt.enableShadow) {\n        lgt.shadow.appendData(shadowMapCount++);\n      }\n    }\n\n    if (shadowMapCount) {\n      this.enabled = true;\n      LightShadow._updateShaderData(shaderData);\n      shaderData.enableMacro(\"O3_SHADOW_MAP_COUNT\", shadowMapCount.toString());\n    } else {\n      shaderData.disableMacro(\"O3_SHADOW_MAP_COUNT\");\n    }\n  }\n}\n", "import { Camera } from \"../Camera\";\nimport { Component } from \"../Component\";\nimport { Layer } from \"../Layer\";\nimport { LightFeature } from \"../lighting/LightFeature\";\nimport { RenderQueue } from \"../RenderPipeline/RenderQueue\";\nimport { Scene } from \"../Scene\";\nimport { SceneFeature } from \"../SceneFeature\";\nimport { ShadowMapMaterial } from \"./ShadowMapMaterial\";\nimport { ShadowMapPass } from \"./ShadowMapPass\";\nimport { ShadowMaterial } from \"./ShadowMaterial\";\nimport { ShadowPass } from \"./ShadowPass\";\n\n/**\n * Shadow plug-in.\n */\nexport class ShadowFeature extends SceneFeature {\n  private _shadowPass: ShadowPass;\n  private _shadowMapMaterial: ShadowMapMaterial;\n\n  /**\n   * @override\n   */\n  preRender(scene: Scene, camera: Camera) {\n    const lights = scene.findFeature(LightFeature).visibleLights;\n\n    if (lights.length > 0) {\n      // Check RenderPass for rendering shadows.\n      if (!this._shadowPass) {\n        this.addShadowPass(camera);\n      }\n\n      // Check RenderPass for rendering shadow map.\n      const renderPipeline = camera._renderPipeline;\n\n      for (let i = 0, len = lights.length; i < len; i++) {\n        const lgt: any = lights[i];\n        if (lgt.enableShadow && !lgt.shadowMapPass) {\n          lgt.shadowMapPass = this.addShadowMapPass(camera, lgt);\n        } else if (!lgt.enableShadow && lgt.shadowMapPass) {\n          renderPipeline.removeRenderPass(lgt.shadowMapPass);\n          lgt.shadowMapPass = null;\n        }\n      }\n\n      this.updatePassRenderFlag(renderPipeline._opaqueQueue);\n      this.updatePassRenderFlag(renderPipeline._alphaTestQueue);\n      this.updatePassRenderFlag(renderPipeline._transparentQueue);\n    }\n  }\n\n  /**\n   * Add RenderPass for rendering shadows.\n   * @param camera - The camera for rendering\n   */\n  addShadowPass(camera: Camera) {\n    const shadowMaterial = new ShadowMaterial(camera.engine);\n    this._shadowPass = new ShadowPass(\"ShadowPass\", 1, null, shadowMaterial, Layer.Layer30); // SHADOW\n    const renderer = camera._renderPipeline;\n    renderer.addRenderPass(this._shadowPass);\n  }\n\n  /**\n   * Add RenderPass for rendering shadow map.\n   * @param camera - The camera for rendering\n   * @param light - The light that the shadow belongs to\n   */\n  addShadowMapPass(camera: Camera, light) {\n    // Share shadow map material.\n    this._shadowMapMaterial = this._shadowMapMaterial || new ShadowMapMaterial(camera.engine);\n\n    const shadowMapPass = new ShadowMapPass(\n      \"ShadowMapPass\",\n      -1,\n      light.shadow.renderTarget,\n      this._shadowMapMaterial,\n      Layer.Layer31, // SHADOW_MAP\n      light\n    );\n    const renderer = camera._renderPipeline;\n    renderer.addRenderPass(shadowMapPass);\n\n    return shadowMapPass;\n  }\n\n  /**\n   * Update the renderPassFlag state of renderers in the scene.\n   * @param renderQueue - Render queue\n   */\n  updatePassRenderFlag(renderQueue: RenderQueue) {\n    const items = renderQueue.items;\n    for (let i = 0, len = items.length; i < len; i++) {\n      const item = items[i];\n      const ability: Component = item.component;\n\n      const receiveShadow = (ability as any).recieveShadow;\n      const castShadow = (ability as any).castShadow;\n      if (receiveShadow === true) {\n        ability.entity.layer |= Layer.Layer30; //SHADOW;\n      } else if (receiveShadow === false) {\n        ability.entity.layer &= ~Layer.Layer30; //SHADOW;\n      }\n\n      if (castShadow === true) {\n        ability.entity.layer |= Layer.Layer31; //SHADOW_MAP;\n      } else if (castShadow === false) {\n        ability.entity.layer &= ~Layer.Layer31; //SHADOW_MAP;\n      }\n    }\n  }\n}\n", "import \"./Extension\";\nimport { ShadowFeature } from \"./ShadowFeature\";\nimport { Scene } from \"../Scene\";\n\nScene.registerFeature(ShadowFeature);\n", "export { Engine } from \"./Engine\";\nexport { SystemInfo } from \"./SystemInfo\";\nexport type { Canvas } from \"./Canvas\";\nexport { EngineFeature } from \"./EngineFeature\";\n\nexport { Scene } from \"./Scene\";\nexport { SceneFeature } from \"./SceneFeature\";\nexport { SceneManager } from \"./SceneManager\";\n\nexport { Entity } from \"./Entity\";\nexport { Component } from \"./Component\";\nexport { Script } from \"./Script\";\nexport { Renderer } from \"./Renderer\";\nexport { dependencies } from \"./ComponentsDependencies\";\nexport { Camera } from \"./Camera\";\nexport { Transform } from \"./Transform\";\nexport { UpdateFlag } from \"./UpdateFlag\";\nexport { request } from \"./asset/request\";\nexport { Loader } from \"./asset/Loader\";\nexport { ResourceManager, resourceLoader } from \"./asset/ResourceManager\";\nexport { AssetPromise, AssetPromiseStatus } from \"./asset/AssetPromise\";\nexport type { LoadItem } from \"./asset/LoadItem\";\nexport { AssetType } from \"./asset/AssetType\";\nexport { RefObject } from \"./asset/RefObject\";\n\nexport { BasicRenderPipeline } from \"./RenderPipeline/BasicRenderPipeline\";\nexport { RenderQueue } from \"./RenderPipeline/RenderQueue\";\nexport { RenderPass } from \"./RenderPipeline/RenderPass\";\nexport { RenderElement } from \"./RenderPipeline/RenderElement\";\nexport { SpriteElement } from \"./RenderPipeline/SpriteElement\";\nexport * from \"./base\";\n\n// Lighting\nimport { LightFeature, hasLight } from \"./lighting/LightFeature\";\nimport { Scene } from \"./Scene\";\nScene.registerFeature(LightFeature);\n(Scene.prototype as any).hasLight = hasLight;\n\nexport { PhysicsManager } from \"./PhysicsManager\";\nexport { HitResult } from \"./HitResult\";\n\nexport { Background } from \"./Background\";\nexport { BackgroundMode } from \"./enums/BackgroundMode\";\nexport { CameraClearFlags } from \"./enums/CameraClearFlags\";\nexport * from \"./lighting/index\";\nexport * from \"./material/index\";\nexport * from \"./texture/index\";\nexport * from \"./graphic/index\";\nexport * from \"./2d/index\";\nexport * from \"./shaderlib/index\";\nexport * from \"./animation/index\";\nexport * from \"./mesh/index\";\nexport * from \"./sky/index\";\nexport * from \"./particle/index\";\nexport * from \"./trail/index\";\nexport * from \"./collider/index\";\nexport * from \"./collision/index\";\nexport * from \"./fog/index\";\nexport * from \"./env-probe/index\";\nexport * from \"./shadow/index\";\nexport * from \"./shader/index\";\nexport * from \"./Layer\";\nexport * from \"./clone/CloneManager\";\nexport * from \"./renderingHardwareInterface/index\";\n", "/**\n * Smoothing plug-in.\n * */\nexport interface WebGLExtension {\n  MAX_DRAW_BUFFERS: GLenum;\n  UNSIGNED_INT_24_8: GLenum;\n  MAX_SAMPLES: GLenum;\n  RGBA8: GLenum;\n  RGBA16F: GLenum;\n  RGBA32F: GLenum;\n  DEPTH_COMPONENT32F: GLenum;\n  READ_FRAMEBUFFER: GLenum;\n  DRAW_FRAMEBUFFER: GLenum;\n\n  createVertexArray(): WebGLVertexArrayObject | null;\n  deleteVertexArray(vertexArray: WebGLVertexArrayObject | null): void;\n  isVertexArray(vertexArray: WebGLVertexArrayObject | null): GLboolean;\n  bindVertexArray(array: WebGLVertexArrayObject | null): void;\n\n  renderbufferStorageMultisample(\n    target: GLenum,\n    samples: GLsizei,\n    internalformat: GLenum,\n    width: GLsizei,\n    height: GLsizei\n  ): void;\n  blitFramebuffer(\n    srcX0: GLint,\n    srcY0: GLint,\n    srcX1: GLint,\n    srcY1: GLint,\n    dstX0: GLint,\n    dstY0: GLint,\n    dstX1: GLint,\n    dstY1: GLint,\n    mask: GLbitfield,\n    filter: GLenum\n  ): void;\n\n  drawArraysInstanced(mode: GLenum, first: GLint, count: GLsizei, instanceCount: GLsizei): void;\n  drawElementsInstanced(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr, instanceCount: GLsizei): void;\n  vertexAttribDivisor(index: GLuint, divisor: GLuint): void;\n  drawBuffers(buffers: Iterable<GLenum>): void;\n}\n\nexport interface TextureFormatDetail {\n  internalFormat: GLint;\n  baseFormat?: GLenum;\n  dataType?: GLenum;\n  isCompressed: boolean;\n  attachment?: GLenum;\n}\n\n/**\n * @deprecated\n */\nexport enum GLCompressedTextureInternalFormat {\n  // astc\n  RGBA_ASTC_4X4_KHR = 0x93b0,\n  RGBA_ASTC_5X4_KHR = 0x93b1,\n  RGBA_ASTC_5X5_KHR = 0x93b2,\n  RGBA_ASTC_6X5_KHR = 0x93b3,\n  RGBA_ASTC_6X6_KHR = 0x93b4,\n  RGBA_ASTC_8X5_KHR = 0x93b5,\n  RGBA_ASTC_8X6_KHR = 0x93b6,\n  RGBA_ASTC_8X8_KHR = 0x93b7,\n  RGBA_ASTC_10X5_KHR = 0x93b8,\n  RGBA_ASTC_10X6_KHR = 0x93b9,\n  RGBA_ASTC_10X8_KHR = 0x93ba,\n  RGBA_ASTC_10X10_KHR = 0x93bb,\n  RGBA_ASTC_12X10_KHR = 0x93bc,\n  RGBA_ASTC_12X12_KHR = 0x93bd,\n  SRGB8_ALPHA8_ASTC_4X4_KHR = 0x93d0,\n  SRGB8_ALPHA8_ASTC_5X4_KHR = 0x93d1,\n  SRGB8_ALPHA8_ASTC_5X5_KHR = 0x93d2,\n  SRGB8_ALPHA8_ASTC_6X5_KHR = 0x93d3,\n  SRGB8_ALPHA8_ASTC_6X6_KHR = 0x93d4,\n  SRGB8_ALPHA8_ASTC_8X5_KHR = 0x93d5,\n  SRGB8_ALPHA8_ASTC_8X6_KHR = 0x93d6,\n  SRGB8_ALPHA8_ASTC_8X8_KHR = 0x93d7,\n  SRGB8_ALPHA8_ASTC_10X5_KHR = 0x93d8,\n  SRGB8_ALPHA8_ASTC_10X6_KHR = 0x93d9,\n  SRGB8_ALPHA8_ASTC_10X8_KHR = 0x93da,\n  SRGB8_ALPHA8_ASTC_10X10_KHR = 0x93db,\n  SRGB8_ALPHA8_ASTC_12X10_KHR = 0x93dc,\n  SRGB8_ALPHA8_ASTC_12X12_KHR = 0x93dd,\n\n  // etc1\n  RGB_ETC1_WEBGL = 0x8d64,\n\n  // etc2\n  R11_EAC = 0x9270,\n  SIGNED_R11_EAC = 0x9271,\n  RG11_EAC = 0x9272,\n  SIGNED_RG11_EAC = 0x9273,\n  RGB8_ETC2 = 0x9274,\n  SRGB8_ETC2 = 0x9275,\n  RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9276,\n  SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277,\n  RGBA8_ETC2_EAC = 0x9278,\n  SRGB8_ALPHA8_ETC2_EAC = 0x9279,\n\n  // pvrtc\n  RGB_PVRTC_4BPPV1_IMG = 0x8c00,\n  RGB_PVRTC_2BPPV1_IMG = 0x8c01,\n  RGBA_PVRTC_4BPPV1_IMG = 0x8c02,\n  RGBA_PVRTC_2BPPV1_IMG = 0x8c03,\n\n  // s3tc\n  RGB_S3TC_DXT1_EXT = 0x83f0,\n  RGBA_S3TC_DXT1_EXT = 0x83f1,\n  RGBA_S3TC_DXT3_EXT = 0x83f2,\n  RGBA_S3TC_DXT5_EXT = 0x83f3\n}\n", "import { Canvas } from \"@oasis-engine/core\";\nimport { Vector2 } from \"@oasis-engine/math\";\n\n/**\n * The canvas used on the web, which can support HTMLCanvasElement and OffscreenCanvas.\n */\nexport class WebCanvas implements Canvas {\n  _webCanvas: HTMLCanvasElement | OffscreenCanvas;\n\n  private _width: number;\n  private _height: number;\n  private _scale: Vector2 = new Vector2();\n\n  /**\n   * @inheritdoc\n   */\n  get width(): number {\n    return this._width;\n  }\n\n  set width(value: number) {\n    if (this._width !== value) {\n      this._webCanvas.width = value;\n      this._width = value;\n    }\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get height(): number {\n    return this._height;\n  }\n\n  set height(value: number) {\n    if (this._height !== value) {\n      this._webCanvas.height = value;\n      this._height = value;\n    }\n  }\n\n  /**\n   * The scale of canvas, the value is visible width/height divide the render width/height.\n   * @remarks Need to re-assign after modification to ensure that the modification takes effect.\n   */\n  get scale(): Vector2 {\n    const webCanvas = this._webCanvas;\n    if (webCanvas instanceof HTMLCanvasElement) {\n      this._scale.setValue(\n        (webCanvas.clientWidth * devicePixelRatio) / webCanvas.width,\n        (webCanvas.clientHeight * devicePixelRatio) / webCanvas.height\n      );\n    }\n    return this._scale;\n  }\n\n  set scale(value: Vector2) {\n    const webCanvas = this._webCanvas;\n    if (webCanvas instanceof HTMLCanvasElement) {\n      webCanvas.style.transformOrigin = `left top`;\n      webCanvas.style.transform = `scale(${value.x}, ${value.y})`;\n    }\n  }\n\n  /**\n   * Resize the rendering size according to the clientWidth and clientHeight of the canvas.\n   * @param pixelRatio - Pixel ratio\n   */\n  resizeByClientSize(pixelRatio: number = window.devicePixelRatio): void {\n    const webCanvas = this._webCanvas;\n    if (webCanvas instanceof HTMLCanvasElement) {\n      const width = webCanvas.clientWidth;\n      const height = webCanvas.clientHeight;\n      this.width = width * pixelRatio;\n      this.height = height * pixelRatio;\n    }\n  }\n\n  /**\n   * Create a web canvas.\n   * @param webCanvas - Web native canvas\n   */\n  constructor(webCanvas: HTMLCanvasElement | OffscreenCanvas) {\n    const width = webCanvas.width;\n    const height = webCanvas.height;\n    this._webCanvas = webCanvas;\n    this._width = width;\n    this._height = height;\n  }\n\n  /**\n   * Set scale.\n   * @param x - Scale along the X axis\n   * @param y - Scale along the Y axis\n   */\n  setScale(x: number, y: number): void {\n    this._scale.setValue(x, y);\n    this.scale = this._scale;\n  }\n}\n", "import { GLCapabilityType } from \"@oasis-engine/core\";\nimport { GLCompressedTextureInternalFormat } from \"./type\";\nimport { WebGLRenderer } from \"./WebGLRenderer\";\n\ntype extensionKey = string;\n\n/**\n * GL capability.\n */\nexport class GLCapability {\n  private _maxDrawBuffers: number;\n  private _maxAnisoLevel: number;\n  private _maxAntiAliasing: number;\n\n  _rhi: WebGLRenderer;\n  capabilityList: Map<GLCapabilityType, boolean>;\n\n  get canUseFloatTextureBlendShape(): boolean {\n    return (\n      this.canIUse(GLCapabilityType.shaderVertexID) &&\n      this.canIUse(GLCapabilityType.textureFloat) &&\n      this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0\n    );\n  }\n\n  /**\n   * Whether can use more joints.\n   */\n  get canIUseMoreJoints(): boolean {\n    return (\n      this.canIUse(GLCapabilityType.textureFloat) &&\n      this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0\n    );\n  }\n\n  get maxDrawBuffers() {\n    if (!this._maxDrawBuffers) {\n      if (this.canIUse(GLCapabilityType.drawBuffers)) {\n        this._maxDrawBuffers = this._rhi.gl.getParameter(this._rhi.gl.MAX_DRAW_BUFFERS);\n      } else {\n        this._maxDrawBuffers = 1;\n      }\n    }\n    return this._maxDrawBuffers;\n  }\n\n  /**\n   * Max anisoLevel.\n   */\n  get maxAnisoLevel(): number {\n    if (!this._maxAnisoLevel) {\n      const ext = this._rhi.requireExtension(GLCapabilityType.textureFilterAnisotropic);\n      this._maxAnisoLevel = ext ? this._rhi.gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;\n    }\n    return this._maxAnisoLevel;\n  }\n\n  /**\n   * Max MSAA count.\n   */\n  get maxAntiAliasing(): number {\n    if (!this._maxAntiAliasing) {\n      const gl = this._rhi.gl;\n      const canMSAA = this.canIUse(GLCapabilityType.multipleSample);\n\n      this._maxAntiAliasing = canMSAA ? gl.getParameter(gl.MAX_SAMPLES) : 1;\n    }\n    return this._maxAntiAliasing;\n  }\n\n  get rhi() {\n    return this._rhi;\n  }\n\n  constructor(rhi: WebGLRenderer) {\n    this._rhi = rhi;\n    this.capabilityList = new Map();\n\n    this._init();\n    this._compatibleAllInterface();\n  }\n\n  /**\n   * Check device capabilities.\n   */\n  canIUse(capabilityType: GLCapabilityType): boolean {\n    return this.capabilityList.get(capabilityType);\n  }\n\n  /**\n   * Check if can use some compressed texture format.\n   */\n  canIUseCompressedTextureInternalFormat(internalType: GLCompressedTextureInternalFormat): boolean {\n    const {\n      // astc\n      RGBA_ASTC_4X4_KHR,\n      RGBA_ASTC_12X12_KHR,\n      SRGB8_ALPHA8_ASTC_4X4_KHR,\n      SRGB8_ALPHA8_ASTC_12X12_KHR,\n      // etc1\n      RGB_ETC1_WEBGL,\n      // etc\n      R11_EAC,\n      SRGB8_ALPHA8_ETC2_EAC,\n      // pvrtc\n      RGB_PVRTC_4BPPV1_IMG,\n      RGBA_PVRTC_2BPPV1_IMG,\n      // s3tc\n      RGB_S3TC_DXT1_EXT,\n      RGBA_S3TC_DXT5_EXT\n    } = GLCompressedTextureInternalFormat;\n    if (\n      (internalType >= RGBA_ASTC_4X4_KHR && RGBA_ASTC_12X12_KHR <= RGBA_ASTC_12X12_KHR) ||\n      (internalType >= SRGB8_ALPHA8_ASTC_4X4_KHR && internalType <= SRGB8_ALPHA8_ASTC_12X12_KHR)\n    ) {\n      return this.canIUse(GLCapabilityType.astc);\n    } else if (internalType === RGB_ETC1_WEBGL) {\n      return this.canIUse(GLCapabilityType.etc1);\n    } else if (internalType >= R11_EAC && internalType <= SRGB8_ALPHA8_ETC2_EAC) {\n      return this.canIUse(GLCapabilityType.etc);\n    } else if (internalType >= RGB_PVRTC_4BPPV1_IMG && internalType <= RGBA_PVRTC_2BPPV1_IMG) {\n      return this.canIUse(GLCapabilityType.pvrtc);\n    } else if (internalType >= RGB_S3TC_DXT1_EXT && internalType <= RGBA_S3TC_DXT5_EXT) {\n      return this.canIUse(GLCapabilityType.s3tc);\n    }\n    return false;\n  }\n\n  /**\n   *  Init capabilities.\n   */\n  private _init() {\n    const cap = this.capabilityList;\n    const { isWebGL2 } = this.rhi;\n    const requireExtension = this.rhi.requireExtension.bind(this.rhi);\n\n    const {\n      shaderVertexID,\n      standardDerivatives,\n      shaderTextureLod,\n      elementIndexUint,\n      depthTexture,\n      vertexArrayObject,\n      instancedArrays,\n      multipleSample,\n      drawBuffers,\n\n      astc,\n      astc_webkit,\n      etc,\n      etc_webkit,\n      etc1,\n      etc1_webkit,\n      pvrtc,\n      pvrtc_webkit,\n      s3tc,\n      s3tc_webkit,\n\n      textureFloat,\n      textureHalfFloat,\n      textureFloatLinear,\n      textureHalfFloatLinear,\n      WEBGL_colorBufferFloat,\n      colorBufferFloat,\n      colorBufferHalfFloat,\n      textureFilterAnisotropic\n    } = GLCapabilityType;\n    cap.set(shaderVertexID, isWebGL2);\n    cap.set(standardDerivatives, isWebGL2 || !!requireExtension(standardDerivatives));\n    cap.set(shaderTextureLod, isWebGL2 || !!requireExtension(shaderTextureLod));\n    cap.set(elementIndexUint, isWebGL2 || !!requireExtension(elementIndexUint));\n    cap.set(depthTexture, isWebGL2 || !!requireExtension(depthTexture));\n    cap.set(vertexArrayObject, isWebGL2 || !!requireExtension(vertexArrayObject));\n    cap.set(instancedArrays, isWebGL2 || !!requireExtension(instancedArrays));\n    cap.set(multipleSample, isWebGL2);\n    cap.set(drawBuffers, isWebGL2 || !!requireExtension(drawBuffers));\n    cap.set(textureFloat, isWebGL2 || !!requireExtension(textureFloat));\n    cap.set(textureHalfFloat, isWebGL2 || !!requireExtension(textureHalfFloat));\n    cap.set(textureFloatLinear, !!requireExtension(textureFloatLinear));\n    cap.set(textureHalfFloatLinear, isWebGL2 || !!requireExtension(textureHalfFloatLinear));\n    cap.set(\n      colorBufferFloat,\n      (isWebGL2 && !!requireExtension(colorBufferFloat)) || !!requireExtension(WEBGL_colorBufferFloat)\n    );\n    cap.set(\n      colorBufferHalfFloat,\n      (isWebGL2 && !!requireExtension(colorBufferFloat)) || !!requireExtension(colorBufferHalfFloat)\n    );\n    cap.set(textureFilterAnisotropic, !!requireExtension(textureFilterAnisotropic));\n\n    cap.set(astc, !!(requireExtension(astc) || requireExtension(astc_webkit)));\n    cap.set(etc, !!(requireExtension(etc) || requireExtension(etc_webkit)));\n    cap.set(etc1, !!(requireExtension(etc1) || requireExtension(etc1_webkit)));\n    cap.set(pvrtc, !!(requireExtension(pvrtc) || requireExtension(pvrtc_webkit)));\n    cap.set(s3tc, !!(requireExtension(s3tc) || requireExtension(s3tc_webkit)));\n  }\n\n  /**\n   * If there are extensions that can supplement this ability, smooth out the difference.\n   * @example\n   * compatible(GLCapabilityType.depthTexture,{\n   *    UNSIGNED_INT_24_8: \"UNSIGNED_INT_24_8_WEBGL\"\n   * })\n   * gl.UNSIGNED_INT_24_8 = ext.UNSIGNED_INT_24_8_WEBGL\n   */\n  private _compatibleInterface(capabilityType: GLCapabilityType, flatItem: { [glKey: string]: extensionKey }) {\n    const rhi = this.rhi;\n    const gl = rhi.gl;\n    let ext = null;\n\n    if ((ext = rhi.requireExtension(capabilityType))) {\n      for (let glKey in flatItem) {\n        const extensionKey = flatItem[glKey];\n        const extensionVal = ext[extensionKey];\n\n        // Mini game hack the native function,use \u201C.bind\u201D to smooth out if is \u201CFuncion\u201D.\n        if (extensionVal?.bind) {\n          gl[glKey] = extensionVal.bind(ext);\n        } else {\n          gl[glKey] = extensionVal;\n        }\n      }\n    }\n  }\n\n  private _compatibleAllInterface() {\n    const {\n      depthTexture,\n      vertexArrayObject,\n      instancedArrays,\n      drawBuffers,\n      textureFilterAnisotropic,\n      textureHalfFloat,\n      colorBufferHalfFloat,\n      WEBGL_colorBufferFloat\n    } = GLCapabilityType;\n    const { isWebGL2 } = this.rhi;\n\n    if (!isWebGL2) {\n      this._compatibleInterface(depthTexture, {\n        UNSIGNED_INT_24_8: \"UNSIGNED_INT_24_8_WEBGL\"\n      });\n      this._compatibleInterface(vertexArrayObject, {\n        createVertexArray: \"createVertexArrayOES\",\n        deleteVertexArray: \"deleteVertexArrayOES\",\n        isVertexArray: \"isVertexArrayOES\",\n        bindVertexArray: \"bindVertexArrayOES\"\n      });\n      this._compatibleInterface(instancedArrays, {\n        drawArraysInstanced: \"drawArraysInstancedANGLE\",\n        drawElementsInstanced: \"drawElementsInstancedANGLE\",\n        vertexAttribDivisor: \"vertexAttribDivisorANGLE\"\n      });\n      this._compatibleInterface(drawBuffers, {\n        MAX_DRAW_BUFFERS: \"MAX_DRAW_BUFFERS_WEBGL\"\n      });\n      const items = {};\n      if (this.canIUse(GLCapabilityType.drawBuffers)) {\n        const maxDrawBuffers = this.maxDrawBuffers;\n        for (let i = 0; i < maxDrawBuffers; i++) {\n          i != 0 && (items[`COLOR_ATTACHMENT${i}`] = `COLOR_ATTACHMENT${i}_WEBGL`);\n          items[`DRAW_BUFFER${i}`] = `DRAW_BUFFER${i}_WEBGL`;\n        }\n        this._compatibleInterface(drawBuffers, {\n          drawBuffers: \"drawBuffersWEBGL\",\n          ...items\n        });\n      }\n      this._compatibleInterface(textureHalfFloat, {\n        HAFL_FLOAT: \"HALF_FLOAT_OES\"\n      });\n      this._compatibleInterface(colorBufferHalfFloat, {\n        RGBA16F: \"RBGA16F_EXT\"\n      });\n      this._compatibleInterface(WEBGL_colorBufferFloat, {\n        RGBA32F: \"RBGA32F_EXT\"\n      });\n    }\n\n    this._compatibleInterface(textureFilterAnisotropic, {\n      TEXTURE_MAX_ANISOTROPY_EXT: \"TEXTURE_MAX_ANISOTROPY_EXT\"\n    });\n  }\n}\n", "import { WebGLRenderer } from \"./WebGLRenderer\";\nimport { GLCapabilityType } from \"@oasis-engine/core\";\n\n/**\n * GLContext extension.\n */\nexport class GLExtensions {\n  private rhi: WebGLRenderer;\n  private _requireResult;\n\n  constructor(rhi: WebGLRenderer) {\n    this.rhi = rhi;\n    this._requireResult = {};\n  }\n\n  /**\n   * Require an extension.\n   */\n  requireExtension(ext: GLCapabilityType) {\n    if (this._requireResult[ext] !== undefined) {\n      return this._requireResult[ext];\n    }\n\n    this._requireResult[ext] = this.rhi.gl.getExtension(ext);\n    return this._requireResult[ext];\n  }\n}\n", "import { GLCapabilityType, Logger, Mesh, SubMesh } from \"@oasis-engine/core\";\nimport { IPlatformPrimitive } from \"@oasis-engine/design\";\nimport { WebGLExtension } from \"./type\";\nimport { WebGLRenderer } from \"./WebGLRenderer\";\n\n/**\n * Improvement of VAO:\n * 1) WebGL2.0 must support VAO, almost all devices support vao extensions in webgl1.0, we can use PollyFill,only keep VAO mode.\n * 2) VAO implementation now has bugs, change IndexBuffer\u3001VertexBuffer\u3001VertexElements need to update VAO.\n */\n\n/**\n * @internal\n * GL platform primitive.\n */\nexport class GLPrimitive implements IPlatformPrimitive {\n  protected attribLocArray: number[];\n  protected readonly _primitive: Mesh;\n  protected readonly canUseInstancedArrays: boolean;\n\n  private gl: (WebGLRenderingContext & WebGLExtension) | WebGL2RenderingContext;\n  private vao: Map<number, WebGLVertexArrayObject> = new Map();\n  private readonly _useVao: boolean;\n\n  constructor(rhi: WebGLRenderer, primitive: Mesh) {\n    this._primitive = primitive;\n    this.canUseInstancedArrays = rhi.canIUse(GLCapabilityType.instancedArrays);\n    this._useVao = rhi.canIUse(GLCapabilityType.vertexArrayObject);\n    this.gl = rhi.gl;\n  }\n\n  /**\n   * Draw the primitive.\n   */\n  draw(shaderProgram: any, subMesh: SubMesh): void {\n    const gl = this.gl;\n    const primitive = this._primitive;\n\n    if (this._useVao) {\n      if (!this.vao.has(shaderProgram.id)) {\n        this.registerVAO(shaderProgram);\n      }\n      const vao = this.vao.get(shaderProgram.id);\n      gl.bindVertexArray(vao);\n    } else {\n      this.bindBufferAndAttrib(shaderProgram);\n    }\n\n    // @ts-ignore\n    const { _indexBufferBinding, _instanceCount, _glIndexType, _glIndexByteCount } = primitive;\n    const { topology, start, count } = subMesh;\n\n    if (!_instanceCount) {\n      if (_indexBufferBinding) {\n        if (this._useVao) {\n          gl.drawElements(topology, count, _glIndexType, start * _glIndexByteCount);\n        } else {\n          const { _nativeBuffer } = _indexBufferBinding.buffer;\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer);\n          gl.drawElements(topology, count, _glIndexType, start * _glIndexByteCount);\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        }\n      } else {\n        gl.drawArrays(topology, start, count);\n      }\n    } else {\n      if (this.canUseInstancedArrays) {\n        if (_indexBufferBinding) {\n          if (this._useVao) {\n            gl.drawElementsInstanced(topology, count, _glIndexType, start * _glIndexByteCount, _instanceCount);\n          } else {\n            const { _nativeBuffer } = _indexBufferBinding.buffer;\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer);\n            gl.drawElementsInstanced(topology, count, _glIndexType, start * _glIndexByteCount, _instanceCount);\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n          }\n        } else {\n          gl.drawArraysInstanced(topology, start, count, _instanceCount);\n        }\n      } else {\n        Logger.error(\"ANGLE_instanced_arrays extension is not supported\");\n      }\n    }\n\n    // unbind\n    if (this._useVao) {\n      gl.bindVertexArray(null);\n    } else {\n      this.disableAttrib();\n    }\n  }\n\n  destroy() {\n    if (this._useVao) {\n      const gl = this.gl;\n      this.vao.forEach((vao) => {\n        gl.deleteVertexArray(vao);\n      });\n      this.vao.clear();\n    }\n  }\n\n  /**\n   * Bind buffer and attribute.\n   */\n  protected bindBufferAndAttrib(shaderProgram: any): void {\n    const gl = this.gl;\n    const primitive = this._primitive;\n    // @ts-ignore\n    const vertexBufferBindings = primitive._vertexBufferBindings;\n\n    this.attribLocArray = [];\n    const attributeLocation = shaderProgram.attributeLocation;\n    const attributes = primitive._vertexElementMap;\n\n    let vbo: WebGLBuffer;\n    let lastBoundVbo: WebGLBuffer;\n\n    for (const name in attributeLocation) {\n      const loc = attributeLocation[name];\n      if (loc === -1) continue;\n\n      const element = attributes[name];\n      if (element) {\n        const { buffer, stride } = vertexBufferBindings[element.bindingIndex];\n        vbo = buffer._nativeBuffer;\n        // prevent binding the vbo which already bound at the last loop, e.g. a buffer with multiple attributes.\n        if (lastBoundVbo !== vbo) {\n          lastBoundVbo = vbo;\n          gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n        }\n\n        gl.enableVertexAttribArray(loc);\n        const { size, type, normalized } = element._glElementInfo;\n        gl.vertexAttribPointer(loc, size, type, normalized, stride, element.offset);\n        if (this.canUseInstancedArrays) {\n          gl.vertexAttribDivisor(loc, element.instanceStepRate);\n        }\n        this.attribLocArray.push(loc);\n      } else {\n        Logger.warn(\"vertex attribute not found: \" + name);\n      }\n    }\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  }\n\n  protected disableAttrib() {\n    const gl = this.gl;\n    for (let i = 0, l = this.attribLocArray.length; i < l; i++) {\n      gl.disableVertexAttribArray(this.attribLocArray[i]);\n    }\n  }\n\n  private registerVAO(shaderProgram: any): void {\n    const gl = this.gl;\n    const vao = gl.createVertexArray();\n\n    /** register VAO */\n    gl.bindVertexArray(vao);\n\n    // @ts-ignore\n    const { _indexBufferBinding } = this._primitive;\n    if (_indexBufferBinding) {\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _indexBufferBinding.buffer._nativeBuffer);\n    }\n    this.bindBufferAndAttrib(shaderProgram);\n\n    /** unbind */\n    gl.bindVertexArray(null);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    this.disableAttrib();\n\n    this.vao.set(shaderProgram.id, vao);\n  }\n}\n", "import {\n  GLCapabilityType,\n  IPlatformTexture,\n  Logger,\n  RenderBufferColorFormat,\n  RenderBufferDepthFormat,\n  Texture,\n  TextureCubeFace,\n  TextureFilterMode,\n  TextureFormat,\n  TextureWrapMode\n} from \"@oasis-engine/core\";\nimport { GLCompressedTextureInternalFormat, TextureFormatDetail } from \"./type\";\nimport { WebGLRenderer } from \"./WebGLRenderer\";\n\n/**\n * Texture in WebGL platform.\n */\nexport class GLTexture implements IPlatformTexture {\n  /** @internal */\n  static _readFrameBuffer: WebGLFramebuffer = null;\n\n  /** @internal */\n  static _isPowerOf2(v: number): boolean {\n    return (v & (v - 1)) === 0;\n  }\n\n  /**\n   * Get more texture info from TextureFormat.\n   * @internal\n   */\n  static _getFormatDetail(\n    format: TextureFormat,\n    gl: WebGLRenderingContext & WebGL2RenderingContext,\n    isWebGL2: boolean\n  ): TextureFormatDetail {\n    switch (format) {\n      case TextureFormat.R8G8B8:\n        return {\n          internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,\n          baseFormat: gl.RGB,\n          dataType: gl.UNSIGNED_BYTE,\n          isCompressed: false\n        };\n      case TextureFormat.R8G8B8A8:\n        return {\n          internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,\n          baseFormat: gl.RGBA,\n          dataType: gl.UNSIGNED_BYTE,\n          isCompressed: false\n        };\n      case TextureFormat.R4G4B4A4:\n        return {\n          internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,\n          baseFormat: gl.RGBA,\n          dataType: gl.UNSIGNED_SHORT_4_4_4_4,\n          isCompressed: false\n        };\n      case TextureFormat.R5G5B5A1:\n        return {\n          internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,\n          baseFormat: gl.RGBA,\n          dataType: gl.UNSIGNED_SHORT_5_5_5_1,\n          isCompressed: false\n        };\n      case TextureFormat.R5G6B5:\n        return {\n          internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,\n          baseFormat: gl.RGB,\n          dataType: gl.UNSIGNED_SHORT_5_6_5,\n          isCompressed: false\n        };\n      case TextureFormat.Alpha8:\n        return {\n          internalFormat: gl.ALPHA,\n          baseFormat: gl.ALPHA,\n          dataType: gl.UNSIGNED_BYTE,\n          isCompressed: false\n        };\n      case TextureFormat.LuminanceAlpha:\n        return {\n          internalFormat: gl.LUMINANCE_ALPHA,\n          baseFormat: gl.LUMINANCE_ALPHA,\n          dataType: gl.UNSIGNED_BYTE,\n          isCompressed: false\n        };\n      case TextureFormat.R32G32B32A32:\n        return {\n          internalFormat: gl.RGBA32F,\n          baseFormat: gl.RGBA,\n          dataType: gl.FLOAT,\n          isCompressed: false\n        };\n      case TextureFormat.DXT1:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,\n          isCompressed: true\n        };\n      case TextureFormat.DXT5:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT,\n          isCompressed: true\n        };\n      case TextureFormat.ETC1_RGB:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,\n          isCompressed: true\n        };\n      case TextureFormat.ETC2_RGB:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGB8_ETC2,\n          isCompressed: true\n        };\n      case TextureFormat.ETC2_RGBA5:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n          isCompressed: true\n        };\n      case TextureFormat.ETC2_RGBA8:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC,\n          isCompressed: true\n        };\n      case TextureFormat.PVRTC_RGB2:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG,\n          isCompressed: true\n        };\n      case TextureFormat.PVRTC_RGBA2:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,\n          isCompressed: true\n        };\n      case TextureFormat.PVRTC_RGB4:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,\n          isCompressed: true\n        };\n      case TextureFormat.PVRTC_RGBA4:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG,\n          isCompressed: true\n        };\n      case TextureFormat.ASTC_4x4:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,\n          isCompressed: true\n        };\n      case TextureFormat.ASTC_5x5:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR,\n          isCompressed: true\n        };\n      case TextureFormat.ASTC_6x6:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR,\n          isCompressed: true\n        };\n      case TextureFormat.ASTC_8x8:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR,\n          isCompressed: true\n        };\n      case TextureFormat.ASTC_10x10:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR,\n          isCompressed: true\n        };\n      case TextureFormat.ASTC_12x12:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,\n          isCompressed: true\n        };\n      default:\n        throw new Error(`this TextureFormat is not supported in Oasis Engine: ${format}`);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static _getRenderBufferColorFormatDetail(\n    format: RenderBufferColorFormat,\n    gl: WebGLRenderingContext & WebGL2RenderingContext,\n    isWebGL2: boolean\n  ): TextureFormatDetail {\n    switch (format) {\n      case RenderBufferColorFormat.R8G8B8:\n        return {\n          internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,\n          baseFormat: gl.RGB,\n          dataType: gl.UNSIGNED_BYTE,\n          isCompressed: false\n        };\n      case RenderBufferColorFormat.R8G8B8A8:\n        return {\n          internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,\n          baseFormat: gl.RGBA,\n          dataType: gl.UNSIGNED_BYTE,\n          isCompressed: false\n        };\n      case RenderBufferColorFormat.R4G4B4A4:\n        return {\n          internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,\n          baseFormat: gl.RGBA,\n          dataType: gl.UNSIGNED_SHORT_4_4_4_4,\n          isCompressed: false\n        };\n      case RenderBufferColorFormat.R5G5B5A1:\n        return {\n          internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,\n          baseFormat: gl.RGBA,\n          dataType: gl.UNSIGNED_SHORT_5_5_5_1,\n          isCompressed: false\n        };\n      case RenderBufferColorFormat.R5G6B5:\n        return {\n          internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,\n          baseFormat: gl.RGB,\n          dataType: gl.UNSIGNED_SHORT_5_6_5,\n          isCompressed: false\n        };\n      case RenderBufferColorFormat.Alpha8:\n        return {\n          internalFormat: gl.ALPHA,\n          baseFormat: gl.ALPHA,\n          dataType: gl.UNSIGNED_BYTE,\n          isCompressed: false\n        };\n      case RenderBufferColorFormat.R16G16B16A16:\n        return {\n          internalFormat: gl.RGBA16F,\n          baseFormat: gl.RGBA,\n          dataType: gl.HALF_FLOAT,\n          isCompressed: false\n        };\n      case RenderBufferColorFormat.R32G32B32A32:\n        return {\n          internalFormat: gl.RGBA32F,\n          baseFormat: gl.RGBA,\n          dataType: gl.FLOAT,\n          isCompressed: false\n        };\n      default:\n        throw new Error(`this RenderBufferColorFormat is not supported in Oasis Engine: ${format}`);\n    }\n  }\n\n  /**\n   * In WebGL 1, internalformat must be the same as baseFormat when call texImage2D.\n   * @internal\n   */\n  static _getRenderBufferDepthFormatDetail(\n    format: RenderBufferDepthFormat,\n    gl: WebGLRenderingContext & WebGL2RenderingContext,\n    isWebGL2: boolean\n  ): TextureFormatDetail {\n    switch (format) {\n      case RenderBufferDepthFormat.Depth:\n        return {\n          internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16,\n          baseFormat: gl.DEPTH_COMPONENT,\n          dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_INT,\n          isCompressed: false,\n          attachment: gl.DEPTH_ATTACHMENT\n        };\n      case RenderBufferDepthFormat.DepthStencil:\n        return {\n          internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,\n          baseFormat: gl.DEPTH_STENCIL,\n          dataType: gl.UNSIGNED_INT_24_8,\n          isCompressed: false,\n          attachment: gl.DEPTH_STENCIL_ATTACHMENT\n        };\n      case RenderBufferDepthFormat.Stencil:\n        return {\n          internalFormat: gl.STENCIL_INDEX8,\n          baseFormat: gl.STENCIL_ATTACHMENT,\n          dataType: gl.UNSIGNED_BYTE,\n          isCompressed: false,\n          attachment: gl.STENCIL_ATTACHMENT\n        };\n      case RenderBufferDepthFormat.Depth16:\n        return {\n          internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT16,\n          baseFormat: gl.DEPTH_COMPONENT,\n          dataType: gl.UNSIGNED_INT,\n          isCompressed: false,\n          attachment: gl.DEPTH_ATTACHMENT\n        };\n      case RenderBufferDepthFormat.Depth24:\n        return {\n          internalFormat: gl.DEPTH_COMPONENT24,\n          baseFormat: gl.DEPTH_COMPONENT,\n          dataType: gl.UNSIGNED_INT,\n          isCompressed: false,\n          attachment: gl.DEPTH_ATTACHMENT\n        };\n      case RenderBufferDepthFormat.Depth32:\n        return {\n          internalFormat: gl.DEPTH_COMPONENT32F,\n          baseFormat: gl.DEPTH_COMPONENT,\n          dataType: gl.FLOAT,\n          isCompressed: false,\n          attachment: gl.DEPTH_ATTACHMENT\n        };\n      case RenderBufferDepthFormat.Depth24Stencil8:\n        return {\n          internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,\n          baseFormat: gl.DEPTH_STENCIL,\n          dataType: gl.UNSIGNED_INT_24_8,\n          isCompressed: false,\n          attachment: gl.DEPTH_STENCIL_ATTACHMENT\n        };\n      case RenderBufferDepthFormat.Depth32Stencil8:\n        return {\n          internalFormat: gl.DEPTH32F_STENCIL8,\n          baseFormat: gl.DEPTH_STENCIL,\n          dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,\n          isCompressed: false,\n          attachment: gl.DEPTH_STENCIL_ATTACHMENT\n        };\n      default:\n        throw new Error(`this RenderBufferDepthFormat is not supported in Oasis Engine: ${format}`);\n    }\n  }\n\n  /**\n   * Check whether the corresponding texture format is supported.\n   * @internal\n   */\n  static _supportTextureFormat(format: TextureFormat, rhi: WebGLRenderer): boolean {\n    let isSupported = true;\n\n    switch (format) {\n      case TextureFormat.R32G32B32A32:\n        {\n          if (!rhi.canIUse(GLCapabilityType.textureFloat)) {\n            isSupported = false;\n          }\n        }\n        break;\n    }\n\n    return isSupported;\n  }\n\n  /**\n   * @internal\n   */\n  static _supportRenderBufferColorFormat(format: RenderBufferColorFormat, rhi: WebGLRenderer): boolean {\n    let isSupported = true;\n\n    switch (format) {\n      case RenderBufferColorFormat.R32G32B32A32:\n        {\n          if (!rhi.canIUse(GLCapabilityType.colorBufferFloat) || !rhi.canIUse(GLCapabilityType.textureFloat)) {\n            isSupported = false;\n          }\n        }\n        break;\n      case RenderBufferColorFormat.R16G16B16A16:\n        {\n          if (!rhi.canIUse(GLCapabilityType.colorBufferHalfFloat) || !rhi.canIUse(GLCapabilityType.textureHalfFloat)) {\n            isSupported = false;\n          }\n        }\n        break;\n    }\n\n    return isSupported;\n  }\n\n  /**\n   * @internal\n   */\n  static _supportRenderBufferDepthFormat(\n    format: RenderBufferDepthFormat,\n    rhi: WebGLRenderer,\n    isTexture: boolean\n  ): boolean {\n    const isWebGL2: boolean = rhi.isWebGL2;\n    let isSupported = true;\n\n    if (isTexture && !rhi.canIUse(GLCapabilityType.depthTexture)) {\n      return false;\n    }\n\n    switch (format) {\n      case RenderBufferDepthFormat.Stencil:\n        {\n          isSupported = false;\n        }\n        break;\n      case RenderBufferDepthFormat.Depth24:\n      case RenderBufferDepthFormat.Depth32:\n      case RenderBufferDepthFormat.Depth32Stencil8:\n        {\n          if (!isWebGL2) {\n            isSupported = false;\n          }\n        }\n        break;\n    }\n\n    return isSupported;\n  }\n\n  /** @internal */\n  _texture: Texture;\n  /** @internal */\n  _glTexture: WebGLTexture;\n  /** @internal */\n  _rhi: WebGLRenderer;\n  /** @internal */\n  _gl: WebGLRenderingContext & WebGL2RenderingContext;\n  /** @internal */\n  _isWebGL2: boolean;\n  /** @internal */\n  _target: GLenum; // gl.TEXTURE_2D | gl.TEXTURE_CUBE_MAP\n  /** @internal */\n  _formatDetail: TextureFormatDetail;\n\n  /**\n   * Wrapping mode for texture coordinate S.\n   */\n  set wrapModeU(value: TextureWrapMode) {\n    this._bind();\n    this._setWrapMode(value, this._gl.TEXTURE_WRAP_S);\n  }\n\n  /**\n   * Wrapping mode for texture coordinate T.\n   */\n  set wrapModeV(value: TextureWrapMode) {\n    this._bind();\n    this._setWrapMode(value, this._gl.TEXTURE_WRAP_T);\n  }\n\n  /**\n   * Filter mode for texture.\n   */\n  set filterMode(value: TextureFilterMode) {\n    const gl = this._gl;\n    const target = this._target;\n    /** @ts-ignore */\n    const { _mipmap } = this._texture;\n\n    this._bind();\n    switch (value) {\n      case TextureFilterMode.Point:\n        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST);\n        break;\n      case TextureFilterMode.Bilinear:\n        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR);\n        break;\n      case TextureFilterMode.Trilinear:\n        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\n        break;\n    }\n  }\n\n  /**\n   * Anisotropic level for texture.\n   */\n  set anisoLevel(value: number) {\n    const gl = this._gl as WebGLRenderingContext & WebGL2RenderingContext & EXT_texture_filter_anisotropic;\n\n    this._bind();\n    gl.texParameterf(this._target, gl.TEXTURE_MAX_ANISOTROPY_EXT, value);\n  }\n\n  /**\n   * Create texture in WebGL platform.\n   */\n  constructor(rhi: WebGLRenderer, texture: Texture, target: GLenum) {\n    this._texture = texture;\n    this._rhi = rhi;\n    this._gl = rhi.gl as WebGLRenderingContext & WebGL2RenderingContext;\n    this._isWebGL2 = rhi.isWebGL2;\n    this._target = target;\n    this._glTexture = this._gl.createTexture();\n  }\n\n  /**\n   * Destroy texture.\n   */\n  destroy() {\n    this._gl.deleteTexture(this._glTexture);\n    this._texture = null;\n    this._glTexture = null;\n    this._formatDetail = null;\n  }\n\n  /**\n   * Generate multi-level textures based on the 0th level data.\n   */\n  generateMipmaps(): void {\n    this._bind();\n    this._gl.generateMipmap(this._target);\n  }\n\n  protected _bind() {\n    this._rhi.bindTexture(this);\n  }\n\n  /**\n   * Pre-development mipmapping GPU memory.\n   */\n  protected _initMipmap(isCube: boolean): void {\n    const gl = this._gl;\n    const isWebGL2 = this._isWebGL2;\n    let { internalFormat, baseFormat, dataType } = this._formatDetail;\n    const { mipmapCount, width, height } = this._texture;\n\n    this._bind();\n\n    if (isWebGL2 && !(baseFormat === gl.LUMINANCE_ALPHA || baseFormat === gl.ALPHA)) {\n      gl.texStorage2D(this._target, mipmapCount, internalFormat, width, height);\n    } else {\n      // In WebGL 1, internalformat must be the same as baseFormat\n      if (baseFormat !== internalFormat) {\n        internalFormat = baseFormat;\n      }\n\n      if (!isCube) {\n        for (let i = 0; i < mipmapCount; i++) {\n          const mipWidth = Math.max(1, width >> i);\n          const mipHeight = Math.max(1, height >> i);\n\n          gl.texImage2D(this._target, i, internalFormat, mipWidth, mipHeight, 0, baseFormat, dataType, null);\n        }\n      } else {\n        for (let i = 0; i < mipmapCount; i++) {\n          const size = Math.max(1, width >> i);\n          for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n            gl.texImage2D(\n              gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\n              i,\n              internalFormat,\n              size,\n              size,\n              0,\n              baseFormat,\n              dataType,\n              null\n            );\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the pixel color buffer according to the specified cube face and area.\n   * @param face - You can choose which cube face to read\n   * @param x - X coordinate of area start\n   * @param y - Y coordinate of area start\n   * @param width - Area width\n   * @param height - Area height\n   * @param out - Color buffer\n   */\n  protected _getPixelBuffer(\n    face: TextureCubeFace | null,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    out: ArrayBufferView\n  ): void {\n    const gl = this._gl;\n    const { baseFormat, dataType } = this._formatDetail;\n\n    if (!GLTexture._readFrameBuffer) {\n      GLTexture._readFrameBuffer = gl.createFramebuffer();\n    }\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, GLTexture._readFrameBuffer);\n\n    if (face != null) {\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0,\n        gl.TEXTURE_CUBE_MAP_POSITIVE_X + face,\n        this._glTexture,\n        0\n      );\n    } else {\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._glTexture, 0);\n    }\n    gl.readPixels(x, y, width, height, baseFormat, dataType, out);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  }\n\n  private _setWrapMode(value: TextureWrapMode, pname: GLenum): void {\n    const gl = this._gl;\n    const isWebGL2 = this._isWebGL2;\n    const target = this._target;\n    const { width, height } = this._texture;\n\n    if (\n      !isWebGL2 &&\n      value !== TextureWrapMode.Clamp &&\n      (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))\n    ) {\n      Logger.warn(\n        \"non-power-2 texture is not supported for REPEAT or MIRRORED_REPEAT in WebGL1,and has automatically downgraded to CLAMP_TO_EDGE\"\n      );\n      value = TextureWrapMode.Clamp;\n    }\n\n    switch (value) {\n      case TextureWrapMode.Clamp:\n        gl.texParameteri(target, pname, gl.CLAMP_TO_EDGE);\n        break;\n      case TextureWrapMode.Repeat:\n        gl.texParameteri(target, pname, gl.REPEAT);\n        break;\n      case TextureWrapMode.Mirror:\n        gl.texParameteri(target, pname, gl.MIRRORED_REPEAT);\n        break;\n    }\n  }\n}\n", "import {\n  IPlatformRenderColorTexture,\n  Logger,\n  RenderBufferColorFormat,\n  RenderColorTexture,\n  TextureCubeFace\n} from \"@oasis-engine/core\";\nimport { GLTexture } from \"./GLTexture\";\nimport { WebGLRenderer } from \"./WebGLRenderer\";\n\n/**\n * The texture in WebGL platform is used for the output of color information in off-screen rendering.\n */\nexport class GLRenderColorTexture extends GLTexture implements IPlatformRenderColorTexture {\n  /**\n   * Create render color texture in WebGL platform.\n   */\n  constructor(rhi: WebGLRenderer, texture: RenderColorTexture) {\n    super(rhi, texture, texture.isCube ? rhi.gl.TEXTURE_CUBE_MAP : rhi.gl.TEXTURE_2D);\n\n    /** @ts-ignore */\n    const { format, _mipmap, width, height, isCube } = texture;\n\n    const isWebGL2 = this._isWebGL2;\n\n    if (!GLTexture._supportRenderBufferColorFormat(format, rhi)) {\n      throw new Error(`RenderBufferColorFormat is not supported:${RenderBufferColorFormat[format]}`);\n    }\n\n    if (isCube && width !== height) {\n      throw new Error(\"The cube texture must have the same width and height\");\n    }\n\n    if (_mipmap && !isWebGL2 && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {\n      Logger.warn(\n        \"non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap\"\n      );\n\n      /** @ts-ignore */\n      texture._mipmap = false;\n      /** @ts-ignore */\n      texture._mipmapCount = texture._getMipmapCount();\n    }\n\n    this._formatDetail = GLTexture._getRenderBufferColorFormatDetail(format, this._gl, isWebGL2);\n    this._initMipmap(isCube);\n  }\n\n  /**\n   * Get the pixel color buffer according to the specified cube face and area.\n   * @param face - You can choose which cube face to read if it's cube texture\n   * @param x - X coordinate of area start\n   * @param y - Y coordinate of area start\n   * @param width - Area width\n   * @param height - Area height\n   * @param out - Color buffer\n   */\n  getPixelBuffer(\n    face: TextureCubeFace | null,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    out: ArrayBufferView\n  ): void {\n    super._getPixelBuffer(face, x, y, width, height, out);\n  }\n}\n", "import { IPlatformRenderDepthTexture, Logger, RenderBufferDepthFormat, RenderDepthTexture } from \"@oasis-engine/core\";\nimport { GLTexture } from \"./GLTexture\";\nimport { WebGLRenderer } from \"./WebGLRenderer\";\n\n/**\n * The texture in WebGL platform is used for the output of depth information in off-screen rendering.\n */\nexport class GLRenderDepthTexture extends GLTexture implements IPlatformRenderDepthTexture {\n  /**\n   * Create render depth texture in WebGL platform.\n   */\n  constructor(rhi: WebGLRenderer, texture: RenderDepthTexture) {\n    super(rhi, texture, texture.isCube ? rhi.gl.TEXTURE_CUBE_MAP : rhi.gl.TEXTURE_2D);\n\n    /** @ts-ignore */\n    const { format, _mipmap, width, height, isCube } = texture;\n    const isWebGL2 = this._isWebGL2;\n\n    if (!GLTexture._supportRenderBufferDepthFormat(format, rhi, true)) {\n      throw new Error(`RenderBufferDepthFormat is not supported:${RenderBufferDepthFormat[format]}`);\n    }\n\n    if (isCube && width !== height) {\n      throw new Error(\"The cube texture must have the same width and height\");\n    }\n\n    if (_mipmap && !isWebGL2 && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {\n      Logger.warn(\n        \"non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap\"\n      );\n\n      /** @ts-ignore */\n      texture._mipmap = false;\n      /** @ts-ignore */\n      texture._mipmapCount = texture._getMipmapCount();\n    }\n\n    this._formatDetail = GLTexture._getRenderBufferDepthFormatDetail(format, this._gl, isWebGL2);\n    this._initMipmap(isCube);\n  }\n}\n", "/**\n * @private\n */\nexport class GLRenderStates {\n  private _gl: WebGLRenderingContext;\n  private _parameters = {};\n  /**\n   * @param {WebGLRenderingContext} gl\n   */\n  constructor(gl: WebGLRenderingContext) {\n    this._gl = gl;\n    this._parameters = {}; // current gl state parameters\n\n    /** cache */\n    this._parameters[gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n    this._parameters[gl.MAX_VERTEX_UNIFORM_VECTORS] = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n    this._parameters[gl.MAX_VERTEX_ATTRIBS] = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n    this._parameters[gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n    this._parameters[gl.MAX_TEXTURE_SIZE] = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n\n    // init blend state same as BlendState default value.\n    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);\n    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n    gl.colorMask(true, true, true, true);\n    gl.blendColor(0, 0, 0, 0);\n    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n\n    // init depth state same as DepthState default value.\n    gl.enable(gl.DEPTH_TEST);\n    gl.depthFunc(gl.LESS);\n    gl.depthMask(true);\n\n    // init stencil state same as StencilState default value.\n    gl.disable(gl.STENCIL_TEST);\n    gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 0, 0xff);\n    gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 0, 0xff);\n    gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);\n    gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);\n    gl.stencilMask(0xff);\n\n    // init raster state same as RasterState default value.\n    gl.enable(gl.CULL_FACE);\n    gl.cullFace(gl.BACK);\n    gl.disable(gl.POLYGON_OFFSET_FILL);\n    gl.polygonOffset(0, 0);\n  }\n\n  /**\n   * Get a parameter.\n   */\n  getParameter(pname) {\n    return this._parameters[pname];\n  }\n}\n", "import {\n  GLCapabilityType,\n  IPlatformRenderTarget,\n  Logger,\n  RenderBufferDepthFormat,\n  RenderColorTexture,\n  RenderDepthTexture,\n  RenderTarget,\n  TextureCubeFace\n} from \"@oasis-engine/core\";\nimport { GLRenderColorTexture } from \"./GLRenderColorTexture\";\nimport { GLRenderDepthTexture } from \"./GLRenderDepthTexture\";\nimport { GLTexture } from \"./GLTexture\";\nimport { WebGLRenderer } from \"./WebGLRenderer\";\n\n/**\n * The render target in WebGL platform is used for off-screen rendering.\n */\nexport class GLRenderTarget implements IPlatformRenderTarget {\n  private _gl: WebGLRenderingContext & WebGL2RenderingContext;\n  private _isWebGL2: boolean;\n  private _target: RenderTarget;\n  private _frameBuffer: WebGLFramebuffer;\n  private _MSAAFrameBuffer: WebGLFramebuffer | null;\n  private _depthRenderBuffer: WebGLRenderbuffer | null;\n  private _MSAAColorRenderBuffers: WebGLRenderbuffer[] = [];\n  private _MSAADepthRenderBuffer: WebGLRenderbuffer | null;\n  private _oriDrawBuffers: GLenum[];\n  private _blitDrawBuffers: GLenum[] | null;\n\n  /**\n   * Create render target in WebGL platform.\n   */\n  constructor(rhi: WebGLRenderer, target: RenderTarget) {\n    this._gl = rhi.gl as WebGLRenderingContext & WebGL2RenderingContext;\n    this._isWebGL2 = rhi.isWebGL2;\n    this._target = target;\n\n    /** @ts-ignore */\n    const { _colorTextures, _depth, width, height } = target;\n\n    /** todo\n     * MRT + Cube + [,MSAA]\n     * MRT + MSAA\n     */\n\n    if (!(_depth instanceof RenderDepthTexture) && !GLTexture._supportRenderBufferDepthFormat(_depth, rhi, false)) {\n      throw new Error(`RenderBufferDepthFormat is not supported:${RenderBufferDepthFormat[_depth]}`);\n    }\n\n    if (_colorTextures.length > 1 && !rhi.canIUse(GLCapabilityType.drawBuffers)) {\n      throw new Error(\"MRT is not supported\");\n    }\n\n    if (_colorTextures.some((v: RenderColorTexture) => v.width !== width || v.height !== height)) {\n      throw new Error(\"RenderColorTexture's size must as same as RenderTarget\");\n    }\n\n    if (_depth instanceof RenderDepthTexture && (_depth.width !== width || _depth.height !== height)) {\n      throw new Error(\"RenderDepthTexture's size must as same as RenderTarget\");\n    }\n\n    // todo: necessary to support MRT + Cube + [,MSAA] ?\n    if (_colorTextures.length > 1 && _colorTextures.some((v: RenderColorTexture) => v.isCube)) {\n      throw new Error(\"MRT+Cube+[,MSAA] is not supported\");\n    }\n\n    const maxAntiAliasing = rhi.capability.maxAntiAliasing;\n    if (target.antiAliasing > maxAntiAliasing) {\n      Logger.warn(`MSAA antiAliasing exceeds the limit and is automatically downgraded to:${maxAntiAliasing}`);\n\n      /** @ts-ignore */\n      target._antiAliasing = maxAntiAliasing;\n    }\n\n    this._frameBuffer = this._gl.createFramebuffer();\n\n    // bind main FBO\n    this._bindMainFBO();\n\n    // bind MSAA FBO\n    if (target.antiAliasing > 1) {\n      this._MSAAFrameBuffer = this._gl.createFramebuffer();\n      this._bindMSAAFBO();\n    }\n  }\n\n  /**\n   * Set which face of the cube texture to render to.\n   * @param faceIndex - Cube texture face\n   */\n  setRenderTargetFace(faceIndex: TextureCubeFace): void {\n    const gl = this._gl;\n    const colorTexture = this._target.getColorTexture(0);\n    const depthTexture = this._target.depthTexture;\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\n\n    // bind render color texture\n    if (colorTexture?.isCube) {\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0,\n        gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\n        /** @ts-ignore */\n        (colorTexture._platformTexture as GLRenderColorTexture)._glTexture,\n        0\n      );\n    }\n\n    // bind depth texture\n    if (depthTexture?.isCube) {\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        /** @ts-ignore */\n        (depthTexture._platformTexture as GLRenderDepthTexture)._formatDetail.attachment,\n        gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\n        /** @ts-ignore */\n        (depthTexture._platformTexture as GLRenderDepthTexture)._glTexture,\n        0\n      );\n    }\n\n    // revert current activated render target\n    this._activeRenderTarget();\n  }\n\n  /**\n   * Blit FBO.\n   */\n  blitRenderTarget(): void {\n    if (!this._MSAAFrameBuffer) return;\n\n    const gl = this._gl;\n    const mask = gl.COLOR_BUFFER_BIT | (this._target.depthTexture ? gl.DEPTH_BUFFER_BIT : 0);\n    const { colorTextureCount, width, height } = this._target;\n\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._MSAAFrameBuffer);\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);\n\n    for (let textureIndex = 0; textureIndex < colorTextureCount; textureIndex++) {\n      const attachment = gl.COLOR_ATTACHMENT0 + textureIndex;\n\n      this._blitDrawBuffers[textureIndex] = attachment;\n\n      gl.readBuffer(attachment);\n      gl.drawBuffers(this._blitDrawBuffers);\n      gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);\n\n      this._blitDrawBuffers[textureIndex] = gl.NONE;\n    }\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  }\n\n  /**\n   * Destroy render target.\n   */\n  destroy(): void {\n    const gl = this._gl;\n\n    this._frameBuffer && gl.deleteFramebuffer(this._frameBuffer);\n    this._depthRenderBuffer && gl.deleteRenderbuffer(this._depthRenderBuffer);\n    this._MSAAFrameBuffer && gl.deleteFramebuffer(this._MSAAFrameBuffer);\n    this._MSAADepthRenderBuffer && gl.deleteRenderbuffer(this._MSAADepthRenderBuffer);\n\n    for (let i = 0; i < this._MSAAColorRenderBuffers.length; i++) {\n      gl.deleteRenderbuffer(this._MSAAColorRenderBuffers[i]);\n    }\n\n    this._frameBuffer = null;\n    this._depthRenderBuffer = null;\n    this._MSAAFrameBuffer = null;\n    this._MSAAColorRenderBuffers.length = 0;\n    this._MSAADepthRenderBuffer = null;\n  }\n\n  /**\n   * Activate this RenderTarget.\n   * @internal\n   * @remarks\n   * If MSAA is turned on, MSAA FBO is activated, and then this._blitRenderTarget() is performed to exchange FBO.\n   * If MSAA is not turned on, activate the main FBO.\n   */\n  _activeRenderTarget(): void {\n    const gl = this._gl;\n\n    if (this._MSAAFrameBuffer) {\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);\n    } else {\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\n    }\n  }\n\n  private _bindMainFBO(): void {\n    const gl = this._gl;\n    const isWebGL2: boolean = this._isWebGL2;\n\n    /** @ts-ignore */\n    const { _depth, colorTextureCount, width, height } = this._target;\n    const drawBuffers = new Array(colorTextureCount);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\n\n    /** color render buffer */\n    for (let i = 0; i < colorTextureCount; i++) {\n      const colorTexture = this._target.getColorTexture(i);\n      const attachment = gl.COLOR_ATTACHMENT0 + i;\n\n      drawBuffers[i] = attachment;\n\n      // Cube texture please call _setRenderTargetFace()\n      if (!colorTexture.isCube) {\n        gl.framebufferTexture2D(\n          gl.FRAMEBUFFER,\n          attachment,\n          gl.TEXTURE_2D,\n          /** @ts-ignore */\n          (colorTexture._platformTexture as GLRenderColorTexture)._glTexture,\n          0\n        );\n      }\n    }\n\n    if (colorTextureCount > 1) {\n      gl.drawBuffers(drawBuffers);\n    }\n    this._oriDrawBuffers = drawBuffers;\n\n    /** depth render buffer */\n    if (_depth !== null) {\n      if (_depth instanceof RenderDepthTexture) {\n        // Cube texture please call _setRenderTargetFace()\n        if (!_depth.isCube) {\n          gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            /** @ts-ignore */\n            (_depth._platformTexture as GLRenderDepthTexture)._formatDetail.attachment,\n            gl.TEXTURE_2D,\n            /** @ts-ignore */\n            (_depth._platformTexture as GLRenderDepthTexture)._glTexture,\n            0\n          );\n        }\n      } else if (this._target.antiAliasing <= 1) {\n        const { internalFormat, attachment } = GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2);\n        const depthRenderBuffer = gl.createRenderbuffer();\n\n        this._depthRenderBuffer = depthRenderBuffer;\n\n        gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);\n        gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, depthRenderBuffer);\n      }\n    }\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n  }\n\n  private _bindMSAAFBO(): void {\n    const gl = this._gl;\n    const isWebGL2 = this._isWebGL2;\n    const MSAADepthRenderBuffer = gl.createRenderbuffer();\n\n    /** @ts-ignore */\n    const { _depth, colorTextureCount, antiAliasing, width, height } = this._target;\n\n    this._blitDrawBuffers = new Array(colorTextureCount);\n    this._MSAADepthRenderBuffer = MSAADepthRenderBuffer;\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);\n\n    // prepare MRT+MSAA color RBOs\n    for (let i = 0; i < colorTextureCount; i++) {\n      const MSAAColorRenderBuffer = gl.createRenderbuffer();\n\n      this._MSAAColorRenderBuffers[i] = MSAAColorRenderBuffer;\n      this._blitDrawBuffers[i] = gl.NONE;\n\n      gl.bindRenderbuffer(gl.RENDERBUFFER, MSAAColorRenderBuffer);\n      gl.renderbufferStorageMultisample(\n        gl.RENDERBUFFER,\n        antiAliasing,\n        /** @ts-ignore */\n        (this._target.getColorTexture(i)._platformTexture as GLRenderColorTexture)._formatDetail.internalFormat,\n        width,\n        height\n      );\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, MSAAColorRenderBuffer);\n    }\n    gl.drawBuffers(this._oriDrawBuffers);\n\n    // prepare MSAA depth RBO\n    if (_depth !== null) {\n      const { internalFormat, attachment } =\n        _depth instanceof RenderDepthTexture\n          ? /** @ts-ignore */\n            (_depth._platformTexture as GLRenderDepthTexture)._formatDetail\n          : GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2);\n\n      gl.bindRenderbuffer(gl.RENDERBUFFER, MSAADepthRenderBuffer);\n      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, antiAliasing, internalFormat, width, height);\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, MSAADepthRenderBuffer);\n    }\n\n    this._checkFrameBuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n  }\n\n  private _checkFrameBuffer(): void {\n    const gl = this._gl;\n    const isWebGL2 = this._isWebGL2;\n    const e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\n    switch (e) {\n      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n        throw new Error(\n          \"The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete\"\n        );\n      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n        throw new Error(\"There is no attachment\");\n      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n        throw new Error(\" Height and width of the attachment are not the same.\");\n      case gl.FRAMEBUFFER_UNSUPPORTED:\n        throw new Error(\n          \"The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer\"\n        );\n    }\n\n    if (isWebGL2 && e === gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {\n      throw new Error(\n        \"The values of gl.RENDERBUFFER_SAMPLES are different among attached renderbuffers, or are non-zero if the attached images are a mix of renderbuffers and textures.\"\n      );\n    }\n  }\n}\n", "import { IPlatformTexture2D, Logger, Texture2D, TextureFormat } from \"@oasis-engine/core\";\nimport { GLTexture } from \"./GLTexture\";\nimport { WebGLRenderer } from \"./WebGLRenderer\";\n\n/**\n * Texture 2d in WebGL platform.\n */\nexport class GLTexture2D extends GLTexture implements IPlatformTexture2D {\n  /**\n   * Backward compatible with WebGL1.0.\n   */\n  private _compressedMipFilled: number = 0;\n\n  /**\n   * Create texture2D in WebGL platform.\n   */\n  constructor(rhi: WebGLRenderer, texture2D: Texture2D) {\n    super(rhi, texture2D, rhi.gl.TEXTURE_2D);\n\n    /** @ts-ignore */\n    const { format, _mipmap, width, height } = texture2D;\n    const isWebGL2 = this._isWebGL2;\n\n    if (!GLTexture._supportTextureFormat(format, rhi)) {\n      throw new Error(`Texture format is not supported:${TextureFormat[format]}`);\n    }\n\n    if (_mipmap && !isWebGL2 && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {\n      Logger.warn(\n        \"non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap\"\n      );\n\n      /** @ts-ignore */\n      texture2D._mipmap = false;\n      /** @ts-ignore */\n      texture2D._mipmapCount = texture2D._getMipmapCount();\n    }\n\n    this._formatDetail = GLTexture._getFormatDetail(format, this._gl, isWebGL2);\n    (this._formatDetail.isCompressed && !isWebGL2) || this._initMipmap(false);\n  }\n\n  /**\n   * Setting pixels data through color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.\n   * @remarks If it is the WebGL1.0 platform and the texture format is compressed, the first upload must be filled with textures.\n   * @param colorBuffer - Color buffer data\n   * @param mipLevel - Texture mipmapping level\n   * @param x - X coordinate of area start\n   * @param y - Y coordinate of area start\n   * @param width - Data width. if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)\n   * @param height - Data height. if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)\n   */\n  setPixelBuffer(\n    colorBuffer: ArrayBufferView,\n    mipLevel: number = 0,\n    x?: number,\n    y?: number,\n    width?: number,\n    height?: number\n  ): void {\n    const gl = this._gl;\n    const isWebGL2: boolean = this._isWebGL2;\n    const { internalFormat, baseFormat, dataType, isCompressed } = this._formatDetail;\n    const mipWidth = Math.max(1, this._texture.width >> mipLevel);\n    const mipHeight = Math.max(1, this._texture.height >> mipLevel);\n\n    x = x || 0;\n    y = y || 0;\n    width = width || mipWidth - x;\n    height = height || mipHeight - y;\n\n    this._bind();\n\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\n\n    if (isCompressed) {\n      const mipBit = 1 << mipLevel;\n      if (isWebGL2 || this._compressedMipFilled & mipBit) {\n        gl.compressedTexSubImage2D(this._target, mipLevel, x, y, width, height, internalFormat, colorBuffer);\n      } else {\n        gl.compressedTexImage2D(this._target, mipLevel, internalFormat, width, height, 0, colorBuffer);\n        this._compressedMipFilled |= mipBit;\n      }\n    } else {\n      gl.texSubImage2D(this._target, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);\n    }\n  }\n\n  /**\n   * Setting pixels data through TexImageSource, designated area and texture mipmapping level.\n   * @param imageSource - The source of texture\n   * @param mipLevel - Texture mipmapping level\n   * @param flipY - Whether to flip the Y axis\n   * @param premultiplyAlpha - Whether to premultiply the transparent channel\n   * @param x - X coordinate of area start\n   * @param y - Y coordinate of area start\n   */\n  setImageSource(\n    imageSource: TexImageSource,\n    mipLevel: number = 0,\n    flipY: boolean = false,\n    premultiplyAlpha: boolean = false,\n    x?: number,\n    y?: number\n  ): void {\n    const gl = this._gl;\n    const { baseFormat, dataType } = this._formatDetail;\n\n    this._bind();\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);\n    gl.texSubImage2D(this._target, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);\n  }\n\n  /**\n   * Get the pixel color buffer according to the specified area.\n   * @param x - X coordinate of area start\n   * @param y - Y coordinate of area start\n   * @param width - Area width\n   * @param height - Area height\n   * @param out - Color buffer\n   */\n  getPixelBuffer(x: number, y: number, width: number, height: number, out: ArrayBufferView): void {\n    if (this._formatDetail.isCompressed) {\n      throw new Error(\"Unable to read compressed texture\");\n    }\n    super._getPixelBuffer(null, x, y, width, height, out);\n  }\n}\n", "import { IPlatformTextureCubeMap, Logger, TextureCubeFace, TextureCubeMap, TextureFormat } from \"@oasis-engine/core\";\nimport { GLTexture } from \"./GLTexture\";\nimport { WebGLRenderer } from \"./WebGLRenderer\";\n\n/**\n * Cube texture in WebGL platform.\n */\nexport class GLTextureCubeMap extends GLTexture implements IPlatformTextureCubeMap {\n  /**\n   * Backward compatible with WebGL1.0.\u3002\n   */\n  private _compressedFaceFilled: number[] = [0, 0, 0, 0, 0, 0];\n\n  /**\n   * Create cube texture in WebGL platform.\n   */\n  constructor(rhi: WebGLRenderer, textureCube: TextureCubeMap) {\n    super(rhi, textureCube, rhi.gl.TEXTURE_CUBE_MAP);\n\n    /** @ts-ignore */\n    const { format, _mipmap, width: size } = textureCube;\n    const isWebGL2 = this._isWebGL2;\n\n    if (!GLTexture._supportTextureFormat(format, rhi)) {\n      throw new Error(`Texture format is not supported:${TextureFormat[format]}`);\n    }\n\n    if (_mipmap && !isWebGL2 && !GLTexture._isPowerOf2(size)) {\n      Logger.warn(\n        \"non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap\"\n      );\n\n      /** @ts-ignore */\n      textureCube._mipmap = false;\n      /** @ts-ignore */\n      textureCube._mipmapCount = textureCube._getMipmapCount();\n    }\n\n    this._formatDetail = GLTexture._getFormatDetail(format, this._gl, isWebGL2);\n    (this._formatDetail.isCompressed && !isWebGL2) || this._initMipmap(true);\n  }\n\n  /**\n   * Setting pixels data through cube face,color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.\n   * @remarks When compressed texture is in WebGL1, the texture must be filled first before writing the sub-region\n   * @param face - Cube face\n   * @param colorBuffer - Color buffer data\n   * @param mipLevel - Texture mipmapping level\n   * @param x - X coordinate of area start\n   * @param y -  Y coordinate of area start\n   * @param width - Data width.if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)\n   * @param height - Data height.if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)\n   */\n  setPixelBuffer(\n    face: TextureCubeFace,\n    colorBuffer: ArrayBufferView,\n    mipLevel: number = 0,\n    x?: number,\n    y?: number,\n    width?: number,\n    height?: number\n  ): void {\n    const gl = this._gl;\n    const isWebGL2 = this._isWebGL2;\n    const { internalFormat, baseFormat, dataType, isCompressed } = this._formatDetail;\n    const mipSize = Math.max(1, this._texture.width >> mipLevel);\n\n    x = x || 0;\n    y = y || 0;\n    width = width || mipSize - x;\n    height = height || mipSize - y;\n\n    this._bind();\n\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\n\n    if (isCompressed) {\n      const mipBit = 1 << mipLevel;\n      if (isWebGL2 || this._compressedFaceFilled[face] & mipBit) {\n        gl.compressedTexSubImage2D(\n          gl.TEXTURE_CUBE_MAP_POSITIVE_X + face,\n          mipLevel,\n          x,\n          y,\n          width,\n          height,\n          internalFormat,\n          colorBuffer\n        );\n      } else {\n        gl.compressedTexImage2D(\n          gl.TEXTURE_CUBE_MAP_POSITIVE_X + face,\n          mipLevel,\n          internalFormat,\n          width,\n          height,\n          0,\n          colorBuffer\n        );\n        this._compressedFaceFilled[face] |= mipBit;\n      }\n    } else {\n      gl.texSubImage2D(\n        gl.TEXTURE_CUBE_MAP_POSITIVE_X + face,\n        mipLevel,\n        x,\n        y,\n        width,\n        height,\n        baseFormat,\n        dataType,\n        colorBuffer\n      );\n    }\n  }\n\n  /**\n   * Setting pixels data through cube face, TexImageSource, designated area and texture mipmapping level.\n   * @param face - Cube face\n   * @param imageSource - The source of texture\n   * @param mipLevel - Texture mipmapping level\n   * @param flipY - Whether to flip the Y axis\n   * @param premultiplyAlpha - Whether to premultiply the transparent channel\n   * @param x - X coordinate of area start\n   * @param y - Y coordinate of area start\n   */\n  setImageSource(\n    face: TextureCubeFace,\n    imageSource: TexImageSource,\n    mipLevel: number = 0,\n    flipY: boolean = false,\n    premultiplyAlpha: boolean = false,\n    x?: number,\n    y?: number\n  ): void {\n    const gl = this._gl;\n    const { baseFormat, dataType } = this._formatDetail;\n\n    this._bind();\n\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);\n    gl.texSubImage2D(\n      gl.TEXTURE_CUBE_MAP_POSITIVE_X + face,\n      mipLevel,\n      x || 0,\n      y || 0,\n      baseFormat,\n      dataType,\n      imageSource\n    );\n  }\n\n  /**\n   * Get the pixel color buffer according to the specified cube face and area.\n   * @param face - You can choose which cube face to read\n   * @param x - X coordinate of area start\n   * @param y - Y coordinate of area start\n   * @param width - Area width\n   * @param height - Area height\n   * @param out - Color buffer\n   */\n  getPixelBuffer(\n    face: TextureCubeFace,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    out: ArrayBufferView\n  ): void {\n    if (this._formatDetail.isCompressed) {\n      throw new Error(\"Unable to read compressed texture\");\n    }\n    super._getPixelBuffer(face, x, y, width, height, out);\n  }\n}\n", "import {\n  Camera,\n  Canvas,\n  ColorWriteMask,\n  Engine,\n  GLCapabilityType,\n  IHardwareRenderer,\n  IPlatformRenderColorTexture,\n  IPlatformRenderDepthTexture,\n  IPlatformRenderTarget,\n  IPlatformTexture2D,\n  IPlatformTextureCubeMap,\n  Logger,\n  Mesh,\n  RenderColorTexture,\n  RenderDepthTexture,\n  RenderTarget,\n  SubMesh,\n  Texture2D,\n  TextureCubeMap\n} from \"@oasis-engine/core\";\nimport { CameraClearFlags } from \"@oasis-engine/core\";\nimport { IPlatformPrimitive } from \"@oasis-engine/design\";\nimport { Color, Vector4 } from \"@oasis-engine/math\";\nimport { GLCapability } from \"./GLCapability\";\nimport { GLExtensions } from \"./GLExtensions\";\nimport { GLPrimitive } from \"./GLPrimitive\";\nimport { GLRenderColorTexture } from \"./GLRenderColorTexture\";\nimport { GLRenderDepthTexture } from \"./GLRenderDepthTexture\";\nimport { GLRenderStates } from \"./GLRenderStates\";\nimport { GLRenderTarget } from \"./GLRenderTarget\";\nimport { GLTexture } from \"./GLTexture\";\nimport { GLTexture2D } from \"./GLTexture2D\";\nimport { GLTextureCubeMap } from \"./GLTextureCubeMap\";\nimport { WebGLExtension } from \"./type\";\nimport { WebCanvas } from \"./WebCanvas\";\n\n/**\n * WebGL mode.\n */\nexport enum WebGLMode {\n  /** Auto, use WebGL2.0 if support, or will fallback to WebGL1.0. */\n  Auto = 0,\n  /** WebGL2.0. */\n  WebGL2 = 1,\n  /** WebGL1.0, */\n  WebGL1 = 2\n}\n\n/**\n * WebGL renderer options.\n */\nexport interface WebGLRendererOptions extends WebGLContextAttributes {\n  /** WebGL mode.*/\n  webGLMode?: WebGLMode;\n}\n\n/**\n * WebGL renderer, including WebGL1.0 and WebGL2.0.\n */\nexport class WebGLRenderer implements IHardwareRenderer {\n  _currentBind: any;\n\n  private _options: WebGLRendererOptions;\n  private _gl: (WebGLRenderingContext & WebGLExtension) | WebGL2RenderingContext;\n  private _renderStates;\n  private _extensions;\n  private _capability: GLCapability;\n  private _isWebGL2: boolean;\n\n  private _activeTextureID: number;\n  private _activeTextures: GLTexture[] = new Array(32);\n\n  // cache value\n  private _lastViewport: Vector4 = new Vector4(null, null, null, null);\n  private _lastClearColor: Color = new Color(null, null, null, null);\n\n  get isWebGL2() {\n    return this._isWebGL2;\n  }\n\n  /**\n   * GL Context\n   * @member {WebGLRenderingContext}\n   */\n  get gl() {\n    return this._gl;\n  }\n\n  get renderStates(): GLRenderStates {\n    return this._renderStates;\n  }\n\n  get capability(): GLCapability {\n    return this._capability;\n  }\n\n  get canIUseMoreJoints() {\n    return this.capability.canIUseMoreJoints;\n  }\n\n  constructor(options: WebGLRendererOptions = {}) {\n    this._options = options;\n  }\n\n  init(canvas: Canvas) {\n    const option = this._options;\n    option.alpha === undefined && (option.alpha = false);\n    option.stencil === undefined && (option.stencil = true);\n\n    const webCanvas = (canvas as WebCanvas)._webCanvas;\n    const webGLMode = option.webGLMode || WebGLMode.Auto;\n    let gl: (WebGLRenderingContext & WebGLExtension) | WebGL2RenderingContext;\n\n    if (webGLMode == WebGLMode.Auto || webGLMode == WebGLMode.WebGL2) {\n      gl = webCanvas.getContext(\"webgl2\", option);\n      if (!gl && webCanvas instanceof HTMLCanvasElement) {\n        gl = <WebGL2RenderingContext>webCanvas.getContext(\"experimental-webgl2\", option);\n      }\n      this._isWebGL2 = true;\n\n      // Prevent weird browsers to lie (such as safari!)\n      if (gl && !(<WebGL2RenderingContext>gl).deleteQuery) {\n        this._isWebGL2 = false;\n      }\n    }\n\n    if (!gl) {\n      if (webGLMode == WebGLMode.Auto || webGLMode == WebGLMode.WebGL1) {\n        gl = <WebGLRenderingContext & WebGLExtension>webCanvas.getContext(\"webgl\", option);\n        if (!gl && webCanvas instanceof HTMLCanvasElement) {\n          gl = <WebGLRenderingContext & WebGLExtension>webCanvas.getContext(\"experimental-webgl\", option);\n        }\n        this._isWebGL2 = false;\n      }\n    }\n\n    if (!gl) {\n      throw new Error(\"Get GL Context FAILED.\");\n    }\n\n    this._gl = gl;\n    this._activeTextureID = gl.TEXTURE0;\n    this._renderStates = new GLRenderStates(gl);\n    this._extensions = new GLExtensions(this);\n    this._capability = new GLCapability(this);\n    // Make sure the active texture in gl context is on default, because gl context may be used in other webgl renderer.\n    gl.activeTexture(gl.TEXTURE0);\n\n    this._options = null;\n  }\n\n  createPlatformPrimitive(primitive: Mesh): IPlatformPrimitive {\n    return new GLPrimitive(this, primitive);\n  }\n\n  createPlatformTexture2D(texture2D: Texture2D): IPlatformTexture2D {\n    return new GLTexture2D(this, texture2D);\n  }\n\n  createPlatformTextureCubeMap(textureCube: TextureCubeMap): IPlatformTextureCubeMap {\n    return new GLTextureCubeMap(this, textureCube);\n  }\n\n  createPlatformRenderColorTexture(texture: RenderColorTexture): IPlatformRenderColorTexture {\n    return new GLRenderColorTexture(this, texture);\n  }\n\n  createPlatformRenderDepthTexture(texture: RenderDepthTexture): IPlatformRenderDepthTexture {\n    return new GLRenderDepthTexture(this, texture);\n  }\n\n  createPlatformRenderTarget(target: RenderTarget): IPlatformRenderTarget {\n    return new GLRenderTarget(this, target);\n  }\n\n  requireExtension(ext) {\n    return this._extensions.requireExtension(ext);\n  }\n\n  canIUse(capabilityType: GLCapabilityType) {\n    return this.capability.canIUse(capabilityType);\n  }\n\n  canIUseCompressedTextureInternalFormat(type: number) {\n    return this.capability.canIUseCompressedTextureInternalFormat(type);\n  }\n\n  viewport(x: number, y: number, width: number, height: number): void {\n    // gl.enable(gl.SCISSOR_TEST);\n    // gl.scissor(x, transformY, width, height);\n    const gl = this._gl;\n    const lv = this._lastViewport;\n\n    if (x !== lv.x || y !== lv.y || width !== lv.z || height !== lv.w) {\n      gl.viewport(x, y, width, height);\n      lv.setValue(x, y, width, height);\n    }\n  }\n\n  colorMask(r, g, b, a) {\n    this._gl.colorMask(r, g, b, a);\n  }\n\n  clearRenderTarget(\n    engine: Engine,\n    clearFlags: CameraClearFlags.Depth | CameraClearFlags.DepthColor,\n    clearColor: Color\n  ) {\n    const gl = this._gl;\n    const {\n      blendState: { targetBlendState },\n      depthState,\n      stencilState\n    } = engine._lastRenderState;\n\n    let clearFlag = gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT;\n\n    if (clearFlags === CameraClearFlags.DepthColor) {\n      clearFlag |= gl.COLOR_BUFFER_BIT;\n\n      const lc = this._lastClearColor;\n      const { r, g, b, a } = clearColor;\n\n      if (clearColor && (r !== lc.r || g !== lc.g || b !== lc.b || a !== lc.a)) {\n        gl.clearColor(r, g, b, a);\n        lc.setValue(r, g, b, a);\n      }\n\n      if (targetBlendState.colorWriteMask !== ColorWriteMask.All) {\n        gl.colorMask(true, true, true, true);\n        targetBlendState.colorWriteMask = ColorWriteMask.All;\n      }\n    }\n\n    if (depthState.writeEnabled !== true) {\n      gl.depthMask(true);\n      depthState.writeEnabled = true;\n    }\n\n    if (stencilState.writeMask !== 0xff) {\n      gl.stencilMask(0xff);\n      stencilState.writeMask = 0xff;\n    }\n\n    gl.clear(clearFlag);\n  }\n\n  drawPrimitive(primitive: Mesh, subPrimitive: SubMesh, shaderProgram: any) {\n    // todo: VAO not support morph animation\n    if (primitive) {\n      //@ts-ignore\n      primitive._draw(shaderProgram, subPrimitive);\n    } else {\n      Logger.error(\"draw primitive failed.\");\n    }\n  }\n\n  activeRenderTarget(renderTarget: RenderTarget, camera: Camera) {\n    const gl = this._gl;\n    if (renderTarget) {\n      /** @ts-ignore */\n      (renderTarget._platformRenderTarget as GLRenderTarget)?._activeRenderTarget();\n      const { width, height } = renderTarget;\n      this.viewport(0, 0, width, height);\n    } else {\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      const viewport = camera.viewport;\n      const { drawingBufferWidth, drawingBufferHeight } = gl;\n      const width = drawingBufferWidth * viewport.z;\n      const height = drawingBufferHeight * viewport.w;\n      const x = viewport.x * drawingBufferWidth;\n      const y = drawingBufferHeight - viewport.y * drawingBufferHeight - height;\n      this.viewport(x, y, width, height);\n    }\n  }\n\n  destroy() {}\n\n  activeTexture(textureID: number): void {\n    if (this._activeTextureID !== textureID) {\n      this._gl.activeTexture(textureID);\n      this._activeTextureID = textureID;\n    }\n  }\n\n  bindTexture(texture: GLTexture): void {\n    const index = this._activeTextureID - this._gl.TEXTURE0;\n    if (this._activeTextures[index] !== texture) {\n      this._gl.bindTexture(texture._target, texture._glTexture);\n      this._activeTextures[index] = texture;\n    }\n  }\n}\n", "import { Engine } from \"@oasis-engine/core\";\nimport { WebCanvas } from \"./WebCanvas\";\nimport { WebGLRenderer, WebGLRendererOptions } from \"./WebGLRenderer\";\n\n/**\n * WebGL platform engine,support includes WebGL1.0 and WebGL2.0.\n */\nexport class WebGLEngine extends Engine {\n  /**\n   * Create an engine suitable for the WebGL platform.\n   * @param canvas - Native web canvas\n   * @param webGLRendererOptions - WebGL renderer options\n   */\n  constructor(canvas: string | HTMLCanvasElement | OffscreenCanvas, webGLRendererOptions?: WebGLRendererOptions) {\n    const webCanvas = new WebCanvas(\n      <HTMLCanvasElement | OffscreenCanvas>(typeof canvas === \"string\" ? document.getElementById(canvas) : canvas)\n    );\n    const hardwareRenderer = new WebGLRenderer(webGLRendererOptions);\n\n    super(webCanvas, hardwareRenderer);\n  }\n\n  /**\n   * Web canvas.\n   */\n  get canvas(): WebCanvas {\n    return this._canvas as WebCanvas;\n  }\n}\n", "import { Logger } from \"@oasis-engine/core\";\n\nexport class DRACOWorker {\n  // Worker instance.\n  private _worker: Worker;\n  // Record byteLength of each task.\n  private _costs: { [taskId: number]: number } = {};\n  // The sum of bytelength that the worker is currently dealing with, in order to sort the workers.\n  private _currentLoad: number = 0;\n  private _callbacks: { [taskId: number]: IResolveReject } = {};\n  get currentLoad(): number {\n    return this._currentLoad;\n  }\n\n  constructor(workerSourceURL: string, decoderWASMBinary?: ArrayBuffer) {\n    this._worker = new Worker(workerSourceURL);\n    this._worker.onmessage = (e) => {\n      const message = e.data;\n      switch (message.type) {\n        case \"decode\":\n          this._callbacks[message.id].resolve(message.geometry);\n          break;\n\n        case \"error\":\n          this._callbacks[message.id].reject(message);\n          break;\n        default:\n          Logger.error('DRACOWorker: Unexpected message, \"' + message.type + '\"');\n      }\n    };\n    if (decoderWASMBinary) {\n      this._worker.postMessage({ type: \"init\", decoderConfig: { wasmBinary: decoderWASMBinary } });\n    } else {\n      this._worker.postMessage({ type: \"init\", decoderConfig: {} });\n    }\n  }\n\n  setCosts(taskId: number, cost: number) {\n    this._costs[taskId] = cost;\n  }\n\n  addCurrentLoad(cost: number) {\n    this._currentLoad += cost;\n  }\n\n  setCallback(taskId: number, resolve: (any) => void, reject: (any) => void) {\n    this._callbacks[taskId] = { resolve, reject };\n  }\n\n  decode(taskId: number, taskConfig: ITaskConfig, buffer: ArrayBuffer) {\n    this._worker.postMessage({ type: \"decode\", id: taskId, taskConfig, buffer }, [buffer]);\n  }\n\n  releaseTask(taskId: number) {\n    this._currentLoad -= this._costs[taskId];\n    delete this._callbacks[taskId];\n    delete this._costs[taskId];\n  }\n}\n\ninterface IResolveReject {\n  resolve: (any) => void;\n  reject: (any) => void;\n}\n\nexport interface ITaskConfig {\n  attributeIDs: { [attribute: string]: number };\n  attributeTypes: { [attribute: string]: string };\n  useUniqueIDs: boolean;\n  indexType: string;\n}\n", "export default `let decoderPending;\nlet decoderConfig;\n\nonmessage = function(e) {\n  const message = e.data;\n\n  switch (message.type) {\n    case \"init\":\n      decoderConfig = message.decoderConfig;\n      decoderPending = new Promise(function(resolve /*, reject*/) {\n        decoderConfig.onModuleLoaded = function(draco) {\n          // Module is Promise-like. Wrap before resolving to avoid loop.\n          resolve({ draco: draco });\n        };\n        DracoDecoderModule(decoderConfig);\n      });\n      break;\n\n    case \"decode\":\n      const buffer = message.buffer;\n      const taskConfig = message.taskConfig;\n      decoderPending.then(module => {\n        const draco = module.draco;\n        const decoder = new draco.Decoder();\n        const decoderBuffer = new draco.DecoderBuffer();\n        decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n        try {\n          const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n          const buffers = geometry.attributes.map(attr => attr.array.buffer);\n          if (geometry.index) buffers.push(geometry.index.array.buffer);\n          self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n        } catch (error) {\n          console.error(error);\n          self.postMessage({ type: \"error\", id: message.id, error: error.message });\n        } finally {\n          draco.destroy(decoderBuffer);\n          draco.destroy(decoder);\n        }\n      });\n      break;\n  }\n};\n\nfunction decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n  const attributeIDs = taskConfig.attributeIDs;\n  const attributeTypes = taskConfig.attributeTypes;\n\n  let dracoGeometry;\n  let decodingStatus;\n\n  const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    dracoGeometry = new draco.Mesh();\n    decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n  } else {\n    throw new Error(\"DRACODecoder worker: Unexpected geometry type.\");\n  }\n\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new Error(\"DRACODecoder worker: Decoding failed: \" + decodingStatus.error_msg());\n  }\n\n  const geometry = { index: null, attributes: [] };\n\n  // Gather all vertex attributes.\n  for (let attributeName in attributeIDs) {\n    const attributeType = self[attributeTypes[attributeName]];\n\n    let attribute;\n    let attributeID;\n\n    // A Draco file may be created with default vertex attributes, whose attribute IDs\n    // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n    // a Draco file may contain a custom set of attributes, identified by known unique\n    // IDs. glTF files always do the latter, and .drc files typically do the former.\n    if (taskConfig.useUniqueIDs) {\n      attributeID = attributeIDs[attributeName];\n      attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n    } else {\n      attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n      if (attributeID === -1) continue;\n      attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n    }\n    geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n  }\n  // Add index.\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    // Generate mesh faces.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    let dataSize;\n    let ptr;\n    let index;\n    const indexType = self[taskConfig.indexType];\n\n    switch (indexType) {\n      case Uint16Array:\n        dataSize = numIndices * 2;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt16Array(dracoGeometry, dataSize, ptr);\n        index = new Uint16Array(draco.HEAPU16.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      case Uint32Array:\n        dataSize = numIndices * 4;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, dataSize, ptr);\n        index = new Uint32Array(draco.HEAPU32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      default:\n        throw new Error(\"DRACODecoder: Unexpected index type.\");\n    }\n    geometry.index = { array: index, itemSize: 1 };\n  }\n  draco.destroy(dracoGeometry);\n  return geometry;\n}\n\nfunction decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n  const numComponents = attribute.num_components();\n  const numPoints = dracoGeometry.num_points();\n  const numValues = numPoints * numComponents;\n  let ptr;\n  let array;\n  let dataSize;\n  switch (attributeType) {\n    case Float32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr);\n      array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT8, numValues, ptr);\n      array = new Int8Array(draco.HEAP8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr);\n      array = new Int16Array(draco.HEAP16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr);\n      array = new Int32Array(draco.HEAP32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr);\n      array = new Uint8Array(draco.HEAPU8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr);\n      array = new Uint16Array(draco.HEAPU16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr);\n      array = new Uint32Array(draco.HEAPU32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    default:\n      throw new Error(\"DRACODecoder: Unexpected attribute type.\");\n  }\n\n  return {\n    name: attributeName,\n    array: array,\n    itemSize: numComponents\n  };\n}\n`;", "import { Logger, request } from \"@oasis-engine/core\";\n\nimport { DRACOWorker, ITaskConfig } from \"./DRACOWorker\";\n\nimport workerString from \"./worker/worker.js\";\n\nconst LIB_PATH = \"https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/\";\nconst JS_FILE = \"draco_decoder_gltf.js\";\n\nconst WASM_FILE = \"draco_decoder_gltf.r3bin\";\nconst WASM_WRAPPER_FILE = \"draco_wasm_wrapper_gltf.js\";\n\nexport class DRACODecoder {\n  private pool: DRACOWorker[] = [];\n  private workerLimit = Math.min(navigator.hardwareConcurrency || 4, 4);\n  private useJS: boolean;\n  private currentTaskId: number = 1;\n  private taskCache = new WeakMap();\n  private loadLibPromise: Promise<any>;\n\n  constructor(config: IDecoderConfig = { type: \"wasm\", workerLimit: 4 }) {\n    if (config.workerLimit > this.workerLimit) {\n      Logger.warn(\"DRACOWorkerPool: Can not initialize worker pool with limit:\" + config.workerLimit);\n    } else {\n      this.workerLimit = config.workerLimit ?? 4;\n    }\n    this.useJS = typeof WebAssembly !== \"object\" || config.type === \"js\";\n    this.loadLibPromise = this.preloadLib();\n  }\n\n  private preloadLib(): Promise<any> {\n    if (this.loadLibPromise) {\n      return this.loadLibPromise;\n    }\n\n    return new Promise((resolve, reject) => {\n      if (this.useJS) {\n        request(`${LIB_PATH}${JS_FILE}`, { type: \"text\" })\n          .then((jsSource) => {\n            const body = [jsSource, workerString].join(\"\\n\");\n            const workerSourceURL = URL.createObjectURL(new Blob([body]));\n            resolve({ workerSourceURL, decoderWASMBinary: null });\n          })\n          .catch((reason) => {\n            reject(reason);\n          });\n      } else {\n        Promise.all([\n          request(`${LIB_PATH}${WASM_WRAPPER_FILE}`, { type: \"text\" }),\n          request(`${LIB_PATH}${WASM_FILE}`, { type: \"arraybuffer\" })\n        ])\n          .then((resources) => {\n            const [wrapperSource, decoderWASMBinary] = resources;\n            const body = [wrapperSource, workerString].join(\"\\n\");\n            const workerSourceURL = URL.createObjectURL(new Blob([body]));\n            resolve({ workerSourceURL, decoderWASMBinary });\n          })\n          .catch((reason) => {\n            reject(reason);\n          });\n      }\n    });\n  }\n\n  private getWorker(): Promise<DRACOWorker> {\n    return this.preloadLib().then((worderResources) => {\n      if (this.pool.length < this.workerLimit) {\n        const dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);\n        this.pool.push(dracoWorker);\n      } else {\n        this.pool.sort(function (a, b) {\n          return a.currentLoad > b.currentLoad ? -1 : 1;\n        });\n      }\n      return this.pool[this.pool.length - 1];\n    });\n  }\n\n  decode(buffer: ArrayBuffer, taskConfig: ITaskConfig): Promise<any> {\n    const taskKey = JSON.stringify(taskConfig);\n\n    // Check for an existing task using this buffer. A transferred buffer cannot be transferred.\n    // again from this thread.\n    if (this.taskCache.has(buffer)) {\n      const cachedTask = this.taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        // After using transferable to transfer data, the data in the original environment will be cleared, so it is judged that byteLength is 0, which means it has been transferred.\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error(\n          \"DRACODecoder: Unable to re-decode a buffer with different \" +\n            \"settings. Buffer has already been transferred.\"\n        );\n      }\n    }\n\n    const taskId = this.currentTaskId++;\n    const cost = buffer.byteLength;\n    let taskWorker;\n    const task = new Promise((resolve, reject) => {\n      this.getWorker()\n        .then((worker) => {\n          taskWorker = worker;\n          worker.setCosts(taskId, cost);\n          worker.addCurrentLoad(cost);\n\n          worker.setCallback(taskId, resolve, reject);\n          worker.decode(taskId, taskConfig, buffer);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n    task.finally(() => {\n      if (taskWorker && taskId) {\n        taskWorker.releaseTask(taskId);\n      }\n    });\n\n    this.taskCache.set(buffer, {\n      key: taskKey,\n      promise: task\n    });\n    return task;\n  }\n}\n\ninterface IDecoderConfig {\n  type?: \"js\" | \"wasm\";\n  workerLimit?: number;\n}\n", "import { resourceLoader, Loader, AssetPromise, AssetType, LoadItem } from \"@oasis-engine/core\";\n\nfunction isBase64(url) {\n  return /^data:(.+?);base64,/.test(url);\n}\n@resourceLoader(AssetType.Buffer, [\"bin\", \"r3bin\"], false)\nclass BufferLoader extends Loader<ArrayBuffer> {\n  load(item: LoadItem): AssetPromise<ArrayBuffer> {\n    const url = item.url;\n    if (isBase64(url)) {\n      return new AssetPromise((resolve) => {\n        const base64Str = url.slice(13 + RegExp.$1.length);\n        const result = Uint8Array.from(atob(base64Str), (c) => c.charCodeAt(0));\n        resolve(result.buffer);\n      });\n    }\n    return this.request(url, {\n      ...item,\n      type: \"arraybuffer\"\n    });\n  }\n}\n", "/**\n * Module for glTF 2.0 Interface\n */\n\nimport { MeshTopology } from \"@oasis-engine/core\";\n\n/**\n * The datatype of the components in the attribute\n */\nexport enum AccessorComponentType {\n  /**\n   * Byte\n   */\n  BYTE = 5120,\n  /**\n   * Unsigned Byte\n   */\n  UNSIGNED_BYTE = 5121,\n  /**\n   * Short\n   */\n  SHORT = 5122,\n  /**\n   * Unsigned Short\n   */\n  UNSIGNED_SHORT = 5123,\n  /**\n   * Unsigned Int\n   */\n  UNSIGNED_INT = 5125,\n  /**\n   * Float\n   */\n  FLOAT = 5126\n}\n\n/**\n * Specifies if the attirbute is a scalar, vector, or matrix\n */\nexport enum AccessorType {\n  /**\n   * Scalar\n   */\n  SCALAR = \"SCALAR\",\n  /**\n   * Vector2\n   */\n  VEC2 = \"VEC2\",\n  /**\n   * Vector3\n   */\n  VEC3 = \"VEC3\",\n  /**\n   * Vector4\n   */\n  VEC4 = \"VEC4\",\n  /**\n   * Matrix2x2\n   */\n  MAT2 = \"MAT2\",\n  /**\n   * Matrix3x3\n   */\n  MAT3 = \"MAT3\",\n  /**\n   * Matrix4x4\n   */\n  MAT4 = \"MAT4\"\n}\n\n/**\n * The name of the node's TRS property to modify, or the weights of the Morph Targets it instantiates\n */\nexport enum AnimationChannelTargetPath {\n  /**\n   * Translation\n   */\n  TRANSLATION = \"translation\",\n  /**\n   * Rotation\n   */\n  ROTATION = \"rotation\",\n  /**\n   * Scale\n   */\n  SCALE = \"scale\",\n  /**\n   * Weights\n   */\n  WEIGHTS = \"weights\"\n}\n\n/**\n * Interpolation algorithm\n */\nexport enum AnimationSamplerInterpolation {\n  /**\n   * The animated values are linearly interpolated between keyframes\n   */\n  Linear = \"LINEAR\",\n  /**\n   * The animated values remain constant to the output of the first keyframe, until the next keyframe\n   */\n  Step = \"STEP\",\n  /**\n   * The animation's interpolation is computed using a cubic spline with specified tangents\n   */\n  CubicSpine = \"CUBICSPLINE\"\n}\n\n/**\n * A camera's projection.  A node can reference a camera to apply a transform to place the camera in the scene\n */\nexport enum CameraType {\n  /**\n   * A perspective camera containing properties to create a perspective projection matrix\n   */\n  PERSPECTIVE = \"perspective\",\n  /**\n   * An orthographic camera containing properties to create an orthographic projection matrix\n   */\n  ORTHOGRAPHIC = \"orthographic\"\n}\n\n/**\n * The mime-type of the image\n */\nexport enum ImageMimeType {\n  /**\n   * JPEG Mime-type\n   */\n  JPEG = \"image/jpeg\",\n  /**\n   * PNG Mime-type\n   */\n  PNG = \"image/png\"\n}\n\n/**\n * The alpha rendering mode of the material\n */\nexport enum MaterialAlphaMode {\n  /**\n   * The alpha value is ignored and the rendered output is fully opaque\n   */\n  OPAQUE = \"OPAQUE\",\n  /**\n   * The rendered output is either fully opaque or fully transparent depending on the alpha value and the specified alpha cutoff value\n   */\n  MASK = \"MASK\",\n  /**\n   * The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator)\n   */\n  BLEND = \"BLEND\"\n}\n\n/**\n * Magnification filter.  Valid values correspond to WebGL enums: 9728 (NEAREST) and 9729 (LINEAR)\n */\nexport enum TextureMagFilter {\n  /**\n   * Nearest\n   */\n  NEAREST = 9728,\n  /**\n   * Linear\n   */\n  LINEAR = 9729\n}\n\n/**\n * Minification filter.  All valid values correspond to WebGL enums\n */\nexport enum TextureMinFilter {\n  /**\n   * Nearest\n   */\n  NEAREST = 9728,\n  /**\n   * Linear\n   */\n  LINEAR = 9729,\n  /**\n   * Nearest Mip-Map Nearest\n   */\n  NEAREST_MIPMAP_NEAREST = 9984,\n  /**\n   * Linear Mipmap Nearest\n   */\n  LINEAR_MIPMAP_NEAREST = 9985,\n  /**\n   * Nearest Mipmap Linear\n   */\n  NEAREST_MIPMAP_LINEAR = 9986,\n  /**\n   * Linear Mipmap Linear\n   */\n  LINEAR_MIPMAP_LINEAR = 9987\n}\n\n/**\n * S (U) wrapping mode.  All valid values correspond to WebGL enums\n */\nexport enum TextureWrapMode {\n  /**\n   * Clamp to Edge\n   */\n  CLAMP_TO_EDGE = 33071,\n  /**\n   * Mirrored Repeat\n   */\n  MIRRORED_REPEAT = 33648,\n  /**\n   * Repeat\n   */\n  REPEAT = 10497\n}\n\n/**\n * glTF Property\n */\nexport interface IProperty {\n  /**\n   * Dictionary object with extension-specific objects\n   */\n  extensions?: {\n    [key: string]: any;\n  };\n  /**\n   * Application-Specific data\n   */\n  extras?: any;\n}\n\n/**\n * glTF Child of Root Property\n */\nexport interface IChildRootProperty extends IProperty {\n  /**\n   * The user-defined name of this object\n   */\n  name?: string;\n}\n\n/**\n * Indices of those attributes that deviate from their initialization value\n */\nexport interface IAccessorSparseIndices extends IProperty {\n  /**\n   * The index of the bufferView with sparse indices. Referenced bufferView can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target\n   */\n  bufferView: number;\n  /**\n   * The offset relative to the start of the bufferView in bytes. Must be aligned\n   */\n  byteOffset?: number;\n  /**\n   * The indices data type.  Valid values correspond to WebGL enums: 5121 (UNSIGNED_BYTE), 5123 (UNSIGNED_SHORT), 5125 (UNSIGNED_INT)\n   */\n  componentType: AccessorComponentType;\n}\n\n/**\n * Array of size accessor.sparse.count times number of components storing the displaced accessor attributes pointed by accessor.sparse.indices\n */\nexport interface IAccessorSparseValues extends IProperty {\n  /**\n   * The index of the bufferView with sparse values. Referenced bufferView can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target\n   */\n  bufferView: number;\n  /**\n   * The offset relative to the start of the bufferView in bytes. Must be aligned\n   */\n  byteOffset?: number;\n}\n\n/**\n * Sparse storage of attributes that deviate from their initialization value\n */\nexport interface IAccessorSparse extends IProperty {\n  /**\n   * The number of attributes encoded in this sparse accessor\n   */\n  count: number;\n  /**\n   * Index array of size count that points to those accessor attributes that deviate from their initialization value. Indices must strictly increase\n   */\n  indices: IAccessorSparseIndices;\n  /**\n   * Array of size count times number of components, storing the displaced accessor attributes pointed by indices. Substituted values must have the same componentType and number of components as the base accessor\n   */\n  values: IAccessorSparseValues;\n}\n\n/**\n * A typed view into a bufferView.  A bufferView contains raw binary data.  An accessor provides a typed view into a bufferView or a subset of a bufferView similar to how WebGL's vertexAttribPointer() defines an attribute in a buffer\n */\nexport interface IAccessor extends IChildRootProperty {\n  /**\n   * The index of the bufferview\n   */\n  bufferView?: number;\n  /**\n   * The offset relative to the start of the bufferView in bytes\n   */\n  byteOffset?: number;\n  /**\n   * The datatype of components in the attribute\n   */\n  componentType: AccessorComponentType;\n  /**\n   * Specifies whether integer data values should be normalized\n   */\n  normalized?: boolean;\n  /**\n   * The number of attributes referenced by this accessor\n   */\n  count: number;\n  /**\n   * Specifies if the attribute is a scalar, vector, or matrix\n   */\n  type: AccessorType;\n  /**\n   * Maximum value of each component in this attribute\n   */\n  max?: number[];\n  /**\n   * Minimum value of each component in this attribute\n   */\n  min?: number[];\n  /**\n   * Sparse storage of attributes that deviate from their initialization value\n   */\n  sparse?: IAccessorSparse;\n}\n\n/**\n * Targets an animation's sampler at a node's property\n */\nexport interface IAnimationChannel extends IProperty {\n  /**\n   * The index of a sampler in this animation used to compute the value for the target\n   */\n  sampler: number;\n  /**\n   * The index of the node and TRS property to target\n   */\n  target: IAnimationChannelTarget;\n}\n\n/**\n * The index of the node and TRS property that an animation channel targets\n */\nexport interface IAnimationChannelTarget extends IProperty {\n  /**\n   * The index of the node to target\n   */\n  node: number;\n  /**\n   * The name of the node's TRS property to modify, or the weights of the Morph Targets it instantiates\n   */\n  path: AnimationChannelTargetPath;\n}\n\n/**\n * Combines input and output accessors with an interpolation algorithm to define a keyframe graph (but not its target)\n */\nexport interface IAnimationSampler extends IProperty {\n  /**\n   * The index of an accessor containing keyframe input values, e.g., time\n   */\n  input: number;\n  /**\n   * Interpolation algorithm\n   */\n  interpolation?: AnimationSamplerInterpolation;\n  /**\n   * The index of an accessor, containing keyframe output values\n   */\n  output: number;\n}\n\n/**\n * A keyframe animation\n */\nexport interface IAnimation extends IChildRootProperty {\n  /**\n   * An array of channels, each of which targets an animation's sampler at a node's property\n   */\n  channels: IAnimationChannel[];\n  /**\n   * An array of samplers that combines input and output accessors with an interpolation algorithm to define a keyframe graph (but not its target)\n   */\n  samplers: IAnimationSampler[];\n}\n\n/**\n * Metadata about the glTF asset\n */\nexport interface IAsset extends IChildRootProperty {\n  /**\n   * A copyright message suitable for display to credit the content creator\n   */\n  copyright?: string;\n  /**\n   * Tool that generated this glTF model.  Useful for debugging\n   */\n  generator?: string;\n  /**\n   * The glTF version that this asset targets\n   */\n  version: string;\n  /**\n   * The minimum glTF version that this asset targets\n   */\n  minVersion?: string;\n}\n\n/**\n * A buffer points to binary geometry, animation, or skins\n */\nexport interface IBuffer extends IChildRootProperty {\n  /**\n   * The uri of the buffer.  Relative paths are relative to the .gltf file.  Instead of referencing an external file, the uri can also be a data-uri\n   */\n  uri?: string;\n  /**\n   * The length of the buffer in bytes\n   */\n  byteLength: number;\n}\n\n/**\n * A view into a buffer generally representing a subset of the buffer\n */\nexport interface IBufferView extends IChildRootProperty {\n  /**\n   * The index of the buffer\n   */\n  buffer: number;\n  /**\n   * The offset into the buffer in bytes\n   */\n  byteOffset?: number;\n  /**\n   * The lenth of the bufferView in bytes\n   */\n  byteLength: number;\n  /**\n   * The stride, in bytes\n   */\n  byteStride?: number;\n}\n\n/**\n * An orthographic camera containing properties to create an orthographic projection matrix\n */\nexport interface ICameraOrthographic extends IProperty {\n  /**\n   * The floating-point horizontal magnification of the view. Must not be zero\n   */\n  xmag: number;\n  /**\n   * The floating-point vertical magnification of the view. Must not be zero\n   */\n  ymag: number;\n  /**\n   * The floating-point distance to the far clipping plane. zfar must be greater than znear\n   */\n  zfar: number;\n  /**\n   * The floating-point distance to the near clipping plane\n   */\n  znear: number;\n}\n\n/**\n * A perspective camera containing properties to create a perspective projection matrix\n */\nexport interface ICameraPerspective extends IProperty {\n  /**\n   * The floating-point aspect ratio of the field of view\n   */\n  aspectRatio?: number;\n  /**\n   * The floating-point vertical field of view in radians\n   */\n  yfov: number;\n  /**\n   * The floating-point distance to the far clipping plane\n   */\n  zfar?: number;\n  /**\n   * The floating-point distance to the near clipping plane\n   */\n  znear: number;\n}\n\n/**\n * A camera's projection.  A node can reference a camera to apply a transform to place the camera in the scene\n */\nexport interface ICamera extends IChildRootProperty {\n  /**\n   * An orthographic camera containing properties to create an orthographic projection matrix\n   */\n  orthographic?: ICameraOrthographic;\n  /**\n   * A perspective camera containing properties to create a perspective projection matrix\n   */\n  perspective?: ICameraPerspective;\n  /**\n   * Specifies if the camera uses a perspective or orthographic projection\n   */\n  type: CameraType;\n}\n\n/**\n * Image data used to create a texture. Image can be referenced by URI or bufferView index. mimeType is required in the latter case\n */\nexport interface IImage extends IChildRootProperty {\n  /**\n   * The uri of the image.  Relative paths are relative to the .gltf file.  Instead of referencing an external file, the uri can also be a data-uri.  The image format must be jpg or png\n   */\n  uri?: string;\n  /**\n   * The image's MIME type\n   */\n  mimeType?: ImageMimeType;\n  /**\n   * The index of the bufferView that contains the image. Use this instead of the image's uri property\n   */\n  bufferView?: number;\n}\n\n/**\n * Material Normal Texture Info\n */\nexport interface IMaterialNormalTextureInfo extends ITextureInfo {\n  /**\n   * The scalar multiplier applied to each normal vector of the normal texture\n   */\n  scale?: number;\n}\n\n/**\n * Material Occlusion Texture Info\n */\nexport interface IMaterialOcclusionTextureInfo extends ITextureInfo {\n  /**\n   * A scalar multiplier controlling the amount of occlusion applied\n   */\n  strength?: number;\n}\n\n/**\n * A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology\n */\nexport interface IMaterialPbrMetallicRoughness {\n  /**\n   * The material's base color factor\n   */\n  baseColorFactor?: number[];\n  /**\n   * The base color texture\n   */\n  baseColorTexture?: ITextureInfo;\n  /**\n   * The metalness of the material\n   */\n  metallicFactor?: number;\n  /**\n   * The roughness of the material\n   */\n  roughnessFactor?: number;\n  /**\n   * The metallic-roughness texture\n   */\n  metallicRoughnessTexture?: ITextureInfo;\n}\n\n/**\n * The material appearance of a primitive\n */\nexport interface IMaterial extends IChildRootProperty {\n  /**\n   * A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology. When not specified, all the default values of pbrMetallicRoughness apply\n   */\n  pbrMetallicRoughness?: IMaterialPbrMetallicRoughness;\n  /**\n   * The normal map texture\n   */\n  normalTexture?: IMaterialNormalTextureInfo;\n  /**\n   * The occlusion map texture\n   */\n  occlusionTexture?: IMaterialOcclusionTextureInfo;\n  /**\n   * The emissive map texture\n   */\n  emissiveTexture?: ITextureInfo;\n  /**\n   * The RGB components of the emissive color of the material. These values are linear. If an emissiveTexture is specified, this value is multiplied with the texel values\n   */\n  emissiveFactor?: number[];\n  /**\n   * The alpha rendering mode of the material\n   */\n  alphaMode?: MaterialAlphaMode;\n  /**\n   * The alpha cutoff value of the material\n   */\n  alphaCutoff?: number;\n  /**\n   * Specifies whether the material is double sided\n   */\n  doubleSided?: boolean;\n}\n\n/**\n * Geometry to be rendered with the given material\n */\nexport interface IMeshPrimitive extends IProperty {\n  /**\n   * A dictionary object, where each key corresponds to mesh attribute semantic and each value is the index of the accessor containing attribute's data\n   */\n  attributes: {\n    [name: string]: number;\n  };\n  /**\n   * The index of the accessor that contains the indices\n   */\n  indices?: number;\n  /**\n   * The index of the material to apply to this primitive when rendering\n   */\n  material?: number;\n  /**\n   * The type of primitives to render. All valid values correspond to WebGL enums\n   */\n  mode?: MeshTopology;\n  /**\n   * An array of Morph Targets, each  Morph Target is a dictionary mapping attributes (only POSITION, NORMAL, and TANGENT supported) to their deviations in the Morph Target\n   */\n  targets?: {\n    [name: string]: number;\n  }[];\n}\n\n/**\n * A set of primitives to be rendered.  A node can contain one mesh.  A node's transform places the mesh in the scene\n */\nexport interface IMesh extends IChildRootProperty {\n  /**\n   * An array of primitives, each defining geometry to be rendered with a material\n   */\n  primitives: IMeshPrimitive[];\n  /**\n   * Array of weights to be applied to the Morph Targets\n   */\n  weights?: number[];\n}\n\n/**\n * A node in the node hierarchy\n */\nexport interface INode extends IChildRootProperty {\n  /**\n   * The index of the camera referenced by this node\n   */\n  camera?: number;\n  /**\n   * The indices of this node's children\n   */\n  children?: number[];\n  /**\n   * The index of the skin referenced by this node\n   */\n  skin?: number;\n  /**\n   * A floating-point 4x4 transformation matrix stored in column-major order\n   */\n  matrix?: number[];\n  /**\n   * The index of the mesh in this node\n   */\n  mesh?: number;\n  /**\n   * The node's unit quaternion rotation in the order (x, y, z, w), where w is the scalar\n   */\n  rotation?: number[];\n  /**\n   * The node's non-uniform scale, given as the scaling factors along the x, y, and z axes\n   */\n  scale?: number[];\n  /**\n   * The node's translation along the x, y, and z axes\n   */\n  translation?: number[];\n  /**\n   * The weights of the instantiated Morph Target. Number of elements must match number of Morph Targets of used mesh\n   */\n  weights?: number[];\n}\n\n/**\n * Texture sampler properties for filtering and wrapping modes\n */\nexport interface ISampler extends IChildRootProperty {\n  /**\n   * Magnification filter.  Valid values correspond to WebGL enums: 9728 (NEAREST) and 9729 (LINEAR)\n   */\n  magFilter?: TextureMagFilter;\n  /**\n   * Minification filter.  All valid values correspond to WebGL enums\n   */\n  minFilter?: TextureMinFilter;\n  /**\n   * S (U) wrapping mode.  All valid values correspond to WebGL enums\n   */\n  wrapS?: TextureWrapMode;\n  /**\n   * T (V) wrapping mode.  All valid values correspond to WebGL enums\n   */\n  wrapT?: TextureWrapMode;\n}\n\n/**\n * The root nodes of a scene\n */\nexport interface IScene extends IChildRootProperty {\n  /**\n   * The indices of each root node\n   */\n  nodes: number[];\n}\n\n/**\n * Joints and matrices defining a skin\n */\nexport interface ISkin extends IChildRootProperty {\n  /**\n   * The index of the accessor containing the floating-point 4x4 inverse-bind matrices.  The default is that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were pre-applied\n   */\n  inverseBindMatrices?: number;\n  /**\n   * The index of the node used as a skeleton root. When undefined, joints transforms resolve to scene root\n   */\n  skeleton?: number;\n  /**\n   * Indices of skeleton nodes, used as joints in this skin.  The array length must be the same as the count property of the inverseBindMatrices accessor (when defined)\n   */\n  joints: number[];\n}\n\n/**\n * A texture and its sampler\n */\nexport interface ITexture extends IChildRootProperty {\n  /**\n   * The index of the sampler used by this texture. When undefined, a sampler with repeat wrapping and auto filtering should be used\n   */\n  sampler?: number;\n  /**\n   * The index of the image used by this texture\n   */\n  source: number;\n}\n\n/**\n * Reference to a texture\n */\nexport interface ITextureInfo extends IProperty {\n  /**\n   * The index of the texture\n   */\n  index: number;\n  /**\n   * The set index of texture's TEXCOORD attribute used for texture coordinate mapping\n   */\n  texCoord?: number;\n}\n\n/**\n * The root object for a glTF asset\n */\nexport interface IGLTF extends IProperty {\n  /**\n   * An array of accessors. An accessor is a typed view into a bufferView\n   */\n  accessors?: IAccessor[];\n  /**\n   * An array of keyframe animations\n   */\n  animations?: IAnimation[];\n  /**\n   * Metadata about the glTF asset\n   */\n  asset: IAsset;\n  /**\n   * An array of buffers.  A buffer points to binary geometry, animation, or skins\n   */\n  buffers?: IBuffer[];\n  /**\n   * An array of bufferViews.  A bufferView is a view into a buffer generally representing a subset of the buffer\n   */\n  bufferViews?: IBufferView[];\n  /**\n   * An array of cameras\n   */\n  cameras?: ICamera[];\n  /**\n   * Names of glTF extensions used somewhere in this asset\n   */\n  extensionsUsed?: string[];\n  /**\n   * Names of glTF extensions required to properly load this asset\n   */\n  extensionsRequired?: string[];\n  /**\n   * An array of images.  An image defines data used to create a texture\n   */\n  images?: IImage[];\n  /**\n   * An array of materials.  A material defines the appearance of a primitive\n   */\n  materials?: IMaterial[];\n  /**\n   * An array of meshes.  A mesh is a set of primitives to be rendered\n   */\n  meshes?: IMesh[];\n  /**\n   * An array of nodes\n   */\n  nodes?: INode[];\n  /**\n   * An array of samplers.  A sampler contains properties for texture filtering and wrapping modes\n   */\n  samplers?: ISampler[];\n  /**\n   * The index of the default scene\n   */\n  scene?: number;\n  /**\n   * An array of scenes\n   */\n  scenes?: IScene[];\n  /**\n   * An array of skins.  A skin is defined by joints and matrices\n   */\n  skins?: ISkin[];\n  /**\n   * An array of textures\n   */\n  textures?: ITexture[];\n}\n", "import { Vector3, Vector4, Vector2 } from \"@oasis-engine/math\";\nimport { IndexFormat, TypedArray, VertexElement, VertexElementFormat } from \"@oasis-engine/core\";\nimport { AccessorComponentType, AccessorType, IAccessor, IBufferView, IGLTF } from \"./Schema\";\n\n/**\n * @internal\n */\nexport class GLTFUtil {\n  public static floatBufferToVector2Array(buffer: Float32Array): Vector2[] {\n    const bufferLen = buffer.length;\n    const array = new Array<Vector2>(bufferLen / 2);\n    for (let i = 0; i < bufferLen; i += 2) {\n      array[i / 2] = new Vector2(buffer[i], buffer[i + 1]);\n    }\n    return array;\n  }\n\n  public static floatBufferToVector3Array(buffer: Float32Array): Vector3[] {\n    const bufferLen = buffer.length;\n    const array = new Array<Vector3>(bufferLen / 3);\n    for (let i = 0; i < bufferLen; i += 3) {\n      array[i / 3] = new Vector3(buffer[i], buffer[i + 1], buffer[i + 2]);\n    }\n    return array;\n  }\n\n  public static floatBufferToVector4Array(buffer: Float32Array): Vector4[] {\n    const bufferLen = buffer.length;\n    const array = new Array<Vector4>(bufferLen / 4);\n    for (let i = 0; i < bufferLen; i += 4) {\n      array[i / 4] = new Vector4(buffer[i], buffer[i + 1], buffer[i + 2], buffer[i + 3]);\n    }\n    return array;\n  }\n\n  /**\n   * Parse binary text for glb loader.\n   */\n  static decodeText(array: Uint8Array): string {\n    if (typeof TextDecoder !== \"undefined\") {\n      return new TextDecoder().decode(array);\n    }\n\n    // TextDecoder polyfill\n    let s = \"\";\n\n    for (let i = 0, il = array.length; i < il; i++) {\n      s += String.fromCharCode(array[i]);\n    }\n\n    return decodeURIComponent(encodeURIComponent(s));\n  }\n\n  /**\n   * Get the number of bytes occupied by accessor type.\n   */\n  static getAccessorTypeSize(accessorType: AccessorType): number {\n    switch (accessorType) {\n      case AccessorType.SCALAR:\n        return 1;\n      case AccessorType.VEC2:\n        return 2;\n      case AccessorType.VEC3:\n        return 3;\n      case AccessorType.VEC4:\n        return 4;\n      case AccessorType.MAT2:\n        return 4;\n      case AccessorType.MAT3:\n        return 9;\n      case AccessorType.MAT4:\n        return 16;\n    }\n  }\n\n  /**\n   * Get the TypedArray corresponding to the component type.\n   */\n  static getComponentType(componentType: AccessorComponentType) {\n    switch (componentType) {\n      case AccessorComponentType.BYTE:\n        return Int8Array;\n      case AccessorComponentType.UNSIGNED_BYTE:\n        return Uint8Array;\n      case AccessorComponentType.SHORT:\n        return Int16Array;\n      case AccessorComponentType.UNSIGNED_SHORT:\n        return Uint16Array;\n      case AccessorComponentType.UNSIGNED_INT:\n        return Uint32Array;\n      case AccessorComponentType.FLOAT:\n        return Float32Array;\n    }\n  }\n\n  /**\n   * Get accessor data.\n   */\n  static getAccessorData(gltf: IGLTF, accessor: IAccessor, buffers: ArrayBuffer[]): TypedArray {\n    const bufferViews = gltf.bufferViews;\n    const bufferView = bufferViews[accessor.bufferView];\n    const arrayBuffer = buffers[bufferView.buffer];\n    const accessorByteOffset = accessor.hasOwnProperty(\"byteOffset\") ? accessor.byteOffset : 0;\n    const bufferViewByteOffset = bufferView.hasOwnProperty(\"byteOffset\") ? bufferView.byteOffset : 0;\n    const byteOffset = accessorByteOffset + bufferViewByteOffset;\n    const accessorTypeSize = GLTFUtil.getAccessorTypeSize(accessor.type);\n    const length = accessorTypeSize * accessor.count;\n    const byteStride = bufferView.byteStride ?? 0;\n    const arrayType = GLTFUtil.getComponentType(accessor.componentType);\n    let uint8Array;\n    if (byteStride) {\n      const accessorByteSize = accessorTypeSize * arrayType.BYTES_PER_ELEMENT;\n      uint8Array = new Uint8Array(accessor.count * accessorByteSize);\n      const originalBufferView = new Uint8Array(arrayBuffer, bufferViewByteOffset, bufferView.byteLength);\n      for (let i = 0; i < accessor.count; i++) {\n        for (let j = 0; j < accessorByteSize; j++) {\n          uint8Array[i * accessorByteSize + j] = originalBufferView[i * byteStride + accessorByteOffset + j];\n        }\n      }\n    } else {\n      uint8Array = new Uint8Array(arrayBuffer.slice(byteOffset, byteOffset + length * arrayType.BYTES_PER_ELEMENT));\n    }\n\n    const typedArray = new arrayType(uint8Array.buffer);\n\n    if (accessor.sparse) {\n      const { count, indices, values } = accessor.sparse;\n      const indicesBufferView = bufferViews[indices.bufferView];\n      const valuesBufferView = bufferViews[values.bufferView];\n      const indicesArrayBuffer = buffers[indicesBufferView.buffer];\n      const valuesArrayBuffer = buffers[valuesBufferView.buffer];\n      const indicesByteOffset = (indices.byteOffset ?? 0) + (indicesBufferView.byteOffset ?? 0);\n      const indicesByteLength = indicesBufferView.byteLength;\n      const valuesByteOffset = (values.byteOffset ?? 0) + (valuesBufferView.byteOffset ?? 0);\n      const valuesByteLength = valuesBufferView.byteLength;\n\n      const indicesType = GLTFUtil.getComponentType(indices.componentType);\n      const indicesArray = new indicesType(\n        indicesArrayBuffer,\n        indicesByteOffset,\n        indicesByteLength / indicesType.BYTES_PER_ELEMENT\n      );\n      const valuesArray = new arrayType(\n        valuesArrayBuffer,\n        valuesByteOffset,\n        valuesByteLength / arrayType.BYTES_PER_ELEMENT\n      );\n\n      for (let i = 0; i < count; i++) {\n        const replaceIndex = indicesArray[i];\n        for (let j = 0; j < accessorTypeSize; j++) {\n          typedArray[replaceIndex * accessorTypeSize + j] = valuesArray[i * accessorTypeSize + j];\n        }\n      }\n    }\n\n    return typedArray;\n  }\n\n  static getBufferViewData(bufferView: IBufferView, buffers: ArrayBuffer[]): ArrayBuffer {\n    const { buffer, byteOffset = 0, byteLength } = bufferView;\n    const arrayBuffer = buffers[buffer];\n\n    return arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n  }\n\n  static getVertexStride(gltf: IGLTF, accessor: IAccessor): number {\n    const stride = gltf.bufferViews[accessor.bufferView ?? 0].byteStride;\n    if (stride) {\n      return stride;\n    }\n\n    const size = GLTFUtil.getAccessorTypeSize(accessor.type);\n    const componentType = GLTFUtil.getComponentType(accessor.componentType);\n    return size * componentType.BYTES_PER_ELEMENT;\n  }\n\n  static createVertexElement(semantic: string, accessor: IAccessor, index: number): VertexElement {\n    const size = GLTFUtil.getAccessorTypeSize(accessor.type);\n    return new VertexElement(\n      semantic,\n      0,\n      GLTFUtil.getElementFormat(accessor.componentType, size, accessor.normalized),\n      index\n    );\n  }\n\n  static getIndexFormat(type: AccessorComponentType): IndexFormat {\n    switch (type) {\n      case AccessorComponentType.UNSIGNED_BYTE:\n        return IndexFormat.UInt8;\n      case AccessorComponentType.UNSIGNED_SHORT:\n        return IndexFormat.UInt16;\n      case AccessorComponentType.UNSIGNED_INT:\n        return IndexFormat.UInt32;\n    }\n  }\n\n  static getElementFormat(type: AccessorComponentType, size: number, normalized: boolean = false): VertexElementFormat {\n    if (type == AccessorComponentType.FLOAT) {\n      switch (size) {\n        case 1:\n          return VertexElementFormat.Float;\n        case 2:\n          return VertexElementFormat.Vector2;\n        case 3:\n          return VertexElementFormat.Vector3;\n        case 4:\n          return VertexElementFormat.Vector4;\n      }\n    }\n\n    if (type == AccessorComponentType.SHORT) {\n      switch (size) {\n        case 2:\n          return normalized ? VertexElementFormat.NormalizedShort2 : VertexElementFormat.Short2;\n        case 3:\n        case 4:\n          return normalized ? VertexElementFormat.NormalizedShort4 : VertexElementFormat.Short4;\n      }\n    }\n\n    if (type == AccessorComponentType.UNSIGNED_SHORT) {\n      switch (size) {\n        case 2:\n          return normalized ? VertexElementFormat.NormalizedUShort2 : VertexElementFormat.UShort2;\n        case 3:\n        case 4:\n          return normalized ? VertexElementFormat.NormalizedUShort4 : VertexElementFormat.UShort4;\n      }\n    }\n\n    if (type == AccessorComponentType.BYTE) {\n      switch (size) {\n        case 2:\n        case 3:\n        case 4:\n          return normalized ? VertexElementFormat.NormalizedByte4 : VertexElementFormat.Byte4;\n      }\n    }\n\n    if (type == AccessorComponentType.UNSIGNED_BYTE) {\n      switch (size) {\n        case 2:\n        case 3:\n        case 4:\n          return normalized ? VertexElementFormat.NormalizedUByte4 : VertexElementFormat.UByte4;\n      }\n    }\n  }\n\n  /**\n   * Load image buffer\n   */\n  static loadImageBuffer(imageBuffer: ArrayBuffer, type: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n      const blob = new window.Blob([imageBuffer], { type });\n      const img = new Image();\n      img.src = URL.createObjectURL(blob);\n\n      img.crossOrigin = \"anonymous\";\n      img.onerror = function () {\n        reject(new Error(\"Failed to load image buffer\"));\n      };\n      img.onload = function () {\n        // Call requestAnimationFrame to avoid iOS's bug.\n        requestAnimationFrame(() => {\n          resolve(img);\n          img.onload = null;\n          img.onerror = null;\n          img.onabort = null;\n        });\n      };\n    });\n  }\n\n  static isAbsoluteUrl(url: string): boolean {\n    return /^(?:http|blob|data:|\\/)/.test(url);\n  }\n\n  static parseRelativeUrl(baseUrl: string, relativeUrl: string): string {\n    if (GLTFUtil.isAbsoluteUrl(relativeUrl)) {\n      return relativeUrl;\n    }\n\n    const char0 = relativeUrl.charAt(0);\n    if (char0 === \".\") {\n      return GLTFUtil._formatRelativePath(relativeUrl + relativeUrl);\n    }\n\n    return baseUrl.substring(0, baseUrl.lastIndexOf(\"/\") + 1) + relativeUrl;\n  }\n\n  /**\n   * Parse the glb format.\n   */\n  static parseGLB(glb: ArrayBuffer): {\n    gltf: IGLTF;\n    buffers: ArrayBuffer[];\n  } {\n    const UINT32_LENGTH = 4;\n    const GLB_HEADER_MAGIC = 0x46546c67; // 'glTF'\n    const GLB_HEADER_LENGTH = 12;\n    const GLB_CHUNK_TYPES = { JSON: 0x4e4f534a, BIN: 0x004e4942 };\n\n    const dataView = new DataView(glb);\n\n    // read header\n    const header = {\n      magic: dataView.getUint32(0, true),\n      version: dataView.getUint32(UINT32_LENGTH, true),\n      length: dataView.getUint32(2 * UINT32_LENGTH, true)\n    };\n\n    if (header.magic !== GLB_HEADER_MAGIC) {\n      console.error(\"Invalid glb magic number. Expected 0x46546C67, found 0x\" + header.magic.toString(16));\n      return null;\n    }\n\n    // read main data\n    let chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);\n    let chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true);\n\n    // read glTF json\n    if (chunkType !== GLB_CHUNK_TYPES.JSON) {\n      console.error(\"Invalid glb chunk type. Expected 0x4E4F534A, found 0x\" + chunkType.toString(16));\n      return null;\n    }\n\n    const glTFData = new Uint8Array(glb, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);\n    const gltf: IGLTF = JSON.parse(GLTFUtil.decodeText(glTFData));\n\n    // read all buffers\n    const buffers: ArrayBuffer[] = [];\n    let byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;\n\n    while (byteOffset < header.length) {\n      chunkLength = dataView.getUint32(byteOffset, true);\n      chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);\n\n      if (chunkType !== GLB_CHUNK_TYPES.BIN) {\n        console.error(\"Invalid glb chunk type. Expected 0x004E4942, found 0x\" + chunkType.toString(16));\n        return null;\n      }\n\n      const currentOffset = byteOffset + 2 * UINT32_LENGTH;\n      const buffer = glb.slice(currentOffset, currentOffset + chunkLength);\n      buffers.push(buffer);\n\n      byteOffset += chunkLength + 2 * UINT32_LENGTH;\n    }\n\n    return {\n      gltf,\n      buffers\n    };\n  }\n\n  private static _formatRelativePath(value: string): string {\n    const parts = value.split(\"/\");\n    for (let i = 0, n = parts.length; i < n; i++) {\n      if (parts[i] == \"..\") {\n        parts.splice(i - 1, 2);\n        i -= 2;\n      }\n    }\n    return parts.join(\"/\");\n  }\n}\n", "import { EngineObject } from \"@oasis-engine/core\";\nimport { ExtensionParser } from \"../extensions/ExtensionParser\";\nimport { ExtensionSchema } from \"../extensions/Schema\";\nimport { GLTFResource } from \"../GLTFResource\";\n\nexport abstract class Parser {\n  private static _extensionParsers: Record<string, ExtensionParser[]> = {};\n\n  static parseEngineResource(\n    extensionName: string,\n    extensionSchema: ExtensionSchema,\n    parseResource: EngineObject,\n    context: GLTFResource,\n    ...extra\n  ): void {\n    const parsers = Parser._extensionParsers[extensionName];\n\n    if (parsers?.length) {\n      for (let i = 0; i < parsers.length; i++) {\n        parsers[i].parseEngineResource(extensionSchema, parseResource, context, ...extra);\n      }\n    }\n  }\n\n  static createEngineResource<T extends EngineObject>(\n    extensionName: string,\n    extensionSchema: ExtensionSchema,\n    context: GLTFResource,\n    ...extra\n  ): T | Promise<T> {\n    const parsers = Parser._extensionParsers[extensionName];\n\n    if (parsers?.length) {\n      return parsers[0].createEngineResource(extensionSchema, context, ...extra) as T;\n    }\n  }\n\n  static hasExtensionParser(extensionName: string): boolean {\n    const parsers = Parser._extensionParsers[extensionName];\n    return !!parsers?.length;\n  }\n\n  static initialize(extensionName: string) {\n    const parsers = Parser._extensionParsers[extensionName];\n\n    if (parsers?.length) {\n      for (let i = 0; i < parsers.length; i++) {\n        parsers[i].initialize();\n      }\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static _addExtensionParser(extensionName: string, extensionParser: ExtensionParser) {\n    if (!Parser._extensionParsers[extensionName]) {\n      Parser._extensionParsers[extensionName] = [];\n    }\n    Parser._extensionParsers[extensionName].push(extensionParser);\n  }\n\n  abstract parse(context: GLTFResource): void | Promise<void>;\n}\n\n/**\n * Declare ExtensionParser's decorator.\n * @param extensionName - Extension name\n */\nexport function registerExtension(extensionName: string) {\n  return (parser: new () => ExtensionParser) => {\n    const extensionParser = new parser();\n\n    Parser._addExtensionParser(extensionName, extensionParser);\n  };\n}\n", "import {\n  AnimationClip,\n  AnimationCurve,\n  Component,\n  Entity,\n  InterpolableKeyframe,\n  InterpolationType,\n  SkinnedMeshRenderer,\n  Transform,\n  TypedArray\n} from \"@oasis-engine/core\";\nimport { Quaternion, Vector2, Vector3, Vector4 } from \"@oasis-engine/math\";\nimport { GLTFResource } from \"../GLTFResource\";\nimport { GLTFUtil } from \"../GLTFUtil\";\nimport { AccessorType, AnimationChannelTargetPath, AnimationSamplerInterpolation, IAnimationChannel } from \"../Schema\";\nimport { Parser } from \"./Parser\";\n\nexport class AnimationParser extends Parser {\n  parse(context: GLTFResource): void {\n    const { gltf, buffers, entities } = context;\n    const { animations, accessors } = gltf;\n    if (!animations) {\n      return;\n    }\n    const animationClipCount = animations.length;\n    const animationClips = new Array<AnimationClip>(animationClipCount);\n    const animationsIndices = new Array<{\n      name: string;\n      index: number;\n    }>(animationClipCount);\n\n    for (let i = 0; i < animationClipCount; i++) {\n      const gltfAnimation = animations[i];\n      const { channels, samplers, name = `AnimationClip${i}` } = gltfAnimation;\n      const animationClip = new AnimationClip(name);\n      const sampleDataCollection = new Array<SampleData>();\n\n      let duration = -1;\n\n      // parse samplers\n      for (let i = 0; i < samplers.length; i++) {\n        const gltfSampler = samplers[i];\n        const inputAccessor = accessors[gltfSampler.input];\n        const outputAccessor = accessors[gltfSampler.output];\n\n        const input = GLTFUtil.getAccessorData(gltf, inputAccessor, buffers);\n        const output = GLTFUtil.getAccessorData(gltf, outputAccessor, buffers);\n        const outputAccessorSize = output.length / input.length;\n\n        const interpolation = gltfSampler.interpolation ?? AnimationSamplerInterpolation.Linear;\n        let samplerInterpolation: InterpolationType;\n        switch (interpolation) {\n          case AnimationSamplerInterpolation.CubicSpine:\n            samplerInterpolation = InterpolationType.CubicSpine;\n            break;\n          case AnimationSamplerInterpolation.Step:\n            samplerInterpolation = InterpolationType.Step;\n            break;\n          case AnimationSamplerInterpolation.Linear:\n            samplerInterpolation = InterpolationType.Linear;\n            break;\n        }\n        const maxTime = input[input.length - 1];\n        if (maxTime > duration) {\n          duration = maxTime;\n        }\n\n        sampleDataCollection.push({\n          type: outputAccessor.type,\n          interpolation: samplerInterpolation,\n          input,\n          output,\n          outputSize: outputAccessorSize\n        });\n      }\n\n      for (let i = 0; i < channels.length; i++) {\n        const gltfChannel = channels[i];\n        const { target } = gltfChannel;\n\n        const channelTargetEntity = entities[target.node];\n        let relativePath = \"\";\n        let entity = channelTargetEntity;\n        while (entity.parent) {\n          relativePath = relativePath === \"\" ? `${entity.name}` : `${entity.name}/${relativePath}`;\n          entity = entity.parent;\n        }\n\n        let compType: new (entity: Entity) => Component;\n        let propertyName: string;\n        switch (target.path) {\n          case AnimationChannelTargetPath.TRANSLATION:\n            compType = Transform;\n            propertyName = \"position\";\n            break;\n          case AnimationChannelTargetPath.ROTATION:\n            compType = Transform;\n            propertyName = \"rotation\";\n            break;\n          case AnimationChannelTargetPath.SCALE:\n            compType = Transform;\n            propertyName = \"scale\";\n            break;\n          case AnimationChannelTargetPath.WEIGHTS:\n            compType = SkinnedMeshRenderer;\n            propertyName = \"blendShapeWeights\";\n            break;\n          default:\n        }\n\n        const curve = this._addCurve(gltfChannel, sampleDataCollection);\n        animationClip.addCurveBinding(relativePath, compType, propertyName, curve);\n      }\n\n      animationClips[i] = animationClip;\n      animationsIndices[i] = {\n        name,\n        index: i\n      };\n    }\n    context.animations = animationClips;\n    // @ts-ignore for editor\n    context._animationsIndices = animationsIndices;\n  }\n\n  private _addCurve(gltfChannel: IAnimationChannel, sampleDataCollection: SampleData[]): AnimationCurve {\n    const curve = new AnimationCurve();\n    const sampleData = sampleDataCollection[gltfChannel.sampler];\n    const { type, input, output, outputSize } = sampleData;\n\n    curve.interpolation = sampleData.interpolation;\n    for (let j = 0, n = input.length; j < n; j++) {\n      const offset = j * outputSize;\n      if (type === AccessorType.SCALAR) {\n        let keyframe =\n          outputSize > 1\n            ? new InterpolableKeyframe<Float32Array, Float32Array>()\n            : new InterpolableKeyframe<number, number>();\n        keyframe.time = input[j];\n        keyframe.inTangent = 0;\n        keyframe.outTangent = 0;\n        keyframe.value = outputSize > 1 ? <Float32Array>output.subarray(offset, offset + outputSize) : output[offset];\n        curve.addKey(keyframe);\n      }\n      if (type === AccessorType.VEC2) {\n        const keyframe = new InterpolableKeyframe<Vector2, Vector2>();\n        keyframe.time = input[j];\n        keyframe.value = new Vector2(output[offset], output[offset + 1]);\n        keyframe.inTangent = new Vector2();\n        keyframe.outTangent = new Vector2();\n        curve.addKey(keyframe);\n      }\n      if (type === AccessorType.VEC3) {\n        const keyframe = new InterpolableKeyframe<Vector3, Vector3>();\n        keyframe.time = input[j];\n        keyframe.value = new Vector3(output[offset], output[offset + 1], output[offset + 2]);\n        keyframe.inTangent = new Vector3();\n        keyframe.outTangent = new Vector3();\n        curve.addKey(keyframe);\n      }\n      if (type === AccessorType.VEC4) {\n        const keyframe = new InterpolableKeyframe<Vector4, Quaternion>();\n        keyframe.time = input[j];\n        keyframe.value = new Quaternion(output[offset], output[offset + 1], output[offset + 2], output[offset + 3]);\n        keyframe.inTangent = new Vector4();\n        keyframe.outTangent = new Vector4();\n        curve.addKey(keyframe);\n      }\n    }\n    return curve;\n  }\n}\n\ninterface SampleData {\n  type: AccessorType;\n  input: TypedArray;\n  output: TypedArray;\n  interpolation: InterpolationType;\n  outputSize: number;\n}\n", "import { AssetType } from \"@oasis-engine/core\";\nimport { GLTFResource } from \"../GLTFResource\";\nimport { IBuffer, IGLTF } from \"../Schema\";\nimport { GLTFUtil } from \"../GLTFUtil\";\nimport { Parser } from \"./Parser\";\n\nexport class BufferParser extends Parser {\n  parse(context: GLTFResource): Promise<void> {\n    const { url, engine } = context;\n\n    if (this._isGLB(url)) {\n      return engine.resourceManager\n        .load<ArrayBuffer>({\n          url,\n          type: AssetType.Buffer\n        })\n        .then(GLTFUtil.parseGLB)\n        .then(({ gltf, buffers }) => {\n          context.gltf = gltf;\n          context.buffers = buffers;\n        });\n    } else {\n      return engine.resourceManager\n        .load<IGLTF>({\n          url,\n          type: AssetType.JSON\n        })\n        .then((gltf: IGLTF) => {\n          context.gltf = gltf;\n          return Promise.all(\n            gltf.buffers.map((buffer: IBuffer) => {\n              return engine.resourceManager.load<ArrayBuffer>({\n                type: AssetType.Buffer,\n                url: GLTFUtil.parseRelativeUrl(url, buffer.uri)\n              });\n            })\n          ).then((buffers: ArrayBuffer[]) => {\n            context.buffers = buffers;\n          });\n        });\n    }\n  }\n\n  private _isGLB(url: string): boolean {\n    return url.substring(url.lastIndexOf(\".\") + 1) === \"glb\";\n  }\n}\n", "import { Entity } from \"@oasis-engine/core\";\nimport { GLTFResource } from \"../GLTFResource\";\nimport { Parser } from \"./Parser\";\n\nexport class EntityParser extends Parser {\n  /** @internal */\n  static _defaultName: String = \"_GLTF_ENTITY_\";\n\n  parse(context: GLTFResource): void {\n    const {\n      engine,\n      gltf: { nodes }\n    } = context;\n    if (!nodes) return;\n\n    const entities: Entity[] = [];\n\n    for (let i = 0; i < nodes.length; i++) {\n      const gltfNode = nodes[i];\n      const { matrix, translation, rotation, scale } = gltfNode;\n      const entity = new Entity(engine, gltfNode.name || `${EntityParser._defaultName}${i}`);\n\n      const { transform } = entity;\n      if (matrix) {\n        const localMatrix = transform.localMatrix;\n        localMatrix.setValueByArray(matrix);\n        transform.localMatrix = localMatrix;\n      } else {\n        if (translation) {\n          transform.setPosition(translation[0], translation[1], translation[2]);\n        }\n        if (rotation) {\n          transform.setRotationQuaternion(rotation[0], rotation[1], rotation[2], rotation[3]);\n        }\n        if (scale) {\n          transform.setScale(scale[0], scale[1], scale[2]);\n        }\n      }\n\n      entities[i] = entity;\n    }\n\n    context.entities = entities;\n    this._buildEntityTree(context);\n    this._createSceneRoots(context);\n  }\n\n  private _buildEntityTree(context: GLTFResource): void {\n    const {\n      gltf: { nodes },\n      entities\n    } = context;\n\n    for (let i = 0; i < nodes.length; i++) {\n      const { children } = nodes[i];\n      const entity = entities[i];\n\n      if (children) {\n        for (let j = 0; j < children.length; j++) {\n          const childEntity = entities[children[j]];\n\n          entity.addChild(childEntity);\n        }\n      }\n    }\n  }\n\n  private _createSceneRoots(context: GLTFResource): void {\n    const {\n      engine,\n      gltf: { scene: sceneID = 0, scenes },\n      entities\n    } = context;\n\n    if (!scenes) return;\n\n    const sceneRoots: Entity[] = [];\n\n    for (let i = 0; i < scenes.length; i++) {\n      const { nodes } = scenes[i];\n\n      if (!nodes) continue;\n\n      if (nodes.length === 1) {\n        sceneRoots[i] = entities[nodes[0]];\n      } else {\n        const rootEntity = new Entity(engine, \"GLTF_ROOT\");\n        for (let j = 0; j < nodes.length; j++) {\n          rootEntity.addChild(entities[nodes[j]]);\n        }\n        sceneRoots[i] = rootEntity;\n      }\n    }\n\n    context.sceneRoots = sceneRoots;\n    context.defaultSceneRoot = sceneRoots[sceneID];\n  }\n}\n", "import { Material, PBRMaterial, PBRSpecularMaterial, RenderFace, UnlitMaterial } from \"@oasis-engine/core\";\nimport { Color } from \"@oasis-engine/math\";\nimport { GLTFResource } from \"../GLTFResource\";\nimport { MaterialAlphaMode } from \"../Schema\";\nimport { Parser } from \"./Parser\";\n\nexport class MaterialParser extends Parser {\n  /** @internal */\n  static _parseTextureTransform(material: Material, extensions: any = {}, context: GLTFResource): void {\n    const schema = extensions.KHR_texture_transform;\n    if (schema) {\n      Parser.parseEngineResource(\"KHR_texture_transform\", schema, material, context);\n    }\n  }\n\n  parse(context: GLTFResource): void {\n    const { gltf, engine, textures } = context;\n    if (!gltf.materials) return;\n\n    const materials: Material[] = [];\n\n    for (let i = 0; i < gltf.materials.length; i++) {\n      const {\n        extensions = {},\n        pbrMetallicRoughness,\n        normalTexture,\n        occlusionTexture,\n        emissiveTexture,\n        emissiveFactor,\n        alphaMode,\n        alphaCutoff,\n        doubleSided,\n        name = \"\"\n      } = gltf.materials[i];\n\n      const { KHR_materials_unlit, KHR_materials_pbrSpecularGlossiness } = extensions;\n\n      let material: UnlitMaterial | PBRMaterial | PBRSpecularMaterial = null;\n\n      if (KHR_materials_unlit) {\n        material = <UnlitMaterial>Parser.createEngineResource(\"KHR_materials_unlit\", KHR_materials_unlit, context);\n      } else if (KHR_materials_pbrSpecularGlossiness) {\n        material = <PBRSpecularMaterial>(\n          Parser.createEngineResource(\n            \"KHR_materials_pbrSpecularGlossiness\",\n            KHR_materials_pbrSpecularGlossiness,\n            context\n          )\n        );\n      } else {\n        material = new PBRMaterial(engine);\n      }\n\n      material.name = name;\n\n      if (pbrMetallicRoughness) {\n        const { baseColorFactor, baseColorTexture, metallicFactor, roughnessFactor, metallicRoughnessTexture } =\n          pbrMetallicRoughness;\n\n        if (baseColorFactor) {\n          material.baseColor = new Color(...baseColorFactor);\n        }\n        if (baseColorTexture) {\n          material.baseTexture = textures[baseColorTexture.index];\n          MaterialParser._parseTextureTransform(material, baseColorTexture.extensions, context);\n        }\n\n        if (!KHR_materials_unlit && !KHR_materials_pbrSpecularGlossiness) {\n          const m = material as PBRMaterial;\n          m.metallic = metallicFactor ?? 1;\n          m.roughness = roughnessFactor ?? 1;\n          if (metallicRoughnessTexture) {\n            m.roughnessMetallicTexture = textures[metallicRoughnessTexture.index];\n            MaterialParser._parseTextureTransform(material, metallicRoughnessTexture.extensions, context);\n          }\n        }\n      }\n\n      if (!KHR_materials_unlit) {\n        const m = material as PBRMaterial | PBRSpecularMaterial;\n\n        if (emissiveTexture) {\n          m.emissiveTexture = textures[emissiveTexture.index];\n          MaterialParser._parseTextureTransform(material, emissiveTexture.extensions, context);\n        }\n\n        if (emissiveFactor) {\n          m.emissiveColor = new Color(...emissiveFactor);\n        }\n\n        if (normalTexture) {\n          const { index, scale } = normalTexture;\n          m.normalTexture = textures[index];\n          MaterialParser._parseTextureTransform(material, normalTexture.extensions, context);\n          if (scale !== undefined) {\n            m.normalTextureIntensity = scale;\n          }\n        }\n\n        if (occlusionTexture) {\n          const { index, strength } = occlusionTexture;\n          m.occlusionTexture = textures[index];\n          MaterialParser._parseTextureTransform(material, occlusionTexture.extensions, context);\n          if (strength !== undefined) {\n            m.occlusionTextureIntensity = strength;\n          }\n        }\n      }\n\n      if (doubleSided) {\n        material.renderFace = RenderFace.Double;\n      } else {\n        material.renderFace = RenderFace.Front;\n      }\n\n      switch (alphaMode) {\n        case MaterialAlphaMode.OPAQUE:\n          material.isTransparent = false;\n          break;\n        case MaterialAlphaMode.BLEND:\n          material.isTransparent = true;\n          break;\n        case MaterialAlphaMode.MASK:\n          material.alphaCutoff = alphaCutoff ?? 0.5;\n          break;\n      }\n\n      materials[i] = material;\n    }\n\n    context.materials = materials;\n  }\n}\n", "import { BlendShape, Engine, EngineObject, ModelMesh, TypedArray } from \"@oasis-engine/core\";\nimport { Vector3 } from \"@oasis-engine/math\";\nimport { GLTFResource } from \"../GLTFResource\";\nimport { GLTFUtil } from \"../GLTFUtil\";\nimport { IGLTF, IMesh, IMeshPrimitive } from \"../Schema\";\nimport { Parser } from \"./Parser\";\n\nexport class MeshParser extends Parser {\n  private static _tempVector3 = new Vector3();\n  parse(context: GLTFResource): Promise<void> {\n    const { engine, gltf, buffers } = context;\n    if (!gltf.meshes) return;\n\n    const meshPromises: Promise<ModelMesh[]>[] = [];\n\n    for (let i = 0; i < gltf.meshes.length; i++) {\n      const gltfMesh = gltf.meshes[i];\n      const primitivePromises: Promise<ModelMesh>[] = [];\n\n      for (let j = 0; j < gltfMesh.primitives.length; j++) {\n        const gltfPrimitive = gltfMesh.primitives[j];\n        const { extensions = {} } = gltfPrimitive;\n        const { KHR_draco_mesh_compression } = extensions;\n\n        primitivePromises.push(\n          new Promise((resolve) => {\n            const mesh = new ModelMesh(engine, gltfMesh.name || j + \"\");\n\n            if (KHR_draco_mesh_compression) {\n              (<Promise<EngineObject>>(\n                Parser.createEngineResource(\n                  \"KHR_draco_mesh_compression\",\n                  KHR_draco_mesh_compression,\n                  context,\n                  gltfPrimitive\n                )\n              ))\n                .then((decodedGeometry: any) => {\n                  return this._parseMeshFromGLTFPrimitive(\n                    mesh,\n                    gltfMesh,\n                    gltfPrimitive,\n                    gltf,\n                    (attributeSemantic) => {\n                      for (let j = 0; j < decodedGeometry.attributes.length; j++) {\n                        if (decodedGeometry.attributes[j].name === attributeSemantic) {\n                          return decodedGeometry.attributes[j].array;\n                        }\n                      }\n                      return null;\n                    },\n                    (attributeSemantic, shapeIndex) => {\n                      throw \"BlendShape animation is not supported when using draco.\";\n                    },\n                    () => {\n                      return decodedGeometry.index.array;\n                    },\n                    engine\n                  );\n                })\n                .then(resolve);\n            } else {\n              this._parseMeshFromGLTFPrimitive(\n                mesh,\n                gltfMesh,\n                gltfPrimitive,\n                gltf,\n                (attributeSemantic) => {\n                  const accessorIdx = gltfPrimitive.attributes[attributeSemantic];\n                  const accessor = gltf.accessors[accessorIdx];\n                  return GLTFUtil.getAccessorData(gltf, accessor, buffers);\n                },\n                (attributeName, shapeIndex) => {\n                  const shapeAccessorIdx = gltfPrimitive.targets[shapeIndex];\n                  const attributeAccessorIdx = shapeAccessorIdx[attributeName];\n                  if (attributeAccessorIdx) {\n                    const accessor = gltf.accessors[attributeAccessorIdx];\n                    return GLTFUtil.getAccessorData(gltf, accessor, buffers);\n                  } else {\n                    return null;\n                  }\n                },\n                () => {\n                  const indexAccessor = gltf.accessors[gltfPrimitive.indices];\n                  return GLTFUtil.getAccessorData(gltf, indexAccessor, buffers);\n                },\n                engine\n              ).then(resolve);\n            }\n          })\n        );\n      }\n\n      meshPromises.push(Promise.all(primitivePromises));\n    }\n\n    return Promise.all(meshPromises).then((meshes: ModelMesh[][]) => {\n      context.meshes = meshes;\n    });\n  }\n\n  private _parseMeshFromGLTFPrimitive(\n    mesh: ModelMesh,\n    gltfMesh: IMesh,\n    gltfPrimitive: IMeshPrimitive,\n    gltf: IGLTF,\n    getVertexBufferData: (semantic: string) => TypedArray,\n    getBlendShapeData: (semantic: string, shapeIndex: number) => TypedArray,\n    getIndexBufferData: () => TypedArray,\n    engine: Engine\n  ): Promise<ModelMesh> {\n    const { attributes, targets, indices, mode } = gltfPrimitive;\n    let vertexCount: number;\n\n    const accessor = gltf.accessors[attributes[\"POSITION\"]];\n    const positionBuffer = <Float32Array>getVertexBufferData(\"POSITION\");\n    const positions = GLTFUtil.floatBufferToVector3Array(positionBuffer);\n    mesh.setPositions(positions);\n\n    const { bounds } = mesh;\n    vertexCount = accessor.count;\n    if (accessor.min && accessor.max) {\n      bounds.min.setValueByArray(accessor.min);\n      bounds.max.setValueByArray(accessor.max);\n    } else {\n      const position = MeshParser._tempVector3;\n      const { min, max } = bounds;\n\n      min.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n      max.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n      const stride = positionBuffer.length / vertexCount;\n      for (let j = 0; j < vertexCount; j++) {\n        const offset = j * stride;\n        position.setValueByArray(positionBuffer, offset);\n        Vector3.min(min, position, min);\n        Vector3.max(max, position, max);\n      }\n    }\n\n    for (const attributeSemantic in attributes) {\n      if (attributeSemantic === \"POSITION\") {\n        continue;\n      }\n      const bufferData = getVertexBufferData(attributeSemantic);\n      switch (attributeSemantic) {\n        case \"NORMAL\":\n          const normals = GLTFUtil.floatBufferToVector3Array(<Float32Array>bufferData);\n          mesh.setNormals(normals);\n          break;\n        case \"TANGENT\":\n          const tangents = GLTFUtil.floatBufferToVector4Array(<Float32Array>bufferData);\n          mesh.setTangents(tangents);\n          break;\n        case \"TEXCOORD_0\":\n          const texturecoords = GLTFUtil.floatBufferToVector2Array(<Float32Array>bufferData);\n          mesh.setUVs(texturecoords, 0);\n          break;\n        case \"JOINTS_0\":\n          const joints = GLTFUtil.floatBufferToVector4Array(<Float32Array>bufferData);\n          mesh.setBoneIndices(joints);\n          break;\n        case \"WEIGHTS_0\":\n          const weights = GLTFUtil.floatBufferToVector4Array(<Float32Array>bufferData);\n          mesh.setBoneWeights(weights);\n          break;\n        default:\n          // console.warn(`Unsupport attribute semantic ${attributeSemantic}.`);\n          break;\n      }\n    }\n\n    // Indices\n    if (indices !== undefined) {\n      const indexAccessor = gltf.accessors[indices];\n      const indexData = getIndexBufferData();\n      mesh.setIndices(<Uint8Array | Uint16Array | Uint32Array>indexData);\n      mesh.addSubMesh(0, indexAccessor.count, mode);\n    } else {\n      mesh.addSubMesh(0, vertexCount, mode);\n    }\n\n    // BlendShapes\n    targets && this._createBlendShape(mesh, gltfMesh, targets, getBlendShapeData);\n\n    mesh.uploadData(true);\n    return Promise.resolve(mesh);\n  }\n\n  private _createBlendShape(\n    mesh: ModelMesh,\n    glTFMesh: IMesh,\n    glTFTargets: {\n      [name: string]: number;\n    }[],\n    getBlendShapeData: (semantic: string, shapeIndex: number) => TypedArray\n  ): void {\n    const blendShapeNames = glTFMesh.extras ? glTFMesh.extras.targetNames : null;\n\n    for (let i = 0, n = glTFTargets.length; i < n; i++) {\n      const name = blendShapeNames ? blendShapeNames[i] : `blendShape${i}`;\n      const deltaPosBuffer = getBlendShapeData(\"POSITION\", i);\n      const deltaNorBuffer = getBlendShapeData(\"NORMAL\", i);\n      const deltaTanBuffer = getBlendShapeData(\"TANGENT\", i);\n      const deltaPositions = deltaPosBuffer ? GLTFUtil.floatBufferToVector3Array(<Float32Array>deltaPosBuffer) : null;\n      const deltaNormals = deltaNorBuffer ? GLTFUtil.floatBufferToVector3Array(<Float32Array>deltaNorBuffer) : null;\n      const deltaTangents = deltaTanBuffer ? GLTFUtil.floatBufferToVector3Array(<Float32Array>deltaTanBuffer) : null;\n\n      const blendShape = new BlendShape(name);\n      blendShape.addFrame(1.0, deltaPositions, deltaNormals, deltaTangents);\n      mesh.addBlendShape(blendShape);\n    }\n  }\n}\n", "import {\n  Animator,\n  AnimatorController,\n  AnimatorControllerLayer,\n  AnimatorStateMachine,\n  BlinnPhongMaterial,\n  Camera,\n  Engine,\n  Entity,\n  MeshRenderer,\n  SkinnedMeshRenderer\n} from \"@oasis-engine/core\";\nimport { IKHRLightsPunctual, IKHRLightsPunctual_LightNode } from \"../extensions/Schema\";\nimport { GLTFResource } from \"../GLTFResource\";\nimport { CameraType, ICamera, INode } from \"../Schema\";\nimport { Parser } from \"./Parser\";\n\nexport class SceneParser extends Parser {\n  private static _defaultMaterial: BlinnPhongMaterial;\n\n  private static _getDefaultMaterial(engine: Engine): BlinnPhongMaterial {\n    if (!SceneParser._defaultMaterial) {\n      SceneParser._defaultMaterial = new BlinnPhongMaterial(engine);\n    }\n\n    return SceneParser._defaultMaterial;\n  }\n\n  parse(context: GLTFResource): void {\n    const {\n      gltf: { nodes, cameras: gltfCameras },\n      entities\n    } = context;\n\n    if (!nodes) return;\n\n    for (let i = 0; i < nodes.length; i++) {\n      const gltfNode = nodes[i];\n      const { camera: cameraID, mesh: meshID, extensions = {} } = gltfNode;\n      const KHR_lights_punctual = <IKHRLightsPunctual_LightNode>extensions.KHR_lights_punctual;\n      const entity = entities[i];\n\n      if (cameraID !== undefined) {\n        this._createCamera(context, gltfCameras[cameraID], entity);\n      }\n\n      if (meshID !== undefined) {\n        this._createRenderer(context, gltfNode, entity);\n      }\n\n      if (KHR_lights_punctual) {\n        const lightIndex = KHR_lights_punctual.light;\n        const lights = (context.gltf.extensions.KHR_lights_punctual as IKHRLightsPunctual).lights;\n\n        Parser.parseEngineResource(\"KHR_lights_punctual\", lights[lightIndex], entity, context);\n      }\n    }\n\n    if (context.defaultSceneRoot) {\n      this._createAnimator(context);\n    }\n  }\n\n  private _createCamera(context: GLTFResource, cameraSchema: ICamera, entity: Entity): void {\n    const { orthographic, perspective, type } = cameraSchema;\n    const camera = entity.addComponent(Camera);\n\n    if (type === CameraType.ORTHOGRAPHIC) {\n      const { xmag, ymag, zfar, znear } = orthographic;\n\n      camera.isOrthographic = true;\n\n      if (znear !== undefined) {\n        camera.nearClipPlane = znear;\n      }\n      if (zfar !== undefined) {\n        camera.farClipPlane = zfar;\n      }\n\n      camera.orthographicSize = Math.max(ymag ?? 0, xmag ?? 0) / 2;\n    } else if (type === CameraType.PERSPECTIVE) {\n      const { aspectRatio, yfov, zfar, znear } = perspective;\n\n      if (aspectRatio !== undefined) {\n        camera.aspectRatio = aspectRatio;\n      }\n      if (yfov !== undefined) {\n        camera.fieldOfView = (yfov * 180) / Math.PI;\n      }\n      if (zfar !== undefined) {\n        camera.farClipPlane = zfar;\n      }\n      if (znear !== undefined) {\n        camera.nearClipPlane = znear;\n      }\n    }\n\n    if (!context.cameras) context.cameras = [];\n    context.cameras.push(camera);\n    // @todo: use engine camera by default\n    camera.enabled = false;\n  }\n\n  private _createRenderer(context: GLTFResource, gltfNode: INode, entity: Entity): void {\n    const {\n      engine,\n      gltf: { meshes: gltfMeshes },\n      meshes,\n      materials,\n      skins\n    } = context;\n    const { mesh: meshID, skin: skinID } = gltfNode;\n    const glTFMesh = gltfMeshes[meshID];\n    const gltfMeshPrimitives = glTFMesh.primitives;\n    const blendShapeWeights = gltfNode.weights || glTFMesh.weights;\n\n    for (let i = 0; i < gltfMeshPrimitives.length; i++) {\n      const mesh = meshes[meshID][i];\n      let renderer: MeshRenderer | SkinnedMeshRenderer;\n\n      if (skinID !== undefined || blendShapeWeights) {\n        const skinRenderer = entity.addComponent(SkinnedMeshRenderer);\n        skinRenderer.mesh = mesh;\n        if (skinID !== undefined) {\n          skinRenderer.skin = skins[skinID];\n        }\n        if (blendShapeWeights) {\n          skinRenderer.blendShapeWeights = new Float32Array(blendShapeWeights);\n        }\n        renderer = skinRenderer;\n      } else {\n        renderer = entity.addComponent(MeshRenderer);\n        renderer.mesh = mesh;\n      }\n\n      const materialIndex = gltfMeshPrimitives[i].material;\n      const material = materials?.[materialIndex] || SceneParser._getDefaultMaterial(engine);\n      renderer.setMaterial(material);\n\n      const { extensions = {} } = gltfMeshPrimitives[i];\n      const { KHR_materials_variants } = extensions;\n      if (KHR_materials_variants) {\n        Parser.parseEngineResource(\"KHR_materials_variants\", KHR_materials_variants, renderer, context);\n      }\n    }\n  }\n\n  private _createAnimator(context: GLTFResource) {\n    const { defaultSceneRoot, animations } = context;\n    if (!animations) return;\n    const animator = defaultSceneRoot.addComponent(Animator);\n    const animatorController = new AnimatorController();\n    const layer = new AnimatorControllerLayer(\"layer\");\n    const animatorStateMachine = new AnimatorStateMachine();\n    animatorController.addLayer(layer);\n    animator.animatorController = animatorController;\n    layer.stateMachine = animatorStateMachine;\n    if (animations) {\n      for (let i = 0; i < animations.length; i++) {\n        const animationClip = animations[i];\n        const name = animationClip.name;\n        const uniqueName = animatorStateMachine.makeUniqueStateName(name);\n        if (uniqueName !== name) {\n          console.warn(`AnimatorState name is existed, name: ${name} reset to ${uniqueName}`);\n        }\n        const animatorState = animatorStateMachine.addState(uniqueName);\n        animatorState.clip = animationClip;\n      }\n    }\n  }\n}\n", "import { Skin } from \"@oasis-engine/core\";\nimport { Matrix } from \"@oasis-engine/math\";\nimport { GLTFResource } from \"../GLTFResource\";\nimport { GLTFUtil } from \"../GLTFUtil\";\nimport { Parser } from \"./Parser\";\n\nexport class SkinParser extends Parser {\n  parse(context: GLTFResource): void {\n    const { gltf, buffers, entities, defaultSceneRoot } = context;\n    const gltfSkins = gltf.skins;\n\n    if (!gltfSkins) return;\n\n    const skins: Skin[] = [];\n\n    for (let i = 0; i < gltfSkins.length; i++) {\n      const { inverseBindMatrices, skeleton, joints, name = `SKIN_${i}` } = gltfSkins[i];\n      const jointCount = joints.length;\n\n      const skin = new Skin(name);\n      skin.inverseBindMatrices.length = jointCount;\n\n      // parse IBM\n      const accessor = gltf.accessors[inverseBindMatrices];\n      const buffer = GLTFUtil.getAccessorData(gltf, accessor, buffers);\n      for (let i = 0; i < jointCount; i++) {\n        const inverseBindMatrix = new Matrix();\n        inverseBindMatrix.setValueByArray(buffer, i * 16);\n        skin.inverseBindMatrices[i] = inverseBindMatrix;\n      }\n\n      // get joints\n      for (let i = 0; i < jointCount; i++) {\n        skin.joints[i] = entities[joints[i]].name;\n      }\n\n      // get skeleton\n      if (skeleton !== undefined) {\n        skin.skeleton = entities[skeleton].name;\n      } else {\n        skin.skeleton = defaultSceneRoot.name;\n      }\n\n      skins[i] = skin;\n    }\n\n    context.skins = skins;\n  }\n}\n", "import { AssetType, Logger, Texture2D, TextureWrapMode } from \"@oasis-engine/core\";\nimport { GLTFResource } from \"../GLTFResource\";\nimport { ISampler } from \"../Schema\";\nimport { GLTFUtil } from \"../GLTFUtil\";\nimport { Parser } from \"./Parser\";\n\nexport class TextureParser extends Parser {\n  private static _wrapMap = {\n    33071: TextureWrapMode.Clamp,\n    33648: TextureWrapMode.Mirror,\n    10497: TextureWrapMode.Repeat\n  };\n\n  parse(context: GLTFResource): void | Promise<void> {\n    const { gltf, buffers, engine, url } = context;\n\n    if (gltf.textures) {\n      return Promise.all(\n        gltf.textures.map(({ sampler, source = 0, name: textureName }, index) => {\n          const { uri, bufferView: bufferViewIndex, mimeType, name: imageName } = gltf.images[source];\n\n          if (uri) {\n            return engine.resourceManager\n              .load<Texture2D>({\n                url: GLTFUtil.parseRelativeUrl(url, uri),\n                type: AssetType.Texture2D\n              })\n              .then((texture) => {\n                if (!texture.name) {\n                  texture.name = textureName || imageName || `texture_${index}`;\n                }\n                if (sampler !== undefined) {\n                  this._parseSampler(texture, gltf.samplers[sampler]);\n                }\n                return texture;\n              });\n          } else {\n            const bufferView = gltf.bufferViews[bufferViewIndex];\n            const bufferViewData = GLTFUtil.getBufferViewData(bufferView, buffers);\n            return GLTFUtil.loadImageBuffer(bufferViewData, mimeType).then((image) => {\n              const texture = new Texture2D(engine, image.width, image.height);\n              texture.setImageSource(image);\n              texture.generateMipmaps();\n              texture.name = textureName || imageName || `texture_${index}`;\n              if (sampler !== undefined) {\n                this._parseSampler(texture, gltf.samplers[sampler]);\n              }\n              return texture;\n            });\n          }\n        })\n      ).then((textures: Texture2D[]) => {\n        context.textures = textures;\n      });\n    }\n  }\n\n  private _parseSampler(texture: Texture2D, sampler: ISampler): void {\n    const { magFilter, minFilter, wrapS, wrapT } = sampler;\n\n    if (magFilter || minFilter) {\n      Logger.warn(\"texture use filterMode in engine\");\n    }\n\n    if (wrapS) {\n      texture.wrapModeU = TextureParser._wrapMap[wrapS];\n    }\n\n    if (wrapT) {\n      texture.wrapModeV = TextureParser._wrapMap[wrapT];\n    }\n  }\n}\n", "import { Logger } from \"@oasis-engine/core\";\nimport { GLTFResource } from \"../GLTFResource\";\nimport { Parser } from \"./Parser\";\n\nexport class Validator extends Parser {\n  parse(context: GLTFResource): void {\n    const {\n      gltf: {\n        asset: { version },\n        extensionsUsed,\n        extensionsRequired\n      }\n    } = context;\n\n    const gltfVersion = Number(version);\n    if (!(gltfVersion >= 2 && gltfVersion < 3)) {\n      throw \"Only support gltf 2.x.\";\n    }\n\n    if (extensionsUsed) {\n      Logger.info(\"extensionsUsed: \", extensionsUsed);\n      for (let i = 0; i < extensionsUsed.length; i++) {\n        if (!Parser.hasExtensionParser(extensionsUsed[i])) {\n          Logger.warn(`Extension ${extensionsUsed[i]} is not implemented, you can customize this extension in gltf.`);\n        }\n      }\n    }\n\n    if (extensionsRequired) {\n      Logger.info(`extensionsRequired: ${extensionsRequired}`);\n      for (let i = 0; i < extensionsRequired.length; i++) {\n        const extensionRequired = extensionsRequired[i];\n\n        if (!Parser.hasExtensionParser(extensionRequired)) {\n          Logger.error(`GLTF parser has not supported required extension ${extensionRequired}.`);\n        } else {\n          Parser.initialize(extensionRequired);\n        }\n      }\n    }\n  }\n}\n", "import { GLTFResource } from \"./GLTFResource\";\nimport { AnimationParser } from \"./parser/AnimationParser\";\nimport { BufferParser } from \"./parser/BufferParser\";\nimport { EntityParser } from \"./parser/EntityParser\";\nimport { MaterialParser } from \"./parser/MaterialParser\";\nimport { MeshParser } from \"./parser/MeshParser\";\nimport { Parser } from \"./parser/Parser\";\nimport { SceneParser } from \"./parser/SceneParser\";\nimport { SkinParser } from \"./parser/SkinParser\";\nimport { TextureParser } from \"./parser/TextureParser\";\nimport { Validator } from \"./parser/Validator\";\n\nexport class GLTFParser {\n  static instance = new GLTFParser([\n    BufferParser,\n    Validator,\n    TextureParser,\n    MaterialParser,\n    MeshParser,\n    EntityParser,\n    SkinParser,\n    AnimationParser,\n    SceneParser\n  ]);\n\n  private _pipes: Parser[] = [];\n\n  private constructor(pipes: (new () => Parser)[]) {\n    pipes.forEach((pipe: new () => Parser, index: number) => {\n      this._pipes[index] = new pipe();\n    });\n  }\n\n  parse(context: GLTFResource): Promise<GLTFResource> {\n    let lastPipe: void | Promise<void>;\n\n    return new Promise((resolve, reject) => {\n      this._pipes.forEach((parser: Parser) => {\n        if (lastPipe) {\n          lastPipe = lastPipe.then(() => {\n            return parser.parse(context);\n          });\n        } else {\n          lastPipe = parser.parse(context);\n        }\n      });\n\n      if (lastPipe) {\n        lastPipe\n          .then(() => {\n            resolve(context);\n          })\n          .catch(reject);\n      } else {\n        resolve(context);\n      }\n    });\n  }\n}\n", "import {\n  AnimationClip,\n  Camera,\n  EngineObject,\n  Entity,\n  Light,\n  Material,\n  ModelMesh,\n  Renderer,\n  Skin,\n  Texture2D\n} from \"@oasis-engine/core\";\nimport { IGLTF } from \"./Schema\";\n\n/**\n * Product after GLTF parser, usually, `defaultSceneRoot` is only needed to use.\n */\nexport class GLTFResource extends EngineObject {\n  /** GLTF file url. */\n  url: string;\n  /** GLTF file content. */\n  gltf: IGLTF;\n  /** ArrayBuffer after BufferParser. */\n  buffers: ArrayBuffer[];\n  /** Oasis Texture2D after TextureParser. */\n  textures?: Texture2D[];\n  /** Oasis Material after MaterialParser. */\n  materials?: Material[];\n  /** Oasis ModelMesh after MeshParser. */\n  meshes?: ModelMesh[][];\n  /** Oasis Skin after SkinParser. */\n  skins?: Skin[];\n  /** Oasis AnimationClip after AnimationParser. */\n  animations?: AnimationClip[];\n  /** Oasis Entity after EntityParser. */\n  entities: Entity[];\n  /** Oasis Camera after SceneParser. */\n  cameras?: Camera[];\n  /** GLTF can export lights in extension KHR_lights_punctual */\n  lights?: Light[];\n  /** Oasis RootEntities after SceneParser. */\n  sceneRoots: Entity[];\n  /** Oasis RootEntity after SceneParser. */\n  defaultSceneRoot: Entity;\n  /** Renderer can replace material by `renderer.setMaterial` if gltf use plugin-in KHR_materials_variants. */\n  variants?: { renderer: Renderer; material: Material; variants: string[] }[];\n}\n", "import { AssetPromise, AssetType, Loader, LoadItem, resourceLoader, ResourceManager } from \"@oasis-engine/core\";\nimport { GLTFParser } from \"./gltf/GLTFParser\";\nimport { GLTFResource } from \"./gltf/GLTFResource\";\n\n@resourceLoader(AssetType.Prefab, [\"gltf\", \"glb\"])\nexport class GLTFLoader extends Loader<GLTFResource> {\n  load(item: LoadItem, resourceManager: ResourceManager): AssetPromise<GLTFResource> {\n    const url = item.url;\n    return new AssetPromise((resolve, reject) => {\n      const resource = new GLTFResource(resourceManager.engine);\n      resource.url = url;\n\n      GLTFParser.instance\n        .parse(resource)\n        .then(resolve)\n        .catch((e) => {\n          console.error(e);\n          reject(`Error loading glTF model from ${url} .`);\n        });\n    });\n  }\n}\n", "import { resourceLoader, Loader, AssetPromise, AssetType, LoadItem } from \"@oasis-engine/core\";\n\n@resourceLoader(AssetType.JSON, [\"json\"], false)\nclass JSONLoader extends Loader<string> {\n  load(item: LoadItem): AssetPromise<string> {\n    return this.request(item.url, {\n      ...item,\n      type: \"json\"\n    });\n  }\n}\n", "/**\n *\n * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts\n */\n\nimport { TextureFormat } from \"@oasis-engine/core\";\nimport { GLCompressedTextureInternalFormat } from \"@oasis-engine/rhi-webgl\";\nimport { KTXContainer, Mipmap } from \"./type\";\n\nconst HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)\n\n// load types\nconst COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\nconst COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\nconst TEX_2D = 2; // uses a gl.texImage2D()\nconst TEX_3D = 3; // uses a gl.texImage3D()\n\nfunction getMipmaps(ktxContainer: KTXContainer, loadMipmaps: boolean): Mipmap[] {\n  const mipmaps = [];\n\n  // initialize width & height for level 1\n  var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;\n  var width = ktxContainer.pixelWidth;\n  var height = ktxContainer.pixelHeight;\n  var mipmapCount = loadMipmaps ? ktxContainer.numberOfMipmapLevels : 1;\n\n  for (var level = 0; level < mipmapCount; level++) {\n    var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps\n    dataOffset += 4; // size of the image + 4 for the imageSize field\n\n    for (var face = 0; face < ktxContainer.numberOfFaces; face++) {\n      var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);\n\n      mipmaps.push({ data: byteArray, width: width, height: height });\n\n      dataOffset += imageSize;\n      dataOffset += 3 - ((imageSize + 3) % 4); // add padding for odd sized image\n    }\n    width = Math.max(1.0, width * 0.5);\n    height = Math.max(1.0, height * 0.5);\n  }\n\n  return mipmaps;\n}\n\n/**\n * Checks if the given data starts with a KTX file identifier.\n * @param data the data to check\n * @returns true if the data is a KTX file or false otherwise\n */\nfunction isValid(data: ArrayBuffer): boolean {\n  if (data.byteLength >= 12) {\n    // '\u00AB', 'K', 'T', 'X', ' ', '1', '1', '\u00BB', '\\r', '\\n', '\\x1A', '\\n'\n    const identifier = new Uint8Array(data, 0, 12);\n    if (\n      identifier[0] === 0xab &&\n      identifier[1] === 0x4b &&\n      identifier[2] === 0x54 &&\n      identifier[3] === 0x58 &&\n      identifier[4] === 0x20 &&\n      identifier[5] === 0x31 &&\n      identifier[6] === 0x31 &&\n      identifier[7] === 0xbb &&\n      identifier[8] === 0x0d &&\n      identifier[9] === 0x0a &&\n      identifier[10] === 0x1a &&\n      identifier[11] === 0x0a\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getEngineFormat(internalFormat: GLint): TextureFormat {\n  switch (internalFormat) {\n    // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT3_EXT:\n    // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:\n    // break;\n    case GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:\n      return TextureFormat.DXT1;\n    case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:\n      return TextureFormat.DXT5;\n    case GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:\n      return TextureFormat.ETC1_RGB;\n    case GLCompressedTextureInternalFormat.RGB8_ETC2:\n      return TextureFormat.ETC2_RGB;\n    case GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:\n      return TextureFormat.ETC2_RGBA5;\n    case GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:\n      return TextureFormat.ETC2_RGBA8;\n    case GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:\n      return TextureFormat.PVRTC_RGB2;\n    case GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:\n      return TextureFormat.PVRTC_RGBA2;\n    case GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:\n      return TextureFormat.PVRTC_RGB4;\n    case GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:\n      return TextureFormat.PVRTC_RGBA4;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:\n      return TextureFormat.ASTC_4x4;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:\n      return TextureFormat.ASTC_5x5;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:\n      return TextureFormat.ASTC_6x6;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:\n      return TextureFormat.ASTC_8x8;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:\n      return TextureFormat.ASTC_10x10;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:\n      return TextureFormat.ASTC_12x12;\n    default:\n      const formatName: any = GLCompressedTextureInternalFormat[internalFormat];\n      throw new Error(`this format is not supported in Oasis Engine: ${formatName}`);\n  }\n}\n/**\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\n */\nexport const khronosTextureContainerParser = {\n  /**\n   *\n   * @param buffer contents of the KTX container file\n   * @param facesExpected should be either 1 or 6, based whether a cube texture or or\n   * @param threeDExpected provision for indicating that data should be a 3D texture, not implemented\n   * @param textureArrayExpected provision for indicating that data should be a texture array, not implemented\n   * @param mapEngineFormat get Oasis Engine native TextureFormat?\n   */\n  parse(\n    buffer: ArrayBuffer,\n    facesExpected: number,\n    withMipmaps: boolean,\n    mapEngineFormat: boolean = false\n  ): KTXContainer {\n    if (!isValid(buffer)) {\n      throw new Error(\"khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier\");\n    }\n\n    // load the reset of the header in native 32 bit uint\n    const dataSize = Uint32Array.BYTES_PER_ELEMENT;\n    const headerDataView = new DataView(buffer, 12, 13 * dataSize);\n    const endianness = headerDataView.getUint32(0, true);\n    const littleEndian = endianness === 0x04030201;\n\n    const parsedResult: KTXContainer = {\n      buffer: buffer,\n      glType: headerDataView.getUint32(1 * dataSize, littleEndian), // must be 0 for compressed textures\n      glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian), // must be 1 for compressed textures\n      glFormat: headerDataView.getUint32(3 * dataSize, littleEndian), // must be 0 for compressed textures\n      glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian), // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\n      glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian), // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\n      pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian), // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\n      pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian), // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\n      pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian), // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\n      numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian), // used for texture arrays\n      numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian), // used for cubemap textures, should either be 1 or 6\n      numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian), // number of levels; disregard possibility of 0 for compressed textures\n      bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian), // the amount of space after the header for meta-data\n      // would need to make this more elaborate & adjust checks above to support more than one load type\n      loadType: COMPRESSED_2D\n    };\n\n    // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\n    if (parsedResult.glType !== 0) {\n      throw new Error(\"only compressed formats currently supported\");\n    } else {\n      // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\n      parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);\n    }\n\n    if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {\n      throw new Error(\"only 2D textures currently supported\");\n    }\n\n    if (parsedResult.numberOfArrayElements !== 0) {\n      throw new Error(\"texture arrays not currently supported\");\n    }\n\n    if (parsedResult.numberOfFaces !== facesExpected) {\n      throw new Error(\"number of faces expected\" + facesExpected + \", but found \" + parsedResult.numberOfFaces);\n    }\n\n    if (withMipmaps) {\n      parsedResult.mipmaps = getMipmaps(parsedResult, true);\n    }\n\n    if (mapEngineFormat) {\n      parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);\n    }\n    return parsedResult;\n  }\n};\n", "import { CompressedTextureData, CompressedCubeData } from \"./type\";\nimport { khronosTextureContainerParser } from \"./KhronosTextureContainer\";\nimport { TextureFormat } from \"@oasis-engine/core\";\n\nexport function parseSingleKTX(data: ArrayBuffer): CompressedTextureData {\n  const ktx = khronosTextureContainerParser.parse(data, 1, true, true);\n  return {\n    mipmaps: ktx.mipmaps,\n    engineFormat: ktx.engineFormat,\n    internalFormat: ktx.glInternalFormat,\n    width: ktx.pixelWidth,\n    height: ktx.pixelHeight\n  };\n}\n\nexport function parseCubeKTX(dataArray: ArrayBuffer[]): CompressedCubeData {\n  const mipmapsFaces = [];\n  let internalFormat: number;\n  let engineFormat: TextureFormat;\n  let width: number;\n  let height: number;\n  for (let i = 0; i < dataArray.length; i++) {\n    const ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);\n    mipmapsFaces.push(ktx.mipmaps);\n    if (i === 0) {\n      width = ktx.pixelWidth;\n      height = ktx.pixelHeight;\n      internalFormat = ktx.glInternalFormat;\n      engineFormat = ktx.engineFormat;\n    }\n  }\n  return {\n    mipmapsFaces,\n    engineFormat,\n    internalFormat,\n    width,\n    height\n  };\n}\n", "import {\n  AssetPromise,\n  AssetType,\n  Loader,\n  LoadItem,\n  resourceLoader,\n  ResourceManager,\n  TextureCubeFace,\n  TextureCubeMap\n} from \"@oasis-engine/core\";\nimport { parseCubeKTX } from \"./compressed-texture\";\n\n@resourceLoader(AssetType.KTXCube, [])\nclass KTXCubeLoader extends Loader<TextureCubeMap> {\n  load(item: LoadItem, resourceManager: ResourceManager): AssetPromise<TextureCubeMap> {\n    return new AssetPromise((resolve, reject) => {\n      Promise.all(\n        item.urls.map((url) =>\n          this.request<ArrayBuffer>(url, {\n            ...item,\n            type: \"arraybuffer\"\n          })\n        )\n      )\n        .then((data) => {\n          const parsedData = parseCubeKTX(data);\n          const { width, mipmapsFaces, engineFormat } = parsedData;\n          const mipmap = mipmapsFaces[0].length > 1;\n          const texture = new TextureCubeMap(resourceManager.engine, width, engineFormat, mipmap);\n\n          for (let face = 0; face < 6; face++) {\n            const length = mipmapsFaces[face].length;\n\n            for (let miplevel = 0; miplevel < length; miplevel++) {\n              const { data, width, height } = mipmapsFaces[face][miplevel];\n\n              texture.setPixelBuffer(TextureCubeFace.PositiveX + face, data, miplevel, 0, 0, width, height);\n            }\n          }\n\n          resolve(texture);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n}\n", "import {\n  AssetPromise,\n  AssetType,\n  Loader,\n  LoadItem,\n  resourceLoader,\n  ResourceManager,\n  Texture2D\n} from \"@oasis-engine/core\";\nimport { parseSingleKTX } from \"./compressed-texture\";\n\n@resourceLoader(AssetType.KTX, [\"ktx\"])\nexport class KTXLoader extends Loader<Texture2D> {\n  load(item: LoadItem, resourceManager: ResourceManager): AssetPromise<Texture2D> {\n    return new AssetPromise((resolve, reject) => {\n      this.request<ArrayBuffer>(item.url, {\n        ...item,\n        type: \"arraybuffer\"\n      })\n        .then((bin) => {\n          const parsedData = parseSingleKTX(bin);\n          const { width, height, mipmaps, engineFormat } = parsedData;\n          const mipmap = mipmaps.length > 1;\n          const texture = new Texture2D(resourceManager.engine, width, height, engineFormat, mipmap);\n\n          for (let miplevel = 0; miplevel < mipmaps.length; miplevel++) {\n            const { width, height, data } = mipmaps[miplevel];\n            texture.setPixelBuffer(data, miplevel, 0, 0, width, height);\n          }\n\n          resolve(texture);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n}\n", "import {\n  AssetPromise,\n  AssetType,\n  Loader,\n  LoadItem,\n  resourceLoader,\n  ResourceManager,\n  Texture2D\n} from \"@oasis-engine/core\";\n\n@resourceLoader(AssetType.Texture2D, [\"png\", \"jpg\", \"webp\", \"jpeg\"])\nclass Texture2DLoader extends Loader<Texture2D> {\n  load(item: LoadItem, resourceManager: ResourceManager): AssetPromise<Texture2D> {\n    return new AssetPromise((resolve, reject) => {\n      this.request<HTMLImageElement>(item.url, {\n        ...item,\n        type: \"image\"\n      })\n        .then((image) => {\n          const texture = new Texture2D(resourceManager.engine, image.width, image.height);\n          /** @ts-ignore */\n          if (!texture._platformTexture) return;\n          texture.setImageSource(image);\n          texture.generateMipmaps();\n\n          if (item.url.indexOf(\"data:\") !== 0) {\n            const splitPath = item.url.split(\"/\");\n            texture.name = splitPath[splitPath.length - 1];\n          }\n          resolve(texture);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n}\n", "import {\n  AssetPromise,\n  AssetType,\n  Loader,\n  LoadItem,\n  resourceLoader,\n  ResourceManager,\n  TextureCubeFace,\n  TextureCubeMap\n} from \"@oasis-engine/core\";\n\n@resourceLoader(AssetType.TextureCube, [\"\"])\nclass TextureCubeLoader extends Loader<TextureCubeMap> {\n  load(item: LoadItem, resourceManager: ResourceManager): AssetPromise<TextureCubeMap> {\n    return new AssetPromise((resolve, reject) => {\n      Promise.all(\n        item.urls.map((url) =>\n          this.request<HTMLImageElement>(url, {\n            ...item,\n            type: \"image\"\n          })\n        )\n      )\n        .then((images) => {\n          const { width, height } = images[0];\n\n          if (width !== height) {\n            console.error(\"The cube texture must have the same width and height\");\n            return;\n          }\n\n          const tex = new TextureCubeMap(resourceManager.engine, width);\n\n          /** @ts-ignore */\n          if (!tex._platformTexture) return;\n\n          for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n            tex.setImageSource(TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);\n          }\n\n          tex.generateMipmaps();\n          resolve(tex);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n}\n", "import {\n  resourceLoader,\n  Loader,\n  AssetPromise,\n  AssetType,\n  LoadItem,\n  ResourceManager,\n  Texture2D,\n  Sprite,\n  SpriteAtlas\n} from \"@oasis-engine/core\";\nimport { AtlasConfig } from \"@oasis-engine/core/types/2d/atlas/types\";\nimport { Rect, Vector2 } from \"@oasis-engine/math\";\nimport { GLTFUtil } from \"./gltf/GLTFUtil\";\n\n@resourceLoader(AssetType.SpriteAtlas, [\"atlas\"], false)\nclass SpriteAtlasLoader extends Loader<SpriteAtlas> {\n  load(item: LoadItem, resourceManager: ResourceManager): AssetPromise<SpriteAtlas> {\n    return new AssetPromise((resolve, reject) => {\n      this.request<AtlasConfig>(item.url, {\n        ...item,\n        type: \"json\"\n      })\n        .then((atlasData) => {\n          const { atlasItems, format } = atlasData;\n          const atlasItemsLen = atlasItems.length;\n          Promise.all(\n            atlasItems.map(({ img }) =>\n              this.request<HTMLImageElement>(GLTFUtil.parseRelativeUrl(item.url, img), {\n                ...item,\n                type: \"image\"\n              })\n            )\n          ).then((imgs) => {\n            const { engine } = resourceManager;\n            // Generate a SpriteAtlas object.\n            const tempRect = new Rect();\n            const tempVect2 = new Vector2();\n            const spriteAtlas = new SpriteAtlas(engine);\n            for (let i = 0; i < atlasItemsLen; i++) {\n              // Generate Texture2D according to configuration.\n              const originalImg = imgs[i];\n              const { width, height } = originalImg;\n              const texture = new Texture2D(engine, width, height, format);\n              texture.setImageSource(originalImg);\n              texture.generateMipmaps();\n              // Generate all the sprites on this texture.\n              const atlasItem = atlasItems[i];\n              const sprites = atlasItem.sprites;\n              const sourceWidthReciprocal = 1.0 / width;\n              const sourceHeightReciprocal = 1.0 / height;\n              for (let j = sprites.length - 1; j >= 0; j--) {\n                const atlasSprite = sprites[j];\n                const { region, pivot, atlasRegionOffset, atlasRegion, id } = atlasSprite;\n                const sprite = new Sprite(\n                  engine,\n                  texture,\n                  region ? tempRect.setValue(region.x, region.y, region.w, region.h) : undefined,\n                  pivot ? tempVect2.setValue(pivot.x, pivot.y) : undefined,\n                  atlasSprite.pixelsPerUnit || undefined,\n                  atlasSprite.name\n                );\n                sprite.atlasRegion.setValue(\n                  atlasRegion.x * sourceWidthReciprocal,\n                  atlasRegion.y * sourceHeightReciprocal,\n                  atlasRegion.w * sourceWidthReciprocal,\n                  atlasRegion.h * sourceHeightReciprocal\n                );\n                atlasSprite.atlasRotated && (sprite.atlasRotated = true);\n                if (atlasRegionOffset) {\n                  const { x: offsetLeft, y: offsetTop, z: offsetRight, w: offsetBottom } = atlasRegionOffset;\n                  let originalWReciprocal: number, originalHReciprocal: number;\n                  if (atlasSprite.atlasRotated) {\n                    originalWReciprocal = 1 / (offsetLeft + atlasRegion.h + offsetRight);\n                    originalHReciprocal = 1 / (offsetTop + atlasRegion.w + offsetBottom);\n                  } else {\n                    originalWReciprocal = 1 / (offsetLeft + atlasRegion.w + offsetRight);\n                    originalHReciprocal = 1 / (offsetTop + atlasRegion.h + offsetBottom);\n                  }\n                  sprite.atlasRegionOffset.setValue(\n                    offsetLeft * originalWReciprocal,\n                    offsetTop * originalHReciprocal,\n                    offsetRight * originalWReciprocal,\n                    offsetBottom * originalHReciprocal\n                  );\n                }\n                if (id !== undefined) {\n                  // @ts-ignore\n                  sprite._assetID = id;\n                }\n                // @ts-ignore\n                spriteAtlas._addSprite(sprite);\n              }\n            }\n            resolve(spriteAtlas);\n          });\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n}\n", "import { EngineObject } from \"@oasis-engine/core\";\nimport { GLTFResource } from \"../GLTFResource\";\nimport { ExtensionSchema } from \"./Schema\";\n\nexport abstract class ExtensionParser {\n  initialize(): void {}\n\n  parseEngineResource(\n    schema: ExtensionSchema,\n    parseResource: EngineObject,\n    context: GLTFResource,\n    ...extra\n  ): void | Promise<void> {}\n\n  createEngineResource(schema: ExtensionSchema, context: GLTFResource, ...extra): EngineObject | Promise<EngineObject> {\n    return null;\n  }\n}\n", "import { DRACODecoder } from \"@oasis-engine/draco\";\nimport { GLTFResource } from \"../GLTFResource\";\nimport { GLTFUtil } from \"../GLTFUtil\";\nimport { registerExtension } from \"../parser/Parser\";\nimport { IMeshPrimitive } from \"../Schema\";\nimport { ExtensionParser } from \"./ExtensionParser\";\nimport { IKHRDracoMeshCompression } from \"./Schema\";\n\n@registerExtension(\"KHR_draco_mesh_compression\")\nclass KHR_draco_mesh_compression extends ExtensionParser {\n  private static _decoder: DRACODecoder;\n\n  initialize(): void {\n    if (!KHR_draco_mesh_compression._decoder) {\n      KHR_draco_mesh_compression._decoder = new DRACODecoder();\n    }\n  }\n\n  createEngineResource(schema: IKHRDracoMeshCompression, context: GLTFResource, gltfPrimitive: IMeshPrimitive) {\n    const { gltf, buffers } = context;\n    const { bufferViews, accessors } = gltf;\n    const { bufferView: bufferViewIndex, attributes: gltfAttributeMap } = schema;\n\n    const attributeMap = {};\n    const attributeTypeMap = {};\n    for (let attributeName in gltfAttributeMap) {\n      attributeMap[attributeName] = gltfAttributeMap[attributeName];\n    }\n    for (let attributeName in gltfPrimitive.attributes) {\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        const accessorDef = accessors[gltfPrimitive.attributes[attributeName]];\n        attributeTypeMap[attributeName] = GLTFUtil.getComponentType(accessorDef.componentType).name;\n      }\n    }\n    const indexAccessor = accessors[gltfPrimitive.indices];\n    const indexType = GLTFUtil.getComponentType(indexAccessor.componentType).name;\n    const taskConfig = {\n      attributeIDs: attributeMap,\n      attributeTypes: attributeTypeMap,\n      useUniqueIDs: true,\n      indexType\n    };\n    const buffer = GLTFUtil.getBufferViewData(bufferViews[bufferViewIndex], buffers);\n    return KHR_draco_mesh_compression._decoder.decode(buffer, taskConfig).then((parsedGeometry) => parsedGeometry);\n  }\n}\n", "import { DirectLight, Entity, PointLight, SpotLight } from \"@oasis-engine/core\";\nimport { GLTFResource } from \"../GLTFResource\";\nimport { registerExtension } from \"../parser/Parser\";\nimport { ExtensionParser } from \"./ExtensionParser\";\nimport { IKHRLightsPunctual_Light } from \"./Schema\";\n\n@registerExtension(\"KHR_lights_punctual\")\nclass KHR_lights_punctual extends ExtensionParser {\n  parseEngineResource(schema: IKHRLightsPunctual_Light, entity: Entity, context: GLTFResource): void {\n    const { color, intensity = 1, type, range, spot } = schema;\n    let light: DirectLight | PointLight | SpotLight;\n\n    if (type === \"directional\") {\n      light = entity.addComponent(DirectLight);\n    } else if (type === \"point\") {\n      light = entity.addComponent(PointLight);\n    } else if (type === \"spot\") {\n      light = entity.addComponent(SpotLight);\n    }\n\n    if (color) {\n      light.color.setValue(color[0], color[1], color[2], 1);\n    }\n\n    light.intensity = intensity;\n\n    if (range && !(light instanceof DirectLight)) {\n      light.distance = range;\n    }\n\n    if (spot && light instanceof SpotLight) {\n      const { innerConeAngle = 0, outerConeAngle = Math.PI / 4 } = spot;\n\n      light.angle = innerConeAngle;\n      light.penumbra = outerConeAngle - innerConeAngle;\n    }\n\n    if (!context.lights) context.lights = [];\n    context.lights.push(light);\n  }\n}\n", "import { PBRSpecularMaterial } from \"@oasis-engine/core\";\nimport { Color } from \"@oasis-engine/math\";\nimport { GLTFResource } from \"../GLTFResource\";\nimport { MaterialParser } from \"../parser/MaterialParser\";\nimport { registerExtension } from \"../parser/Parser\";\nimport { ExtensionParser } from \"./ExtensionParser\";\nimport { IKHRMaterialsPbrSpecularGlossiness } from \"./Schema\";\n\n@registerExtension(\"KHR_materials_pbrSpecularGlossiness\")\nclass KHR_materials_pbrSpecularGlossiness extends ExtensionParser {\n  createEngineResource(schema: IKHRMaterialsPbrSpecularGlossiness, context: GLTFResource): PBRSpecularMaterial {\n    const { engine, textures } = context;\n    const material = new PBRSpecularMaterial(engine);\n    const { diffuseFactor, diffuseTexture, specularFactor, glossinessFactor, specularGlossinessTexture } = schema;\n\n    if (diffuseFactor) {\n      material.baseColor = new Color(...diffuseFactor);\n    }\n\n    if (diffuseTexture) {\n      material.baseTexture = textures[diffuseTexture.index];\n      MaterialParser._parseTextureTransform(material, diffuseTexture.extensions, context);\n    }\n\n    if (specularFactor) {\n      material.specularColor = new Color(...specularFactor);\n    }\n\n    if (glossinessFactor !== undefined) {\n      material.glossiness = glossinessFactor;\n    }\n\n    if (specularGlossinessTexture) {\n      material.specularGlossinessTexture = textures[specularGlossinessTexture.index];\n      MaterialParser._parseTextureTransform(material, specularGlossinessTexture.extensions, context);\n    }\n\n    return material;\n  }\n}\n", "import { UnlitMaterial } from \"@oasis-engine/core\";\nimport { GLTFResource } from \"../GLTFResource\";\nimport { registerExtension } from \"../parser/Parser\";\nimport { ExtensionParser } from \"./ExtensionParser\";\nimport { IKHRMaterialsUnlit } from \"./Schema\";\n\n@registerExtension(\"KHR_materials_unlit\")\nclass KHR_materials_unlit extends ExtensionParser {\n  createEngineResource(schema: IKHRMaterialsUnlit, context: GLTFResource): UnlitMaterial {\n    const { engine } = context;\n    const material = new UnlitMaterial(engine);\n\n    return material;\n  }\n}\n", "import { Renderer } from \"@oasis-engine/core\";\nimport { GLTFResource } from \"../GLTFResource\";\nimport { registerExtension } from \"../parser/Parser\";\nimport { ExtensionParser } from \"./ExtensionParser\";\nimport { IKHRMaterialVariants_Mapping } from \"./Schema\";\n\n@registerExtension(\"KHR_materials_variants\")\nclass KHR_materials_variants extends ExtensionParser {\n  parseEngineResource(schema: IKHRMaterialVariants_Mapping, renderer: Renderer, context: GLTFResource): void {\n    const {\n      gltf: {\n        extensions: {\n          KHR_materials_variants: { variants: variantNames }\n        }\n      },\n      materials\n    } = context;\n    const { mappings } = schema;\n\n    for (let i = 0; i < mappings.length; i++) {\n      const { material, variants } = mappings[i];\n      if (!context.variants) context.variants = [];\n      context.variants.push({\n        renderer,\n        material: materials[material],\n        variants: variants.map((index) => variantNames[index].name)\n      });\n    }\n  }\n}\n", "import { registerExtension } from \"../parser/Parser\";\nimport { ExtensionParser } from \"./ExtensionParser\";\n\n@registerExtension(\"KHR_mesh_quantization\")\nclass KHR_mesh_quantization extends ExtensionParser {}\n", "import { Logger, PBRBaseMaterial, UnlitMaterial } from \"@oasis-engine/core\";\nimport { GLTFResource } from \"../GLTFResource\";\nimport { registerExtension } from \"../parser/Parser\";\nimport { ExtensionParser } from \"./ExtensionParser\";\nimport { IKHRTextureTransform } from \"./Schema\";\n\n@registerExtension(\"KHR_texture_transform\")\nclass KHR_texture_transform extends ExtensionParser {\n  parseEngineResource(\n    schema: IKHRTextureTransform,\n    material: PBRBaseMaterial | UnlitMaterial,\n    context: GLTFResource\n  ): void {\n    const { offset, rotation, scale, texCoord } = schema;\n\n    if (offset) {\n      material.tilingOffset.z = offset[0];\n      material.tilingOffset.w = offset[1];\n    }\n\n    if (scale) {\n      material.tilingOffset.x = scale[0];\n      material.tilingOffset.y = scale[1];\n    }\n\n    if (rotation) {\n      Logger.warn(\"rotation in KHR_texture_transform is not supported now\");\n    }\n\n    if (texCoord) {\n      Logger.warn(\"texCoord in KHR_texture_transform is not supported now\");\n    }\n  }\n}\n", "import { Animator, AnimatorController, AnimatorState, Component, Entity, UpdateFlag } from \"@oasis-engine/core\";\nimport { GLTFResource } from \"../gltf/GLTFResource\";\n\n/**\n * @deprecated\n * Temporarily only for editor use.\n * Remove when editor finish change from gltf to prefab.\n */\nexport class GLTFModel extends Component {\n  private _animatorController: AnimatorController;\n  private _speed: number = 1.0;\n  private _animator: Animator;\n  private _asset: GLTFResource;\n  private _glTFEntity: Entity;\n  private _clipPreview: string;\n  private _hasBuiltNode: boolean = false;\n  private _controllerUpdateFlag: UpdateFlag;\n\n  get asset() {\n    return this._asset;\n  }\n\n  set asset(value: GLTFResource) {\n    const { _animatorController: animatorController, _speed: speed } = this;\n    const entity = this._glTFEntity;\n    if (value && value.defaultSceneRoot === this._glTFEntity) {\n      return;\n    }\n    if (!this._hasBuiltNode) {\n      entity.clearChildren();\n      if (value !== null) {\n        entity?.destroy();\n        const gltfEntity = value.defaultSceneRoot.clone();\n        this._animator = gltfEntity.getComponent(Animator);\n        this.entity.addChild(gltfEntity);\n        gltfEntity.isActive = this.enabled;\n        this._glTFEntity = gltfEntity;\n      }\n    }\n    if (animatorController) {\n      this._animator.animatorController = animatorController;\n      this._animator.speed = speed;\n      this._playState();\n    }\n    this._asset = value;\n  }\n\n  get animatorController(): AnimatorController {\n    return this._animatorController;\n  }\n\n  set animatorController(animatorController: AnimatorController) {\n    const { _animator: animator } = this;\n    if (animatorController !== this._animatorController) {\n      this._controllerUpdateFlag && this._controllerUpdateFlag.destroy();\n      // @ts-ignore\n      this._controllerUpdateFlag = animatorController && animatorController._registerChangeFlag();\n      this._animatorController = animatorController;\n      if (animator) {\n        animator.animatorController = animatorController;\n        this._playState();\n      }\n    }\n  }\n\n  get speed(): number {\n    return this._speed;\n  }\n\n  set speed(speed: number) {\n    const { _animator: animator } = this;\n    this._speed = speed;\n    if (animator) {\n      animator.speed = speed;\n      this._playState();\n    }\n  }\n\n  get animator() {\n    return this._animator;\n  }\n\n  get clipPreview() {\n    return this._clipPreview;\n  }\n\n  set clipPreview(value: string) {\n    if (this._animator) {\n      if (value) {\n        this._animator.play(value, 0);\n      } else {\n        this._playDefaultState();\n      }\n    }\n    this._clipPreview = value;\n  }\n\n  constructor(entity) {\n    super(entity);\n  }\n\n  /**\n   * Init.\n   * @param props - Init props\n   */\n  init(props): void {\n    const { asset = null, speed, animatorController, clipPreview,  isClone } = props;\n    if (isClone) {\n      const rootName = (props as any).gltfRootName;\n      if (rootName) {\n        this._glTFEntity = this.entity.findByName(rootName);\n      }\n    }\n    if (!this._glTFEntity) {\n      const rootName = `GLTF-${Date.now()}`;\n      (props as any).gltfRootName = rootName;\n      this._glTFEntity = this.entity.createChild(rootName);\n      this._hasBuiltNode = false;\n    } else {\n      this._hasBuiltNode = true;\n    }\n\n    this.asset = asset;\n    this.animatorController = animatorController;\n    this.speed = speed;\n    this.clipPreview = clipPreview;\n  }\n\n  update() {\n    if (this._animator) {\n      if (this._controllerUpdateFlag?.flag) {\n        this._playState();\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  _onEnable(): void {\n    this._glTFEntity && (this._glTFEntity.isActive = true);\n    this.engine._componentsManager.addOnUpdateAnimations(this);\n  }\n\n  /**\n   * @override\n   */\n  _onDisable(): void {\n    this._glTFEntity && (this._glTFEntity.isActive = false);\n    this.engine._componentsManager.removeOnUpdateAnimations(this);\n  }\n\n  _playState() {\n    const playStateName = this._clipPreview;\n    if (playStateName) {\n      this._animator.play(playStateName, 0);\n      if (this._controllerUpdateFlag?.flag) {\n        this._controllerUpdateFlag.flag = false;\n      }\n    } else {\n      this._playDefaultState();\n    }\n  }\n\n  _playDefaultState() {\n    const { _animatorController: animatorController, _animator: animator } = this;\n    if (!animator) return;\n    if (animatorController) {\n      const { layers } = animatorController;\n      for (let i = 0, length = layers.length; i < length; ++i) {\n        //@ts-ignore\n        const defaultState = layers[i]?.stateMachine?._defaultState ?? layers[i]?.stateMachine?.states[0];\n        const defaultStateName = defaultState?.name;\n        if (defaultStateName) {\n          animator.play(defaultStateName, i);\n          if (this._controllerUpdateFlag?.flag) {\n            this._controllerUpdateFlag.flag = false;\n          }\n        }\n      }\n    }\n  }\n}\n", "import { BlinnPhongMaterial, Entity, MeshRenderer, PrimitiveMesh } from \"@oasis-engine/core\";\n\n// Only for editor\nexport class Model extends MeshRenderer {\n  private _props: Object = null;\n\n  constructor(entity: Entity) {\n    super(entity);\n    this.setMaterial(new BlinnPhongMaterial(this.engine));\n  }\n\n  get material(): any {\n    return this.getMaterial();\n  }\n\n  set material(mtl: any) {\n    this.setMaterial(mtl);\n  }\n\n  setProps(props: any = {}) {\n    if (this._props !== props) {\n      this._props = props;\n    }\n\n    switch (props.geometryType) {\n      case \"Sphere\":\n        this.mesh = PrimitiveMesh.createSphere(this._engine, props.sphereRadius, props.sphereSegments);\n        break;\n\n      case \"Cylinder\":\n        this.mesh = PrimitiveMesh.createCylinder(\n          this._engine,\n          props.cylinderRadiusTop,\n          props.cylinderRadiusBottom,\n          props.cylinderHeight,\n          props.cylinderRadialSegments,\n          props.cylinderHeightSegments\n        );\n        break;\n\n      case \"Plane\":\n        this.mesh = PrimitiveMesh.createPlane(\n          this._engine,\n          props.planeWidth,\n          props.planeHeight,\n          props.planeHorizontalSegments,\n          props.planeVerticalSegments\n        );\n        break;\n\n      case \"Box\":\n        this.mesh = PrimitiveMesh.createCuboid(this._engine, props.boxWidth, props.boxHeight, props.boxDepth);\n        break;\n    }\n  }\n\n  updateProp(key: string, value: string | number) {\n    const props = this._props;\n    props[key] = value;\n    this.setProps(props);\n  }\n}\n", "import { Component, Entity } from \"@oasis-engine/core\";\nimport { Oasis } from \"../Oasis\";\nimport { SchemaResource } from \"../resources\";\nimport { Plugin } from \"./Plugin\";\nexport class PluginManager implements PluginHook {\n  private registeredPlugins: Set<Plugin> = new Set();\n  private plugins: PluginHook[] = [];\n\n  register(plugin: Plugin) {\n    this.registeredPlugins.add(plugin);\n  }\n\n  boot(oasis: Oasis) {\n    for (let plugin of this.registeredPlugins.values()) {\n      if (typeof plugin === \"function\") {\n        plugin = plugin(oasis);\n      }\n      this.plugins.push(plugin);\n    }\n  }\n\n  reset() {\n    this.registeredPlugins.clear();\n    this.plugins = [];\n  }\n\n  nodeAdded(entity: Entity) {\n    this.delegateMethod(\"nodeAdded\", entity);\n  }\n\n  private delegateMethod(name: keyof PluginHook, ...args) {\n    this.plugins.forEach((plugin) => plugin[name] && (plugin[name] as any)(...args));\n  }\n}\n\nexport interface PluginHook {\n  oasis?: Oasis;\n  nodeAdded?(entity: Entity): any;\n  beforeNodeUpdated?(id: string, key: string, value: any): any;\n  nodeUpdated?(updateConfig?: { id: string; key: string; value: any }): any;\n  abilityAdded?(ability: Component): any;\n  beforeAbilityAdded?(config: any): any;\n  beforeAbilityUpdated?(id: string, key: string, value: any): any;\n  abilityUpdated?(updateConfig?: { id: string; key: string; value: any }): any;\n  schemaParsed?(): any;\n  abilityDeleted?(id: string): any;\n  beforeAbilityDeleted?(id: string): any;\n  beforeNodeDeleted?(config: any): any;\n  beforeResourceRemove?(id: string): any;\n  resourceUpdated?(info: { resource: SchemaResource; id: string; key: string; value: any }): any;\n  beforeResourceUpdate?(id: string, key: string, value: any): any;\n  // todo type\n  beforeResourceAdd?(resource: any): any;\n  resourceAdded?(resource: any): any;\n  beforeSceneUpdated?(field: string, key: string, value: any): any;\n  sceneUpdated?(updateConfig?: { type: string; key: string; value: any }): any;\n}\n\nexport function pluginHook(options: Partial<{ before: keyof PluginHook; after: keyof PluginHook }>): MethodDecorator {\n  return function (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<any>) {\n    const method = descriptor.value;\n\n    descriptor.value = function (...args: any[]) {\n      options.before && this.oasis.pluginManager.delegateMethod(options.before, ...args);\n      return Promise.resolve(method.apply(this, arguments)).then((returnObj) => {\n        options.after && this.oasis.pluginManager.delegateMethod(options.after, returnObj);\n        return returnObj;\n      });\n    };\n  };\n}\n", "import { Color, Vector2, Vector3, Vector4, SphericalHarmonics3 } from \"@oasis-engine/math\";\n\n/**\n * temp compa\n * @param config\n */\nexport function compatibleToV2(config) {\n  const { abilities = {}, assets = {}, scene = {} } = config;\n  const ids = Object.keys(abilities);\n  const assetKeys = Object.keys(assets);\n  const sceneKeys = Object.keys(scene || {});\n\n  for (let i = 0, l = ids.length; i < l; ++i) {\n    handleComponents(abilities[ids[i]].props);\n  }\n\n  for (let i = 0, l = assetKeys.length; i < l; ++i) {\n    handleAssets(assets[assetKeys[i]].props);\n  }\n\n  for (let i = 0, l = sceneKeys.length; i < l; ++i) {\n    handleSceneProps(scene[sceneKeys[i]].props);\n  }\n\n  return config;\n}\n\n// TODO temp\nfunction handleComponents(props) {\n  const keys = Object.keys(props);\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const k = keys[i];\n    const v = props[k];\n\n    if (Array.isArray(v) && typeof v[0] !== \"object\") {\n      if ([\"color\", \"diffuseColor\", \"specularColor\"].indexOf(k) !== -1) {\n        props[k] = new Color(v[0], v[1], v[2], v[3]);\n      } else if (v.length === 4) {\n        props[k] = new Vector4(v[0], v[1], v[2], v[3]);\n      } else if (v.length === 3) {\n        props[k] = new Vector3(v[0], v[1], v[2]);\n      } else if (v.length === 2) {\n        props[k] = new Vector2(v[0], v[1]);\n      }\n    }\n  }\n}\n\nconst sh = new SphericalHarmonics3();\n\nfunction handleSceneProps(props) {\n  const keys = Object.keys(props);\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const k = keys[i];\n    const v = props[k];\n\n    if (Array.isArray(v) && typeof v[0] !== \"object\") {\n      if (/color/i.test(k)) {\n        props[k] = new Color(v[0], v[1], v[2], v[3]);\n      } else if (v.length === 4) {\n        props[k] = new Vector4(v[0], v[1], v[2], v[3]);\n      } else if (v.length === 3) {\n        props[k] = new Vector3(v[0], v[1], v[2]);\n      } else if (v.length === 2) {\n        props[k] = new Vector2(v[0], v[1]);\n      }\n    } else if (v && k === \"diffuseSphericalHarmonics\") {\n      sh.setValueByArray(JSON.parse(v));\n      props[k] = sh;\n    }\n  }\n}\n\nfunction handleAssets(props: any = {}) {\n  if (!props) {\n    return;\n  }\n  const keys = Object.keys(props);\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const value = props[key];\n\n    if (key === \"newMaterial\" || key === \"scripts\") {\n      continue;\n    }\n\n    if (Array.isArray(value) && typeof value[0] !== \"object\") {\n      if ([\"emissiveColor\", \"diffuseColor\", \"specularColor\", \"baseColor\"].indexOf(key) !== -1) {\n        props[key] = new Color(value[0], value[1], value[2], value[3]);\n      } else if (value.length === 4) {\n        props[key] = new Vector4(value[0], value[1], value[2], value[3]);\n      } else if (value.length === 3) {\n        props[key] = new Vector3(value[0], value[1], value[2]);\n      } else if (value.length === 2) {\n        props[key] = new Vector2(value[0], value[1]);\n      }\n    }\n  }\n}\n", "import { Component } from \"@oasis-engine/core\";\nimport { Oasis } from \"./Oasis\";\nimport { Plugin } from \"./plugins/Plugin\";\nimport { PluginManager } from \"./plugins/PluginManager\";\nimport { Options } from \"./types\";\nimport { compatibleToV2 } from \"./temp.compatible\";\n\nconst CURRENT_SCHEMA_VERSION = 3;\n\nexport class Parser {\n  private pluginManager: PluginManager = new PluginManager();\n  /**\n   * Parse a scene config.\n   * @param options - Options of scene\n   */\n  public parse(options: Options): Promise<Oasis> {\n    if (options?.config?.version !== CURRENT_SCHEMA_VERSION) {\n      console.warn(\n        `schema-parser: schema version \"${options?.config?.version}\" is out of date, please re-pull the latest version (version ${CURRENT_SCHEMA_VERSION}) of the schema`\n      );\n    }\n    compatibleToV2(options.config);\n    return Oasis.create(options, this.pluginManager);\n  }\n\n  register(plugin: Plugin) {\n    this.pluginManager.register(plugin);\n  }\n\n  resetPlugins() {\n    this.pluginManager.reset();\n  }\n\n  private constructor() {}\n\n  static create(): Parser {\n    const parser = new Parser();\n    return parser;\n  }\n\n  /** @internal */\n  public static _components: { [namespace: string]: { [compName: string]: Component } } = {};\n  /**\n   * Register parsing component\n   * @param namespace - Namespace\n   * @param components - Components\n   */\n  static registerComponents(namespace: string, components: { [key: string]: any }) {\n    if (!this._components[namespace]) {\n      this._components[namespace] = {};\n    }\n    Object.assign(this._components[namespace], components);\n  }\n}\n\nexport const parser = Parser.create();\n", "export function switchElementsIndex(elements: any[], currentIndex: number, targetIndex: number) {\n  if (currentIndex === targetIndex || targetIndex === null || targetIndex === undefined) {\n    return;\n  }\n  [elements[currentIndex], elements[targetIndex]] = [elements[targetIndex], elements[currentIndex]];\n}\n\nexport function isAsset(config: any): boolean {\n  return config && config.type === \"asset\";\n}\n\nexport function getAllGetters(obj: any): Array<string> {\n  const result = [];\n  const prototype = Object.getPrototypeOf(obj);\n  const prototype_property_descriptors = Object.getOwnPropertyDescriptors(prototype);\n  for (const [property, descriptor] of Object.entries(prototype_property_descriptors)) {\n    if (typeof descriptor.get === \"function\") {\n      result.push(property);\n    }\n  }\n  return result;\n}\n\nexport function union(arr1: Array<any>, arr2: Array<any>): Array<any> {\n  return arr1.concat(arr2.filter((v) => !(arr1.indexOf(v) > -1)));\n}\n\n// https://github.com/BabylonJS/Babylon.js/blob/d780145531ac1b1cee85cbfba4d836dcc24ab58e/src/Engines/Extensions/engine.textureSelector.ts#L70\n// Intelligently add supported compressed formats in order to check for.\n// Check for ASTC support first as it is most powerful and to be very cross platform.\n// Next PVRTC & DXT, which are probably superior to ETC1/2.\n// Likely no hardware which supports both PVR & DXT, so order matters little.\n// ETC2 is newer and handles ETC1 (no alpha capability), so check for first.\nexport const compressedTextureLoadOrder = {\n  astc: 1,\n  s3tc: 2,\n  pvrtc: 3,\n  etc: 4,\n  etc1: 5\n};\n", "import { Logger, ResourceManager } from \"@oasis-engine/core\";\nimport { Oasis } from \"../Oasis\";\nimport { SchemaResourceManager } from \"../ResourceManager\";\nimport { AssetConfig, LoadAttachedResourceResult } from \"../types\";\nimport { isAsset } from \"../utils\";\n\ninterface IResourceMeta {\n  name?: string;\n  url?: string;\n  size?: number;\n  source?: string;\n}\n\nexport abstract class SchemaResource {\n  protected _meta: IResourceMeta = {};\n  protected _attachedResources: Array<SchemaResource> = [];\n\n  /**\n   * Resource\n   */\n  get resource() {\n    return this._resource;\n  }\n\n  get meta(): IResourceMeta {\n    return this._meta;\n  }\n\n  get attachedResources() {\n    return this._attachedResources;\n  }\n\n  protected setMeta() {}\n\n  constructor(protected resourceManager: SchemaResourceManager, protected _resource?: any) {\n    this.setMeta();\n  }\n\n  abstract load(resourceManager: ResourceManager, assetConfig: AssetConfig, oasis: Oasis): Promise<SchemaResource>;\n  loadWithAttachedResources(\n    resourceLoader: any,\n    assetConfig: AssetConfig,\n    oasis: Oasis\n  ): Promise<LoadAttachedResourceResult> {\n    return new Promise((resolve, reject) => {\n      this.load(resourceLoader, assetConfig, oasis)\n        .then(() => {\n          resolve({\n            resources: [this],\n            structure: {\n              index: 0,\n              props: {}\n            }\n          });\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n\n  getProps(): any {\n    return {};\n  }\n\n  bind(): void {}\n  attach(): void {}\n\n  update(key: string, value: any) {\n    if (isAsset(value)) {\n      const resource = this.resourceManager.get(value.id);\n      if (resource) {\n        this._resource[key] = resource.resource;\n      } else {\n        Logger.warn(`SchemaResource: ${this.meta.name} can't find asset, which id is: ${value.id}`);\n      }\n    } else {\n      this._resource[key] = value;\n    }\n  }\n\n  updateMeta(key: string, value: any) {\n    this._meta[key] = value;\n  }\n\n  onDestroy() {}\n}\n", "import {\n  ResourceManager,\n} from \"@oasis-engine/core\";\nimport { AssetConfig, LoadAttachedResourceResult } from \"../types\";\nimport { SchemaResource } from \"./SchemaResource\";\n\nexport class AnimationClipResource extends SchemaResource {\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig): Promise<any> {\n    return new Promise((resolve) => {\n      this._resource = assetConfig.props || {};\n      this.setMeta();\n      resolve(this);\n    });\n  }\n\n  loadWithAttachedResources(\n    resourceManager: ResourceManager,\n    assetConfig: AssetConfig\n  ): Promise<LoadAttachedResourceResult> {\n    return new Promise((resolve, reject) => {\n      let loadPromise;\n      if (assetConfig.props) {\n        loadPromise = this.load(resourceManager, assetConfig);\n      } else {\n        reject(\"Load AnimationClip Error\");\n      }\n      if (loadPromise) {\n        loadPromise.then(() => {\n          const result: any = {\n            resources: [this],\n            structure: {\n              index: 0,\n              props: {}\n            }\n          };\n          resolve(result);\n        });\n      }\n    });\n  }\n\n  setMeta() {\n    if (this.resource) {\n      this.meta.name = this.resource.name;\n    }\n  }\n\n  getProps() {\n    return this._resource;\n  }\n}\n", "import { AnimationClipResource } from \"./AnimationClipResource\";\nimport {\n  AnimatorController,\n  AnimatorControllerLayer,\n  AnimatorStateMachine,\n  AnimatorStateTransition\n} from \"@oasis-engine/core\";\nimport { ResourceManager } from \"@oasis-engine/core\";\nimport { SchemaResource } from \"./SchemaResource\";\nimport { AssetConfig, LoadAttachedResourceResult } from \"../types\";\n\nexport class AnimatorControllerResource extends SchemaResource {\n  public gltf;\n  private animatorControllerData;\n  private animationClipAssets: any[];\n  private animationsIndices: {\n    name: string;\n    index: number;\n  }[];\n\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig): Promise<any> {\n    return new Promise((resolve) => {\n      const { animatorController, animationClips: animationClipAssets, animationsIndices, gltf } =\n        assetConfig.props || {};\n      this._resource = new AnimatorController();\n      this.animatorControllerData = animatorController;\n      this.animationsIndices = animationsIndices || [];\n      this.animationClipAssets = animationClipAssets || [];\n      this.gltf = gltf;\n      !animatorController && this._setDefaultDataByAnimationClip();\n      this.setMetaData(\"name\", assetConfig.name);\n      resolve(this);\n    });\n  }\n\n  loadWithAttachedResources(\n    resourceManager: ResourceManager,\n    assetConfig: AssetConfig\n  ): Promise<LoadAttachedResourceResult> {\n    return new Promise((resolve, reject) => {\n      const clipLoadPromises = [];\n      this.load(resourceManager, assetConfig).then(() => {\n        const result: any = {\n          resources: [this],\n          structure: {\n            index: 0,\n            props: {\n              animationClips: []\n            }\n          }\n        };\n\n        const animations = this.animationsIndices;\n        for (let i = 0, length = animations.length; i < length; ++i) {\n          const clip = animations[i];\n          const clipResourse = new AnimationClipResource(this.resourceManager);\n          this.attachedResources.push(clipResourse);\n          clipLoadPromises.push(\n            clipResourse.loadWithAttachedResources(resourceManager, {\n              type: \"animationClip\",\n              name: clip.name,\n              props: clip\n            })\n          );\n        }\n\n        Promise.all(clipLoadPromises).then((res) => {\n          const { animationClips } = result.structure.props;\n          res.forEach((clip) => {\n            const clipStructure = clip.structure;\n            const clipResource = clip.resources[clipStructure.index];\n            result.resources.push(clipResource);\n            clipStructure.index = result.resources.length - 1;\n            animationClips.push(clipStructure);\n          });\n          resolve(result);\n        });\n      });\n    });\n  }\n\n  setMetaData(key, value) {\n    this._meta[key] = value;\n  }\n\n  update(key: string, value: any) {\n    this._initAnimatorController(value);\n  }\n\n  bind() {\n    const { animatorControllerData, animationClipAssets } = this;\n    this._bindClips(animationClipAssets);\n    if (animatorControllerData) {\n      this._initAnimatorController(animatorControllerData);\n    } else {\n      this._setDefaultDataByAnimationClipAsset();\n    }\n  }\n\n  _initAnimatorController(animatorControllerData) {\n    const { animations } = this.gltf || {};\n    const { layers } = animatorControllerData;\n    if (!animations || !layers) return;\n    this._resource.clearLayers();\n    for (let i = 0, length = layers.length; i < length; ++i) {\n      const { name, blending, weight, stateMachine: stateMachineData } = layers[i];\n      if (!stateMachineData) continue;\n      const layer = new AnimatorControllerLayer(name);\n      layer.blendingMode = blending;\n      layer.weight = weight;\n      const { states } = stateMachineData;\n      const stateMachine = new AnimatorStateMachine();\n      let stateMachineTransitions = [];\n      for (let j = 0, length = states.length; j < length; ++j) {\n        const stateData = states[j];\n        const {\n          name,\n          transitions,\n          clip,\n          speed,\n          wrapMode,\n          clipStartNormalizedTime,\n          clipEndNormalizedTime,\n          isDefaultState\n        } = stateData;\n        const { id: clipAssetId } = clip || {};\n        if (!clipAssetId) continue;\n        const uniqueName = stateMachine.makeUniqueStateName(name);\n        if (uniqueName !== name) {\n          console.warn(`AnimatorState name is existed, name: ${name} reset to ${uniqueName}`);\n        }\n        const state = stateMachine.addState(uniqueName);\n        state.speed = speed;\n        state.wrapMode = wrapMode;\n        const animationIndex = this.resourceManager.get(clipAssetId).resource;\n        const animationClip = animations[animationIndex.index];\n        if (!animationClip) continue;\n        state.clip = animationClip;\n        state.clipStartTime = animationClip.length * clipStartNormalizedTime;\n        state.clipEndTime = animationClip.length * clipEndNormalizedTime;\n        for (let j = 0, length = transitions.length; j < length; ++j) {\n          const transition = transitions[j];\n          transitions[j].srcState = state;\n          stateMachineTransitions.push(transition);\n        }\n\n        if (isDefaultState) {\n          //@ts-ignore\n          stateMachine._defaultState = state;\n        }\n      }\n      for (let j = 0, length = stateMachineTransitions.length; j < length; ++j) {\n        const transitionData = stateMachineTransitions[j];\n        const transition = new AnimatorStateTransition();\n        transition.duration = transitionData.duration;\n        transition.offset = transitionData.offset;\n        transition.exitTime = transitionData.exitTime;\n        transition.destinationState = stateMachine.findStateByName(transitionData.targetStateName);\n        transitionData.srcState.addTransition(transition);\n        delete transitionData.srcState;\n      }\n      layer.stateMachine = stateMachine;\n      this._resource.addLayer(layer);\n    }\n  }\n\n  _bindClips(animationClips) {\n    for (let i = 0, length = animationClips.length; i < length; i++) {\n      const clipAsset = animationClips[i];\n      const clipResource = this.resourceManager.get(clipAsset.id);\n      if (clipResource) {\n        this._attachedResources.push(clipResource);\n      } else {\n        `AnimatorResource: ${this.meta.name} can't find asset \"animationClip\", which id is: ${clipAsset.id}`;\n      }\n    }\n  }\n\n  _setDefaultDataByAnimationClipAsset() {\n    const { animationClipAssets } = this;\n    if (!animationClipAssets.length) {\n      return;\n    }\n    let clips = [];\n    for (let i = 0, length = animationClipAssets.length; i < length; i++) {\n      const clipAsset = this.resourceManager.get(animationClipAssets[i].id);\n      clips.push(clipAsset.resource);\n    }\n    this.animationsIndices = clips;\n    this._setDefaultDataByAnimationClip();\n  }\n\n  _setDefaultDataByAnimationClip() {\n    const { animationsIndices, _resource: animatorController, gltf } = this;\n    if (!animationsIndices.length || !gltf) {\n      return;\n    }\n    const { animations } = gltf\n    const layer = new AnimatorControllerLayer(\"layer\");\n    const animatorStateMachine = new AnimatorStateMachine();\n    animatorController.addLayer(layer);\n    layer.stateMachine = animatorStateMachine;\n    for (let i = 0, length = animationsIndices.length; i < length; i++) {\n      const animationIndex = animationsIndices[i];\n      const { name, index} = animationIndex\n      const uniqueName = animatorStateMachine.makeUniqueStateName(name);\n      if (uniqueName !== name) {\n        console.warn(`AnimatorState name is existed, name: ${name} reset to ${uniqueName}`);\n      }\n      const animatorState = animatorStateMachine.addState(uniqueName);\n      animatorState.clip = animations[index];\n    }\n  }\n}\n", "import { AssetType, GLCapabilityType, ResourceManager } from \"@oasis-engine/core\";\nimport { Oasis } from \"../Oasis\";\nimport { AssetConfig } from \"../types\";\nimport { SchemaResource } from \"./SchemaResource\";\n\nexport class TextureResource extends SchemaResource {\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig, oasis: Oasis): Promise<TextureResource> {\n    return new Promise((resolve, reject) => {\n      let url: string;\n      let assetType = AssetType.Texture2D;\n      if (this.resourceManager.useCompressedTexture && assetConfig?.props?.compression?.compressions.length) {\n        const rhi = oasis.engine._hardwareRenderer;\n        const compressions = assetConfig.props.compression.compressions;\n        for (let i = 0; i < compressions.length; i++) {\n          const compression = compressions[i];\n          if (compression.container === \"ktx\" && rhi.canIUse(GLCapabilityType[compression.type])) {\n            url = compression.url;\n            assetType = AssetType.KTX;\n            break;\n          }\n        }\n      }\n\n      url = url ?? assetConfig.url;\n\n      resourceManager\n        .load({ url, type: assetType })\n        .then((res) => {\n          this._resource = res;\n          resolve(this);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n\n  setMeta() {\n    if (this.resource) {\n      this._meta.name = this.resource.name;\n    }\n  }\n}\n", "import { BlinnPhongMaterial, Logger, ResourceManager, Texture } from \"@oasis-engine/core\";\nimport { AssetConfig, LoadAttachedResourceResult } from \"../types\";\nimport { getAllGetters, isAsset } from \"../utils\";\nimport { SchemaResource } from \"./SchemaResource\";\nimport { TextureResource } from \"./TextureResource\";\n\nexport class BlinnPhongMaterialResource extends SchemaResource {\n  private configProps;\n\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig): Promise<BlinnPhongMaterialResource> {\n    return new Promise((resolve) => {\n      const assetObj = new BlinnPhongMaterial(resourceManager.engine);\n      this.configProps = assetConfig.props;\n      this._resource = assetObj;\n\n      for (let k in this.configProps) {\n        if (!isAsset(this.configProps[k])) {\n          assetObj[k] = this.configProps[k];\n        }\n      }\n      this.setMeta();\n      resolve(this);\n    });\n  }\n\n  loadWithAttachedResources(\n    resourceManager: ResourceManager,\n    assetConfig: AssetConfig\n  ): Promise<LoadAttachedResourceResult> {\n    return new Promise((resolve, reject) => {\n      let loadPromise;\n      if (assetConfig.resource instanceof BlinnPhongMaterial) {\n        loadPromise = new Promise((resolve) => {\n          this._resource = assetConfig.resource;\n          this.setMeta();\n          resolve(this);\n        });\n      } else if (assetConfig.props) {\n        loadPromise = this.load(resourceManager, assetConfig);\n      } else {\n        reject(\"Load BlinnPhongMaterial Error\");\n      }\n      if (loadPromise) {\n        loadPromise.then(() => {\n          const result: any = {\n            resources: [this],\n            structure: {\n              index: 0,\n              props: {}\n            }\n          };\n\n          const material = this._resource;\n          getAllGetters(this._resource).forEach((attr) => {\n            if (!(material[attr] instanceof Texture)) return;\n            const textureResource = new TextureResource(this.resourceManager, material[attr]);\n            this.attachedResources.push(textureResource);\n            result.resources.push(textureResource);\n            result.structure.props[attr] = {\n              index: result.resources.length - 1\n            };\n          });\n          resolve(result);\n        });\n      }\n    });\n  }\n\n  setMeta() {\n    if (this.resource) {\n      this.meta.name = this.resource.name;\n    }\n  }\n\n  bind() {\n    const resource = this._resource;\n    Object.keys(this.configProps).forEach((attr) => {\n      const value = this.configProps[attr];\n      if (isAsset(value)) {\n        const textureResource = this.resourceManager.get(value.id);\n        if (textureResource && textureResource instanceof TextureResource) {\n          resource[attr] = textureResource.resource;\n          this._attachedResources.push(textureResource);\n        } else {\n          resource[attr] = null;\n          Logger.warn(\n            `BlinnPhongMaterialResource: ${this.meta.name} can't find asset \"${attr}\", which id is: ${value.id}`\n          );\n        }\n      } else {\n        resource[attr] = value;\n      }\n    });\n  }\n}\n", "import { Logger, PBRMaterial, ResourceManager, Texture } from \"@oasis-engine/core\";\nimport { AssetConfig, LoadAttachedResourceResult } from \"../types\";\nimport { isAsset } from \"../utils\";\nimport { SchemaResource } from \"./SchemaResource\";\nimport { TextureResource } from \"./TextureResource\";\n\nconst attrs = [\n  \"metallic\",\n  \"roughness\",\n  \"roughnessMetallicTexture\",\n\n  // pbr base\n  \"tilingOffset\",\n  \"baseColor\",\n  \"normalTextureIntensity\",\n  \"emissiveColor\",\n  \"occlusionTextureIntensity\",\n  \"baseTexture\",\n  \"normalTexture\",\n  \"emissiveTexture\",\n  \"occlusionTexture\",\n\n  // base material\n  \"isTransparent\",\n  \"alphaCutoff\",\n  \"renderFace\",\n  \"blendMode\"\n];\nexport class PBRMaterialResource extends SchemaResource {\n  private configProps;\n\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig): Promise<PBRMaterialResource> {\n    return new Promise((resolve) => {\n      const assetObj = new PBRMaterial(resourceManager.engine);\n      this.configProps = assetConfig.props;\n\n      for (let k in this.configProps) {\n        if (!isAsset(this.configProps[k])) {\n          assetObj[k] = this.configProps[k];\n        }\n      }\n      this._resource = assetObj;\n      this.setMeta();\n      resolve(this);\n    });\n  }\n\n  loadWithAttachedResources(\n    resourceManager: ResourceManager,\n    assetConfig: AssetConfig\n  ): Promise<LoadAttachedResourceResult> {\n    return new Promise((resolve, reject) => {\n      let loadPromise;\n      if (assetConfig.resource instanceof PBRMaterial) {\n        loadPromise = new Promise((resolve) => {\n          this._resource = assetConfig.resource;\n          this.setMeta();\n          resolve(this);\n        });\n      } else if (assetConfig.props) {\n        loadPromise = this.load(resourceManager, assetConfig);\n      } else {\n        reject(\"Load PBRMaterial Error\");\n      }\n      if (loadPromise) {\n        loadPromise.then(() => {\n          const result: any = {\n            resources: [this],\n            structure: {\n              index: 0,\n              props: {}\n            }\n          };\n\n          const material = this._resource;\n          attrs.forEach((attr) => {\n            if (!(material[attr] instanceof Texture)) return;\n            const textureResource = new TextureResource(this.resourceManager, material[attr]);\n            this.attachedResources.push(textureResource);\n            result.resources.push(textureResource);\n            result.structure.props[attr] = {\n              index: result.resources.length - 1\n            };\n          });\n          resolve(result);\n        });\n      }\n    });\n  }\n\n  setMeta() {\n    if (this.resource) {\n      this.meta.name = this.resource.name;\n    }\n  }\n\n  getProps() {\n    const result = {};\n    attrs.forEach((prop) => (result[prop] = this.resource[prop]));\n    return result;\n  }\n\n  bind() {\n    const resource = this._resource;\n    Object.keys(this.configProps).forEach((attr) => {\n      const value = this.configProps[attr];\n      if (isAsset(value)) {\n        const textureResource = this.resourceManager.get(value.id);\n        if (textureResource && textureResource instanceof TextureResource) {\n          resource[attr] = textureResource.resource;\n          this._attachedResources.push(textureResource);\n        } else {\n          resource[attr] = null;\n          Logger.warn(`PBRMaterialResource: ${this.meta.name} can't find asset \"${attr}\", which id is: ${value.id}`);\n        }\n      } else {\n        resource[attr] = value;\n      }\n    });\n  }\n}\n", "import { Logger, PBRSpecularMaterial, ResourceManager, Texture } from \"@oasis-engine/core\";\nimport { AssetConfig, LoadAttachedResourceResult } from \"../types\";\nimport { isAsset } from \"../utils\";\nimport { SchemaResource } from \"./SchemaResource\";\nimport { TextureResource } from \"./TextureResource\";\n\nconst attrs = [\n  \"specularColor\",\n  \"glossiness\",\n  \"specularGlossinessTexture\",\n\n  // pbr base\n  \"tilingOffset\",\n  \"baseColor\",\n  \"normalTextureIntensity\",\n  \"emissiveColor\",\n  \"occlusionTextureIntensity\",\n  \"baseTexture\",\n  \"normalTexture\",\n  \"emissiveTexture\",\n  \"occlusionTexture\",\n\n  // base material\n  \"isTransparent\",\n  \"alphaCutoff\",\n  \"renderFace\",\n  \"blendMode\"\n];\n\nexport class PBRSpecularMaterialResource extends SchemaResource {\n  private configProps;\n\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig): Promise<PBRSpecularMaterialResource> {\n    return new Promise((resolve) => {\n      const assetObj = new PBRSpecularMaterial(resourceManager.engine);\n      this.configProps = assetConfig.props;\n      this._resource = assetObj;\n\n      for (let k in this.configProps) {\n        if (!isAsset(this.configProps[k])) {\n          assetObj[k] = this.configProps[k];\n        }\n      }\n      this.setMeta();\n      resolve(this);\n    });\n  }\n\n  loadWithAttachedResources(\n    resourceManager: ResourceManager,\n    assetConfig: AssetConfig\n  ): Promise<LoadAttachedResourceResult> {\n    return new Promise((resolve, reject) => {\n      let loadPromise;\n      if (assetConfig.resource instanceof PBRSpecularMaterial) {\n        loadPromise = new Promise((resolve) => {\n          this._resource = assetConfig.resource;\n          this.setMeta();\n          resolve(this);\n        });\n      } else if (assetConfig.props) {\n        loadPromise = this.load(resourceManager, assetConfig);\n      } else {\n        reject(\"Load PBRSpecularMaterial Error\");\n      }\n      if (loadPromise) {\n        loadPromise.then(() => {\n          const result: any = {\n            resources: [this],\n            structure: {\n              index: 0,\n              props: {}\n            }\n          };\n\n          const material = this._resource;\n          Object.keys(this._resource).forEach((attr) => {\n            if (!(material[attr] instanceof Texture)) return;\n            const textureResource = new TextureResource(this.resourceManager, material[attr]);\n            this.attachedResources.push(textureResource);\n            result.resources.push(textureResource);\n            result.structure.props[attr] = {\n              index: result.resources.length - 1\n            };\n          });\n          resolve(result);\n        });\n      }\n    });\n  }\n\n  setMeta() {\n    if (this.resource) {\n      this.meta.name = this.resource.name;\n    }\n  }\n\n  getProps() {\n    const result = {};\n    attrs.forEach((prop) => (result[prop] = this.resource[prop]));\n    return result;\n  }\n\n  bind() {\n    const resource = this._resource;\n    Object.keys(this.configProps).forEach((attr) => {\n      const value = this.configProps[attr];\n      if (isAsset(value)) {\n        const textureResource = this.resourceManager.get(value.id);\n        if (textureResource && textureResource instanceof TextureResource) {\n          resource[attr] = textureResource.resource;\n          this._attachedResources.push(textureResource);\n        } else {\n          resource[attr] = null;\n          Logger.warn(\n            `PBRSpecularMaterialResource: ${this.meta.name} can't find asset \"${attr}\", which id is: ${value.id}`\n          );\n        }\n      } else {\n        resource[attr] = value;\n      }\n    });\n  }\n}\n", "import { Logger, UnlitMaterial, ResourceManager, Texture } from \"@oasis-engine/core\";\nimport { AssetConfig, LoadAttachedResourceResult } from \"../types\";\nimport { getAllGetters, isAsset } from \"../utils\";\nimport { SchemaResource } from \"./SchemaResource\";\nimport { TextureResource } from \"./TextureResource\";\n\nexport class UnlitMaterialResource extends SchemaResource {\n  private configProps;\n\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig): Promise<UnlitMaterialResource> {\n    return new Promise((resolve) => {\n      const assetObj = new UnlitMaterial(resourceManager.engine);\n      this.configProps = assetConfig.props;\n\n      for (let k in this.configProps) {\n        if (!isAsset(this.configProps[k])) {\n          assetObj[k] = this.configProps[k];\n        }\n      }\n      this._resource = assetObj;\n      this.setMeta();\n      resolve(this);\n    });\n  }\n\n  loadWithAttachedResources(\n    resourceManager: ResourceManager,\n    assetConfig: AssetConfig\n  ): Promise<LoadAttachedResourceResult> {\n    return new Promise((resolve, reject) => {\n      let loadPromise;\n      if (assetConfig.resource instanceof UnlitMaterial) {\n        loadPromise = new Promise((resolve) => {\n          this._resource = assetConfig.resource;\n          this.setMeta();\n          resolve(this);\n        });\n      } else if (assetConfig.props) {\n        loadPromise = this.load(resourceManager, assetConfig);\n      } else {\n        reject(\"Load PBRMaterial Error\");\n      }\n      if (loadPromise) {\n        loadPromise.then(() => {\n          const result: any = {\n            resources: [this],\n            structure: {\n              index: 0,\n              props: {}\n            }\n          };\n\n          const material = this._resource;\n          getAllGetters(this._resource).forEach((attr) => {\n            if (!(material[attr] instanceof Texture)) return;\n            const textureResource = new TextureResource(this.resourceManager, material[attr]);\n            this.attachedResources.push(textureResource);\n            result.resources.push(textureResource);\n            result.structure.props[attr] = {\n              index: result.resources.length - 1\n            };\n          });\n          resolve(result);\n        });\n      }\n    });\n  }\n\n  setMeta() {\n    if (this.resource) {\n      this.meta.name = this.resource.name;\n    }\n  }\n\n  getProps() {\n    const result = {};\n    const props = getAllGetters(this.resource);\n    props.forEach((prop) => (result[prop] = this.resource[prop]));\n    return result;\n  }\n\n  bind() {\n    const resource = this._resource;\n    Object.keys(this.configProps).forEach((attr) => {\n      const value = this.configProps[attr];\n      if (isAsset(value)) {\n        const textureResource = this.resourceManager.get(value.id);\n        if (textureResource && textureResource instanceof TextureResource) {\n          resource[attr] = textureResource.resource;\n          this._attachedResources.push(textureResource);\n        } else {\n          resource[attr] = null;\n          Logger.warn(`PBRMaterialResource: ${this.meta.name} can't find asset \"${attr}\", which id is: ${value.id}`);\n        }\n      } else {\n        resource[attr] = value;\n      }\n    });\n  }\n}\n", "import { AnimatorControllerResource } from \"./AnimatorControllerResource\";\nimport {\n  AssetType,\n  Entity,\n  Logger,\n  MeshRenderer,\n  PBRMaterial,\n  PBRSpecularMaterial,\n  ResourceManager,\n  UnlitMaterial\n} from \"@oasis-engine/core\";\nimport { Oasis } from \"../Oasis\";\nimport { AssetConfig, LoadAttachedResourceResult } from \"../types\";\nimport { BlinnPhongMaterialResource } from \"./BlinnPhongMaterialResource\";\nimport { PBRMaterialResource } from \"./PBRMaterialResource\";\nimport { PBRSpecularMaterialResource } from \"./PBRSpecularMaterialResource\";\nimport { SchemaResource } from \"./SchemaResource\";\nimport { UnlitMaterialResource } from \"./UnlitMaterialResource\";\n\nexport class GLTFResource extends SchemaResource {\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig, oasis: Oasis): Promise<any> {\n    return resourceManager.load<any>({ url: assetConfig.url, type: AssetType.Prefab }).then((res) => {\n      const gltf = res;\n      if (assetConfig.props) {\n        gltf.newMaterial = (assetConfig.props as any).newMaterial;\n        gltf.animatorControllers = (assetConfig.props as any).animatorControllers;\n      }\n      this._resource = gltf;\n    });\n  }\n\n  loadWithAttachedResources(\n    resourceManager: ResourceManager,\n    assetConfig: AssetConfig,\n    oasis: Oasis\n  ): Promise<LoadAttachedResourceResult> {\n    return new Promise((resolve) => {\n      this.load(resourceManager, assetConfig, oasis).then(() => {\n        const gltf = this.resource;\n        const { materials = [], _animationsIndices = [] } = gltf;\n        const materialLoadPromises = [];\n        const clipLoadPromises = [];\n        let animatorControllerLoadPromise: Promise<any>;\n        const result = {\n          resources: [this],\n          structure: {\n            index: 0,\n            props: {\n              newMaterial: [],\n              animatorControllers: []\n            }\n          }\n        };\n        if (materials?.length) {\n          for (let i = 0; i < materials.length; i++) {\n            const material = materials[i];\n            let materialResource = null;\n            let type = \"\";\n\n            if (material instanceof PBRMaterial) {\n              materialResource = new PBRMaterialResource(this.resourceManager);\n              type = \"PBRMaterial\";\n            } else if (material instanceof UnlitMaterial) {\n              materialResource = new UnlitMaterialResource(this.resourceManager);\n              type = \"UnlitMaterial\";\n            } else if (material instanceof PBRSpecularMaterial) {\n              materialResource = new PBRSpecularMaterialResource(this.resourceManager);\n              type = \"PBRSpecularMaterial\";\n            } else {\n              materialResource = new BlinnPhongMaterialResource(this.resourceManager);\n              type = \"BlinnPhongMaterial\";\n            }\n\n            this._attachedResources.push(materialResource);\n            materialLoadPromises.push(\n              materialResource.loadWithAttachedResources(resourceManager, {\n                type,\n                name: material.name,\n                resource: material\n              })\n            );\n          }\n        }\n\n        if (_animationsIndices.length) {\n          const animatorControllerResource = new AnimatorControllerResource(this.resourceManager);\n          this._attachedResources.push(animatorControllerResource);\n          animatorControllerLoadPromise = animatorControllerResource.loadWithAttachedResources(resourceManager, {\n            type: \"animatorController\",\n            name: \"AnimatorController\",\n            props: {\n              animationsIndices: _animationsIndices,\n              gltf: this._resource\n            }\n          });\n        }\n\n        const loadAttachedMaterial = Promise.all(materialLoadPromises).then((res) => {\n          const newMaterial = result.structure.props.newMaterial;\n          res.forEach((mat) => {\n            const matStructure = mat.structure;\n            const matResource = mat.resources[matStructure.index];\n            result.resources.push(matResource);\n            matStructure.index = result.resources.length - 1;\n            for (const key in matStructure.props) {\n              if (matStructure.props.hasOwnProperty(key)) {\n                const textureStructure = matStructure.props[key];\n                const textureResource = mat.resources[textureStructure.index];\n                result.resources.push(textureResource);\n                textureStructure.index = result.resources.length - 1;\n              }\n            }\n            newMaterial.push(matStructure);\n          });\n        });\n        const loadAttachedController = animatorControllerLoadPromise\n          ? animatorControllerLoadPromise.then((res) => {\n              const { animatorControllers } = result.structure.props;\n              const controllerStructure = res.structure;\n              const controllerResource = res.resources[controllerStructure.index];\n              result.resources.push(controllerResource as any);\n              controllerStructure.index = result.resources.length - 1;\n              const { animationClips } = controllerStructure.props;\n              if (animationClips) {\n                for (let i = 0, length = animationClips.length; i < length; ++i) {\n                  const clipStructure = animationClips[i];\n                  const clipResource = res.resources[clipStructure.index];\n                  result.resources.push(clipResource);\n                  clipStructure.index = result.resources.length - 1;\n                }\n              }\n              animatorControllers.push(controllerStructure);\n            })\n          : Promise.resolve();\n        Promise.all([loadAttachedMaterial, loadAttachedController]).then(() => {\n          resolve(result);\n        });\n      });\n    });\n  }\n\n  setMeta(assetConfig?: AssetConfig) {\n    if (assetConfig) {\n      this.meta.name = assetConfig.name;\n    }\n  }\n\n  bind() {\n    const resource = this._resource;\n    this.bindMaterials(resource.newMaterial);\n    this.bindAnimatorControllers(resource.animatorControllers);\n  }\n\n  update(key: string, value: any) {\n    if (key === \"newMaterial\") {\n      this.bindMaterials(value);\n    } else {\n      this._resource[key] = value;\n    }\n  }\n\n  private bindMaterials(newMaterialsConfig) {\n    const newMaterialCount = newMaterialsConfig.length;\n    if (!newMaterialsConfig || !newMaterialsConfig.length) {\n      return;\n    }\n\n    const gltf = this._resource;\n\n    const newMaterials = new Array(newMaterialCount);\n    gltf.newMaterial = newMaterials;\n\n    for (let i = 0; i < newMaterialsConfig.length; i++) {\n      const mtlResource = this.resourceManager.get(newMaterialsConfig[i].id);\n      if (mtlResource) {\n        this._attachedResources.push(mtlResource);\n        newMaterials[i] = mtlResource.resource;\n      } else {\n        Logger.warn(\n          `GLTFResource: ${this.meta.name} can't find asset \"material\", which id is: ${newMaterialsConfig[i].id}`\n        );\n      }\n    }\n\n    const gltfRoot = gltf.defaultSceneRoot as Entity;\n    const originMaterials = gltf.materials;\n    const meshRenderers: MeshRenderer[] = gltfRoot.getComponentsIncludeChildren(MeshRenderer, []);\n\n    for (let i = 0; i < newMaterialCount; i++) {\n      const newMaterial = newMaterials[i];\n      const originMaterial = originMaterials[i];\n      for (let j = 0; j < meshRenderers.length; j++) {\n        const meshRenderer = meshRenderers[j];\n        const meshMaterials = meshRenderer.getMaterials();\n        for (let k = 0; k < meshMaterials.length; k++) {\n          if (originMaterial === meshMaterials[k]) {\n            meshRenderer.setMaterial(k, newMaterial);\n          }\n        }\n      }\n    }\n  }\n\n  private bindAnimatorControllers(animatorControllers) {\n    for (let i = 0, length = animatorControllers.length; i < length; i++) {\n      const animatorControllerAsset = animatorControllers[i];\n      const controllerResource = <AnimatorControllerResource>this.resourceManager.get(animatorControllerAsset.id);\n      controllerResource.gltf = this._resource;\n      if (controllerResource) {\n        this._attachedResources.push(controllerResource);\n      } else {\n        `GLTFResource: ${this.meta.name} can't find asset \"animatorController\", which id is: ${animatorControllerAsset.id}`;\n      }\n    }\n  }\n}\n", "import { SchemaResource } from \"./SchemaResource\";\nimport { AssetConfig } from \"../types\";\nimport { Oasis } from \"../Oasis\";\nimport { Parser } from \"../Parser\";\n\nexport const scriptAbility = {};\nexport function script(name: string) {\n  return (target: any) => {\n    scriptAbility[name] = target;\n  };\n}\nexport class ScriptResource extends SchemaResource {\n  private isInit = false;\n\n  private initScriptContext() {\n    if (this.isInit) {\n      return;\n    }\n    this.isInit = true;\n    (window as any).__o3_script_context__ = {\n      o3: Parser._components[\"o3\"],\n      script: (name: string) => {\n        return (target: any) => {\n          scriptAbility[name] = target;\n        };\n      }\n    };\n  }\n\n  load(resourceLoader, assetConfig: AssetConfig, oasis: Oasis): Promise<ScriptResource> {\n    this.initScriptContext();\n    return new Promise((resolve) => {\n      const config = assetConfig as any;\n      const scripts = config.props.scripts;\n\n      if (!this.resourceManager.isLocal) {\n        const scriptDom = document.createElement(\"script\");\n        scriptDom.crossOrigin = \"anonymous\";\n        this.setMeta(assetConfig);\n        scriptDom.onload = () => {\n          const o3Scripts = (window as any).o3Scripts;\n          for (let i = 0; i < scripts.length; i++) {\n            const name = scripts[i].name;\n            this._resource = o3Scripts && o3Scripts[name];\n            scriptAbility[name] = this._resource;\n          }\n          resolve(this);\n        };\n        scriptDom.src = assetConfig.url;\n        document.body.appendChild(scriptDom);\n      } else {\n        for (let i = 0; i < scripts.length; i++) {\n          const name = scripts[i].name;\n          scriptAbility[name] = oasis.options?.scripts[name];\n        }\n        resolve(this);\n      }\n    });\n  }\n\n  setMeta(assetConfig?: AssetConfig) {\n    if (assetConfig) {\n      this._meta.name = assetConfig.name;\n      this._meta.url = assetConfig.url;\n      this._meta.source = assetConfig.source;\n    }\n  }\n}\n", "import { Logger, ResourceManager, Sprite, Texture } from \"@oasis-engine/core\";\nimport { AssetConfig, LoadAttachedResourceResult } from \"../types\";\nimport { getAllGetters, isAsset } from \"../utils\";\nimport { SchemaResource } from \"./SchemaResource\";\nimport { TextureResource } from \"./TextureResource\";\n\nexport class SpriteResource extends SchemaResource {\n  private configProps;\n\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig): Promise<SpriteResource> {\n    return new Promise((resolve) => {\n      const assetObj = new Sprite(resourceManager.engine);\n      this.configProps = assetConfig.props;\n      const { configProps } = this;\n      const { pivotType, pivot } = configProps;\n\n      if (typeof pivot !== \"undefined\" && typeof pivotType !== \"undefined\" && pivotType !== SpritePivotType.Custom) {\n        switch (pivotType) {\n          case SpritePivotType.Center:\n            pivot.x = 0.5;\n            pivot.y = 0.5;\n            break;\n          case SpritePivotType.TopLeft:\n            pivot.x = 0;\n            pivot.y = 1;\n            break;\n          case SpritePivotType.Top:\n            pivot.x = 0.5;\n            pivot.y = 1;\n            break;\n          case SpritePivotType.TopRight:\n            pivot.x = 1;\n            pivot.y = 1;\n            break;\n          case SpritePivotType.Left:\n            pivot.x = 0;\n            pivot.y = 0.5;\n            break;\n          case SpritePivotType.Right:\n            pivot.x = 1;\n            pivot.y = 0.5;\n            break;\n          case SpritePivotType.BottomLeft:\n            pivot.x = 0;\n            pivot.y = 0;\n            break;\n          case SpritePivotType.Bottom:\n            pivot.x = 0.5;\n            pivot.y = 0;\n            break;\n          case SpritePivotType.BottomRight:\n            pivot.x = 1;\n            pivot.y = 0;\n            break;\n          default:\n            break;\n        }\n      }\n\n      for (let k in configProps) {\n        if (!isAsset(configProps[k]) && typeof configProps[k] !== \"undefined\") {\n          assetObj[k] = configProps[k];\n        }\n      }\n\n      this._resource = assetObj;\n      this.setMeta();\n      resolve(this);\n    });\n  }\n\n  loadWithAttachedResources(\n    resourceManager: ResourceManager,\n    assetConfig: AssetConfig\n  ): Promise<LoadAttachedResourceResult> {\n    return new Promise((resolve, reject) => {\n      let loadPromise;\n      if (assetConfig.resource instanceof SpriteResource) {\n        loadPromise = new Promise((resolve) => {\n          this._resource = assetConfig.resource;\n          this.setMeta();\n          resolve(this);\n        });\n      } else if (assetConfig.props) {\n        loadPromise = this.load(resourceManager, assetConfig);\n      } else {\n        reject(\"Load Sprite Error\");\n      }\n      if (loadPromise) {\n        loadPromise.then(() => {\n          const result: any = {\n            resources: [this],\n            structure: {\n              index: 0,\n              props: {}\n            }\n          };\n\n          const sprite = this._resource;\n          getAllGetters(this._resource).forEach((attr) => {\n            if (!(sprite[attr] instanceof Texture)) return;\n            const textureResource = new TextureResource(this.resourceManager, sprite[attr]);\n            this.attachedResources.push(textureResource);\n            result.resources.push(textureResource);\n            result.structure.props[attr] = {\n              index: result.resources.length - 1\n            };\n          });\n          resolve(result);\n        });\n      }\n    });\n  }\n\n  setMeta() {\n    if (this.resource) {\n      this.meta.name = this.resource.name;\n    }\n  }\n\n  getProps() {\n    const result = {};\n    const props = getAllGetters(this.resource);\n    props.forEach((prop) => (result[prop] = this.resource[prop]));\n    return result;\n  }\n\n  bind() {\n    const resource = this._resource;\n    this.configProps &&\n      Object.keys(this.configProps).forEach((attr) => {\n        const value = this.configProps[attr];\n        if (isAsset(value)) {\n          const textureResource = this.resourceManager.get(value.id);\n          if (textureResource && textureResource instanceof TextureResource) {\n            resource[attr] = textureResource.resource;\n            this._attachedResources.push(textureResource);\n          } else {\n            resource[attr] = null;\n            Logger.warn(`SpriteResource: ${this.meta.name} can't find asset \"${attr}\", which id is: ${value.id}`);\n          }\n        } else {\n          resource[attr] = value;\n        }\n      });\n  }\n}\n\nexport enum SpritePivotType {\n  Center = 0,\n  TopLeft = 1,\n  Top = 2,\n  TopRight = 3,\n  Left = 4,\n  Right = 5,\n  BottomLeft = 6,\n  Bottom = 7,\n  BottomRight = 8,\n  Custom = 9\n}\n", "import { AssetType, GLCapabilityType, ResourceManager } from \"@oasis-engine/core\";\nimport { Oasis } from \"../Oasis\";\nimport { AssetConfig } from \"../types\";\nimport { SchemaResource } from \"./SchemaResource\";\n\nconst imageOrderMap = {\n  px: 0,\n  nx: 1,\n  py: 2,\n  ny: 3,\n  pz: 4,\n  nz: 5\n};\n\nexport class TextureCubeMapResource extends SchemaResource {\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig, oasis: Oasis): Promise<TextureCubeMapResource> {\n    return new Promise((resolve, reject) => {\n      const imageUrls = [];\n      let type = AssetType.TextureCube;\n      if (this.resourceManager.useCompressedTexture && assetConfig?.props?.compression?.compressions.length) {\n        const rhi = oasis.engine._hardwareRenderer;\n        const compressions = assetConfig.props.compression.compressions;\n        for (let i = 0; i < compressions.length; i++) {\n          const compression = compressions[i];\n          if (compression.container === \"ktx\" && rhi.canIUse(GLCapabilityType[compression.type])) {\n            for (const key in compression.files) {\n              if (compression.files.hasOwnProperty(key)) {\n                const image = compression.files[key];\n                imageUrls[imageOrderMap[key]] = image.url;\n              }\n            }\n            console.warn(compression.type);\n            type = AssetType.KTXCube;\n            break;\n          }\n        }\n      }\n\n      if (type === AssetType.TextureCube) {\n        for (const key in assetConfig.props.images) {\n          if (assetConfig.props.images.hasOwnProperty(key)) {\n            const image = assetConfig.props.images[key];\n            imageUrls[imageOrderMap[key]] = image.url;\n          }\n        }\n      }\n\n      resourceManager\n        .load({\n          urls: imageUrls,\n          type: type\n        })\n        .then((res) => {\n          this._resource = res;\n          resolve(this);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n\n  setMeta() {\n    if (this.resource) {\n      this.meta.name = this.resource.name;\n    }\n  }\n}\n", "import { SchemaResource } from \"./SchemaResource\";\nimport { AssetConfig } from \"../types\";\n\nexport class BaseResource extends SchemaResource {\n  load(resourceLoader, assetConfig: AssetConfig): Promise<BaseResource> {\n    return new Promise((resolve) => {\n      this._resource = assetConfig;\n      this.setMetaData(\"name\", this.resource.name);\n      this.setMetaData(\"url\", this.resource.url);\n      resolve(this);\n    });\n  }\n\n  setMetaData(key, value) {\n    this._meta[key] = value;\n  }\n}\n", "import { Component, Logger } from \"@oasis-engine/core\";\nimport { Model } from \"./Model\";\nimport { Oasis } from \"./Oasis\";\nimport { Parser } from \"./Parser\";\nimport { pluginHook } from \"./plugins/PluginManager\";\nimport { scriptAbility } from \"./resources\";\nimport { ComponentConfig, Props } from \"./types\";\nimport { switchElementsIndex } from \"./utils\";\nexport class AbilityManager {\n  private abilityMap: { [id: string]: Component } = {};\n\n  constructor(private oasis: Oasis) {}\n\n  @pluginHook({ after: \"abilityAdded\", before: \"beforeAbilityAdded\" })\n  public add(abilityConfig: ComponentConfig) {\n    const { type, node: nodeId, props, id, index } = abilityConfig;\n\n    const node = this.oasis.nodeManager.get(nodeId);\n    const AbilityConstructor = this.getCompConstructor(type);\n    if (!AbilityConstructor) {\n      Logger.error(`${type} abiltiy is not defined`);\n      return;\n    }\n\n    const abilityProps = this.mixPropsToExplicitProps(props);\n    const ability = node.addComponent(AbilityConstructor);\n    const { enabled } = abilityProps;\n    if (enabled !== undefined) {\n      ability.enabled = enabled;\n    }\n\n    if (type === \"GLTFModel\") {\n      // TODO\n      (ability as any).init(abilityProps);\n    } else if (type === \"Model\") {\n      // TODO\n      (ability as any).setProps(abilityProps);\n      if (abilityProps.material) {\n        (ability as any).material = abilityProps.material;\n      }\n    } else {\n      for (let k in abilityProps) {\n        if (abilityProps[k] !== null) {\n          ability[k] = abilityProps[k];\n        }\n      }\n    }\n\n    //@ts-ignore\n    const abilityArray = node._components;\n    const currentIndex = abilityArray.length - 1;\n    switchElementsIndex(abilityArray, currentIndex, index);\n    (ability as any).id = id;\n    this.abilityMap[id] = ability;\n    return ability;\n  }\n\n  @pluginHook({ before: \"beforeAbilityUpdated\", after: \"abilityUpdated\" })\n  public update(id: string, key: string, value: any) {\n    if (value && this.checkIsAsset(value)) {\n      this.get(id)[key] = this.oasis.resourceManager.get(value.id).resource;\n    } else {\n      if (this.get(id).constructor === Model) {\n        (this.get(id) as any).updateProp(key, value);\n      } else {\n        this.get(id)[key] = value;\n      }\n    }\n\n    return { id, key, value };\n  }\n\n  public addRuntimeComponent(componentId: string, component: Component) {\n    (component as any).id = componentId;\n    this.abilityMap[componentId] = component;\n    return component;\n  }\n\n  public get(id: string): Component {\n    return this.abilityMap[id];\n  }\n\n  @pluginHook({ after: \"abilityDeleted\", before: \"beforeAbilityDeleted\" })\n  public delete(id: string) {\n    const ability = this.abilityMap[id];\n    ability.destroy();\n    delete this.abilityMap[id];\n    return id;\n  }\n\n  private getCompConstructor(type: string) {\n    const splits = type.split(\".\");\n    // script\n    if (splits[0] === \"script\") {\n      return scriptAbility[splits[1]];\n    }\n\n    const constructor = Parser._components[\"o3\"][type];\n    if (!constructor) {\n      console.warn(`${type} is not defined`);\n    }\n    return constructor;\n  }\n\n  private mixPropsToExplicitProps(props: Props) {\n    const explicitProps = { ...props };\n    for (let k in props) {\n      const prop = props[k];\n      if (prop && this.checkIsAsset(prop)) {\n        const res = this.oasis.resourceManager.get(prop.id);\n        if (res) {\n          explicitProps[k] = res.resource;\n        } else {\n          explicitProps[k] = null;\n          Logger.warn(`AbilityManager: can't get asset \"${k}\", which id is ${prop.id}`);\n        }\n      }\n    }\n    return explicitProps;\n  }\n\n  private checkIsAsset(prop: any): boolean {\n    return prop.type === \"asset\";\n  }\n}\n", "import { Entity } from \"@oasis-engine/core\";\nimport { Vector3 } from \"@oasis-engine/math\";\nimport { Oasis } from \"./Oasis\";\nimport { pluginHook } from \"./plugins/PluginManager\";\nimport { NodeConfig } from \"./types\";\nimport { switchElementsIndex } from \"./utils\";\n\nexport class NodeManager {\n  private nodeMap: { [id: string]: Entity } = {};\n  private readonly root: Entity;\n\n  constructor(private oasis: Oasis) {\n    this.root = new Entity(this.oasis.engine, \"root\");\n  }\n\n  public addRootEntity() {\n    this.oasis.engine.sceneManager.activeScene.addRootEntity(this.root);\n  }\n\n  @pluginHook({ after: \"nodeAdded\" })\n  public add(nodeConfig: NodeConfig) {\n    this.create(nodeConfig);\n    this.append(nodeConfig.id, nodeConfig.parent, nodeConfig.index);\n    return this.get(nodeConfig.id);\n  }\n\n  @pluginHook({ before: \"beforeNodeUpdated\", after: \"nodeUpdated\" })\n  public update(id: string, key: string, value: any) {\n    this.get(id)[key] = value;\n    return { id, key, value };\n  }\n\n  public get(id: string): Entity {\n    return this.nodeMap[id];\n  }\n\n  public reset() {\n    this.nodeMap = {};\n  }\n\n  @pluginHook({ before: \"beforeNodeDeleted\" })\n  public delete(id: string) {\n    this.nodeMap[id].destroy();\n    delete this.nodeMap[id];\n  }\n\n  private create(nodeConfig: NodeConfig): Entity {\n    const { isActive, position, rotation, scale, id, name } = nodeConfig;\n    const entity = new Entity(this.oasis.engine, name);\n    entity.isActive = isActive;\n    entity.transform.position = new Vector3(position[0], position[1], position[2]);\n    entity.transform.rotation = new Vector3(rotation[0], rotation[1], rotation[2]);\n    entity.transform.scale = new Vector3(scale[0], scale[1], scale[2]);\n    (entity as any).id = id;\n    this.nodeMap[id] = entity;\n    return entity;\n  }\n\n  private append(childId: string, parentId: string, index: number) {\n    const child = this.nodeMap[childId];\n    const parent = this.nodeMap[parentId] || this.root;\n    parent.addChild(child);\n    //@ts-ignore\n    const children = parent._children;\n    const currentIndex = children.length - 1;\n    switchElementsIndex(children, currentIndex, index);\n  }\n}\n", "import { PrimitiveMesh, SkyBoxMaterial } from \"@oasis-engine/core\";\nimport { Oasis } from \"./Oasis\";\nimport { pluginHook } from \"./plugins/PluginManager\";\n\nexport class SceneManager {\n  constructor(private oasis: Oasis) {}\n\n  init() {\n    const { scene } = this.oasis.options.config;\n    if (scene) {\n      Object.keys(scene).forEach((field) => {\n        const fieldConfig = scene[field];\n        Object.keys(fieldConfig.props).forEach((key) => {\n          const prop = fieldConfig.props[key];\n          this.setProp(field, key, prop);\n        });\n      });\n    }\n  }\n\n  @pluginHook({ before: \"beforeSceneUpdated\", after: \"sceneUpdated\" })\n  public update(field: string, key: string, value: any) {\n    this.setProp(field, key, value);\n    return { field, key, value };\n  }\n\n  private setProp(field, key, prop) {\n    const scene = this.oasis.engine.sceneManager.activeScene;\n    if (field === \"background\" && key === \"skyboxTexture\") {\n      const sky = scene.background.sky;\n      if (prop) {\n        sky.mesh = PrimitiveMesh.createCuboid(scene.engine, 2, 2, 2);\n        const skyMaterial = new SkyBoxMaterial(scene.engine);\n        skyMaterial.textureCubeMap = this.oasis.resourceManager.get(prop.id).resource;\n        sky.material = skyMaterial;\n      } else {\n        sky.mesh = null;\n        sky.material = null;\n      }\n    } else if (scene[field]) {\n      if (prop && prop.type === \"asset\") {\n        scene[field][key] = this.oasis.resourceManager.get(prop.id).resource;\n      } else {\n        scene[field][key] = prop;\n      }\n    }\n  }\n}\n", "import { AssetType, ResourceManager, SpriteAtlas } from \"@oasis-engine/core\";\nimport { AssetConfig } from \"../types\";\nimport { getAllGetters } from \"../utils\";\nimport { SchemaResource } from \"./SchemaResource\";\nimport { SpriteResource } from \"./SpriteResource\";\n\nexport class SpriteAtlasResource extends SchemaResource {\n  static defaultAtlas: SpriteAtlas;\n\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig): Promise<SpriteAtlasResource> {\n    return new Promise((resolve) => {\n      this.setMeta();\n      if (assetConfig.source) {\n        resourceManager\n          .load<SpriteAtlas>({\n            url: assetConfig.source,\n            type: AssetType.SpriteAtlas\n          })\n          .then((spriteAtlas) => {\n            this._resource = spriteAtlas;\n            const { sprites } = spriteAtlas;\n            const schemaResourceManager = this.resourceManager;\n            for (let index = sprites.length - 1; index >= 0; index--) {\n              const sprite = sprites[index];\n              const spriteResource = new SpriteResource(schemaResourceManager, sprite);\n              // @ts-ignore\n              const assetID = sprite._assetID;\n              // @ts-ignore\n              schemaResourceManager.maxId = Math.max(assetID, schemaResourceManager.maxId);\n              // @ts-ignore\n              schemaResourceManager.resourceMap[assetID] = spriteResource;\n              // @ts-ignore\n              schemaResourceManager.resourceIdMap.set(spriteResource, \"\" + assetID);\n            }\n            resolve(this);\n          });\n      } else {\n        if (!SpriteAtlasResource.defaultAtlas) {\n          SpriteAtlasResource.defaultAtlas = new SpriteAtlas(resourceManager.engine);\n        }\n        this._resource = SpriteAtlasResource.defaultAtlas;\n        resolve(this);\n      }\n    });\n  }\n\n  setMeta() {\n    if (this.resource) {\n      this.meta.name = this.resource.name;\n    }\n  }\n\n  getProps() {\n    const result = {};\n    const props = getAllGetters(this.resource);\n    props.forEach((prop) => (result[prop] = this.resource[prop]));\n    return result;\n  }\n\n  update() {}\n}\n", "import { ObjectValues, ResourceManager } from \"@oasis-engine/core\";\nimport { Oasis } from \"./Oasis\";\nimport { pluginHook } from \"./plugins/PluginManager\";\nimport {\n  BaseResource,\n  BlinnPhongMaterialResource,\n  GLTFResource,\n  PBRMaterialResource,\n  PBRSpecularMaterialResource,\n  SchemaResource,\n  ScriptResource,\n  SpriteResource,\n  TextureCubeMapResource,\n  TextureResource,\n  UnlitMaterialResource,\n  AnimatorControllerResource,\n  AnimationClipResource\n} from \"./resources\";\nimport { SpriteAtlasResource } from \"./resources/SpriteAtlasResource\";\nimport { AssetConfig } from \"./types\";\n\nexport const RESOURCE_CLASS = {\n  script: ScriptResource,\n  gltf: GLTFResource,\n  texture: TextureResource,\n  // 'image': TextureResource,\n  cubeTexture: TextureCubeMapResource,\n  PBRMaterial: PBRMaterialResource,\n  PBRSpecularMaterial: PBRSpecularMaterialResource,\n  UnlitMaterial: UnlitMaterialResource,\n  BlinnPhongMaterial: BlinnPhongMaterialResource,\n  base: BaseResource,\n  sprite: SpriteResource,\n  SpriteAtlas: SpriteAtlasResource,\n  animatorController: AnimatorControllerResource,\n  animationClip: AnimationClipResource\n};\n\nconst RESOURCE_TYPE: Map<SchemaResource, string> = new Map();\nfor (const key in RESOURCE_CLASS) {\n  if (RESOURCE_CLASS.hasOwnProperty(key)) {\n    const element = RESOURCE_CLASS[key];\n    RESOURCE_TYPE.set(element, key);\n  }\n}\n\nconst resourceFactory = {\n  createResource(resourceManager: SchemaResourceManager, type: string): SchemaResource {\n    return new RESOURCE_CLASS[type](resourceManager);\n  }\n};\n\nexport function registerResource(type: string, resource: any) {\n  if (!RESOURCE_CLASS.hasOwnProperty(type)) {\n    RESOURCE_CLASS[type] = resource;\n    RESOURCE_TYPE.set(resource, type);\n  }\n}\n\nexport class SchemaResourceManager {\n  private resourceMap: { [id: string]: SchemaResource } = {};\n  private resourceIdMap: WeakMap<SchemaResource, string> = new WeakMap();\n  private maxId = 0;\n  private readonly engineResourceManager: ResourceManager;\n\n  constructor(private oasis: Oasis) {\n    this.engineResourceManager = this.oasis.engine.resourceManager;\n  }\n\n  load(asset: AssetConfig): Promise<SchemaResource> {\n    const resource = resourceFactory.createResource(this, asset.type);\n    const loadPromise = resource.load(this.oasis.engine.resourceManager, asset, this.oasis);\n    this.maxId = Math.max(+asset.id, this.maxId);\n    loadPromise.then(() => {\n      this.resourceMap[asset.id] = resource;\n      this.resourceIdMap.set(resource, asset.id);\n    });\n    return loadPromise;\n  }\n\n  add(asset: AssetConfig): Promise<any> {\n    const resource = resourceFactory.createResource(this, asset.type);\n    return new Promise((resolve) => {\n      resource.loadWithAttachedResources(this.oasis.engine.resourceManager, asset, this.oasis).then((result) => {\n        resolve(this.getAddResourceResult(result.resources, result.structure));\n      });\n    });\n  }\n\n  @pluginHook({ before: \"beforeResourceRemove\" })\n  remove(id: string): Promise<Array<string>> {\n    return new Promise((resolve) => {\n      const resource = this.resourceMap[id];\n      const result = [id];\n      let hasAttachedResource = false;\n      delete this.resourceMap[id];\n      if (resource) {\n        const attached = resource.attachedResources;\n        for (let index = 0; index < attached.length; index++) {\n          const attachedResource = attached[index];\n          const attachedResourceId = this.resourceIdMap.get(attachedResource);\n          if (attachedResourceId) {\n            hasAttachedResource = true;\n            this.remove(attachedResourceId).then((attachedResourceRemoveResult) => {\n              result.push(...attachedResourceRemoveResult);\n              resolve(result);\n            });\n          }\n        }\n      }\n      if (!hasAttachedResource) {\n        resolve(result);\n      }\n    });\n  }\n\n  @pluginHook({ after: \"resourceUpdated\", before: \"beforeResourceUpdate\" })\n  update(id: string, key: string, value: any) {\n    const resource = this.get(id);\n    if (resource) {\n      resource.update(key, value);\n    }\n    return {\n      resource,\n      id,\n      key,\n      value\n    };\n  }\n\n  updateMeta(id: string, key: string, value: any) {\n    const resource = this.get(id);\n    if (resource) {\n      resource.updateMeta(key, value);\n    }\n  }\n\n  get(id: string): SchemaResource {\n    return this.resourceMap[id];\n  }\n\n  getAll(): Array<SchemaResource> {\n    return ObjectValues(this.resourceMap);\n  }\n\n  private getAddResourceResult(resources, structure) {\n    const addResourceResult: any = {};\n    const resource = resources[structure.index];\n    const id = `${++this.maxId}`;\n    this.resourceMap[id] = resource;\n    this.resourceIdMap.set(resource, id);\n\n    addResourceResult.id = this.maxId;\n    addResourceResult.type = RESOURCE_TYPE.get(resource.constructor);\n    addResourceResult.meta = resource.meta;\n    addResourceResult.props = {};\n    for (const key in structure.props) {\n      if (structure.props.hasOwnProperty(key)) {\n        const element = structure.props[key];\n        if (element) {\n          if (Array.isArray(element)) {\n            addResourceResult.props[key] = element.map((child) => this.getAddResourceResult(resources, child));\n          } else {\n            addResourceResult.props[key] = this.getAddResourceResult(resources, element);\n          }\n        }\n      }\n    }\n    return addResourceResult;\n  }\n\n  get isLocal(): boolean {\n    return this.oasis.options.local;\n  }\n\n  get useCompressedTexture(): boolean {\n    return this.oasis.options.useCompressedTexture ?? true;\n  }\n}\n", "import { EventDispatcher, ObjectValues } from \"@oasis-engine/core\";\nimport { AbilityManager } from \"./AbilityManager\";\nimport { NodeManager } from \"./NodeManager\";\nimport { SceneManager } from \"./SceneManager\";\nimport { pluginHook, PluginManager } from \"./plugins/PluginManager\";\nimport { RESOURCE_CLASS, SchemaResourceManager } from \"./ResourceManager\";\nimport { Options, Schema } from \"./types\";\n\nexport class Oasis extends EventDispatcher {\n  public readonly nodeManager: NodeManager;\n  public readonly abilityManager: AbilityManager;\n  public readonly sceneManager: SceneManager;\n  public resourceManager: SchemaResourceManager;\n  public _canvas: HTMLCanvasElement;\n  private schema: Schema;\n  public timeout: number;\n  private oasis = this;\n\n  private constructor(private _options: Options, public readonly pluginManager: PluginManager) {\n    super(_options.engine);\n    this.schema = _options.config;\n    this.timeout = _options.timeout;\n    _options.scripts = _options.scripts ?? {};\n    this.nodeManager = new NodeManager(this);\n    this.abilityManager = new AbilityManager(this);\n    this.nodeManager.add = this.nodeManager.add.bind(this.nodeManager);\n    this.abilityManager.add = this.abilityManager.add.bind(this.abilityManager);\n    this.resourceManager = new SchemaResourceManager(this);\n    this.sceneManager = new SceneManager(this);\n    if (_options.fps) {\n      this.engine.targetFrameRate = _options.fps;\n      this.engine.vSyncCount = 0;\n    }\n  }\n\n  public get canvas(): HTMLCanvasElement {\n    return this._options.canvas;\n  }\n\n  public get options(): Readonly<Options> {\n    return this._options;\n  }\n\n  public updateConfig(config: Schema): void {\n    this.schema = config;\n\n    this.init();\n  }\n\n  @pluginHook({ after: \"schemaParsed\" })\n  private init(): Promise<any> {\n    return this.loadResources().then(() => {\n      this.bindResources();\n      this.parseEntities();\n      this.attach();\n      this.nodeManager.addRootEntity();\n      this.sceneManager.init();\n      this.parseNodeAbilities();\n      this.pluginManager.boot(this);\n    });\n  }\n\n  private loadResources(): Promise<any> {\n    const { assets = {} } = this.schema;\n\n    const loadingPromises = ObjectValues(assets)\n      .filter((asset) => {\n        if (RESOURCE_CLASS[asset.type]) {\n          return true;\n        }\n        console.warn(`${asset.type} loader is not defined. the ${asset.type} type will be ignored.`);\n        return false;\n      })\n      .map((asset) => this.resourceManager.load(asset));\n\n    return Promise.all(loadingPromises);\n  }\n\n  private bindResources() {\n    this.resourceManager.getAll().forEach((resource) => {\n      resource.bind();\n    });\n  }\n\n  private parseEntities(): void {\n    const { nodes } = this.schema;\n    const indices = this.bfsNodes();\n    indices.map((index) => nodes[index]).forEach(this.nodeManager.add);\n  }\n\n  private parseNodeAbilities(): void {\n    const { abilities } = this.schema;\n    Object.keys(abilities)\n      .map((id) => ({ id, ...abilities[id] }))\n      .forEach(this.abilityManager.add);\n  }\n\n  private bfsNodes(): number[] {\n    const { nodes } = this.schema;\n    const roots = ObjectValues(nodes)\n      .filter((node) => !nodes[node.parent])\n      .map((node) => node.id);\n\n    let result = [];\n    const traverseChildren = (roots: string[]) => {\n      result = result.concat(roots);\n      roots.forEach((id) => {\n        const children = nodes[id].children;\n        children && traverseChildren(children);\n      });\n    };\n    traverseChildren(roots);\n    return result;\n  }\n\n  private attach() {\n    this.resourceManager.getAll().forEach((resource) => {\n      resource.attach();\n    });\n  }\n\n  static create(options: Options, pluginManager: PluginManager): Promise<Oasis> {\n    const oasis = new Oasis(options, pluginManager);\n    return oasis.init().then(() => {\n      options.autoPlay && oasis.engine.run();\n      return oasis;\n    });\n  }\n}\n", "export * from \"@oasis-engine/core\";\nexport * from \"@oasis-engine/loader\";\nexport * from \"@oasis-engine/math\";\nexport * from \"@oasis-engine/rhi-webgl\";\nimport {\n  AmbientLight,\n  BoxCollider,\n  Camera,\n  Component,\n  DirectLight,\n  ParticleRenderer,\n  PointLight,\n  SphereCollider,\n  SpriteRenderer,\n  SpriteMask,\n  Animator\n} from \"@oasis-engine/core\";\nimport { GLTFModel, Parser, Model } from \"@oasis-engine/loader\";\n\nParser.registerComponents(\"o3\", {\n  GLTFModel,\n  SpriteRenderer,\n  SpriteMask,\n  PointLight,\n  AmbientLight,\n  DirectLight,\n  ParticleRenderer,\n  BoxCollider,\n  Camera,\n  Model,\n  Component,\n  SphereCollider,\n  Animator\n});\n\n//@ts-ignore\nexport const version = `__buildVersion`;\n\nconsole.log(`oasis engine version: ${version}`);\n"],
  "mappings": "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",
  "names": []
}
