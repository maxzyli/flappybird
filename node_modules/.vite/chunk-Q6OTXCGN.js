// node_modules/@oasis-engine/math/dist/module.js
var ContainmentType;
(function(ContainmentType2) {
  ContainmentType2[ContainmentType2["Disjoint"] = 0] = "Disjoint";
  ContainmentType2[ContainmentType2["Contains"] = 1] = "Contains";
  ContainmentType2[ContainmentType2["Intersects"] = 2] = "Intersects";
})(ContainmentType || (ContainmentType = {}));
var PlaneIntersectionType;
(function(PlaneIntersectionType2) {
  PlaneIntersectionType2[PlaneIntersectionType2["Back"] = 0] = "Back";
  PlaneIntersectionType2[PlaneIntersectionType2["Front"] = 1] = "Front";
  PlaneIntersectionType2[PlaneIntersectionType2["Intersecting"] = 2] = "Intersecting";
})(PlaneIntersectionType || (PlaneIntersectionType = {}));
var MathUtil = function() {
  function MathUtil2() {
  }
  MathUtil2.clamp = function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
  };
  MathUtil2.equals = function equals(a, b) {
    return Math.abs(a - b) <= MathUtil2.zeroTolerance;
  };
  MathUtil2.isPowerOf2 = function isPowerOf2(v) {
    return (v & v - 1) === 0;
  };
  MathUtil2.radianToDegree = function radianToDegree(r) {
    return r * MathUtil2.radToDegreeFactor;
  };
  MathUtil2.degreeToRadian = function degreeToRadian(d) {
    return d * MathUtil2.degreeToRadFactor;
  };
  return MathUtil2;
}();
MathUtil.zeroTolerance = 1e-6;
MathUtil.radToDegreeFactor = 180 / Math.PI;
MathUtil.degreeToRadFactor = Math.PI / 180;
var Vector3 = function() {
  Vector32.add = function add(left, right, out) {
    out.x = left.x + right.x;
    out.y = left.y + right.y;
    out.z = left.z + right.z;
  };
  Vector32.subtract = function subtract(left, right, out) {
    out.x = left.x - right.x;
    out.y = left.y - right.y;
    out.z = left.z - right.z;
  };
  Vector32.multiply = function multiply(left, right, out) {
    out.x = left.x * right.x;
    out.y = left.y * right.y;
    out.z = left.z * right.z;
  };
  Vector32.divide = function divide(left, right, out) {
    out.x = left.x / right.x;
    out.y = left.y / right.y;
    out.z = left.z / right.z;
  };
  Vector32.dot = function dot(left, right) {
    return left.x * right.x + left.y * right.y + left.z * right.z;
  };
  Vector32.cross = function cross(left, right, out) {
    var ax = left.x;
    var ay = left.y;
    var az = left.z;
    var bx = right.x;
    var by = right.y;
    var bz = right.z;
    out.x = ay * bz - az * by;
    out.y = az * bx - ax * bz;
    out.z = ax * by - ay * bx;
  };
  Vector32.distance = function distance(a, b) {
    var x = b.x - a.x;
    var y = b.y - a.y;
    var z = b.z - a.z;
    return Math.sqrt(x * x + y * y + z * z);
  };
  Vector32.distanceSquared = function distanceSquared(a, b) {
    var x = b.x - a.x;
    var y = b.y - a.y;
    var z = b.z - a.z;
    return x * x + y * y + z * z;
  };
  Vector32.equals = function equals(left, right) {
    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z);
  };
  Vector32.lerp = function lerp(start, end, t, out) {
    var x = start.x, y = start.y, z = start.z;
    out.x = x + (end.x - x) * t;
    out.y = y + (end.y - y) * t;
    out.z = z + (end.z - z) * t;
  };
  Vector32.max = function max(left, right, out) {
    out.x = Math.max(left.x, right.x);
    out.y = Math.max(left.y, right.y);
    out.z = Math.max(left.z, right.z);
  };
  Vector32.min = function min(left, right, out) {
    out.x = Math.min(left.x, right.x);
    out.y = Math.min(left.y, right.y);
    out.z = Math.min(left.z, right.z);
  };
  Vector32.negate = function negate(a, out) {
    out.x = -a.x;
    out.y = -a.y;
    out.z = -a.z;
  };
  Vector32.normalize = function normalize(a, out) {
    var x = a.x, y = a.y, z = a.z;
    var len = Math.sqrt(x * x + y * y + z * z);
    if (len > 0) {
      len = 1 / len;
      out.x = x * len;
      out.y = y * len;
      out.z = z * len;
    }
  };
  Vector32.scale = function scale(a, s, out) {
    out.x = a.x * s;
    out.y = a.y * s;
    out.z = a.z * s;
  };
  Vector32.transformNormal = function transformNormal(v, m, out) {
    var x = v.x, y = v.y, z = v.z;
    var e = m.elements;
    out.x = x * e[0] + y * e[4] + z * e[8];
    out.y = x * e[1] + y * e[5] + z * e[9];
    out.z = x * e[2] + y * e[6] + z * e[10];
  };
  Vector32.transformToVec3 = function transformToVec3(v, m, out) {
    var x = v.x, y = v.y, z = v.z;
    var e = m.elements;
    out.x = x * e[0] + y * e[4] + z * e[8] + e[12];
    out.y = x * e[1] + y * e[5] + z * e[9] + e[13];
    out.z = x * e[2] + y * e[6] + z * e[10] + e[14];
  };
  Vector32.transformToVec4 = function transformToVec4(v, m, out) {
    var x = v.x, y = v.y, z = v.z;
    var e = m.elements;
    out.x = x * e[0] + y * e[4] + z * e[8] + e[12];
    out.y = x * e[1] + y * e[5] + z * e[9] + e[13];
    out.z = x * e[2] + y * e[6] + z * e[10] + e[14];
    out.w = x * e[3] + y * e[7] + z * e[11] + e[15];
  };
  Vector32.transformCoordinate = function transformCoordinate(v, m, out) {
    var x = v.x, y = v.y, z = v.z;
    var e = m.elements;
    var w = x * e[3] + y * e[7] + z * e[11] + e[15];
    w = 1 / w;
    out.x = (x * e[0] + y * e[4] + z * e[8] + e[12]) * w;
    out.y = (x * e[1] + y * e[5] + z * e[9] + e[13]) * w;
    out.z = (x * e[2] + y * e[6] + z * e[10] + e[14]) * w;
  };
  Vector32.transformByQuat = function transformByQuat(v, quaternion, out) {
    var x = v.x, y = v.y, z = v.z;
    var qx = quaternion.x, qy = quaternion.y, qz = quaternion.z, qw = quaternion.w;
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    out.x = ix * qw - iw * qx - iy * qz + iz * qy;
    out.y = iy * qw - iw * qy - iz * qx + ix * qz;
    out.z = iz * qw - iw * qz - ix * qy + iy * qx;
  };
  function Vector32(x, y, z) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    this.x = void 0;
    this.y = void 0;
    this.z = void 0;
    this.x = x;
    this.y = y;
    this.z = z;
  }
  var _proto = Vector32.prototype;
  _proto.setValue = function setValue(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  };
  _proto.setValueByArray = function setValueByArray(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  };
  _proto.add = function add(right) {
    this.x += right.x;
    this.y += right.y;
    this.z += right.z;
    return this;
  };
  _proto.subtract = function subtract(right) {
    this.x -= right.x;
    this.y -= right.y;
    this.z -= right.z;
    return this;
  };
  _proto.multiply = function multiply(right) {
    this.x *= right.x;
    this.y *= right.y;
    this.z *= right.z;
    return this;
  };
  _proto.divide = function divide(right) {
    this.x /= right.x;
    this.y /= right.y;
    this.z /= right.z;
    return this;
  };
  _proto.length = function length2() {
    var x = this.x, y = this.y, z = this.z;
    return Math.sqrt(x * x + y * y + z * z);
  };
  _proto.lengthSquared = function lengthSquared() {
    var x = this.x, y = this.y, z = this.z;
    return x * x + y * y + z * z;
  };
  _proto.negate = function negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  };
  _proto.normalize = function normalize() {
    Vector32.normalize(this, this);
    return this;
  };
  _proto.scale = function scale(s) {
    this.x *= s;
    this.y *= s;
    this.z *= s;
    return this;
  };
  _proto.toArray = function toArray(out, outOffset) {
    if (outOffset === void 0) {
      outOffset = 0;
    }
    out[outOffset] = this.x;
    out[outOffset + 1] = this.y;
    out[outOffset + 2] = this.z;
  };
  _proto.clone = function clone2() {
    return new Vector32(this.x, this.y, this.z);
  };
  _proto.cloneTo = function cloneTo(out) {
    out.x = this.x;
    out.y = this.y;
    out.z = this.z;
    return out;
  };
  _proto.transformNormal = function transformNormal(m) {
    Vector32.transformNormal(this, m, this);
    return this;
  };
  _proto.transformToVec3 = function transformToVec3(m) {
    Vector32.transformToVec3(this, m, this);
    return this;
  };
  _proto.transformCoordinate = function transformCoordinate(m) {
    Vector32.transformCoordinate(this, m, this);
    return this;
  };
  _proto.transformByQuat = function transformByQuat(quaternion) {
    Vector32.transformByQuat(this, quaternion, this);
    return this;
  };
  return Vector32;
}();
Vector3._zero = new Vector3(0, 0, 0);
Vector3._one = new Vector3(1, 1, 1);
var BoundingSphere = function() {
  BoundingSphere2.fromPoints = function fromPoints(points, out) {
    if (!points || points.length === 0) {
      throw new Error("points must be array and length must > 0");
    }
    var len = points.length;
    var center = BoundingSphere2._tempVec30;
    center.x = center.y = center.z = 0;
    for (var i = 0; i < len; ++i) {
      Vector3.add(points[i], center, center);
    }
    Vector3.scale(center, 1 / len, out.center);
    var radius = 0;
    for (var _i = 0; _i < len; ++_i) {
      var distance = Vector3.distanceSquared(center, points[_i]);
      distance > radius && (radius = distance);
    }
    out.radius = Math.sqrt(radius);
  };
  BoundingSphere2.fromBox = function fromBox(box, out) {
    var center = out.center;
    var min = box.min, max = box.max;
    center.x = (min.x + max.x) * 0.5;
    center.y = (min.y + max.y) * 0.5;
    center.z = (min.z + max.z) * 0.5;
    out.radius = Vector3.distance(center, max);
  };
  function BoundingSphere2(center, radius) {
    if (center === void 0) {
      center = null;
    }
    if (radius === void 0) {
      radius = 0;
    }
    this.center = new Vector3();
    this.radius = 0;
    center && center.cloneTo(this.center);
    this.radius = radius;
  }
  var _proto = BoundingSphere2.prototype;
  _proto.clone = function clone2() {
    return new BoundingSphere2(this.center, this.radius);
  };
  _proto.cloneTo = function cloneTo(out) {
    this.center.cloneTo(out.center);
    out.radius = this.radius;
    return out;
  };
  return BoundingSphere2;
}();
BoundingSphere._tempVec30 = new Vector3();
var BoundingBox = function() {
  BoundingBox2.fromCenterAndExtent = function fromCenterAndExtent(center, extent, out) {
    Vector3.subtract(center, extent, out.min);
    Vector3.add(center, extent, out.max);
  };
  BoundingBox2.fromPoints = function fromPoints(points, out) {
    if (!points || points.length === 0) {
      throw new Error("points must be array and length must > 0");
    }
    var min = out.min, max = out.max;
    min.x = min.y = min.z = Number.MAX_VALUE;
    max.x = max.y = max.z = -Number.MAX_VALUE;
    for (var i = 0, l = points.length; i < l; ++i) {
      var point = points[i];
      Vector3.min(min, point, min);
      Vector3.max(max, point, max);
    }
  };
  BoundingBox2.fromSphere = function fromSphere(sphere, out) {
    var center = sphere.center, radius = sphere.radius;
    var min = out.min, max = out.max;
    min.x = center.x - radius;
    min.y = center.y - radius;
    min.z = center.z - radius;
    max.x = center.x + radius;
    max.y = center.y + radius;
    max.z = center.z + radius;
  };
  BoundingBox2.transform = function transform(source, matrix, out) {
    var center = BoundingBox2._tempVec30;
    var extent = BoundingBox2._tempVec31;
    source.getCenter(center);
    source.getExtent(extent);
    Vector3.transformCoordinate(center, matrix, center);
    var x = extent.x, y = extent.y, z = extent.z;
    var e = matrix.elements;
    extent.x = Math.abs(x * e[0]) + Math.abs(y * e[4]) + Math.abs(z * e[8]);
    extent.y = Math.abs(x * e[1]) + Math.abs(y * e[5]) + Math.abs(z * e[9]);
    extent.z = Math.abs(x * e[2]) + Math.abs(y * e[6]) + Math.abs(z * e[10]);
    Vector3.subtract(center, extent, out.min);
    Vector3.add(center, extent, out.max);
  };
  BoundingBox2.merge = function merge(box1, box2, out) {
    Vector3.min(box1.min, box2.min, out.min);
    Vector3.max(box1.max, box2.max, out.max);
    return out;
  };
  function BoundingBox2(min, max) {
    if (min === void 0) {
      min = null;
    }
    if (max === void 0) {
      max = null;
    }
    this.min = new Vector3();
    this.max = new Vector3();
    min && min.cloneTo(this.min);
    max && max.cloneTo(this.max);
  }
  var _proto = BoundingBox2.prototype;
  _proto.clone = function clone2() {
    return new BoundingBox2(this.min, this.max);
  };
  _proto.cloneTo = function cloneTo(out) {
    this.min.cloneTo(out.min);
    this.max.cloneTo(out.max);
    return out;
  };
  _proto.getCenter = function getCenter(out) {
    Vector3.add(this.min, this.max, out);
    Vector3.scale(out, 0.5, out);
    return out;
  };
  _proto.getExtent = function getExtent(out) {
    Vector3.subtract(this.max, this.min, out);
    Vector3.scale(out, 0.5, out);
    return out;
  };
  _proto.getCorners = function getCorners(out) {
    if (out === void 0) {
      out = [];
    }
    var min = this.min, max = this.max;
    var minX = min.x;
    var minY = min.y;
    var minZ = min.z;
    var maxX = max.x;
    var maxY = max.y;
    var maxZ = max.z;
    var len = out.length;
    if (len < 8) {
      for (var i = 0, l = 8 - len; i < l; ++i) {
        out[len + i] = new Vector3();
      }
    }
    out[0].setValue(minX, maxY, maxZ);
    out[1].setValue(maxX, maxY, maxZ);
    out[2].setValue(maxX, minY, maxZ);
    out[3].setValue(minX, minY, maxZ);
    out[4].setValue(minX, maxY, minZ);
    out[5].setValue(maxX, maxY, minZ);
    out[6].setValue(maxX, minY, minZ);
    out[7].setValue(minX, minY, minZ);
    return out;
  };
  _proto.transform = function transform(matrix) {
    BoundingBox2.transform(this, matrix, this);
    return this;
  };
  return BoundingBox2;
}();
BoundingBox._tempVec30 = new Vector3();
BoundingBox._tempVec31 = new Vector3();
var CollisionUtil = function() {
  function CollisionUtil2() {
  }
  CollisionUtil2.distancePlaneAndPoint = function distancePlaneAndPoint(plane, point) {
    return Vector3.dot(plane.normal, point) + plane.distance;
  };
  CollisionUtil2.intersectsPlaneAndPoint = function intersectsPlaneAndPoint(plane, point) {
    var distance = CollisionUtil2.distancePlaneAndPoint(plane, point);
    if (distance > 0) {
      return PlaneIntersectionType.Front;
    }
    if (distance < 0) {
      return PlaneIntersectionType.Back;
    }
    return PlaneIntersectionType.Intersecting;
  };
  CollisionUtil2.intersectsPlaneAndBox = function intersectsPlaneAndBox(plane, box) {
    var min = box.min, max = box.max;
    var normal = plane.normal;
    var front = CollisionUtil2._tempVec30;
    var back = CollisionUtil2._tempVec31;
    if (normal.x >= 0) {
      front.x = max.x;
      back.x = min.x;
    } else {
      front.x = min.x;
      back.x = max.x;
    }
    if (normal.y >= 0) {
      front.y = max.y;
      back.y = min.y;
    } else {
      front.y = min.y;
      back.y = max.y;
    }
    if (normal.z >= 0) {
      front.z = max.z;
      back.z = min.z;
    } else {
      front.z = min.z;
      back.z = max.z;
    }
    if (CollisionUtil2.distancePlaneAndPoint(plane, front) < 0) {
      return PlaneIntersectionType.Back;
    }
    if (CollisionUtil2.distancePlaneAndPoint(plane, back) > 0) {
      return PlaneIntersectionType.Front;
    }
    return PlaneIntersectionType.Intersecting;
  };
  CollisionUtil2.intersectsPlaneAndSphere = function intersectsPlaneAndSphere(plane, sphere) {
    var center = sphere.center, radius = sphere.radius;
    var distance = CollisionUtil2.distancePlaneAndPoint(plane, center);
    if (distance > radius) {
      return PlaneIntersectionType.Front;
    }
    if (distance < -radius) {
      return PlaneIntersectionType.Back;
    }
    return PlaneIntersectionType.Intersecting;
  };
  CollisionUtil2.intersectsRayAndPlane = function intersectsRayAndPlane(ray, plane) {
    var normal = plane.normal;
    var zeroTolerance = MathUtil.zeroTolerance;
    var dir = Vector3.dot(normal, ray.direction);
    if (Math.abs(dir) < zeroTolerance) {
      return -1;
    }
    var position = Vector3.dot(normal, ray.origin);
    var distance = (-plane.distance - position) / dir;
    if (distance < 0) {
      if (distance < -zeroTolerance) {
        return -1;
      }
      distance = 0;
    }
    return distance;
  };
  CollisionUtil2.intersectsRayAndBox = function intersectsRayAndBox(ray, box) {
    var zeroTolerance = MathUtil.zeroTolerance;
    var origin = ray.origin, direction = ray.direction;
    var min = box.min, max = box.max;
    var dirX = direction.x;
    var dirY = direction.y;
    var dirZ = direction.z;
    var oriX = origin.x;
    var oriY = origin.y;
    var oriZ = origin.z;
    var distance = 0;
    var tmax = Number.MAX_VALUE;
    if (Math.abs(dirX) < zeroTolerance) {
      if (oriX < min.x || oriX > max.x) {
        return -1;
      }
    } else {
      var inverse = 1 / dirX;
      var t1 = (min.x - oriX) * inverse;
      var t2 = (max.x - oriX) * inverse;
      if (t1 > t2) {
        var temp = t1;
        t1 = t2;
        t2 = temp;
      }
      distance = Math.max(t1, distance);
      tmax = Math.min(t2, tmax);
      if (distance > tmax) {
        return -1;
      }
    }
    if (Math.abs(dirY) < zeroTolerance) {
      if (oriY < min.y || oriY > max.y) {
        return -1;
      }
    } else {
      var _inverse = 1 / dirY;
      var _t = (min.y - oriY) * _inverse;
      var _t2 = (max.y - oriY) * _inverse;
      if (_t > _t2) {
        var _temp3 = _t;
        _t = _t2;
        _t2 = _temp3;
      }
      distance = Math.max(_t, distance);
      tmax = Math.min(_t2, tmax);
      if (distance > tmax) {
        return -1;
      }
    }
    if (Math.abs(dirZ) < zeroTolerance) {
      if (oriZ < min.z || oriZ > max.z) {
        return -1;
      }
    } else {
      var _inverse2 = 1 / dirZ;
      var _t3 = (min.z - oriZ) * _inverse2;
      var _t4 = (max.z - oriZ) * _inverse2;
      if (_t3 > _t4) {
        var _temp22 = _t3;
        _t3 = _t4;
        _t4 = _temp22;
      }
      distance = Math.max(_t3, distance);
      tmax = Math.min(_t4, tmax);
      if (distance > tmax) {
        return -1;
      }
    }
    return distance;
  };
  CollisionUtil2.intersectsRayAndSphere = function intersectsRayAndSphere(ray, sphere) {
    var origin = ray.origin, direction = ray.direction;
    var center = sphere.center, radius = sphere.radius;
    var m = CollisionUtil2._tempVec30;
    Vector3.subtract(origin, center, m);
    var b = Vector3.dot(m, direction);
    var c = Vector3.dot(m, m) - radius * radius;
    if (b > 0 && c > 0) {
      return -1;
    }
    var discriminant = b * b - c;
    if (discriminant < 0) {
      return -1;
    }
    var distance = -b - Math.sqrt(discriminant);
    if (distance < 0) {
      distance = 0;
    }
    return distance;
  };
  CollisionUtil2.intersectsFrustumAndBox = function intersectsFrustumAndBox(frustum, box) {
    var min = box.min, max = box.max;
    var back = CollisionUtil2._tempVec30;
    for (var i = 0; i < 6; ++i) {
      var plane = frustum.getPlane(i);
      var normal = plane.normal;
      back.x = normal.x >= 0 ? min.x : max.x;
      back.y = normal.y >= 0 ? min.y : max.y;
      back.z = normal.z >= 0 ? min.z : max.z;
      if (Vector3.dot(plane.normal, back) > -plane.distance) {
        return false;
      }
    }
    return true;
  };
  CollisionUtil2.frustumContainsBox = function frustumContainsBox(frustum, box) {
    var min = box.min, max = box.max;
    var front = CollisionUtil2._tempVec30;
    var back = CollisionUtil2._tempVec31;
    var result = ContainmentType.Contains;
    for (var i = 0; i < 6; ++i) {
      var plane = frustum.getPlane(i);
      var normal = plane.normal;
      if (normal.x >= 0) {
        front.x = max.x;
        back.x = min.x;
      } else {
        front.x = min.x;
        back.x = max.x;
      }
      if (normal.y >= 0) {
        front.y = max.y;
        back.y = min.y;
      } else {
        front.y = min.y;
        back.y = max.y;
      }
      if (normal.z >= 0) {
        front.z = max.z;
        back.z = min.z;
      } else {
        front.z = min.z;
        back.z = max.z;
      }
      if (CollisionUtil2.intersectsPlaneAndPoint(plane, back) === PlaneIntersectionType.Front) {
        return ContainmentType.Disjoint;
      }
      if (CollisionUtil2.intersectsPlaneAndPoint(plane, front) === PlaneIntersectionType.Front) {
        result = ContainmentType.Intersects;
      }
    }
    return result;
  };
  CollisionUtil2.frustumContainsSphere = function frustumContainsSphere(frustum, sphere) {
    var result = ContainmentType.Contains;
    for (var i = 0; i < 6; ++i) {
      var plane = frustum.getPlane(i);
      var intersectionType = CollisionUtil2.intersectsPlaneAndSphere(plane, sphere);
      if (intersectionType === PlaneIntersectionType.Front) {
        return ContainmentType.Disjoint;
      } else if (intersectionType === PlaneIntersectionType.Intersecting) {
        result = ContainmentType.Intersects;
        break;
      }
    }
    return result;
  };
  return CollisionUtil2;
}();
CollisionUtil._tempVec30 = new Vector3();
CollisionUtil._tempVec31 = new Vector3();
var Plane = function() {
  Plane2.normalize = function normalize(p, out) {
    var normal = p.normal;
    var factor = 1 / normal.length();
    var outNormal = out.normal;
    outNormal.x = normal.x * factor;
    outNormal.y = normal.y * factor;
    outNormal.z = normal.z * factor;
    out.distance = p.distance * factor;
  };
  Plane2.fromPoints = function fromPoints(point0, point1, point2, out) {
    var x0 = point0.x;
    var y0 = point0.y;
    var z0 = point0.z;
    var x1 = point1.x - x0;
    var y1 = point1.y - y0;
    var z1 = point1.z - z0;
    var x2 = point2.x - x0;
    var y2 = point2.y - y0;
    var z2 = point2.z - z0;
    var yz = y1 * z2 - z1 * y2;
    var xz = z1 * x2 - x1 * z2;
    var xy = x1 * y2 - y1 * x2;
    var invPyth = 1 / Math.sqrt(yz * yz + xz * xz + xy * xy);
    var x = yz * invPyth;
    var y = xz * invPyth;
    var z = xy * invPyth;
    var normal = out.normal;
    normal.x = x;
    normal.y = y;
    normal.z = z;
    out.distance = -(x * x0 + y * y0 + z * z0);
  };
  function Plane2(normal, distance) {
    if (normal === void 0) {
      normal = null;
    }
    if (distance === void 0) {
      distance = 0;
    }
    this.normal = new Vector3();
    this.distance = 0;
    normal && normal.cloneTo(this.normal);
    this.distance = distance;
  }
  var _proto = Plane2.prototype;
  _proto.normalize = function normalize() {
    Plane2.normalize(this, this);
    return this;
  };
  _proto.clone = function clone2() {
    var out = new Plane2();
    this.cloneTo(out);
    return out;
  };
  _proto.cloneTo = function cloneTo(out) {
    this.normal.cloneTo(out.normal);
    out.distance = this.distance;
    return out;
  };
  return Plane2;
}();
var BoundingFrustum = function() {
  function BoundingFrustum2(matrix) {
    if (matrix === void 0) {
      matrix = null;
    }
    this.near = void 0;
    this.far = void 0;
    this.left = void 0;
    this.right = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.near = new Plane();
    this.far = new Plane();
    this.left = new Plane();
    this.right = new Plane();
    this.top = new Plane();
    this.bottom = new Plane();
    matrix && this.calculateFromMatrix(matrix);
  }
  var _proto = BoundingFrustum2.prototype;
  _proto.clone = function clone2() {
    var bf = new BoundingFrustum2();
    this.cloneTo(bf);
    return bf;
  };
  _proto.cloneTo = function cloneTo(out) {
    this.near.cloneTo(out.near);
    this.far.cloneTo(out.far);
    this.left.cloneTo(out.left);
    this.right.cloneTo(out.right);
    this.top.cloneTo(out.top);
    this.bottom.cloneTo(out.bottom);
    return out;
  };
  _proto.getPlane = function getPlane(index) {
    switch (index) {
      case 0:
        return this.near;
      case 1:
        return this.far;
      case 2:
        return this.left;
      case 3:
        return this.right;
      case 4:
        return this.top;
      case 5:
        return this.bottom;
      default:
        return null;
    }
  };
  _proto.calculateFromMatrix = function calculateFromMatrix(matrix) {
    var me = matrix.elements;
    var m11 = me[0];
    var m12 = me[1];
    var m13 = me[2];
    var m14 = me[3];
    var m21 = me[4];
    var m22 = me[5];
    var m23 = me[6];
    var m24 = me[7];
    var m31 = me[8];
    var m32 = me[9];
    var m33 = me[10];
    var m34 = me[11];
    var m41 = me[12];
    var m42 = me[13];
    var m43 = me[14];
    var m44 = me[15];
    var nearNormal = this.near.normal;
    nearNormal.x = -m14 - m13;
    nearNormal.y = -m24 - m23;
    nearNormal.z = -m34 - m33;
    this.near.distance = -m44 - m43;
    this.near.normalize();
    var farNormal = this.far.normal;
    farNormal.x = m13 - m14;
    farNormal.y = m23 - m24;
    farNormal.z = m33 - m34;
    this.far.distance = m43 - m44;
    this.far.normalize();
    var leftNormal = this.left.normal;
    leftNormal.x = -m14 - m11;
    leftNormal.y = -m24 - m21;
    leftNormal.z = -m34 - m31;
    this.left.distance = -m44 - m41;
    this.left.normalize();
    var rightNormal = this.right.normal;
    rightNormal.x = m11 - m14;
    rightNormal.y = m21 - m24;
    rightNormal.z = m31 - m34;
    this.right.distance = m41 - m44;
    this.right.normalize();
    var topNormal = this.top.normal;
    topNormal.x = m12 - m14;
    topNormal.y = m22 - m24;
    topNormal.z = m32 - m34;
    this.top.distance = m42 - m44;
    this.top.normalize();
    var bottomNormal = this.bottom.normal;
    bottomNormal.x = -m14 - m12;
    bottomNormal.y = -m24 - m22;
    bottomNormal.z = -m34 - m32;
    this.bottom.distance = -m44 - m42;
    this.bottom.normalize();
  };
  _proto.intersectsBox = function intersectsBox(box) {
    return CollisionUtil.intersectsFrustumAndBox(this, box);
  };
  _proto.intersectsSphere = function intersectsSphere(sphere) {
    return CollisionUtil.frustumContainsSphere(this, sphere) !== ContainmentType.Disjoint;
  };
  return BoundingFrustum2;
}();
var Matrix3x3 = function() {
  Matrix3x32.add = function add(left, right, out) {
    var le = left.elements;
    var re = right.elements;
    var oe = out.elements;
    oe[0] = le[0] + re[0];
    oe[1] = le[1] + re[1];
    oe[2] = le[2] + re[2];
    oe[3] = le[3] + re[3];
    oe[4] = le[4] + re[4];
    oe[5] = le[5] + re[5];
    oe[6] = le[6] + re[6];
    oe[7] = le[7] + re[7];
    oe[8] = le[8] + re[8];
  };
  Matrix3x32.subtract = function subtract(left, right, out) {
    var le = left.elements;
    var re = right.elements;
    var oe = out.elements;
    oe[0] = le[0] - re[0];
    oe[1] = le[1] - re[1];
    oe[2] = le[2] - re[2];
    oe[3] = le[3] - re[3];
    oe[4] = le[4] - re[4];
    oe[5] = le[5] - re[5];
    oe[6] = le[6] - re[6];
    oe[7] = le[7] - re[7];
    oe[8] = le[8] - re[8];
  };
  Matrix3x32.multiply = function multiply(left, right, out) {
    var le = left.elements;
    var re = right.elements;
    var oe = out.elements;
    var l11 = le[0], l12 = le[1], l13 = le[2];
    var l21 = le[3], l22 = le[4], l23 = le[5];
    var l31 = le[6], l32 = le[7], l33 = le[8];
    var r11 = re[0], r12 = re[1], r13 = re[2];
    var r21 = re[3], r22 = re[4], r23 = re[5];
    var r31 = re[6], r32 = re[7], r33 = re[8];
    oe[0] = l11 * r11 + l21 * r12 + l31 * r13;
    oe[1] = l12 * r11 + l22 * r12 + l32 * r13;
    oe[2] = l13 * r11 + l23 * r12 + l33 * r13;
    oe[3] = l11 * r21 + l21 * r22 + l31 * r23;
    oe[4] = l12 * r21 + l22 * r22 + l32 * r23;
    oe[5] = l13 * r21 + l23 * r22 + l33 * r23;
    oe[6] = l11 * r31 + l21 * r32 + l31 * r33;
    oe[7] = l12 * r31 + l22 * r32 + l32 * r33;
    oe[8] = l13 * r31 + l23 * r32 + l33 * r33;
  };
  Matrix3x32.equals = function equals(left, right) {
    var le = left.elements;
    var re = right.elements;
    return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]);
  };
  Matrix3x32.lerp = function lerp(start, end, t, out) {
    var se = start.elements;
    var ee = end.elements;
    var oe = out.elements;
    var inv = 1 - t;
    oe[0] = se[0] * inv + ee[0] * t;
    oe[1] = se[1] * inv + ee[1] * t;
    oe[2] = se[2] * inv + ee[2] * t;
    oe[3] = se[3] * inv + ee[3] * t;
    oe[4] = se[4] * inv + ee[4] * t;
    oe[5] = se[5] * inv + ee[5] * t;
    oe[6] = se[6] * inv + ee[6] * t;
    oe[7] = se[7] * inv + ee[7] * t;
    oe[8] = se[8] * inv + ee[8] * t;
  };
  Matrix3x32.rotationQuaternion = function rotationQuaternion(quaternion, out) {
    var oe = out.elements;
    var x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    oe[0] = 1 - yy - zz;
    oe[3] = yx - wz;
    oe[6] = zx + wy;
    oe[1] = yx + wz;
    oe[4] = 1 - xx - zz;
    oe[7] = zy - wx;
    oe[2] = zx - wy;
    oe[5] = zy + wx;
    oe[8] = 1 - xx - yy;
  };
  Matrix3x32.scaling = function scaling(s, out) {
    var oe = out.elements;
    oe[0] = s.x;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = s.y;
    oe[5] = 0;
    oe[6] = 0;
    oe[7] = 0;
    oe[8] = 1;
  };
  Matrix3x32.translation = function translation(_translation, out) {
    var oe = out.elements;
    oe[0] = 1;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = 1;
    oe[5] = 0;
    oe[6] = _translation.x;
    oe[7] = _translation.y;
    oe[8] = 1;
  };
  Matrix3x32.invert = function invert(a, out) {
    var ae = a.elements;
    var oe = out.elements;
    var a11 = ae[0], a12 = ae[1], a13 = ae[2];
    var a21 = ae[3], a22 = ae[4], a23 = ae[5];
    var a31 = ae[6], a32 = ae[7], a33 = ae[8];
    var b12 = a33 * a22 - a23 * a32;
    var b22 = -a33 * a21 + a23 * a31;
    var b32 = a32 * a21 - a22 * a31;
    var det = a11 * b12 + a12 * b22 + a13 * b32;
    if (!det) {
      return;
    }
    det = 1 / det;
    oe[0] = b12 * det;
    oe[1] = (-a33 * a12 + a13 * a32) * det;
    oe[2] = (a23 * a12 - a13 * a22) * det;
    oe[3] = b22 * det;
    oe[4] = (a33 * a11 - a13 * a31) * det;
    oe[5] = (-a23 * a11 + a13 * a21) * det;
    oe[6] = b32 * det;
    oe[7] = (-a32 * a11 + a12 * a31) * det;
    oe[8] = (a22 * a11 - a12 * a21) * det;
  };
  Matrix3x32.normalMatrix = function normalMatrix(mat4, out) {
    var ae = mat4.elements;
    var oe = out.elements;
    var a11 = ae[0], a12 = ae[1], a13 = ae[2], a14 = ae[3];
    var a21 = ae[4], a22 = ae[5], a23 = ae[6], a24 = ae[7];
    var a31 = ae[8], a32 = ae[9], a33 = ae[10], a34 = ae[11];
    var a41 = ae[12], a42 = ae[13], a43 = ae[14], a44 = ae[15];
    var b00 = a11 * a22 - a12 * a21;
    var b01 = a11 * a23 - a13 * a21;
    var b02 = a11 * a24 - a14 * a21;
    var b03 = a12 * a23 - a13 * a22;
    var b04 = a12 * a24 - a14 * a22;
    var b05 = a13 * a24 - a14 * a23;
    var b06 = a31 * a42 - a32 * a41;
    var b07 = a31 * a43 - a33 * a41;
    var b08 = a31 * a44 - a34 * a41;
    var b09 = a32 * a43 - a33 * a42;
    var b10 = a32 * a44 - a34 * a42;
    var b11 = a33 * a44 - a34 * a43;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
    oe[1] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
    oe[2] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
    oe[3] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
    oe[4] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
    oe[5] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
    oe[6] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
    oe[7] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
    oe[8] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
  };
  Matrix3x32.rotate = function rotate(a, r, out) {
    var ae = a.elements;
    var oe = out.elements;
    var s = Math.sin(r);
    var c = Math.cos(r);
    var a11 = ae[0], a12 = ae[1], a13 = ae[2];
    var a21 = ae[3], a22 = ae[4], a23 = ae[5];
    var a31 = ae[6], a32 = ae[7], a33 = ae[8];
    oe[0] = c * a11 + s * a21;
    oe[1] = c * a12 + s * a22;
    oe[2] = c * a13 + s * a23;
    oe[3] = c * a21 - s * a11;
    oe[4] = c * a22 - s * a12;
    oe[5] = c * a23 - s * a13;
    oe[6] = a31;
    oe[7] = a32;
    oe[8] = a33;
  };
  Matrix3x32.scale = function scale(m, s, out) {
    var x = s.x, y = s.y;
    var ae = m.elements;
    var oe = out.elements;
    oe[0] = x * ae[0];
    oe[1] = x * ae[1];
    oe[2] = x * ae[2];
    oe[3] = y * ae[3];
    oe[4] = y * ae[4];
    oe[5] = y * ae[5];
    oe[6] = ae[6];
    oe[7] = ae[7];
    oe[8] = ae[8];
  };
  Matrix3x32.translate = function translate(m, translation, out) {
    var x = translation.x, y = translation.y;
    var ae = m.elements;
    var oe = out.elements;
    var a11 = ae[0], a12 = ae[1], a13 = ae[2];
    var a21 = ae[3], a22 = ae[4], a23 = ae[5];
    var a31 = ae[6], a32 = ae[7], a33 = ae[8];
    oe[0] = a11;
    oe[1] = a12;
    oe[2] = a13;
    oe[3] = a21;
    oe[4] = a22;
    oe[5] = a23;
    oe[6] = x * a11 + y * a21 + a31;
    oe[7] = x * a12 + y * a22 + a32;
    oe[8] = x * a13 + y * a23 + a33;
  };
  Matrix3x32.transpose = function transpose(a, out) {
    var ae = a.elements;
    var oe = out.elements;
    if (out === a) {
      var a12 = ae[1];
      var a13 = ae[2];
      var a23 = ae[5];
      oe[1] = ae[3];
      oe[2] = ae[6];
      oe[3] = a12;
      oe[5] = ae[7];
      oe[6] = a13;
      oe[7] = a23;
    } else {
      oe[0] = ae[0];
      oe[1] = ae[3];
      oe[2] = ae[6];
      oe[3] = ae[1];
      oe[4] = ae[4];
      oe[5] = ae[7];
      oe[6] = ae[2];
      oe[7] = ae[5];
      oe[8] = ae[8];
    }
  };
  function Matrix3x32(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
    if (m11 === void 0) {
      m11 = 1;
    }
    if (m12 === void 0) {
      m12 = 0;
    }
    if (m13 === void 0) {
      m13 = 0;
    }
    if (m21 === void 0) {
      m21 = 0;
    }
    if (m22 === void 0) {
      m22 = 1;
    }
    if (m23 === void 0) {
      m23 = 0;
    }
    if (m31 === void 0) {
      m31 = 0;
    }
    if (m32 === void 0) {
      m32 = 0;
    }
    if (m33 === void 0) {
      m33 = 1;
    }
    this.elements = new Float32Array(9);
    var e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m21;
    e[4] = m22;
    e[5] = m23;
    e[6] = m31;
    e[7] = m32;
    e[8] = m33;
  }
  var _proto = Matrix3x32.prototype;
  _proto.setValue = function setValue(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
    var e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m21;
    e[4] = m22;
    e[5] = m23;
    e[6] = m31;
    e[7] = m32;
    e[8] = m33;
    return this;
  };
  _proto.setValueByArray = function setValueByArray(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var srce = this.elements;
    for (var i = 0; i < 12; i++) {
      srce[i] = array[i + offset];
    }
    return this;
  };
  _proto.setValueByMatrix = function setValueByMatrix(a) {
    var ae = a.elements;
    var e = this.elements;
    e[0] = ae[0];
    e[1] = ae[1];
    e[2] = ae[2];
    e[3] = ae[4];
    e[4] = ae[5];
    e[5] = ae[6];
    e[6] = ae[8];
    e[7] = ae[9];
    e[8] = ae[10];
    return this;
  };
  _proto.toArray = function toArray(out, outOffset) {
    if (outOffset === void 0) {
      outOffset = 0;
    }
    var e = this.elements;
    out[outOffset] = e[0];
    out[outOffset + 1] = e[1];
    out[outOffset + 2] = e[2];
    out[outOffset + 3] = e[3];
    out[outOffset + 4] = e[4];
    out[outOffset + 5] = e[5];
    out[outOffset + 6] = e[6];
    out[outOffset + 7] = e[7];
    out[outOffset + 8] = e[8];
  };
  _proto.clone = function clone2() {
    var e = this.elements;
    var ret = new Matrix3x32(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
    return ret;
  };
  _proto.cloneTo = function cloneTo(out) {
    var e = this.elements;
    var oe = out.elements;
    oe[0] = e[0];
    oe[1] = e[1];
    oe[2] = e[2];
    oe[3] = e[3];
    oe[4] = e[4];
    oe[5] = e[5];
    oe[6] = e[6];
    oe[7] = e[7];
    oe[8] = e[8];
    return out;
  };
  _proto.add = function add(right) {
    Matrix3x32.add(this, right, this);
    return this;
  };
  _proto.subtract = function subtract(right) {
    Matrix3x32.subtract(this, right, this);
    return this;
  };
  _proto.multiply = function multiply(right) {
    Matrix3x32.multiply(this, right, this);
    return this;
  };
  _proto.determinant = function determinant() {
    var e = this.elements;
    var a11 = e[0], a12 = e[1], a13 = e[2];
    var a21 = e[3], a22 = e[4], a23 = e[5];
    var a31 = e[6], a32 = e[7], a33 = e[8];
    var b12 = a33 * a22 - a23 * a32;
    var b22 = -a33 * a21 + a23 * a31;
    var b32 = a32 * a21 - a22 * a31;
    return a11 * b12 + a12 * b22 + a13 * b32;
  };
  _proto.identity = function identity() {
    var e = this.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 1;
    e[5] = 0;
    e[6] = 0;
    e[7] = 0;
    e[8] = 1;
    return this;
  };
  _proto.invert = function invert() {
    Matrix3x32.invert(this, this);
    return this;
  };
  _proto.rotate = function rotate(r) {
    Matrix3x32.rotate(this, r, this);
    return this;
  };
  _proto.scale = function scale(s) {
    Matrix3x32.scale(this, s, this);
    return this;
  };
  _proto.translate = function translate(translation) {
    Matrix3x32.translate(this, translation, this);
    return this;
  };
  _proto.transpose = function transpose() {
    Matrix3x32.transpose(this, this);
    return this;
  };
  return Matrix3x32;
}();
var Quaternion = function() {
  Quaternion2.add = function add(left, right, out) {
    out.x = left.x + right.x;
    out.y = left.y + right.y;
    out.z = left.z + right.z;
    out.w = left.w + right.w;
  };
  Quaternion2.multiply = function multiply(left, right, out) {
    var ax = left.x, ay = left.y, az = left.z, aw = left.w;
    var bx = right.x, by = right.y, bz = right.z, bw = right.w;
    out.x = ax * bw + aw * bx + ay * bz - az * by;
    out.y = ay * bw + aw * by + az * bx - ax * bz;
    out.z = az * bw + aw * bz + ax * by - ay * bx;
    out.w = aw * bw - ax * bx - ay * by - az * bz;
  };
  Quaternion2.conjugate = function conjugate(a, out) {
    out.x = -a.x;
    out.y = -a.y;
    out.z = -a.z;
    out.w = a.w;
  };
  Quaternion2.dot = function dot(left, right) {
    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
  };
  Quaternion2.equals = function equals(left, right) {
    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z) && MathUtil.equals(left.w, right.w);
  };
  Quaternion2.rotationAxisAngle = function rotationAxisAngle(axis, rad, out) {
    var normalAxis = Quaternion2._tempVector3;
    Vector3.normalize(axis, normalAxis);
    rad *= 0.5;
    var s = Math.sin(rad);
    out.x = normalAxis.x * s;
    out.y = normalAxis.y * s;
    out.z = normalAxis.z * s;
    out.w = Math.cos(rad);
  };
  Quaternion2.rotationEuler = function rotationEuler(x, y, z, out) {
    Quaternion2.rotationYawPitchRoll(y, x, z, out);
  };
  Quaternion2.rotationYawPitchRoll = function rotationYawPitchRoll(yaw, pitch, roll, out) {
    var halfRoll = roll * 0.5;
    var halfPitch = pitch * 0.5;
    var halfYaw = yaw * 0.5;
    var sinRoll = Math.sin(halfRoll);
    var cosRoll = Math.cos(halfRoll);
    var sinPitch = Math.sin(halfPitch);
    var cosPitch = Math.cos(halfPitch);
    var sinYaw = Math.sin(halfYaw);
    var cosYaw = Math.cos(halfYaw);
    var cosYawPitch = cosYaw * cosPitch;
    var sinYawPitch = sinYaw * sinPitch;
    out.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
    out.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
    out.z = cosYawPitch * sinRoll - sinYawPitch * cosRoll;
    out.w = cosYawPitch * cosRoll + sinYawPitch * sinRoll;
  };
  Quaternion2.rotationMatrix3x3 = function rotationMatrix3x3(m, out) {
    var me = m.elements;
    var m11 = me[0], m12 = me[1], m13 = me[2];
    var m21 = me[3], m22 = me[4], m23 = me[5];
    var m31 = me[6], m32 = me[7], m33 = me[8];
    var scale = m11 + m22 + m33;
    var sqrt, half;
    if (scale > 0) {
      sqrt = Math.sqrt(scale + 1);
      out.w = sqrt * 0.5;
      sqrt = 0.5 / sqrt;
      out.x = (m23 - m32) * sqrt;
      out.y = (m31 - m13) * sqrt;
      out.z = (m12 - m21) * sqrt;
    } else if (m11 >= m22 && m11 >= m33) {
      sqrt = Math.sqrt(1 + m11 - m22 - m33);
      half = 0.5 / sqrt;
      out.x = 0.5 * sqrt;
      out.y = (m12 + m21) * half;
      out.z = (m13 + m31) * half;
      out.w = (m23 - m32) * half;
    } else if (m22 > m33) {
      sqrt = Math.sqrt(1 + m22 - m11 - m33);
      half = 0.5 / sqrt;
      out.x = (m21 + m12) * half;
      out.y = 0.5 * sqrt;
      out.z = (m32 + m23) * half;
      out.w = (m31 - m13) * half;
    } else {
      sqrt = Math.sqrt(1 + m33 - m11 - m22);
      half = 0.5 / sqrt;
      out.x = (m13 + m31) * half;
      out.y = (m23 + m32) * half;
      out.z = 0.5 * sqrt;
      out.w = (m12 - m21) * half;
    }
  };
  Quaternion2.invert = function invert(a, out) {
    var x = a.x, y = a.y, z = a.z, w = a.w;
    var dot = x * x + y * y + z * z + w * w;
    if (dot > MathUtil.zeroTolerance) {
      var invDot = 1 / dot;
      out.x = -x * invDot;
      out.y = -y * invDot;
      out.z = -z * invDot;
      out.w = w * invDot;
    }
  };
  Quaternion2.lerp = function lerp(start, end, t, out) {
    var inv = 1 - t;
    if (Quaternion2.dot(start, end) >= 0) {
      out.x = start.x * inv + end.x * t;
      out.y = start.y * inv + end.y * t;
      out.z = start.z * inv + end.z * t;
      out.w = start.w * inv + end.w * t;
    } else {
      out.x = start.x * inv - end.x * t;
      out.y = start.y * inv - end.y * t;
      out.z = start.z * inv - end.z * t;
      out.w = start.w * inv - end.w * t;
    }
    out.normalize();
  };
  Quaternion2.slerp = function slerp(start, end, t, out) {
    var ax = start.x;
    var ay = start.y;
    var az = start.z;
    var aw = start.w;
    var bx = end.x;
    var by = end.y;
    var bz = end.z;
    var bw = end.w;
    var scale0, scale1;
    var cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > MathUtil.zeroTolerance) {
      var omega = Math.acos(cosom);
      var sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      scale0 = 1 - t;
      scale1 = t;
    }
    out.x = scale0 * ax + scale1 * bx;
    out.y = scale0 * ay + scale1 * by;
    out.z = scale0 * az + scale1 * bz;
    out.w = scale0 * aw + scale1 * bw;
  };
  Quaternion2.normalize = function normalize(a, out) {
    var x = a.x, y = a.y, z = a.z, w = a.w;
    var len = Math.sqrt(x * x + y * y + z * z + w * w);
    if (len > MathUtil.zeroTolerance) {
      len = 1 / len;
      out.x = x * len;
      out.y = y * len;
      out.z = z * len;
      out.w = w * len;
    }
  };
  Quaternion2.rotationX = function rotationX(rad, out) {
    rad *= 0.5;
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out.x = s;
    out.y = 0;
    out.z = 0;
    out.w = c;
  };
  Quaternion2.rotationY = function rotationY(rad, out) {
    rad *= 0.5;
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out.x = 0;
    out.y = s;
    out.z = 0;
    out.w = c;
  };
  Quaternion2.rotationZ = function rotationZ(rad, out) {
    rad *= 0.5;
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out.x = 0;
    out.y = 0;
    out.z = s;
    out.w = c;
  };
  Quaternion2.rotateX = function rotateX(quaternion, rad, out) {
    var x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;
    rad *= 0.5;
    var bx = Math.sin(rad);
    var bw = Math.cos(rad);
    out.x = x * bw + w * bx;
    out.y = y * bw + z * bx;
    out.z = z * bw - y * bx;
    out.w = w * bw - x * bx;
  };
  Quaternion2.rotateY = function rotateY(quaternion, rad, out) {
    var x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;
    rad *= 0.5;
    var by = Math.sin(rad);
    var bw = Math.cos(rad);
    out.x = x * bw - z * by;
    out.y = y * bw + w * by;
    out.z = z * bw + x * by;
    out.w = w * bw - y * by;
  };
  Quaternion2.rotateZ = function rotateZ(quaternion, rad, out) {
    var x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;
    rad *= 0.5;
    var bz = Math.sin(rad);
    var bw = Math.cos(rad);
    out.x = x * bw + y * bz;
    out.y = y * bw - x * bz;
    out.z = z * bw + w * bz;
    out.w = w * bw - z * bz;
  };
  Quaternion2.scale = function scale(a, s, out) {
    out.x = a.x * s;
    out.y = a.y * s;
    out.z = a.z * s;
    out.w = a.w * s;
  };
  function Quaternion2(x, y, z, w) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (w === void 0) {
      w = 1;
    }
    this.x = void 0;
    this.y = void 0;
    this.z = void 0;
    this.w = void 0;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  var _proto = Quaternion2.prototype;
  _proto.setValue = function setValue(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  };
  _proto.setValueByArray = function setValueByArray(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  };
  _proto.conjugate = function conjugate() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    return this;
  };
  _proto.getAxisAngle = function getAxisAngle(out) {
    var x = this.x, y = this.y, z = this.z;
    var length2 = x * x + y * y + z * z;
    if (length2 < MathUtil.zeroTolerance) {
      out.x = 1;
      out.y = 0;
      out.z = 0;
      return 0;
    } else {
      var inv = 1 / length2;
      out.x = this.x * inv;
      out.y = this.y * inv;
      out.z = this.z * inv;
      return Math.acos(this.w) * 2;
    }
  };
  _proto.identity = function identity() {
    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.w = 1;
    return this;
  };
  _proto.length = function length2() {
    var x = this.x, y = this.y, z = this.z, w = this.w;
    return Math.sqrt(x * x + y * y + z * z + w * w);
  };
  _proto.lengthSquared = function lengthSquared() {
    var x = this.x, y = this.y, z = this.z, w = this.w;
    return x * x + y * y + z * z + w * w;
  };
  _proto.normalize = function normalize() {
    Quaternion2.normalize(this, this);
    return this;
  };
  _proto.toEuler = function toEuler(out) {
    this.toYawPitchRoll(out);
    var t = out.x;
    out.x = out.y;
    out.y = t;
    return out;
  };
  _proto.toYawPitchRoll = function toYawPitchRoll(out) {
    var x = this.x, y = this.y, z = this.z, w = this.w;
    var xx = x * x;
    var yy = y * y;
    var zz = z * z;
    var xy = x * y;
    var zw = z * w;
    var zx = z * x;
    var yw = y * w;
    var yz = y * z;
    var xw = x * w;
    out.y = Math.asin(2 * (xw - yz));
    if (Math.cos(out.y) > MathUtil.zeroTolerance) {
      out.z = Math.atan2(2 * (xy + zw), 1 - 2 * (zz + xx));
      out.x = Math.atan2(2 * (zx + yw), 1 - 2 * (yy + xx));
    } else {
      out.z = Math.atan2(-2 * (xy - zw), 1 - 2 * (yy + zz));
      out.x = 0;
    }
    return out;
  };
  _proto.toArray = function toArray(out, outOffset) {
    if (outOffset === void 0) {
      outOffset = 0;
    }
    out[outOffset] = this.x;
    out[outOffset + 1] = this.y;
    out[outOffset + 2] = this.z;
    out[outOffset + 3] = this.w;
  };
  _proto.clone = function clone2() {
    return new Quaternion2(this.x, this.y, this.z, this.w);
  };
  _proto.cloneTo = function cloneTo(out) {
    out.x = this.x;
    out.y = this.y;
    out.z = this.z;
    out.w = this.w;
    return out;
  };
  _proto.rotateX = function rotateX(rad) {
    Quaternion2.rotateX(this, rad, this);
    return this;
  };
  _proto.rotateY = function rotateY(rad) {
    Quaternion2.rotateY(this, rad, this);
    return this;
  };
  _proto.rotateZ = function rotateZ(rad) {
    Quaternion2.rotateZ(this, rad, this);
    return this;
  };
  _proto.rotationAxisAngle = function rotationAxisAngle(axis, rad) {
    Quaternion2.rotationAxisAngle(axis, rad, this);
    return this;
  };
  _proto.multiply = function multiply(quat) {
    Quaternion2.multiply(this, quat, this);
    return this;
  };
  _proto.invert = function invert() {
    Quaternion2.invert(this, this);
    return this;
  };
  _proto.dot = function dot(quat) {
    return Quaternion2.dot(this, quat);
  };
  _proto.lerp = function lerp(quat, t) {
    Quaternion2.lerp(this, quat, t, this);
    return this;
  };
  _proto.rotateAxisAngle = function rotateAxisAngle(axis, rad) {
    Quaternion2._tempQuat1.rotationAxisAngle(axis, rad);
    this.multiply(Quaternion2._tempQuat1);
    return this;
  };
  return Quaternion2;
}();
Quaternion._tempVector3 = new Vector3();
Quaternion._tempQuat1 = new Quaternion();
var Matrix = function() {
  Matrix2.multiply = function multiply(left, right, out) {
    var le = left.elements;
    var re = right.elements;
    var oe = out.elements;
    var l11 = le[0], l12 = le[1], l13 = le[2], l14 = le[3];
    var l21 = le[4], l22 = le[5], l23 = le[6], l24 = le[7];
    var l31 = le[8], l32 = le[9], l33 = le[10], l34 = le[11];
    var l41 = le[12], l42 = le[13], l43 = le[14], l44 = le[15];
    var r11 = re[0], r12 = re[1], r13 = re[2], r14 = re[3];
    var r21 = re[4], r22 = re[5], r23 = re[6], r24 = re[7];
    var r31 = re[8], r32 = re[9], r33 = re[10], r34 = re[11];
    var r41 = re[12], r42 = re[13], r43 = re[14], r44 = re[15];
    oe[0] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;
    oe[1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;
    oe[2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;
    oe[3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;
    oe[4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;
    oe[5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;
    oe[6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;
    oe[7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;
    oe[8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;
    oe[9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;
    oe[10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;
    oe[11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;
    oe[12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;
    oe[13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;
    oe[14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;
    oe[15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;
  };
  Matrix2.equals = function equals(left, right) {
    var le = left.elements;
    var re = right.elements;
    return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]) && MathUtil.equals(le[9], re[9]) && MathUtil.equals(le[10], re[10]) && MathUtil.equals(le[11], re[11]) && MathUtil.equals(le[12], re[12]) && MathUtil.equals(le[13], re[13]) && MathUtil.equals(le[14], re[14]) && MathUtil.equals(le[15], re[15]);
  };
  Matrix2.lerp = function lerp(start, end, t, out) {
    var se = start.elements;
    var ee = end.elements;
    var oe = out.elements;
    var inv = 1 - t;
    oe[0] = se[0] * inv + ee[0] * t;
    oe[1] = se[1] * inv + ee[1] * t;
    oe[2] = se[2] * inv + ee[2] * t;
    oe[3] = se[3] * inv + ee[3] * t;
    oe[4] = se[4] * inv + ee[4] * t;
    oe[5] = se[5] * inv + ee[5] * t;
    oe[6] = se[6] * inv + ee[6] * t;
    oe[7] = se[7] * inv + ee[7] * t;
    oe[8] = se[8] * inv + ee[8] * t;
    oe[9] = se[9] * inv + ee[9] * t;
    oe[10] = se[10] * inv + ee[10] * t;
    oe[11] = se[11] * inv + ee[11] * t;
    oe[12] = se[12] * inv + ee[12] * t;
    oe[13] = se[13] * inv + ee[13] * t;
    oe[14] = se[14] * inv + ee[14] * t;
    oe[15] = se[15] * inv + ee[15] * t;
  };
  Matrix2.rotationQuaternion = function rotationQuaternion(quaternion, out) {
    var oe = out.elements;
    var x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    oe[0] = 1 - yy - zz;
    oe[1] = yx + wz;
    oe[2] = zx - wy;
    oe[3] = 0;
    oe[4] = yx - wz;
    oe[5] = 1 - xx - zz;
    oe[6] = zy + wx;
    oe[7] = 0;
    oe[8] = zx + wy;
    oe[9] = zy - wx;
    oe[10] = 1 - xx - yy;
    oe[11] = 0;
    oe[12] = 0;
    oe[13] = 0;
    oe[14] = 0;
    oe[15] = 1;
  };
  Matrix2.rotationAxisAngle = function rotationAxisAngle(axis, r, out) {
    var oe = out.elements;
    var x = axis.x, y = axis.y, z = axis.z;
    var len = Math.sqrt(x * x + y * y + z * z);
    var s, c, t;
    if (Math.abs(len) < MathUtil.zeroTolerance) {
      return;
    }
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(r);
    c = Math.cos(r);
    t = 1 - c;
    oe[0] = x * x * t + c;
    oe[1] = y * x * t + z * s;
    oe[2] = z * x * t - y * s;
    oe[3] = 0;
    oe[4] = x * y * t - z * s;
    oe[5] = y * y * t + c;
    oe[6] = z * y * t + x * s;
    oe[7] = 0;
    oe[8] = x * z * t + y * s;
    oe[9] = y * z * t - x * s;
    oe[10] = z * z * t + c;
    oe[11] = 0;
    oe[12] = 0;
    oe[13] = 0;
    oe[14] = 0;
    oe[15] = 1;
  };
  Matrix2.rotationTranslation = function rotationTranslation(quaternion, translation, out) {
    Matrix2.rotationQuaternion(quaternion, out);
    var oe = out.elements;
    oe[12] = translation.x;
    oe[13] = translation.y;
    oe[14] = translation.z;
  };
  Matrix2.affineTransformation = function affineTransformation(scale, rotation, translation, out) {
    var oe = out.elements;
    var x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w;
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = scale.x;
    var sy = scale.y;
    var sz = scale.z;
    oe[0] = (1 - (yy + zz)) * sx;
    oe[1] = (xy + wz) * sx;
    oe[2] = (xz - wy) * sx;
    oe[3] = 0;
    oe[4] = (xy - wz) * sy;
    oe[5] = (1 - (xx + zz)) * sy;
    oe[6] = (yz + wx) * sy;
    oe[7] = 0;
    oe[8] = (xz + wy) * sz;
    oe[9] = (yz - wx) * sz;
    oe[10] = (1 - (xx + yy)) * sz;
    oe[11] = 0;
    oe[12] = translation.x;
    oe[13] = translation.y;
    oe[14] = translation.z;
    oe[15] = 1;
  };
  Matrix2.scaling = function scaling(s, out) {
    var oe = out.elements;
    oe[0] = s.x;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = 0;
    oe[5] = s.y;
    oe[6] = 0;
    oe[7] = 0;
    oe[8] = 0;
    oe[9] = 0;
    oe[10] = s.z;
    oe[11] = 0;
    oe[12] = 0;
    oe[13] = 0;
    oe[14] = 0;
    oe[15] = 1;
  };
  Matrix2.translation = function translation(_translation, out) {
    var oe = out.elements;
    oe[0] = 1;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = 0;
    oe[5] = 1;
    oe[6] = 0;
    oe[7] = 0;
    oe[8] = 0;
    oe[9] = 0;
    oe[10] = 1;
    oe[11] = 0;
    oe[12] = _translation.x;
    oe[13] = _translation.y;
    oe[14] = _translation.z;
    oe[15] = 1;
  };
  Matrix2.invert = function invert(a, out) {
    var ae = a.elements;
    var oe = out.elements;
    var a11 = ae[0], a12 = ae[1], a13 = ae[2], a14 = ae[3];
    var a21 = ae[4], a22 = ae[5], a23 = ae[6], a24 = ae[7];
    var a31 = ae[8], a32 = ae[9], a33 = ae[10], a34 = ae[11];
    var a41 = ae[12], a42 = ae[13], a43 = ae[14], a44 = ae[15];
    var b00 = a11 * a22 - a12 * a21;
    var b01 = a11 * a23 - a13 * a21;
    var b02 = a11 * a24 - a14 * a21;
    var b03 = a12 * a23 - a13 * a22;
    var b04 = a12 * a24 - a14 * a22;
    var b05 = a13 * a24 - a14 * a23;
    var b06 = a31 * a42 - a32 * a41;
    var b07 = a31 * a43 - a33 * a41;
    var b08 = a31 * a44 - a34 * a41;
    var b09 = a32 * a43 - a33 * a42;
    var b10 = a32 * a44 - a34 * a42;
    var b11 = a33 * a44 - a34 * a43;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
    oe[1] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
    oe[2] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
    oe[3] = (a33 * b04 - a32 * b05 - a34 * b03) * det;
    oe[4] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
    oe[5] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
    oe[6] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
    oe[7] = (a31 * b05 - a33 * b02 + a34 * b01) * det;
    oe[8] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
    oe[9] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
    oe[10] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
    oe[11] = (a32 * b02 - a31 * b04 - a34 * b00) * det;
    oe[12] = (a22 * b07 - a21 * b09 - a23 * b06) * det;
    oe[13] = (a11 * b09 - a12 * b07 + a13 * b06) * det;
    oe[14] = (a42 * b01 - a41 * b03 - a43 * b00) * det;
    oe[15] = (a31 * b03 - a32 * b01 + a33 * b00) * det;
  };
  Matrix2.lookAt = function lookAt(eye, target, up, out) {
    var oe = out.elements;
    var xAxis = Matrix2._tempVec30;
    var yAxis = Matrix2._tempVec31;
    var zAxis = Matrix2._tempVec32;
    Vector3.subtract(eye, target, zAxis);
    zAxis.normalize();
    Vector3.cross(up, zAxis, xAxis);
    xAxis.normalize();
    Vector3.cross(zAxis, xAxis, yAxis);
    oe[0] = xAxis.x;
    oe[1] = yAxis.x;
    oe[2] = zAxis.x;
    oe[3] = 0;
    oe[4] = xAxis.y;
    oe[5] = yAxis.y;
    oe[6] = zAxis.y;
    oe[7] = 0;
    oe[8] = xAxis.z;
    oe[9] = yAxis.z;
    oe[10] = zAxis.z;
    oe[11] = 0;
    oe[12] = -Vector3.dot(xAxis, eye);
    oe[13] = -Vector3.dot(yAxis, eye);
    oe[14] = -Vector3.dot(zAxis, eye);
    oe[15] = 1;
  };
  Matrix2.ortho = function ortho(left, right, bottom, top, near, far, out) {
    var oe = out.elements;
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    oe[0] = -2 * lr;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = 0;
    oe[5] = -2 * bt;
    oe[6] = 0;
    oe[7] = 0;
    oe[8] = 0;
    oe[9] = 0;
    oe[10] = 2 * nf;
    oe[11] = 0;
    oe[12] = (left + right) * lr;
    oe[13] = (top + bottom) * bt;
    oe[14] = (far + near) * nf;
    oe[15] = 1;
  };
  Matrix2.perspective = function perspective(fovy, aspect, near, far, out) {
    var oe = out.elements;
    var f = 1 / Math.tan(fovy / 2);
    var nf = 1 / (near - far);
    oe[0] = f / aspect;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = 0;
    oe[5] = f;
    oe[6] = 0;
    oe[7] = 0;
    oe[8] = 0;
    oe[9] = 0;
    oe[10] = (far + near) * nf;
    oe[11] = -1;
    oe[12] = 0;
    oe[13] = 0;
    oe[14] = 2 * far * near * nf;
    oe[15] = 0;
  };
  Matrix2.rotateAxisAngle = function rotateAxisAngle(m, axis, r, out) {
    var x = axis.x, y = axis.y, z = axis.z;
    var len = Math.sqrt(x * x + y * y + z * z);
    if (Math.abs(len) < MathUtil.zeroTolerance) {
      return;
    }
    var me = m.elements;
    var oe = out.elements;
    var s, c, t;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(r);
    c = Math.cos(r);
    t = 1 - c;
    var a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];
    var a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];
    var a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];
    var b11 = x * x * t + c;
    var b12 = y * x * t + z * s;
    var b13 = z * x * t - y * s;
    var b21 = x * y * t - z * s;
    var b22 = y * y * t + c;
    var b23 = z * y * t + x * s;
    var b31 = x * z * t + y * s;
    var b32 = y * z * t - x * s;
    var b33 = z * z * t + c;
    oe[0] = a11 * b11 + a21 * b12 + a31 * b13;
    oe[1] = a12 * b11 + a22 * b12 + a32 * b13;
    oe[2] = a13 * b11 + a23 * b12 + a33 * b13;
    oe[3] = a14 * b11 + a24 * b12 + a34 * b13;
    oe[4] = a11 * b21 + a21 * b22 + a31 * b23;
    oe[5] = a12 * b21 + a22 * b22 + a32 * b23;
    oe[6] = a13 * b21 + a23 * b22 + a33 * b23;
    oe[7] = a14 * b21 + a24 * b22 + a34 * b23;
    oe[8] = a11 * b31 + a21 * b32 + a31 * b33;
    oe[9] = a12 * b31 + a22 * b32 + a32 * b33;
    oe[10] = a13 * b31 + a23 * b32 + a33 * b33;
    oe[11] = a14 * b31 + a24 * b32 + a34 * b33;
    if (m !== out) {
      oe[12] = me[12];
      oe[13] = me[13];
      oe[14] = me[14];
      oe[15] = me[15];
    }
  };
  Matrix2.scale = function scale(m, s, out) {
    var me = m.elements;
    var oe = out.elements;
    var x = s.x, y = s.y, z = s.z;
    oe[0] = me[0] * x;
    oe[1] = me[1] * x;
    oe[2] = me[2] * x;
    oe[3] = me[3] * x;
    oe[4] = me[4] * y;
    oe[5] = me[5] * y;
    oe[6] = me[6] * y;
    oe[7] = me[7] * y;
    oe[8] = me[8] * z;
    oe[9] = me[9] * z;
    oe[10] = me[10] * z;
    oe[11] = me[11] * z;
    oe[12] = me[12];
    oe[13] = me[13];
    oe[14] = me[14];
    oe[15] = me[15];
  };
  Matrix2.translate = function translate(m, v, out) {
    var me = m.elements;
    var oe = out.elements;
    var x = v.x, y = v.y, z = v.z;
    if (m === out) {
      oe[12] = me[0] * x + me[4] * y + me[8] * z + me[12];
      oe[13] = me[1] * x + me[5] * y + me[9] * z + me[13];
      oe[14] = me[2] * x + me[6] * y + me[10] * z + me[14];
      oe[15] = me[3] * x + me[7] * y + me[11] * z + me[15];
    } else {
      var a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];
      var a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];
      var a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];
      oe[0] = a11, oe[1] = a12, oe[2] = a13, oe[3] = a14;
      oe[4] = a21, oe[5] = a22, oe[6] = a23, oe[7] = a24;
      oe[8] = a31, oe[9] = a32, oe[10] = a33, oe[11] = a34;
      oe[12] = a11 * x + a21 * y + a31 * z + me[12];
      oe[13] = a12 * x + a22 * y + a32 * z + me[13];
      oe[14] = a13 * x + a23 * y + a33 * z + me[14];
      oe[15] = a14 * x + a24 * y + a34 * z + me[15];
    }
  };
  Matrix2.transpose = function transpose(a, out) {
    var ae = a.elements;
    var oe = out.elements;
    if (out === a) {
      var a12 = ae[1];
      var a13 = ae[2];
      var a14 = ae[3];
      var a23 = ae[6];
      var a24 = ae[7];
      var a34 = ae[11];
      oe[1] = ae[4];
      oe[2] = ae[8];
      oe[3] = ae[12];
      oe[4] = a12;
      oe[6] = ae[9];
      oe[7] = ae[13];
      oe[8] = a13;
      oe[9] = a23;
      oe[11] = ae[14];
      oe[12] = a14;
      oe[13] = a24;
      oe[14] = a34;
    } else {
      oe[0] = ae[0];
      oe[1] = ae[4];
      oe[2] = ae[8];
      oe[3] = ae[12];
      oe[4] = ae[1];
      oe[5] = ae[5];
      oe[6] = ae[9];
      oe[7] = ae[13];
      oe[8] = ae[2];
      oe[9] = ae[6];
      oe[10] = ae[10];
      oe[11] = ae[14];
      oe[12] = ae[3];
      oe[13] = ae[7];
      oe[14] = ae[11];
      oe[15] = ae[15];
    }
  };
  function Matrix2(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
    if (m11 === void 0) {
      m11 = 1;
    }
    if (m12 === void 0) {
      m12 = 0;
    }
    if (m13 === void 0) {
      m13 = 0;
    }
    if (m14 === void 0) {
      m14 = 0;
    }
    if (m21 === void 0) {
      m21 = 0;
    }
    if (m22 === void 0) {
      m22 = 1;
    }
    if (m23 === void 0) {
      m23 = 0;
    }
    if (m24 === void 0) {
      m24 = 0;
    }
    if (m31 === void 0) {
      m31 = 0;
    }
    if (m32 === void 0) {
      m32 = 0;
    }
    if (m33 === void 0) {
      m33 = 1;
    }
    if (m34 === void 0) {
      m34 = 0;
    }
    if (m41 === void 0) {
      m41 = 0;
    }
    if (m42 === void 0) {
      m42 = 0;
    }
    if (m43 === void 0) {
      m43 = 0;
    }
    if (m44 === void 0) {
      m44 = 1;
    }
    this.elements = new Float32Array(16);
    var e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m14;
    e[4] = m21;
    e[5] = m22;
    e[6] = m23;
    e[7] = m24;
    e[8] = m31;
    e[9] = m32;
    e[10] = m33;
    e[11] = m34;
    e[12] = m41;
    e[13] = m42;
    e[14] = m43;
    e[15] = m44;
  }
  var _proto = Matrix2.prototype;
  _proto.setValue = function setValue(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
    var e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m14;
    e[4] = m21;
    e[5] = m22;
    e[6] = m23;
    e[7] = m24;
    e[8] = m31;
    e[9] = m32;
    e[10] = m33;
    e[11] = m34;
    e[12] = m41;
    e[13] = m42;
    e[14] = m43;
    e[15] = m44;
    return this;
  };
  _proto.setValueByArray = function setValueByArray(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var srce = this.elements;
    for (var i = 0; i < 16; i++) {
      srce[i] = array[i + offset];
    }
    return this;
  };
  _proto.toArray = function toArray(out, outOffset) {
    if (outOffset === void 0) {
      outOffset = 0;
    }
    var e = this.elements;
    out[outOffset] = e[0];
    out[outOffset + 1] = e[1];
    out[outOffset + 2] = e[2];
    out[outOffset + 3] = e[3];
    out[outOffset + 4] = e[4];
    out[outOffset + 5] = e[5];
    out[outOffset + 6] = e[6];
    out[outOffset + 7] = e[7];
    out[outOffset + 8] = e[8];
    out[outOffset + 9] = e[9];
    out[outOffset + 10] = e[10];
    out[outOffset + 11] = e[11];
    out[outOffset + 12] = e[12];
    out[outOffset + 13] = e[13];
    out[outOffset + 14] = e[14];
    out[outOffset + 15] = e[15];
  };
  _proto.clone = function clone2() {
    var e = this.elements;
    var ret = new Matrix2(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
    return ret;
  };
  _proto.cloneTo = function cloneTo(out) {
    var e = this.elements;
    var oe = out.elements;
    oe[0] = e[0];
    oe[1] = e[1];
    oe[2] = e[2];
    oe[3] = e[3];
    oe[4] = e[4];
    oe[5] = e[5];
    oe[6] = e[6];
    oe[7] = e[7];
    oe[8] = e[8];
    oe[9] = e[9];
    oe[10] = e[10];
    oe[11] = e[11];
    oe[12] = e[12];
    oe[13] = e[13];
    oe[14] = e[14];
    oe[15] = e[15];
    return out;
  };
  _proto.multiply = function multiply(right) {
    Matrix2.multiply(this, right, this);
    return this;
  };
  _proto.determinant = function determinant() {
    var e = this.elements;
    var a11 = e[0], a12 = e[1], a13 = e[2], a14 = e[3];
    var a21 = e[4], a22 = e[5], a23 = e[6], a24 = e[7];
    var a31 = e[8], a32 = e[9], a33 = e[10], a34 = e[11];
    var a41 = e[12], a42 = e[13], a43 = e[14], a44 = e[15];
    var b00 = a11 * a22 - a12 * a21;
    var b01 = a11 * a23 - a13 * a21;
    var b02 = a11 * a24 - a14 * a21;
    var b03 = a12 * a23 - a13 * a22;
    var b04 = a12 * a24 - a14 * a22;
    var b05 = a13 * a24 - a14 * a23;
    var b06 = a31 * a42 - a32 * a41;
    var b07 = a31 * a43 - a33 * a41;
    var b08 = a31 * a44 - a34 * a41;
    var b09 = a32 * a43 - a33 * a42;
    var b10 = a32 * a44 - a34 * a42;
    var b11 = a33 * a44 - a34 * a43;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  };
  _proto.decompose = function decompose(translation, rotation, scale) {
    var rm = Matrix2._tempMat30;
    var e = this.elements;
    var rme = rm.elements;
    var m11 = e[0];
    var m12 = e[1];
    var m13 = e[2];
    var m14 = e[3];
    var m21 = e[4];
    var m22 = e[5];
    var m23 = e[6];
    var m24 = e[7];
    var m31 = e[8];
    var m32 = e[9];
    var m33 = e[10];
    var m34 = e[11];
    translation.x = e[12];
    translation.y = e[13];
    translation.z = e[14];
    var xs = Math.sign(m11 * m12 * m13 * m14) < 0 ? -1 : 1;
    var ys = Math.sign(m21 * m22 * m23 * m24) < 0 ? -1 : 1;
    var zs = Math.sign(m31 * m32 * m33 * m34) < 0 ? -1 : 1;
    var sx = xs * Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    var sy = ys * Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    var sz = zs * Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    if (Math.abs(sx) < MathUtil.zeroTolerance || Math.abs(sy) < MathUtil.zeroTolerance || Math.abs(sz) < MathUtil.zeroTolerance) {
      rotation.identity();
      return false;
    } else {
      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;
      rme[0] = m11 * invSX;
      rme[1] = m12 * invSX;
      rme[2] = m13 * invSX;
      rme[3] = m21 * invSY;
      rme[4] = m22 * invSY;
      rme[5] = m23 * invSY;
      rme[6] = m31 * invSZ;
      rme[7] = m32 * invSZ;
      rme[8] = m33 * invSZ;
      Quaternion.rotationMatrix3x3(rm, rotation);
      return true;
    }
  };
  _proto.getRotation = function getRotation(out) {
    var e = this.elements;
    var trace = e[0] + e[5] + e[10];
    if (trace > MathUtil.zeroTolerance) {
      var S = Math.sqrt(trace + 1) * 2;
      out.w = 0.25 * S;
      out.x = (e[6] - e[9]) / S;
      out.y = (e[8] - e[2]) / S;
      out.z = (e[1] - e[4]) / S;
    } else if (e[0] > e[5] && e[0] > e[10]) {
      var _S = Math.sqrt(1 + e[0] - e[5] - e[10]) * 2;
      out.w = (e[6] - e[9]) / _S;
      out.x = 0.25 * _S;
      out.y = (e[1] + e[4]) / _S;
      out.z = (e[8] + e[2]) / _S;
    } else if (e[5] > e[10]) {
      var _S2 = Math.sqrt(1 + e[5] - e[0] - e[10]) * 2;
      out.w = (e[8] - e[2]) / _S2;
      out.x = (e[1] + e[4]) / _S2;
      out.y = 0.25 * _S2;
      out.z = (e[6] + e[9]) / _S2;
    } else {
      var _S3 = Math.sqrt(1 + e[10] - e[0] - e[5]) * 2;
      out.w = (e[1] - e[4]) / _S3;
      out.x = (e[8] + e[2]) / _S3;
      out.y = (e[6] + e[9]) / _S3;
      out.z = 0.25 * _S3;
    }
    return out;
  };
  _proto.getScaling = function getScaling(out) {
    var e = this.elements;
    var m11 = e[0], m12 = e[1], m13 = e[2];
    var m21 = e[4], m22 = e[5], m23 = e[6];
    var m31 = e[8], m32 = e[9], m33 = e[10];
    out.x = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out.y = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out.z = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    return out;
  };
  _proto.getTranslation = function getTranslation(out) {
    var e = this.elements;
    out.x = e[12];
    out.y = e[13];
    out.z = e[14];
    return out;
  };
  _proto.identity = function identity() {
    var e = this.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 0;
    e[5] = 1;
    e[6] = 0;
    e[7] = 0;
    e[8] = 0;
    e[9] = 0;
    e[10] = 1;
    e[11] = 0;
    e[12] = 0;
    e[13] = 0;
    e[14] = 0;
    e[15] = 1;
    return this;
  };
  _proto.invert = function invert() {
    Matrix2.invert(this, this);
    return this;
  };
  _proto.rotateAxisAngle = function rotateAxisAngle(axis, r) {
    Matrix2.rotateAxisAngle(this, axis, r, this);
    return this;
  };
  _proto.scale = function scale(s) {
    Matrix2.scale(this, s, this);
    return this;
  };
  _proto.translate = function translate(v) {
    Matrix2.translate(this, v, this);
    return this;
  };
  _proto.transpose = function transpose() {
    Matrix2.transpose(this, this);
    return this;
  };
  return Matrix2;
}();
Matrix._tempVec30 = new Vector3();
Matrix._tempVec31 = new Vector3();
Matrix._tempVec32 = new Vector3();
Matrix._tempMat30 = new Matrix3x3();
Matrix._identity = new Matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
var Ray = function() {
  function Ray2(origin, direction) {
    if (origin === void 0) {
      origin = null;
    }
    if (direction === void 0) {
      direction = null;
    }
    this.origin = new Vector3();
    this.direction = new Vector3();
    origin && origin.cloneTo(this.origin);
    direction && direction.cloneTo(this.direction);
  }
  var _proto = Ray2.prototype;
  _proto.intersectPlane = function intersectPlane(plane) {
    return CollisionUtil.intersectsRayAndPlane(this, plane);
  };
  _proto.intersectSphere = function intersectSphere(sphere) {
    return CollisionUtil.intersectsRayAndSphere(this, sphere);
  };
  _proto.intersectBox = function intersectBox(box) {
    return CollisionUtil.intersectsRayAndBox(this, box);
  };
  _proto.getPoint = function getPoint(distance, out) {
    Vector3.scale(this.direction, distance, out);
    return out.add(this.origin);
  };
  return Ray2;
}();
var Vector2 = function() {
  Vector22.add = function add(left, right, out) {
    out.x = left.x + right.x;
    out.y = left.y + right.y;
  };
  Vector22.subtract = function subtract(left, right, out) {
    out.x = left.x - right.x;
    out.y = left.y - right.y;
  };
  Vector22.multiply = function multiply(left, right, out) {
    out.x = left.x * right.x;
    out.y = left.y * right.y;
  };
  Vector22.divide = function divide(left, right, out) {
    out.x = left.x / right.x;
    out.y = left.y / right.y;
  };
  Vector22.dot = function dot(left, right) {
    return left.x * right.x + left.y * right.y;
  };
  Vector22.distance = function distance(left, right) {
    var x = right.x - left.x;
    var y = right.y - left.y;
    return Math.sqrt(x * x + y * y);
  };
  Vector22.distanceSquared = function distanceSquared(left, right) {
    var x = right.x - left.x;
    var y = right.y - left.y;
    return x * x + y * y;
  };
  Vector22.equals = function equals(left, right) {
    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y);
  };
  Vector22.lerp = function lerp(left, right, t, out) {
    var x = left.x, y = left.y;
    out.x = x + (right.x - x) * t;
    out.y = y + (right.y - y) * t;
  };
  Vector22.max = function max(left, right, out) {
    out.x = Math.max(left.x, right.x);
    out.y = Math.max(left.y, right.y);
  };
  Vector22.min = function min(left, right, out) {
    out.x = Math.min(left.x, right.x);
    out.y = Math.min(left.y, right.y);
  };
  Vector22.negate = function negate(left, out) {
    out.x = -left.x;
    out.y = -left.y;
  };
  Vector22.normalize = function normalize(left, out) {
    var x = left.x, y = left.y;
    var len = Math.sqrt(x * x + y * y);
    if (len > MathUtil.zeroTolerance) {
      len = 1 / len;
      out.x = x * len;
      out.y = y * len;
    }
  };
  Vector22.scale = function scale(left, s, out) {
    out.x = left.x * s;
    out.y = left.y * s;
  };
  function Vector22(x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this.x = void 0;
    this.y = void 0;
    this.x = x;
    this.y = y;
  }
  var _proto = Vector22.prototype;
  _proto.setValue = function setValue(x, y) {
    this.x = x;
    this.y = y;
    return this;
  };
  _proto.setValueByArray = function setValueByArray(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  };
  _proto.add = function add(right) {
    this.x += right.x;
    this.y += right.y;
    return this;
  };
  _proto.subtract = function subtract(right) {
    this.x -= right.x;
    this.y -= right.y;
    return this;
  };
  _proto.multiply = function multiply(right) {
    this.x *= right.x;
    this.y *= right.y;
    return this;
  };
  _proto.divide = function divide(right) {
    this.x /= right.x;
    this.y /= right.y;
    return this;
  };
  _proto.length = function length2() {
    var x = this.x, y = this.y;
    return Math.sqrt(x * x + y * y);
  };
  _proto.lengthSquared = function lengthSquared() {
    var x = this.x, y = this.y;
    return x * x + y * y;
  };
  _proto.negate = function negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  };
  _proto.normalize = function normalize() {
    Vector22.normalize(this, this);
    return this;
  };
  _proto.scale = function scale(s) {
    this.x *= s;
    this.y *= s;
    return this;
  };
  _proto.toArray = function toArray(out, outOffset) {
    if (outOffset === void 0) {
      outOffset = 0;
    }
    out[outOffset] = this.x;
    out[outOffset + 1] = this.y;
  };
  _proto.clone = function clone2() {
    return new Vector22(this.x, this.y);
  };
  _proto.cloneTo = function cloneTo(out) {
    out.x = this.x;
    out.y = this.y;
    return out;
  };
  return Vector22;
}();
Vector2._zero = new Vector2(0, 0);
Vector2._one = new Vector2(1, 1);
var Vector4 = function() {
  Vector42.add = function add(left, right, out) {
    out.x = left.x + right.x;
    out.y = left.y + right.y;
    out.z = left.z + right.z;
    out.w = left.w + right.w;
  };
  Vector42.subtract = function subtract(left, right, out) {
    out.x = left.x - right.x;
    out.y = left.y - right.y;
    out.z = left.z - right.z;
    out.w = left.w - right.w;
  };
  Vector42.multiply = function multiply(left, right, out) {
    out.x = left.x * right.x;
    out.y = left.y * right.y;
    out.z = left.z * right.z;
    out.w = left.w * right.w;
  };
  Vector42.divide = function divide(left, right, out) {
    out.x = left.x / right.x;
    out.y = left.y / right.y;
    out.z = left.z / right.z;
    out.w = left.w / right.w;
  };
  Vector42.dot = function dot(left, right) {
    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
  };
  Vector42.distance = function distance(a, b) {
    var x = b.x - a.x;
    var y = b.y - a.y;
    var z = b.z - a.z;
    var w = b.w - a.w;
    return Math.sqrt(x * x + y * y + z * z + w * w);
  };
  Vector42.distanceSquared = function distanceSquared(a, b) {
    var x = b.x - a.x;
    var y = b.y - a.y;
    var z = b.z - a.z;
    var w = b.w - a.w;
    return x * x + y * y + z * z + w * w;
  };
  Vector42.equals = function equals(left, right) {
    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z) && MathUtil.equals(left.w, right.w);
  };
  Vector42.lerp = function lerp(start, end, t, out) {
    var x = start.x, y = start.y, z = start.z, w = start.w;
    out.x = x + (end.x - x) * t;
    out.y = y + (end.y - y) * t;
    out.z = z + (end.z - z) * t;
    out.w = w + (end.w - w) * t;
  };
  Vector42.max = function max(left, right, out) {
    out.x = Math.max(left.x, right.x);
    out.y = Math.max(left.y, right.y);
    out.z = Math.max(left.z, right.z);
    out.w = Math.max(left.w, right.w);
  };
  Vector42.min = function min(left, right, out) {
    out.x = Math.min(left.x, right.x);
    out.y = Math.min(left.y, right.y);
    out.z = Math.min(left.z, right.z);
    out.w = Math.min(left.w, right.w);
  };
  Vector42.negate = function negate(a, out) {
    out.x = -a.x;
    out.y = -a.y;
    out.z = -a.z;
    out.w = -a.w;
  };
  Vector42.normalize = function normalize(a, out) {
    var x = a.x, y = a.y, z = a.z, w = a.w;
    var len = Math.sqrt(x * x + y * y + z * z + w * w);
    if (len > MathUtil.zeroTolerance) {
      len = 1 / len;
      out.x = x * len;
      out.y = y * len;
      out.z = z * len;
      out.w = w * len;
    }
  };
  Vector42.scale = function scale(a, s, out) {
    out.x = a.x * s;
    out.y = a.y * s;
    out.z = a.z * s;
    out.w = a.w * s;
  };
  Vector42.transform = function transform(v, m, out) {
    var x = v.x, y = v.y, z = v.z, w = v.w;
    var e = m.elements;
    out.x = x * e[0] + y * e[4] + z * e[8] + w * e[12];
    out.y = x * e[1] + y * e[5] + z * e[9] + w * e[13];
    out.z = x * e[2] + y * e[6] + z * e[10] + w * e[14];
    out.w = x * e[3] + y * e[7] + z * e[11] + w * e[15];
  };
  Vector42.transformByQuat = function transformByQuat(v, q, out) {
    var x = v.x, y = v.y, z = v.z, w = v.w;
    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    out.x = ix * qw - iw * qx - iy * qz + iz * qy;
    out.y = iy * qw - iw * qy - iz * qx + ix * qz;
    out.z = iz * qw - iw * qz - ix * qy + iy * qx;
    out.w = w;
  };
  function Vector42(x, y, z, w) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (w === void 0) {
      w = 0;
    }
    this.x = void 0;
    this.y = void 0;
    this.z = void 0;
    this.w = void 0;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  var _proto = Vector42.prototype;
  _proto.setValue = function setValue(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  };
  _proto.setValueByArray = function setValueByArray(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  };
  _proto.add = function add(right) {
    this.x += right.x;
    this.y += right.y;
    this.z += right.z;
    this.w += right.w;
    return this;
  };
  _proto.subtract = function subtract(right) {
    this.x -= right.x;
    this.y -= right.y;
    this.z -= right.z;
    this.w -= right.w;
    return this;
  };
  _proto.multiply = function multiply(right) {
    this.x *= right.x;
    this.y *= right.y;
    this.z *= right.z;
    this.w *= right.w;
    return this;
  };
  _proto.divide = function divide(right) {
    this.x /= right.x;
    this.y /= right.y;
    this.z /= right.z;
    this.w /= right.w;
    return this;
  };
  _proto.length = function length2() {
    var x = this.x, y = this.y, z = this.z, w = this.w;
    return Math.sqrt(x * x + y * y + z * z + w * w);
  };
  _proto.lengthSquared = function lengthSquared() {
    var x = this.x, y = this.y, z = this.z, w = this.w;
    return x * x + y * y + z * z + w * w;
  };
  _proto.negate = function negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  };
  _proto.normalize = function normalize() {
    Vector42.normalize(this, this);
    return this;
  };
  _proto.scale = function scale(s) {
    this.x *= s;
    this.y *= s;
    this.z *= s;
    this.w *= s;
    return this;
  };
  _proto.toArray = function toArray(out, outOffset) {
    if (outOffset === void 0) {
      outOffset = 0;
    }
    out[outOffset] = this.x;
    out[outOffset + 1] = this.y;
    out[outOffset + 2] = this.z;
    out[outOffset + 3] = this.w;
  };
  _proto.clone = function clone2() {
    var ret = new Vector42(this.x, this.y, this.z, this.w);
    return ret;
  };
  _proto.cloneTo = function cloneTo(out) {
    out.x = this.x;
    out.y = this.y;
    out.z = this.z;
    out.w = this.w;
    return out;
  };
  return Vector42;
}();
Vector4._zero = new Vector4(0, 0, 0, 0);
Vector4._one = new Vector4(1, 1, 1, 1);
var Color = function() {
  Color2.gammaToLinearSpace = function gammaToLinearSpace(value) {
    if (value <= 0)
      return 0;
    else if (value <= 0.04045)
      return value / 12.92;
    else if (value < 1)
      return Math.pow((value + 0.055) / 1.055, 2.4);
    else
      return Math.pow(value, 2.4);
  };
  Color2.linearToGammaSpace = function linearToGammaSpace(value) {
    if (value <= 0)
      return 0;
    else if (value < 31308e-7)
      return 12.92 * value;
    else if (value < 1)
      return 1.055 * Math.pow(value, 0.41666) - 0.055;
    else
      return Math.pow(value, 0.41666);
  };
  Color2.equals = function equals(left, right) {
    return MathUtil.equals(left.r, right.r) && MathUtil.equals(left.g, right.g) && MathUtil.equals(left.b, right.b) && MathUtil.equals(left.a, right.a);
  };
  Color2.add = function add(left, right, out) {
    out.r = left.r + right.r;
    out.g = left.g + right.g;
    out.b = left.b + right.b;
    out.a = left.a + right.a;
    return out;
  };
  Color2.scale = function scale(left, s, out) {
    out.r = left.r * s;
    out.g = left.g * s;
    out.b = left.b * s;
    out.a = left.a * s;
    return out;
  };
  function Color2(r, g, b, a) {
    if (r === void 0) {
      r = 1;
    }
    if (g === void 0) {
      g = 1;
    }
    if (b === void 0) {
      b = 1;
    }
    if (a === void 0) {
      a = 1;
    }
    this.r = void 0;
    this.g = void 0;
    this.b = void 0;
    this.a = void 0;
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  var _proto = Color2.prototype;
  _proto.setValue = function setValue(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    return this;
  };
  _proto.add = function add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    this.a += color.a;
    return this;
  };
  _proto.scale = function scale(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    this.a *= s;
    return this;
  };
  _proto.clone = function clone2() {
    var ret = new Color2(this.r, this.g, this.b, this.a);
    return ret;
  };
  _proto.cloneTo = function cloneTo(out) {
    out.r = this.r;
    out.g = this.g;
    out.b = this.b;
    out.a = this.a;
    return out;
  };
  _proto.toLinear = function toLinear(out) {
    out.r = Color2.gammaToLinearSpace(this.r);
    out.g = Color2.gammaToLinearSpace(this.g);
    out.b = Color2.gammaToLinearSpace(this.b);
    return out;
  };
  _proto.toGamma = function toGamma(out) {
    out.r = Color2.linearToGammaSpace(this.r);
    out.g = Color2.linearToGammaSpace(this.g);
    out.b = Color2.linearToGammaSpace(this.b);
    return out;
  };
  return Color2;
}();
var Rect = function() {
  function Rect2(x, y, width, height) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    this.x = void 0;
    this.y = void 0;
    this.width = void 0;
    this.height = void 0;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  var _proto = Rect2.prototype;
  _proto.setValue = function setValue(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    return this;
  };
  _proto.clone = function clone2() {
    return new Rect2(this.x, this.y, this.width, this.height);
  };
  _proto.cloneTo = function cloneTo(out) {
    out.x = this.x;
    out.y = this.y;
    out.width = this.width;
    out.height = this.height;
    return out;
  };
  return Rect2;
}();
var SphericalHarmonics3 = function() {
  function SphericalHarmonics32() {
    this.coefficients = new Float32Array(27);
  }
  var _proto = SphericalHarmonics32.prototype;
  _proto.addLight = function addLight(direction, color, deltaSolidAngle) {
    color.scale(deltaSolidAngle);
    var coe = this.coefficients;
    var x = direction.x, y = direction.y, z = direction.z;
    var r = color.r, g = color.g, b = color.b;
    var bv0 = 0.282095;
    var bv1 = -0.488603 * y;
    var bv2 = 0.488603 * z;
    var bv3 = -0.488603 * x;
    var bv4 = 1.092548 * (x * y);
    var bv5 = -1.092548 * (y * z);
    var bv6 = 0.315392 * (3 * z * z - 1);
    var bv7 = -1.092548 * (x * z);
    var bv8 = 0.546274 * (x * x - y * y);
    coe[0] += r * bv0, coe[1] += g * bv0, coe[2] += b * bv0;
    coe[3] += r * bv1, coe[4] += g * bv1, coe[5] += b * bv1;
    coe[6] += r * bv2, coe[7] += g * bv2, coe[8] += b * bv2;
    coe[9] += r * bv3, coe[10] += g * bv3, coe[11] += b * bv3;
    coe[12] += r * bv4, coe[13] += g * bv4, coe[14] += b * bv4;
    coe[15] += r * bv5, coe[16] += g * bv5, coe[17] += b * bv5;
    coe[18] += r * bv6, coe[19] += g * bv6, coe[20] += b * bv6;
    coe[21] += r * bv7, coe[22] += g * bv7, coe[23] += b * bv7;
    coe[24] += r * bv8, coe[25] += g * bv8, coe[26] += b * bv8;
  };
  _proto.evaluate = function evaluate(direction, out) {
    var coe = this.coefficients;
    var x = direction.x, y = direction.y, z = direction.z;
    var bv0 = 0.886227;
    var bv1 = -1.023327 * y;
    var bv2 = 1.023327 * z;
    var bv3 = -1.023327 * x;
    var bv4 = 0.858086 * y * x;
    var bv5 = -0.858086 * y * z;
    var bv6 = 0.247708 * (3 * z * z - 1);
    var bv7 = -0.858086 * z * x;
    var bv8 = 0.429042 * (x * x - y * y);
    var r = coe[0] * bv0;
    var g = coe[1] * bv0;
    var b = coe[2] * bv0;
    r += coe[3] * bv1 + coe[6] * bv2 + coe[9] * bv3;
    g += coe[4] * bv1 + coe[7] * bv2 + coe[10] * bv3;
    b += coe[5] * bv1 + coe[8] * bv2 + coe[11] * bv3;
    r += coe[12] * bv4 + coe[15] * bv5 + coe[18] * bv6 + coe[21] * bv7 + coe[24] * bv8;
    g += coe[13] * bv4 + coe[16] * bv5 + coe[19] * bv6 + coe[22] * bv7 + coe[25] * bv8;
    b += coe[14] * bv4 + coe[17] * bv5 + coe[20] * bv6 + coe[23] * bv7 + coe[26] * bv8;
    out.setValue(r, g, b, 1);
    return out;
  };
  _proto.scale = function scale(s) {
    var src = this.coefficients;
    src[0] *= s, src[1] *= s, src[2] *= s;
    src[3] *= s, src[4] *= s, src[5] *= s;
    src[6] *= s, src[7] *= s, src[8] *= s;
    src[9] *= s, src[10] *= s, src[11] *= s;
    src[12] *= s, src[13] *= s, src[14] *= s;
    src[15] *= s, src[16] *= s, src[17] *= s;
    src[18] *= s, src[19] *= s, src[20] *= s;
    src[21] *= s, src[22] *= s, src[23] *= s;
    src[24] *= s, src[25] *= s, src[26] *= s;
  };
  _proto.setValueByArray = function setValueByArray(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var s = this.coefficients;
    s[0] = array[offset], s[1] = array[1 + offset], s[2] = array[2 + offset];
    s[3] = array[3 + offset], s[4] = array[4 + offset], s[5] = array[5 + offset];
    s[6] = array[6 + offset], s[7] = array[7 + offset], s[8] = array[8 + offset];
    s[9] = array[9 + offset], s[10] = array[10 + offset], s[11] = array[11 + offset];
    s[12] = array[12 + offset], s[13] = array[13 + offset], s[14] = array[14 + offset];
    s[15] = array[15 + offset], s[16] = array[16 + offset], s[17] = array[17 + offset];
    s[18] = array[18 + offset], s[19] = array[19 + offset], s[20] = array[20 + offset];
    s[21] = array[21 + offset], s[22] = array[22 + offset], s[23] = array[23 + offset];
    s[24] = array[24 + offset], s[25] = array[25 + offset], s[26] = array[26 + offset];
  };
  _proto.toArray = function toArray(out, outOffset) {
    if (outOffset === void 0) {
      outOffset = 0;
    }
    var s = this.coefficients;
    out[0 + outOffset] = s[0], out[1 + outOffset] = s[1], out[2 + outOffset] = s[2];
    out[3 + outOffset] = s[3], out[4 + outOffset] = s[4], out[5 + outOffset] = s[5];
    out[6 + outOffset] = s[6], out[7 + outOffset] = s[7], out[8 + outOffset] = s[8];
    out[9 + outOffset] = s[9], out[10 + outOffset] = s[10], out[11 + outOffset] = s[11];
    out[12 + outOffset] = s[12], out[13 + outOffset] = s[13], out[14 + outOffset] = s[14];
    out[15 + outOffset] = s[15], out[16 + outOffset] = s[16], out[17 + outOffset] = s[17];
    out[18 + outOffset] = s[18], out[19 + outOffset] = s[19], out[20 + outOffset] = s[20];
    out[21 + outOffset] = s[21], out[22 + outOffset] = s[22], out[23 + outOffset] = s[23];
    out[24 + outOffset] = s[24], out[25 + outOffset] = s[25], out[26 + outOffset] = s[26];
  };
  _proto.clone = function clone2() {
    var v = new SphericalHarmonics32();
    this.cloneTo(v);
    return v;
  };
  _proto.cloneTo = function cloneTo(out) {
    this.toArray(out.coefficients);
  };
  return SphericalHarmonics32;
}();

// node_modules/@oasis-engine/core/dist/module.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf4(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct3(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _initializerDefineProperty(target, property, descriptor, context) {
  if (!descriptor)
    return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}
function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function(key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;
  if ("value" in desc || desc.initializer) {
    desc.writable = true;
  }
  desc = decorators.slice().reverse().reduce(function(desc2, decorator) {
    return decorator(target, property, desc2) || desc2;
  }, desc);
  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = void 0;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }
  return desc;
}
var AssetPromiseStatus;
(function(AssetPromiseStatus2) {
  AssetPromiseStatus2[AssetPromiseStatus2["Success"] = 0] = "Success";
  AssetPromiseStatus2[AssetPromiseStatus2["Pending"] = 1] = "Pending";
  AssetPromiseStatus2[AssetPromiseStatus2["Failed"] = 2] = "Failed";
})(AssetPromiseStatus || (AssetPromiseStatus = {}));
var AssetPromise = function(_Promise) {
  _inheritsLoose(AssetPromise2, _Promise);
  AssetPromise2.all = function all(promises) {
    return new AssetPromise2(function(resolve, reject, setProgress) {
      if (!Array.isArray(promises)) {
        return resolve([promises]);
      }
      var completed = 0;
      var total = promises.length;
      var results = new Array(total);
      promises.forEach(function(value, index) {
        Promise.resolve(value).then(function(result) {
          results[index] = result;
          completed += 1;
          setProgress(completed / total);
          if (completed == total) {
            resolve(results);
          }
        }).catch(function(err) {
          return reject(err);
        });
      });
    });
  };
  var _proto = AssetPromise2.prototype;
  _proto.onProgress = function onProgress(callback) {
    this._listeners.add(callback);
    return this;
  };
  _proto.cancel = function cancel() {
    if (this._status !== AssetPromiseStatus.Pending) {
      return this;
    }
    this._reject("Promise Canceled");
    return this;
  };
  function AssetPromise2(executor) {
    var _this;
    var newReject;
    var setProgress = function setProgress2(progress) {
      if (progress <= _this._progress) {
        return;
      }
      _this._progress = progress;
      for (var _iterator = _createForOfIteratorHelperLoose(_this._listeners), _step; !(_step = _iterator()).done; ) {
        var listener = _step.value;
        listener(progress);
      }
    };
    _this = _Promise.call(this, function(resolve, reject) {
      newReject = function newReject2(reason) {
        Promise.resolve().then(function() {
          _this._status = AssetPromiseStatus.Failed;
          reject(reason);
        });
      };
      executor(function(value) {
        Promise.resolve().then(function() {
          setProgress(1);
          _this._status = AssetPromiseStatus.Success;
          resolve(value);
        });
      }, newReject, function(progress) {
        Promise.resolve().then(function() {
          setProgress(progress);
        });
      });
    }) || this;
    _this._status = void 0;
    _this._progress = void 0;
    _this._reject = void 0;
    _this._listeners = void 0;
    _this._reject = newReject;
    _this._listeners = new Set();
    _this._progress = 0;
    _this._status = AssetPromiseStatus.Pending;
    return _this;
  }
  _createClass(AssetPromise2, [{
    key: "status",
    get: function get4() {
      return this._status;
    }
  }, {
    key: "progress",
    get: function get4() {
      return this._progress;
    }
  }]);
  return AssetPromise2;
}(_wrapNativeSuper(Promise));
var Util = {
  isArray: "isArray" in Array ? Array.isArray : function(value) {
    return toString.call(value) === "[object Array]";
  },
  isArrayLike: function isArrayLike(x) {
    return !!x && typeof x.length === "number" && typeof x !== "function";
  },
  clone: function clone(obj) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    var rst;
    if (Util.isArrayLike(obj)) {
      rst = obj.slice();
      for (var i = 0, l = obj.length; i < l; i++) {
        rst[i] = Util.clone(obj[i]);
      }
    } else {
      rst = {};
      for (var k in obj) {
        if (obj.hasOwnProperty(k)) {
          rst[k] = Util.clone(obj[k]);
        }
      }
    }
    return rst;
  },
  downloadBlob: function downloadBlob(blob, fileName) {
    if (fileName === void 0) {
      fileName = "";
    }
    if (navigator && navigator.msSaveBlob) {
      navigator.msSaveBlob(blob, fileName);
      return;
    }
    var url = window.URL.createObjectURL(blob);
    var a = document.createElement("a");
    document.body.appendChild(a);
    a.style.display = "none";
    a.href = url;
    a.download = fileName;
    a.addEventListener("click", function() {
      if (a.parentElement) {
        a.parentElement.removeChild(a);
      }
    });
    a.click();
    window.URL.revokeObjectURL(url);
  }
};
function removeFromArray(array, item) {
  var index = array.indexOf(item);
  if (index < 0) {
    return false;
  }
  var last = array.length - 1;
  if (index !== last) {
    var end = array[last];
    array[index] = end;
  }
  array.length--;
  return true;
}
function ObjectValues(obj) {
  return Object.keys(obj).map(function(key) {
    return obj[key];
  });
}
var ResourceManager = function() {
  ResourceManager2._addLoader = function _addLoader(type, loader, extnames) {
    this._loaders[type] = loader;
    for (var i = 0, len = extnames.length; i < len; i++) {
      this._extTypeMapping[extnames[i]] = type;
    }
  };
  ResourceManager2._getTypeByUrl = function _getTypeByUrl(url) {
    var path = url.split("?")[0];
    return this._extTypeMapping[path.substring(path.lastIndexOf(".") + 1)];
  };
  function ResourceManager2(engine) {
    this.engine = engine;
    this.retryCount = 1;
    this.retryInterval = 0;
    this.timeout = 2e4;
    this._assetPool = Object.create(null);
    this._assetUrlPool = Object.create(null);
    this._refObjectPool = Object.create(null);
    this._loadingPromises = {};
  }
  var _proto = ResourceManager2.prototype;
  _proto.load = function load(assetInfo) {
    var _this = this;
    if (!Array.isArray(assetInfo)) {
      return this._loadSingleItem(assetInfo);
    }
    var promises = assetInfo.map(function(item) {
      return _this._loadSingleItem(item);
    });
    return AssetPromise.all(promises);
  };
  _proto.cancelNotLoaded = function cancelNotLoaded(url) {
    var _this2 = this;
    if (!url) {
      ObjectValues(this._loadingPromises).forEach(function(promise) {
        promise.cancel();
      });
    } else if (typeof url === "string") {
      var _this$_loadingPromise;
      (_this$_loadingPromise = this._loadingPromises[url]) === null || _this$_loadingPromise === void 0 ? void 0 : _this$_loadingPromise.cancel();
    } else {
      url.forEach(function(p) {
        var _this2$_loadingPromis;
        (_this2$_loadingPromis = _this2._loadingPromises[p]) === null || _this2$_loadingPromis === void 0 ? void 0 : _this2$_loadingPromis.cancel();
      });
    }
  };
  _proto.gc = function gc() {
    var objects = ObjectValues(this._refObjectPool);
    for (var i = 0, len = objects.length; i < len; i++) {
      if (!objects[i].isGCIgnored) {
        objects[i].destroy();
      }
    }
  };
  _proto.getAssetPath = function getAssetPath(instanceId) {
    return this._assetPool[instanceId];
  };
  _proto._addAsset = function _addAsset(path, asset) {
    this._assetPool[asset.instanceId] = path;
    this._assetUrlPool[path] = asset;
  };
  _proto._deleteAsset = function _deleteAsset(asset) {
    var id = asset.instanceId;
    var path = this._assetPool[id];
    if (path) {
      delete this._assetPool[id];
      delete this._assetUrlPool[path];
    }
  };
  _proto._addRefObject = function _addRefObject(id, asset) {
    this._refObjectPool[id] = asset;
  };
  _proto._deleteRefObject = function _deleteRefObject(id) {
    delete this._refObjectPool[id];
  };
  _proto._assignDefaultOptions = function _assignDefaultOptions(assetInfo) {
    var _assetInfo$type, _assetInfo$retryCount, _assetInfo$timeout, _assetInfo$retryInter, _assetInfo$url;
    assetInfo.type = (_assetInfo$type = assetInfo.type) != null ? _assetInfo$type : ResourceManager2._getTypeByUrl(assetInfo.url);
    if (assetInfo.type === void 0) {
      throw "asset type should be specified: " + assetInfo.url;
    }
    assetInfo.retryCount = (_assetInfo$retryCount = assetInfo.retryCount) != null ? _assetInfo$retryCount : this.retryCount;
    assetInfo.timeout = (_assetInfo$timeout = assetInfo.timeout) != null ? _assetInfo$timeout : this.timeout;
    assetInfo.retryInterval = (_assetInfo$retryInter = assetInfo.retryInterval) != null ? _assetInfo$retryInter : this.retryInterval;
    assetInfo.url = (_assetInfo$url = assetInfo.url) != null ? _assetInfo$url : assetInfo.urls.join(",");
    return assetInfo;
  };
  _proto._loadSingleItem = function _loadSingleItem(item) {
    var _this3 = this;
    var info2 = this._assignDefaultOptions(typeof item === "string" ? {
      url: item
    } : item);
    var url = info2.url;
    if (this._assetUrlPool[url]) {
      return new AssetPromise(function(resolve) {
        resolve(_this3._assetUrlPool[url]);
      });
    }
    if (this._loadingPromises[url]) {
      return this._loadingPromises[info2.url];
    }
    var loader = ResourceManager2._loaders[info2.type];
    var promise = loader.load(info2, this);
    this._loadingPromises[url] = promise;
    promise.then(function(res) {
      if (loader.useCache)
        _this3._addAsset(url, res);
      delete _this3._loadingPromises[url];
    }).catch(function() {
    });
    return promise;
  };
  return ResourceManager2;
}();
ResourceManager._loaders = {};
ResourceManager._extTypeMapping = {};
function resourceLoader(assetType, extnames, useCache) {
  if (useCache === void 0) {
    useCache = true;
  }
  return function(Target) {
    var loader = new Target(useCache);
    ResourceManager._addLoader(assetType, loader, extnames);
  };
}
var Event = function() {
  function Event2(type, target, data, bubbles) {
    if (target === void 0) {
      target = null;
    }
    if (data === void 0) {
      data = {};
    }
    if (bubbles === void 0) {
      bubbles = true;
    }
    this.data = void 0;
    this._timeStamp = void 0;
    this._target = void 0;
    this._currentTarget = void 0;
    this._bubbles = void 0;
    this._propagationStopped = void 0;
    this._type = void 0;
    this._timeStamp = new Date().getTime();
    this._target = target;
    this.data = data;
    this._currentTarget = null;
    this._bubbles = bubbles;
    this._propagationStopped = false;
    this._type = type;
  }
  var _proto = Event2.prototype;
  _proto.stopPropagation = function stopPropagation() {
    this._propagationStopped = true;
  };
  _createClass(Event2, [{
    key: "propagationStopped",
    get: function get4() {
      return this._propagationStopped;
    }
  }, {
    key: "target",
    get: function get4() {
      return this._target;
    },
    set: function set4(t) {
      this._target = t;
    }
  }, {
    key: "timeStamp",
    get: function get4() {
      return this._timeStamp;
    }
  }, {
    key: "currentTarget",
    get: function get4() {
      return this._currentTarget;
    },
    set: function set4(t) {
      this._currentTarget = t;
    }
  }, {
    key: "bubbles",
    get: function get4() {
      return this._bubbles;
    }
  }, {
    key: "type",
    get: function get4() {
      return this._type;
    }
  }]);
  return Event2;
}();
var CloneMode;
(function(CloneMode2) {
  CloneMode2[CloneMode2["Ignore"] = 0] = "Ignore";
  CloneMode2[CloneMode2["Assignment"] = 1] = "Assignment";
  CloneMode2[CloneMode2["Shallow"] = 2] = "Shallow";
  CloneMode2[CloneMode2["Deep"] = 3] = "Deep";
})(CloneMode || (CloneMode = {}));
function ignoreClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Ignore);
}
function assignmentClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Assignment);
}
function shallowClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Shallow);
}
function deepClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Deep);
}
var CloneManager = function() {
  function CloneManager2() {
  }
  CloneManager2.registerCloneMode = function registerCloneMode(target, propertyKey, mode) {
    var targetMap = CloneManager2._subCloneModeMap.get(target.constructor);
    if (!targetMap) {
      targetMap = Object.create(null);
      CloneManager2._subCloneModeMap.set(target.constructor, targetMap);
    }
    targetMap[propertyKey] = mode;
  };
  CloneManager2.getCloneMode = function getCloneMode(type) {
    var cloneModes = CloneManager2._cloneModeMap.get(type);
    if (!cloneModes) {
      cloneModes = Object.create(null);
      CloneManager2._cloneModeMap.set(type, cloneModes);
      var objectType = CloneManager2._objectType;
      var cloneModeMap = CloneManager2._subCloneModeMap;
      while (type !== objectType) {
        var subCloneModes = cloneModeMap.get(type);
        if (subCloneModes) {
          _extends(cloneModes, subCloneModes);
        }
        type = Object.getPrototypeOf(type);
      }
    }
    return cloneModes;
  };
  CloneManager2.deepCloneObject = function deepCloneObject(source, target) {
    var type = source.constructor;
    switch (type) {
      case Uint8Array:
      case Uint16Array:
      case Uint32Array:
      case Int8Array:
      case Int16Array:
      case Int32Array:
      case Float32Array:
      case Float64Array:
        target.set(source);
        break;
      case Array:
        for (var i = 0, n = source.length; i < n; i++) {
          CloneManager2._deepCloneObjectItem(source, target, i);
        }
        break;
      default:
        var customSource = source;
        if (customSource.clone && customSource.cloneTo) {
          customSource.cloneTo(target);
        } else {
          var keys = Object.keys(source);
          for (var _i = 0, _n = keys.length; _i < _n; _i++) {
            CloneManager2._deepCloneObjectItem(source, target, keys[_i]);
          }
        }
    }
  };
  CloneManager2._deepCloneObjectItem = function _deepCloneObjectItem(source, target, k) {
    var sourceItem = source[k];
    if (sourceItem instanceof Object) {
      var itemType = sourceItem.constructor;
      switch (itemType) {
        case Uint8Array:
        case Uint16Array:
        case Uint32Array:
        case Int8Array:
        case Int16Array:
        case Int32Array:
        case Float32Array:
        case Float64Array:
          var sourceTypeArrayItem = sourceItem;
          var targetTypeArrayItem = target[k];
          if (targetTypeArrayItem == null) {
            target[k] = sourceTypeArrayItem.slice();
          } else {
            targetTypeArrayItem.set(sourceTypeArrayItem);
          }
          break;
        case Array:
          var sourceArrayItem = sourceItem;
          var targetArrayItem = target[k];
          if (targetArrayItem == null) {
            target[k] = new Array(sourceArrayItem.length);
          } else {
            targetArrayItem.length = sourceArrayItem.length;
          }
          CloneManager2.deepCloneObject(sourceArrayItem, targetArrayItem);
          break;
        default:
          if (sourceItem.clone && sourceItem.cloneTo) {
            var sourceCustomItem = sourceItem;
            var targetCustomItem = target[k];
            if (targetCustomItem) {
              sourceCustomItem.cloneTo(targetCustomItem);
            } else {
              target[k] = sourceCustomItem.clone();
            }
          } else {
            var targetItem = target[k];
            targetItem == null && (target[k] = targetItem = new sourceItem.constructor());
            CloneManager2.deepCloneObject(sourceItem, targetItem);
            break;
          }
      }
    } else {
      target[k] = sourceItem;
    }
  };
  return CloneManager2;
}();
CloneManager._subCloneModeMap = new Map();
CloneManager._cloneModeMap = new Map();
CloneManager._objectType = Object.getPrototypeOf(Object);
var _class$b;
var _descriptor$b;
var _descriptor2$a;
var _class2$8;
var _temp$8;
var EngineObject = (_class$b = (_temp$8 = _class2$8 = function() {
  function EngineObject2(engine) {
    _initializerDefineProperty(this, "instanceId", _descriptor$b, this);
    _initializerDefineProperty(this, "_engine", _descriptor2$a, this);
    this._engine = engine;
  }
  _createClass(EngineObject2, [{
    key: "engine",
    get: function get4() {
      return this._engine;
    }
  }]);
  return EngineObject2;
}(), _class2$8._instanceIdCounter = 0, _temp$8), _descriptor$b = _applyDecoratedDescriptor(_class$b.prototype, "instanceId", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return ++EngineObject._instanceIdCounter;
  }
}), _descriptor2$a = _applyDecoratedDescriptor(_class$b.prototype, "_engine", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _class$b);
var _class$a;
var _descriptor$a;
var EventDispatcher = (_class$a = function(_EngineObject) {
  _inheritsLoose(EventDispatcher2, _EngineObject);
  function EventDispatcher2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _EngineObject.call.apply(_EngineObject, [this].concat(args)) || this;
    _initializerDefineProperty(_this, "_evts", _descriptor$a, _assertThisInitialized(_this));
    _this._evtCount = 0;
    return _this;
  }
  var _proto = EventDispatcher2.prototype;
  _proto.hasEvent = function hasEvent(event) {
    return this._evts[event] != null;
  };
  _proto.eventNames = function eventNames() {
    if (this._evtCount === 0)
      return [];
    return Object.keys(this._evts);
  };
  _proto.listenerCount = function listenerCount(event) {
    var listeners = this._evts[event];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  _proto.dispatch = function dispatch(event, data) {
    if (!this._evts[event]) {
      return false;
    }
    var listeners = this._evts[event];
    if (listeners.fn) {
      if (listeners.once)
        this.removeEventListener(event, listeners.fn);
      listeners.fn(data);
    } else {
      var l = listeners.length;
      for (var i = 0; i < l; i++) {
        if (listeners[i].once)
          this.removeEventListener(event, listeners[i].fn);
        listeners[i].fn(data);
      }
    }
    return true;
  };
  _proto.on = function on(event, fn) {
    return this.addEventListener(event, fn);
  };
  _proto.once = function once(event, fn) {
    return this.addEventListener(event, fn, true);
  };
  _proto.addEventListener = function addEventListener(event, fn, once) {
    var listener = {
      fn,
      once
    };
    var events = this._evts;
    if (!events[event]) {
      events[event] = listener;
      this._evtCount++;
    } else if (!events[event].fn) {
      events[event].push(listener);
    } else {
      events[event] = [events[event], listener];
    }
    return this;
  };
  _proto.off = function off(event, fn) {
    if (!this._evts[event])
      return this;
    if (!fn) {
      this._clearEvent(event);
      return this;
    }
    var listeners = this._evts[event];
    if (listeners.fn && listeners.fn === fn) {
      this._clearEvent(event);
    } else {
      var index = listeners.indexOf(fn);
      if (index > -1) {
        var temp = listeners[listeners.length - 1];
        listeners[index] = temp;
        listeners.length--;
        if (listeners.length === 1) {
          this._evts[event] = listeners[0];
        }
      }
    }
    return this;
  };
  _proto.removeEventListener = function removeEventListener(event, fn) {
    return this.off(event, fn);
  };
  _proto.removeAllEventListeners = function removeAllEventListeners(event) {
    if (event) {
      if (this._evts[event])
        this._clearEvent(event);
    } else {
      this._evts = Object.create(null);
      this._evtCount = 0;
    }
  };
  _proto.trigger = function trigger(e) {
    this.dispatch(e.type, e.data);
  };
  _proto._clearEvent = function _clearEvent(event) {
    if (--this._evtCount === 0) {
      this._evts = Object.create(null);
    } else {
      delete this._evts[event];
    }
  };
  return EventDispatcher2;
}(EngineObject), _descriptor$a = _applyDecoratedDescriptor(_class$a.prototype, "_evts", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer2() {
    return Object.create(null);
  }
}), _class$a);
var noop = function noop2(message) {
};
var debug = console.log.bind(console);
var info = console.info.bind(console);
var warn = console.warn.bind(console);
var error = console.error.bind(console);
var Logger = {
  debug: noop,
  info: noop,
  warn: noop,
  error: noop,
  isEnabled: false,
  enable: function enable() {
    this.debug = debug;
    this.info = info;
    this.warn = warn;
    this.error = error;
    this.isEnabled = true;
  },
  disable: function disable() {
    this.debug = noop;
    this.info = noop;
    this.warn = noop;
    this.error = noop;
    this.isEnabled = false;
  }
};
var Time = function() {
  function Time2() {
    this._clock = void 0;
    this._timeScale = void 0;
    this._deltaTime = void 0;
    this._startTime = void 0;
    this._lastTickTime = void 0;
    this._clock = performance ? performance : Date;
    this._timeScale = 1;
    this._deltaTime = 1e-4;
    var now = this._clock.now();
    this._startTime = now;
    this._lastTickTime = now;
  }
  var _proto = Time2.prototype;
  _proto.reset = function reset() {
    this._lastTickTime = this._clock.now();
  };
  _proto.tick = function tick() {
    var now = this.nowTime;
    this._deltaTime = (now - this._lastTickTime) * this._timeScale;
    this._lastTickTime = now;
  };
  _createClass(Time2, [{
    key: "nowTime",
    get: function get4() {
      return this._clock.now();
    }
  }, {
    key: "deltaTime",
    get: function get4() {
      return this._deltaTime;
    }
  }, {
    key: "timeScale",
    get: function get4() {
      return this._timeScale;
    },
    set: function set4(s) {
      this._timeScale = s;
    }
  }, {
    key: "unscaledDeltaTime",
    get: function get4() {
      return this._deltaTime / this._timeScale;
    }
  }, {
    key: "timeSinceStartup",
    get: function get4() {
      return this.nowTime - this._startTime;
    }
  }]);
  return Time2;
}();
var DataType;
(function(DataType2) {
  DataType2[DataType2["FLOAT"] = 5126] = "FLOAT";
  DataType2[DataType2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  DataType2[DataType2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  DataType2[DataType2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  DataType2[DataType2["INT"] = 5124] = "INT";
  DataType2[DataType2["INT_VEC2"] = 35667] = "INT_VEC2";
  DataType2[DataType2["INT_VEC3"] = 35668] = "INT_VEC3";
  DataType2[DataType2["INT_VEC4"] = 35669] = "INT_VEC4";
  DataType2[DataType2["BOOL"] = 35670] = "BOOL";
  DataType2[DataType2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  DataType2[DataType2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  DataType2[DataType2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  DataType2[DataType2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  DataType2[DataType2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  DataType2[DataType2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  DataType2[DataType2["FLOAT_ARRAY"] = 35677] = "FLOAT_ARRAY";
  DataType2[DataType2["FLOAT_VEC2_ARRAY"] = 1e5] = "FLOAT_VEC2_ARRAY";
  DataType2[DataType2["FLOAT_VEC3_ARRAY"] = 100001] = "FLOAT_VEC3_ARRAY";
  DataType2[DataType2["FLOAT_VEC4_ARRAY"] = 100002] = "FLOAT_VEC4_ARRAY";
  DataType2[DataType2["INT_ARRAY"] = 100003] = "INT_ARRAY";
  DataType2[DataType2["INT_VEC2_ARRAY"] = 100004] = "INT_VEC2_ARRAY";
  DataType2[DataType2["INT_VEC3_ARRAY"] = 100005] = "INT_VEC3_ARRAY";
  DataType2[DataType2["INT_VEC4_ARRAY"] = 100006] = "INT_VEC4_ARRAY";
  DataType2[DataType2["FLOAT_MAT2_ARRAY"] = 100007] = "FLOAT_MAT2_ARRAY";
  DataType2[DataType2["FLOAT_MAT3_ARRAY"] = 100008] = "FLOAT_MAT3_ARRAY";
  DataType2[DataType2["FLOAT_MAT4_ARRAY"] = 100009] = "FLOAT_MAT4_ARRAY";
  DataType2[DataType2["SAMPLER_2D_ARRAY"] = 100010] = "SAMPLER_2D_ARRAY";
  DataType2[DataType2["SAMPLER_CUBE_ARRAY"] = 100011] = "SAMPLER_CUBE_ARRAY";
  DataType2[DataType2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
  DataType2[DataType2["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
  DataType2[DataType2["BYTE"] = 5120] = "BYTE";
  DataType2[DataType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  DataType2[DataType2["SHORT"] = 5122] = "SHORT";
  DataType2[DataType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  DataType2[DataType2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
})(DataType || (DataType = {}));
var GLCapabilityType;
(function(GLCapabilityType2) {
  GLCapabilityType2["shaderVertexID"] = "shaderVertexID";
  GLCapabilityType2["standardDerivatives"] = "OES_standard_derivatives";
  GLCapabilityType2["shaderTextureLod"] = "EXT_shader_texture_lod";
  GLCapabilityType2["elementIndexUint"] = "OES_element_index_uint";
  GLCapabilityType2["depthTexture"] = "WEBGL_depth_texture";
  GLCapabilityType2["drawBuffers"] = "WEBGL_draw_buffers";
  GLCapabilityType2["vertexArrayObject"] = "OES_vertex_array_object";
  GLCapabilityType2["instancedArrays"] = "ANGLE_instanced_arrays";
  GLCapabilityType2["multipleSample"] = "multipleSampleOnlySupportedInWebGL2";
  GLCapabilityType2["textureFloat"] = "OES_texture_float";
  GLCapabilityType2["textureFloatLinear"] = "OES_texture_float_linear";
  GLCapabilityType2["textureHalfFloat"] = "OES_texture_half_float";
  GLCapabilityType2["textureHalfFloatLinear"] = "OES_texture_half_float_linear";
  GLCapabilityType2["WEBGL_colorBufferFloat"] = "WEBGL_color_buffer_float";
  GLCapabilityType2["colorBufferFloat"] = "EXT_color_buffer_float";
  GLCapabilityType2["colorBufferHalfFloat"] = "EXT_color_buffer_half_float";
  GLCapabilityType2["textureFilterAnisotropic"] = "EXT_texture_filter_anisotropic";
  GLCapabilityType2["blendMinMax"] = "EXT_blend_minmax";
  GLCapabilityType2["astc"] = "WEBGL_compressed_texture_astc";
  GLCapabilityType2["astc_webkit"] = "WEBKIT_WEBGL_compressed_texture_astc";
  GLCapabilityType2["etc"] = "WEBGL_compressed_texture_etc";
  GLCapabilityType2["etc_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc";
  GLCapabilityType2["etc1"] = "WEBGL_compressed_texture_etc1";
  GLCapabilityType2["etc1_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc1";
  GLCapabilityType2["pvrtc"] = "WEBGL_compressed_texture_pvrtc";
  GLCapabilityType2["pvrtc_webkit"] = "WEBKIT_WEBGL_compressed_texture_pvrtc";
  GLCapabilityType2["s3tc"] = "WEBGL_compressed_texture_s3tc";
  GLCapabilityType2["s3tc_webkit"] = "WEBKIT_WEBGL_compressed_texture_s3tc";
})(GLCapabilityType || (GLCapabilityType = {}));
var DisorderedArray = function() {
  function DisorderedArray2(count) {
    if (count === void 0) {
      count = 0;
    }
    this._elements = void 0;
    this.length = 0;
    this._elements = new Array(count);
  }
  var _proto = DisorderedArray2.prototype;
  _proto.add = function add(element) {
    if (this.length === this._elements.length)
      this._elements.push(element);
    else
      this._elements[this.length] = element;
    this.length++;
  };
  _proto.delete = function _delete(element) {
    var index = this._elements.indexOf(element);
    this.deleteByIndex(index);
  };
  _proto.get = function get4(index) {
    if (index >= this.length) {
      throw "Index is out of range.";
    }
    return this._elements[index];
  };
  _proto.deleteByIndex = function deleteByIndex(index) {
    var elements = this._elements;
    var end = null;
    var lastIndex = this.length - 1;
    if (index !== lastIndex) {
      end = elements[lastIndex];
      elements[index] = end;
    }
    this.length--;
    return end;
  };
  _proto.garbageCollection = function garbageCollection() {
    this._elements.length = this.length;
  };
  return DisorderedArray2;
}();
var ShaderMacroCollection = function() {
  function ShaderMacroCollection2() {
    this._mask = [];
    this._length = 0;
  }
  ShaderMacroCollection2.unionCollection = function unionCollection(left, right, out) {
    var outMask = out._mask;
    var minSize, maxSize;
    var minMask, maxMask;
    if (left._length < right._length) {
      minSize = left._length;
      maxSize = right._length;
      minMask = left._mask;
      maxMask = right._mask;
    } else {
      minSize = right._length;
      maxSize = left._length;
      minMask = right._mask;
      maxMask = left._mask;
    }
    var i = 0;
    outMask.length < maxSize && (outMask.length = maxSize);
    for (; i < minSize; i++) {
      outMask[i] = minMask[i] | maxMask[i];
    }
    for (; i < maxSize; i++) {
      outMask[i] = maxMask[i];
    }
    out._length = maxSize;
  };
  var _proto = ShaderMacroCollection2.prototype;
  _proto.enable = function enable2(macro) {
    var index = macro._index;
    var size = index + 1;
    var mask = this._mask;
    var maskStart = this._length;
    if (maskStart < size) {
      mask.length < size && (mask.length = size);
      for (; maskStart < index; maskStart++) {
        mask[maskStart] = 0;
      }
      mask[index] = macro._value;
      this._length = size;
    } else {
      mask[index] |= macro._value;
    }
  };
  _proto.disable = function disable2(macro) {
    var index = macro._index;
    var mask = this._mask;
    var endIndex = this._length - 1;
    if (index > endIndex) {
      return;
    }
    var newValue = mask[index] & ~macro._value;
    if (index == endIndex && newValue === 0) {
      this._length--;
    } else {
      mask[index] = newValue;
    }
  };
  _proto.unionCollection = function unionCollection(macroCollection) {
    var addMask = macroCollection._mask;
    var addSize = macroCollection._length;
    var mask = this._mask;
    var maskSize = this._length;
    if (maskSize < addSize) {
      mask.length < addSize && (mask.length = addSize);
      var i = 0;
      for (; i < maskSize; i++) {
        mask[i] |= addMask[i];
      }
      for (; i < addSize; i++) {
        mask[i] = addMask[i];
      }
      this._length = addSize;
    } else {
      for (var _i = 0; _i < addSize; _i++) {
        mask[_i] |= addMask[_i];
      }
    }
  };
  _proto.complementaryCollection = function complementaryCollection(macroCollection) {
    var removeMask = macroCollection._mask;
    var mask = this._mask;
    var endIndex = this._length - 1;
    var i = Math.min(macroCollection._length - 1, endIndex);
    for (; i >= 0; i--) {
      var newValue = mask[i] & ~removeMask[i];
      if (i == endIndex && newValue === 0) {
        endIndex--;
        this._length--;
      } else {
        mask[i] = newValue;
      }
    }
  };
  _proto.intersectionCollection = function intersectionCollection(macroCollection) {
    var unionMask = macroCollection._mask;
    var mask = this._mask;
    for (var i = this._length - 1; i >= 0; i--) {
      var value = mask[i] & unionMask[i];
      if (value == 0 && i == this._length - 1) {
        this._length--;
      } else {
        mask[i] = value;
      }
    }
  };
  _proto.isEnable = function isEnable(macro) {
    var index = macro._index;
    if (index >= this._length) {
      return false;
    }
    return (this._mask[index] & macro._value) !== 0;
  };
  _proto.clear = function clear() {
    this._length = 0;
  };
  return ShaderMacroCollection2;
}();
var ComponentsManager = function() {
  function ComponentsManager2() {
    this._onStartScripts = new DisorderedArray();
    this._onUpdateScripts = new DisorderedArray();
    this._onLateUpdateScripts = new DisorderedArray();
    this._destroyComponents = [];
    this._onUpdateAnimations = new DisorderedArray();
    this._renderers = new DisorderedArray();
    this._onUpdateRenderers = new DisorderedArray();
    this._componentsContainerPool = [];
  }
  var _proto = ComponentsManager2.prototype;
  _proto.addRenderer = function addRenderer(renderer) {
    renderer._rendererIndex = this._renderers.length;
    this._renderers.add(renderer);
  };
  _proto.removeRenderer = function removeRenderer(renderer) {
    var replaced = this._renderers.deleteByIndex(renderer._rendererIndex);
    replaced && (replaced._rendererIndex = renderer._rendererIndex);
    renderer._rendererIndex = -1;
  };
  _proto.addOnStartScript = function addOnStartScript(script2) {
    script2._onStartIndex = this._onStartScripts.length;
    this._onStartScripts.add(script2);
  };
  _proto.removeOnStartScript = function removeOnStartScript(script2) {
    var replaced = this._onStartScripts.deleteByIndex(script2._onStartIndex);
    replaced && (replaced._onStartIndex = script2._onStartIndex);
    script2._onStartIndex = -1;
  };
  _proto.addOnUpdateScript = function addOnUpdateScript(script2) {
    script2._onUpdateIndex = this._onUpdateScripts.length;
    this._onUpdateScripts.add(script2);
  };
  _proto.removeOnUpdateScript = function removeOnUpdateScript(script2) {
    var replaced = this._onUpdateScripts.deleteByIndex(script2._onUpdateIndex);
    replaced && (replaced._onUpdateIndex = script2._onUpdateIndex);
    script2._onUpdateIndex = -1;
  };
  _proto.addOnLateUpdateScript = function addOnLateUpdateScript(script2) {
    script2._onLateUpdateIndex = this._onLateUpdateScripts.length;
    this._onLateUpdateScripts.add(script2);
  };
  _proto.removeOnLateUpdateScript = function removeOnLateUpdateScript(script2) {
    var replaced = this._onLateUpdateScripts.deleteByIndex(script2._onLateUpdateIndex);
    replaced && (replaced._onLateUpdateIndex = script2._onLateUpdateIndex);
    script2._onLateUpdateIndex = -1;
  };
  _proto.addOnUpdateAnimations = function addOnUpdateAnimations(animation) {
    animation._onUpdateIndex = this._onUpdateAnimations.length;
    this._onUpdateAnimations.add(animation);
  };
  _proto.removeOnUpdateAnimations = function removeOnUpdateAnimations(animation) {
    var replaced = this._onUpdateAnimations.deleteByIndex(animation._onUpdateIndex);
    replaced && (replaced._onUpdateIndex = animation._onUpdateIndex);
    animation._onUpdateIndex = -1;
  };
  _proto.addOnUpdateRenderers = function addOnUpdateRenderers(renderer) {
    renderer._onUpdateIndex = this._onUpdateRenderers.length;
    this._onUpdateRenderers.add(renderer);
  };
  _proto.removeOnUpdateRenderers = function removeOnUpdateRenderers(renderer) {
    var replaced = this._onUpdateRenderers.deleteByIndex(renderer._onUpdateIndex);
    replaced && (replaced._onUpdateIndex = renderer._onUpdateIndex);
    renderer._onUpdateIndex = -1;
  };
  _proto.addDestroyComponent = function addDestroyComponent(component) {
    this._destroyComponents.push(component);
  };
  _proto.callScriptOnStart = function callScriptOnStart() {
    var onStartScripts = this._onStartScripts;
    if (onStartScripts.length > 0) {
      var elements = onStartScripts._elements;
      for (var i = 0; i < onStartScripts.length; i++) {
        var script2 = elements[i];
        script2._started = true;
        script2._onStartIndex = -1;
        script2.onStart();
      }
      onStartScripts.length = 0;
    }
  };
  _proto.callScriptOnUpdate = function callScriptOnUpdate(deltaTime) {
    var elements = this._onUpdateScripts._elements;
    for (var i = this._onUpdateScripts.length - 1; i >= 0; --i) {
      var element = elements[i];
      if (element._started) {
        element.onUpdate(deltaTime);
      }
    }
  };
  _proto.callScriptOnLateUpdate = function callScriptOnLateUpdate(deltaTime) {
    var elements = this._onLateUpdateScripts._elements;
    for (var i = this._onLateUpdateScripts.length - 1; i >= 0; --i) {
      var element = elements[i];
      if (element._started) {
        element.onLateUpdate(deltaTime);
      }
    }
  };
  _proto.callAnimationUpdate = function callAnimationUpdate(deltaTime) {
    var elements = this._onUpdateAnimations._elements;
    for (var i = this._onUpdateAnimations.length - 1; i >= 0; --i) {
      elements[i].update(deltaTime);
    }
  };
  _proto.callRendererOnUpdate = function callRendererOnUpdate(deltaTime) {
    var elements = this._onUpdateRenderers._elements;
    for (var i = this._onUpdateRenderers.length - 1; i >= 0; --i) {
      elements[i].update(deltaTime);
    }
  };
  _proto.callRender = function callRender(context) {
    var camera = context._camera;
    var elements = this._renderers._elements;
    for (var i = this._renderers.length - 1; i >= 0; --i) {
      var element = elements[i];
      if (!(camera.cullingMask & element._entity.layer)) {
        continue;
      }
      if (camera.enableFrustumCulling) {
        element.isCulled = !camera._frustum.intersectsBox(element.bounds);
        if (element.isCulled) {
          continue;
        }
      }
      var transform = camera.entity.transform;
      var position = transform.worldPosition;
      var center = element.bounds.getCenter(ComponentsManager2._tempVector0);
      if (camera.isOrthographic) {
        var forward = transform.getWorldForward(ComponentsManager2._tempVector1);
        Vector3.subtract(center, position, center);
        element._distanceForSort = Vector3.dot(center, forward);
      } else {
        element._distanceForSort = Vector3.distanceSquared(center, position);
      }
      element._updateShaderData(context);
      element._render(camera);
      ShaderMacroCollection.unionCollection(camera._globalShaderMacro, element.shaderData._macroCollection, element._globalShaderMacro);
    }
  };
  _proto.callComponentDestroy = function callComponentDestroy() {
    var destroyComponents = this._destroyComponents;
    var length2 = destroyComponents.length;
    if (length2 > 0) {
      for (var i = length2 - 1; i >= 0; --i) {
        destroyComponents[i].onDestroy();
      }
      destroyComponents.length = 0;
    }
  };
  _proto.callCameraOnBeginRender = function callCameraOnBeginRender(camera) {
    var camComps = camera.entity._components;
    for (var i = camComps.length - 1; i >= 0; --i) {
      var camComp = camComps[i];
      camComp.onBeginRender && camComp.onBeginRender(camera);
    }
  };
  _proto.callCameraOnEndRender = function callCameraOnEndRender(camera) {
    var camComps = camera.entity._components;
    for (var i = camComps.length - 1; i >= 0; --i) {
      var camComp = camComps[i];
      camComp.onBeginRender && camComp.onEndRender(camera);
    }
  };
  _proto.getActiveChangedTempList = function getActiveChangedTempList() {
    return this._componentsContainerPool.length ? this._componentsContainerPool.pop() : [];
  };
  _proto.putActiveChangedTempList = function putActiveChangedTempList(componentContainer) {
    componentContainer.length = 0;
    this._componentsContainerPool.push(componentContainer);
  };
  return ComponentsManager2;
}();
ComponentsManager._tempVector0 = new Vector3();
ComponentsManager._tempVector1 = new Vector3();
var ComponentCloner = function() {
  function ComponentCloner2() {
  }
  ComponentCloner2.cloneComponent = function cloneComponent(source, target) {
    var cloneModes = CloneManager.getCloneMode(source.constructor);
    var keys = Object.keys(source);
    for (var i = 0, n = keys.length; i < n; i++) {
      var k = keys[i];
      var cloneMode = cloneModes[k];
      switch (cloneMode) {
        case void 0:
        case CloneMode.Assignment:
          target[k] = source[k];
          break;
        case CloneMode.Shallow:
          var sourcePropS = source[k];
          if (sourcePropS instanceof Object) {
            var tarProp = target[k];
            tarProp == null && (tarProp = target[k] = sourcePropS.constructor());
            _extends(tarProp, sourcePropS);
          } else {
            target[k] = sourcePropS;
          }
          break;
        case CloneMode.Deep:
          var sourcePropD = source[k];
          if (sourcePropD instanceof Object) {
            var _tarProp = target[k];
            _tarProp == null && (_tarProp = target[k] = sourcePropD.constructor());
            CloneManager.deepCloneObject(sourcePropD, _tarProp);
          } else {
            target[k] = sourcePropD;
          }
          break;
      }
    }
    if (source._cloneTo) {
      source._cloneTo(target);
    }
  };
  return ComponentCloner2;
}();
var ComponentsDependencies = function() {
  ComponentsDependencies2.register = function register(currentComponent, dependentComponent) {
    this._addDependency(currentComponent, dependentComponent, this._dependenciesMap);
    this._addDependency(dependentComponent, currentComponent, this._invDependenciesMap);
  };
  ComponentsDependencies2._addCheck = function _addCheck(entity, type) {
    var dependencies2 = ComponentsDependencies2._dependenciesMap.get(type);
    if (dependencies2) {
      for (var i = 0, len = dependencies2.length; i < len; i++) {
        if (!entity.getComponent(dependencies2[i])) {
          throw "you should add " + dependencies2[i] + " before adding " + type;
        }
      }
    }
  };
  ComponentsDependencies2._removeCheck = function _removeCheck(entity, type) {
    var invDependencies = ComponentsDependencies2._invDependenciesMap.get(type);
    if (invDependencies) {
      for (var i = 0, len = invDependencies.length; i < len; i++) {
        if (entity.getComponent(invDependencies[i])) {
          throw "you should remove " + invDependencies[i] + " before adding " + type;
        }
      }
    }
  };
  ComponentsDependencies2._addDependency = function _addDependency(currentComponent, dependentComponent, map) {
    var components = map.get(currentComponent);
    if (!components) {
      components = [];
      map.set(currentComponent, components);
    }
    if (components.indexOf(dependentComponent) === -1) {
      components.push(dependentComponent);
    }
  };
  function ComponentsDependencies2() {
  }
  return ComponentsDependencies2;
}();
ComponentsDependencies._dependenciesMap = new Map();
ComponentsDependencies._invDependenciesMap = new Map();
function dependencies() {
  for (var _len = arguments.length, abilityClass = new Array(_len), _key = 0; _key < _len; _key++) {
    abilityClass[_key] = arguments[_key];
  }
  return function(target) {
    abilityClass.forEach(function(ability) {
      return ComponentsDependencies.register(target, ability);
    });
  };
}
var Layer;
(function(Layer2) {
  Layer2[Layer2["Layer0"] = 1] = "Layer0";
  Layer2[Layer2["Layer1"] = 2] = "Layer1";
  Layer2[Layer2["Layer2"] = 4] = "Layer2";
  Layer2[Layer2["Layer3"] = 8] = "Layer3";
  Layer2[Layer2["Layer4"] = 16] = "Layer4";
  Layer2[Layer2["Layer5"] = 32] = "Layer5";
  Layer2[Layer2["Layer6"] = 64] = "Layer6";
  Layer2[Layer2["Layer7"] = 128] = "Layer7";
  Layer2[Layer2["Layer8"] = 256] = "Layer8";
  Layer2[Layer2["Layer9"] = 512] = "Layer9";
  Layer2[Layer2["Layer10"] = 1024] = "Layer10";
  Layer2[Layer2["Layer11"] = 2048] = "Layer11";
  Layer2[Layer2["Layer12"] = 4096] = "Layer12";
  Layer2[Layer2["Layer13"] = 8192] = "Layer13";
  Layer2[Layer2["Layer14"] = 16384] = "Layer14";
  Layer2[Layer2["Layer15"] = 32768] = "Layer15";
  Layer2[Layer2["Layer16"] = 65536] = "Layer16";
  Layer2[Layer2["Layer17"] = 131072] = "Layer17";
  Layer2[Layer2["Layer18"] = 262144] = "Layer18";
  Layer2[Layer2["Layer19"] = 524288] = "Layer19";
  Layer2[Layer2["Layer20"] = 1048576] = "Layer20";
  Layer2[Layer2["Layer21"] = 2097152] = "Layer21";
  Layer2[Layer2["Layer22"] = 4194304] = "Layer22";
  Layer2[Layer2["Layer23"] = 8388608] = "Layer23";
  Layer2[Layer2["Layer24"] = 16777216] = "Layer24";
  Layer2[Layer2["Layer25"] = 33554432] = "Layer25";
  Layer2[Layer2["Layer26"] = 67108864] = "Layer26";
  Layer2[Layer2["Layer27"] = 134217728] = "Layer27";
  Layer2[Layer2["Layer28"] = 268435456] = "Layer28";
  Layer2[Layer2["Layer29"] = 536870912] = "Layer29";
  Layer2[Layer2["Layer30"] = 1073741824] = "Layer30";
  Layer2[Layer2["Layer31"] = 2147483648] = "Layer31";
  Layer2[Layer2["Everything"] = 4294967295] = "Everything";
  Layer2[Layer2["Nothing"] = 0] = "Nothing";
})(Layer || (Layer = {}));
var _class$9;
var _descriptor$9;
var _descriptor2$9;
var _descriptor3$8;
var _descriptor4$8;
var Component = (_class$9 = function(_EngineObject) {
  _inheritsLoose(Component2, _EngineObject);
  function Component2(entity) {
    var _this;
    _this = _EngineObject.call(this, entity.engine) || this;
    _initializerDefineProperty(_this, "_entity", _descriptor$9, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_destroyed", _descriptor2$9, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_enabled", _descriptor3$8, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_awoken", _descriptor4$8, _assertThisInitialized(_this));
    _this._entity = entity;
    return _this;
  }
  var _proto = Component2.prototype;
  _proto.destroy = function destroy() {
    if (this._destroyed) {
      return;
    }
    this._entity._removeComponent(this);
    if (this._entity.isActiveInHierarchy) {
      this._enabled && this._onDisable();
      this._onInActive();
    }
    this._destroyed = true;
    this._onDestroy();
  };
  _proto._onAwake = function _onAwake() {
  };
  _proto._onEnable = function _onEnable() {
  };
  _proto._onDisable = function _onDisable() {
  };
  _proto._onDestroy = function _onDestroy() {
  };
  _proto._onActive = function _onActive() {
  };
  _proto._onInActive = function _onInActive() {
  };
  _proto._setActive = function _setActive(value) {
    if (value) {
      if (!this._awoken) {
        this._awoken = true;
        this._onAwake();
      }
      if (this._entity._isActiveInHierarchy) {
        this._onActive();
        this._enabled && this._onEnable();
      }
    } else {
      this._enabled && this._onDisable();
      this._onInActive();
    }
  };
  _createClass(Component2, [{
    key: "enabled",
    get: function get4() {
      return this._enabled;
    },
    set: function set4(value) {
      if (value === this._enabled) {
        return;
      }
      this._enabled = value;
      if (value) {
        this._entity.isActiveInHierarchy && this._onEnable();
      } else {
        this._entity.isActiveInHierarchy && this._onDisable();
      }
    }
  }, {
    key: "destroyed",
    get: function get4() {
      return this._destroyed;
    }
  }, {
    key: "entity",
    get: function get4() {
      return this._entity;
    }
  }, {
    key: "scene",
    get: function get4() {
      return this._entity.scene;
    }
  }]);
  return Component2;
}(EngineObject), _descriptor$9 = _applyDecoratedDescriptor(_class$9.prototype, "_entity", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$9 = _applyDecoratedDescriptor(_class$9.prototype, "_destroyed", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer3() {
    return false;
  }
}), _descriptor3$8 = _applyDecoratedDescriptor(_class$9.prototype, "_enabled", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer4() {
    return true;
  }
}), _descriptor4$8 = _applyDecoratedDescriptor(_class$9.prototype, "_awoken", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer5() {
    return false;
  }
}), _class$9);
var UpdateFlag = function() {
  function UpdateFlag2(_flags) {
    if (_flags === void 0) {
      _flags = [];
    }
    this._flags = _flags;
    this.flag = true;
    this._flags.push(this);
  }
  var _proto = UpdateFlag2.prototype;
  _proto.destroy = function destroy() {
    var flags = this._flags;
    removeFromArray(flags, this);
    this._flags = null;
  };
  return UpdateFlag2;
}();
var UpdateFlagManager = function() {
  function UpdateFlagManager2() {
    this._updateFlags = [];
  }
  var _proto = UpdateFlagManager2.prototype;
  _proto.register = function register() {
    return new UpdateFlag(this._updateFlags);
  };
  _proto.distribute = function distribute() {
    var updateFlags = this._updateFlags;
    for (var i = updateFlags.length - 1; i >= 0; i--) {
      updateFlags[i].flag = true;
    }
  };
  return UpdateFlagManager2;
}();
var _class$8;
var _descriptor$8;
var _descriptor2$8;
var _descriptor3$7;
var _descriptor4$7;
var _descriptor5$7;
var _descriptor6$7;
var _descriptor7$5;
var _descriptor8$3;
var _descriptor9$3;
var _descriptor10$3;
var _descriptor11$3;
var _descriptor12$3;
var _descriptor13$2;
var _class2$7;
var _temp$7;
var Transform = (_class$8 = (_temp$7 = _class2$7 = function(_Component) {
  _inheritsLoose(Transform2, _Component);
  function Transform2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _initializerDefineProperty(_this, "_position", _descriptor$8, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_rotation", _descriptor2$8, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_rotationQuaternion", _descriptor3$7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_scale", _descriptor4$7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_worldPosition", _descriptor5$7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_worldRotation", _descriptor6$7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_worldRotationQuaternion", _descriptor7$5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_lossyWorldScale", _descriptor8$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_localMatrix", _descriptor9$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_worldMatrix", _descriptor10$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_updateFlagManager", _descriptor11$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_isParentDirty", _descriptor12$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_parentTransformCache", _descriptor13$2, _assertThisInitialized(_this));
    _this._dirtyFlag = TransformFlag.WmWpWeWqWs;
    return _this;
  }
  var _proto = Transform2.prototype;
  _proto.setPosition = function setPosition(x, y, z) {
    this._position.setValue(x, y, z);
    this.position = this._position;
  };
  _proto.setRotation = function setRotation(x, y, z) {
    this._rotation.setValue(x, y, z);
    this.rotation = this._rotation;
  };
  _proto.setRotationQuaternion = function setRotationQuaternion(x, y, z, w) {
    this._rotationQuaternion.setValue(x, y, z, w);
    this.rotationQuaternion = this._rotationQuaternion;
  };
  _proto.setScale = function setScale(x, y, z) {
    this._scale.setValue(x, y, z);
    this.scale = this._scale;
  };
  _proto.setWorldPosition = function setWorldPosition(x, y, z) {
    this._worldPosition.setValue(x, y, z);
    this.worldPosition = this._worldPosition;
  };
  _proto.setWorldRotation = function setWorldRotation(x, y, z) {
    this._worldRotation.setValue(x, y, z);
    this.worldRotation = this._worldRotation;
  };
  _proto.setWorldRotationQuaternion = function setWorldRotationQuaternion(x, y, z, w) {
    this._worldRotationQuaternion.setValue(x, y, z, w);
    this.worldRotationQuaternion = this._worldRotationQuaternion;
  };
  _proto.getWorldForward = function getWorldForward(forward) {
    var e = this.worldMatrix.elements;
    forward.setValue(-e[8], -e[9], -e[10]);
    return forward.normalize();
  };
  _proto.getWorldRight = function getWorldRight(right) {
    var e = this.worldMatrix.elements;
    right.setValue(e[0], e[1], e[2]);
    return right.normalize();
  };
  _proto.getWorldUp = function getWorldUp(up) {
    var e = this.worldMatrix.elements;
    up.setValue(e[4], e[5], e[6]);
    return up.normalize();
  };
  _proto.translate = function translate(translationOrX, relativeToLocalOrY, z, relativeToLocal) {
    if (typeof translationOrX === "number") {
      var _translate2 = Transform2._tempVec3;
      _translate2.setValue(translationOrX, relativeToLocalOrY, z);
      this._translate(_translate2, relativeToLocal);
    } else {
      this._translate(translationOrX, relativeToLocalOrY);
    }
  };
  _proto.rotate = function rotate(rotationOrX, relativeToLocalOrY, z, relativeToLocal) {
    if (typeof rotationOrX === "number") {
      this._rotateXYZ(rotationOrX, relativeToLocalOrY, z, relativeToLocal);
    } else {
      this._rotateXYZ(rotationOrX.x, rotationOrX.y, rotationOrX.z, relativeToLocalOrY);
    }
  };
  _proto.rotateByAxis = function rotateByAxis(axis, angle, relativeToLocal) {
    if (relativeToLocal === void 0) {
      relativeToLocal = true;
    }
    var rad = angle * MathUtil.degreeToRadFactor;
    Quaternion.rotationAxisAngle(axis, rad, Transform2._tempQuat0);
    this._rotateByQuat(Transform2._tempQuat0, relativeToLocal);
  };
  _proto.lookAt = function lookAt(worldPosition, worldUp) {
    var _worldUp;
    var position = this.worldPosition;
    var EPSILON = MathUtil.zeroTolerance;
    if (Math.abs(position.x - worldPosition.x) < EPSILON && Math.abs(position.y - worldPosition.y) < EPSILON && Math.abs(position.z - worldPosition.z) < EPSILON) {
      return;
    }
    var rotMat = Transform2._tempMat43;
    var worldRotationQuaternion = this._worldRotationQuaternion;
    worldUp = (_worldUp = worldUp) != null ? _worldUp : Transform2._tempVec3.setValue(0, 1, 0);
    Matrix.lookAt(position, worldPosition, worldUp, rotMat);
    rotMat.getRotation(worldRotationQuaternion).invert();
    this.worldRotationQuaternion = worldRotationQuaternion;
  };
  _proto.registerWorldChangeFlag = function registerWorldChangeFlag() {
    return this._updateFlagManager.register();
  };
  _proto._parentChange = function _parentChange() {
    this._isParentDirty = true;
    this._updateAllWorldFlag();
  };
  _proto._updateWorldPositionFlag = function _updateWorldPositionFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWp)) {
      this._worldAssociatedChange(TransformFlag.WmWp);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans;
        (_nodeChildren$i$trans = nodeChildren[i].transform) === null || _nodeChildren$i$trans === void 0 ? void 0 : _nodeChildren$i$trans._updateWorldPositionFlag();
      }
    }
  };
  _proto._updateWorldRotationFlag = function _updateWorldRotationFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWeWq)) {
      this._worldAssociatedChange(TransformFlag.WmWeWq);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans2;
        (_nodeChildren$i$trans2 = nodeChildren[i].transform) === null || _nodeChildren$i$trans2 === void 0 ? void 0 : _nodeChildren$i$trans2._updateWorldPositionAndRotationFlag();
      }
    }
  };
  _proto._updateWorldPositionAndRotationFlag = function _updateWorldPositionAndRotationFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWpWeWq)) {
      this._worldAssociatedChange(TransformFlag.WmWpWeWq);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans3;
        (_nodeChildren$i$trans3 = nodeChildren[i].transform) === null || _nodeChildren$i$trans3 === void 0 ? void 0 : _nodeChildren$i$trans3._updateWorldPositionAndRotationFlag();
      }
    }
  };
  _proto._updateWorldScaleFlag = function _updateWorldScaleFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWs)) {
      this._worldAssociatedChange(TransformFlag.WmWs);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans4;
        (_nodeChildren$i$trans4 = nodeChildren[i].transform) === null || _nodeChildren$i$trans4 === void 0 ? void 0 : _nodeChildren$i$trans4._updateWorldPositionAndScaleFlag();
      }
    }
  };
  _proto._updateWorldPositionAndScaleFlag = function _updateWorldPositionAndScaleFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWpWs)) {
      this._worldAssociatedChange(TransformFlag.WmWpWs);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans5;
        (_nodeChildren$i$trans5 = nodeChildren[i].transform) === null || _nodeChildren$i$trans5 === void 0 ? void 0 : _nodeChildren$i$trans5._updateWorldPositionAndScaleFlag();
      }
    }
  };
  _proto._updateAllWorldFlag = function _updateAllWorldFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWpWeWqWs)) {
      this._worldAssociatedChange(TransformFlag.WmWpWeWqWs);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans6;
        (_nodeChildren$i$trans6 = nodeChildren[i].transform) === null || _nodeChildren$i$trans6 === void 0 ? void 0 : _nodeChildren$i$trans6._updateAllWorldFlag();
      }
    }
  };
  _proto._getParentTransform = function _getParentTransform() {
    if (!this._isParentDirty) {
      return this._parentTransformCache;
    }
    var parentCache = null;
    var parent = this._entity.parent;
    while (parent) {
      var transform = parent.transform;
      if (transform) {
        parentCache = transform;
        break;
      } else {
        parent = parent.parent;
      }
    }
    this._parentTransformCache = parentCache;
    this._isParentDirty = false;
    return parentCache;
  };
  _proto._getScaleMatrix = function _getScaleMatrix() {
    var invRotation = Transform2._tempQuat0;
    var invRotationMat = Transform2._tempMat30;
    var worldRotScaMat = Transform2._tempMat31;
    var scaMat = Transform2._tempMat32;
    worldRotScaMat.setValueByMatrix(this.worldMatrix);
    Quaternion.invert(this.worldRotationQuaternion, invRotation);
    Matrix3x3.rotationQuaternion(invRotation, invRotationMat);
    Matrix3x3.multiply(invRotationMat, worldRotScaMat, scaMat);
    return scaMat;
  };
  _proto._isContainDirtyFlags = function _isContainDirtyFlags(targetDirtyFlags) {
    return (this._dirtyFlag & targetDirtyFlags) === targetDirtyFlags;
  };
  _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
    return (this._dirtyFlag & type) != 0;
  };
  _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
    this._dirtyFlag |= type;
  };
  _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
    this._dirtyFlag &= ~type;
  };
  _proto._worldAssociatedChange = function _worldAssociatedChange(type) {
    this._dirtyFlag |= type;
    this._updateFlagManager.distribute();
  };
  _proto._rotateByQuat = function _rotateByQuat(rotateQuat, relativeToLocal) {
    if (relativeToLocal) {
      Quaternion.multiply(this.rotationQuaternion, rotateQuat, this._rotationQuaternion);
      this.rotationQuaternion = this._rotationQuaternion;
    } else {
      Quaternion.multiply(this.worldRotationQuaternion, rotateQuat, this._worldRotationQuaternion);
      this.worldRotationQuaternion = this._worldRotationQuaternion;
    }
  };
  _proto._translate = function _translate(translation, relativeToLocal) {
    if (relativeToLocal === void 0) {
      relativeToLocal = true;
    }
    if (relativeToLocal) {
      this.position = this._position.add(translation);
    } else {
      this.worldPosition = this._worldPosition.add(translation);
    }
  };
  _proto._rotateXYZ = function _rotateXYZ(x, y, z, relativeToLocal) {
    if (relativeToLocal === void 0) {
      relativeToLocal = true;
    }
    var radFactor = MathUtil.degreeToRadFactor;
    var rotQuat = Transform2._tempQuat0;
    Quaternion.rotationEuler(x * radFactor, y * radFactor, z * radFactor, rotQuat);
    this._rotateByQuat(rotQuat, relativeToLocal);
  };
  _createClass(Transform2, [{
    key: "position",
    get: function get4() {
      return this._position;
    },
    set: function set4(value) {
      if (this._position !== value) {
        value.cloneTo(this._position);
      }
      this._setDirtyFlagTrue(TransformFlag.LocalMatrix);
      this._updateWorldPositionFlag();
    }
  }, {
    key: "worldPosition",
    get: function get4() {
      if (this._isContainDirtyFlag(TransformFlag.WorldPosition)) {
        if (this._getParentTransform()) {
          this.worldMatrix.getTranslation(this._worldPosition);
        } else {
          this._position.cloneTo(this._worldPosition);
        }
        this._setDirtyFlagFalse(TransformFlag.WorldPosition);
      }
      return this._worldPosition;
    },
    set: function set4(value) {
      if (this._worldPosition !== value) {
        value.cloneTo(this._worldPosition);
      }
      var parent = this._getParentTransform();
      if (parent) {
        Matrix.invert(parent.worldMatrix, Transform2._tempMat41);
        Vector3.transformCoordinate(value, Transform2._tempMat41, this._position);
      } else {
        value.cloneTo(this._position);
      }
      this.position = this._position;
      this._setDirtyFlagFalse(TransformFlag.WorldPosition);
    }
  }, {
    key: "rotation",
    get: function get4() {
      if (this._isContainDirtyFlag(TransformFlag.LocalEuler)) {
        this._rotationQuaternion.toEuler(this._rotation);
        this._rotation.scale(MathUtil.radToDegreeFactor);
        this._setDirtyFlagFalse(TransformFlag.LocalEuler);
      }
      return this._rotation;
    },
    set: function set4(value) {
      if (this._rotation !== value) {
        value.cloneTo(this._rotation);
      }
      this._setDirtyFlagTrue(TransformFlag.LocalMatrix | TransformFlag.LocalQuat);
      this._setDirtyFlagFalse(TransformFlag.LocalEuler);
      this._updateWorldRotationFlag();
    }
  }, {
    key: "worldRotation",
    get: function get4() {
      if (this._isContainDirtyFlag(TransformFlag.WorldEuler)) {
        this.worldRotationQuaternion.toEuler(this._worldRotation);
        this._worldRotation.scale(MathUtil.radToDegreeFactor);
        this._setDirtyFlagFalse(TransformFlag.WorldEuler);
      }
      return this._worldRotation;
    },
    set: function set4(value) {
      if (this._worldRotation !== value) {
        value.cloneTo(this._worldRotation);
      }
      Quaternion.rotationEuler(MathUtil.degreeToRadian(value.x), MathUtil.degreeToRadian(value.y), MathUtil.degreeToRadian(value.z), this._worldRotationQuaternion);
      this.worldRotationQuaternion = this._worldRotationQuaternion;
      this._setDirtyFlagFalse(TransformFlag.WorldEuler);
    }
  }, {
    key: "rotationQuaternion",
    get: function get4() {
      if (this._isContainDirtyFlag(TransformFlag.LocalQuat)) {
        Quaternion.rotationEuler(MathUtil.degreeToRadian(this._rotation.x), MathUtil.degreeToRadian(this._rotation.y), MathUtil.degreeToRadian(this._rotation.z), this._rotationQuaternion);
        this._setDirtyFlagFalse(TransformFlag.LocalQuat);
      }
      return this._rotationQuaternion;
    },
    set: function set4(value) {
      if (this._rotationQuaternion !== value) {
        value.cloneTo(this._rotationQuaternion);
      }
      this._setDirtyFlagTrue(TransformFlag.LocalMatrix | TransformFlag.LocalEuler);
      this._setDirtyFlagFalse(TransformFlag.LocalQuat);
      this._updateWorldRotationFlag();
    }
  }, {
    key: "worldRotationQuaternion",
    get: function get4() {
      if (this._isContainDirtyFlag(TransformFlag.WorldQuat)) {
        var parent = this._getParentTransform();
        if (parent != null) {
          Quaternion.multiply(parent.worldRotationQuaternion, this.rotationQuaternion, this._worldRotationQuaternion);
        } else {
          this.rotationQuaternion.cloneTo(this._worldRotationQuaternion);
        }
        this._setDirtyFlagFalse(TransformFlag.WorldQuat);
      }
      return this._worldRotationQuaternion;
    },
    set: function set4(value) {
      if (this._worldRotationQuaternion !== value) {
        value.cloneTo(this._worldRotationQuaternion);
      }
      var parent = this._getParentTransform();
      if (parent) {
        Quaternion.invert(parent.worldRotationQuaternion, Transform2._tempQuat0);
        Quaternion.multiply(value, Transform2._tempQuat0, this._rotationQuaternion);
      } else {
        value.cloneTo(this._rotationQuaternion);
      }
      this.rotationQuaternion = this._rotationQuaternion;
      this._setDirtyFlagFalse(TransformFlag.WorldQuat);
    }
  }, {
    key: "scale",
    get: function get4() {
      return this._scale;
    },
    set: function set4(value) {
      if (this._scale !== value) {
        value.cloneTo(this._scale);
      }
      this._setDirtyFlagTrue(TransformFlag.LocalMatrix);
      this._updateWorldScaleFlag();
    }
  }, {
    key: "lossyWorldScale",
    get: function get4() {
      if (this._isContainDirtyFlag(TransformFlag.WorldScale)) {
        if (this._getParentTransform()) {
          var scaleMat = this._getScaleMatrix();
          var e = scaleMat.elements;
          this._lossyWorldScale.setValue(e[0], e[4], e[8]);
        } else {
          this._scale.cloneTo(this._lossyWorldScale);
        }
        this._setDirtyFlagFalse(TransformFlag.WorldScale);
      }
      return this._lossyWorldScale;
    }
  }, {
    key: "localMatrix",
    get: function get4() {
      if (this._isContainDirtyFlag(TransformFlag.LocalMatrix)) {
        Matrix.affineTransformation(this._scale, this.rotationQuaternion, this._position, this._localMatrix);
        this._setDirtyFlagFalse(TransformFlag.LocalMatrix);
      }
      return this._localMatrix;
    },
    set: function set4(value) {
      if (this._localMatrix !== value) {
        value.cloneTo(this._localMatrix);
      }
      this._localMatrix.decompose(this._position, this._rotationQuaternion, this._scale);
      this._setDirtyFlagTrue(TransformFlag.LocalEuler);
      this._setDirtyFlagFalse(TransformFlag.LocalMatrix);
      this._updateAllWorldFlag();
    }
  }, {
    key: "worldMatrix",
    get: function get4() {
      if (this._isContainDirtyFlag(TransformFlag.WorldMatrix)) {
        var parent = this._getParentTransform();
        if (parent) {
          Matrix.multiply(parent.worldMatrix, this.localMatrix, this._worldMatrix);
        } else {
          this.localMatrix.cloneTo(this._worldMatrix);
        }
        this._setDirtyFlagFalse(TransformFlag.WorldMatrix);
      }
      return this._worldMatrix;
    },
    set: function set4(value) {
      if (this._worldMatrix !== value) {
        value.cloneTo(this._worldMatrix);
      }
      var parent = this._getParentTransform();
      if (parent) {
        Matrix.invert(parent.worldMatrix, Transform2._tempMat42);
        Matrix.multiply(value, Transform2._tempMat42, this._localMatrix);
      } else {
        value.cloneTo(this._localMatrix);
      }
      this.localMatrix = this._localMatrix;
      this._setDirtyFlagFalse(TransformFlag.WorldMatrix);
    }
  }]);
  return Transform2;
}(Component), _class2$7._tempQuat0 = new Quaternion(), _class2$7._tempVec3 = new Vector3(), _class2$7._tempMat30 = new Matrix3x3(), _class2$7._tempMat31 = new Matrix3x3(), _class2$7._tempMat32 = new Matrix3x3(), _class2$7._tempMat40 = new Matrix(), _class2$7._tempMat41 = new Matrix(), _class2$7._tempMat42 = new Matrix(), _class2$7._tempMat43 = new Matrix(), _temp$7), _descriptor$8 = _applyDecoratedDescriptor(_class$8.prototype, "_position", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer6() {
    return new Vector3();
  }
}), _descriptor2$8 = _applyDecoratedDescriptor(_class$8.prototype, "_rotation", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer7() {
    return new Vector3();
  }
}), _descriptor3$7 = _applyDecoratedDescriptor(_class$8.prototype, "_rotationQuaternion", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer8() {
    return new Quaternion();
  }
}), _descriptor4$7 = _applyDecoratedDescriptor(_class$8.prototype, "_scale", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer9() {
    return new Vector3(1, 1, 1);
  }
}), _descriptor5$7 = _applyDecoratedDescriptor(_class$8.prototype, "_worldPosition", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer10() {
    return new Vector3();
  }
}), _descriptor6$7 = _applyDecoratedDescriptor(_class$8.prototype, "_worldRotation", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer11() {
    return new Vector3();
  }
}), _descriptor7$5 = _applyDecoratedDescriptor(_class$8.prototype, "_worldRotationQuaternion", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer12() {
    return new Quaternion();
  }
}), _descriptor8$3 = _applyDecoratedDescriptor(_class$8.prototype, "_lossyWorldScale", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer13() {
    return new Vector3(1, 1, 1);
  }
}), _descriptor9$3 = _applyDecoratedDescriptor(_class$8.prototype, "_localMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer14() {
    return new Matrix();
  }
}), _descriptor10$3 = _applyDecoratedDescriptor(_class$8.prototype, "_worldMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer15() {
    return new Matrix();
  }
}), _descriptor11$3 = _applyDecoratedDescriptor(_class$8.prototype, "_updateFlagManager", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer16() {
    return new UpdateFlagManager();
  }
}), _descriptor12$3 = _applyDecoratedDescriptor(_class$8.prototype, "_isParentDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer17() {
    return true;
  }
}), _descriptor13$2 = _applyDecoratedDescriptor(_class$8.prototype, "_parentTransformCache", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer18() {
    return null;
  }
}), _class$8);
var TransformFlag;
(function(TransformFlag2) {
  TransformFlag2[TransformFlag2["LocalEuler"] = 1] = "LocalEuler";
  TransformFlag2[TransformFlag2["LocalQuat"] = 2] = "LocalQuat";
  TransformFlag2[TransformFlag2["WorldPosition"] = 4] = "WorldPosition";
  TransformFlag2[TransformFlag2["WorldEuler"] = 8] = "WorldEuler";
  TransformFlag2[TransformFlag2["WorldQuat"] = 16] = "WorldQuat";
  TransformFlag2[TransformFlag2["WorldScale"] = 32] = "WorldScale";
  TransformFlag2[TransformFlag2["LocalMatrix"] = 64] = "LocalMatrix";
  TransformFlag2[TransformFlag2["WorldMatrix"] = 128] = "WorldMatrix";
  TransformFlag2[TransformFlag2["WmWp"] = 132] = "WmWp";
  TransformFlag2[TransformFlag2["WmWeWq"] = 152] = "WmWeWq";
  TransformFlag2[TransformFlag2["WmWpWeWq"] = 156] = "WmWpWeWq";
  TransformFlag2[TransformFlag2["WmWs"] = 160] = "WmWs";
  TransformFlag2[TransformFlag2["WmWpWs"] = 164] = "WmWpWs";
  TransformFlag2[TransformFlag2["WmWpWeWqWs"] = 188] = "WmWpWeWqWs";
})(TransformFlag || (TransformFlag = {}));
var Entity = function(_EngineObject) {
  _inheritsLoose(Entity2, _EngineObject);
  Entity2._findChildByName = function _findChildByName(root, name) {
    var children = root._children;
    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];
      if (child.name === name) {
        return child;
      }
    }
    return null;
  };
  Entity2._traverseSetOwnerScene = function _traverseSetOwnerScene(entity, scene) {
    entity._scene = scene;
    var children = entity._children;
    for (var i = entity.childCount - 1; i >= 0; i--) {
      this._traverseSetOwnerScene(children[i], scene);
    }
  };
  function Entity2(engine, name) {
    var _this;
    _this = _EngineObject.call(this, engine) || this;
    _this.name = void 0;
    _this.layer = Layer.Layer0;
    _this.transform = void 0;
    _this._isActiveInHierarchy = false;
    _this._components = [];
    _this._scripts = new DisorderedArray();
    _this._children = [];
    _this._scene = void 0;
    _this._isRoot = false;
    _this._isActive = true;
    _this._parent = null;
    _this._activeChangedComponents = void 0;
    _this._invModelMatrix = new Matrix();
    _this._inverseWorldMatFlag = void 0;
    _this.name = name;
    _this.transform = _this.addComponent(Transform);
    _this._inverseWorldMatFlag = _this.transform.registerWorldChangeFlag();
    return _this;
  }
  var _proto = Entity2.prototype;
  _proto.addComponent = function addComponent(type) {
    ComponentsDependencies._addCheck(this, type);
    var component = new type(this);
    this._components.push(component);
    if (this._isActiveInHierarchy) {
      component._setActive(true);
    }
    return component;
  };
  _proto.getComponent = function getComponent(type) {
    for (var i = this._components.length - 1; i >= 0; i--) {
      var component = this._components[i];
      if (component instanceof type) {
        return component;
      }
    }
  };
  _proto.getComponents = function getComponents(type, results) {
    results.length = 0;
    for (var i = this._components.length - 1; i >= 0; i--) {
      var component = this._components[i];
      if (component instanceof type) {
        results.push(component);
      }
    }
    return results;
  };
  _proto.getComponentsIncludeChildren = function getComponentsIncludeChildren(type, results) {
    results.length = 0;
    this._getComponentsInChildren(type, results);
    return results;
  };
  _proto.addChild = function addChild(child) {
    child.parent = this;
  };
  _proto.removeChild = function removeChild(child) {
    child.parent = null;
  };
  _proto.getChild = function getChild(index) {
    return this._children[index];
  };
  _proto.findByName = function findByName(name) {
    var children = this._children;
    var child = Entity2._findChildByName(this, name);
    if (child)
      return child;
    for (var i = children.length - 1; i >= 0; i--) {
      var _child = children[i];
      var grandson = _child.findByName(name);
      if (grandson) {
        return grandson;
      }
    }
    return null;
  };
  _proto.findByPath = function findByPath(path) {
    var splits = path.split("/");
    var entity = this;
    for (var i = 0, length2 = splits.length; i < length2; ++i) {
      var split = splits[i];
      if (split) {
        entity = Entity2._findChildByName(entity, split);
        if (!entity) {
          return null;
        }
      }
    }
    return entity;
  };
  _proto.createChild = function createChild(name) {
    var child = new Entity2(this.engine, name);
    child.layer = this.layer;
    child.parent = this;
    return child;
  };
  _proto.clearChildren = function clearChildren() {
    var children = this._children;
    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];
      child._parent = null;
      child._isActiveInHierarchy && child._processInActive();
      Entity2._traverseSetOwnerScene(child, null);
    }
    children.length = 0;
  };
  _proto.clone = function clone2() {
    var cloneEntity = new Entity2(this._engine, this.name);
    cloneEntity._isActive = this._isActive;
    cloneEntity.transform.localMatrix = this.transform.localMatrix;
    var children = this._children;
    for (var i = 0, len = this._children.length; i < len; i++) {
      var child = children[i];
      cloneEntity.addChild(child.clone());
    }
    var components = this._components;
    for (var _i = 0, n = components.length; _i < n; _i++) {
      var sourceComp = components[_i];
      if (!(sourceComp instanceof Transform)) {
        var targetComp = cloneEntity.addComponent(sourceComp.constructor);
        ComponentCloner.cloneComponent(sourceComp, targetComp);
      }
    }
    return cloneEntity;
  };
  _proto.destroy = function destroy() {
    var abilityArray = this._components;
    for (var i = abilityArray.length - 1; i >= 0; i--) {
      abilityArray[i].destroy();
    }
    this._components.length = 0;
    var children = this._children;
    for (var _i2 = children.length - 1; _i2 >= 0; _i2--) {
      children[_i2].destroy();
    }
    this._children.length = 0;
    if (this._parent != null) {
      var parentChildren = this._parent._children;
      parentChildren.splice(parentChildren.indexOf(this), 1);
    }
    this._parent = null;
  };
  _proto._removeComponent = function _removeComponent(component) {
    ComponentsDependencies._removeCheck(this, component.constructor);
    var components = this._components;
    components.splice(components.indexOf(component), 1);
  };
  _proto._addScript = function _addScript(script2) {
    script2._entityCacheIndex = this._scripts.length;
    this._scripts.add(script2);
  };
  _proto._removeScript = function _removeScript(script2) {
    var replaced = this._scripts.deleteByIndex(script2._entityCacheIndex);
    replaced && (replaced._entityCacheIndex = script2._entityCacheIndex);
    script2._entityCacheIndex = -1;
  };
  _proto._removeFromParent = function _removeFromParent() {
    var oldParent = this._parent;
    if (oldParent != null) {
      var oldParentChildren = oldParent._children;
      oldParentChildren.splice(oldParentChildren.indexOf(this), 1);
      this._parent = null;
    }
    return oldParent;
  };
  _proto._processActive = function _processActive() {
    if (this._activeChangedComponents) {
      throw "Note: can't set the 'main inActive entity' active in hierarchy, if the operation is in main inActive entity or it's children script's onDisable Event.";
    }
    this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();
    this._setActiveInHierarchy(this._activeChangedComponents);
    this._setActiveComponents(true);
  };
  _proto._processInActive = function _processInActive() {
    if (this._activeChangedComponents) {
      throw "Note: can't set the 'main active entity' inActive in hierarchy, if the operation is in main active entity or it's children script's onEnable Event.";
    }
    this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();
    this._setInActiveInHierarchy(this._activeChangedComponents);
    this._setActiveComponents(false);
  };
  _proto._getComponentsInChildren = function _getComponentsInChildren(type, results) {
    for (var i = this._components.length - 1; i >= 0; i--) {
      var component = this._components[i];
      if (component instanceof type) {
        results.push(component);
      }
    }
    for (var _i3 = this._children.length - 1; _i3 >= 0; _i3--) {
      this._children[_i3]._getComponentsInChildren(type, results);
    }
  };
  _proto._setActiveComponents = function _setActiveComponents(isActive) {
    var activeChangedComponents = this._activeChangedComponents;
    for (var i = 0, length2 = activeChangedComponents.length; i < length2; ++i) {
      activeChangedComponents[i]._setActive(isActive);
    }
    this._engine._componentsManager.putActiveChangedTempList(activeChangedComponents);
    this._activeChangedComponents = null;
  };
  _proto._setActiveInHierarchy = function _setActiveInHierarchy(activeChangedComponents) {
    this._isActiveInHierarchy = true;
    var components = this._components;
    for (var i = components.length - 1; i >= 0; i--) {
      activeChangedComponents.push(components[i]);
    }
    var children = this._children;
    for (var _i4 = children.length - 1; _i4 >= 0; _i4--) {
      var child = children[_i4];
      child.isActive && child._setActiveInHierarchy(activeChangedComponents);
    }
  };
  _proto._setInActiveInHierarchy = function _setInActiveInHierarchy(activeChangedComponents) {
    this._isActiveInHierarchy = false;
    var components = this._components;
    for (var i = components.length - 1; i >= 0; i--) {
      activeChangedComponents.push(components[i]);
    }
    var children = this._children;
    for (var _i5 = children.length - 1; _i5 >= 0; _i5--) {
      var child = children[_i5];
      child.isActive && child._setInActiveInHierarchy(activeChangedComponents);
    }
  };
  _proto._setTransformDirty = function _setTransformDirty() {
    if (this.transform) {
      this.transform._parentChange();
    } else {
      for (var i = 0, len = this._children.length; i < len; i++) {
        this._children[i]._setTransformDirty();
      }
    }
  };
  _proto.getInvModelMatrix = function getInvModelMatrix() {
    if (this._inverseWorldMatFlag.flag) {
      Matrix.invert(this.transform.worldMatrix, this._invModelMatrix);
      this._inverseWorldMatFlag.flag = false;
    }
    return this._invModelMatrix;
  };
  _createClass(Entity2, [{
    key: "isActive",
    get: function get4() {
      return this._isActive;
    },
    set: function set4(value) {
      if (value !== this._isActive) {
        this._isActive = value;
        if (value) {
          var parent = this._parent;
          if (parent !== null && parent !== void 0 && parent._isActiveInHierarchy || this._isRoot && this._scene._isActiveInEngine) {
            this._processActive();
          }
        } else {
          if (this._isActiveInHierarchy) {
            this._processInActive();
          }
        }
      }
    }
  }, {
    key: "isActiveInHierarchy",
    get: function get4() {
      return this._isActiveInHierarchy;
    }
  }, {
    key: "parent",
    get: function get4() {
      return this._parent;
    },
    set: function set4(entity) {
      if (entity !== this._parent) {
        var oldParent = this._removeFromParent();
        var newParent = this._parent = entity;
        if (newParent) {
          newParent._children.push(this);
          var parentScene = newParent._scene;
          if (this._scene !== parentScene) {
            Entity2._traverseSetOwnerScene(this, parentScene);
          }
          if (newParent._isActiveInHierarchy) {
            !this._isActiveInHierarchy && this._isActive && this._processActive();
          } else {
            this._isActiveInHierarchy && this._processInActive();
          }
        } else {
          this._isActiveInHierarchy && this._processInActive();
          if (oldParent) {
            Entity2._traverseSetOwnerScene(this, null);
          }
        }
        this._setTransformDirty();
      }
    }
  }, {
    key: "children",
    get: function get4() {
      return this._children;
    }
  }, {
    key: "childCount",
    get: function get4() {
      return this._children.length;
    }
  }, {
    key: "scene",
    get: function get4() {
      return this._scene;
    }
  }, {
    key: "position",
    get: function get4() {
      return this.transform.position;
    },
    set: function set4(val) {
      this.transform.position = val;
    }
  }, {
    key: "worldPosition",
    get: function get4() {
      return this.transform.worldPosition;
    },
    set: function set4(val) {
      this.transform.worldPosition = val;
    }
  }, {
    key: "rotation",
    get: function get4() {
      return this.transform.rotationQuaternion;
    },
    set: function set4(val) {
      this.transform.rotationQuaternion = val;
    }
  }, {
    key: "scale",
    get: function get4() {
      return this.transform.scale;
    },
    set: function set4(val) {
      this.transform.scale = val;
    }
  }]);
  return Entity2;
}(EngineObject);
var FeatureManager = function() {
  function FeatureManager2() {
    this._features = [];
    this._objects = [];
  }
  var _proto = FeatureManager2.prototype;
  _proto.registerFeature = function registerFeature(IFeature) {
    var featureArray = this._features;
    for (var i = 0, len = featureArray.length; i < len; i++) {
      if (featureArray[i] === IFeature) {
        return;
      }
    }
    featureArray.push(IFeature);
    var objectArray = this._objects;
    for (var _i = 0, _len = objectArray.length; _i < _len; _i++) {
      objectArray[_i].features.push(new IFeature());
    }
  };
  _proto.addObject = function addObject(obj) {
    obj.features = [];
    for (var i = 0, len = this._features.length; i < len; i++) {
      var _engine;
      obj.features.push(new this._features[i]((_engine = obj.engine) != null ? _engine : obj));
    }
    this._objects.push(obj);
  };
  _proto.callFeatureMethod = function callFeatureMethod(obj, method, args) {
    var features = obj.features;
    var count = features.length;
    for (var i = 0; i < count; i++) {
      var feature = features[i];
      if (feature[method]) {
        feature[method].apply(feature, args);
      }
    }
  };
  _proto.findFeature = function findFeature(obj, IFeature) {
    var features = obj.features;
    var count = features.length;
    for (var i = 0; i < count; i++) {
      var feature = features[i];
      if (feature.constructor === IFeature) {
        return feature;
      }
    }
    return void 0;
  };
  return FeatureManager2;
}();
var RenderQueueType;
(function(RenderQueueType2) {
  RenderQueueType2[RenderQueueType2["Opaque"] = 1e3] = "Opaque";
  RenderQueueType2[RenderQueueType2["AlphaTest"] = 2e3] = "AlphaTest";
  RenderQueueType2[RenderQueueType2["Transparent"] = 3e3] = "Transparent";
})(RenderQueueType || (RenderQueueType = {}));
var RefObject = function(_EngineObject) {
  _inheritsLoose(RefObject2, _EngineObject);
  function RefObject2(engine) {
    var _this;
    _this = _EngineObject.call(this, engine) || this;
    _this.isGCIgnored = false;
    _this._refCount = 0;
    _this._destroyed = false;
    engine.resourceManager._addRefObject(_this.instanceId, _assertThisInitialized(_this));
    return _this;
  }
  var _proto = RefObject2.prototype;
  _proto.destroy = function destroy(force) {
    if (force === void 0) {
      force = false;
    }
    if (this._destroyed)
      return true;
    if (!force && this._refCount !== 0)
      return false;
    var resourceManager = this._engine.resourceManager;
    if (resourceManager) {
      resourceManager._deleteAsset(this);
      resourceManager._deleteRefObject(this.instanceId);
    }
    var refCount = this._getRefCount();
    if (refCount > 0) {
      this._addRefCount(-refCount);
    }
    this._engine = null;
    this._onDestroy();
    this._destroyed = true;
    return true;
  };
  _proto._getRefCount = function _getRefCount() {
    return this._refCount;
  };
  _proto._addRefCount = function _addRefCount(value) {
    this._refCount += value;
  };
  _proto._addToResourceManager = function _addToResourceManager(path) {
    this._engine.resourceManager._addAsset(path, this);
  };
  _createClass(RefObject2, [{
    key: "refCount",
    get: function get4() {
      return this._refCount;
    }
  }, {
    key: "destroyed",
    get: function get4() {
      return this._destroyed;
    }
  }]);
  return RefObject2;
}(EngineObject);
var ShaderDataGroup;
(function(ShaderDataGroup2) {
  ShaderDataGroup2[ShaderDataGroup2["Scene"] = 0] = "Scene";
  ShaderDataGroup2[ShaderDataGroup2["Camera"] = 1] = "Camera";
  ShaderDataGroup2[ShaderDataGroup2["Renderer"] = 2] = "Renderer";
  ShaderDataGroup2[ShaderDataGroup2["Material"] = 3] = "Material";
})(ShaderDataGroup || (ShaderDataGroup = {}));
var Texture = function(_RefObject) {
  _inheritsLoose(Texture2, _RefObject);
  function Texture2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _RefObject.call.apply(_RefObject, [this].concat(args)) || this;
    _this.name = void 0;
    _this._platformTexture = void 0;
    _this._mipmap = void 0;
    _this._width = void 0;
    _this._height = void 0;
    _this._mipmapCount = void 0;
    _this._wrapModeU = void 0;
    _this._wrapModeV = void 0;
    _this._filterMode = void 0;
    _this._anisoLevel = 1;
    return _this;
  }
  var _proto = Texture2.prototype;
  _proto.generateMipmaps = function generateMipmaps() {
    if (!this._mipmap)
      return;
    this._platformTexture.generateMipmaps();
  };
  _proto._onDestroy = function _onDestroy() {
    this._platformTexture.destroy();
    this._platformTexture = null;
  };
  _proto._getMaxMiplevel = function _getMaxMiplevel(size) {
    return Math.floor(Math.log2(size));
  };
  _proto._getMipmapCount = function _getMipmapCount() {
    return this._mipmap ? Math.floor(Math.log2(Math.max(this._width, this._height))) + 1 : 1;
  };
  _createClass(Texture2, [{
    key: "width",
    get: function get4() {
      return this._width;
    }
  }, {
    key: "height",
    get: function get4() {
      return this._height;
    }
  }, {
    key: "wrapModeU",
    get: function get4() {
      return this._wrapModeU;
    },
    set: function set4(value) {
      if (value === this._wrapModeU)
        return;
      this._wrapModeU = value;
      this._platformTexture.wrapModeU = value;
    }
  }, {
    key: "wrapModeV",
    get: function get4() {
      return this._wrapModeV;
    },
    set: function set4(value) {
      if (value === this._wrapModeV)
        return;
      this._wrapModeV = value;
      this._platformTexture.wrapModeV = value;
    }
  }, {
    key: "mipmapCount",
    get: function get4() {
      return this._mipmapCount;
    }
  }, {
    key: "filterMode",
    get: function get4() {
      return this._filterMode;
    },
    set: function set4(value) {
      if (value === this._filterMode)
        return;
      this._filterMode = value;
      this._platformTexture.filterMode = value;
    }
  }, {
    key: "anisoLevel",
    get: function get4() {
      return this._anisoLevel;
    },
    set: function set4(value) {
      var max = this._engine._hardwareRenderer.capability.maxAnisoLevel;
      if (value > max) {
        Logger.warn("anisoLevel:" + value + ", exceeds the limit and is automatically downgraded to:" + max);
        value = max;
      }
      if (value < 1) {
        Logger.warn("anisoLevel:" + value + ", must be greater than 0, and is automatically downgraded to 1");
        value = 1;
      }
      if (value === this._anisoLevel)
        return;
      this._anisoLevel = value;
      this._platformTexture.anisoLevel = value;
    }
  }]);
  return Texture2;
}(RefObject);
var common = "#define GLSLIFY 1\n#define PI 3.14159265359\n#define LOG2 1.442695\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n";
var common_vert = "#define GLSLIFY 1\nattribute vec3 POSITION;\n#ifdef O3_HAS_UV\nattribute vec2 TEXCOORD_0;\n#endif\n#ifdef O3_HAS_SKIN\nattribute vec4 JOINTS_0;attribute vec4 WEIGHTS_0;\n#ifdef O3_USE_JOINT_TEXTURE\nuniform sampler2D u_jointSampler;uniform float u_jointCount;mat4 getJointMatrix(sampler2D smp,float index){float base=index/u_jointCount;float hf=0.5/u_jointCount;float v=base+hf;vec4 m0=texture2D(smp,vec2(0.125,v));vec4 m1=texture2D(smp,vec2(0.375,v));vec4 m2=texture2D(smp,vec2(0.625,v));vec4 m3=texture2D(smp,vec2(0.875,v));return mat4(m0,m1,m2,m3);}\n#else\nuniform mat4 u_jointMatrix[O3_JOINTS_NUM];\n#endif\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\nattribute vec4 COLOR_0;\n#endif\nuniform mat4 u_localMat;uniform mat4 u_modelMat;uniform mat4 u_viewMat;uniform mat4 u_projMat;uniform mat4 u_MVMat;uniform mat4 u_MVPMat;uniform mat4 u_normalMat;uniform vec3 u_cameraPos;uniform vec4 u_tilingOffset;\n#ifndef OMIT_NORMAL\n#ifdef O3_HAS_NORMAL\nattribute vec3 NORMAL;\n#endif\n#ifdef O3_HAS_TANGENT\nattribute vec4 TANGENT;\n#endif\n#endif\n";
var common_frag = "#define GLSLIFY 1\nuniform O3_VERTEX_PRECISION mat4 u_localMat;uniform O3_VERTEX_PRECISION mat4 u_modelMat;uniform O3_VERTEX_PRECISION mat4 u_viewMat;uniform O3_VERTEX_PRECISION mat4 u_projMat;uniform O3_VERTEX_PRECISION mat4 u_MVMat;uniform O3_VERTEX_PRECISION mat4 u_MVPMat;uniform O3_VERTEX_PRECISION mat4 u_normalMat;uniform O3_VERTEX_PRECISION vec3 u_cameraPos;";
var color_share = "#define GLSLIFY 1\n#ifdef O3_HAS_VERTEXCOLOR\nvarying vec4 v_color;\n#endif\n";
var normal_share = "#define GLSLIFY 1\n#ifdef O3_HAS_NORMAL\n#if defined( O3_HAS_TANGENT ) && defined( O3_NORMAL_TEXTURE )\nvarying mat3 v_TBN;\n#else\nvarying vec3 v_normal;\n#endif\n#endif\n";
var uv_share = "#define GLSLIFY 1\nvarying vec2 v_uv;";
var worldpos_share = "#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvarying vec3 v_pos;\n#endif\n";
var shadow_share = "#define GLSLIFY 1\n#ifdef O3_GENERATE_SHADOW_MAP\nuniform mat4 u_viewMatFromLight;uniform mat4 u_projMatFromLight;\n#endif\n#ifdef O3_SHADOW_MAP_COUNT\nuniform mat4 u_viewMatFromLight[O3_SHADOW_MAP_COUNT];uniform mat4 u_projMatFromLight[O3_SHADOW_MAP_COUNT];varying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];\n#endif\n";
var fog_share = "#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nvarying vec3 v_fogDepth;uniform O3_VERTEX_PRECISION vec3 u_fogColor;\n#ifdef O3_FOG_EXP2\nuniform O3_VERTEX_PRECISION float u_fogDensity;\n#else\nuniform O3_VERTEX_PRECISION float u_fogNear;uniform O3_VERTEX_PRECISION float u_fogFar;\n#endif\n#endif\n";
var begin_normal_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_NORMAL\nvec3 normal=vec3(NORMAL);\n#if defined( O3_HAS_TANGENT ) && defined( O3_NORMAL_TEXTURE )\nvec4 tangent=vec4(TANGENT);\n#endif\n#endif\n";
var begin_position_vert = "#define GLSLIFY 1\nvec4 position=vec4(POSITION,1.0);";
var position_vert = "#define GLSLIFY 1\n#ifndef O3_GENERATE_SHADOW_MAP\ngl_Position=u_MVPMat*position;\n#endif\n";
var color_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_VERTEXCOLOR\nv_color=COLOR_0;\n#endif\n";
var normal_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_NORMAL\n#if defined( O3_HAS_TANGENT ) && defined( O3_NORMAL_TEXTURE )\nvec3 normalW=normalize(mat3(u_normalMat)*normal.xyz);vec3 tangentW=normalize(mat3(u_normalMat)*tangent.xyz);vec3 bitangentW=cross(normalW,tangentW)*tangent.w;v_TBN=mat3(tangentW,bitangentW,normalW);\n#else\nv_normal=normalize(mat3(u_normalMat)*normal);\n#endif\n#endif\n";
var skinning_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_SKIN\n#ifdef O3_USE_JOINT_TEXTURE\nmat4 skinMatrix=WEIGHTS_0.x*getJointMatrix(u_jointSampler,JOINTS_0.x)+WEIGHTS_0.y*getJointMatrix(u_jointSampler,JOINTS_0.y)+WEIGHTS_0.z*getJointMatrix(u_jointSampler,JOINTS_0.z)+WEIGHTS_0.w*getJointMatrix(u_jointSampler,JOINTS_0.w);\n#else\nmat4 skinMatrix=WEIGHTS_0.x*u_jointMatrix[int(JOINTS_0.x)]+WEIGHTS_0.y*u_jointMatrix[int(JOINTS_0.y)]+WEIGHTS_0.z*u_jointMatrix[int(JOINTS_0.z)]+WEIGHTS_0.w*u_jointMatrix[int(JOINTS_0.w)];\n#endif\nposition=skinMatrix*position;\n#if defined(O3_HAS_NORMAL) && !defined(OMIT_NORMAL)\nnormal=vec4(skinMatrix*vec4(normal,0.0)).xyz;\n#if defined( O3_HAS_TANGENT ) && defined( O3_NORMAL_TEXTURE )\ntangent.xyz=vec4(skinMatrix*vec4(tangent.xyz,0.0)).xyz;\n#endif\n#endif\n#endif\n";
var blendShape_input = "#define GLSLIFY 1\n#ifdef OASIS_BLENDSHAPE\n#ifndef OASIS_BLENDSHAPE_TEXTURE\nattribute vec3 POSITION_BS0;attribute vec3 POSITION_BS1;attribute vec3 POSITION_BS2;attribute vec3 POSITION_BS3;\n#ifdef OASIS_BLENDSHAPE_NORMAL\nattribute vec3 NORMAL_BS0;attribute vec3 NORMAL_BS1;attribute vec3 NORMAL_BS2;attribute vec3 NORMAL_BS3;\n#endif\n#ifdef OASIS_BLENDSHAPE_TANGENT\nattribute vec3 TANGENT_BS0;attribute vec3 TANGENT_BS1;attribute vec3 TANGENT_BS2;attribute vec3 TANGENT_BS3;\n#endif\n#endif\nuniform float u_blendShapeWeights[4];\n#endif\n";
var blendShape_vert = "#define GLSLIFY 1\n#ifdef OASIS_BLENDSHAPE\n#ifdef OASIS_BLENDSHAPE_TEXTURE\n#else\nposition.xyz+=POSITION_BS0*u_blendShapeWeights[0];position.xyz+=POSITION_BS1*u_blendShapeWeights[1];position.xyz+=POSITION_BS2*u_blendShapeWeights[2];position.xyz+=POSITION_BS3*u_blendShapeWeights[3];\n#if defined( O3_HAS_NORMAL ) && defined( OASIS_BLENDSHAPE_NORMAL )\nnormal.xyz+=NORMAL_BS0*u_blendShapeWeights[0];normal.xyz+=NORMAL_BS1*u_blendShapeWeights[1];normal.xyz+=NORMAL_BS2*u_blendShapeWeights[2];normal.xyz+=NORMAL_BS3*u_blendShapeWeights[3];\n#endif\n#if defined( O3_HAS_TANGENT ) && defined( O3_NORMAL_TEXTURE ) && defined(OASIS_BLENDSHAPE_TANGENT)\ntangent.xyz+=TANGENT_BS0*u_blendShapeWeights[0];tangent.xyz+=TANGENT_BS1*u_blendShapeWeights[1];tangent.xyz+=TANGENT_BS2*u_blendShapeWeights[2];tangent.xyz+=TANGENT_BS3*u_blendShapeWeights[3];\n#endif\n#endif\n#endif\n";
var uv_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_UV\nv_uv=TEXCOORD_0;\n#else\nv_uv=vec2(0.,0.);\n#endif\n#ifdef O3_NEED_TILINGOFFSET\nv_uv=v_uv*u_tilingOffset.xy+u_tilingOffset.zw;\n#endif\n";
var worldpos_vert = "#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvec4 temp_pos=u_modelMat*position;v_pos=temp_pos.xyz/temp_pos.w;\n#endif\n";
var shadow_vert = "#define GLSLIFY 1\n#ifdef O3_GENERATE_SHADOW_MAP\ngl_Position=u_projMatFromLight*u_viewMatFromLight*u_modelMat*position;\n#endif\n#ifdef O3_SHADOW_MAP_COUNT\nfor(int i=0;i<O3_SHADOW_MAP_COUNT;i++){v_PositionFromLight[i]=u_projMatFromLight[i]*u_viewMatFromLight[i]*u_modelMat*vec4(POSITION,1.0);}\n#endif\n";
var fog_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nv_fogDepth=(u_MVMat*position).xyz;\n#endif\n";
var direct_light_frag = "#define GLSLIFY 1\n#ifdef O3_DIRECT_LIGHT_COUNT\nstruct DirectLight{vec3 color;vec3 direction;};uniform vec3 u_directLightColor[O3_DIRECT_LIGHT_COUNT];uniform vec3 u_directLightDirection[O3_DIRECT_LIGHT_COUNT];\n#endif\n";
var point_light_frag = "#define GLSLIFY 1\n#ifdef O3_POINT_LIGHT_COUNT\nstruct PointLight{vec3 color;vec3 position;float distance;};uniform vec3 u_pointLightColor[O3_POINT_LIGHT_COUNT];uniform vec3 u_pointLightPosition[O3_POINT_LIGHT_COUNT];uniform float u_pointLightDistance[O3_POINT_LIGHT_COUNT];\n#endif\n";
var spot_light_frag = "#define GLSLIFY 1\n#ifdef O3_SPOT_LIGHT_COUNT\nstruct SpotLight{vec3 color;vec3 position;vec3 direction;float distance;float angleCos;float penumbraCos;};uniform vec3 u_spotLightColor[O3_SPOT_LIGHT_COUNT];uniform vec3 u_spotLightPosition[O3_SPOT_LIGHT_COUNT];uniform vec3 u_spotLightDirection[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightDistance[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightAngleCos[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightPenumbraCos[O3_SPOT_LIGHT_COUNT];\n#endif\n";
var mobile_material_frag = "#define GLSLIFY 1\nuniform vec4 u_emissiveColor;uniform vec4 u_diffuseColor;uniform vec4 u_specularColor;uniform float u_shininess;uniform float u_normalIntensity;uniform float u_alphaCutoff;\n#ifdef O3_EMISSIVE_TEXTURE\nuniform sampler2D u_emissiveTexture;\n#endif\n#ifdef O3_DIFFUSE_TEXTURE\nuniform sampler2D u_diffuseTexture;\n#endif\n#ifdef O3_SPECULAR_TEXTURE\nuniform sampler2D u_specularTexture;\n#endif\n#ifdef O3_NORMAL_TEXTURE\nuniform sampler2D u_normalTexture;\n#endif\n";
var fog_frag = "#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nfloat fogDepth=length(v_fogDepth);\n#ifdef O3_FOG_EXP2\nfloat fogFactor=whiteCompliment(exp2(-u_fogDensity*u_fogDensity*fogDepth*fogDepth*LOG2));\n#else\nfloat fogFactor=smoothstep(u_fogNear,u_fogFar,fogDepth);\n#endif\ngl_FragColor.rgb=mix(gl_FragColor.rgb,u_fogColor,fogFactor);\n#endif\n";
var begin_mobile_frag = "#define GLSLIFY 1\nvec4 ambient=vec4(0.0);vec4 emission=u_emissiveColor;vec4 diffuse=u_diffuseColor;vec4 specular=u_specularColor;\n#ifdef O3_EMISSIVE_TEXTURE\nemission*=texture2D(u_emissiveTexture,v_uv);\n#endif\n#ifdef O3_DIFFUSE_TEXTURE\ndiffuse*=texture2D(u_diffuseTexture,v_uv);\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\ndiffuse*=v_color;\n#endif\n#ifdef O3_SPECULAR_TEXTURE\nspecular*=texture2D(u_specularTexture,v_uv);\n#endif\nambient=vec4(u_envMapLight.diffuse*u_envMapLight.diffuseIntensity,1.0)*diffuse;";
var begin_viewdir_frag = "#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvec3 V=normalize(u_cameraPos-v_pos);\n#endif\n";
var mobile_blinnphong_frag = "#define GLSLIFY 1\nvec3 N=getNormal();vec3 lightDiffuse=vec3(0.0,0.0,0.0);vec3 lightSpecular=vec3(0.0,0.0,0.0);\n#ifdef O3_DIRECT_LIGHT_COUNT\nDirectLight directionalLight;for(int i=0;i<O3_DIRECT_LIGHT_COUNT;i++){directionalLight.color=u_directLightColor[i];directionalLight.direction=u_directLightDirection[i];float d=max(dot(N,-directionalLight.direction),0.0);lightDiffuse+=directionalLight.color*d;vec3 halfDir=normalize(V-directionalLight.direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess);lightSpecular+=directionalLight.color*s;}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nPointLight pointLight;for(int i=0;i<O3_POINT_LIGHT_COUNT;i++){pointLight.color=u_pointLightColor[i];pointLight.position=u_pointLightPosition[i];pointLight.distance=u_pointLightDistance[i];vec3 direction=v_pos-pointLight.position;float dist=length(direction);direction/=dist;float decay=clamp(1.0-pow(dist/pointLight.distance,4.0),0.0,1.0);float d=max(dot(N,-direction),0.0)*decay;lightDiffuse+=pointLight.color*d;vec3 halfDir=normalize(V-direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess)*decay;lightSpecular+=pointLight.color*s;}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nSpotLight spotLight;for(int i=0;i<O3_SPOT_LIGHT_COUNT;i++){spotLight.color=u_spotLightColor[i];spotLight.position=u_spotLightPosition[i];spotLight.direction=u_spotLightDirection[i];spotLight.distance=u_spotLightDistance[i];spotLight.angleCos=u_spotLightAngleCos[i];spotLight.penumbraCos=u_spotLightPenumbraCos[i];vec3 direction=spotLight.position-v_pos;float lightDistance=length(direction);direction/=lightDistance;float angleCos=dot(direction,-spotLight.direction);float decay=clamp(1.0-pow(lightDistance/spotLight.distance,4.0),0.0,1.0);float spotEffect=smoothstep(spotLight.penumbraCos,spotLight.angleCos,angleCos);float decayTotal=decay*spotEffect;float d=max(dot(N,direction),0.0)*decayTotal;lightDiffuse+=spotLight.color*d;vec3 halfDir=normalize(V+direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess)*decayTotal;lightSpecular+=spotLight.color*s;}\n#endif\ndiffuse*=vec4(lightDiffuse,1.0);specular*=vec4(lightSpecular,1.0);\n#ifdef ALPHA_CUTOFF\nif(diffuse.a<u_alphaCutoff){discard;}\n#endif\n";
var noise_common = "#define GLSLIFY 1\nvec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec2 mod289(vec2 x){return x-floor(x*(1.0/289.0))*289.0;}float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod7(vec4 x){return x-floor(x*(1.0/7.0))*7.0;}vec3 mod7(vec3 x){return x-floor(x*(1.0/7.0))*7.0;}vec4 permute(vec4 x){return mod289((34.0*x+1.0)*x);}vec3 permute(vec3 x){return mod289((34.0*x+1.0)*x);}float permute(float x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}vec4 fade(vec4 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec2 fade(vec2 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}\n#define K 0.142857142857\n#define Ko 0.428571428571\n#define K2 0.020408163265306\n#define Kd2 0.0714285714285\n#define Kz 0.166666666667\n#define Kzo 0.416666666667\n#define jitter 1.0\n#define jitter1 0.8\n";
var noise_cellular_2D = "#define GLSLIFY 1\nvec2 cellular(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec3 oi=vec3(-1.0,0.0,1.0);vec3 of=vec3(-0.5,0.5,1.5);vec3 px=permute(Pi.x+oi);vec3 p=permute(px.x+Pi.y+oi);vec3 ox=fract(p*K)-Ko;vec3 oy=mod7(floor(p*K))*K-Ko;vec3 dx=Pf.x+0.5+jitter*ox;vec3 dy=Pf.y-of+jitter*oy;vec3 d1=dx*dx+dy*dy;p=permute(px.y+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-0.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d2=dx*dx+dy*dy;p=permute(px.z+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-1.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d3=dx*dx+dy*dy;vec3 d1a=min(d1,d2);d2=max(d1,d2);d2=min(d2,d3);d1=min(d1a,d2);d2=max(d1a,d2);d1.xy=(d1.x<d1.y)? d1.xy : d1.yx;d1.xz=(d1.x<d1.z)? d1.xz : d1.zx;d1.yz=min(d1.yz,d2.yz);d1.y=min(d1.y,d1.z);d1.y=min(d1.y,d2.x);return sqrt(d1.xy);}";
var noise_cellular_2x2 = "#define GLSLIFY 1\nvec2 cellular2x2(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec4 Pfx=Pf.x+vec4(-0.5,-1.5,-0.5,-1.5);vec4 Pfy=Pf.y+vec4(-0.5,-0.5,-1.5,-1.5);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 ox=mod7(p)*K+Kd2;vec4 oy=mod7(floor(p*K))*K+Kd2;vec4 dx=Pfx+jitter1*ox;vec4 dy=Pfy+jitter1*oy;vec4 d=dx*dx+dy*dy;d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.y=min(d.y,d.z);d.y=min(d.y,d.w);return sqrt(d.xy);}";
var noise_cellular_2x2x2 = "#define GLSLIFY 1\nvec2 cellular2x2x2(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P);vec4 Pfx=Pf.x+vec4(0.0,-1.0,0.0,-1.0);vec4 Pfy=Pf.y+vec4(0.0,0.0,-1.0,-1.0);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 p1=permute(p+Pi.z);vec4 p2=permute(p+Pi.z+vec4(1.0));vec4 ox1=fract(p1*K)-Ko;vec4 oy1=mod7(floor(p1*K))*K-Ko;vec4 oz1=floor(p1*K2)*Kz-Kzo;vec4 ox2=fract(p2*K)-Ko;vec4 oy2=mod7(floor(p2*K))*K-Ko;vec4 oz2=floor(p2*K2)*Kz-Kzo;vec4 dx1=Pfx+jitter1*ox1;vec4 dy1=Pfy+jitter1*oy1;vec4 dz1=Pf.z+jitter1*oz1;vec4 dx2=Pfx+jitter1*ox2;vec4 dy2=Pfy+jitter1*oy2;vec4 dz2=Pf.z-1.0+jitter1*oz2;vec4 d1=dx1*dx1+dy1*dy1+dz1*dz1;vec4 d2=dx2*dx2+dy2*dy2+dz2*dz2;vec4 d=min(d1,d2);d2=max(d1,d2);d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.yzw=min(d.yzw,d2.yzw);d.y=min(d.y,d.z);d.y=min(d.y,d.w);d.y=min(d.y,d2.x);return sqrt(d.xy);}";
var noise_cellular_3D = "#define GLSLIFY 1\nvec2 cellular(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P)-0.5;vec3 Pfx=Pf.x+vec3(1.0,0.0,-1.0);vec3 Pfy=Pf.y+vec3(1.0,0.0,-1.0);vec3 Pfz=Pf.z+vec3(1.0,0.0,-1.0);vec3 p=permute(Pi.x+vec3(-1.0,0.0,1.0));vec3 p1=permute(p+Pi.y-1.0);vec3 p2=permute(p+Pi.y);vec3 p3=permute(p+Pi.y+1.0);vec3 p11=permute(p1+Pi.z-1.0);vec3 p12=permute(p1+Pi.z);vec3 p13=permute(p1+Pi.z+1.0);vec3 p21=permute(p2+Pi.z-1.0);vec3 p22=permute(p2+Pi.z);vec3 p23=permute(p2+Pi.z+1.0);vec3 p31=permute(p3+Pi.z-1.0);vec3 p32=permute(p3+Pi.z);vec3 p33=permute(p3+Pi.z+1.0);vec3 ox11=fract(p11*K)-Ko;vec3 oy11=mod7(floor(p11*K))*K-Ko;vec3 oz11=floor(p11*K2)*Kz-Kzo;vec3 ox12=fract(p12*K)-Ko;vec3 oy12=mod7(floor(p12*K))*K-Ko;vec3 oz12=floor(p12*K2)*Kz-Kzo;vec3 ox13=fract(p13*K)-Ko;vec3 oy13=mod7(floor(p13*K))*K-Ko;vec3 oz13=floor(p13*K2)*Kz-Kzo;vec3 ox21=fract(p21*K)-Ko;vec3 oy21=mod7(floor(p21*K))*K-Ko;vec3 oz21=floor(p21*K2)*Kz-Kzo;vec3 ox22=fract(p22*K)-Ko;vec3 oy22=mod7(floor(p22*K))*K-Ko;vec3 oz22=floor(p22*K2)*Kz-Kzo;vec3 ox23=fract(p23*K)-Ko;vec3 oy23=mod7(floor(p23*K))*K-Ko;vec3 oz23=floor(p23*K2)*Kz-Kzo;vec3 ox31=fract(p31*K)-Ko;vec3 oy31=mod7(floor(p31*K))*K-Ko;vec3 oz31=floor(p31*K2)*Kz-Kzo;vec3 ox32=fract(p32*K)-Ko;vec3 oy32=mod7(floor(p32*K))*K-Ko;vec3 oz32=floor(p32*K2)*Kz-Kzo;vec3 ox33=fract(p33*K)-Ko;vec3 oy33=mod7(floor(p33*K))*K-Ko;vec3 oz33=floor(p33*K2)*Kz-Kzo;vec3 dx11=Pfx+jitter*ox11;vec3 dy11=Pfy.x+jitter*oy11;vec3 dz11=Pfz.x+jitter*oz11;vec3 dx12=Pfx+jitter*ox12;vec3 dy12=Pfy.x+jitter*oy12;vec3 dz12=Pfz.y+jitter*oz12;vec3 dx13=Pfx+jitter*ox13;vec3 dy13=Pfy.x+jitter*oy13;vec3 dz13=Pfz.z+jitter*oz13;vec3 dx21=Pfx+jitter*ox21;vec3 dy21=Pfy.y+jitter*oy21;vec3 dz21=Pfz.x+jitter*oz21;vec3 dx22=Pfx+jitter*ox22;vec3 dy22=Pfy.y+jitter*oy22;vec3 dz22=Pfz.y+jitter*oz22;vec3 dx23=Pfx+jitter*ox23;vec3 dy23=Pfy.y+jitter*oy23;vec3 dz23=Pfz.z+jitter*oz23;vec3 dx31=Pfx+jitter*ox31;vec3 dy31=Pfy.z+jitter*oy31;vec3 dz31=Pfz.x+jitter*oz31;vec3 dx32=Pfx+jitter*ox32;vec3 dy32=Pfy.z+jitter*oy32;vec3 dz32=Pfz.y+jitter*oz32;vec3 dx33=Pfx+jitter*ox33;vec3 dy33=Pfy.z+jitter*oy33;vec3 dz33=Pfz.z+jitter*oz33;vec3 d11=dx11*dx11+dy11*dy11+dz11*dz11;vec3 d12=dx12*dx12+dy12*dy12+dz12*dz12;vec3 d13=dx13*dx13+dy13*dy13+dz13*dz13;vec3 d21=dx21*dx21+dy21*dy21+dz21*dz21;vec3 d22=dx22*dx22+dy22*dy22+dz22*dz22;vec3 d23=dx23*dx23+dy23*dy23+dz23*dz23;vec3 d31=dx31*dx31+dy31*dy31+dz31*dz31;vec3 d32=dx32*dx32+dy32*dy32+dz32*dz32;vec3 d33=dx33*dx33+dy33*dy33+dz33*dz33;vec3 d1a=min(d11,d12);d12=max(d11,d12);d11=min(d1a,d13);d13=max(d1a,d13);d12=min(d12,d13);vec3 d2a=min(d21,d22);d22=max(d21,d22);d21=min(d2a,d23);d23=max(d2a,d23);d22=min(d22,d23);vec3 d3a=min(d31,d32);d32=max(d31,d32);d31=min(d3a,d33);d33=max(d3a,d33);d32=min(d32,d33);vec3 da=min(d11,d21);d21=max(d11,d21);d11=min(da,d31);d31=max(da,d31);d11.xy=(d11.x<d11.y)? d11.xy : d11.yx;d11.xz=(d11.x<d11.z)? d11.xz : d11.zx;d12=min(d12,d21);d12=min(d12,d22);d12=min(d12,d31);d12=min(d12,d32);d11.yz=min(d11.yz,d12.xy);d11.y=min(d11.y,d12.z);d11.y=min(d11.y,d11.z);return sqrt(d11.xy);}";
var noise_cellular = "#define GLSLIFY 1\n#include <noise_cellular_2D>\n#include <noise_cellular_3D>\n#include <noise_cellular_2x2>\n#include <noise_cellular_2x2x2>\n";
var noise_perlin_2D = "#define GLSLIFY 1\nfloat perlin(vec2 P){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}float perlin(vec2 P,vec2 rep){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod(Pi,rep.xyxy);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}";
var noise_perlin_3D = "#define GLSLIFY 1\nfloat perlin(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}float perlin(vec3 P,vec3 rep){vec3 Pi0=mod(floor(P),rep);vec3 Pi1=mod(Pi0+vec3(1.0),rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}";
var noise_perlin_4D = "#define GLSLIFY 1\nfloat perlin(vec4 P){vec4 Pi0=floor(P);vec4 Pi1=Pi0+1.0;Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}float perlin(vec4 P,vec4 rep){vec4 Pi0=mod(floor(P),rep);vec4 Pi1=mod(Pi0+1.0,rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}";
var noise_perlin = "#define GLSLIFY 1\n#include <noise_perlin_2D>\n#include <noise_perlin_3D>\n#include <noise_perlin_4D>\n";
var noise_psrd_2D = "#define GLSLIFY 1\nvec2 rgrad2(vec2 p,float rot){float u=permute(permute(p.x)+p.y)*0.0243902439+rot;u=fract(u)*6.28318530718;return vec2(cos(u),sin(u));}vec3 psrdnoise(vec2 pos,vec2 per,float rot){pos.y+=0.01;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 psdnoise(vec2 pos,vec2 per){return psrdnoise(pos,per,0.0);}float psrnoise(vec2 pos,vec2 per,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float psnoise(vec2 pos,vec2 per){return psrnoise(pos,per,0.0);}vec3 srdnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 sdnoise(vec2 pos){return srdnoise(pos,0.0);}float srnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float snoise(vec2 pos){return srnoise(pos,0.0);}";
var noise_simplex_2D = "#define GLSLIFY 1\nfloat simplex(vec2 v){const vec4 C=vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);vec2 i=floor(v+dot(v,C.yy));vec2 x0=v-i+dot(i,C.xx);vec2 i1;i1=(x0.x>x0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec4 x12=x0.xyxy+C.xxzz;x12.xy-=i1;i=mod289(i);vec3 p=permute(permute(i.y+vec3(0.0,i1.y,1.0))+i.x+vec3(0.0,i1.x,1.0));vec3 m=max(0.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.0);m=m*m;m=m*m;vec3 x=2.0*fract(p*C.www)-1.0;vec3 h=abs(x)-0.5;vec3 ox=floor(x+0.5);vec3 a0=x-ox;m*=1.79284291400159-0.85373472095314*(a0*a0+h*h);vec3 g;g.x=a0.x*x0.x+h.x*x0.y;g.yz=a0.yz*x12.xz+h.yz*x12.yw;return 130.0*dot(m,g);}";
var noise_simplex_3D_grad = "#define GLSLIFY 1\nfloat simplex(vec3 v,out vec3 gradient){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);vec4 m2=m*m;vec4 m4=m2*m2;vec4 pdotx=vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3));vec4 temp=m2*m*pdotx;gradient=-8.0*(temp.x*x0+temp.y*x1+temp.z*x2+temp.w*x3);gradient+=m4.x*p0+m4.y*p1+m4.z*p2+m4.w*p3;gradient*=42.0;return 42.0*dot(m4,pdotx);}";
var noise_simplex_3D = "#define GLSLIFY 1\nfloat simplex(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}";
var noise_simplex_4D = "#define GLSLIFY 1\nvec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}\n#define F4 0.309016994374947451\nfloat simplex(vec4 v){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v+dot(v,vec4(F4)));vec4 x0=v-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 m0=max(0.6-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.6-vec2(dot(x3,x3),dot(x4,x4)),0.0);m0=m0*m0;m1=m1*m1;return 49.0*(dot(m0*m0,vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2)))+dot(m1*m1,vec2(dot(p3,x3),dot(p4,x4))));}";
var noise_simplex = "#define GLSLIFY 1\n#include <noise_simplex_2D>\n#include <noise_simplex_3D>\n#include <noise_simplex_3D_grad>\n#include <noise_simplex_4D>\n";
var gamma_frag = "#define GLSLIFY 1\n#ifdef GAMMA\nfloat gamma=2.2;gl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(1.0/gamma));\n#endif\n";
var pbr_common_frag_define = "#define GLSLIFY 1\n#ifndef EPSILON\n#define EPSILON 1e-6\n#endif\n#ifndef RECIPROCAL_PI\n#define RECIPROCAL_PI 0.31830988618\n#endif\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n#define RE_Direct RE_Direct_Physical\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material ) GGXRoughnessToBlinnExponent( material.specularRoughness )\n";
var pbr_util_frag_define = "#define GLSLIFY 1\nvec4 SRGBtoLINEAR(vec4 srgbIn){\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\nvec3 linOut=pow(srgbIn.xyz,vec3(2.2));\n#else\nvec3 bLess=step(vec3(0.04045),srgbIn.xyz);vec3 linOut=mix(srgbIn.xyz/vec3(12.92),pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)),bLess);\n#endif\nreturn vec4(linOut,srgbIn.w);;\n#else\nreturn srgbIn;\n#endif\n}float pow2(const in float x){return x*x;}vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}vec3 BRDF_Diffuse_Lambert(const in vec3 diffuseColor){return RECIPROCAL_PI*diffuseColor;}float GGXRoughnessToBlinnExponent(const in float ggxRoughness){return(2.0/pow2(ggxRoughness+0.0001)-2.0);}float computeSpecularOcclusion(const in float dotNV,const in float ambientOcclusion,const in float roughness){return saturate(pow(dotNV+ambientOcclusion,exp2(-16.0*roughness-1.0))-1.0+ambientOcclusion);}";
var pbr_envmap_light_frag_define = "#define GLSLIFY 1\nstruct EnvMapLight{vec3 diffuse;float mipMapLevel;float diffuseIntensity;float specularIntensity;mat4 transformMatrix;};uniform EnvMapLight u_envMapLight;\n#ifdef O3_USE_SH\nuniform vec3 u_env_sh[9];\n#endif\n#ifdef O3_USE_SPECULAR_ENV\nuniform samplerCube u_env_specularSampler;\n#endif\n";
var pbr_base_frag_define = "#define GLSLIFY 1\nuniform float u_alphaCutoff;uniform vec4 u_baseColor;uniform float u_metal;uniform float u_roughness;uniform vec3 u_specularColor;uniform float u_glossinessFactor;uniform vec3 u_emissiveColor;uniform float u_normalIntensity;uniform float u_occlusionStrength;";
var pbr_texture_frag_define = "#define GLSLIFY 1\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_baseColorSampler;\n#endif\n#ifdef O3_NORMAL_TEXTURE\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_emissiveSampler;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_metallicRoughnessSampler;\n#endif\n#ifdef HAS_SPECULARGLOSSINESSMAP\nuniform sampler2D u_specularGlossinessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_occlusionSampler;\n#endif\n";
var pbr_runtime_frag_define = "#define GLSLIFY 1\nstruct IncidentLight{vec3 color;vec3 direction;};struct ReflectedLight{vec3 directDiffuse;vec3 directSpecular;vec3 indirectDiffuse;vec3 indirectSpecular;};struct GeometricContext{vec3 position;vec3 normal;vec3 viewDir;};struct PhysicalMaterial{vec3 diffuseColor;float specularRoughness;vec3 specularColor;};";
var pbr_brdf_cook_torrance_frag_define = "#define GLSLIFY 1\nvec3 F_Schlick(const in vec3 specularColor,const in float dotLH){float fresnel=exp2((-5.55473*dotLH-6.98316)*dotLH);return(1.0-specularColor)*fresnel+specularColor;}float G_GGX_SmithCorrelated(const in float alpha,const in float dotNL,const in float dotNV){float a2=pow2(alpha);float gv=dotNL*sqrt(a2+(1.0-a2)*pow2(dotNV));float gl=dotNV*sqrt(a2+(1.0-a2)*pow2(dotNL));return 0.5/max(gv+gl,EPSILON);}float D_GGX(const in float alpha,const in float dotNH){float a2=pow2(alpha);float denom=pow2(dotNH)*(a2-1.0)+1.0;return RECIPROCAL_PI*a2/pow2(denom);}vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight,const in GeometricContext geometry,const in vec3 specularColor,const in float roughness){float alpha=pow2(roughness);vec3 halfDir=normalize(incidentLight.direction+geometry.viewDir);float dotNL=saturate(dot(geometry.normal,incidentLight.direction));float dotNV=saturate(dot(geometry.normal,geometry.viewDir));float dotNH=saturate(dot(geometry.normal,halfDir));float dotLH=saturate(dot(incidentLight.direction,halfDir));vec3 F=F_Schlick(specularColor,dotLH);float G=G_GGX_SmithCorrelated(alpha,dotNL,dotNV);float D=D_GGX(alpha,dotNH);return F*(G*D);}";
var pbr_direct_irradiance_frag_define = "#define GLSLIFY 1\nvoid RE_Direct_Physical(const in IncidentLight directLight,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){float dotNL=saturate(dot(geometry.normal,directLight.direction));vec3 irradiance=dotNL*directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance*=PI;\n#endif\nreflectedLight.directSpecular+=irradiance*BRDF_Specular_GGX(directLight,geometry,material.specularColor,material.specularRoughness);reflectedLight.directDiffuse+=irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);}\n#ifdef O3_DIRECT_LIGHT_COUNT\nvoid getDirectionalDirectLightIrradiance(const in DirectLight directionalLight,const in GeometricContext geometry,out IncidentLight directLight){directLight.color=directionalLight.color;directLight.direction=-directionalLight.direction;}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nvoid getPointDirectLightIrradiance(const in PointLight pointLight,const in GeometricContext geometry,out IncidentLight directLight){vec3 lVector=pointLight.position-geometry.position;directLight.direction=normalize(lVector);float lightDistance=length(lVector);directLight.color=pointLight.color;directLight.color*=clamp(1.0-pow(lightDistance/pointLight.distance,4.0),0.0,1.0);}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nvoid getSpotDirectLightIrradiance(const in SpotLight spotLight,const in GeometricContext geometry,out IncidentLight directLight){vec3 lVector=spotLight.position-geometry.position;directLight.direction=normalize(lVector);float lightDistance=length(lVector);float angleCos=dot(directLight.direction,-spotLight.direction);float spotEffect=smoothstep(spotLight.penumbraCos,spotLight.angleCos,angleCos);float decayEffect=clamp(1.0-pow(lightDistance/spotLight.distance,4.0),0.0,1.0);directLight.color=spotLight.color;directLight.color*=spotEffect*decayEffect;}\n#endif\n";
var pbr_ibl_specular_frag_define = "#define GLSLIFY 1\nvec3 BRDF_Specular_GGX_Environment(const in GeometricContext geometry,const in vec3 specularColor,const in float roughness){float dotNV=saturate(dot(geometry.normal,geometry.viewDir));const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}float getSpecularMIPLevel(const in float blinnShininessExponent,const in int maxMIPLevel){float maxMIPLevelScalar=float(maxMIPLevel);float desiredMIPLevel=maxMIPLevelScalar+0.79248-0.5*log2(pow2(blinnShininessExponent)+1.0);return clamp(desiredMIPLevel,0.0,maxMIPLevelScalar);}vec3 getLightProbeIndirectRadiance(const in GeometricContext geometry,const in float blinnShininessExponent,const in int maxMIPLevel){\n#ifndef O3_USE_SPECULAR_ENV\nreturn vec3(0.0);\n#else\nvec3 reflectVec=reflect(-geometry.viewDir,geometry.normal);float specularMIPLevel=getSpecularMIPLevel(blinnShininessExponent,maxMIPLevel);\n#ifdef HAS_TEX_LOD\nvec4 envMapColor=textureCubeLodEXT(u_env_specularSampler,reflectVec,specularMIPLevel);\n#else\nvec4 envMapColor=textureCube(u_env_specularSampler,reflectVec,specularMIPLevel);\n#endif\nenvMapColor.rgb=SRGBtoLINEAR(envMapColor*u_envMapLight.specularIntensity).rgb;return envMapColor.rgb;\n#endif\n}void RE_IndirectSpecular_Physical(const in vec3 radiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){float dotNV=saturate(dot(geometry.normal,geometry.viewDir));float dotNL=dotNV;reflectedLight.indirectSpecular+=radiance*BRDF_Specular_GGX_Environment(geometry,material.specularColor,material.specularRoughness);}";
var pbr_ibl_diffuse_frag_define = "#define GLSLIFY 1\nvoid RE_IndirectDiffuse_Physical(const in vec3 irradiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){reflectedLight.indirectDiffuse+=irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);}vec3 getLightProbeIrradiance(vec3 sh[9],vec3 normal){vec3 result=sh[0]+sh[1]*(normal.y)+sh[2]*(normal.z)+sh[3]*(normal.x)+sh[4]*(normal.y*normal.x)+sh[5]*(normal.y*normal.z)+sh[6]*(3.0*normal.z*normal.z-1.0)+sh[7]*(normal.z*normal.x)+sh[8]*(normal.x*normal.x-normal.y*normal.y);return max(result,vec3(0.0));}";
var pbr_begin_frag = "#define GLSLIFY 1\nvec3 normal=getNormal();vec4 diffuseColor=u_baseColor;vec3 totalEmissiveRadiance=u_emissiveColor;float metalnessFactor=u_metal;float roughnessFactor=u_roughness;vec3 specularFactor=u_specularColor;float glossinessFactor=u_glossinessFactor;ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));PhysicalMaterial material;GeometricContext geometry;IncidentLight directLight;\n#ifdef HAS_BASECOLORMAP\nvec4 baseMapColor=texture2D(u_baseColorSampler,v_uv);baseMapColor=SRGBtoLINEAR(baseMapColor);diffuseColor*=baseMapColor;\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\ndiffuseColor*=v_color;\n#endif\n#ifdef ALPHA_CUTOFF\nif(diffuseColor.a<u_alphaCutoff){discard;}\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nvec4 metalRoughMapColor=texture2D(u_metallicRoughnessSampler,v_uv);roughnessFactor*=metalRoughMapColor.g;metalnessFactor*=metalRoughMapColor.b;\n#endif\n#ifdef HAS_SPECULARGLOSSINESSMAP\nvec4 specularGlossinessColor=texture2D(u_specularGlossinessSampler,v_uv);specularFactor*=specularGlossinessColor.rgb;glossinessFactor*=specularGlossinessColor.a;\n#endif\n#ifdef IS_METALLIC_WORKFLOW\nmaterial.diffuseColor=diffuseColor.rgb*(1.0-metalnessFactor);material.specularRoughness=clamp(roughnessFactor,0.04,1.0);material.specularColor=mix(vec3(MAXIMUM_SPECULAR_COEFFICIENT),diffuseColor.rgb,metalnessFactor);\n#else\nfloat specularStrength=max(max(specularFactor.r,specularFactor.g),specularFactor.b);material.diffuseColor=diffuseColor.rgb*(1.0-specularStrength);material.specularRoughness=clamp(1.0-glossinessFactor,0.04,1.0);material.specularColor=specularFactor;\n#endif\ngeometry.position=v_pos;geometry.normal=normal;geometry.viewDir=normalize(u_cameraPos-v_pos);";
var pbr_direct_irradiance_frag = "#define GLSLIFY 1\n#if defined( O3_DIRECT_LIGHT_COUNT ) && defined( RE_Direct )\nDirectLight directionalLight;for(int i=0;i<O3_DIRECT_LIGHT_COUNT;i++){directionalLight.color=u_directLightColor[i];directionalLight.direction=u_directLightDirection[i];getDirectionalDirectLightIrradiance(directionalLight,geometry,directLight);RE_Direct(directLight,geometry,material,reflectedLight);}\n#endif\n#if defined( O3_POINT_LIGHT_COUNT ) && defined( RE_Direct )\nPointLight pointLight;for(int i=0;i<O3_POINT_LIGHT_COUNT;i++){pointLight.color=u_pointLightColor[i];pointLight.position=u_pointLightPosition[i];pointLight.distance=u_pointLightDistance[i];getPointDirectLightIrradiance(pointLight,geometry,directLight);RE_Direct(directLight,geometry,material,reflectedLight);}\n#endif\n#if defined( O3_SPOT_LIGHT_COUNT ) && defined( RE_Direct )\nSpotLight spotLight;for(int i=0;i<O3_SPOT_LIGHT_COUNT;i++){spotLight.color=u_spotLightColor[i];spotLight.position=u_spotLightPosition[i];spotLight.direction=u_spotLightDirection[i];spotLight.distance=u_spotLightDistance[i];spotLight.angleCos=u_spotLightAngleCos[i];spotLight.penumbraCos=u_spotLightPenumbraCos[i];getSpotDirectLightIrradiance(spotLight,geometry,directLight);RE_Direct(directLight,geometry,material,reflectedLight);}\n#endif\n";
var pbr_ibl_diffuse_frag = "#define GLSLIFY 1\n#ifdef O3_USE_SH\nvec3 irradiance=getLightProbeIrradiance(u_env_sh,normal)*u_envMapLight.diffuseIntensity;\n#else\nvec3 irradiance=u_envMapLight.diffuse*u_envMapLight.diffuseIntensity;\n#endif\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance*=PI;\n#endif\nRE_IndirectDiffuse_Physical(irradiance,geometry,material,reflectedLight);";
var pbr_ibl_specular_frag = "#define GLSLIFY 1\n#if defined( RE_IndirectSpecular )\nvec3 radiance=vec3(0.0);\n#endif\n#if defined( RE_IndirectSpecular )\nradiance+=getLightProbeIndirectRadiance(geometry,Material_BlinnShininessExponent(material),int(u_envMapLight.mipMapLevel));\n#endif\n#if defined( RE_IndirectSpecular )\nRE_IndirectSpecular(radiance,geometry,material,reflectedLight);\n#endif\n";
var pbr_end_frag = "#define GLSLIFY 1\n#ifdef HAS_OCCLUSIONMAP\nfloat ambientOcclusion=(texture2D(u_occlusionSampler,v_uv).r-1.0)*u_occlusionStrength+1.0;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined(O3_USE_SPECULAR_ENV)\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.specularRoughness);\n#endif\n#endif\n#ifdef HAS_EMISSIVEMAP\nvec4 emissiveMapColor=texture2D(u_emissiveSampler,v_uv);emissiveMapColor=SRGBtoLINEAR(emissiveMapColor);totalEmissiveRadiance*=emissiveMapColor.rgb;\n#endif\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+totalEmissiveRadiance;gl_FragColor=vec4(outgoingLight,diffuseColor.a);";
var PBRShaderLib = {
  pbr_common_frag_define,
  pbr_util_frag_define,
  pbr_envmap_light_frag_define,
  pbr_base_frag_define,
  pbr_texture_frag_define,
  pbr_runtime_frag_define,
  pbr_brdf_cook_torrance_frag_define,
  pbr_direct_irradiance_frag_define,
  pbr_ibl_specular_frag_define,
  pbr_ibl_diffuse_frag_define,
  pbr_begin_frag,
  pbr_direct_irradiance_frag,
  pbr_ibl_diffuse_frag,
  pbr_ibl_specular_frag,
  pbr_end_frag
};
var normal_get = "#define GLSLIFY 1\nvec3 getNormal(){\n#ifdef O3_NORMAL_TEXTURE\n#ifndef O3_HAS_TANGENT\n#ifdef HAS_DERIVATIVES\nvec3 pos_dx=dFdx(v_pos);vec3 pos_dy=dFdy(v_pos);vec3 tex_dx=dFdx(vec3(v_uv,0.0));vec3 tex_dy=dFdy(vec3(v_uv,0.0));vec3 t=(tex_dy.t*pos_dx-tex_dx.t*pos_dy)/(tex_dx.s*tex_dy.t-tex_dy.s*tex_dx.t);\n#ifdef O3_HAS_NORMAL\nvec3 ng=normalize(v_normal);\n#else\nvec3 ng=normalize(cross(pos_dx,pos_dy));\n#endif\nt=normalize(t-ng*dot(ng,t));vec3 b=normalize(cross(ng,t));mat3 tbn=mat3(t,b,ng);\n#else\n#ifdef O3_HAS_NORMAL\nvec3 ng=normalize(v_normal);\n#else\nvec3 ng=vec3(0.0,0.0,1.0);\n#endif\nmat3 tbn=mat3(vec3(0.0),vec3(0.0),ng);\n#endif\n#else\nmat3 tbn=v_TBN;\n#endif\nvec3 n=texture2D(u_normalTexture,v_uv).rgb;n=normalize(tbn*((2.0*n-1.0)*vec3(u_normalIntensity,u_normalIntensity,1.0)));\n#else\n#ifdef O3_HAS_NORMAL\nvec3 n=normalize(v_normal);\n#elif defined(HAS_DERIVATIVES)\nvec3 pos_dx=dFdx(v_pos);vec3 pos_dy=dFdy(v_pos);vec3 n=normalize(cross(pos_dx,pos_dy));\n#else\nvec3 n=vec3(0.0,0.0,1.0);\n#endif\n#endif\nn*=float(gl_FrontFacing)*2.0-1.0;return n;}";
var ShaderLib = _objectSpread2(_objectSpread2({
  common,
  common_vert,
  common_frag,
  color_share,
  normal_share,
  uv_share,
  worldpos_share,
  shadow_share,
  fog_share,
  begin_normal_vert,
  begin_position_vert,
  position_vert,
  color_vert,
  normal_vert,
  skinning_vert,
  blendShape_input,
  blendShape_vert,
  uv_vert,
  worldpos_vert,
  shadow_vert,
  fog_vert,
  direct_light_frag,
  point_light_frag,
  spot_light_frag,
  mobile_material_frag,
  fog_frag,
  begin_mobile_frag,
  begin_viewdir_frag,
  mobile_blinnphong_frag,
  noise_common,
  noise_cellular_2D,
  noise_cellular_2x2,
  noise_cellular_2x2x2,
  noise_cellular_3D,
  noise_cellular,
  noise_perlin_2D,
  noise_perlin_3D,
  noise_perlin_4D,
  noise_perlin,
  noise_psrd_2D,
  noise_simplex_2D,
  noise_simplex_3D_grad,
  noise_simplex_3D,
  noise_simplex_4D,
  noise_simplex,
  gamma_frag
}, PBRShaderLib), {}, {
  normal_get
});
var ShaderFactory = function() {
  function ShaderFactory2() {
  }
  ShaderFactory2.parseCustomMacros = function parseCustomMacros(macros) {
    return macros.map(function(m) {
      return "#define " + m + "\n";
    }).join("");
  };
  ShaderFactory2.parseIncludes = function parseIncludes(src) {
    var regex = /^[ \t]*#include +<([\w\d.]+)>/gm;
    function replace(match, slice) {
      var replace2 = ShaderLib[slice];
      if (replace2 === void 0) {
        Logger.error('Shader slice "' + match.trim() + '" not founded.');
        return "";
      }
      return ShaderFactory2.parseIncludes(replace2);
    }
    return src.replace(regex, replace);
  };
  ShaderFactory2.parseExtension = function parseExtension(extensions) {
    return extensions.map(function(e) {
      return "#extension " + e + " : enable\n";
    }).join("");
  };
  ShaderFactory2.convertTo300 = function convertTo300(shader, isFrag) {
    shader = shader.replace(/\battribute\b/g, "in");
    shader = shader.replace(/\bvarying\b/g, isFrag ? "in" : "out");
    shader = shader.replace(/\btexture(2D|Cube)\b/g, "texture");
    shader = shader.replace(/\btexture(2D|Cube)LodEXT\b/g, "textureLod");
    if (isFrag) {
      var isMRT = /\bgl_FragData\[.+?\]/g.test(shader);
      if (isMRT) {
        shader = shader.replace(/\bgl_FragColor\b/g, "gl_FragData[0]");
        var result = shader.match(/\bgl_FragData\[.+?\]/g);
        shader = this._replaceMRTShader(shader, result);
      } else {
        shader = shader.replace(/void\s+?main\s*\(/g, "out vec4 glFragColor;\nvoid main(");
        shader = shader.replace(/\bgl_FragColor\b/g, "glFragColor");
      }
    }
    return shader;
  };
  ShaderFactory2._replaceMRTShader = function _replaceMRTShader(shader, result) {
    var declaration = "";
    var mrtIndexSet = new Set();
    for (var i = 0; i < result.length; i++) {
      var res = result[i].match(/\bgl_FragData\[(.+?)\]/);
      mrtIndexSet.add(res[1]);
    }
    mrtIndexSet.forEach(function(index) {
      declaration += "layout(location=" + index + ") out vec4 fragOutColor" + index + ";\n";
    });
    declaration += "void main(";
    shader = shader.replace(/\bgl_FragData\[(.+?)\]/g, "fragOutColor$1");
    shader = shader.replace(/void\s+?main\s*\(/g, declaration);
    return shader;
  };
  return ShaderFactory2;
}();
var ShaderMacro = function ShaderMacro2(name, index, value) {
  this.name = void 0;
  this._index = void 0;
  this._value = void 0;
  this.name = name;
  this._index = index;
  this._value = value;
};
var ShaderUniform = function() {
  function ShaderUniform2(engine) {
    this.name = void 0;
    this.propertyId = void 0;
    this.location = void 0;
    this.applyFunc = void 0;
    this.cacheValue = void 0;
    this.textureIndex = void 0;
    this.textureDefault = void 0;
    this._rhi = void 0;
    this._gl = void 0;
    var rhi = engine._hardwareRenderer;
    this._rhi = rhi;
    this._gl = rhi.gl;
  }
  var _proto = ShaderUniform2.prototype;
  _proto.upload1f = function upload1f(shaderUniform, value) {
    if (this.cacheValue !== value) {
      this._gl.uniform1f(shaderUniform.location, value);
      this.cacheValue = value;
    }
  };
  _proto.upload1fv = function upload1fv(shaderUniform, value) {
    this._gl.uniform1fv(shaderUniform.location, value);
  };
  _proto.upload2f = function upload2f(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g) {
        this._gl.uniform2f(shaderUniform.location, value.r, value.g);
        cacheValue.x = value.r;
        cacheValue.y = value.g;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y) {
        this._gl.uniform2f(shaderUniform.location, value.x, value.y);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
      }
    }
  };
  _proto.upload2fv = function upload2fv(shaderUniform, value) {
    this._gl.uniform2fv(shaderUniform.location, value);
  };
  _proto.upload3f = function upload3f(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b) {
        this._gl.uniform3f(shaderUniform.location, value.r, value.g, value.b);
        cacheValue.x = value.r;
        cacheValue.y = value.g;
        cacheValue.z = value.b;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z) {
        this._gl.uniform3f(shaderUniform.location, value.x, value.y, value.z);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
        cacheValue.z = value.z;
      }
    }
  };
  _proto.upload3fv = function upload3fv(shaderUniform, value) {
    this._gl.uniform3fv(shaderUniform.location, value);
  };
  _proto.upload4f = function upload4f(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b || cacheValue.w !== value.a) {
        this._gl.uniform4f(shaderUniform.location, value.r, value.g, value.b, value.a);
        cacheValue.x = value.r;
        cacheValue.y = value.g;
        cacheValue.z = value.b;
        cacheValue.w = value.a;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z || cacheValue.w !== value.w) {
        this._gl.uniform4f(shaderUniform.location, value.x, value.y, value.z, value.w);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
        cacheValue.z = value.z;
        cacheValue.w = value.w;
      }
    }
  };
  _proto.upload4fv = function upload4fv(shaderUniform, value) {
    this._gl.uniform4fv(shaderUniform.location, value);
  };
  _proto.upload1i = function upload1i(shaderUniform, value) {
    if (this.cacheValue !== value) {
      this._gl.uniform1i(shaderUniform.location, value);
      this.cacheValue = value;
    }
  };
  _proto.upload1iv = function upload1iv(shaderUniform, value) {
    this._gl.uniform1iv(shaderUniform.location, value);
  };
  _proto.upload2i = function upload2i(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g) {
        this._gl.uniform2i(shaderUniform.location, value.r, value.g);
        cacheValue.x = value.r;
        cacheValue.y = value.g;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y) {
        this._gl.uniform2i(shaderUniform.location, value.x, value.y);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
      }
    }
  };
  _proto.upload2iv = function upload2iv(shaderUniform, value) {
    this._gl.uniform2iv(shaderUniform.location, value);
  };
  _proto.upload3i = function upload3i(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b) {
        this._gl.uniform3i(shaderUniform.location, value.r, value.g, value.b);
        cacheValue.x = value.r;
        cacheValue.y = value.g;
        cacheValue.z = value.b;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z) {
        this._gl.uniform3i(shaderUniform.location, value.x, value.y, value.z);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
        cacheValue.z = value.z;
      }
    }
  };
  _proto.upload3iv = function upload3iv(shaderUniform, value) {
    this._gl.uniform3iv(shaderUniform.location, value);
  };
  _proto.upload4i = function upload4i(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b || cacheValue.w !== value.a) {
        this._gl.uniform4i(shaderUniform.location, value.r, value.g, value.b, value.a);
        cacheValue.x = value.r;
        cacheValue.y = value.g;
        cacheValue.z = value.b;
        cacheValue.w = value.a;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z || cacheValue.w !== value.w) {
        this._gl.uniform4i(shaderUniform.location, value.x, value.y, value.z, value.w);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
        cacheValue.z = value.z;
        cacheValue.w = value.w;
      }
    }
  };
  _proto.upload4iv = function upload4iv(shaderUniform, value) {
    this._gl.uniform4iv(shaderUniform.location, value);
  };
  _proto.uploadMat4 = function uploadMat4(shaderUniform, value) {
    this._gl.uniformMatrix4fv(shaderUniform.location, false, value.elements);
  };
  _proto.uploadMat4v = function uploadMat4v(shaderUniform, value) {
    this._gl.uniformMatrix4fv(shaderUniform.location, false, value);
  };
  _proto.uploadTexture = function uploadTexture(shaderUniform, value) {
    var rhi = this._rhi;
    rhi.activeTexture(shaderUniform.textureIndex);
    rhi.bindTexture(value._platformTexture);
  };
  _proto.uploadTextureArray = function uploadTextureArray(shaderUniform, value) {
    var rhi = this._rhi;
    var textureIndices = shaderUniform.textureIndex;
    for (var i = 0; i < value.length; i++) {
      var texture = value[i];
      rhi.activeTexture(textureIndices[i]);
      rhi.bindTexture(texture._platformTexture);
    }
  };
  return ShaderUniform2;
}();
var ShaderUniformBlock = function ShaderUniformBlock2() {
  this.constUniforms = [];
  this.textureUniforms = [];
};
var ShaderProgram = function() {
  ShaderProgram2._addLineNum = function _addLineNum(str) {
    var lines = str.split("\n");
    var limitLength = (lines.length + 1).toString().length + 6;
    var prefix;
    return lines.map(function(line, index) {
      prefix = "0:" + (index + 1);
      if (prefix.length >= limitLength)
        return prefix.substring(0, limitLength) + line;
      for (var i = 0; i < limitLength - prefix.length; i++) {
        prefix += " ";
      }
      return prefix + line;
    }).join("\n");
  };
  function ShaderProgram2(engine, vertexSource, fragmentSource) {
    this.id = void 0;
    this.sceneUniformBlock = new ShaderUniformBlock();
    this.cameraUniformBlock = new ShaderUniformBlock();
    this.rendererUniformBlock = new ShaderUniformBlock();
    this.materialUniformBlock = new ShaderUniformBlock();
    this.otherUniformBlock = new ShaderUniformBlock();
    this._uploadRenderCount = -1;
    this._uploadCamera = void 0;
    this._uploadRenderer = void 0;
    this._uploadMaterial = void 0;
    this.attributeLocation = Object.create(null);
    this._isValid = void 0;
    this._engine = void 0;
    this._gl = void 0;
    this._vertexShader = void 0;
    this._fragmentShader = void 0;
    this._glProgram = void 0;
    this._activeTextureUint = 0;
    this._engine = engine;
    this._gl = engine._hardwareRenderer.gl;
    this._glProgram = this._createProgram(vertexSource, fragmentSource);
    if (this._glProgram) {
      this._isValid = true;
      this._recordLocation();
    } else {
      this._isValid = false;
    }
    this.id = ShaderProgram2._counter++;
  }
  var _proto = ShaderProgram2.prototype;
  _proto.uploadAll = function uploadAll(uniformBlock, shaderData) {
    this.uploadUniforms(uniformBlock, shaderData);
    this.uploadTextures(uniformBlock, shaderData);
  };
  _proto.uploadUniforms = function uploadUniforms(uniformBlock, shaderData) {
    var properties = shaderData._properties;
    var constUniforms = uniformBlock.constUniforms;
    for (var i = 0, n = constUniforms.length; i < n; i++) {
      var uniform = constUniforms[i];
      var data = properties[uniform.propertyId];
      data != null && uniform.applyFunc(uniform, data);
    }
  };
  _proto.uploadTextures = function uploadTextures(uniformBlock, shaderData) {
    var properties = shaderData._properties;
    var textureUniforms = uniformBlock.textureUniforms;
    if (textureUniforms) {
      for (var i = 0, n = textureUniforms.length; i < n; i++) {
        var uniform = textureUniforms[i];
        var texture = properties[uniform.propertyId];
        if (texture) {
          uniform.applyFunc(uniform, texture);
        } else {
          uniform.applyFunc(uniform, uniform.textureDefault);
        }
      }
    }
  };
  _proto.uploadUngroupTextures = function uploadUngroupTextures() {
    var textureUniforms = this.otherUniformBlock.textureUniforms;
    if (textureUniforms) {
      for (var i = 0, n = textureUniforms.length; i < n; i++) {
        var uniform = textureUniforms[i];
        uniform.applyFunc(uniform, uniform.textureDefault);
      }
    }
  };
  _proto.groupingOtherUniformBlock = function groupingOtherUniformBlock() {
    var _this$otherUniformBlo = this.otherUniformBlock, constUniforms = _this$otherUniformBlo.constUniforms, textureUniforms = _this$otherUniformBlo.textureUniforms;
    constUniforms.length > 0 && this._groupingSubOtherUniforms(constUniforms, false);
    textureUniforms.length > 0 && this._groupingSubOtherUniforms(textureUniforms, true);
  };
  _proto.bind = function bind() {
    var rhi = this._engine._hardwareRenderer;
    if (rhi._currentBind !== this) {
      this._gl.useProgram(this._glProgram);
      rhi._currentBind = this;
      return true;
    } else {
      return false;
    }
  };
  _proto.destroy = function destroy() {
    var gl = this._gl;
    this._vertexShader && gl.deleteShader(this._vertexShader);
    this._fragmentShader && gl.deleteShader(this._fragmentShader);
    this._glProgram && gl.deleteProgram(this._glProgram);
  };
  _proto._groupingSubOtherUniforms = function _groupingSubOtherUniforms(uniforms, isTexture) {
    for (var i = uniforms.length - 1; i >= 0; i--) {
      var uniform = uniforms[i];
      var group = Shader._getShaderPropertyGroup(uniform.name);
      if (group !== void 0) {
        uniforms.splice(uniforms.indexOf(uniform), 1);
        this._groupingUniform(uniform, group, isTexture);
      }
    }
  };
  _proto._groupingUniform = function _groupingUniform(uniform, group, isTexture) {
    switch (group) {
      case ShaderDataGroup.Scene:
        if (isTexture) {
          this.sceneUniformBlock.textureUniforms.push(uniform);
        } else {
          this.sceneUniformBlock.constUniforms.push(uniform);
        }
        break;
      case ShaderDataGroup.Camera:
        if (isTexture) {
          this.cameraUniformBlock.textureUniforms.push(uniform);
        } else {
          this.cameraUniformBlock.constUniforms.push(uniform);
        }
        break;
      case ShaderDataGroup.Renderer:
        if (isTexture) {
          this.rendererUniformBlock.textureUniforms.push(uniform);
        } else {
          this.rendererUniformBlock.constUniforms.push(uniform);
        }
        break;
      case ShaderDataGroup.Material:
        if (isTexture) {
          this.materialUniformBlock.textureUniforms.push(uniform);
        } else {
          this.materialUniformBlock.constUniforms.push(uniform);
        }
        break;
      default:
        if (isTexture) {
          this.otherUniformBlock.textureUniforms.push(uniform);
        } else {
          this.otherUniformBlock.constUniforms.push(uniform);
        }
    }
  };
  _proto._createProgram = function _createProgram(vertexSource, fragmentSource) {
    var gl = this._gl;
    var vertexShader = this._createShader(gl.VERTEX_SHADER, vertexSource);
    if (!vertexShader) {
      return null;
    }
    var fragmentShader = this._createShader(gl.FRAGMENT_SHADER, fragmentSource);
    if (!fragmentShader) {
      return null;
    }
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.validateProgram(program);
    if (gl.isContextLost()) {
      Logger.error("Context lost while linking program.");
      gl.deleteShader(vertexShader);
      gl.deleteShader(fragmentShader);
      return null;
    }
    if (Logger.isEnabled && !gl.getProgramParameter(program, gl.LINK_STATUS)) {
      Logger.error("Could not link WebGL program. \n" + gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      return null;
    }
    this._vertexShader = vertexShader;
    this._fragmentShader = fragmentShader;
    return program;
  };
  _proto._createShader = function _createShader(shaderType, shaderSource) {
    var gl = this._gl;
    var shader = gl.createShader(shaderType);
    if (!shader) {
      Logger.error("Context lost while create shader.");
      return null;
    }
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);
    if (gl.isContextLost()) {
      Logger.error("Context lost while compiling shader.");
      gl.deleteShader(shader);
      return null;
    }
    if (Logger.isEnabled && !gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      Logger.error("Could not compile WebGL shader.\n" + gl.getShaderInfoLog(shader), ShaderProgram2._addLineNum(shaderSource));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  };
  _proto._recordLocation = function _recordLocation() {
    var _this = this;
    var gl = this._gl;
    var program = this._glProgram;
    var uniformInfos = this._getUniformInfos();
    var attributeInfos = this._getAttributeInfos();
    uniformInfos.forEach(function(_ref) {
      var name = _ref.name, size = _ref.size, type = _ref.type;
      var shaderUniform = new ShaderUniform(_this._engine);
      var isArray = false;
      var isTexture = false;
      if (name.indexOf("[0]") > 0) {
        name = name.substr(0, name.length - 3);
        isArray = true;
      }
      var group = Shader._getShaderPropertyGroup(name);
      var location = gl.getUniformLocation(program, name);
      shaderUniform.name = name;
      shaderUniform.propertyId = Shader.getPropertyByName(name)._uniqueId;
      shaderUniform.location = location;
      switch (type) {
        case gl.FLOAT:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload1fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload1f;
            shaderUniform.cacheValue = 0;
          }
          break;
        case gl.FLOAT_VEC2:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload2fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload2f;
            shaderUniform.cacheValue = new Vector2(0, 0);
          }
          break;
        case gl.FLOAT_VEC3:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload3fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload3f;
            shaderUniform.cacheValue = new Vector3(0, 0, 0);
          }
          break;
        case gl.FLOAT_VEC4:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload4fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload4f;
            shaderUniform.cacheValue = new Vector4(0, 0, 0, 0);
          }
          break;
        case gl.BOOL:
        case gl.INT:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload1iv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload1i;
            shaderUniform.cacheValue = 0;
          }
          break;
        case gl.BOOL_VEC2:
        case gl.INT_VEC2:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload2iv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload2i;
            shaderUniform.cacheValue = new Vector2(0, 0);
          }
          break;
        case gl.BOOL_VEC3:
        case gl.INT_VEC3:
          shaderUniform.applyFunc = isArray ? shaderUniform.upload3iv : shaderUniform.upload3i;
          shaderUniform.cacheValue = new Vector3(0, 0, 0);
          break;
        case gl.BOOL_VEC4:
        case gl.INT_VEC4:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload4iv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload4i;
            shaderUniform.cacheValue = new Vector4(0, 0, 0);
          }
          break;
        case gl.FLOAT_MAT4:
          shaderUniform.applyFunc = isArray ? shaderUniform.uploadMat4v : shaderUniform.uploadMat4;
          break;
        case gl.SAMPLER_2D:
        case gl.SAMPLER_CUBE:
          var defaultTexture = type === gl.SAMPLER_2D ? _this._engine._whiteTexture2D : _this._engine._whiteTextureCube;
          isTexture = true;
          if (isArray) {
            var defaultTextures = new Array(size);
            var textureIndices = new Int32Array(size);
            var glTextureIndices = new Array(size);
            for (var i = 0; i < size; i++) {
              defaultTextures[i] = defaultTexture;
              textureIndices[i] = _this._activeTextureUint;
              glTextureIndices[i] = gl.TEXTURE0 + _this._activeTextureUint++;
            }
            shaderUniform.textureDefault = defaultTextures;
            shaderUniform.textureIndex = glTextureIndices;
            shaderUniform.applyFunc = shaderUniform.uploadTextureArray;
            _this.bind();
            gl.uniform1iv(location, textureIndices);
            shaderUniform.uploadTextureArray(shaderUniform, defaultTextures);
          } else {
            var textureIndex = gl.TEXTURE0 + _this._activeTextureUint;
            shaderUniform.textureDefault = defaultTexture;
            shaderUniform.textureIndex = textureIndex;
            shaderUniform.applyFunc = shaderUniform.uploadTexture;
            _this.bind();
            gl.uniform1i(location, _this._activeTextureUint++);
            shaderUniform.uploadTexture(shaderUniform, defaultTexture);
          }
          break;
      }
      _this._groupingUniform(shaderUniform, group, isTexture);
    });
    attributeInfos.forEach(function(_ref2) {
      var name = _ref2.name;
      _this.attributeLocation[name] = gl.getAttribLocation(program, name);
    });
  };
  _proto._getUniformInfos = function _getUniformInfos() {
    var gl = this._gl;
    var program = this._glProgram;
    var uniformInfos = [];
    var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (var i = 0; i < uniformCount; ++i) {
      var info2 = gl.getActiveUniform(program, i);
      uniformInfos[i] = info2;
    }
    return uniformInfos;
  };
  _proto._getAttributeInfos = function _getAttributeInfos() {
    var gl = this._gl;
    var program = this._glProgram;
    var attributeInfos = [];
    var attributeCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (var i = 0; i < attributeCount; ++i) {
      var info2 = gl.getActiveAttrib(program, i);
      attributeInfos[i] = info2;
    }
    return attributeInfos;
  };
  _createClass(ShaderProgram2, [{
    key: "isValid",
    get: function get4() {
      return this._isValid;
    }
  }]);
  return ShaderProgram2;
}();
ShaderProgram._counter = 0;
var ShaderProperty = function ShaderProperty2(name) {
  this._uniqueId = void 0;
  this._group = void 0;
  this.name = void 0;
  this.name = name;
  this._uniqueId = ShaderProperty2._propertyNameCounter++;
};
ShaderProperty._propertyNameCounter = 0;
var Shader = function() {
  Shader2.create = function create(name, vertexSource, fragmentSource) {
    var shaderMap = Shader2._shaderMap;
    if (shaderMap[name]) {
      throw 'Shader named "' + name + '" already exists.';
    }
    return shaderMap[name] = new Shader2(name, vertexSource, fragmentSource);
  };
  Shader2.find = function find(name) {
    return Shader2._shaderMap[name];
  };
  Shader2.getMacroByName = function getMacroByName(name) {
    var macro = Shader2._macroMap[name];
    if (!macro) {
      var maskMap = Shader2._macroMaskMap;
      var counter = Shader2._macroCounter;
      var index = Math.floor(counter / 32);
      var bit = counter % 32;
      macro = new ShaderMacro(name, index, 1 << bit);
      Shader2._macroMap[name] = macro;
      if (index == maskMap.length) {
        maskMap.length++;
        maskMap[index] = new Array(32);
      }
      maskMap[index][bit] = name;
      Shader2._macroCounter++;
    }
    return macro;
  };
  Shader2.getPropertyByName = function getPropertyByName(name) {
    var propertyNameMap = Shader2._propertyNameMap;
    if (propertyNameMap[name] != null) {
      return propertyNameMap[name];
    } else {
      var property = new ShaderProperty(name);
      propertyNameMap[name] = property;
      return property;
    }
  };
  Shader2._getShaderPropertyGroup = function _getShaderPropertyGroup(propertyName) {
    var shaderProperty = Shader2._propertyNameMap[propertyName];
    return shaderProperty === null || shaderProperty === void 0 ? void 0 : shaderProperty._group;
  };
  Shader2._getNamesByMacros = function _getNamesByMacros(macros, out) {
    var maskMap = Shader2._macroMaskMap;
    var mask = macros._mask;
    out.length = 0;
    for (var i = 0, n = macros._length; i < n; i++) {
      var subMaskMap = maskMap[i];
      var subMask = mask[i];
      var _n = subMask < 0 ? 32 : Math.floor(Math.log2(subMask)) + 1;
      for (var j = 0; j < _n; j++) {
        if (subMask & 1 << j) {
          out.push(subMaskMap[j]);
        }
      }
    }
  };
  function Shader2(name, vertexSource, fragmentSource) {
    this.name = void 0;
    this._shaderId = 0;
    this._vertexSource = void 0;
    this._fragmentSource = void 0;
    this._shaderId = Shader2._shaderCounter++;
    this.name = name;
    this._vertexSource = vertexSource;
    this._fragmentSource = fragmentSource;
  }
  var _proto = Shader2.prototype;
  _proto.compileVariant = function compileVariant(engine, macros) {
    var compileMacros = Shader2._compileMacros;
    compileMacros.clear();
    for (var i = 0, n = macros.length; i < n; i++) {
      compileMacros.enable(Shader2.getMacroByName(macros[i]));
    }
    return this._getShaderProgram(engine, compileMacros).isValid;
  };
  _proto._getShaderProgram = function _getShaderProgram(engine, macroCollection) {
    var shaderProgramPool = engine._getShaderProgramPool(this);
    var shaderProgram = shaderProgramPool.get(macroCollection);
    if (shaderProgram) {
      return shaderProgram;
    }
    var isWebGL2 = engine._hardwareRenderer.isWebGL2;
    var macroNameList = [];
    Shader2._getNamesByMacros(macroCollection, macroNameList);
    var macroNameStr = ShaderFactory.parseCustomMacros(macroNameList);
    var versionStr = isWebGL2 ? "#version 300 es" : "#version 100";
    var precisionStr = "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      precision highp int;\n      #define O3_VERTEX_PRECISION highp\n      #define O3_FRAGMENT_PRECISION highp\n    #else\n      precision mediump float;\n      precision mediump int;\n      #define O3_VERTEX_PRECISION mediump\n      #define O3_FRAGMENT_PRECISION mediump\n    #endif\n    ";
    if (engine._hardwareRenderer.canIUse(GLCapabilityType.shaderTextureLod)) {
      precisionStr += "#define HAS_TEX_LOD\n";
    }
    if (engine._hardwareRenderer.canIUse(GLCapabilityType.standardDerivatives)) {
      precisionStr += "#define HAS_DERIVATIVES\n";
    }
    var vertexSource = ShaderFactory.parseIncludes(" " + versionStr + "\n        " + precisionStr + "\n        " + macroNameStr + "\n        " + this._vertexSource);
    var fragmentSource = ShaderFactory.parseIncludes(" " + versionStr + "\n        " + (isWebGL2 ? "" : ShaderFactory.parseExtension(Shader2._shaderExtension)) + "\n        " + precisionStr + "\n        " + macroNameStr + "\n      " + this._fragmentSource);
    if (isWebGL2) {
      vertexSource = ShaderFactory.convertTo300(vertexSource);
      fragmentSource = ShaderFactory.convertTo300(fragmentSource, true);
    }
    shaderProgram = new ShaderProgram(engine, vertexSource, fragmentSource);
    shaderProgramPool.cache(shaderProgram);
    return shaderProgram;
  };
  return Shader2;
}();
Shader._compileMacros = new ShaderMacroCollection();
Shader._shaderCounter = 0;
Shader._shaderMap = Object.create(null);
Shader._propertyNameMap = Object.create(null);
Shader._macroMaskMap = [];
Shader._macroCounter = 0;
Shader._macroMap = Object.create(null);
Shader._shaderExtension = ["GL_EXT_shader_texture_lod", "GL_OES_standard_derivatives", "GL_EXT_draw_buffers"];
var ShaderData = function() {
  function ShaderData2(group) {
    this._group = void 0;
    this._properties = Object.create(null);
    this._macroCollection = new ShaderMacroCollection();
    this._variableMacros = Object.create(null);
    this._refCount = 0;
    this._group = group;
  }
  var _proto = ShaderData2.prototype;
  _proto.getFloat = function getFloat(property) {
    return this._getData(property);
  };
  _proto.setFloat = function setFloat(property, value) {
    this._setData(property, value);
  };
  _proto.getInt = function getInt(property) {
    return this._getData(property);
  };
  _proto.setInt = function setInt(property, value) {
    this._setData(property, value);
  };
  _proto.getFloatArray = function getFloatArray(property) {
    return this._getData(property);
  };
  _proto.setFloatArray = function setFloatArray(property, value) {
    this._setData(property, value);
  };
  _proto.getIntArray = function getIntArray(property) {
    return this._getData(property);
  };
  _proto.setIntArray = function setIntArray(property, value) {
    this._setData(property, value);
  };
  _proto.getVector2 = function getVector2(property) {
    return this._getData(property);
  };
  _proto.setVector2 = function setVector2(property, value) {
    this._setData(property, value);
  };
  _proto.getVector3 = function getVector3(property) {
    return this._getData(property);
  };
  _proto.setVector3 = function setVector3(property, value) {
    this._setData(property, value);
  };
  _proto.getVector4 = function getVector4(property) {
    return this._getData(property);
  };
  _proto.setVector4 = function setVector4(property, value) {
    this._setData(property, value);
  };
  _proto.getMatrix = function getMatrix(property) {
    return this._getData(property);
  };
  _proto.setMatrix = function setMatrix(property, value) {
    this._setData(property, value);
  };
  _proto.getColor = function getColor(property) {
    return this._getData(property);
  };
  _proto.setColor = function setColor(property, value) {
    this._setData(property, value);
  };
  _proto.getTexture = function getTexture(property) {
    return this._getData(property);
  };
  _proto.setTexture = function setTexture(property, value) {
    if (this._getRefCount() > 0) {
      var lastValue = this._getData(property);
      lastValue && lastValue._addRefCount(-1);
      value && value._addRefCount(1);
    }
    this._setData(property, value);
  };
  _proto.getTextureArray = function getTextureArray(property) {
    return this._getData(property);
  };
  _proto.setTextureArray = function setTextureArray(property, value) {
    if (this._getRefCount() > 0) {
      var lastValue = this._getData(property);
      if (lastValue) {
        for (var i = 0, n = lastValue.length; i < n; i++) {
          lastValue[i]._addRefCount(-1);
        }
      }
      if (value) {
        for (var _i = 0, _n = value.length; _i < _n; _i++) {
          value[_i]._addRefCount(1);
        }
      }
    }
    this._setData(property, value);
  };
  _proto.enableMacro = function enableMacro(macro, value) {
    if (value === void 0) {
      value = null;
    }
    if (value) {
      this._enableVariableMacro(macro, value);
    } else {
      if (typeof macro === "string") {
        macro = Shader.getMacroByName(macro);
      }
      this._macroCollection.enable(macro);
    }
  };
  _proto.disableMacro = function disableMacro(macro) {
    if (typeof macro === "string") {
      var variableValue = this._variableMacros[macro];
      if (variableValue) {
        this._disableVariableMacro(macro, variableValue);
      } else {
        macro = Shader.getMacroByName(macro);
        this._macroCollection.disable(macro);
      }
    } else {
      this._macroCollection.disable(macro);
    }
  };
  _proto.clone = function clone2() {
    var shaderData = new ShaderData2(this._group);
    this.cloneTo(shaderData);
    return shaderData;
  };
  _proto.cloneTo = function cloneTo(target) {
    CloneManager.deepCloneObject(this._macroCollection, target._macroCollection);
    _extends(target._variableMacros, this._variableMacros);
    var properties = this._properties;
    var targetProperties = target._properties;
    var keys = Object.keys(properties);
    for (var i = 0, n = keys.length; i < n; i++) {
      var k = keys[i];
      var _property = properties[k];
      if (_property != null) {
        if (typeof _property === "number") {
          targetProperties[k] = _property;
        } else if (_property instanceof Texture) {
          targetProperties[k] = _property;
        } else if (_property instanceof Array || _property instanceof Float32Array || _property instanceof Int32Array) {
          targetProperties[k] = _property.slice();
        } else {
          var targetProperty = targetProperties[k];
          if (targetProperty) {
            _property.cloneTo(targetProperty);
          } else {
            targetProperties[k] = _property.clone();
          }
        }
      } else {
        targetProperties[k] = _property;
      }
    }
  };
  _proto._getData = function _getData(property) {
    if (typeof property === "string") {
      property = Shader.getPropertyByName(property);
    }
    return this._properties[property._uniqueId];
  };
  _proto._setData = function _setData(property, value) {
    if (typeof property === "string") {
      property = Shader.getPropertyByName(property);
    }
    if (property._group !== this._group) {
      if (property._group === void 0) {
        property._group = this._group;
      } else {
        throw "Shader property " + property.name + " has been used as " + ShaderDataGroup[property._group] + " property.";
      }
    }
    this._properties[property._uniqueId] = value;
  };
  _proto._getRefCount = function _getRefCount() {
    return this._refCount;
  };
  _proto._addRefCount = function _addRefCount(value) {
    this._refCount += value;
    var properties = this._properties;
    for (var k in properties) {
      var _property2 = properties[k];
      if (_property2 && _property2 instanceof Texture) {
        _property2._addRefCount(value);
      }
    }
  };
  _proto._enableVariableMacro = function _enableVariableMacro(name, value) {
    var variableMacro = this._variableMacros;
    var variableValue = variableMacro[name];
    if (variableValue !== value) {
      variableValue && this._disableVariableMacro(name, variableValue);
      var _macro = Shader.getMacroByName(name + " " + value);
      this._macroCollection.enable(_macro);
      variableMacro[name] = value;
    }
  };
  _proto._disableVariableMacro = function _disableVariableMacro(name, value) {
    var oldMacro = Shader.getMacroByName(name + " " + value);
    this._macroCollection.disable(oldMacro);
    delete this._variableMacros[name];
  };
  return ShaderData2;
}();
var BlendFactor;
(function(BlendFactor2) {
  BlendFactor2[BlendFactor2["Zero"] = 0] = "Zero";
  BlendFactor2[BlendFactor2["One"] = 1] = "One";
  BlendFactor2[BlendFactor2["SourceColor"] = 2] = "SourceColor";
  BlendFactor2[BlendFactor2["OneMinusSourceColor"] = 3] = "OneMinusSourceColor";
  BlendFactor2[BlendFactor2["DestinationColor"] = 4] = "DestinationColor";
  BlendFactor2[BlendFactor2["OneMinusDestinationColor"] = 5] = "OneMinusDestinationColor";
  BlendFactor2[BlendFactor2["SourceAlpha"] = 6] = "SourceAlpha";
  BlendFactor2[BlendFactor2["OneMinusSourceAlpha"] = 7] = "OneMinusSourceAlpha";
  BlendFactor2[BlendFactor2["DestinationAlpha"] = 8] = "DestinationAlpha";
  BlendFactor2[BlendFactor2["OneMinusDestinationAlpha"] = 9] = "OneMinusDestinationAlpha";
  BlendFactor2[BlendFactor2["SourceAlphaSaturate"] = 10] = "SourceAlphaSaturate";
  BlendFactor2[BlendFactor2["BlendColor"] = 11] = "BlendColor";
  BlendFactor2[BlendFactor2["OneMinusBlendColor"] = 12] = "OneMinusBlendColor";
})(BlendFactor || (BlendFactor = {}));
var BlendOperation;
(function(BlendOperation2) {
  BlendOperation2[BlendOperation2["Add"] = 0] = "Add";
  BlendOperation2[BlendOperation2["Subtract"] = 1] = "Subtract";
  BlendOperation2[BlendOperation2["ReverseSubtract"] = 2] = "ReverseSubtract";
  BlendOperation2[BlendOperation2["Min"] = 3] = "Min";
  BlendOperation2[BlendOperation2["Max"] = 4] = "Max";
})(BlendOperation || (BlendOperation = {}));
var ColorWriteMask;
(function(ColorWriteMask2) {
  ColorWriteMask2[ColorWriteMask2["None"] = 0] = "None";
  ColorWriteMask2[ColorWriteMask2["Red"] = 1] = "Red";
  ColorWriteMask2[ColorWriteMask2["Green"] = 2] = "Green";
  ColorWriteMask2[ColorWriteMask2["Blue"] = 4] = "Blue";
  ColorWriteMask2[ColorWriteMask2["Alpha"] = 8] = "Alpha";
  ColorWriteMask2[ColorWriteMask2["All"] = 15] = "All";
})(ColorWriteMask || (ColorWriteMask = {}));
var RenderTargetBlendState = function RenderTargetBlendState2() {
  this.enabled = false;
  this.colorBlendOperation = BlendOperation.Add;
  this.alphaBlendOperation = BlendOperation.Add;
  this.sourceColorBlendFactor = BlendFactor.One;
  this.sourceAlphaBlendFactor = BlendFactor.One;
  this.destinationColorBlendFactor = BlendFactor.Zero;
  this.destinationAlphaBlendFactor = BlendFactor.Zero;
  this.colorWriteMask = ColorWriteMask.All;
};
var BlendState = function() {
  function BlendState2() {
    this.targetBlendState = new RenderTargetBlendState();
    this.blendColor = new Color(0, 0, 0, 0);
    this.alphaToCoverage = false;
  }
  BlendState2._getGLBlendFactor = function _getGLBlendFactor(rhi, blendFactor) {
    var gl = rhi.gl;
    switch (blendFactor) {
      case BlendFactor.Zero:
        return gl.ZERO;
      case BlendFactor.One:
        return gl.ONE;
      case BlendFactor.SourceColor:
        return gl.SRC_COLOR;
      case BlendFactor.OneMinusSourceColor:
        return gl.ONE_MINUS_SRC_COLOR;
      case BlendFactor.DestinationColor:
        return gl.DST_COLOR;
      case BlendFactor.OneMinusDestinationColor:
        return gl.ONE_MINUS_DST_COLOR;
      case BlendFactor.SourceAlpha:
        return gl.SRC_ALPHA;
      case BlendFactor.OneMinusSourceAlpha:
        return gl.ONE_MINUS_SRC_ALPHA;
      case BlendFactor.DestinationAlpha:
        return gl.DST_ALPHA;
      case BlendFactor.OneMinusDestinationAlpha:
        return gl.ONE_MINUS_DST_ALPHA;
      case BlendFactor.SourceAlphaSaturate:
        return gl.SRC_ALPHA_SATURATE;
      case BlendFactor.BlendColor:
        return gl.CONSTANT_COLOR;
      case BlendFactor.OneMinusBlendColor:
        return gl.ONE_MINUS_CONSTANT_COLOR;
    }
  };
  BlendState2._getGLBlendOperation = function _getGLBlendOperation(rhi, blendOperation) {
    var gl = rhi.gl;
    switch (blendOperation) {
      case BlendOperation.Add:
        return gl.FUNC_ADD;
      case BlendOperation.Subtract:
        return gl.FUNC_SUBTRACT;
      case BlendOperation.ReverseSubtract:
        return gl.FUNC_REVERSE_SUBTRACT;
      case BlendOperation.Min:
        if (!rhi.canIUse(GLCapabilityType.blendMinMax)) {
          throw new Error("BlendOperation.Min is not supported in this context");
        }
        return gl.MIN;
      case BlendOperation.Max:
        if (!rhi.canIUse(GLCapabilityType.blendMinMax)) {
          throw new Error("BlendOperation.Max is not supported in this context");
        }
        return gl.MAX;
    }
  };
  var _proto = BlendState2.prototype;
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.blendState);
  };
  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var lastTargetBlendState = lastState.targetBlendState;
    var _this$targetBlendStat = this.targetBlendState, enabled = _this$targetBlendStat.enabled, colorBlendOperation = _this$targetBlendStat.colorBlendOperation, alphaBlendOperation = _this$targetBlendStat.alphaBlendOperation, sourceColorBlendFactor = _this$targetBlendStat.sourceColorBlendFactor, destinationColorBlendFactor = _this$targetBlendStat.destinationColorBlendFactor, sourceAlphaBlendFactor = _this$targetBlendStat.sourceAlphaBlendFactor, destinationAlphaBlendFactor = _this$targetBlendStat.destinationAlphaBlendFactor, colorWriteMask = _this$targetBlendStat.colorWriteMask;
    if (enabled !== lastTargetBlendState.enabled) {
      if (enabled) {
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
      lastTargetBlendState.enabled = enabled;
    }
    if (enabled) {
      if (sourceColorBlendFactor !== lastTargetBlendState.sourceColorBlendFactor || destinationColorBlendFactor !== lastTargetBlendState.destinationColorBlendFactor || sourceAlphaBlendFactor !== lastTargetBlendState.sourceAlphaBlendFactor || destinationAlphaBlendFactor !== lastTargetBlendState.destinationAlphaBlendFactor) {
        gl.blendFuncSeparate(BlendState2._getGLBlendFactor(rhi, sourceColorBlendFactor), BlendState2._getGLBlendFactor(rhi, destinationColorBlendFactor), BlendState2._getGLBlendFactor(rhi, sourceAlphaBlendFactor), BlendState2._getGLBlendFactor(rhi, destinationAlphaBlendFactor));
        lastTargetBlendState.sourceColorBlendFactor = sourceColorBlendFactor;
        lastTargetBlendState.destinationColorBlendFactor = destinationColorBlendFactor;
        lastTargetBlendState.sourceAlphaBlendFactor = sourceAlphaBlendFactor;
        lastTargetBlendState.destinationAlphaBlendFactor = destinationAlphaBlendFactor;
      }
      if (colorBlendOperation !== lastTargetBlendState.colorBlendOperation || alphaBlendOperation !== lastTargetBlendState.alphaBlendOperation) {
        gl.blendEquationSeparate(BlendState2._getGLBlendOperation(rhi, colorBlendOperation), BlendState2._getGLBlendOperation(rhi, alphaBlendOperation));
        lastTargetBlendState.colorBlendOperation = colorBlendOperation;
        lastTargetBlendState.alphaBlendOperation = alphaBlendOperation;
      }
      var blendColor = this.blendColor;
      if (!Color.equals(lastState.blendColor, blendColor)) {
        gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendColor.a);
        blendColor.cloneTo(lastState.blendColor);
      }
    }
    if (colorWriteMask !== lastTargetBlendState.colorWriteMask) {
      gl.colorMask((colorWriteMask & ColorWriteMask.Red) !== 0, (colorWriteMask & ColorWriteMask.Green) !== 0, (colorWriteMask & ColorWriteMask.Blue) !== 0, (colorWriteMask & ColorWriteMask.Alpha) !== 0);
      lastTargetBlendState.colorWriteMask = colorWriteMask;
    }
    var alphaToCoverage = this.alphaToCoverage;
    if (alphaToCoverage !== lastState.alphaToCoverage) {
      if (alphaToCoverage) {
        gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
      } else {
        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
      }
      lastState.alphaToCoverage = alphaToCoverage;
    }
  };
  return BlendState2;
}();
var CompareFunction;
(function(CompareFunction2) {
  CompareFunction2[CompareFunction2["Never"] = 0] = "Never";
  CompareFunction2[CompareFunction2["Less"] = 1] = "Less";
  CompareFunction2[CompareFunction2["Equal"] = 2] = "Equal";
  CompareFunction2[CompareFunction2["LessEqual"] = 3] = "LessEqual";
  CompareFunction2[CompareFunction2["Greater"] = 4] = "Greater";
  CompareFunction2[CompareFunction2["NotEqual"] = 5] = "NotEqual";
  CompareFunction2[CompareFunction2["GreaterEqual"] = 6] = "GreaterEqual";
  CompareFunction2[CompareFunction2["Always"] = 7] = "Always";
})(CompareFunction || (CompareFunction = {}));
var DepthState = function() {
  function DepthState2() {
    this.enabled = true;
    this.writeEnabled = true;
    this.compareFunction = CompareFunction.Less;
  }
  DepthState2._getGLCompareFunction = function _getGLCompareFunction(rhi, compareFunction) {
    var gl = rhi.gl;
    switch (compareFunction) {
      case CompareFunction.Never:
        return gl.NEVER;
      case CompareFunction.Less:
        return gl.LESS;
      case CompareFunction.Equal:
        return gl.EQUAL;
      case CompareFunction.LessEqual:
        return gl.LEQUAL;
      case CompareFunction.Greater:
        return gl.GREATER;
      case CompareFunction.NotEqual:
        return gl.NOTEQUAL;
      case CompareFunction.GreaterEqual:
        return gl.GEQUAL;
      case CompareFunction.Always:
        return gl.ALWAYS;
    }
  };
  var _proto = DepthState2.prototype;
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.depthState);
  };
  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var enabled = this.enabled, compareFunction = this.compareFunction, writeEnabled = this.writeEnabled;
    if (enabled != lastState.enabled) {
      if (enabled) {
        gl.enable(gl.DEPTH_TEST);
      } else {
        gl.disable(gl.DEPTH_TEST);
      }
      lastState.enabled = enabled;
    }
    if (enabled) {
      if (compareFunction != lastState.compareFunction) {
        gl.depthFunc(DepthState2._getGLCompareFunction(rhi, compareFunction));
        lastState.compareFunction = compareFunction;
      }
      if (writeEnabled != lastState.writeEnabled) {
        gl.depthMask(writeEnabled);
        lastState.writeEnabled = writeEnabled;
      }
    }
  };
  return DepthState2;
}();
var CullMode;
(function(CullMode2) {
  CullMode2[CullMode2["Off"] = 0] = "Off";
  CullMode2[CullMode2["Front"] = 1] = "Front";
  CullMode2[CullMode2["Back"] = 2] = "Back";
})(CullMode || (CullMode = {}));
var RasterState = function() {
  function RasterState2() {
    this.cullMode = CullMode.Back;
    this.depthBias = 0;
    this.slopeScaledDepthBias = 0;
    this._cullFaceEnable = true;
  }
  var _proto = RasterState2.prototype;
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.rasterState);
  };
  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var cullMode = this.cullMode, depthBias = this.depthBias, slopeScaledDepthBias = this.slopeScaledDepthBias;
    var cullFaceEnable = cullMode !== CullMode.Off;
    if (cullFaceEnable !== lastState._cullFaceEnable) {
      if (cullFaceEnable) {
        gl.enable(gl.CULL_FACE);
      } else {
        gl.disable(gl.CULL_FACE);
      }
      lastState._cullFaceEnable = cullFaceEnable;
    }
    if (cullFaceEnable) {
      if (cullMode !== lastState.cullMode) {
        if (cullMode == CullMode.Back) {
          gl.cullFace(gl.BACK);
        } else {
          gl.cullFace(gl.FRONT);
        }
        lastState.cullMode = cullMode;
      }
    }
    if (depthBias !== lastState.depthBias || slopeScaledDepthBias !== lastState.slopeScaledDepthBias) {
      if (depthBias !== 0 || slopeScaledDepthBias !== 0) {
        gl.enable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(slopeScaledDepthBias, depthBias);
      } else {
        gl.disable(gl.POLYGON_OFFSET_FILL);
      }
      lastState.depthBias = depthBias;
      lastState.slopeScaledDepthBias = slopeScaledDepthBias;
    }
  };
  return RasterState2;
}();
var StencilOperation;
(function(StencilOperation2) {
  StencilOperation2[StencilOperation2["Keep"] = 0] = "Keep";
  StencilOperation2[StencilOperation2["Zero"] = 1] = "Zero";
  StencilOperation2[StencilOperation2["Replace"] = 2] = "Replace";
  StencilOperation2[StencilOperation2["IncrementSaturate"] = 3] = "IncrementSaturate";
  StencilOperation2[StencilOperation2["DecrementSaturate"] = 4] = "DecrementSaturate";
  StencilOperation2[StencilOperation2["Invert"] = 5] = "Invert";
  StencilOperation2[StencilOperation2["IncrementWrap"] = 6] = "IncrementWrap";
  StencilOperation2[StencilOperation2["DecrementWrap"] = 7] = "DecrementWrap";
})(StencilOperation || (StencilOperation = {}));
var StencilState = function() {
  function StencilState2() {
    this.enabled = false;
    this.referenceValue = 0;
    this.mask = 255;
    this.writeMask = 255;
    this.compareFunctionFront = CompareFunction.Always;
    this.compareFunctionBack = CompareFunction.Always;
    this.passOperationFront = StencilOperation.Keep;
    this.passOperationBack = StencilOperation.Keep;
    this.failOperationFront = StencilOperation.Keep;
    this.failOperationBack = StencilOperation.Keep;
    this.zFailOperationFront = StencilOperation.Keep;
    this.zFailOperationBack = StencilOperation.Keep;
  }
  StencilState2._getGLCompareFunction = function _getGLCompareFunction(rhi, compareFunction) {
    var gl = rhi.gl;
    switch (compareFunction) {
      case CompareFunction.Never:
        return gl.NEVER;
      case CompareFunction.Less:
        return gl.LESS;
      case CompareFunction.Equal:
        return gl.EQUAL;
      case CompareFunction.LessEqual:
        return gl.LEQUAL;
      case CompareFunction.Greater:
        return gl.GREATER;
      case CompareFunction.NotEqual:
        return gl.NOTEQUAL;
      case CompareFunction.GreaterEqual:
        return gl.GEQUAL;
      case CompareFunction.Always:
        return gl.ALWAYS;
    }
  };
  StencilState2._getGLStencilOperation = function _getGLStencilOperation(rhi, compareFunction) {
    var gl = rhi.gl;
    switch (compareFunction) {
      case StencilOperation.Keep:
        return gl.KEEP;
      case StencilOperation.Zero:
        return gl.ZERO;
      case StencilOperation.Replace:
        return gl.REPLACE;
      case StencilOperation.IncrementSaturate:
        return gl.INCR;
      case StencilOperation.DecrementSaturate:
        return gl.DECR;
      case StencilOperation.Invert:
        return gl.INVERT;
      case StencilOperation.IncrementWrap:
        return gl.INCR_WRAP;
      case StencilOperation.DecrementWrap:
        return gl.DECR_WRAP;
    }
  };
  var _proto = StencilState2.prototype;
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.stencilState);
  };
  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var enabled = this.enabled, referenceValue = this.referenceValue, mask = this.mask, compareFunctionFront = this.compareFunctionFront, compareFunctionBack = this.compareFunctionBack, failOperationFront = this.failOperationFront, zFailOperationFront = this.zFailOperationFront, passOperationFront = this.passOperationFront, failOperationBack = this.failOperationBack, zFailOperationBack = this.zFailOperationBack, passOperationBack = this.passOperationBack, writeMask = this.writeMask;
    if (enabled != lastState.enabled) {
      if (enabled) {
        gl.enable(gl.STENCIL_TEST);
      } else {
        gl.disable(gl.STENCIL_TEST);
      }
      lastState.enabled = enabled;
    }
    if (enabled) {
      var referenceOrMaskChange = referenceValue !== lastState.referenceValue || mask !== lastState.mask;
      if (referenceOrMaskChange || compareFunctionFront !== lastState.compareFunctionFront) {
        gl.stencilFuncSeparate(gl.FRONT, StencilState2._getGLCompareFunction(rhi, compareFunctionFront), referenceValue, mask);
        lastState.compareFunctionFront = compareFunctionFront;
      }
      if (referenceOrMaskChange || compareFunctionBack !== lastState.compareFunctionBack) {
        gl.stencilFuncSeparate(gl.BACK, StencilState2._getGLCompareFunction(rhi, compareFunctionBack), referenceValue, mask);
        lastState.compareFunctionBack = this.compareFunctionBack;
      }
      if (referenceOrMaskChange) {
        lastState.referenceValue = this.referenceValue;
        lastState.mask = this.mask;
      }
      if (failOperationFront !== lastState.failOperationFront || zFailOperationFront !== lastState.zFailOperationFront || passOperationFront !== lastState.passOperationFront) {
        gl.stencilOpSeparate(gl.FRONT, StencilState2._getGLStencilOperation(rhi, failOperationFront), StencilState2._getGLStencilOperation(rhi, zFailOperationFront), StencilState2._getGLStencilOperation(rhi, passOperationFront));
        lastState.failOperationFront = failOperationFront;
        lastState.zFailOperationFront = zFailOperationFront;
        lastState.passOperationFront = passOperationFront;
      }
      if (failOperationBack !== lastState.failOperationBack || zFailOperationBack !== lastState.zFailOperationBack || passOperationBack !== lastState.passOperationBack) {
        gl.stencilOpSeparate(gl.BACK, StencilState2._getGLStencilOperation(rhi, failOperationBack), StencilState2._getGLStencilOperation(rhi, zFailOperationBack), StencilState2._getGLStencilOperation(rhi, passOperationBack));
        lastState.failOperationBack = failOperationBack;
        lastState.zFailOperationBack = zFailOperationBack;
        lastState.passOperationBack = passOperationBack;
      }
      if (writeMask !== lastState.writeMask) {
        gl.stencilMask(writeMask);
        lastState.writeMask = writeMask;
      }
    }
  };
  return StencilState2;
}();
var RenderState = function() {
  function RenderState2() {
    this.blendState = new BlendState();
    this.depthState = new DepthState();
    this.stencilState = new StencilState();
    this.rasterState = new RasterState();
  }
  var _proto = RenderState2.prototype;
  _proto._apply = function _apply(engine) {
    var hardwareRenderer = engine._hardwareRenderer;
    var lastRenderState = engine._lastRenderState;
    this.blendState._apply(hardwareRenderer, lastRenderState);
    this.depthState._apply(hardwareRenderer, lastRenderState);
    this.stencilState._apply(hardwareRenderer, lastRenderState);
    this.rasterState._apply(hardwareRenderer, lastRenderState);
  };
  return RenderState2;
}();
var Material = function(_RefObject) {
  _inheritsLoose(Material2, _RefObject);
  function Material2(engine, shader) {
    var _this;
    _this = _RefObject.call(this, engine) || this;
    _this.name = void 0;
    _this.shader = void 0;
    _this.renderQueueType = RenderQueueType.Opaque;
    _this.shaderData = new ShaderData(ShaderDataGroup.Material);
    _this.renderState = new RenderState();
    _this.shader = shader;
    return _this;
  }
  var _proto = Material2.prototype;
  _proto.clone = function clone2() {
    var dest = new Material2(this._engine, this.shader);
    this.cloneTo(dest);
    return dest;
  };
  _proto.cloneTo = function cloneTo(target) {
    target.shader = this.shader;
    target.renderQueueType = this.renderQueueType;
    this.shaderData.cloneTo(target.shaderData);
    CloneManager.deepCloneObject(this.renderState, target.renderState);
  };
  _proto._addRefCount = function _addRefCount(value) {
    _RefObject.prototype._addRefCount.call(this, value);
    this.shaderData._addRefCount(value);
  };
  _proto._preRender = function _preRender(renderElement) {
  };
  _proto._onDestroy = function _onDestroy() {
  };
  return Material2;
}(RefObject);
var ClassPool = function() {
  function ClassPool2(type) {
    this._elementPoolIndex = 0;
    this._elementPool = [];
    this._type = void 0;
    this._type = type;
  }
  var _proto = ClassPool2.prototype;
  _proto.getFromPool = function getFromPool() {
    var index = this._elementPoolIndex, pool = this._elementPool;
    this._elementPoolIndex++;
    if (pool.length === index) {
      var element = new this._type();
      pool.push(element);
      return element;
    } else {
      return pool[index];
    }
  };
  _proto.resetPool = function resetPool() {
    this._elementPoolIndex = 0;
  };
  return ClassPool2;
}();
var RenderContext = function() {
  function RenderContext2() {
    this._camera = void 0;
    this._viewProjectMatrix = new Matrix();
  }
  var _proto = RenderContext2.prototype;
  _proto._setContext = function _setContext(camera) {
    this._camera = camera;
    Matrix.multiply(camera.projectionMatrix, camera.viewMatrix, this._viewProjectMatrix);
  };
  return RenderContext2;
}();
var RenderElement = function() {
  function RenderElement2() {
    this.component = void 0;
    this.mesh = void 0;
    this.subMesh = void 0;
    this.material = void 0;
  }
  var _proto = RenderElement2.prototype;
  _proto.setValue = function setValue(component, mesh, subMesh, material) {
    this.component = component;
    this.mesh = mesh;
    this.subMesh = subMesh;
    this.material = material;
  };
  return RenderElement2;
}();
var SpriteElement = function() {
  function SpriteElement2() {
    this.component = void 0;
    this.positions = void 0;
    this.uv = void 0;
    this.triangles = void 0;
    this.color = void 0;
    this.material = void 0;
    this.camera = void 0;
  }
  var _proto = SpriteElement2.prototype;
  _proto.setValue = function setValue(component, positions, uv, triangles, color, material, camera) {
    this.component = component;
    this.positions = positions;
    this.uv = uv;
    this.triangles = triangles;
    this.color = color;
    this.material = material;
    this.camera = camera;
  };
  return SpriteElement2;
}();
var SpriteMaskElement = function() {
  function SpriteMaskElement2() {
    this.component = void 0;
    this.positions = void 0;
    this.uv = void 0;
    this.triangles = void 0;
    this.material = void 0;
    this.isAdd = true;
    this.camera = void 0;
  }
  var _proto = SpriteMaskElement2.prototype;
  _proto.setValue = function setValue(component, positions, uv, triangles, material) {
    this.component = component;
    this.positions = positions;
    this.uv = uv;
    this.triangles = triangles;
    this.material = material;
  };
  return SpriteMaskElement2;
}();
var SpriteMaskInteraction;
(function(SpriteMaskInteraction2) {
  SpriteMaskInteraction2[SpriteMaskInteraction2["None"] = 0] = "None";
  SpriteMaskInteraction2[SpriteMaskInteraction2["VisibleInsideMask"] = 1] = "VisibleInsideMask";
  SpriteMaskInteraction2[SpriteMaskInteraction2["VisibleOutsideMask"] = 2] = "VisibleOutsideMask";
})(SpriteMaskInteraction || (SpriteMaskInteraction = {}));
var _class$7;
var _descriptor$7;
var _descriptor2$7;
var _descriptor3$6;
var _descriptor4$6;
var _descriptor5$6;
var _descriptor6$6;
var _descriptor7$4;
var _descriptor8$2;
var _descriptor9$2;
var _descriptor10$2;
var _descriptor11$2;
var _descriptor12$2;
var _descriptor13$1;
var _descriptor14;
var _descriptor15;
var _descriptor16;
var _class2$6;
var _temp$6;
var Renderer = (_class$7 = (_temp$6 = _class2$6 = function(_Component) {
  _inheritsLoose(Renderer2, _Component);
  function Renderer2(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _initializerDefineProperty(_this, "shaderData", _descriptor$7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "isCulled", _descriptor2$7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_distanceForSort", _descriptor3$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onUpdateIndex", _descriptor4$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_rendererIndex", _descriptor5$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_globalShaderMacro", _descriptor6$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_renderSortId", _descriptor7$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_overrideUpdate", _descriptor8$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_materials", _descriptor9$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_transformChangeFlag", _descriptor10$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_bounds", _descriptor11$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_mvMatrix", _descriptor12$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_mvpMatrix", _descriptor13$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_mvInvMatrix", _descriptor14, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_normalMatrix", _descriptor15, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_materialsInstanced", _descriptor16, _assertThisInitialized(_this));
    var prototype = Renderer2.prototype;
    _this._overrideUpdate = _this.update !== prototype.update;
    _this._transformChangeFlag = _this.entity.transform.registerWorldChangeFlag();
    _this.shaderData._addRefCount(1);
    return _this;
  }
  var _proto = Renderer2.prototype;
  _proto.getInstanceMaterial = function getInstanceMaterial(index) {
    if (index === void 0) {
      index = 0;
    }
    var materials = this._materials;
    if (materials.length > index) {
      var _material = materials[index];
      if (_material) {
        if (this._materialsInstanced[index]) {
          return _material;
        } else {
          return this._createInstanceMaterial(_material, index);
        }
      }
    }
    return null;
  };
  _proto.getMaterial = function getMaterial(index) {
    if (index === void 0) {
      index = 0;
    }
    return this._materials[index] || null;
  };
  _proto.setMaterial = function setMaterial(indexOrMaterial, material) {
    if (material === void 0) {
      material = null;
    }
    var index;
    if (typeof indexOrMaterial === "number") {
      index = indexOrMaterial;
    } else {
      index = 0;
      material = indexOrMaterial;
    }
    var materials = this._materials;
    if (index >= materials.length) {
      materials.length = index + 1;
    }
    var materialsInstance = this._materialsInstanced;
    var internalMaterial = materials[index];
    if (internalMaterial !== material) {
      materials[index] = material;
      index < materialsInstance.length && (materialsInstance[index] = false);
      internalMaterial && internalMaterial._addRefCount(-1);
      material && material._addRefCount(1);
    }
  };
  _proto.getInstanceMaterials = function getInstanceMaterials() {
    var materials = this._materials;
    var materialsInstance = this._materialsInstanced;
    for (var i = 0, n = materials.length; i < n; i++) {
      if (!materialsInstance[i]) {
        this._createInstanceMaterial(this._materials[i], i);
      }
    }
    return materials;
  };
  _proto.getMaterials = function getMaterials() {
    return this._materials;
  };
  _proto.setMaterials = function setMaterials(materials) {
    var count = materials.length;
    var internalMaterials = this._materials;
    var materialsInstanced = this._materialsInstanced;
    for (var i = count, n = internalMaterials.length; i < n; i++) {
      var internalMaterial = internalMaterials[i];
      internalMaterial && internalMaterial._addRefCount(-1);
    }
    internalMaterials.length !== count && (internalMaterials.length = count);
    materialsInstanced.length !== 0 && (materialsInstanced.length = 0);
    for (var _i = 0; _i < count; _i++) {
      var _internalMaterial = internalMaterials[_i];
      var _material2 = materials[_i];
      if (_internalMaterial !== _material2) {
        internalMaterials[_i] = _material2;
        _internalMaterial && _internalMaterial._addRefCount(-1);
        _material2 && _material2._addRefCount(1);
      }
    }
  };
  _proto.update = function update(deltaTime) {
  };
  _proto._updateShaderData = function _updateShaderData(context) {
    var shaderData = this.shaderData;
    var worldMatrix = this.entity.transform.worldMatrix;
    var mvMatrix = this._mvMatrix;
    var mvpMatrix = this._mvpMatrix;
    var mvInvMatrix = this._mvInvMatrix;
    var normalMatrix = this._normalMatrix;
    Matrix.multiply(context._camera.viewMatrix, worldMatrix, mvMatrix);
    Matrix.multiply(context._viewProjectMatrix, worldMatrix, mvpMatrix);
    Matrix.invert(mvMatrix, mvInvMatrix);
    Matrix.invert(worldMatrix, normalMatrix);
    normalMatrix.transpose();
    shaderData.setMatrix(Renderer2._localMatrixProperty, this.entity.transform.localMatrix);
    shaderData.setMatrix(Renderer2._worldMatrixProperty, worldMatrix);
    shaderData.setMatrix(Renderer2._mvMatrixProperty, mvMatrix);
    shaderData.setMatrix(Renderer2._mvpMatrixProperty, mvpMatrix);
    shaderData.setMatrix(Renderer2._mvInvMatrixProperty, mvInvMatrix);
    shaderData.setMatrix(Renderer2._normalMatrixProperty, normalMatrix);
  };
  _proto._onEnable = function _onEnable() {
    var componentsManager = this.engine._componentsManager;
    if (this._overrideUpdate) {
      componentsManager.addOnUpdateRenderers(this);
    }
    componentsManager.addRenderer(this);
  };
  _proto._onDisable = function _onDisable() {
    var componentsManager = this.engine._componentsManager;
    if (this._overrideUpdate) {
      componentsManager.removeOnUpdateRenderers(this);
    }
    componentsManager.removeRenderer(this);
  };
  _proto._onDestroy = function _onDestroy() {
    var flag = this._transformChangeFlag;
    if (flag) {
      flag.destroy();
      this._transformChangeFlag = null;
    }
    this.shaderData._addRefCount(-1);
    for (var i = 0, n = this._materials.length; i < n; i++) {
      this._materials[i]._addRefCount(-1);
    }
  };
  _proto._updateBounds = function _updateBounds(worldBounds) {
  };
  _proto._createInstanceMaterial = function _createInstanceMaterial(material, index) {
    var insMaterial = material.clone();
    insMaterial.name = insMaterial.name + "(Instance)";
    material._addRefCount(-1);
    insMaterial._addRefCount(1);
    this._materialsInstanced[index] = true;
    this._materials[index] = insMaterial;
    return insMaterial;
  };
  _createClass(Renderer2, [{
    key: "materialCount",
    get: function get4() {
      return this._materials.length;
    },
    set: function set4(value) {
      var materials = this._materials;
      var materialsInstanced = this._materialsInstanced;
      materials.length !== value && (materials.length = value);
      materialsInstanced.length > value && (materialsInstanced.length = value);
    }
  }, {
    key: "bounds",
    get: function get4() {
      var changeFlag = this._transformChangeFlag;
      if (changeFlag.flag) {
        this._updateBounds(this._bounds);
        changeFlag.flag = false;
      }
      return this._bounds;
    }
  }]);
  return Renderer2;
}(Component), _class2$6._localMatrixProperty = Shader.getPropertyByName("u_localMat"), _class2$6._worldMatrixProperty = Shader.getPropertyByName("u_modelMat"), _class2$6._mvMatrixProperty = Shader.getPropertyByName("u_MVMat"), _class2$6._mvpMatrixProperty = Shader.getPropertyByName("u_MVPMat"), _class2$6._mvInvMatrixProperty = Shader.getPropertyByName("u_MVInvMat"), _class2$6._normalMatrixProperty = Shader.getPropertyByName("u_normalMat"), _temp$6), _descriptor$7 = _applyDecoratedDescriptor(_class$7.prototype, "shaderData", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer19() {
    return new ShaderData(ShaderDataGroup.Renderer);
  }
}), _descriptor2$7 = _applyDecoratedDescriptor(_class$7.prototype, "isCulled", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer20() {
    return false;
  }
}), _descriptor3$6 = _applyDecoratedDescriptor(_class$7.prototype, "_distanceForSort", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$6 = _applyDecoratedDescriptor(_class$7.prototype, "_onUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer21() {
    return -1;
  }
}), _descriptor5$6 = _applyDecoratedDescriptor(_class$7.prototype, "_rendererIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer22() {
    return -1;
  }
}), _descriptor6$6 = _applyDecoratedDescriptor(_class$7.prototype, "_globalShaderMacro", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer23() {
    return new ShaderMacroCollection();
  }
}), _descriptor7$4 = _applyDecoratedDescriptor(_class$7.prototype, "_renderSortId", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer24() {
    return 0;
  }
}), _descriptor8$2 = _applyDecoratedDescriptor(_class$7.prototype, "_overrideUpdate", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer25() {
    return false;
  }
}), _descriptor9$2 = _applyDecoratedDescriptor(_class$7.prototype, "_materials", [shallowClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer26() {
    return [];
  }
}), _descriptor10$2 = _applyDecoratedDescriptor(_class$7.prototype, "_transformChangeFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor11$2 = _applyDecoratedDescriptor(_class$7.prototype, "_bounds", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer27() {
    return new BoundingBox(new Vector3(), new Vector3());
  }
}), _descriptor12$2 = _applyDecoratedDescriptor(_class$7.prototype, "_mvMatrix", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer28() {
    return new Matrix();
  }
}), _descriptor13$1 = _applyDecoratedDescriptor(_class$7.prototype, "_mvpMatrix", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer29() {
    return new Matrix();
  }
}), _descriptor14 = _applyDecoratedDescriptor(_class$7.prototype, "_mvInvMatrix", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer30() {
    return new Matrix();
  }
}), _descriptor15 = _applyDecoratedDescriptor(_class$7.prototype, "_normalMatrix", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer31() {
    return new Matrix();
  }
}), _descriptor16 = _applyDecoratedDescriptor(_class$7.prototype, "_materialsInstanced", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer32() {
    return [];
  }
}), _class$7);
var SpriteMaskLayer;
(function(SpriteMaskLayer2) {
  SpriteMaskLayer2[SpriteMaskLayer2["Layer0"] = 1] = "Layer0";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer1"] = 2] = "Layer1";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer2"] = 4] = "Layer2";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer3"] = 8] = "Layer3";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer4"] = 16] = "Layer4";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer5"] = 32] = "Layer5";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer6"] = 64] = "Layer6";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer7"] = 128] = "Layer7";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer8"] = 256] = "Layer8";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer9"] = 512] = "Layer9";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer10"] = 1024] = "Layer10";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer11"] = 2048] = "Layer11";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer12"] = 4096] = "Layer12";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer13"] = 8192] = "Layer13";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer14"] = 16384] = "Layer14";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer15"] = 32768] = "Layer15";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer16"] = 65536] = "Layer16";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer17"] = 131072] = "Layer17";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer18"] = 262144] = "Layer18";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer19"] = 524288] = "Layer19";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer20"] = 1048576] = "Layer20";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer21"] = 2097152] = "Layer21";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer22"] = 4194304] = "Layer22";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer23"] = 8388608] = "Layer23";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer24"] = 16777216] = "Layer24";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer25"] = 33554432] = "Layer25";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer26"] = 67108864] = "Layer26";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer27"] = 134217728] = "Layer27";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer28"] = 268435456] = "Layer28";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer29"] = 536870912] = "Layer29";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer30"] = 1073741824] = "Layer30";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer31"] = 2147483648] = "Layer31";
  SpriteMaskLayer2[SpriteMaskLayer2["Everything"] = 4294967295] = "Everything";
})(SpriteMaskLayer || (SpriteMaskLayer = {}));
var _class$6;
var _descriptor$6;
var _descriptor2$6;
var _descriptor3$5;
var _descriptor4$5;
var _descriptor5$5;
var _descriptor6$5;
var _class2$5;
var _temp$5;
var SpriteMask = (_class$6 = (_temp$5 = _class2$5 = function(_Renderer) {
  _inheritsLoose(SpriteMask2, _Renderer);
  function SpriteMask2(entity) {
    var _this;
    _this = _Renderer.call(this, entity) || this;
    _this._maskElement = void 0;
    _initializerDefineProperty(_this, "_positions", _descriptor$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_isSpriteDirty", _descriptor2$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_worldMatrixDirtyFlag", _descriptor3$5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_sprite", _descriptor4$5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_alphaCutoff", _descriptor5$5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "influenceLayers", _descriptor6$5, _assertThisInitialized(_this));
    _this._worldMatrixDirtyFlag = entity.transform.registerWorldChangeFlag();
    _this.setMaterial(_this._engine._spriteMaskDefaultMaterial);
    _this.shaderData.setFloat(SpriteMask2._alphaCutoffProperty, _this._alphaCutoff);
    return _this;
  }
  var _proto = SpriteMask2.prototype;
  _proto._onDestroy = function _onDestroy() {
    this._worldMatrixDirtyFlag.destroy();
    _Renderer.prototype._onDestroy.call(this);
  };
  _proto._render = function _render(camera) {
    var sprite = this.sprite;
    if (!sprite) {
      return null;
    }
    var texture = sprite.texture;
    if (!texture) {
      return null;
    }
    var positions = this._positions;
    var transform = this.entity.transform;
    var localDirty = sprite._updateMeshData();
    if (this._worldMatrixDirtyFlag.flag || localDirty || this._isSpriteDirty) {
      var localPositions = sprite._positions;
      var localVertexPos = SpriteMask2._tempVec3;
      var worldMatrix = transform.worldMatrix;
      for (var i = 0, n = positions.length; i < n; i++) {
        var curVertexPos = localPositions[i];
        localVertexPos.setValue(curVertexPos.x, curVertexPos.y, 0);
        Vector3.transformToVec3(localVertexPos, worldMatrix, positions[i]);
      }
      this._isSpriteDirty = false;
      this._worldMatrixDirtyFlag.flag = false;
    }
    this.shaderData.setTexture(SpriteMask2._textureProperty, texture);
    var spriteMaskElementPool = this._engine._spriteMaskElementPool;
    var maskElement = spriteMaskElementPool.getFromPool();
    maskElement.setValue(this, positions, sprite._uv, sprite._triangles, this.getMaterial());
    maskElement.camera = camera;
    camera._renderPipeline._allSpriteMasks.add(this);
    this._maskElement = maskElement;
  };
  _createClass(SpriteMask2, [{
    key: "sprite",
    get: function get4() {
      return this._sprite;
    },
    set: function set4(value) {
      if (this._sprite !== value) {
        this._sprite = value;
        this._isSpriteDirty = true;
      }
    }
  }, {
    key: "alphaCutoff",
    get: function get4() {
      return this._alphaCutoff;
    },
    set: function set4(value) {
      if (this._alphaCutoff !== value) {
        this._alphaCutoff = value;
        this.shaderData.setFloat(SpriteMask2._alphaCutoffProperty, value);
      }
    }
  }]);
  return SpriteMask2;
}(Renderer), _class2$5._textureProperty = Shader.getPropertyByName("u_maskTexture"), _class2$5._alphaCutoffProperty = Shader.getPropertyByName("u_maskAlphaCutoff"), _class2$5._tempVec3 = new Vector3(), _temp$5), _descriptor$6 = _applyDecoratedDescriptor(_class$6.prototype, "_positions", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer33() {
    return [new Vector3(), new Vector3(), new Vector3(), new Vector3()];
  }
}), _descriptor2$6 = _applyDecoratedDescriptor(_class$6.prototype, "_isSpriteDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer34() {
    return true;
  }
}), _descriptor3$5 = _applyDecoratedDescriptor(_class$6.prototype, "_worldMatrixDirtyFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$5 = _applyDecoratedDescriptor(_class$6.prototype, "_sprite", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer35() {
    return null;
  }
}), _descriptor5$5 = _applyDecoratedDescriptor(_class$6.prototype, "_alphaCutoff", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer36() {
    return 0.5;
  }
}), _descriptor6$5 = _applyDecoratedDescriptor(_class$6.prototype, "influenceLayers", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer37() {
    return SpriteMaskLayer.Everything;
  }
}), _class$6);
var VertexElementFormat;
(function(VertexElementFormat2) {
  VertexElementFormat2[VertexElementFormat2["Float"] = 0] = "Float";
  VertexElementFormat2[VertexElementFormat2["Vector2"] = 1] = "Vector2";
  VertexElementFormat2[VertexElementFormat2["Vector3"] = 2] = "Vector3";
  VertexElementFormat2[VertexElementFormat2["Vector4"] = 3] = "Vector4";
  VertexElementFormat2[VertexElementFormat2["Byte4"] = 4] = "Byte4";
  VertexElementFormat2[VertexElementFormat2["UByte4"] = 5] = "UByte4";
  VertexElementFormat2[VertexElementFormat2["NormalizedByte4"] = 6] = "NormalizedByte4";
  VertexElementFormat2[VertexElementFormat2["NormalizedUByte4"] = 7] = "NormalizedUByte4";
  VertexElementFormat2[VertexElementFormat2["Short2"] = 8] = "Short2";
  VertexElementFormat2[VertexElementFormat2["UShort2"] = 9] = "UShort2";
  VertexElementFormat2[VertexElementFormat2["NormalizedShort2"] = 10] = "NormalizedShort2";
  VertexElementFormat2[VertexElementFormat2["NormalizedUShort2"] = 11] = "NormalizedUShort2";
  VertexElementFormat2[VertexElementFormat2["Short4"] = 12] = "Short4";
  VertexElementFormat2[VertexElementFormat2["UShort4"] = 13] = "UShort4";
  VertexElementFormat2[VertexElementFormat2["NormalizedShort4"] = 14] = "NormalizedShort4";
  VertexElementFormat2[VertexElementFormat2["NormalizedUShort4"] = 15] = "NormalizedUShort4";
})(VertexElementFormat || (VertexElementFormat = {}));
var BufferUsage;
(function(BufferUsage2) {
  BufferUsage2[BufferUsage2["Static"] = 0] = "Static";
  BufferUsage2[BufferUsage2["Dynamic"] = 1] = "Dynamic";
  BufferUsage2[BufferUsage2["Stream"] = 2] = "Stream";
})(BufferUsage || (BufferUsage = {}));
var IndexFormat;
(function(IndexFormat2) {
  IndexFormat2[IndexFormat2["UInt8"] = 0] = "UInt8";
  IndexFormat2[IndexFormat2["UInt16"] = 1] = "UInt16";
  IndexFormat2[IndexFormat2["UInt32"] = 2] = "UInt32";
})(IndexFormat || (IndexFormat = {}));
var BufferUtil = function() {
  function BufferUtil2() {
  }
  BufferUtil2._getGLBufferUsage = function _getGLBufferUsage(gl, bufferUsage) {
    switch (bufferUsage) {
      case BufferUsage.Static:
        return gl.STATIC_DRAW;
      case BufferUsage.Dynamic:
        return gl.DYNAMIC_DRAW;
      case BufferUsage.Stream:
        return gl.STREAM_DRAW;
    }
  };
  BufferUtil2._getGLIndexType = function _getGLIndexType(indexFormat) {
    switch (indexFormat) {
      case IndexFormat.UInt8:
        return DataType.UNSIGNED_BYTE;
      case IndexFormat.UInt16:
        return DataType.UNSIGNED_SHORT;
      case IndexFormat.UInt32:
        return DataType.UNSIGNED_INT;
    }
  };
  BufferUtil2._getGLIndexByteCount = function _getGLIndexByteCount(indexFormat) {
    switch (indexFormat) {
      case IndexFormat.UInt8:
        return 1;
      case IndexFormat.UInt16:
        return 2;
      case IndexFormat.UInt32:
        return 4;
    }
  };
  BufferUtil2._getElementInfo = function _getElementInfo(format) {
    var size;
    var type;
    var normalized = false;
    switch (format) {
      case VertexElementFormat.Float:
        size = 1;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Vector2:
        size = 2;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Vector3:
        size = 3;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Vector4:
        size = 4;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Byte4:
        size = 4;
        type = DataType.BYTE;
        break;
      case VertexElementFormat.UByte4:
        size = 4;
        type = DataType.UNSIGNED_BYTE;
        break;
      case VertexElementFormat.NormalizedByte4:
        size = 4;
        type = DataType.BYTE;
        normalized = true;
        break;
      case VertexElementFormat.NormalizedUByte4:
        size = 4;
        type = DataType.UNSIGNED_BYTE;
        normalized = true;
        break;
      case VertexElementFormat.Short2:
        size = 2;
        type = DataType.SHORT;
        break;
      case VertexElementFormat.UShort2:
        size = 2;
        type = DataType.UNSIGNED_SHORT;
        break;
      case VertexElementFormat.NormalizedShort2:
        size = 2;
        type = DataType.SHORT;
        normalized = true;
        break;
      case VertexElementFormat.NormalizedUShort2:
        size = 2;
        type = DataType.UNSIGNED_SHORT;
        normalized = true;
        break;
      case VertexElementFormat.Short4:
        size = 4;
        type = DataType.SHORT;
        break;
      case VertexElementFormat.UShort4:
        size = 4;
        type = DataType.UNSIGNED_SHORT;
        break;
      case VertexElementFormat.NormalizedShort4:
        size = 4;
        type = DataType.SHORT;
        normalized = true;
        break;
      case VertexElementFormat.NormalizedUShort4:
        size = 4;
        type = DataType.UNSIGNED_SHORT;
        normalized = true;
        break;
    }
    return {
      size,
      type,
      normalized
    };
  };
  return BufferUtil2;
}();
var VertexElement = function() {
  function VertexElement2(semantic, offset, format, bindingIndex, instanceStepRate) {
    if (instanceStepRate === void 0) {
      instanceStepRate = 0;
    }
    this._glElementInfo = void 0;
    this._semantic = void 0;
    this._offset = void 0;
    this._format = void 0;
    this._bindingIndex = void 0;
    this._instanceStepRate = void 0;
    this._semantic = semantic;
    this._offset = offset;
    this._format = format;
    this._bindingIndex = bindingIndex;
    this._glElementInfo = BufferUtil._getElementInfo(this.format);
    this._instanceStepRate = Math.floor(instanceStepRate);
  }
  _createClass(VertexElement2, [{
    key: "semantic",
    get: function get4() {
      return this._semantic;
    }
  }, {
    key: "offset",
    get: function get4() {
      return this._offset;
    }
  }, {
    key: "format",
    get: function get4() {
      return this._format;
    }
  }, {
    key: "bindingIndex",
    get: function get4() {
      return this._bindingIndex;
    }
  }, {
    key: "instanceStepRate",
    get: function get4() {
      return this._instanceStepRate;
    }
  }]);
  return VertexElement2;
}();
var BufferBindFlag;
(function(BufferBindFlag2) {
  BufferBindFlag2[BufferBindFlag2["VertexBuffer"] = 0] = "VertexBuffer";
  BufferBindFlag2[BufferBindFlag2["IndexBuffer"] = 1] = "IndexBuffer";
})(BufferBindFlag || (BufferBindFlag = {}));
var SetDataOptions;
(function(SetDataOptions2) {
  SetDataOptions2[SetDataOptions2["None"] = 0] = "None";
  SetDataOptions2[SetDataOptions2["Discard"] = 1] = "Discard";
})(SetDataOptions || (SetDataOptions = {}));
var Buffer = function(_RefObject) {
  _inheritsLoose(Buffer2, _RefObject);
  function Buffer2(engine, type, byteLengthOrData, bufferUsage) {
    var _this;
    if (bufferUsage === void 0) {
      bufferUsage = BufferUsage.Static;
    }
    _this = _RefObject.call(this, engine) || this;
    _this._glBindTarget = void 0;
    _this._glBufferUsage = void 0;
    _this._nativeBuffer = void 0;
    _this._hardwareRenderer = void 0;
    _this._type = void 0;
    _this._byteLength = void 0;
    _this._bufferUsage = void 0;
    _this._engine = engine;
    _this._type = type;
    _this._bufferUsage = bufferUsage;
    var hardwareRenderer = engine._hardwareRenderer;
    var gl = hardwareRenderer.gl;
    var glBufferUsage = BufferUtil._getGLBufferUsage(gl, bufferUsage);
    var glBindTarget = type === BufferBindFlag.VertexBuffer ? gl.ARRAY_BUFFER : gl.ELEMENT_ARRAY_BUFFER;
    _this._nativeBuffer = gl.createBuffer();
    _this._hardwareRenderer = hardwareRenderer;
    _this._glBufferUsage = glBufferUsage;
    _this._glBindTarget = glBindTarget;
    _this.bind();
    if (typeof byteLengthOrData === "number") {
      _this._byteLength = byteLengthOrData;
      gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);
    } else {
      _this._byteLength = byteLengthOrData.byteLength;
      gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);
    }
    gl.bindBuffer(glBindTarget, null);
    return _this;
  }
  var _proto = Buffer2.prototype;
  _proto.bind = function bind() {
    var gl = this._hardwareRenderer.gl;
    gl.bindBuffer(this._glBindTarget, this._nativeBuffer);
  };
  _proto.setData = function setData(data, bufferByteOffset, dataOffset, dataLength, options) {
    if (bufferByteOffset === void 0) {
      bufferByteOffset = 0;
    }
    if (dataOffset === void 0) {
      dataOffset = 0;
    }
    if (options === void 0) {
      options = SetDataOptions.None;
    }
    var gl = this._hardwareRenderer.gl;
    var isWebGL2 = this._hardwareRenderer.isWebGL2;
    var glBindTarget = this._glBindTarget;
    this.bind();
    if (options === SetDataOptions.Discard) {
      gl.bufferData(glBindTarget, this._byteLength, this._glBufferUsage);
    }
    var byteSize = data.BYTES_PER_ELEMENT || 1;
    var dataByteLength = dataLength ? byteSize * dataLength : data.byteLength;
    if (dataOffset !== 0 || dataByteLength < data.byteLength) {
      var isArrayBufferView = data.byteOffset !== void 0;
      if (isWebGL2 && isArrayBufferView) {
        gl.bufferSubData(glBindTarget, bufferByteOffset, data, dataOffset, dataByteLength / byteSize);
      } else {
        var subData = new Uint8Array(isArrayBufferView ? data.buffer : data, dataOffset * byteSize, dataByteLength);
        gl.bufferSubData(glBindTarget, bufferByteOffset, subData);
      }
    } else {
      gl.bufferSubData(glBindTarget, bufferByteOffset, data);
    }
    gl.bindBuffer(glBindTarget, null);
  };
  _proto.getData = function getData(data, bufferByteOffset, dataOffset, dataLength) {
    if (bufferByteOffset === void 0) {
      bufferByteOffset = 0;
    }
    if (dataOffset === void 0) {
      dataOffset = 0;
    }
    var isWebGL2 = this._hardwareRenderer.isWebGL2;
    if (isWebGL2) {
      var gl = this._hardwareRenderer.gl;
      this.bind();
      gl.getBufferSubData(this._glBindTarget, bufferByteOffset, data, dataOffset, dataLength);
    } else {
      throw "Buffer is write-only on WebGL1.0 platforms.";
    }
  };
  _proto._onDestroy = function _onDestroy() {
    var gl = this._hardwareRenderer.gl;
    gl.deleteBuffer(this._nativeBuffer);
    this._nativeBuffer = null;
    this._hardwareRenderer = null;
  };
  _proto.resize = function resize(dataLength) {
    this.bind();
    var gl = this._hardwareRenderer.gl;
    gl.bufferData(this._glBindTarget, dataLength, this._glBufferUsage);
    this._byteLength = dataLength;
  };
  _createClass(Buffer2, [{
    key: "type",
    get: function get4() {
      return this._type;
    }
  }, {
    key: "byteLength",
    get: function get4() {
      return this._byteLength;
    }
  }, {
    key: "bufferUsage",
    get: function get4() {
      return this._bufferUsage;
    }
  }]);
  return Buffer2;
}(RefObject);
var MeshTopology;
(function(MeshTopology2) {
  MeshTopology2[MeshTopology2["Points"] = 0] = "Points";
  MeshTopology2[MeshTopology2["Lines"] = 1] = "Lines";
  MeshTopology2[MeshTopology2["LineLoop"] = 2] = "LineLoop";
  MeshTopology2[MeshTopology2["LineStrip"] = 3] = "LineStrip";
  MeshTopology2[MeshTopology2["Triangles"] = 4] = "Triangles";
  MeshTopology2[MeshTopology2["TriangleStrip"] = 5] = "TriangleStrip";
  MeshTopology2[MeshTopology2["TriangleFan"] = 6] = "TriangleFan";
})(MeshTopology || (MeshTopology = {}));
var IndexBufferBinding = function() {
  function IndexBufferBinding2(buffer, format) {
    this._buffer = void 0;
    this._format = void 0;
    this._buffer = buffer;
    this._format = format;
  }
  _createClass(IndexBufferBinding2, [{
    key: "buffer",
    get: function get4() {
      return this._buffer;
    }
  }, {
    key: "format",
    get: function get4() {
      return this._format;
    }
  }]);
  return IndexBufferBinding2;
}();
var SubMesh = function SubMesh2(start, count, topology) {
  if (start === void 0) {
    start = 0;
  }
  if (count === void 0) {
    count = 0;
  }
  if (topology === void 0) {
    topology = MeshTopology.Triangles;
  }
  this.start = void 0;
  this.count = void 0;
  this.topology = void 0;
  this.start = start;
  this.count = count;
  this.topology = topology;
};
var Mesh = function(_RefObject) {
  _inheritsLoose(Mesh2, _RefObject);
  function Mesh2(engine, name) {
    var _this;
    _this = _RefObject.call(this, engine) || this;
    _this.name = void 0;
    _this.bounds = new BoundingBox();
    _this._vertexElementMap = {};
    _this._glIndexType = void 0;
    _this._glIndexByteCount = void 0;
    _this._platformPrimitive = void 0;
    _this._instanceCount = 0;
    _this._vertexBufferBindings = [];
    _this._indexBufferBinding = null;
    _this._vertexElements = [];
    _this._subMeshes = [];
    _this._updateFlagManager = new UpdateFlagManager();
    _this.name = name;
    _this._platformPrimitive = _this._engine._hardwareRenderer.createPlatformPrimitive(_assertThisInitialized(_this));
    return _this;
  }
  var _proto = Mesh2.prototype;
  _proto.addSubMesh = function addSubMesh(startOrSubMesh, count, topology) {
    if (topology === void 0) {
      topology = MeshTopology.Triangles;
    }
    if (typeof startOrSubMesh === "number") {
      startOrSubMesh = new SubMesh(startOrSubMesh, count, topology);
    }
    this._subMeshes.push(startOrSubMesh);
    return startOrSubMesh;
  };
  _proto.removeSubMesh = function removeSubMesh(subMesh) {
    var subMeshes = this._subMeshes;
    var index = subMeshes.indexOf(subMesh);
    if (index !== -1) {
      subMeshes.splice(index, 1);
    }
  };
  _proto.clearSubMesh = function clearSubMesh() {
    this._subMeshes.length = 0;
  };
  _proto.registerUpdateFlag = function registerUpdateFlag() {
    return this._updateFlagManager.register();
  };
  _proto._draw = function _draw(shaderProgram, subMesh) {
    this._platformPrimitive.draw(shaderProgram, subMesh);
  };
  _proto._addRefCount = function _addRefCount(value) {
    _RefObject.prototype._addRefCount.call(this, value);
    var vertexBufferBindings = this._vertexBufferBindings;
    for (var i = 0, n = vertexBufferBindings.length; i < n; i++) {
      vertexBufferBindings[i]._buffer._addRefCount(value);
    }
  };
  _proto._onDestroy = function _onDestroy() {
    this._vertexBufferBindings = null;
    this._indexBufferBinding = null;
    this._vertexElements = null;
    this._vertexElementMap = null;
    this._platformPrimitive.destroy();
  };
  _proto._setVertexElements = function _setVertexElements(elements) {
    this._clearVertexElements();
    for (var i = 0, n = elements.length; i < n; i++) {
      this._addVertexElement(elements[i]);
    }
  };
  _proto._setVertexBufferBinding = function _setVertexBufferBinding(index, binding) {
    if (this._getRefCount() > 0) {
      var lastBinding = this._vertexBufferBindings[index];
      lastBinding && lastBinding._buffer._addRefCount(-1);
      binding._buffer._addRefCount(1);
    }
    this._vertexBufferBindings[index] = binding;
  };
  _proto._setIndexBufferBinding = function _setIndexBufferBinding(binding) {
    if (binding) {
      this._indexBufferBinding = binding;
      this._glIndexType = BufferUtil._getGLIndexType(binding.format);
      this._glIndexByteCount = BufferUtil._getGLIndexByteCount(binding.format);
    } else {
      this._indexBufferBinding = null;
      this._glIndexType = void 0;
    }
  };
  _proto._clearVertexElements = function _clearVertexElements() {
    this._vertexElements.length = 0;
    var vertexElementMap = this._vertexElementMap;
    for (var k in vertexElementMap) {
      delete vertexElementMap[k];
    }
  };
  _proto._addVertexElement = function _addVertexElement(element) {
    var semantic = element.semantic;
    this._vertexElementMap[semantic] = element;
    this._vertexElements.push(element);
    this._updateFlagManager.distribute();
  };
  _createClass(Mesh2, [{
    key: "subMesh",
    get: function get4() {
      return this._subMeshes[0] || null;
    }
  }, {
    key: "subMeshes",
    get: function get4() {
      return this._subMeshes;
    }
  }]);
  return Mesh2;
}(RefObject);
var VertexBufferBinding = function() {
  function VertexBufferBinding2(buffer, stride) {
    this._buffer = void 0;
    this._stride = void 0;
    this._buffer = buffer;
    this._stride = stride;
  }
  _createClass(VertexBufferBinding2, [{
    key: "buffer",
    get: function get4() {
      return this._buffer;
    }
  }, {
    key: "stride",
    get: function get4() {
      return this._stride;
    }
  }]);
  return VertexBufferBinding2;
}();
var TextureFilterMode;
(function(TextureFilterMode2) {
  TextureFilterMode2[TextureFilterMode2["Point"] = 0] = "Point";
  TextureFilterMode2[TextureFilterMode2["Bilinear"] = 1] = "Bilinear";
  TextureFilterMode2[TextureFilterMode2["Trilinear"] = 2] = "Trilinear";
})(TextureFilterMode || (TextureFilterMode = {}));
var TextureFormat;
(function(TextureFormat2) {
  TextureFormat2[TextureFormat2["R8G8B8"] = 0] = "R8G8B8";
  TextureFormat2[TextureFormat2["R8G8B8A8"] = 1] = "R8G8B8A8";
  TextureFormat2[TextureFormat2["R4G4B4A4"] = 2] = "R4G4B4A4";
  TextureFormat2[TextureFormat2["R5G5B5A1"] = 3] = "R5G5B5A1";
  TextureFormat2[TextureFormat2["R5G6B5"] = 4] = "R5G6B5";
  TextureFormat2[TextureFormat2["Alpha8"] = 5] = "Alpha8";
  TextureFormat2[TextureFormat2["LuminanceAlpha"] = 6] = "LuminanceAlpha";
  TextureFormat2[TextureFormat2["R32G32B32A32"] = 7] = "R32G32B32A32";
  TextureFormat2[TextureFormat2["DXT1"] = 8] = "DXT1";
  TextureFormat2[TextureFormat2["DXT5"] = 9] = "DXT5";
  TextureFormat2[TextureFormat2["ETC1_RGB"] = 10] = "ETC1_RGB";
  TextureFormat2[TextureFormat2["ETC2_RGB"] = 11] = "ETC2_RGB";
  TextureFormat2[TextureFormat2["ETC2_RGBA5"] = 12] = "ETC2_RGBA5";
  TextureFormat2[TextureFormat2["ETC2_RGBA8"] = 13] = "ETC2_RGBA8";
  TextureFormat2[TextureFormat2["PVRTC_RGB2"] = 14] = "PVRTC_RGB2";
  TextureFormat2[TextureFormat2["PVRTC_RGBA2"] = 15] = "PVRTC_RGBA2";
  TextureFormat2[TextureFormat2["PVRTC_RGB4"] = 16] = "PVRTC_RGB4";
  TextureFormat2[TextureFormat2["PVRTC_RGBA4"] = 17] = "PVRTC_RGBA4";
  TextureFormat2[TextureFormat2["ASTC_4x4"] = 18] = "ASTC_4x4";
  TextureFormat2[TextureFormat2["ASTC_5x5"] = 19] = "ASTC_5x5";
  TextureFormat2[TextureFormat2["ASTC_6x6"] = 20] = "ASTC_6x6";
  TextureFormat2[TextureFormat2["ASTC_8x8"] = 21] = "ASTC_8x8";
  TextureFormat2[TextureFormat2["ASTC_10x10"] = 22] = "ASTC_10x10";
  TextureFormat2[TextureFormat2["ASTC_12x12"] = 23] = "ASTC_12x12";
})(TextureFormat || (TextureFormat = {}));
var TextureWrapMode;
(function(TextureWrapMode3) {
  TextureWrapMode3[TextureWrapMode3["Clamp"] = 0] = "Clamp";
  TextureWrapMode3[TextureWrapMode3["Repeat"] = 1] = "Repeat";
  TextureWrapMode3[TextureWrapMode3["Mirror"] = 2] = "Mirror";
})(TextureWrapMode || (TextureWrapMode = {}));
var Texture2D = function(_Texture) {
  _inheritsLoose(Texture2D2, _Texture);
  function Texture2D2(engine, width, height, format, mipmap) {
    var _this;
    if (format === void 0) {
      format = TextureFormat.R8G8B8A8;
    }
    if (mipmap === void 0) {
      mipmap = true;
    }
    _this = _Texture.call(this, engine) || this;
    _this._format = void 0;
    _this._mipmap = mipmap;
    _this._width = width;
    _this._height = height;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    _this._platformTexture = engine._hardwareRenderer.createPlatformTexture2D(_assertThisInitialized(_this));
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode.Repeat;
    return _this;
  }
  var _proto = Texture2D2.prototype;
  _proto.setPixelBuffer = function setPixelBuffer(colorBuffer, mipLevel, x, y, width, height) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    this._platformTexture.setPixelBuffer(colorBuffer, mipLevel, x, y, width, height);
  };
  _proto.setImageSource = function setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    if (flipY === void 0) {
      flipY = false;
    }
    if (premultiplyAlpha === void 0) {
      premultiplyAlpha = false;
    }
    this._platformTexture.setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
  };
  _proto.getPixelBuffer = function getPixelBuffer(x, y, width, height, out) {
    this._platformTexture.getPixelBuffer(x, y, width, height, out);
  };
  _createClass(Texture2D2, [{
    key: "format",
    get: function get4() {
      return this._format;
    }
  }]);
  return Texture2D2;
}(Texture);
var RenderBufferColorFormat;
(function(RenderBufferColorFormat2) {
  RenderBufferColorFormat2[RenderBufferColorFormat2["R8G8B8"] = 0] = "R8G8B8";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R8G8B8A8"] = 1] = "R8G8B8A8";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R4G4B4A4"] = 2] = "R4G4B4A4";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R5G5B5A1"] = 3] = "R5G5B5A1";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R5G6B5"] = 4] = "R5G6B5";
  RenderBufferColorFormat2[RenderBufferColorFormat2["Alpha8"] = 5] = "Alpha8";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R16G16B16A16"] = 6] = "R16G16B16A16";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R32G32B32A32"] = 7] = "R32G32B32A32";
})(RenderBufferColorFormat || (RenderBufferColorFormat = {}));
var RenderBufferDepthFormat;
(function(RenderBufferDepthFormat2) {
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth"] = 0] = "Depth";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["DepthStencil"] = 1] = "DepthStencil";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Stencil"] = 2] = "Stencil";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth16"] = 3] = "Depth16";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth24"] = 4] = "Depth24";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth32"] = 5] = "Depth32";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth24Stencil8"] = 6] = "Depth24Stencil8";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth32Stencil8"] = 7] = "Depth32Stencil8";
})(RenderBufferDepthFormat || (RenderBufferDepthFormat = {}));
var TextureCubeFace;
(function(TextureCubeFace2) {
  TextureCubeFace2[TextureCubeFace2["PositiveX"] = 0] = "PositiveX";
  TextureCubeFace2[TextureCubeFace2["NegativeX"] = 1] = "NegativeX";
  TextureCubeFace2[TextureCubeFace2["PositiveY"] = 2] = "PositiveY";
  TextureCubeFace2[TextureCubeFace2["NegativeY"] = 3] = "NegativeY";
  TextureCubeFace2[TextureCubeFace2["PositiveZ"] = 4] = "PositiveZ";
  TextureCubeFace2[TextureCubeFace2["NegativeZ"] = 5] = "NegativeZ";
})(TextureCubeFace || (TextureCubeFace = {}));
var TextureCubeMap = function(_Texture) {
  _inheritsLoose(TextureCubeMap2, _Texture);
  function TextureCubeMap2(engine, size, format, mipmap) {
    var _this;
    if (format === void 0) {
      format = TextureFormat.R8G8B8A8;
    }
    if (mipmap === void 0) {
      mipmap = true;
    }
    _this = _Texture.call(this, engine) || this;
    _this._format = void 0;
    _this._mipmap = mipmap;
    _this._width = size;
    _this._height = size;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    _this._platformTexture = engine._hardwareRenderer.createPlatformTextureCubeMap(_assertThisInitialized(_this));
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode.Clamp;
    return _this;
  }
  var _proto = TextureCubeMap2.prototype;
  _proto.setPixelBuffer = function setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    this._platformTexture.setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height);
  };
  _proto.setImageSource = function setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    if (flipY === void 0) {
      flipY = false;
    }
    if (premultiplyAlpha === void 0) {
      premultiplyAlpha = false;
    }
    this._platformTexture.setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
  };
  _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, out) {
    this._platformTexture.getPixelBuffer(face, x, y, width, height, out);
  };
  _createClass(TextureCubeMap2, [{
    key: "format",
    get: function get4() {
      return this._format;
    }
  }]);
  return TextureCubeMap2;
}(Texture);
var RenderDepthTexture = function(_Texture) {
  _inheritsLoose(RenderDepthTexture2, _Texture);
  function RenderDepthTexture2(engine, width, height, format, mipmap, isCube) {
    var _this;
    if (format === void 0) {
      format = RenderBufferDepthFormat.Depth;
    }
    if (mipmap === void 0) {
      mipmap = false;
    }
    if (isCube === void 0) {
      isCube = false;
    }
    _this = _Texture.call(this, engine) || this;
    _this._autoMipmap = false;
    _this._format = void 0;
    _this._isCube = false;
    _this._isCube = isCube;
    _this._mipmap = mipmap;
    _this._width = width;
    _this._height = height;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    _this._platformTexture = engine._hardwareRenderer.createPlatformRenderDepthTexture(_assertThisInitialized(_this));
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode.Clamp;
    return _this;
  }
  _createClass(RenderDepthTexture2, [{
    key: "format",
    get: function get4() {
      return this._format;
    }
  }, {
    key: "isCube",
    get: function get4() {
      return this._isCube;
    }
  }, {
    key: "autoGenerateMipmaps",
    get: function get4() {
      return this._autoMipmap;
    },
    set: function set4(value) {
      this._autoMipmap = value;
    }
  }]);
  return RenderDepthTexture2;
}(Texture);
var RenderTarget = function(_EngineObject) {
  _inheritsLoose(RenderTarget2, _EngineObject);
  function RenderTarget2(engine, width, height, renderTexture, depth, antiAliasing) {
    var _this;
    if (depth === void 0) {
      depth = RenderBufferDepthFormat.Depth;
    }
    if (antiAliasing === void 0) {
      antiAliasing = 1;
    }
    _this = _EngineObject.call(this, engine) || this;
    _this._platformRenderTarget = void 0;
    _this._colorTextures = void 0;
    _this._depth = void 0;
    _this._antiAliasing = void 0;
    _this._width = void 0;
    _this._height = void 0;
    _this._depthTexture = void 0;
    _this._width = width;
    _this._height = height;
    _this._antiAliasing = antiAliasing;
    _this._depth = depth;
    if (renderTexture) {
      _this._colorTextures = renderTexture instanceof Array ? renderTexture.slice() : [renderTexture];
    } else {
      _this._colorTextures = [];
    }
    if (depth instanceof RenderDepthTexture) {
      _this._depthTexture = depth;
    }
    _this._platformRenderTarget = engine._hardwareRenderer.createPlatformRenderTarget(_assertThisInitialized(_this));
    return _this;
  }
  var _proto = RenderTarget2.prototype;
  _proto.getColorTexture = function getColorTexture(index) {
    if (index === void 0) {
      index = 0;
    }
    return this._colorTextures[index];
  };
  _proto.generateMipmaps = function generateMipmaps() {
    var _this$_depthTexture;
    var colorTextureCount = this.colorTextureCount;
    if ((_this$_depthTexture = this._depthTexture) !== null && _this$_depthTexture !== void 0 && _this$_depthTexture.autoGenerateMipmaps) {
      this._depthTexture.generateMipmaps();
    }
    for (var i = 0; i < colorTextureCount; i++) {
      var _colorTexture = this._colorTextures[i];
      if (_colorTexture.autoGenerateMipmaps) {
        _colorTexture.generateMipmaps();
      }
    }
  };
  _proto.destroy = function destroy() {
    this._platformRenderTarget.destroy();
    this._colorTextures.length = 0;
    this._depthTexture = null;
    this._depth = null;
  };
  _proto._setRenderTargetFace = function _setRenderTargetFace(faceIndex) {
    this._platformRenderTarget.setRenderTargetFace(faceIndex);
  };
  _proto._blitRenderTarget = function _blitRenderTarget() {
    this._platformRenderTarget.blitRenderTarget();
  };
  _createClass(RenderTarget2, [{
    key: "width",
    get: function get4() {
      return this._width;
    }
  }, {
    key: "height",
    get: function get4() {
      return this._height;
    }
  }, {
    key: "colorTextureCount",
    get: function get4() {
      return this._colorTextures.length;
    }
  }, {
    key: "depthTexture",
    get: function get4() {
      return this._depthTexture;
    }
  }, {
    key: "antiAliasing",
    get: function get4() {
      return this._antiAliasing;
    }
  }]);
  return RenderTarget2;
}(EngineObject);
var RenderColorTexture = function(_Texture) {
  _inheritsLoose(RenderColorTexture2, _Texture);
  function RenderColorTexture2(engine, width, height, format, mipmap, isCube) {
    var _this;
    if (format === void 0) {
      format = RenderBufferColorFormat.R8G8B8A8;
    }
    if (mipmap === void 0) {
      mipmap = false;
    }
    if (isCube === void 0) {
      isCube = false;
    }
    _this = _Texture.call(this, engine) || this;
    _this._autoMipmap = false;
    _this._format = void 0;
    _this._isCube = false;
    _this._isCube = isCube;
    _this._mipmap = mipmap;
    _this._width = width;
    _this._height = height;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    _this._platformTexture = engine._hardwareRenderer.createPlatformRenderColorTexture(_assertThisInitialized(_this));
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode.Clamp;
    return _this;
  }
  var _proto = RenderColorTexture2.prototype;
  _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, out) {
    this._platformTexture.getPixelBuffer(face, x, y, width, height, out);
  };
  _createClass(RenderColorTexture2, [{
    key: "format",
    get: function get4() {
      return this._format;
    }
  }, {
    key: "isCube",
    get: function get4() {
      return this._isCube;
    }
  }, {
    key: "autoGenerateMipmaps",
    get: function get4() {
      return this._autoMipmap;
    },
    set: function set4(value) {
      this._autoMipmap = value;
    }
  }]);
  return RenderColorTexture2;
}(Texture);
var ModelMesh = function(_Mesh) {
  _inheritsLoose(ModelMesh2, _Mesh);
  function ModelMesh2(engine, name) {
    var _this;
    _this = _Mesh.call(this, engine) || this;
    _this._hasBlendShape = false;
    _this._useBlendShapeNormal = false;
    _this._useBlendShapeTangent = false;
    _this._blendShapeTexture = void 0;
    _this._vertexCount = 0;
    _this._accessible = true;
    _this._verticesFloat32 = null;
    _this._verticesUint8 = null;
    _this._indices = null;
    _this._indicesFormat = null;
    _this._vertexSlotChanged = true;
    _this._vertexChangeFlag = 0;
    _this._indicesChangeFlag = false;
    _this._elementCount = 0;
    _this._vertexElementsCache = [];
    _this._positions = [];
    _this._normals = null;
    _this._colors = null;
    _this._tangents = null;
    _this._uv = null;
    _this._uv1 = null;
    _this._uv2 = null;
    _this._uv3 = null;
    _this._uv4 = null;
    _this._uv5 = null;
    _this._uv6 = null;
    _this._uv7 = null;
    _this._boneWeights = null;
    _this._boneIndices = null;
    _this._blendShapes = [];
    _this._blendShapeUpdateFlags = [];
    _this.name = name;
    return _this;
  }
  var _proto = ModelMesh2.prototype;
  _proto.setPositions = function setPositions(positions) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    var count = positions.length;
    this._positions = positions;
    this._vertexChangeFlag |= ValueChanged.Position;
    if (this._vertexCount !== count) {
      this._vertexCount = count;
    }
  };
  _proto.getPositions = function getPositions() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._positions;
  };
  _proto.setNormals = function setNormals(normals) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    if (normals.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }
    this._vertexSlotChanged = !!this._normals !== !!normals;
    this._vertexChangeFlag |= ValueChanged.Normal;
    this._normals = normals;
  };
  _proto.getNormals = function getNormals() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._normals;
  };
  _proto.setColors = function setColors(colors) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    if (colors.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }
    this._vertexSlotChanged = !!this._colors !== !!colors;
    this._vertexChangeFlag |= ValueChanged.Color;
    this._colors = colors;
  };
  _proto.getColors = function getColors() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._colors;
  };
  _proto.setBoneWeights = function setBoneWeights(boneWeights) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    if (boneWeights.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }
    this._vertexSlotChanged = boneWeights != null;
    this._vertexChangeFlag |= ValueChanged.BoneWeight;
    this._boneWeights = boneWeights;
  };
  _proto.getBoneWeights = function getBoneWeights() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._boneWeights;
  };
  _proto.setBoneIndices = function setBoneIndices(boneIndices) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    if (boneIndices.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }
    this._vertexSlotChanged = !!this._boneIndices !== !!boneIndices;
    this._vertexChangeFlag |= ValueChanged.BoneIndex;
    this._boneIndices = boneIndices;
  };
  _proto.getBoneIndices = function getBoneIndices() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._boneIndices;
  };
  _proto.setTangents = function setTangents(tangents) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    if (tangents.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }
    this._vertexSlotChanged = !!this._tangents !== !!tangents;
    this._vertexChangeFlag |= ValueChanged.Tangent;
    this._tangents = tangents;
  };
  _proto.getTangents = function getTangents() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._tangents;
  };
  _proto.setUVs = function setUVs(uv, channelIndex) {
    var _channelIndex;
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    if (uv.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }
    channelIndex = (_channelIndex = channelIndex) != null ? _channelIndex : 0;
    switch (channelIndex) {
      case 0:
        this._vertexSlotChanged = !!this._uv !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV;
        this._uv = uv;
        break;
      case 1:
        this._vertexSlotChanged = !!this._uv1 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV1;
        this._uv1 = uv;
        break;
      case 2:
        this._vertexSlotChanged = !!this._uv2 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV2;
        this._uv2 = uv;
        break;
      case 3:
        this._vertexSlotChanged = !!this._uv3 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV3;
        this._uv3 = uv;
        break;
      case 4:
        this._vertexSlotChanged = !!this._uv4 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV4;
        this._uv4 = uv;
        break;
      case 5:
        this._vertexSlotChanged = !!this._uv5 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV5;
        this._uv5 = uv;
        break;
      case 6:
        this._vertexSlotChanged = !!this._uv6 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV6;
        this._uv6 = uv;
        break;
      case 7:
        this._vertexSlotChanged = !!this._uv7 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV7;
        this._uv7 = uv;
        break;
      default:
        throw "The index of channel needs to be in range [0 - 7].";
    }
  };
  _proto.getUVs = function getUVs(channelIndex) {
    var _channelIndex2;
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    channelIndex = (_channelIndex2 = channelIndex) != null ? _channelIndex2 : 0;
    switch (channelIndex) {
      case 0:
        return this._uv;
      case 1:
        return this._uv1;
      case 2:
        return this._uv2;
      case 3:
        return this._uv3;
      case 4:
        return this._uv4;
      case 5:
        return this._uv5;
      case 6:
        return this._uv6;
      case 7:
        return this._uv7;
    }
    throw "The index of channel needs to be in range [0 - 7].";
  };
  _proto.setIndices = function setIndices(indices) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    if (this._indices !== indices) {
      this._indices = indices;
      if (indices instanceof Uint8Array) {
        this._indicesFormat = IndexFormat.UInt8;
      } else if (indices instanceof Uint16Array) {
        this._indicesFormat = IndexFormat.UInt16;
      } else if (indices instanceof Uint32Array) {
        this._indicesFormat = IndexFormat.UInt32;
      }
    }
    this._indicesChangeFlag = true;
  };
  _proto.getIndices = function getIndices() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._indices;
  };
  _proto.addBlendShape = function addBlendShape(blendShape) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    this._vertexChangeFlag |= ValueChanged.BlendShape;
    this._useBlendShapeNormal = this._useBlendShapeNormal || blendShape._useBlendShapeNormal;
    this._useBlendShapeTangent = this._useBlendShapeTangent || blendShape._useBlendShapeTangent;
    this._blendShapes.push(blendShape);
    this._blendShapeUpdateFlags.push(blendShape._registerChangeFlag());
    this._hasBlendShape = true;
  };
  _proto.clearBlendShapes = function clearBlendShapes() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    this._vertexChangeFlag |= ValueChanged.BlendShape;
    this._useBlendShapeNormal = false;
    this._useBlendShapeTangent = false;
    this._blendShapes.length = 0;
    var blendShapeUpdateFlags = this._blendShapeUpdateFlags;
    for (var i = 0, n = blendShapeUpdateFlags.length; i < n; i++) {
      blendShapeUpdateFlags[i].destroy();
    }
    blendShapeUpdateFlags.length = 0;
    this._hasBlendShape = false;
  };
  _proto.uploadData = function uploadData(noLongerAccessible) {
    var _vertexBufferBindings, _this$_indexBufferBin;
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }
    var _indices = this._indices;
    if (this._vertexSlotChanged) {
      var vertexElements = this._updateVertexElements();
      this._setVertexElements(vertexElements);
      this._vertexChangeFlag = ValueChanged.All;
      this._vertexSlotChanged = false;
    }
    var vertexBufferBindings = this._vertexBufferBindings;
    var elementCount = this._elementCount;
    var vertexBuffer = (_vertexBufferBindings = vertexBufferBindings[0]) === null || _vertexBufferBindings === void 0 ? void 0 : _vertexBufferBindings._buffer;
    var vertexFloatCount = elementCount * this._vertexCount;
    if (!vertexBuffer || this._verticesFloat32.length !== vertexFloatCount) {
      vertexBuffer === null || vertexBuffer === void 0 ? void 0 : vertexBuffer.destroy();
      var vertices = new Float32Array(vertexFloatCount);
      this._verticesFloat32 = vertices;
      this._verticesUint8 = new Uint8Array(vertices.buffer);
      this._vertexChangeFlag = ValueChanged.All;
      this._updateVertices(vertices);
      var newVertexBuffer = new Buffer(this._engine, BufferBindFlag.VertexBuffer, vertices, noLongerAccessible ? BufferUsage.Static : BufferUsage.Dynamic);
      this._setVertexBufferBinding(0, new VertexBufferBinding(newVertexBuffer, elementCount * 4));
    } else if (this._vertexChangeFlag & ValueChanged.All) {
      var _vertices = this._verticesFloat32;
      this._updateVertices(_vertices);
      vertexBuffer.setData(_vertices);
    }
    var indexBuffer = (_this$_indexBufferBin = this._indexBufferBinding) === null || _this$_indexBufferBin === void 0 ? void 0 : _this$_indexBufferBin._buffer;
    if (_indices) {
      if (!indexBuffer || _indices.byteLength != indexBuffer.byteLength) {
        indexBuffer === null || indexBuffer === void 0 ? void 0 : indexBuffer.destroy();
        var newIndexBuffer = new Buffer(this._engine, BufferBindFlag.IndexBuffer, _indices);
        this._setIndexBufferBinding(new IndexBufferBinding(newIndexBuffer, this._indicesFormat));
      } else if (this._indicesChangeFlag) {
        this._indicesChangeFlag = false;
        indexBuffer.setData(_indices);
        if (this._indexBufferBinding._format !== this._indicesFormat) {
          this._setIndexBufferBinding(new IndexBufferBinding(indexBuffer, this._indicesFormat));
        }
      }
    } else if (indexBuffer) {
      indexBuffer.destroy();
      this._setIndexBufferBinding(null);
    }
    if (noLongerAccessible) {
      this._accessible = false;
      this._releaseCache();
    }
  };
  _proto._onDestroy = function _onDestroy() {
    _Mesh.prototype._onDestroy.call(this);
    this._accessible && this._releaseCache();
  };
  _proto._updateVertexElements = function _updateVertexElements() {
    var vertexElements = this._vertexElementsCache;
    vertexElements.length = 1;
    vertexElements[0] = POSITION_VERTEX_ELEMENT;
    var offset = 12;
    var elementCount = 3;
    if (this._normals) {
      vertexElements.push(new VertexElement("NORMAL", offset, VertexElementFormat.Vector3, 0));
      offset += 12;
      elementCount += 3;
    }
    if (this._colors) {
      vertexElements.push(new VertexElement("COLOR_0", offset, VertexElementFormat.Vector4, 0));
      offset += 16;
      elementCount += 4;
    }
    if (this._boneWeights) {
      vertexElements.push(new VertexElement("WEIGHTS_0", offset, VertexElementFormat.Vector4, 0));
      offset += 16;
      elementCount += 4;
    }
    if (this._boneIndices) {
      vertexElements.push(new VertexElement("JOINTS_0", offset, VertexElementFormat.UByte4, 0));
      offset += 4;
      elementCount += 1;
    }
    if (this._tangents) {
      vertexElements.push(new VertexElement("TANGENT", offset, VertexElementFormat.Vector4, 0));
      offset += 16;
      elementCount += 4;
    }
    if (this._uv) {
      vertexElements.push(new VertexElement("TEXCOORD_0", offset, VertexElementFormat.Vector2, 0));
      offset += 8;
      elementCount += 2;
    }
    if (this._uv1) {
      vertexElements.push(new VertexElement("TEXCOORD_1", offset, VertexElementFormat.Vector2, 0));
      offset += 8;
      elementCount += 2;
    }
    if (this._uv2) {
      vertexElements.push(new VertexElement("TEXCOORD_2", offset, VertexElementFormat.Vector2, 0));
      offset += 8;
      elementCount += 2;
    }
    if (this._uv3) {
      vertexElements.push(new VertexElement("TEXCOORD_3", offset, VertexElementFormat.Vector2, 0));
      offset += 8;
      elementCount += 2;
    }
    if (this._uv4) {
      vertexElements.push(new VertexElement("TEXCOORD_4", offset, VertexElementFormat.Vector2, 0));
      offset += 8;
      elementCount += 2;
    }
    if (this._uv5) {
      vertexElements.push(new VertexElement("TEXCOORD_5", offset, VertexElementFormat.Vector2, 0));
      offset += 8;
      elementCount += 2;
    }
    if (this._uv6) {
      vertexElements.push(new VertexElement("TEXCOORD_6", offset, VertexElementFormat.Vector2, 0));
      offset += 8;
      elementCount += 2;
    }
    if (this._uv7) {
      vertexElements.push(new VertexElement("TEXCOORD_7", offset, VertexElementFormat.Vector2, 0));
      offset += 8;
      elementCount += 2;
    }
    var blendShapeCount = Math.min(this._blendShapes.length, 4);
    for (var i = 0, n = blendShapeCount; i < n; i++) {
      vertexElements.push(new VertexElement("POSITION_BS" + i, offset, VertexElementFormat.Vector3, 0));
      offset += 12;
      elementCount += 3;
      if (this._useBlendShapeNormal) {
        vertexElements.push(new VertexElement("NORMAL_BS" + i, offset, VertexElementFormat.Vector3, 0));
        offset += 12;
        elementCount += 3;
      }
      if (this._useBlendShapeTangent) {
        vertexElements.push(new VertexElement("TANGENT_BS" + i, offset, VertexElementFormat.Vector3, 0));
        offset += 12;
        elementCount += 3;
      }
    }
    this._elementCount = elementCount;
    return vertexElements;
  };
  _proto._updateVertices = function _updateVertices(vertices) {
    var _elementCount = this._elementCount, _vertexCount = this._vertexCount, _positions = this._positions, _normals = this._normals, _colors = this._colors, _vertexChangeFlag = this._vertexChangeFlag, _boneWeights = this._boneWeights, _boneIndices = this._boneIndices, _tangents = this._tangents, _uv = this._uv, _uv1 = this._uv1, _uv2 = this._uv2, _uv3 = this._uv3, _uv4 = this._uv4, _uv5 = this._uv5, _uv6 = this._uv6, _uv7 = this._uv7;
    if (_vertexChangeFlag & ValueChanged.Position) {
      for (var i = 0; i < _vertexCount; i++) {
        var start = _elementCount * i;
        var position = _positions[i];
        vertices[start] = position.x;
        vertices[start + 1] = position.y;
        vertices[start + 2] = position.z;
      }
    }
    var offset = 3;
    if (_normals) {
      if (_vertexChangeFlag & ValueChanged.Normal) {
        for (var _i = 0; _i < _vertexCount; _i++) {
          var _start = _elementCount * _i + offset;
          var normal = _normals[_i];
          if (normal) {
            vertices[_start] = normal.x;
            vertices[_start + 1] = normal.y;
            vertices[_start + 2] = normal.z;
          }
        }
      }
      offset += 3;
    }
    if (_colors) {
      if (_vertexChangeFlag & ValueChanged.Color) {
        for (var _i2 = 0; _i2 < _vertexCount; _i2++) {
          var _start2 = _elementCount * _i2 + offset;
          var color = _colors[_i2];
          if (color) {
            vertices[_start2] = color.r;
            vertices[_start2 + 1] = color.g;
            vertices[_start2 + 2] = color.b;
            vertices[_start2 + 3] = color.a;
          }
        }
      }
      offset += 4;
    }
    if (_boneWeights) {
      if (_vertexChangeFlag & ValueChanged.BoneWeight) {
        for (var _i3 = 0; _i3 < _vertexCount; _i3++) {
          var _start3 = _elementCount * _i3 + offset;
          var weight = _boneWeights[_i3];
          if (weight) {
            vertices[_start3] = weight.x;
            vertices[_start3 + 1] = weight.y;
            vertices[_start3 + 2] = weight.z;
            vertices[_start3 + 3] = weight.w;
          }
        }
      }
      offset += 4;
    }
    if (_boneIndices) {
      if (_vertexChangeFlag & ValueChanged.BoneIndex) {
        var _verticesUint8 = this._verticesUint8;
        for (var _i4 = 0; _i4 < _vertexCount; _i4++) {
          var _start4 = _elementCount * _i4 + offset;
          var joint = _boneIndices[_i4];
          if (joint) {
            var internalStart = _start4 * 4;
            _verticesUint8[internalStart] = joint.x;
            _verticesUint8[internalStart + 1] = joint.y;
            _verticesUint8[internalStart + 2] = joint.z;
            _verticesUint8[internalStart + 3] = joint.w;
          }
        }
      }
      offset += 1;
    }
    if (_tangents) {
      if (_vertexChangeFlag & ValueChanged.Tangent) {
        for (var _i5 = 0; _i5 < _vertexCount; _i5++) {
          var _start5 = _elementCount * _i5 + offset;
          var tangent = _tangents[_i5];
          if (tangent) {
            vertices[_start5] = tangent.x;
            vertices[_start5 + 1] = tangent.y;
            vertices[_start5 + 2] = tangent.z;
          }
        }
      }
      offset += 4;
    }
    if (_uv) {
      if (_vertexChangeFlag & ValueChanged.UV) {
        for (var _i6 = 0; _i6 < _vertexCount; _i6++) {
          var _start6 = _elementCount * _i6 + offset;
          var _uv8 = _uv[_i6];
          if (_uv8) {
            vertices[_start6] = _uv8.x;
            vertices[_start6 + 1] = _uv8.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv1) {
      if (_vertexChangeFlag & ValueChanged.UV1) {
        for (var _i7 = 0; _i7 < _vertexCount; _i7++) {
          var _start7 = _elementCount * _i7 + offset;
          var _uv9 = _uv1[_i7];
          if (_uv9) {
            vertices[_start7] = _uv9.x;
            vertices[_start7 + 1] = _uv9.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv2) {
      if (_vertexChangeFlag & ValueChanged.UV2) {
        for (var _i8 = 0; _i8 < _vertexCount; _i8++) {
          var _start8 = _elementCount * _i8 + offset;
          var _uv10 = _uv2[_i8];
          if (_uv10) {
            vertices[_start8] = _uv10.x;
            vertices[_start8 + 1] = _uv10.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv3) {
      if (_vertexChangeFlag & ValueChanged.UV3) {
        for (var _i9 = 0; _i9 < _vertexCount; _i9++) {
          var _start9 = _elementCount * _i9 + offset;
          var _uv11 = _uv3[_i9];
          if (_uv11) {
            vertices[_start9] = _uv11.x;
            vertices[_start9 + 1] = _uv11.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv4) {
      if (_vertexChangeFlag & ValueChanged.UV4) {
        for (var _i10 = 0; _i10 < _vertexCount; _i10++) {
          var _start10 = _elementCount * _i10 + offset;
          var _uv12 = _uv4[_i10];
          if (_uv12) {
            vertices[_start10] = _uv12.x;
            vertices[_start10 + 1] = _uv12.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv5) {
      if (_vertexChangeFlag & ValueChanged.UV5) {
        for (var _i11 = 0; _i11 < _vertexCount; _i11++) {
          var _start11 = _elementCount * _i11 + offset;
          var _uv13 = _uv5[_i11];
          if (_uv13) {
            vertices[_start11] = _uv13.x;
            vertices[_start11 + 1] = _uv13.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv6) {
      if (_vertexChangeFlag & ValueChanged.UV6) {
        for (var _i12 = 0; _i12 < _vertexCount; _i12++) {
          var _start12 = _elementCount * _i12 + offset;
          var _uv14 = _uv6[_i12];
          if (_uv14) {
            vertices[_start12] = _uv14.x;
            vertices[_start12 + 1] = _uv14.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv7) {
      if (_vertexChangeFlag & ValueChanged.UV7) {
        for (var _i13 = 0; _i13 < _vertexCount; _i13++) {
          var _start13 = _elementCount * _i13 + offset;
          var _uv15 = _uv7[_i13];
          if (_uv15) {
            vertices[_start13] = _uv15.x;
            vertices[_start13 + 1] = _uv15.y;
          }
        }
      }
      offset += 2;
    }
    if (_vertexChangeFlag & ValueChanged.BlendShape) {
      var blendShapes = this._blendShapes;
      var blendShapeUpdateFlags = this._blendShapeUpdateFlags;
      var blendShapeCount = Math.min(blendShapes.length, 4);
      this.engine._hardwareRenderer;
      {
        for (var _i14 = 0; _i14 < blendShapeCount; _i14++) {
          var blendShapeUpdateFlag = blendShapeUpdateFlags[_i14];
          if (blendShapeUpdateFlag.flag) {
            var blendShape = blendShapes[_i14];
            var frames = blendShape.frames;
            var frameCount = frames.length;
            var endFrame = frames[frameCount - 1];
            if (frameCount > 0 && endFrame.deltaPositions.length !== this._vertexCount) {
              throw "BlendShape frame deltaPositions length must same with mesh vertexCount.";
            }
            var deltaPositions = endFrame.deltaPositions;
            for (var j = 0; j < _vertexCount; j++) {
              var _start14 = _elementCount * j + offset;
              var deltaPosition = deltaPositions[j];
              if (deltaPosition) {
                vertices[_start14] = deltaPosition.x;
                vertices[_start14 + 1] = deltaPosition.y;
                vertices[_start14 + 2] = deltaPosition.z;
              }
            }
            offset += 3;
            if (this._useBlendShapeNormal) {
              var deltaNormals = endFrame.deltaNormals;
              if (deltaNormals) {
                for (var _j = 0; _j < _vertexCount; _j++) {
                  var _start15 = _elementCount * _j + offset;
                  var deltaNormal = deltaNormals[_j];
                  if (deltaNormal) {
                    vertices[_start15] = deltaNormal.x;
                    vertices[_start15 + 1] = deltaNormal.y;
                    vertices[_start15 + 2] = deltaNormal.z;
                  }
                }
              }
              offset += 3;
            }
            if (this._useBlendShapeTangent) {
              var deltaTangents = endFrame.deltaTangents;
              if (deltaTangents) {
                for (var _j2 = 0; _j2 < _vertexCount; _j2++) {
                  var _start16 = _elementCount * _j2 + offset;
                  var deltaTangent = deltaTangents[_j2];
                  if (deltaTangent) {
                    vertices[_start16] = deltaTangent.x;
                    vertices[_start16 + 1] = deltaTangent.y;
                    vertices[_start16 + 2] = deltaTangent.z;
                  }
                }
              }
              offset += 3;
            }
            blendShapeUpdateFlag.flag = false;
          }
        }
      }
    }
    this._vertexChangeFlag = 0;
  };
  _proto._releaseCache = function _releaseCache() {
    var blendShapeUpdateFlags = this._blendShapeUpdateFlags;
    for (var i = 0, n = blendShapeUpdateFlags.length; i < n; i++) {
      blendShapeUpdateFlags[i].destroy();
    }
    this._verticesUint8 = null;
    this._indices = null;
    this._verticesFloat32 = null;
    this._positions.length = 0;
    this._tangents = null;
    this._normals = null;
    this._colors = null;
    this._uv = null;
    this._uv1 = null;
    this._uv2 = null;
    this._uv3 = null;
    this._uv4 = null;
    this._uv5 = null;
    this._uv6 = null;
    this._uv7 = null;
    this._blendShapes = null;
    this._blendShapeUpdateFlags = null;
  };
  _createClass(ModelMesh2, [{
    key: "accessible",
    get: function get4() {
      return this._accessible;
    }
  }, {
    key: "vertexCount",
    get: function get4() {
      return this._vertexCount;
    }
  }, {
    key: "blendShapes",
    get: function get4() {
      if (!this._accessible) {
        throw "Not allowed to access data while accessible is false.";
      }
      return this._blendShapes;
    }
  }]);
  return ModelMesh2;
}(Mesh);
var POSITION_VERTEX_ELEMENT = new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0);
var ValueChanged;
(function(ValueChanged2) {
  ValueChanged2[ValueChanged2["Position"] = 1] = "Position";
  ValueChanged2[ValueChanged2["Normal"] = 2] = "Normal";
  ValueChanged2[ValueChanged2["Color"] = 4] = "Color";
  ValueChanged2[ValueChanged2["Tangent"] = 8] = "Tangent";
  ValueChanged2[ValueChanged2["BoneWeight"] = 16] = "BoneWeight";
  ValueChanged2[ValueChanged2["BoneIndex"] = 32] = "BoneIndex";
  ValueChanged2[ValueChanged2["UV"] = 64] = "UV";
  ValueChanged2[ValueChanged2["UV1"] = 128] = "UV1";
  ValueChanged2[ValueChanged2["UV2"] = 256] = "UV2";
  ValueChanged2[ValueChanged2["UV3"] = 512] = "UV3";
  ValueChanged2[ValueChanged2["UV4"] = 1024] = "UV4";
  ValueChanged2[ValueChanged2["UV5"] = 2048] = "UV5";
  ValueChanged2[ValueChanged2["UV6"] = 4096] = "UV6";
  ValueChanged2[ValueChanged2["UV7"] = 8192] = "UV7";
  ValueChanged2[ValueChanged2["BlendShape"] = 16384] = "BlendShape";
  ValueChanged2[ValueChanged2["All"] = 65535] = "All";
})(ValueChanged || (ValueChanged = {}));
var Skin = function(_EngineObject) {
  _inheritsLoose(Skin2, _EngineObject);
  function Skin2(name) {
    var _this;
    _this = _EngineObject.call(this, null) || this;
    _this.name = name;
    _this.inverseBindMatrices = void 0;
    _this.joints = void 0;
    _this.skeleton = void 0;
    _this.inverseBindMatrices = [];
    _this.joints = [];
    _this.skeleton = "none";
    return _this;
  }
  return Skin2;
}(EngineObject);
var _class$5;
var _descriptor$5;
var _descriptor2$5;
var _class2$4;
var _temp$4;
var MeshRenderer = (_class$5 = (_temp$4 = _class2$4 = function(_Renderer) {
  _inheritsLoose(MeshRenderer2, _Renderer);
  function MeshRenderer2(entity) {
    var _this;
    _this = _Renderer.call(this, entity) || this;
    _initializerDefineProperty(_this, "_mesh", _descriptor$5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_meshUpdateFlag", _descriptor2$5, _assertThisInitialized(_this));
    return _this;
  }
  var _proto = MeshRenderer2.prototype;
  _proto._render = function _render(camera) {
    var mesh = this._mesh;
    if (mesh) {
      if (this._meshUpdateFlag.flag) {
        var shaderData = this.shaderData;
        var vertexElements = mesh._vertexElements;
        shaderData.disableMacro(MeshRenderer2._uvMacro);
        shaderData.disableMacro(MeshRenderer2._normalMacro);
        shaderData.disableMacro(MeshRenderer2._tangentMacro);
        shaderData.disableMacro(MeshRenderer2._vertexColorMacro);
        for (var i = 0, n = vertexElements.length; i < n; i++) {
          var semantic = vertexElements[i].semantic;
          switch (semantic) {
            case "TEXCOORD_0":
              shaderData.enableMacro(MeshRenderer2._uvMacro);
              break;
            case "NORMAL":
              shaderData.enableMacro(MeshRenderer2._normalMacro);
              break;
            case "TANGENT":
              shaderData.enableMacro(MeshRenderer2._tangentMacro);
              break;
            case "COLOR_0":
              shaderData.enableMacro(MeshRenderer2._vertexColorMacro);
              break;
          }
        }
        this._meshUpdateFlag.flag = false;
      }
      var subMeshes = mesh.subMeshes;
      var renderPipeline = camera._renderPipeline;
      var renderElementPool = this._engine._renderElementPool;
      for (var _i = 0, _n = subMeshes.length; _i < _n; _i++) {
        var material = this._materials[_i];
        if (material) {
          var element = renderElementPool.getFromPool();
          element.setValue(this, mesh, subMeshes[_i], material);
          renderPipeline.pushPrimitive(element);
        }
      }
    } else {
      Logger.error("mesh is null.");
    }
  };
  _proto._onDestroy = function _onDestroy() {
    _Renderer.prototype._onDestroy.call(this);
    var mesh = this._mesh;
    if (mesh && !mesh.destroyed) {
      mesh._addRefCount(-1);
      this._mesh = null;
    }
  };
  _proto._cloneTo = function _cloneTo(target) {
    target.mesh = this._mesh;
  };
  _proto._updateBounds = function _updateBounds(worldBounds) {
    var mesh = this._mesh;
    if (mesh) {
      var localBounds = mesh.bounds;
      var worldMatrix = this._entity.transform.worldMatrix;
      BoundingBox.transform(localBounds, worldMatrix, worldBounds);
    } else {
      worldBounds.min.setValue(0, 0, 0);
      worldBounds.max.setValue(0, 0, 0);
    }
  };
  _createClass(MeshRenderer2, [{
    key: "mesh",
    get: function get4() {
      return this._mesh;
    },
    set: function set4(mesh) {
      var lastMesh = this._mesh;
      if (lastMesh !== mesh) {
        if (lastMesh) {
          lastMesh._addRefCount(-1);
          this._meshUpdateFlag.destroy();
        }
        if (mesh) {
          mesh._addRefCount(1);
          this._meshUpdateFlag = mesh.registerUpdateFlag();
        }
        this._mesh = mesh;
      }
    }
  }]);
  return MeshRenderer2;
}(Renderer), _class2$4._uvMacro = Shader.getMacroByName("O3_HAS_UV"), _class2$4._normalMacro = Shader.getMacroByName("O3_HAS_NORMAL"), _class2$4._tangentMacro = Shader.getMacroByName("O3_HAS_TANGENT"), _class2$4._vertexColorMacro = Shader.getMacroByName("O3_HAS_VERTEXCOLOR"), _temp$4), _descriptor$5 = _applyDecoratedDescriptor(_class$5.prototype, "_mesh", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$5 = _applyDecoratedDescriptor(_class$5.prototype, "_meshUpdateFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _class$5);
var _class$4;
var _descriptor$4;
var _descriptor2$4;
var _descriptor3$4;
var _descriptor4$4;
var _descriptor5$4;
var _descriptor6$4;
var _class2$3;
var _temp$3;
var SkinnedMeshRenderer = (_class$4 = (_temp$3 = _class2$3 = function(_MeshRenderer) {
  _inheritsLoose(SkinnedMeshRenderer2, _MeshRenderer);
  function SkinnedMeshRenderer2(entity) {
    var _this;
    _this = _MeshRenderer.call(this, entity) || this;
    _initializerDefineProperty(_this, "matrixPalette", _descriptor$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "jointNodes", _descriptor2$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "jointTexture", _descriptor3$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_hasInitJoints", _descriptor4$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_mat", _descriptor5$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_useJointTexture", _descriptor6$4, _assertThisInitialized(_this));
    _this._skin = void 0;
    _this._blendShapeWeights = void 0;
    _this._mat = new Matrix();
    _this._skin = null;
    return _this;
  }
  var _proto = SkinnedMeshRenderer2.prototype;
  _proto._updateShaderData = function _updateShaderData(context) {
    _MeshRenderer.prototype._updateShaderData.call(this, context);
    var shaderData = this.shaderData;
    if (!this._useJointTexture && this.matrixPalette) {
      shaderData.setFloatArray(SkinnedMeshRenderer2._jointMatrixProperty, this.matrixPalette);
    }
    var mesh = this.mesh;
    if (mesh._hasBlendShape) {
      shaderData.setFloatArray(SkinnedMeshRenderer2._blendShapeWeightsProperty, this._blendShapeWeights);
      shaderData.enableMacro(SkinnedMeshRenderer2._blendShapeMacro);
      if (mesh._useBlendShapeNormal) {
        shaderData.enableMacro(SkinnedMeshRenderer2._blendShapeNormalMacro);
      } else {
        shaderData.disableMacro(SkinnedMeshRenderer2._blendShapeNormalMacro);
      }
      if (mesh._useBlendShapeTangent) {
        shaderData.enableMacro(SkinnedMeshRenderer2._blendShapeTangentMacro);
      } else {
        shaderData.disableMacro(SkinnedMeshRenderer2._blendShapeTangentMacro);
      }
    } else {
      shaderData.disableMacro(SkinnedMeshRenderer2._blendShapeMacro);
    }
  };
  _proto._initJoints = function _initJoints() {
    var _this$jointNodes;
    if (!this._skin)
      return;
    var skin = this._skin;
    var joints = skin.joints;
    var jointNodes = [];
    for (var i = joints.length - 1; i >= 0; i--) {
      jointNodes[i] = this.findByNodeName(this.entity, joints[i]);
    }
    this.matrixPalette = new Float32Array(jointNodes.length * 16);
    this.jointNodes = jointNodes;
    var rhi = this.entity.engine._hardwareRenderer;
    if (!rhi)
      return;
    var maxAttribUniformVec4 = rhi.renderStates.getParameter(rhi.gl.MAX_VERTEX_UNIFORM_VECTORS);
    var maxJoints = Math.floor((maxAttribUniformVec4 - 20) / 4);
    var shaderData = this.shaderData;
    var jointCount = (_this$jointNodes = this.jointNodes) === null || _this$jointNodes === void 0 ? void 0 : _this$jointNodes.length;
    if (jointCount) {
      shaderData.enableMacro("O3_HAS_SKIN");
      shaderData.setInt(SkinnedMeshRenderer2._jointCountProperty, jointCount);
      if (joints.length > maxJoints) {
        if (rhi.canIUseMoreJoints) {
          this._useJointTexture = true;
        } else {
          Logger.error("component's joints count(" + joints + ") greater than device's MAX_VERTEX_UNIFORM_VECTORS number " + maxAttribUniformVec4 + ", and don't support jointTexture in this device. suggest joint count less than " + maxJoints + ".", this);
        }
      } else {
        var _maxJoints = Math.max(SkinnedMeshRenderer2._maxJoints, joints.length);
        SkinnedMeshRenderer2._maxJoints = _maxJoints;
        shaderData.disableMacro("O3_USE_JOINT_TEXTURE");
        shaderData.enableMacro("O3_JOINTS_NUM", _maxJoints.toString());
      }
    } else {
      shaderData.disableMacro("O3_HAS_SKIN");
    }
  };
  _proto.findByNodeName = function findByNodeName(entity, nodeName) {
    if (!entity)
      return null;
    var n = entity.findByName(nodeName);
    if (n)
      return n;
    return this.findByNodeName(entity.parent, nodeName);
  };
  _proto.update = function update() {
    if (!this._hasInitJoints) {
      this._initJoints();
      this._hasInitJoints = true;
    }
    if (this._skin) {
      var joints = this.jointNodes;
      var ibms = this._skin.inverseBindMatrices;
      var matrixPalette = this.matrixPalette;
      var worldToLocal = this.entity.getInvModelMatrix();
      var mat = this._mat;
      for (var i = joints.length - 1; i >= 0; i--) {
        mat.identity();
        if (joints[i]) {
          Matrix.multiply(joints[i].transform.worldMatrix, ibms[i], mat);
        } else {
          ibms[i].cloneTo(mat);
        }
        Matrix.multiply(worldToLocal, mat, mat);
        matrixPalette.set(mat.elements, i * 16);
      }
      if (this._useJointTexture) {
        this.createJointTexture();
      }
    }
  };
  _proto.createJointTexture = function createJointTexture() {
    if (!this.jointTexture) {
      var engine = this.engine;
      var rhi = engine._hardwareRenderer;
      if (!rhi)
        return;
      this.jointTexture = new Texture2D(engine, 4, this.jointNodes.length, TextureFormat.R32G32B32A32, false);
      this.jointTexture.filterMode = TextureFilterMode.Point;
      this.shaderData.enableMacro("O3_USE_JOINT_TEXTURE");
      this.shaderData.setTexture(SkinnedMeshRenderer2._jointSamplerProperty, this.jointTexture);
    }
    this.jointTexture.setPixelBuffer(this.matrixPalette);
  };
  _createClass(SkinnedMeshRenderer2, [{
    key: "blendShapeWeights",
    get: function get4() {
      return this._blendShapeWeights;
    },
    set: function set4(value) {
      this._blendShapeWeights = value;
    }
  }, {
    key: "skin",
    get: function get4() {
      return this._skin;
    },
    set: function set4(skin) {
      this._skin = skin;
    }
  }]);
  return SkinnedMeshRenderer2;
}(MeshRenderer), _class2$3._blendShapeMacro = Shader.getMacroByName("OASIS_BLENDSHAPE"), _class2$3._blendShapeNormalMacro = Shader.getMacroByName("OASIS_BLENDSHAPE_NORMAL"), _class2$3._blendShapeTangentMacro = Shader.getMacroByName("OASIS_BLENDSHAPE_TANGENT"), _class2$3._jointCountProperty = Shader.getPropertyByName("u_jointCount"), _class2$3._jointSamplerProperty = Shader.getPropertyByName("u_jointSampler"), _class2$3._jointMatrixProperty = Shader.getPropertyByName("u_jointMatrix"), _class2$3._blendShapeWeightsProperty = Shader.getPropertyByName("u_blendShapeWeights"), _class2$3._maxJoints = 0, _temp$3), _descriptor$4 = _applyDecoratedDescriptor(_class$4.prototype, "matrixPalette", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$4 = _applyDecoratedDescriptor(_class$4.prototype, "jointNodes", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$4 = _applyDecoratedDescriptor(_class$4.prototype, "jointTexture", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$4 = _applyDecoratedDescriptor(_class$4.prototype, "_hasInitJoints", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer38() {
    return false;
  }
}), _descriptor5$4 = _applyDecoratedDescriptor(_class$4.prototype, "_mat", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6$4 = _applyDecoratedDescriptor(_class$4.prototype, "_useJointTexture", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer39() {
    return false;
  }
}), _class$4);
var PrimitiveMesh = function() {
  function PrimitiveMesh2() {
  }
  PrimitiveMesh2.createSphere = function createSphere(engine, radius, segments, noLongerAccessible) {
    if (radius === void 0) {
      radius = 0.5;
    }
    if (segments === void 0) {
      segments = 18;
    }
    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }
    var mesh = new ModelMesh(engine);
    segments = Math.max(2, Math.floor(segments));
    var count = segments + 1;
    var vertexCount = count * count;
    var rectangleCount = segments * segments;
    var indices = PrimitiveMesh2._generateIndices(engine, vertexCount, rectangleCount * 6);
    var thetaRange = Math.PI;
    var alphaRange = thetaRange * 2;
    var countReciprocal = 1 / count;
    var segmentsReciprocal = 1 / segments;
    var positions = new Array(vertexCount);
    var normals = new Array(vertexCount);
    var uvs = new Array(vertexCount);
    for (var i = 0; i < vertexCount; ++i) {
      var x = i % count;
      var y = i * countReciprocal | 0;
      var u = x * segmentsReciprocal;
      var v = y * segmentsReciprocal;
      var alphaDelta = u * alphaRange;
      var thetaDelta = v * thetaRange;
      var sinTheta = Math.sin(thetaDelta);
      var posX = -radius * Math.cos(alphaDelta) * sinTheta;
      var posY = radius * Math.cos(thetaDelta);
      var posZ = radius * Math.sin(alphaDelta) * sinTheta;
      positions[i] = new Vector3(posX, posY, posZ);
      normals[i] = new Vector3(posX, posY, posZ);
      uvs[i] = new Vector2(u, v);
    }
    var offset = 0;
    for (var _i = 0; _i < rectangleCount; ++_i) {
      var _x = _i % segments;
      var _y = _i * segmentsReciprocal | 0;
      var a = _y * count + _x;
      var b = a + 1;
      var c = a + count;
      var d = c + 1;
      indices[offset++] = b;
      indices[offset++] = a;
      indices[offset++] = d;
      indices[offset++] = a;
      indices[offset++] = c;
      indices[offset++] = d;
    }
    var bounds = mesh.bounds;
    bounds.min.setValue(-radius, -radius, -radius);
    bounds.max.setValue(radius, radius, radius);
    PrimitiveMesh2._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
    return mesh;
  };
  PrimitiveMesh2.createCuboid = function createCuboid(engine, width, height, depth, noLongerAccessible) {
    if (width === void 0) {
      width = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (depth === void 0) {
      depth = 1;
    }
    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }
    var mesh = new ModelMesh(engine);
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var halfDepth = depth / 2;
    var positions = new Array(24);
    var normals = new Array(24);
    var uvs = new Array(24);
    positions[0] = new Vector3(-halfWidth, halfHeight, -halfDepth);
    positions[1] = new Vector3(halfWidth, halfHeight, -halfDepth);
    positions[2] = new Vector3(halfWidth, halfHeight, halfDepth);
    positions[3] = new Vector3(-halfWidth, halfHeight, halfDepth);
    normals[0] = new Vector3(0, 1, 0);
    normals[1] = new Vector3(0, 1, 0);
    normals[2] = new Vector3(0, 1, 0);
    normals[3] = new Vector3(0, 1, 0);
    uvs[0] = new Vector2(0, 0);
    uvs[1] = new Vector2(1, 0);
    uvs[2] = new Vector2(1, 1);
    uvs[3] = new Vector2(0, 1);
    positions[4] = new Vector3(-halfWidth, -halfHeight, -halfDepth);
    positions[5] = new Vector3(halfWidth, -halfHeight, -halfDepth);
    positions[6] = new Vector3(halfWidth, -halfHeight, halfDepth);
    positions[7] = new Vector3(-halfWidth, -halfHeight, halfDepth);
    normals[4] = new Vector3(0, -1, 0);
    normals[5] = new Vector3(0, -1, 0);
    normals[6] = new Vector3(0, -1, 0);
    normals[7] = new Vector3(0, -1, 0);
    uvs[4] = new Vector2(0, 1);
    uvs[5] = new Vector2(1, 1);
    uvs[6] = new Vector2(1, 0);
    uvs[7] = new Vector2(0, 0);
    positions[8] = new Vector3(-halfWidth, halfHeight, -halfDepth);
    positions[9] = new Vector3(-halfWidth, halfHeight, halfDepth);
    positions[10] = new Vector3(-halfWidth, -halfHeight, halfDepth);
    positions[11] = new Vector3(-halfWidth, -halfHeight, -halfDepth);
    normals[8] = new Vector3(-1, 0, 0);
    normals[9] = new Vector3(-1, 0, 0);
    normals[10] = new Vector3(-1, 0, 0);
    normals[11] = new Vector3(-1, 0, 0);
    uvs[8] = new Vector2(0, 0);
    uvs[9] = new Vector2(1, 0);
    uvs[10] = new Vector2(1, 1);
    uvs[11] = new Vector2(0, 1);
    positions[12] = new Vector3(halfWidth, halfHeight, -halfDepth);
    positions[13] = new Vector3(halfWidth, halfHeight, halfDepth);
    positions[14] = new Vector3(halfWidth, -halfHeight, halfDepth);
    positions[15] = new Vector3(halfWidth, -halfHeight, -halfDepth);
    normals[12] = new Vector3(1, 0, 0);
    normals[13] = new Vector3(1, 0, 0);
    normals[14] = new Vector3(1, 0, 0);
    normals[15] = new Vector3(1, 0, 0);
    uvs[12] = new Vector2(1, 0);
    uvs[13] = new Vector2(0, 0);
    uvs[14] = new Vector2(0, 1);
    uvs[15] = new Vector2(1, 1);
    positions[16] = new Vector3(-halfWidth, halfHeight, halfDepth);
    positions[17] = new Vector3(halfWidth, halfHeight, halfDepth);
    positions[18] = new Vector3(halfWidth, -halfHeight, halfDepth);
    positions[19] = new Vector3(-halfWidth, -halfHeight, halfDepth);
    normals[16] = new Vector3(0, 0, 1);
    normals[17] = new Vector3(0, 0, 1);
    normals[18] = new Vector3(0, 0, 1);
    normals[19] = new Vector3(0, 0, 1);
    uvs[16] = new Vector2(0, 0);
    uvs[17] = new Vector2(1, 0);
    uvs[18] = new Vector2(1, 1);
    uvs[19] = new Vector2(0, 1);
    positions[20] = new Vector3(-halfWidth, halfHeight, -halfDepth);
    positions[21] = new Vector3(halfWidth, halfHeight, -halfDepth);
    positions[22] = new Vector3(halfWidth, -halfHeight, -halfDepth);
    positions[23] = new Vector3(-halfWidth, -halfHeight, -halfDepth);
    normals[20] = new Vector3(0, 0, -1);
    normals[21] = new Vector3(0, 0, -1);
    normals[22] = new Vector3(0, 0, -1);
    normals[23] = new Vector3(0, 0, -1);
    uvs[20] = new Vector2(1, 0);
    uvs[21] = new Vector2(0, 0);
    uvs[22] = new Vector2(0, 1);
    uvs[23] = new Vector2(1, 1);
    var indices = new Uint16Array(36);
    indices[0] = 0, indices[1] = 2, indices[2] = 1, indices[3] = 2, indices[4] = 0, indices[5] = 3, indices[6] = 4, indices[7] = 6, indices[8] = 7, indices[9] = 6, indices[10] = 4, indices[11] = 5, indices[12] = 8, indices[13] = 10, indices[14] = 9, indices[15] = 10, indices[16] = 8, indices[17] = 11, indices[18] = 12, indices[19] = 14, indices[20] = 15, indices[21] = 14, indices[22] = 12, indices[23] = 13, indices[24] = 16, indices[25] = 18, indices[26] = 17, indices[27] = 18, indices[28] = 16, indices[29] = 19, indices[30] = 20, indices[31] = 22, indices[32] = 23, indices[33] = 22, indices[34] = 20, indices[35] = 21;
    var bounds = mesh.bounds;
    bounds.min.setValue(-halfWidth, -halfHeight, -halfDepth);
    bounds.max.setValue(halfWidth, halfHeight, halfDepth);
    PrimitiveMesh2._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
    return mesh;
  };
  PrimitiveMesh2.createPlane = function createPlane(engine, width, height, horizontalSegments, verticalSegments, noLongerAccessible) {
    if (width === void 0) {
      width = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (horizontalSegments === void 0) {
      horizontalSegments = 1;
    }
    if (verticalSegments === void 0) {
      verticalSegments = 1;
    }
    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }
    var mesh = new ModelMesh(engine);
    horizontalSegments = Math.max(1, Math.floor(horizontalSegments));
    verticalSegments = Math.max(1, Math.floor(verticalSegments));
    var horizontalCount = horizontalSegments + 1;
    var verticalCount = verticalSegments + 1;
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var gridWidth = width / horizontalSegments;
    var gridHeight = height / verticalSegments;
    var vertexCount = horizontalCount * verticalCount;
    var rectangleCount = verticalSegments * horizontalSegments;
    var indices = PrimitiveMesh2._generateIndices(engine, vertexCount, rectangleCount * 6);
    var horizontalCountReciprocal = 1 / horizontalCount;
    var horizontalSegmentsReciprocal = 1 / horizontalSegments;
    var verticalSegmentsReciprocal = 1 / verticalSegments;
    var positions = new Array(vertexCount);
    var normals = new Array(vertexCount);
    var uvs = new Array(vertexCount);
    for (var i = 0; i < vertexCount; ++i) {
      var x = i % horizontalCount;
      var y = i * horizontalCountReciprocal | 0;
      positions[i] = new Vector3(x * gridWidth - halfWidth, y * gridHeight - halfHeight, 0);
      normals[i] = new Vector3(0, 0, 1);
      uvs[i] = new Vector2(x * horizontalSegmentsReciprocal, 1 - y * verticalSegmentsReciprocal);
    }
    var offset = 0;
    for (var _i2 = 0; _i2 < rectangleCount; ++_i2) {
      var _x2 = _i2 % horizontalSegments;
      var _y2 = _i2 * horizontalSegmentsReciprocal | 0;
      var a = _y2 * horizontalCount + _x2;
      var b = a + 1;
      var c = a + horizontalCount;
      var d = c + 1;
      indices[offset++] = b;
      indices[offset++] = c;
      indices[offset++] = a;
      indices[offset++] = b;
      indices[offset++] = d;
      indices[offset++] = c;
    }
    var bounds = mesh.bounds;
    bounds.min.setValue(-halfWidth, -halfHeight, 0);
    bounds.max.setValue(halfWidth, halfHeight, 0);
    PrimitiveMesh2._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
    return mesh;
  };
  PrimitiveMesh2.createCylinder = function createCylinder(engine, radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible) {
    if (radiusTop === void 0) {
      radiusTop = 0.5;
    }
    if (radiusBottom === void 0) {
      radiusBottom = 0.5;
    }
    if (height === void 0) {
      height = 2;
    }
    if (radialSegments === void 0) {
      radialSegments = 20;
    }
    if (heightSegments === void 0) {
      heightSegments = 1;
    }
    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }
    var mesh = new ModelMesh(engine);
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    var radialCount = radialSegments + 1;
    var verticalCount = heightSegments + 1;
    var halfHeight = height * 0.5;
    var unitHeight = height / heightSegments;
    var torsoVertexCount = radialCount * verticalCount;
    var torsoRectangleCount = radialSegments * heightSegments;
    var capTriangleCount = radialSegments * 2;
    var totalVertexCount = torsoVertexCount + 2 + capTriangleCount;
    var indices = PrimitiveMesh2._generateIndices(engine, totalVertexCount, torsoRectangleCount * 6 + capTriangleCount * 3);
    var radialCountReciprocal = 1 / radialCount;
    var radialSegmentsReciprocal = 1 / radialSegments;
    var heightSegmentsReciprocal = 1 / heightSegments;
    var positions = new Array(totalVertexCount);
    var normals = new Array(totalVertexCount);
    var uvs = new Array(totalVertexCount);
    var indicesOffset = 0;
    var thetaStart = Math.PI;
    var thetaRange = Math.PI * 2;
    var radiusDiff = radiusBottom - radiusTop;
    var slope = radiusDiff / height;
    var radiusSlope = radiusDiff / heightSegments;
    for (var i = 0; i < torsoVertexCount; ++i) {
      var x = i % radialCount;
      var y = i * radialCountReciprocal | 0;
      var u = x * radialSegmentsReciprocal;
      var v = y * heightSegmentsReciprocal;
      var theta = thetaStart + u * thetaRange;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      var radius = radiusBottom - y * radiusSlope;
      var posX = radius * sinTheta;
      var posY = y * unitHeight - halfHeight;
      var posZ = radius * cosTheta;
      positions[i] = new Vector3(posX, posY, posZ);
      normals[i] = new Vector3(sinTheta, slope, cosTheta);
      uvs[i] = new Vector2(u, 1 - v);
    }
    for (var _i3 = 0; _i3 < torsoRectangleCount; ++_i3) {
      var _x3 = _i3 % radialSegments;
      var _y3 = _i3 * radialSegmentsReciprocal | 0;
      var a = _y3 * radialCount + _x3;
      var b = a + 1;
      var c = a + radialCount;
      var d = c + 1;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = c;
      indices[indicesOffset++] = a;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = d;
      indices[indicesOffset++] = c;
    }
    positions[torsoVertexCount] = new Vector3(0, -halfHeight, 0);
    normals[torsoVertexCount] = new Vector3(0, -1, 0);
    uvs[torsoVertexCount] = new Vector2(0.5, 0.5);
    positions[torsoVertexCount + 1] = new Vector3(0, halfHeight, 0);
    normals[torsoVertexCount + 1] = new Vector3(0, 1, 0);
    uvs[torsoVertexCount + 1] = new Vector2(0.5, 0.5);
    var offset = torsoVertexCount + 2;
    var diameterTopReciprocal = 1 / (radiusTop * 2);
    var diameterBottomReciprocal = 1 / (radiusBottom * 2);
    var positionStride = radialCount * heightSegments;
    for (var _i4 = 0; _i4 < radialSegments; ++_i4) {
      var curPosBottom = positions[_i4];
      var curPosX = curPosBottom.x;
      var curPosZ = curPosBottom.z;
      positions[offset] = new Vector3(curPosX, -halfHeight, curPosZ);
      normals[offset] = new Vector3(0, -1, 0);
      uvs[offset++] = new Vector2(curPosX * diameterBottomReciprocal + 0.5, 0.5 - curPosZ * diameterBottomReciprocal);
      var curPosTop = positions[_i4 + positionStride];
      curPosX = curPosTop.x;
      curPosZ = curPosTop.z;
      positions[offset] = new Vector3(curPosX, halfHeight, curPosZ);
      normals[offset] = new Vector3(0, 1, 0);
      uvs[offset++] = new Vector2(curPosX * diameterTopReciprocal + 0.5, curPosZ * diameterTopReciprocal + 0.5);
    }
    var topCapIndex = torsoVertexCount + 1;
    var bottomIndiceIndex = torsoVertexCount + 2;
    var topIndiceIndex = bottomIndiceIndex + 1;
    for (var _i5 = 0; _i5 < radialSegments; ++_i5) {
      var firstStride = _i5 * 2;
      var secondStride = _i5 === radialSegments - 1 ? 0 : firstStride + 2;
      indices[indicesOffset++] = torsoVertexCount;
      indices[indicesOffset++] = bottomIndiceIndex + secondStride;
      indices[indicesOffset++] = bottomIndiceIndex + firstStride;
      indices[indicesOffset++] = topCapIndex;
      indices[indicesOffset++] = topIndiceIndex + firstStride;
      indices[indicesOffset++] = topIndiceIndex + secondStride;
    }
    var bounds = mesh.bounds;
    var radiusMax = Math.max(radiusTop, radiusBottom);
    bounds.min.setValue(-radiusMax, -halfHeight, -radiusMax);
    bounds.max.setValue(radiusMax, halfHeight, radiusMax);
    PrimitiveMesh2._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
    return mesh;
  };
  PrimitiveMesh2.createTorus = function createTorus(engine, radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible) {
    if (radius === void 0) {
      radius = 0.5;
    }
    if (tubeRadius === void 0) {
      tubeRadius = 0.1;
    }
    if (radialSegments === void 0) {
      radialSegments = 30;
    }
    if (tubularSegments === void 0) {
      tubularSegments = 30;
    }
    if (arc === void 0) {
      arc = 360;
    }
    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }
    var mesh = new ModelMesh(engine);
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    var vertexCount = (radialSegments + 1) * (tubularSegments + 1);
    var rectangleCount = radialSegments * tubularSegments;
    var indices = PrimitiveMesh2._generateIndices(engine, vertexCount, rectangleCount * 6);
    var positions = new Array(vertexCount);
    var normals = new Array(vertexCount);
    var uvs = new Array(vertexCount);
    arc = arc / 180 * Math.PI;
    var offset = 0;
    for (var i = 0; i <= radialSegments; i++) {
      for (var j = 0; j <= tubularSegments; j++) {
        var u = j / tubularSegments * arc;
        var v = i / radialSegments * Math.PI * 2;
        var cosV = Math.cos(v);
        var sinV = Math.sin(v);
        var cosU = Math.cos(u);
        var sinU = Math.sin(u);
        var position = new Vector3((radius + tubeRadius * cosV) * cosU, (radius + tubeRadius * cosV) * sinU, tubeRadius * sinV);
        positions[offset] = position;
        var centerX = radius * cosU;
        var centerY = radius * sinU;
        normals[offset] = new Vector3(position.x - centerX, position.y - centerY, position.z).normalize();
        uvs[offset++] = new Vector2(j / tubularSegments, i / radialSegments);
      }
    }
    offset = 0;
    for (var _i6 = 1; _i6 <= radialSegments; _i6++) {
      for (var _j = 1; _j <= tubularSegments; _j++) {
        var a = (tubularSegments + 1) * _i6 + _j - 1;
        var b = (tubularSegments + 1) * (_i6 - 1) + _j - 1;
        var c = (tubularSegments + 1) * (_i6 - 1) + _j;
        var d = (tubularSegments + 1) * _i6 + _j;
        indices[offset++] = a;
        indices[offset++] = b;
        indices[offset++] = d;
        indices[offset++] = b;
        indices[offset++] = c;
        indices[offset++] = d;
      }
    }
    var bounds = mesh.bounds;
    var outerRadius = radius + tubeRadius;
    bounds.min.setValue(-outerRadius, -outerRadius, -tubeRadius);
    bounds.max.setValue(outerRadius, outerRadius, tubeRadius);
    PrimitiveMesh2._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
    return mesh;
  };
  PrimitiveMesh2.createCone = function createCone(engine, radius, height, radialSegments, heightSegments, noLongerAccessible) {
    if (radius === void 0) {
      radius = 0.5;
    }
    if (height === void 0) {
      height = 2;
    }
    if (radialSegments === void 0) {
      radialSegments = 20;
    }
    if (heightSegments === void 0) {
      heightSegments = 1;
    }
    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }
    var mesh = new ModelMesh(engine);
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    var radialCount = radialSegments + 1;
    var verticalCount = heightSegments + 1;
    var halfHeight = height * 0.5;
    var unitHeight = height / heightSegments;
    var torsoVertexCount = radialCount * verticalCount;
    var torsoRectangleCount = radialSegments * heightSegments;
    var totalVertexCount = torsoVertexCount + 1 + radialSegments;
    var indices = PrimitiveMesh2._generateIndices(engine, totalVertexCount, torsoRectangleCount * 6 + radialSegments * 3);
    var radialCountReciprocal = 1 / radialCount;
    var radialSegmentsReciprocal = 1 / radialSegments;
    var heightSegmentsReciprocal = 1 / heightSegments;
    var positions = new Array(totalVertexCount);
    var normals = new Array(totalVertexCount);
    var uvs = new Array(totalVertexCount);
    var indicesOffset = 0;
    var thetaStart = Math.PI;
    var thetaRange = Math.PI * 2;
    var slope = radius / height;
    for (var i = 0; i < torsoVertexCount; ++i) {
      var x = i % radialCount;
      var y = i * radialCountReciprocal | 0;
      var u = x * radialSegmentsReciprocal;
      var v = y * heightSegmentsReciprocal;
      var theta = thetaStart + u * thetaRange;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      var curRadius = radius - y * radius;
      var posX = curRadius * sinTheta;
      var posY = y * unitHeight - halfHeight;
      var posZ = curRadius * cosTheta;
      positions[i] = new Vector3(posX, posY, posZ);
      normals[i] = new Vector3(sinTheta, slope, cosTheta);
      uvs[i] = new Vector2(u, 1 - v);
    }
    for (var _i7 = 0; _i7 < torsoRectangleCount; ++_i7) {
      var _x4 = _i7 % radialSegments;
      var _y4 = _i7 * radialSegmentsReciprocal | 0;
      var a = _y4 * radialCount + _x4;
      var b = a + 1;
      var c = a + radialCount;
      var d = c + 1;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = c;
      indices[indicesOffset++] = a;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = d;
      indices[indicesOffset++] = c;
    }
    positions[torsoVertexCount] = new Vector3(0, -halfHeight, 0);
    normals[torsoVertexCount] = new Vector3(0, -1, 0);
    uvs[torsoVertexCount] = new Vector2(0.5, 0.5);
    var offset = torsoVertexCount + 1;
    var diameterBottomReciprocal = 1 / (radius * 2);
    for (var _i8 = 0; _i8 < radialSegments; ++_i8) {
      var curPos = positions[_i8];
      var curPosX = curPos.x;
      var curPosZ = curPos.z;
      positions[offset] = new Vector3(curPosX, -halfHeight, curPosZ);
      normals[offset] = new Vector3(0, -1, 0);
      uvs[offset++] = new Vector2(curPosX * diameterBottomReciprocal + 0.5, 0.5 - curPosZ * diameterBottomReciprocal);
    }
    var bottomIndiceIndex = torsoVertexCount + 1;
    for (var _i9 = 0; _i9 < radialSegments; ++_i9) {
      var firstStride = _i9;
      var secondStride = _i9 === radialSegments - 1 ? 0 : firstStride + 1;
      indices[indicesOffset++] = torsoVertexCount;
      indices[indicesOffset++] = bottomIndiceIndex + secondStride;
      indices[indicesOffset++] = bottomIndiceIndex + firstStride;
    }
    var bounds = mesh.bounds;
    bounds.min.setValue(-radius, -halfHeight, -radius);
    bounds.max.setValue(radius, halfHeight, radius);
    PrimitiveMesh2._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
    return mesh;
  };
  PrimitiveMesh2._initialize = function _initialize(mesh, positions, normals, uvs, indices, noLongerAccessible) {
    mesh.setPositions(positions);
    mesh.setNormals(normals);
    mesh.setUVs(uvs);
    mesh.setIndices(indices);
    mesh.uploadData(noLongerAccessible);
    mesh.addSubMesh(0, indices.length);
  };
  PrimitiveMesh2._generateIndices = function _generateIndices(engine, vertexCount, indexCount) {
    var indices = null;
    if (vertexCount > 65535) {
      if (engine._hardwareRenderer.canIUse(GLCapabilityType.elementIndexUint)) {
        indices = new Uint32Array(indexCount);
      } else {
        throw Error("The vertex count is over limit.");
      }
    } else {
      indices = new Uint16Array(indexCount);
    }
    return indices;
  };
  return PrimitiveMesh2;
}();
var BufferMesh = function(_Mesh) {
  _inheritsLoose(BufferMesh2, _Mesh);
  function BufferMesh2() {
    return _Mesh.apply(this, arguments) || this;
  }
  var _proto = BufferMesh2.prototype;
  _proto.setVertexElements = function setVertexElements(elements) {
    this._setVertexElements(elements);
  };
  _proto.setVertexBufferBinding = function setVertexBufferBinding(bufferOrBinding, strideOrFirstIndex, index) {
    if (strideOrFirstIndex === void 0) {
      strideOrFirstIndex = 0;
    }
    if (index === void 0) {
      index = 0;
    }
    var binding = bufferOrBinding;
    var isBinding = binding.buffer !== void 0;
    isBinding || (binding = new VertexBufferBinding(bufferOrBinding, strideOrFirstIndex));
    var bindings = this._vertexBufferBindings;
    bindings.length <= index && (bindings.length = index + 1);
    this._setVertexBufferBinding(isBinding ? strideOrFirstIndex : index, binding);
  };
  _proto.setVertexBufferBindings = function setVertexBufferBindings(vertexBufferBindings, firstIndex) {
    if (firstIndex === void 0) {
      firstIndex = 0;
    }
    var bindings = this._vertexBufferBindings;
    var count = vertexBufferBindings.length;
    var needLength = firstIndex + count;
    bindings.length < needLength && (bindings.length = needLength);
    for (var i = 0; i < count; i++) {
      this._setVertexBufferBinding(firstIndex + i, vertexBufferBindings[i]);
    }
  };
  _proto.setIndexBufferBinding = function setIndexBufferBinding(bufferOrBinding, format) {
    var binding = bufferOrBinding;
    if (binding) {
      var isBinding = binding.buffer !== void 0;
      isBinding || (binding = new IndexBufferBinding(bufferOrBinding, format));
    }
    this._setIndexBufferBinding(binding);
  };
  _createClass(BufferMesh2, [{
    key: "instanceCount",
    get: function get4() {
      return this._instanceCount;
    },
    set: function set4(value) {
      this._instanceCount = value;
    }
  }, {
    key: "vertexBufferBindings",
    get: function get4() {
      return this._vertexBufferBindings;
    }
  }, {
    key: "indexBufferBinding",
    get: function get4() {
      return this._indexBufferBinding;
    }
  }, {
    key: "vertexElements",
    get: function get4() {
      return this._vertexElements;
    }
  }]);
  return BufferMesh2;
}(Mesh);
var BlendShapeFrame = function BlendShapeFrame2(weight, deltaPositions, deltaNormals, deltaTangents) {
  if (deltaNormals === void 0) {
    deltaNormals = null;
  }
  if (deltaTangents === void 0) {
    deltaTangents = null;
  }
  this.weight = void 0;
  this.deltaPositions = void 0;
  this.deltaNormals = void 0;
  this.deltaTangents = void 0;
  if (deltaNormals && deltaNormals.length !== deltaPositions.length) {
    throw "deltaNormals length must same with deltaPositions length.";
  }
  if (deltaTangents && deltaTangents.length !== deltaPositions.length) {
    throw "deltaTangents length must same with deltaPositions length.";
  }
  this.weight = weight;
  this.deltaPositions = deltaPositions;
  this.deltaNormals = deltaNormals;
  this.deltaTangents = deltaTangents;
};
var BlendShape = function() {
  function BlendShape2(name) {
    this.name = void 0;
    this._useBlendShapeNormal = false;
    this._useBlendShapeTangent = false;
    this._frames = [];
    this._updateFlagManager = new UpdateFlagManager();
    this.name = name;
  }
  var _proto = BlendShape2.prototype;
  _proto.addFrame = function addFrame(frameOrWeight, deltaPositions, deltaNormals, deltaTangents) {
    if (typeof frameOrWeight === "number") {
      var _frame = new BlendShapeFrame(frameOrWeight, deltaPositions, deltaNormals, deltaTangents);
      this._addFrame(_frame);
      return _frame;
    } else {
      this._addFrame(frameOrWeight);
    }
    this._updateFlagManager.distribute();
  };
  _proto.clearFrames = function clearFrames() {
    this._frames.length = 0;
    this._updateFlagManager.distribute();
    this._useBlendShapeNormal = false;
    this._useBlendShapeTangent = false;
  };
  _proto._registerChangeFlag = function _registerChangeFlag() {
    return this._updateFlagManager.register();
  };
  _proto._addFrame = function _addFrame(frame) {
    var frames = this._frames;
    var frameCount = frames.length;
    if (frameCount > 0 && frame.deltaPositions.length !== frames[frameCount - 1].deltaPositions.length) {
      throw "Frame's deltaPositions length must same with before frame deltaPositions length.";
    }
    this._useBlendShapeNormal = this._useBlendShapeNormal || frame.deltaNormals !== null;
    this._useBlendShapeTangent = this._useBlendShapeTangent || frame.deltaTangents !== null;
    this._frames.push(frame);
  };
  _createClass(BlendShape2, [{
    key: "frames",
    get: function get4() {
      return this._frames;
    }
  }]);
  return BlendShape2;
}();
var Basic2DBatcher = function() {
  function Basic2DBatcher2(engine) {
    this._subMeshPool = new ClassPool(SubMesh);
    this._batchedQueue = [];
    this._meshes = [];
    this._meshCount = 1;
    this._vertexBuffers = [];
    this._indiceBuffers = [];
    this._vertices = void 0;
    this._indices = void 0;
    this._flushId = 0;
    this._vertexCount = 0;
    this._elementCount = 0;
    var MAX_VERTEX_COUNT = Basic2DBatcher2.MAX_VERTEX_COUNT;
    this._vertices = new Float32Array(MAX_VERTEX_COUNT * 9);
    this._indices = new Uint16Array(MAX_VERTEX_COUNT * 3);
    var _meshes = this._meshes, _meshCount = this._meshCount;
    for (var i = 0; i < _meshCount; i++) {
      _meshes[i] = this._createMesh(engine, i);
    }
  }
  var _proto = Basic2DBatcher2.prototype;
  _proto.drawElement = function drawElement(element) {
    var len = element.positions.length;
    if (this._vertexCount + len > Basic2DBatcher2.MAX_VERTEX_COUNT) {
      this.flush(element.camera.engine);
    }
    this._vertexCount += len;
    this._batchedQueue[this._elementCount++] = element;
  };
  _proto.flush = function flush(engine) {
    var batchedQueue = this._batchedQueue;
    if (batchedQueue.length === 0) {
      return;
    }
    this._updateData(engine);
    this.drawBatches(engine);
    if (!Basic2DBatcher2._canUploadSameBuffer) {
      this._flushId++;
    }
    batchedQueue.length = 0;
    this._subMeshPool.resetPool();
    this._vertexCount = 0;
    this._elementCount = 0;
  };
  _proto.clear = function clear() {
    this._flushId = 0;
    this._vertexCount = 0;
    this._elementCount = 0;
    this._batchedQueue.length = 0;
  };
  _proto.destroy = function destroy() {
    this._batchedQueue = null;
    var meshes = this._meshes, vertexBuffers = this._vertexBuffers, indiceBuffers = this._indiceBuffers;
    for (var i = 0, n = meshes.length; i < n; ++i) {
      meshes[i].destroy();
    }
    this._meshes = null;
    for (var _i = 0, _n = vertexBuffers.length; _i < _n; ++_i) {
      vertexBuffers[_i].destroy();
    }
    this._vertexBuffers = null;
    for (var _i2 = 0, _n2 = indiceBuffers.length; _i2 < _n2; ++_i2) {
      indiceBuffers[_i2].destroy();
    }
    this._indiceBuffers = null;
  };
  _proto._createMesh = function _createMesh(engine, index) {
    var MAX_VERTEX_COUNT = Basic2DBatcher2.MAX_VERTEX_COUNT;
    var mesh = new BufferMesh(engine, "BufferMesh" + index);
    var vertexElements = [];
    var vertexStride = this.createVertexElements(vertexElements);
    this._vertexBuffers[index] = new Buffer(engine, BufferBindFlag.VertexBuffer, MAX_VERTEX_COUNT * 4 * vertexStride, BufferUsage.Dynamic);
    this._indiceBuffers[index] = new Buffer(engine, BufferBindFlag.IndexBuffer, MAX_VERTEX_COUNT * 3, BufferUsage.Dynamic);
    mesh.setVertexBufferBinding(this._vertexBuffers[index], vertexStride);
    mesh.setIndexBufferBinding(this._indiceBuffers[index], IndexFormat.UInt16);
    mesh.setVertexElements(vertexElements);
    return mesh;
  };
  _proto._updateData = function _updateData(engine) {
    var _meshes = this._meshes, _flushId = this._flushId;
    if (!Basic2DBatcher2._canUploadSameBuffer && this._meshCount <= _flushId) {
      this._meshCount++;
      _meshes[_flushId] = this._createMesh(engine, _flushId);
    }
    var batchedQueue = this._batchedQueue, vertices = this._vertices, indices = this._indices;
    var mesh = _meshes[_flushId];
    mesh.clearSubMesh();
    var vertexIndex = 0;
    var indiceIndex = 0;
    var vertexStartIndex = 0;
    var vertexCount = 0;
    var curIndiceStartIndex = 0;
    var curMeshIndex = 0;
    var preElement = null;
    for (var i = 0, len = batchedQueue.length; i < len; i++) {
      var _curElement = batchedQueue[i];
      vertexIndex = this.updateVertices(_curElement, vertices, vertexIndex);
      var triangles = _curElement.triangles;
      var triangleNum = triangles.length;
      for (var j = 0; j < triangleNum; j++) {
        indices[indiceIndex++] = triangles[j] + curIndiceStartIndex;
      }
      curIndiceStartIndex += _curElement.positions.length;
      if (preElement === null) {
        vertexCount += triangleNum;
      } else {
        if (this.canBatch(preElement, _curElement)) {
          vertexCount += triangleNum;
        } else {
          mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex, vertexCount));
          vertexStartIndex += vertexCount;
          vertexCount = triangleNum;
          batchedQueue[curMeshIndex++] = preElement;
        }
      }
      preElement = _curElement;
    }
    mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex, vertexCount));
    batchedQueue[curMeshIndex] = preElement;
    this._vertexBuffers[_flushId].setData(vertices, 0, 0, vertexIndex);
    this._indiceBuffers[_flushId].setData(indices, 0, 0, indiceIndex);
  };
  _proto._getSubMeshFromPool = function _getSubMeshFromPool(start, count) {
    var subMesh = this._subMeshPool.getFromPool();
    subMesh.start = start;
    subMesh.count = count;
    subMesh.topology = MeshTopology.Triangles;
    return subMesh;
  };
  return Basic2DBatcher2;
}();
Basic2DBatcher.MAX_VERTEX_COUNT = 4096;
Basic2DBatcher._canUploadSameBuffer = true;
var SpriteMaskBatcher = function(_Basic2DBatcher) {
  _inheritsLoose(SpriteMaskBatcher2, _Basic2DBatcher);
  function SpriteMaskBatcher2() {
    return _Basic2DBatcher.apply(this, arguments) || this;
  }
  var _proto = SpriteMaskBatcher2.prototype;
  _proto.createVertexElements = function createVertexElements(vertexElements) {
    vertexElements[0] = new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0);
    vertexElements[1] = new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0);
    return 20;
  };
  _proto.canBatch = function canBatch(preElement, curElement) {
    if (preElement.isAdd !== curElement.isAdd) {
      return false;
    }
    var preShaderData = preElement.component.shaderData;
    var curShaderData = curElement.component.shaderData;
    var textureProperty = SpriteMask._textureProperty;
    var alphaCutoffProperty = SpriteMask._alphaCutoffProperty;
    return preShaderData.getTexture(textureProperty) === curShaderData.getTexture(textureProperty) && preShaderData.getTexture(alphaCutoffProperty) === curShaderData.getTexture(alphaCutoffProperty);
  };
  _proto.updateVertices = function updateVertices(element, vertices, vertexIndex) {
    var positions = element.positions, uv = element.uv;
    var verticesNum = positions.length;
    for (var i = 0; i < verticesNum; i++) {
      var curPos = positions[i];
      var curUV = uv[i];
      vertices[vertexIndex++] = curPos.x;
      vertices[vertexIndex++] = curPos.y;
      vertices[vertexIndex++] = curPos.z;
      vertices[vertexIndex++] = curUV.x;
      vertices[vertexIndex++] = curUV.y;
    }
    return vertexIndex;
  };
  _proto.drawBatches = function drawBatches(engine) {
    var mesh = this._meshes[this._flushId];
    var subMeshes = mesh.subMeshes;
    var batchedQueue = this._batchedQueue;
    for (var i = 0, len = subMeshes.length; i < len; i++) {
      var subMesh = subMeshes[i];
      var spriteMaskElement = batchedQueue[i];
      if (!subMesh || !spriteMaskElement) {
        return;
      }
      var renderer = spriteMaskElement.component;
      var material = spriteMaskElement.material;
      var compileMacros = Shader._compileMacros;
      ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, material.shaderData._macroCollection, compileMacros);
      var stencilState = material.renderState.stencilState;
      var op = spriteMaskElement.isAdd ? StencilOperation.IncrementSaturate : StencilOperation.DecrementSaturate;
      stencilState.passOperationFront = op;
      stencilState.passOperationBack = op;
      var program = material.shader._getShaderProgram(engine, compileMacros);
      if (!program.isValid) {
        return;
      }
      var camera = spriteMaskElement.camera;
      program.bind();
      program.groupingOtherUniformBlock();
      program.uploadAll(program.sceneUniformBlock, camera.scene.shaderData);
      program.uploadAll(program.cameraUniformBlock, camera.shaderData);
      program.uploadAll(program.rendererUniformBlock, renderer.shaderData);
      program.uploadAll(program.materialUniformBlock, material.shaderData);
      material.renderState._apply(engine);
      engine._hardwareRenderer.drawPrimitive(mesh, subMesh, program);
    }
  };
  return SpriteMaskBatcher2;
}(Basic2DBatcher);
var SpriteMaskManager = function() {
  function SpriteMaskManager2(engine) {
    this._batcher = void 0;
    this._preMaskLayer = 0;
    this._batcher = new SpriteMaskBatcher(engine);
  }
  var _proto = SpriteMaskManager2.prototype;
  _proto.clear = function clear() {
    this._preMaskLayer = 0;
    this._batcher.clear();
  };
  _proto.preRender = function preRender(camera, renderer) {
    if (renderer.maskInteraction === SpriteMaskInteraction.None) {
      return;
    }
    this._batcher.clear();
    this._processMasksDiff(camera, renderer);
    this._batcher.flush(camera.engine);
  };
  _proto.postRender = function postRender(renderer) {
    if (renderer.maskInteraction === SpriteMaskInteraction.None) {
      return;
    }
    this._preMaskLayer = renderer.maskLayer;
  };
  _proto.destroy = function destroy() {
    this._batcher.destroy();
    this._batcher = null;
  };
  _proto._processMasksDiff = function _processMasksDiff(camera, renderer) {
    var preMaskLayer = this._preMaskLayer;
    var curMaskLayer = renderer.maskLayer;
    if (preMaskLayer !== curMaskLayer) {
      var allMasks = camera._renderPipeline._allSpriteMasks;
      var commonLayer = preMaskLayer & curMaskLayer;
      var addLayer = curMaskLayer & ~preMaskLayer;
      var reduceLayer = preMaskLayer & ~curMaskLayer;
      var allMaskElements = allMasks._elements;
      for (var i = 0, n = allMasks.length; i < n; i++) {
        var mask = allMaskElements[i];
        var influenceLayers = mask.influenceLayers;
        if (influenceLayers & commonLayer) {
          continue;
        }
        if (influenceLayers & addLayer) {
          var maskRenderElement = mask._maskElement;
          maskRenderElement.isAdd = true;
          this._batcher.drawElement(maskRenderElement);
          continue;
        }
        if (influenceLayers & reduceLayer) {
          var _maskRenderElement = mask._maskElement;
          _maskRenderElement.isAdd = false;
          this._batcher.drawElement(_maskRenderElement);
        }
      }
    }
  };
  return SpriteMaskManager2;
}();
var BackgroundMode;
(function(BackgroundMode2) {
  BackgroundMode2[BackgroundMode2["SolidColor"] = 0] = "SolidColor";
  BackgroundMode2[BackgroundMode2["Sky"] = 1] = "Sky";
  BackgroundMode2[BackgroundMode2["Texture"] = 2] = "Texture";
})(BackgroundMode || (BackgroundMode = {}));
var BackgroundTextureFillMode;
(function(BackgroundTextureFillMode2) {
  BackgroundTextureFillMode2[BackgroundTextureFillMode2["AspectFitWidth"] = 0] = "AspectFitWidth";
  BackgroundTextureFillMode2[BackgroundTextureFillMode2["AspectFitHeight"] = 1] = "AspectFitHeight";
  BackgroundTextureFillMode2[BackgroundTextureFillMode2["Fill"] = 2] = "Fill";
})(BackgroundTextureFillMode || (BackgroundTextureFillMode = {}));
var Sky = function Sky2() {
  this.material = void 0;
  this.mesh = void 0;
  this._matrix = new Matrix();
};
var Background = function() {
  function Background2(_engine) {
    this._engine = _engine;
    this.mode = BackgroundMode.SolidColor;
    this.solidColor = new Color(0.25, 0.25, 0.25, 1);
    this.sky = new Sky();
    this._textureFillMode = BackgroundTextureFillMode.AspectFitHeight;
    this._texture = null;
  }
  var _proto = Background2.prototype;
  _proto._resizeBackgroundTexture = function _resizeBackgroundTexture() {
    if (!this._texture) {
      return;
    }
    var canvas = this._engine.canvas;
    var width = canvas.width, height = canvas.height;
    var _backgroundTextureMesh = this._engine._backgroundTextureMesh;
    var positions = _backgroundTextureMesh.getPositions();
    switch (this._textureFillMode) {
      case BackgroundTextureFillMode.Fill:
        positions[0].setValue(-1, -1, 1);
        positions[1].setValue(1, -1, 1);
        positions[2].setValue(-1, 1, 1);
        positions[3].setValue(1, 1, 1);
        break;
      case BackgroundTextureFillMode.AspectFitWidth:
        var fitWidthScale = this._texture.height * width / this.texture.width / height;
        positions[0].setValue(-1, -fitWidthScale, 1);
        positions[1].setValue(1, -fitWidthScale, 1);
        positions[2].setValue(-1, fitWidthScale, 1);
        positions[3].setValue(1, fitWidthScale, 1);
        break;
      case BackgroundTextureFillMode.AspectFitHeight:
        var fitHeightScale = this._texture.width * height / this.texture.height / width;
        positions[0].setValue(-fitHeightScale, -1, 1);
        positions[1].setValue(fitHeightScale, -1, 1);
        positions[2].setValue(-fitHeightScale, 1, 1);
        positions[3].setValue(fitHeightScale, 1, 1);
        break;
    }
    _backgroundTextureMesh.setPositions(positions);
    _backgroundTextureMesh.uploadData(false);
  };
  _createClass(Background2, [{
    key: "texture",
    get: function get4() {
      return this._texture;
    },
    set: function set4(value) {
      if (this._texture !== value) {
        this._texture = value;
        this._engine._backgroundTextureMaterial.shaderData.setTexture("u_baseTexture", value);
      }
    }
  }, {
    key: "textureFillMode",
    get: function get4() {
      return this._textureFillMode;
    },
    set: function set4(value) {
      if (value !== this._textureFillMode) {
        this._textureFillMode = value;
        this._resizeBackgroundTexture();
      }
    }
  }]);
  return Background2;
}();
var DiffuseMode;
(function(DiffuseMode2) {
  DiffuseMode2[DiffuseMode2["SolidColor"] = 0] = "SolidColor";
  DiffuseMode2[DiffuseMode2["SphericalHarmonics"] = 1] = "SphericalHarmonics";
})(DiffuseMode || (DiffuseMode = {}));
var AmbientLight = function() {
  function AmbientLight2(scene) {
    this._scene = void 0;
    this._diffuseSphericalHarmonics = void 0;
    this._diffuseSolidColor = new Color(0.212, 0.227, 0.259);
    this._diffuseIntensity = 1;
    this._specularReflection = void 0;
    this._specularIntensity = 1;
    this._diffuseMode = DiffuseMode.SolidColor;
    this._shArray = new Float32Array(27);
    this._scene = scene;
    var shaderData = this._scene.shaderData;
    shaderData.setColor(AmbientLight2._diffuseColorProperty, this._diffuseSolidColor);
    shaderData.setFloat(AmbientLight2._diffuseIntensityProperty, this._diffuseIntensity);
    shaderData.setFloat(AmbientLight2._specularIntensityProperty, this._specularIntensity);
  }
  var _proto = AmbientLight2.prototype;
  _proto._preComputeSH = function _preComputeSH(sh2, out) {
    var src = sh2.coefficients;
    out[0] = src[0] * 0.886227;
    out[1] = src[1] * 0.886227;
    out[2] = src[2] * 0.886227;
    out[3] = src[3] * -1.023327;
    out[4] = src[4] * -1.023327;
    out[5] = src[5] * -1.023327;
    out[6] = src[6] * 1.023327;
    out[7] = src[7] * 1.023327;
    out[8] = src[8] * 1.023327;
    out[9] = src[9] * -1.023327;
    out[10] = src[10] * -1.023327;
    out[11] = src[11] * -1.023327;
    out[12] = src[12] * 0.858086;
    out[13] = src[13] * 0.858086;
    out[14] = src[14] * 0.858086;
    out[15] = src[15] * -0.858086;
    out[16] = src[16] * -0.858086;
    out[17] = src[17] * -0.858086;
    out[18] = src[18] * 0.247708;
    out[19] = src[19] * 0.247708;
    out[20] = src[20] * 0.247708;
    out[21] = src[21] * -0.858086;
    out[22] = src[22] * -0.858086;
    out[23] = src[23] * -0.858086;
    out[24] = src[24] * 0.429042;
    out[25] = src[25] * 0.429042;
    out[26] = src[26] * 0.429042;
    return out;
  };
  _createClass(AmbientLight2, [{
    key: "diffuseMode",
    get: function get4() {
      return this._diffuseMode;
    },
    set: function set4(value) {
      this._diffuseMode = value;
      if (value === DiffuseMode.SphericalHarmonics) {
        this._scene.shaderData.enableMacro(AmbientLight2._shMacro);
      } else {
        this._scene.shaderData.disableMacro(AmbientLight2._shMacro);
      }
    }
  }, {
    key: "diffuseSolidColor",
    get: function get4() {
      return this._diffuseSolidColor;
    },
    set: function set4(value) {
      if (value !== this._diffuseSolidColor) {
        value.cloneTo(this._diffuseSolidColor);
      }
    }
  }, {
    key: "diffuseSphericalHarmonics",
    get: function get4() {
      return this._diffuseSphericalHarmonics;
    },
    set: function set4(value) {
      this._diffuseSphericalHarmonics = value;
      var shaderData = this._scene.shaderData;
      if (value) {
        shaderData.setFloatArray(AmbientLight2._diffuseSHProperty, this._preComputeSH(value, this._shArray));
      }
    }
  }, {
    key: "diffuseIntensity",
    get: function get4() {
      return this._diffuseIntensity;
    },
    set: function set4(value) {
      this._diffuseIntensity = value;
      this._scene.shaderData.setFloat(AmbientLight2._diffuseIntensityProperty, value);
    }
  }, {
    key: "specularTexture",
    get: function get4() {
      return this._specularReflection;
    },
    set: function set4(value) {
      this._specularReflection = value;
      var shaderData = this._scene.shaderData;
      if (value) {
        shaderData.setTexture(AmbientLight2._specularTextureProperty, value);
        shaderData.setFloat(AmbientLight2._mipLevelProperty, this._specularReflection.mipmapCount);
        shaderData.enableMacro(AmbientLight2._specularMacro);
      } else {
        shaderData.disableMacro(AmbientLight2._specularMacro);
      }
    }
  }, {
    key: "specularIntensity",
    get: function get4() {
      return this._specularIntensity;
    },
    set: function set4(value) {
      this._specularIntensity = value;
      this._scene.shaderData.setFloat(AmbientLight2._specularIntensityProperty, value);
    }
  }]);
  return AmbientLight2;
}();
AmbientLight._shMacro = Shader.getMacroByName("O3_USE_SH");
AmbientLight._specularMacro = Shader.getMacroByName("O3_USE_SPECULAR_ENV");
AmbientLight._diffuseColorProperty = Shader.getPropertyByName("u_envMapLight.diffuse");
AmbientLight._diffuseSHProperty = Shader.getPropertyByName("u_env_sh");
AmbientLight._diffuseIntensityProperty = Shader.getPropertyByName("u_envMapLight.diffuseIntensity");
AmbientLight._specularTextureProperty = Shader.getPropertyByName("u_env_specularSampler");
AmbientLight._specularIntensityProperty = Shader.getPropertyByName("u_envMapLight.specularIntensity");
AmbientLight._mipLevelProperty = Shader.getPropertyByName("u_envMapLight.mipMapLevel");
var SceneFeature = function() {
  function SceneFeature2() {
  }
  var _proto = SceneFeature2.prototype;
  _proto.preUpdate = function preUpdate(scene) {
  };
  _proto.postUpdate = function postUpdate(scene) {
  };
  _proto.preRender = function preRender(scene, camera) {
  };
  _proto.postRender = function postRender(scene, camera) {
  };
  _proto.destroy = function destroy(scene) {
  };
  return SceneFeature2;
}();
var Light = function(_Component) {
  _inheritsLoose(Light2, _Component);
  function Light2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this._viewMat = void 0;
    _this._inverseViewMat = void 0;
    return _this;
  }
  var _proto = Light2.prototype;
  _proto._onEnable = function _onEnable() {
    this.scene.findFeature(LightFeature).attachRenderLight(this);
  };
  _proto._onDisable = function _onDisable() {
    this.scene.findFeature(LightFeature).detachRenderLight(this);
  };
  _createClass(Light2, [{
    key: "viewMatrix",
    get: function get4() {
      if (!this._viewMat)
        this._viewMat = new Matrix();
      Matrix.invert(this.entity.transform.worldMatrix, this._viewMat);
      return this._viewMat;
    }
  }, {
    key: "inverseViewMatrix",
    get: function get4() {
      if (!this._inverseViewMat)
        this._inverseViewMat = new Matrix();
      Matrix.invert(this.viewMatrix, this._inverseViewMat);
      return this._inverseViewMat;
    }
  }]);
  return Light2;
}(Component);
Light._maxLight = 10;
var DirectLight = function(_Light) {
  _inheritsLoose(DirectLight2, _Light);
  function DirectLight2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Light.call.apply(_Light, [this].concat(args)) || this;
    _this.color = new Color(1, 1, 1, 1);
    _this.intensity = 1;
    _this._forward = new Vector3();
    _this._lightColor = new Color(1, 1, 1, 1);
    _this._reverseDirection = new Vector3();
    return _this;
  }
  DirectLight2._updateShaderData = function _updateShaderData(shaderData) {
    var data = DirectLight2._combinedData;
    shaderData.setFloatArray(DirectLight2._colorProperty, data.color);
    shaderData.setFloatArray(DirectLight2._directionProperty, data.direction);
  };
  var _proto = DirectLight2.prototype;
  _proto._appendData = function _appendData(lightIndex) {
    var colorStart = lightIndex * 3;
    var directionStart = lightIndex * 3;
    var lightColor = this.lightColor;
    var direction = this.direction;
    var data = DirectLight2._combinedData;
    data.color[colorStart] = lightColor.r;
    data.color[colorStart + 1] = lightColor.g;
    data.color[colorStart + 2] = lightColor.b;
    data.direction[directionStart] = direction.x;
    data.direction[directionStart + 1] = direction.y;
    data.direction[directionStart + 2] = direction.z;
  };
  _createClass(DirectLight2, [{
    key: "direction",
    get: function get4() {
      this.entity.transform.getWorldForward(this._forward);
      return this._forward;
    }
  }, {
    key: "lightColor",
    get: function get4() {
      this._lightColor.r = this.color.r * this.intensity;
      this._lightColor.g = this.color.g * this.intensity;
      this._lightColor.b = this.color.b * this.intensity;
      this._lightColor.a = this.color.a * this.intensity;
      return this._lightColor;
    }
  }, {
    key: "reverseDirection",
    get: function get4() {
      Vector3.scale(this.direction, -1, this._reverseDirection);
      return this._reverseDirection;
    }
  }]);
  return DirectLight2;
}(Light);
DirectLight._colorProperty = Shader.getPropertyByName("u_directLightColor");
DirectLight._directionProperty = Shader.getPropertyByName("u_directLightDirection");
DirectLight._combinedData = {
  color: new Float32Array(3 * Light._maxLight),
  direction: new Float32Array(3 * Light._maxLight)
};
var PointLight = function(_Light) {
  _inheritsLoose(PointLight2, _Light);
  function PointLight2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Light.call.apply(_Light, [this].concat(args)) || this;
    _this.color = new Color(1, 1, 1, 1);
    _this.intensity = 1;
    _this.distance = 100;
    _this._lightColor = new Color(1, 1, 1, 1);
    return _this;
  }
  PointLight2._updateShaderData = function _updateShaderData(shaderData) {
    var data = PointLight2._combinedData;
    shaderData.setFloatArray(PointLight2._colorProperty, data.color);
    shaderData.setFloatArray(PointLight2._positionProperty, data.position);
    shaderData.setFloatArray(PointLight2._distanceProperty, data.distance);
  };
  var _proto = PointLight2.prototype;
  _proto._appendData = function _appendData(lightIndex) {
    var colorStart = lightIndex * 3;
    var positionStart = lightIndex * 3;
    var distanceStart = lightIndex;
    var lightColor = this.lightColor;
    var lightPosition = this.position;
    var data = PointLight2._combinedData;
    data.color[colorStart] = lightColor.r;
    data.color[colorStart + 1] = lightColor.g;
    data.color[colorStart + 2] = lightColor.b;
    data.position[positionStart] = lightPosition.x;
    data.position[positionStart + 1] = lightPosition.y;
    data.position[positionStart + 2] = lightPosition.z;
    data.distance[distanceStart] = this.distance;
  };
  _createClass(PointLight2, [{
    key: "position",
    get: function get4() {
      return this.entity.transform.worldPosition;
    }
  }, {
    key: "lightColor",
    get: function get4() {
      this._lightColor.r = this.color.r * this.intensity;
      this._lightColor.g = this.color.g * this.intensity;
      this._lightColor.b = this.color.b * this.intensity;
      this._lightColor.a = this.color.a * this.intensity;
      return this._lightColor;
    }
  }]);
  return PointLight2;
}(Light);
PointLight._colorProperty = Shader.getPropertyByName("u_pointLightColor");
PointLight._positionProperty = Shader.getPropertyByName("u_pointLightPosition");
PointLight._distanceProperty = Shader.getPropertyByName("u_pointLightDistance");
PointLight._combinedData = {
  color: new Float32Array(3 * Light._maxLight),
  position: new Float32Array(3 * Light._maxLight),
  distance: new Float32Array(Light._maxLight)
};
var SpotLight = function(_Light) {
  _inheritsLoose(SpotLight2, _Light);
  function SpotLight2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Light.call.apply(_Light, [this].concat(args)) || this;
    _this.color = new Color(1, 1, 1, 1);
    _this.intensity = 1;
    _this.distance = 100;
    _this.angle = Math.PI / 6;
    _this.penumbra = Math.PI / 12;
    _this._forward = new Vector3();
    _this._lightColor = new Color(1, 1, 1, 1);
    _this._inverseDirection = new Vector3();
    return _this;
  }
  SpotLight2._updateShaderData = function _updateShaderData(shaderData) {
    var data = SpotLight2._combinedData;
    shaderData.setFloatArray(SpotLight2._colorProperty, data.color);
    shaderData.setFloatArray(SpotLight2._positionProperty, data.position);
    shaderData.setFloatArray(SpotLight2._directionProperty, data.direction);
    shaderData.setFloatArray(SpotLight2._distanceProperty, data.distance);
    shaderData.setFloatArray(SpotLight2._angleCosProperty, data.angleCos);
    shaderData.setFloatArray(SpotLight2._penumbraCosProperty, data.penumbraCos);
  };
  var _proto = SpotLight2.prototype;
  _proto._appendData = function _appendData(lightIndex) {
    var colorStart = lightIndex * 3;
    var positionStart = lightIndex * 3;
    var directionStart = lightIndex * 3;
    var distanceStart = lightIndex;
    var penumbraCosStart = lightIndex;
    var angleCosStart = lightIndex;
    var color = this.lightColor;
    var position = this.position;
    var direction = this.direction;
    var data = SpotLight2._combinedData;
    data.color[colorStart] = color.r;
    data.color[colorStart + 1] = color.g;
    data.color[colorStart + 2] = color.b;
    data.position[positionStart] = position.x;
    data.position[positionStart + 1] = position.y;
    data.position[positionStart + 2] = position.z;
    data.direction[directionStart] = direction.x;
    data.direction[directionStart + 1] = direction.y;
    data.direction[directionStart + 2] = direction.z;
    data.distance[distanceStart] = this.distance;
    data.angleCos[angleCosStart] = Math.cos(this.angle);
    data.penumbraCos[penumbraCosStart] = Math.cos(this.angle + this.penumbra);
  };
  _createClass(SpotLight2, [{
    key: "position",
    get: function get4() {
      return this.entity.transform.worldPosition;
    }
  }, {
    key: "direction",
    get: function get4() {
      this.entity.transform.getWorldForward(this._forward);
      return this._forward;
    }
  }, {
    key: "reverseDirection",
    get: function get4() {
      Vector3.scale(this.direction, -1, this._inverseDirection);
      return this._inverseDirection;
    }
  }, {
    key: "lightColor",
    get: function get4() {
      this._lightColor.r = this.color.r * this.intensity;
      this._lightColor.g = this.color.g * this.intensity;
      this._lightColor.b = this.color.b * this.intensity;
      this._lightColor.a = this.color.a * this.intensity;
      return this._lightColor;
    }
  }]);
  return SpotLight2;
}(Light);
SpotLight._colorProperty = Shader.getPropertyByName("u_spotLightColor");
SpotLight._positionProperty = Shader.getPropertyByName("u_spotLightPosition");
SpotLight._directionProperty = Shader.getPropertyByName("u_spotLightDirection");
SpotLight._distanceProperty = Shader.getPropertyByName("u_spotLightDistance");
SpotLight._angleCosProperty = Shader.getPropertyByName("u_spotLightAngleCos");
SpotLight._penumbraCosProperty = Shader.getPropertyByName("u_spotLightPenumbraCos");
SpotLight._combinedData = {
  color: new Float32Array(3 * Light._maxLight),
  position: new Float32Array(3 * Light._maxLight),
  direction: new Float32Array(3 * Light._maxLight),
  distance: new Float32Array(Light._maxLight),
  angleCos: new Float32Array(Light._maxLight),
  penumbraCos: new Float32Array(Light._maxLight)
};
function hasLight() {
  return this.findFeature(LightFeature).visibleLights.length > 0;
}
var LightFeature = function(_SceneFeature) {
  _inheritsLoose(LightFeature2, _SceneFeature);
  function LightFeature2() {
    var _this;
    _this = _SceneFeature.call(this) || this;
    _this.visibleLights = void 0;
    _this.visibleLights = [];
    return _this;
  }
  var _proto = LightFeature2.prototype;
  _proto.attachRenderLight = function attachRenderLight(light) {
    var index = this.visibleLights.indexOf(light);
    if (index == -1) {
      this.visibleLights.push(light);
    } else {
      Logger.warn("Light already attached.");
    }
  };
  _proto.detachRenderLight = function detachRenderLight(light) {
    var index = this.visibleLights.indexOf(light);
    if (index != -1) {
      this.visibleLights.splice(index, 1);
    }
  };
  _proto._updateShaderData = function _updateShaderData(shaderData) {
    var directLightCount = 0;
    var pointLightCount = 0;
    var spotLightCount = 0;
    var lights = this.visibleLights;
    for (var i = 0, len = lights.length; i < len; i++) {
      var light = lights[i];
      if (light instanceof DirectLight) {
        light._appendData(directLightCount++);
      } else if (light instanceof PointLight) {
        light._appendData(pointLightCount++);
      } else if (light instanceof SpotLight) {
        light._appendData(spotLightCount++);
      }
    }
    if (directLightCount) {
      DirectLight._updateShaderData(shaderData);
      shaderData.enableMacro("O3_DIRECT_LIGHT_COUNT", directLightCount.toString());
    } else {
      shaderData.disableMacro("O3_DIRECT_LIGHT_COUNT");
    }
    if (pointLightCount) {
      PointLight._updateShaderData(shaderData);
      shaderData.enableMacro("O3_POINT_LIGHT_COUNT", pointLightCount.toString());
    } else {
      shaderData.disableMacro("O3_POINT_LIGHT_COUNT");
    }
    if (spotLightCount) {
      SpotLight._updateShaderData(shaderData);
      shaderData.enableMacro("O3_SPOT_LIGHT_COUNT", spotLightCount.toString());
    } else {
      shaderData.disableMacro("O3_SPOT_LIGHT_COUNT");
    }
  };
  return LightFeature2;
}(SceneFeature);
var Scene = function(_EngineObject) {
  _inheritsLoose(Scene2, _EngineObject);
  function Scene2(engine, name) {
    var _this;
    _this = _EngineObject.call(this, engine) || this;
    _this.name = void 0;
    _this.background = new Background(_this._engine);
    _this.ambientLight = void 0;
    _this.shaderData = new ShaderData(ShaderDataGroup.Scene);
    _this._activeCameras = [];
    _this._isActiveInEngine = false;
    _this._destroyed = false;
    _this._rootEntities = [];
    _this.features = [];
    _this.name = name || "";
    var shaderData = _this.shaderData;
    Scene2.sceneFeatureManager.addObject(_assertThisInitialized(_this));
    shaderData._addRefCount(1);
    _this.ambientLight = new AmbientLight(_assertThisInitialized(_this));
    return _this;
  }
  var _proto = Scene2.prototype;
  _proto.createRootEntity = function createRootEntity(name) {
    var entity = new Entity(this._engine, name);
    this.addRootEntity(entity);
    return entity;
  };
  _proto.addRootEntity = function addRootEntity(entity) {
    var isRoot = entity._isRoot;
    if (!isRoot) {
      entity._isRoot = true;
      entity._removeFromParent();
    }
    var oldScene = entity._scene;
    if (oldScene !== this) {
      if (oldScene && isRoot) {
        oldScene._removeEntity(entity);
      }
      this._rootEntities.push(entity);
      Entity._traverseSetOwnerScene(entity, this);
    } else if (!isRoot) {
      this._rootEntities.push(entity);
    }
    if (this._isActiveInEngine) {
      !entity._isActiveInHierarchy && entity._isActive && entity._processActive();
    } else {
      entity._isActiveInHierarchy && entity._processInActive();
    }
  };
  _proto.removeRootEntity = function removeRootEntity(entity) {
    if (entity._isRoot && entity._scene == this) {
      this._removeEntity(entity);
      this._isActiveInEngine && entity._processInActive();
      Entity._traverseSetOwnerScene(entity, null);
    }
  };
  _proto.getRootEntity = function getRootEntity(index) {
    if (index === void 0) {
      index = 0;
    }
    return this._rootEntities[index];
  };
  _proto.findEntityByName = function findEntityByName(name) {
    var children = this._rootEntities;
    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];
      if (child.name === name) {
        return child;
      }
    }
    for (var _i = children.length - 1; _i >= 0; _i--) {
      var _child = children[_i];
      var entity = _child.findByName(name);
      if (entity) {
        return entity;
      }
    }
    return null;
  };
  _proto.findEntityByPath = function findEntityByPath(path) {
    var splits = path.split("/").filter(Boolean);
    for (var i = 0, n = this.rootEntitiesCount; i < n; i++) {
      var findEntity = this.getRootEntity(i);
      if (findEntity.name != splits[0])
        continue;
      for (var j = 1, m = splits.length; j < m; ++j) {
        findEntity = Entity._findChildByName(findEntity, splits[j]);
        if (!findEntity)
          break;
      }
      return findEntity;
    }
    return null;
  };
  _proto.destroy = function destroy() {
    if (this._destroyed) {
      return;
    }
    this._isActiveInEngine && (this._engine.sceneManager.activeScene = null);
    Scene2.sceneFeatureManager.callFeatureMethod(this, "destroy", [this]);
    for (var i = 0, n = this.rootEntitiesCount; i < n; i++) {
      this._rootEntities[i].destroy();
    }
    this._rootEntities.length = 0;
    this._activeCameras.length = 0;
    Scene2.sceneFeatureManager._objects = [];
    this.shaderData._addRefCount(-1);
    this._destroyed = true;
  };
  _proto._attachRenderCamera = function _attachRenderCamera(camera) {
    var index = this._activeCameras.indexOf(camera);
    if (index === -1) {
      this._activeCameras.push(camera);
    } else {
      Logger.warn("Camera already attached.");
    }
  };
  _proto._detachRenderCamera = function _detachRenderCamera(camera) {
    var index = this._activeCameras.indexOf(camera);
    if (index !== -1) {
      this._activeCameras.splice(index, 1);
    }
  };
  _proto._processActive = function _processActive(active) {
    this._isActiveInEngine = active;
    var rootEntities = this._rootEntities;
    for (var i = rootEntities.length - 1; i >= 0; i--) {
      var entity = rootEntities[i];
      if (entity._isActive) {
        active ? entity._processActive() : entity._processInActive();
      }
    }
  };
  _proto._updateShaderData = function _updateShaderData() {
    var lightMgr = this.findFeature(LightFeature);
    lightMgr._updateShaderData(this.shaderData);
  };
  _proto._removeEntity = function _removeEntity(entity) {
    var oldRootEntities = this._rootEntities;
    oldRootEntities.splice(oldRootEntities.indexOf(entity), 1);
  };
  Scene2.registerFeature = function registerFeature(Feature) {
    Scene2.sceneFeatureManager.registerFeature(Feature);
  };
  _proto.findFeature = function findFeature(Feature) {
    return Scene2.sceneFeatureManager.findFeature(this, Feature);
  };
  _createClass(Scene2, [{
    key: "rootEntitiesCount",
    get: function get4() {
      return this._rootEntities.length;
    }
  }, {
    key: "rootEntities",
    get: function get4() {
      return this._rootEntities;
    }
  }, {
    key: "destroyed",
    get: function get4() {
      return this._destroyed;
    }
  }]);
  return Scene2;
}(EngineObject);
Scene.sceneFeatureManager = new FeatureManager();
var SceneManager = function() {
  function SceneManager3(engine) {
    this.engine = engine;
    this._activeScene = void 0;
  }
  var _proto = SceneManager3.prototype;
  _proto.loadScene = function loadScene(url, destroyOldScene) {
    var _this = this;
    if (destroyOldScene === void 0) {
      destroyOldScene = true;
    }
    var scenePromise = this.engine.resourceManager.load(url);
    scenePromise.then(function(scene) {
      var oldScene = _this._activeScene;
      _this.activeScene = scene;
      if (oldScene && destroyOldScene) {
        oldScene.destroy();
      }
    });
    return scenePromise;
  };
  _proto.mergeScenes = function mergeScenes(sourceScene, destScene) {
    var oldRootEntities = sourceScene.rootEntities;
    for (var i = 0, n = oldRootEntities.length; i < n; i++) {
      destScene.addRootEntity(oldRootEntities[i]);
    }
  };
  _createClass(SceneManager3, [{
    key: "activeScene",
    get: function get4() {
      return this._activeScene;
    },
    set: function set4(scene) {
      var oldScene = this._activeScene;
      if (oldScene !== scene) {
        oldScene && oldScene._processActive(false);
        scene && scene._processActive(true);
        this._activeScene = scene;
      }
    }
  }]);
  return SceneManager3;
}();
var blinnPhongFs = "#define GLSLIFY 1\n#include <common>\n#include <common_frag>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <pbr_envmap_light_frag_define>\n#include <direct_light_frag>\n#include <point_light_frag>\n#include <spot_light_frag>\n#include <mobile_material_frag>\n#include <fog_share>\n#include <normal_get>\nvoid main(){\n#include <begin_mobile_frag>\n#include <begin_viewdir_frag>\n#include <mobile_blinnphong_frag>\ngl_FragColor=emission+ambient+diffuse+specular;gl_FragColor.a=diffuse.a;\n#include <fog_frag>\n}";
var blinnPhongVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <shadow_vert>\n#include <position_vert>\n#include <fog_vert>\n}";
var particleFs = "#define GLSLIFY 1\nvarying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;uniform sampler2D u_texture;void main(){if(v_lifeLeft==1.0){discard;}float alphaFactor=1.0;\n#ifdef fadeIn\nfloat fadeInFactor=step(0.5,v_lifeLeft);alphaFactor=2.0*fadeInFactor*(1.0-v_lifeLeft)+(1.0-fadeInFactor);\n#endif\n#ifdef fadeOut\nfloat fadeOutFactor=step(0.5,v_lifeLeft);alphaFactor=alphaFactor*2.0*(1.0-fadeOutFactor)*v_lifeLeft+alphaFactor*fadeOutFactor;\n#endif\n#ifdef particleTexture\nvec4 tex=texture2D(u_texture,v_uv);\n#ifdef useOriginColor\ngl_FragColor=vec4(tex.rgb,alphaFactor*tex.a*v_color.w);\n#else\ngl_FragColor=vec4(v_color.xyz*tex.rgb,alphaFactor*tex.a*v_color.w);\n#endif\n#else\ngl_FragColor=vec4(v_color.xyz,alphaFactor*v_color.w);\n#endif\n}";
var particleVs = "#define GLSLIFY 1\nattribute vec3 a_position;attribute vec3 a_velocity;attribute vec3 a_acceleration;attribute vec4 a_color;attribute vec4 a_lifeAndSize;attribute vec2 a_rotation;attribute vec3 a_uv;attribute vec2 a_normalizedUv;uniform float u_time;uniform bool u_once;uniform mat4 u_MVPMat;varying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;\n#ifdef is2d\nuniform mat4 u_viewInvMat;uniform mat4 u_projMat;uniform mat4 u_viewMat;uniform mat4 u_modelMat;\n#endif\nmat2 rotation2d(float angle){float s=sin(angle);float c=cos(angle);return mat2(c,-s,s,c);}void main(){v_color=a_color;v_uv=a_uv.xy;float life=a_lifeAndSize.y;float startTime=a_lifeAndSize.x;float deltaTime=max(mod(u_time-startTime,life),0.0);if((u_once&&u_time>life+startTime)){deltaTime=0.0;}v_lifeLeft=1.0-deltaTime/life;float scale=a_lifeAndSize.z;vec3 position=a_position+(a_velocity+a_acceleration*deltaTime*0.5)*deltaTime;\n#ifdef isScaleByLifetime\nscale*=v_lifeLeft;\n#else\nscale*=pow(a_lifeAndSize.w,deltaTime);\n#endif\n#ifdef rotateToVelocity\nvec3 v=a_velocity+a_acceleration*deltaTime;float angle=atan(v.z,v.x)*2.0;\n#else\nfloat deltaAngle=deltaTime*a_rotation.y;float angle=a_rotation.x+deltaAngle;\n#endif\n#ifdef is2d\nvec2 rotatedPoint=rotation2d(angle)*vec2(a_normalizedUv.x,a_normalizedUv.y*a_uv.z);vec3 basisX=u_viewInvMat[0].xyz;vec3 basisZ=u_viewInvMat[1].xyz;vec3 localPosition=vec3(basisX*rotatedPoint.x+basisZ*rotatedPoint.y)*scale+position;gl_Position=u_projMat*u_viewMat*vec4(localPosition+u_modelMat[3].xyz,1.);\n#else\n#ifdef rotateToVelocity\nfloat s=sin(angle);float c=cos(angle);\n#else\nfloat s=sin(angle);float c=cos(angle);\n#endif\nvec4 rotatedPoint=vec4((a_normalizedUv.x*c+a_normalizedUv.y*a_uv.z*s)*scale,0.,(a_normalizedUv.x*s-a_normalizedUv.y*a_uv.z*c)*scale,1.);vec4 orientation=vec4(0,0,0,1);vec4 q2=orientation+orientation;vec4 qx=orientation.xxxw*q2.xyzx;vec4 qy=orientation.xyyw*q2.xyzy;vec4 qz=orientation.xxzw*q2.xxzz;mat4 localMatrix=mat4((1.0-qy.y)-qz.z,qx.y+qz.w,qx.z-qy.w,0,qx.y-qz.w,(1.0-qx.x)-qz.z,qy.z+qx.w,0,qx.z+qy.w,qy.z-qx.w,(1.0-qx.x)-qy.y,0,position.x,position.y,position.z,1);rotatedPoint=localMatrix*rotatedPoint;gl_Position=u_MVPMat*rotatedPoint;\n#endif\n}";
var pbrFs = "#define GLSLIFY 1\n#include <common>\n#include <common_frag>\n#include <pbr_common_frag_define>\n#include <pbr_util_frag_define>\n#include <fog_share>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <direct_light_frag>\n#include <point_light_frag>\n#include <spot_light_frag>\n#include <pbr_envmap_light_frag_define>\n#include <pbr_base_frag_define>\n#include <pbr_texture_frag_define>\n#include <pbr_runtime_frag_define>\n#include <normal_get>\n#include <pbr_brdf_cook_torrance_frag_define>\n#include <pbr_direct_irradiance_frag_define>\n#include <pbr_ibl_diffuse_frag_define>\n#include <pbr_ibl_specular_frag_define>\nvoid main(){\n#include <pbr_begin_frag>\n#include <pbr_direct_irradiance_frag>\n#include <pbr_ibl_diffuse_frag>\n#include <pbr_ibl_specular_frag>\n#include <pbr_end_frag>\n#include <gamma_frag>\n#include <fog_frag>\n}";
var pbrVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <shadow_vert>\n#include <position_vert>\n#include <fog_vert>\n}";
var shadowMapFs = "#define GLSLIFY 1\nvec4 pack(float depth){const vec4 bitShift=vec4(1.0,256.0,256.0*256.0,256.0*256.0*256.0);const vec4 bitMask=vec4(1.0/256.0,1.0/256.0,1.0/256.0,0.0);vec4 rgbaDepth=fract(depth*bitShift);rgbaDepth-=rgbaDepth.gbaa*bitMask;return rgbaDepth;}void main(){gl_FragColor=pack(gl_FragCoord.z);}";
var shadowMapVs = "#define GLSLIFY 1\n#include <common_vert>\n#include <blendShape_input>\n#include <normal_share>\n#include <shadow_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <shadow_vert>\n#include <position_vert>\n}";
var shadowFs = "#define GLSLIFY 1\n#ifdef O3_SHADOW_MAP_COUNT\nuniform float u_shadowBias[O3_SHADOW_MAP_COUNT];uniform float u_shadowIntensity[O3_SHADOW_MAP_COUNT];uniform float u_shadowRadius[O3_SHADOW_MAP_COUNT];uniform vec2 u_shadowMapSize[O3_SHADOW_MAP_COUNT];uniform sampler2D u_shadowMaps[O3_SHADOW_MAP_COUNT];varying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];const vec4 bitShift=vec4(1.0,1.0/256.0,1.0/(256.0*256.0),1.0/(256.0*256.0*256.0));float unpack(const in vec4 rgbaDepth){return dot(rgbaDepth,bitShift);}float getVisibility(vec4 positionFromLight,const in sampler2D shadowMap,vec2 mapSize,float intensity,float bias,float radius){vec3 shadowCoord=(positionFromLight.xyz/positionFromLight.w)/2.0+0.5;float filterX=step(0.0,shadowCoord.x)*(1.0-step(1.0,shadowCoord.x));float filterY=step(0.0,shadowCoord.y)*(1.0-step(1.0,shadowCoord.y));shadowCoord.z-=bias;vec2 texelSize=vec2(1.0)/mapSize;float visibility=0.0;for(float y=-1.0;y<=1.0;y+=1.0){for(float x=-1.0;x<=1.0;x+=1.0){vec2 uv=shadowCoord.xy+texelSize*vec2(x,y)*radius;vec4 rgbaDepth=texture2D(shadowMap,uv);float depth=unpack(rgbaDepth);visibility+=step(depth,shadowCoord.z)*intensity;}}visibility*=(1.0/9.0);return visibility*filterX*filterY;}\n#endif\nvoid main(){vec4 shadowColor=vec4(1.0,1.0,1.0,1.0);\n#ifdef O3_SHADOW_MAP_COUNT\nfloat visibility=1.0;\n#if (O3_SHADOW_MAP_COUNT == 1)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);\n#elif (O3_SHADOW_MAP_COUNT == 2)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);visibility-=getVisibility(v_PositionFromLight[1],u_shadowMaps[1],u_shadowMapSize[1],u_shadowIntensity[1],u_shadowBias[1],u_shadowRadius[1]);\n#elif (O3_SHADOW_MAP_COUNT == 3)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);visibility-=getVisibility(v_PositionFromLight[1],u_shadowMaps[1],u_shadowMapSize[1],u_shadowIntensity[1],u_shadowBias[1],u_shadowRadius[1]);visibility-=getVisibility(v_PositionFromLight[2],u_shadowMaps[2],u_shadowMapSize[2],u_shadowIntensity[2],u_shadowBias[2],u_shadowRadius[2]);\n#endif\nvisibility=clamp(visibility,0.0,1.0);shadowColor=vec4(visibility,visibility,visibility,1.0);\n#endif\ngl_FragColor=shadowColor;}";
var skyboxFs = "#define GLSLIFY 1\nuniform samplerCube u_cube;varying vec3 v_cubeUV;void main(){gl_FragColor=textureCube(u_cube,v_cubeUV);}";
var skyboxVs = "#define GLSLIFY 1\n#include <common_vert>\nuniform mat4 u_mvpNoscale;varying vec3 v_cubeUV;void main(){v_cubeUV=POSITION.xyz;gl_Position=u_mvpNoscale*vec4(POSITION,1.0);gl_Position.z=gl_Position.w;}";
var spriteMaskFs = "#define GLSLIFY 1\nuniform sampler2D u_maskTexture;uniform float u_maskAlphaCutoff;varying vec2 v_uv;void main(){vec4 color=texture2D(u_maskTexture,v_uv);if(color.a<u_maskAlphaCutoff){discard;}gl_FragColor=color;}";
var spriteMaskVs = "#define GLSLIFY 1\nuniform mat4 u_VPMat;attribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=u_VPMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}";
var spriteFs = "#define GLSLIFY 1\n#ifdef USE_CUSTOM_TEXTURE\nuniform sampler2D u_cusTomTexture;\n#else\nuniform sampler2D u_spriteTexture;\n#endif\nvarying vec2 v_uv;varying vec4 v_color;void main(){\n#ifdef USE_CUSTOM_TEXTURE\nvec4 baseColor=texture2D(u_cusTomTexture,v_uv);\n#else\nvec4 baseColor=texture2D(u_spriteTexture,v_uv);\n#endif\ngl_FragColor=baseColor*v_color;}";
var spriteVs = "#define GLSLIFY 1\n#ifdef USE_MODEL_MATRIX\nuniform mat4 u_MVPMat;\n#else\nuniform mat4 u_VPMat;\n#endif\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;attribute vec4 COLOR_0;varying vec2 v_uv;varying vec4 v_color;void main(){\n#ifdef USE_MODEL_MATRIX\ngl_Position=u_MVPMat*vec4(POSITION,1.0);\n#else\ngl_Position=u_VPMat*vec4(POSITION,1.0);\n#endif\nv_uv=TEXCOORD_0;v_color=COLOR_0;}";
var unlitFs = "#define GLSLIFY 1\n#include <uv_share>\n#include <fog_share>\nuniform vec4 u_baseColor;uniform float u_alphaCutoff;\n#ifdef O3_BASE_TEXTURE\nuniform sampler2D u_baseTexture;\n#endif\nvoid main(){vec4 baseColor=u_baseColor;\n#ifdef O3_BASE_TEXTURE\nbaseColor*=texture2D(u_baseTexture,v_uv);\n#endif\n#ifdef ALPHA_CUTOFF\nif(baseColor.a<u_alphaCutoff){discard;}\n#endif\ngl_FragColor=baseColor;\n#include <fog_frag>\n}";
var unlitVs = "#define GLSLIFY 1\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <position_vert>\n#include <fog_vert>\n}";
var backgroundTextureVs = "#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=vec4(POSITION,1.0);v_uv=TEXCOORD_0;}";
var backgroundTextureFs = "#define GLSLIFY 1\nuniform sampler2D u_baseTexture;varying vec2 v_uv;void main(){gl_FragColor=texture2D(u_baseTexture,v_uv);}";
var ShaderPool = function() {
  function ShaderPool2() {
  }
  ShaderPool2.init = function init() {
    Shader.create("blinn-phong", blinnPhongVs, blinnPhongFs);
    Shader.create("pbr", pbrVs, pbrFs);
    Shader.create("unlit", unlitVs, unlitFs);
    Shader.create("shadow-map", shadowMapVs, shadowMapFs);
    Shader.create("shadow", shadowMapVs, shadowFs);
    Shader.create("skybox", skyboxVs, skyboxFs);
    Shader.create("particle-shader", particleVs, particleFs);
    Shader.create("SpriteMask", spriteMaskVs, spriteMaskFs);
    Shader.create("Sprite", spriteVs, spriteFs);
    Shader.create("background-texture", backgroundTextureVs, backgroundTextureFs);
  };
  return ShaderPool2;
}();
var ShaderProgramPool = function() {
  function ShaderProgramPool2() {
    this._cacheHierarchy = 1;
    this._cacheMap = Object.create(null);
    this._lastQueryMap = void 0;
    this._lastQueryKey = void 0;
  }
  var _proto = ShaderProgramPool2.prototype;
  _proto.get = function get4(macros) {
    var cacheMap = this._cacheMap;
    var maskLength = macros._length;
    if (maskLength > this._cacheHierarchy) {
      this._resizeCacheMapHierarchy(cacheMap, 0, maskLength);
    }
    var mask = macros._mask;
    var endIndex = macros._length - 1;
    var maxEndIndex = this._cacheHierarchy - 1;
    for (var i = 0; i < maxEndIndex; i++) {
      var subMask = endIndex < i ? 0 : mask[i];
      var subCacheShaders = cacheMap[subMask];
      subCacheShaders || (cacheMap[subMask] = subCacheShaders = Object.create(null));
      cacheMap = subCacheShaders;
    }
    var cacheKey = endIndex < maxEndIndex ? 0 : mask[maxEndIndex];
    var shader = cacheMap[cacheKey];
    if (!shader) {
      this._lastQueryKey = cacheKey;
      this._lastQueryMap = cacheMap;
    }
    return shader;
  };
  _proto.cache = function cache(shaderProgram) {
    this._lastQueryMap[this._lastQueryKey] = shaderProgram;
  };
  _proto._resizeCacheMapHierarchy = function _resizeCacheMapHierarchy(cacheMap, hierarchy, resizeLength) {
    var end = this._cacheHierarchy - 1;
    if (hierarchy == end) {
      for (var k in cacheMap) {
        var shader = cacheMap[k];
        for (var i = 0, n = resizeLength - end; i < n; i++) {
          if (i == n - 1) {
            cacheMap[0] = shader;
          } else {
            cacheMap = cacheMap[i == 0 ? k : 0] = Object.create(null);
          }
        }
      }
      this._cacheHierarchy = resizeLength;
    } else {
      for (var _k in cacheMap) {
        this._resizeCacheMapHierarchy(cacheMap[_k], ++hierarchy, resizeLength);
      }
    }
  };
  return ShaderProgramPool2;
}();
var ColliderFeature = function(_SceneFeature) {
  _inheritsLoose(ColliderFeature2, _SceneFeature);
  function ColliderFeature2() {
    var _this;
    _this = _SceneFeature.call(this) || this;
    _this.colliders = void 0;
    _this.colliders = [];
    return _this;
  }
  var _proto = ColliderFeature2.prototype;
  _proto.attachCollider = function attachCollider(collider) {
    this.colliders.push(collider);
  };
  _proto.detachCollider = function detachCollider(collider) {
    var index = this.colliders.indexOf(collider);
    if (index != -1) {
      this.colliders.splice(index, 1);
    }
  };
  return ColliderFeature2;
}(SceneFeature);
var Collider = function(_Component) {
  _inheritsLoose(Collider2, _Component);
  function Collider2(entity) {
    return _Component.call(this, entity) || this;
  }
  var _proto = Collider2.prototype;
  _proto._onEnable = function _onEnable() {
    this.scene.findFeature(ColliderFeature).attachCollider(this);
  };
  _proto._onDisable = function _onDisable() {
    this.scene.findFeature(ColliderFeature).detachCollider(this);
  };
  _proto._updateHitResult = function _updateHitResult(ray, distance, outHit, origin, isWorldRay) {
    if (isWorldRay === void 0) {
      isWorldRay = false;
    }
    ray.getPoint(distance, outHit.point);
    if (!isWorldRay) {
      Vector3.transformCoordinate(outHit.point, this.entity.transform.worldMatrix, outHit.point);
    }
    outHit.distance = Vector3.distance(origin, outHit.point);
    outHit.collider = this;
  };
  _proto._getLocalRay = function _getLocalRay(ray) {
    var worldToLocal = this.entity.getInvModelMatrix();
    var outRay = Collider2._ray;
    Vector3.transformCoordinate(ray.origin, worldToLocal, outRay.origin);
    Vector3.transformNormal(ray.direction, worldToLocal, outRay.direction);
    outRay.direction.normalize();
    return outRay;
  };
  _proto._raycast = function _raycast(ray, hit) {
    throw "Error: use concrete type instead!";
  };
  return Collider2;
}(Component);
Collider._ray = new Ray();
var ABoxCollider = function(_Collider) {
  _inheritsLoose(ABoxCollider2, _Collider);
  function ABoxCollider2(entity) {
    var _this;
    _this = _Collider.call(this, entity) || this;
    _this.boxMin = void 0;
    _this.boxMax = void 0;
    _this._corners = [];
    _this._cornerFlag = false;
    _this.boxMin = new Vector3(-0.5, -0.5, -0.5);
    _this.boxMax = new Vector3(0.5, 0.5, 0.5);
    return _this;
  }
  var _proto = ABoxCollider2.prototype;
  _proto.setBoxMinMax = function setBoxMinMax(min, max) {
    this.boxMin = min;
    this.boxMax = max;
    this._cornerFlag = true;
  };
  _proto.setBoxCenterSize = function setBoxCenterSize(center, size) {
    var halfSize = ABoxCollider2._tempVec3;
    Vector3.scale(size, 0.5, halfSize);
    Vector3.add(center, halfSize, this.boxMax);
    Vector3.subtract(center, halfSize, this.boxMin);
    this._cornerFlag = true;
  };
  _proto.getCorners = function getCorners() {
    if (this._cornerFlag) {
      var minX = this.boxMin.x;
      var minY = this.boxMin.y;
      var minZ = this.boxMin.z;
      var w = this.boxMax.x - minX;
      var h = this.boxMax.y - minY;
      var d = this.boxMax.z - minZ;
      if (this._corners.length === 0) {
        for (var i = 0; i < 8; ++i) {
          this._corners.push(new Vector3());
        }
      }
      this._corners[0].setValue(minX + w, minY + h, minZ + d);
      this._corners[1].setValue(minX, minY + h, minZ + d);
      this._corners[2].setValue(minX, minY, minZ + d);
      this._corners[3].setValue(minX + w, minY, minZ + d);
      this._corners[4].setValue(minX + w, minY + h, minZ);
      this._corners[5].setValue(minX, minY + h, minZ);
      this._corners[6].setValue(minX, minY, minZ);
      this._corners[7].setValue(minX + w, minY, minZ);
      this._cornerFlag = false;
    }
    return this._corners;
  };
  _proto._raycast = function _raycast(ray, hit) {
    var localRay = this._getLocalRay(ray);
    var boundingBox = ABoxCollider2._tempBox;
    this.boxMin.cloneTo(boundingBox.min);
    this.boxMax.cloneTo(boundingBox.max);
    var intersect = localRay.intersectBox(boundingBox);
    if (intersect !== -1) {
      this._updateHitResult(localRay, intersect, hit, ray.origin);
      return true;
    } else {
      return false;
    }
  };
  return ABoxCollider2;
}(Collider);
ABoxCollider._tempVec3 = new Vector3();
ABoxCollider._tempBox = new BoundingBox();
var PlaneCollider = function(_Collider) {
  _inheritsLoose(PlaneCollider2, _Collider);
  function PlaneCollider2(entity) {
    var _this;
    _this = _Collider.call(this, entity) || this;
    _this.planePoint = void 0;
    _this.normal = void 0;
    _this.planePoint = new Vector3();
    _this.normal = new Vector3(0, 1, 0);
    return _this;
  }
  var _proto = PlaneCollider2.prototype;
  _proto.setPlane = function setPlane(point, normal) {
    this.planePoint = point;
    this.normal = normal;
  };
  _proto._raycast = function _raycast(ray, hit) {
    var localRay = this._getLocalRay(ray);
    var boundingPlane = PlaneCollider2._tempPlane;
    this.normal.cloneTo(boundingPlane.normal);
    boundingPlane.distance = -Vector3.dot(this.planePoint, boundingPlane.normal);
    var intersect = localRay.intersectPlane(boundingPlane);
    if (intersect !== -1) {
      this._updateHitResult(localRay, intersect, hit, ray.origin);
      return true;
    } else {
      return false;
    }
  };
  return PlaneCollider2;
}(Collider);
PlaneCollider._tempPlane = new Plane();
var ASphereCollider = function(_Collider) {
  _inheritsLoose(ASphereCollider2, _Collider);
  function ASphereCollider2(entity) {
    var _this;
    _this = _Collider.call(this, entity) || this;
    _this.center = void 0;
    _this.radius = void 0;
    _this.center = new Vector3();
    _this.radius = 1;
    return _this;
  }
  var _proto = ASphereCollider2.prototype;
  _proto.setSphere = function setSphere(center, radius) {
    this.center = center;
    this.radius = radius;
  };
  _proto._raycast = function _raycast(ray, hit) {
    var transform = this.entity.transform;
    var boundingSphere = ASphereCollider2._tempSphere;
    Vector3.transformCoordinate(this.center, transform.worldMatrix, boundingSphere.center);
    var lossyScale = transform.lossyWorldScale;
    boundingSphere.radius = this.radius * Math.max(lossyScale.x, lossyScale.y, lossyScale.z);
    var intersect = ray.intersectSphere(boundingSphere);
    if (intersect !== -1) {
      this._updateHitResult(ray, intersect, hit, ray.origin, true);
      return true;
    } else {
      return false;
    }
  };
  return ASphereCollider2;
}(Collider);
ASphereCollider._tempSphere = new BoundingSphere();
var BoxCollider = function(_ABoxCollider) {
  _inheritsLoose(BoxCollider2, _ABoxCollider);
  function BoxCollider2(entity) {
    var _this;
    _this = _ABoxCollider.call(this, entity) || this;
    _this._center = new Vector3();
    _this._size = new Vector3();
    _this.isShowCollider = true;
    _this.center = _this.center;
    _this.size = _this.size;
    _this.isShowCollider = _this.isShowCollider;
    return _this;
  }
  _createClass(BoxCollider2, [{
    key: "center",
    get: function get4() {
      return this._center;
    },
    set: function set4(value) {
      this._center = value;
      this.setBoxCenterSize(this._center, this._size);
    }
  }, {
    key: "size",
    get: function get4() {
      return this._size;
    },
    set: function set4(value) {
      this._size = value;
      this.setBoxCenterSize(this._center, this._size);
    }
  }]);
  return BoxCollider2;
}(ABoxCollider);
var SphereCollider = function(_ASphereCollider) {
  _inheritsLoose(SphereCollider2, _ASphereCollider);
  function SphereCollider2(entity) {
    var _this;
    _this = _ASphereCollider.call(this, entity) || this;
    _this.__center = new Vector3();
    _this.__radius = 1;
    _this.isShowCollider = true;
    _this._center = _this._center;
    _this._radius = _this._radius;
    _this.isShowCollider = _this.isShowCollider;
    return _this;
  }
  _createClass(SphereCollider2, [{
    key: "_center",
    get: function get4() {
      return this.__center;
    },
    set: function set4(value) {
      this.__center = value;
      this.setSphere(this.__center, this.__radius);
    }
  }, {
    key: "_radius",
    get: function get4() {
      return this.__radius;
    },
    set: function set4(value) {
      this.__radius = value;
      this.setSphere(this.__center, this.__radius);
    }
  }]);
  return SphereCollider2;
}(ASphereCollider);
Scene.registerFeature(ColliderFeature);
var HitResult = function HitResult2() {
  this.collider = null;
  this.distance = 0;
  this.point = new Vector3();
  this.normal = new Vector3();
};
var PhysicsManager = function() {
  function PhysicsManager2(engine) {
    this._engine = void 0;
    this._engine = engine;
  }
  var _proto = PhysicsManager2.prototype;
  _proto.raycast = function raycast(ray, distanceOrResult, layerMaskOrResult, outHitResult) {
    var cf = this._engine.sceneManager.activeScene.findFeature(ColliderFeature);
    var colliders = cf.colliders;
    var hitResult;
    var distance = Number.MAX_VALUE;
    if (typeof distanceOrResult === "number") {
      distance = distanceOrResult;
    } else if (distanceOrResult != void 0) {
      hitResult = distanceOrResult;
    }
    var layerMask = Layer.Everything;
    if (typeof layerMaskOrResult === "number") {
      layerMask = layerMaskOrResult;
    } else if (layerMaskOrResult != void 0) {
      hitResult = layerMaskOrResult;
    }
    if (outHitResult) {
      hitResult = outHitResult;
    }
    var isHit = false;
    var curHit = PhysicsManager2._currentHit;
    for (var i = 0, len = colliders.length; i < len; i++) {
      var collider = colliders[i];
      if (!(collider.entity.layer & layerMask)) {
        continue;
      }
      if (collider._raycast(ray, curHit)) {
        isHit = true;
        if (curHit.distance < distance) {
          if (hitResult) {
            curHit.normal.cloneTo(hitResult.normal);
            curHit.point.cloneTo(hitResult.point);
            hitResult.distance = curHit.distance;
            hitResult.collider = curHit.collider;
          } else {
            return true;
          }
          distance = curHit.distance;
        }
      }
    }
    if (!isHit && hitResult) {
      hitResult.collider = null;
      hitResult.distance = 0;
      hitResult.point.setValue(0, 0, 0);
      hitResult.normal.setValue(0, 0, 0);
    }
    return isHit;
  };
  return PhysicsManager2;
}();
PhysicsManager._currentHit = new HitResult();
var engineFeatureManager = new FeatureManager();
ShaderPool.init();
var Engine = function(_EventDispatcher) {
  _inheritsLoose(Engine2, _EventDispatcher);
  function Engine2(canvas, hardwareRenderer) {
    var _this;
    _this = _EventDispatcher.call(this, null) || this;
    _this.physicsManager = new PhysicsManager(_assertThisInitialized(_this));
    _this._componentsManager = new ComponentsManager();
    _this._hardwareRenderer = void 0;
    _this._lastRenderState = new RenderState();
    _this._renderElementPool = new ClassPool(RenderElement);
    _this._spriteElementPool = new ClassPool(SpriteElement);
    _this._spriteMaskElementPool = new ClassPool(SpriteMaskElement);
    _this._spriteDefaultMaterial = void 0;
    _this._spriteMaskDefaultMaterial = void 0;
    _this._renderContext = new RenderContext();
    _this._whiteTexture2D = void 0;
    _this._whiteTextureCube = void 0;
    _this._backgroundTextureMaterial = void 0;
    _this._backgroundTextureMesh = void 0;
    _this._renderCount = 0;
    _this._shaderProgramPools = [];
    _this._spriteMaskManager = void 0;
    _this._canvas = void 0;
    _this._resourceManager = new ResourceManager(_assertThisInitialized(_this));
    _this._sceneManager = new SceneManager(_assertThisInitialized(_this));
    _this._vSyncCount = 1;
    _this._targetFrameRate = 60;
    _this._time = new Time();
    _this._isPaused = true;
    _this._requestId = void 0;
    _this._timeoutId = void 0;
    _this._vSyncCounter = 1;
    _this._targetFrameInterval = 1e3 / 60;
    _this._animate = function() {
      if (_this._vSyncCount) {
        _this._requestId = requestAnimationFrame(_this._animate);
        if (_this._vSyncCounter++ % _this._vSyncCount === 0) {
          _this.update();
          _this._vSyncCounter = 1;
        }
      } else {
        _this._timeoutId = window.setTimeout(_this._animate, _this._targetFrameInterval);
        _this.update();
      }
    };
    _this.features = [];
    _this._hardwareRenderer = hardwareRenderer;
    _this._hardwareRenderer.init(canvas);
    _this._canvas = canvas;
    engineFeatureManager.addObject(_assertThisInitialized(_this));
    _this._sceneManager.activeScene = new Scene(_assertThisInitialized(_this), "DefaultScene");
    _this._spriteMaskManager = new SpriteMaskManager(_assertThisInitialized(_this));
    _this._spriteDefaultMaterial = _this._createSpriteMaterial();
    _this._spriteMaskDefaultMaterial = _this._createSpriteMaskMaterial();
    var whitePixel = new Uint8Array([255, 255, 255, 255]);
    var whiteTexture2D = new Texture2D(_assertThisInitialized(_this), 1, 1, TextureFormat.R8G8B8A8, false);
    whiteTexture2D.setPixelBuffer(whitePixel);
    whiteTexture2D.isGCIgnored = true;
    var whiteTextureCube = new TextureCubeMap(_assertThisInitialized(_this), 1, TextureFormat.R8G8B8A8, false);
    whiteTextureCube.setPixelBuffer(TextureCubeFace.PositiveX, whitePixel);
    whiteTextureCube.setPixelBuffer(TextureCubeFace.NegativeX, whitePixel);
    whiteTextureCube.setPixelBuffer(TextureCubeFace.PositiveY, whitePixel);
    whiteTextureCube.setPixelBuffer(TextureCubeFace.NegativeY, whitePixel);
    whiteTextureCube.setPixelBuffer(TextureCubeFace.PositiveZ, whitePixel);
    whiteTextureCube.setPixelBuffer(TextureCubeFace.NegativeZ, whitePixel);
    whiteTextureCube.isGCIgnored = true;
    _this._whiteTexture2D = whiteTexture2D;
    _this._whiteTextureCube = whiteTextureCube;
    _this._backgroundTextureMaterial = new Material(_assertThisInitialized(_this), Shader.find("background-texture"));
    _this._backgroundTextureMaterial.isGCIgnored = true;
    _this._backgroundTextureMaterial.renderState.depthState.compareFunction = CompareFunction.LessEqual;
    _this._backgroundTextureMesh = PrimitiveMesh.createPlane(_assertThisInitialized(_this), 2, 2, 1, 1, false);
    _this._backgroundTextureMesh.isGCIgnored = true;
    return _this;
  }
  var _proto = Engine2.prototype;
  _proto.createEntity = function createEntity(name) {
    return new Entity(this, name);
  };
  _proto.pause = function pause() {
    this._isPaused = true;
    cancelAnimationFrame(this._requestId);
    clearTimeout(this._timeoutId);
  };
  _proto.resume = function resume() {
    if (!this._isPaused)
      return;
    this._isPaused = false;
    this.time.reset();
    requestAnimationFrame(this._animate);
  };
  _proto.update = function update() {
    var time = this._time;
    var deltaTime = time.deltaTime;
    time.tick();
    this._renderElementPool.resetPool();
    this._spriteElementPool.resetPool();
    this._spriteMaskElementPool.resetPool();
    engineFeatureManager.callFeatureMethod(this, "preTick", [this, this._sceneManager._activeScene]);
    var scene = this._sceneManager._activeScene;
    var componentsManager = this._componentsManager;
    if (scene) {
      componentsManager.callScriptOnStart();
      componentsManager.callScriptOnUpdate(deltaTime);
      componentsManager.callAnimationUpdate(deltaTime);
      componentsManager.callScriptOnLateUpdate(deltaTime);
      this._render(scene);
    }
    this._componentsManager.callComponentDestroy();
    engineFeatureManager.callFeatureMethod(this, "postTick", [this, this._sceneManager._activeScene]);
  };
  _proto.run = function run() {
    engineFeatureManager.callFeatureMethod(this, "preLoad", [this]);
    this.resume();
    this.trigger(new Event("run", this));
  };
  _proto.destroy = function destroy() {
    if (this._sceneManager) {
      this._whiteTexture2D.destroy(true);
      this._whiteTextureCube.destroy(true);
      this.trigger(new Event("shutdown", this));
      engineFeatureManager.callFeatureMethod(this, "shutdown", [this]);
      this.pause();
      this._animate = null;
      this._sceneManager._activeScene.destroy();
      this._resourceManager.gc();
      this._componentsManager.callComponentDestroy();
      this._sceneManager = null;
      this._resourceManager = null;
      this._canvas = null;
      this.features = [];
      this._time = null;
      this._spriteMaskManager.destroy();
      engineFeatureManager._objects = [];
      this.removeAllEventListeners();
    }
  };
  _proto._getShaderProgramPool = function _getShaderProgramPool(shader) {
    var index = shader._shaderId;
    var shaderProgramPools = this._shaderProgramPools;
    var pool = shaderProgramPools[index];
    if (!pool) {
      var length2 = index + 1;
      if (length2 < shaderProgramPools.length) {
        shaderProgramPools.length = length2;
      }
      shaderProgramPools[index] = pool = new ShaderProgramPool();
    }
    return pool;
  };
  _proto._render = function _render(scene) {
    var cameras = scene._activeCameras;
    var componentsManager = this._componentsManager;
    var deltaTime = this.time.deltaTime;
    componentsManager.callRendererOnUpdate(deltaTime);
    scene._updateShaderData();
    if (cameras.length > 0) {
      cameras.sort(function(camera1, camera2) {
        return camera1.priority - camera2.priority;
      });
      for (var i = 0, l = cameras.length; i < l; i++) {
        var camera = cameras[i];
        var cameraEntity = camera.entity;
        if (camera.enabled && cameraEntity.isActiveInHierarchy) {
          componentsManager.callCameraOnBeginRender(camera);
          Scene.sceneFeatureManager.callFeatureMethod(scene, "preRender", [scene, camera]);
          camera.render();
          Scene.sceneFeatureManager.callFeatureMethod(scene, "postRender", [scene, camera]);
          componentsManager.callCameraOnEndRender(camera);
        }
      }
    } else {
      Logger.debug("NO active camera.");
    }
  };
  _proto._createSpriteMaterial = function _createSpriteMaterial() {
    var material = new Material(this, Shader.find("Sprite"));
    var renderState = material.renderState;
    var target = renderState.blendState.targetBlendState;
    target.enabled = true;
    target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
    target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
    target.sourceAlphaBlendFactor = BlendFactor.One;
    target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
    target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
    renderState.depthState.writeEnabled = false;
    renderState.rasterState.cullMode = CullMode.Off;
    material.renderQueueType = RenderQueueType.Transparent;
    material.isGCIgnored = true;
    return material;
  };
  _proto._createSpriteMaskMaterial = function _createSpriteMaskMaterial() {
    var material = new Material(this, Shader.find("SpriteMask"));
    var renderState = material.renderState;
    renderState.blendState.targetBlendState.colorWriteMask = ColorWriteMask.None;
    renderState.rasterState.cullMode = CullMode.Off;
    renderState.stencilState.enabled = true;
    renderState.depthState.enabled = false;
    material.isGCIgnored = true;
    return material;
  };
  _proto.findFeature = function findFeature(Feature) {
    return engineFeatureManager.findFeature(this, Feature);
  };
  Engine2.registerFeature = function registerFeature(Feature) {
    engineFeatureManager.registerFeature(Feature);
  };
  _createClass(Engine2, [{
    key: "canvas",
    get: function get4() {
      return this._canvas;
    }
  }, {
    key: "resourceManager",
    get: function get4() {
      return this._resourceManager;
    }
  }, {
    key: "sceneManager",
    get: function get4() {
      return this._sceneManager;
    }
  }, {
    key: "time",
    get: function get4() {
      return this._time;
    }
  }, {
    key: "isPaused",
    get: function get4() {
      return this._isPaused;
    }
  }, {
    key: "vSyncCount",
    get: function get4() {
      return this._vSyncCount;
    },
    set: function set4(value) {
      this._vSyncCount = Math.max(0, Math.floor(value));
    }
  }, {
    key: "targetFrameRate",
    get: function get4() {
      return this._targetFrameRate;
    },
    set: function set4(value) {
      value = Math.max(1e-6, value);
      this._targetFrameRate = value;
      this._targetFrameInterval = 1e3 / value;
    }
  }]);
  return Engine2;
}(EventDispatcher);
var SystemInfo = function() {
  function SystemInfo2() {
  }
  SystemInfo2._isIos = function _isIos() {
    if (!window) {
      return false;
    }
    var ua = window.navigator.userAgent.toLocaleLowerCase();
    return /iphone|ipad|ipod/.test(ua);
  };
  _createClass(SystemInfo2, null, [{
    key: "devicePixelRatio",
    get: function get4() {
      return window.devicePixelRatio;
    }
  }]);
  return SystemInfo2;
}();
var EngineFeature = function() {
  function EngineFeature2() {
  }
  var _proto = EngineFeature2.prototype;
  _proto.preLoad = function preLoad(engine) {
  };
  _proto.preTick = function preTick(engine, currentScene) {
  };
  _proto.postTick = function postTick(engine, currentScene) {
  };
  _proto.shutdown = function shutdown(engine) {
  };
  return EngineFeature2;
}();
var _class$3;
var _descriptor$3;
var _descriptor2$3;
var _descriptor3$3;
var _descriptor4$3;
var _descriptor5$3;
var _descriptor6$3;
var _descriptor7$3;
var Script = (_class$3 = function(_Component) {
  _inheritsLoose(Script2, _Component);
  function Script2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _initializerDefineProperty(_this, "_started", _descriptor$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onStartIndex", _descriptor2$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onUpdateIndex", _descriptor3$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onLateUpdateIndex", _descriptor4$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onPreRenderIndex", _descriptor5$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onPostRenderIndex", _descriptor6$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_entityCacheIndex", _descriptor7$3, _assertThisInitialized(_this));
    return _this;
  }
  var _proto = Script2.prototype;
  _proto.onAwake = function onAwake() {
  };
  _proto.onEnable = function onEnable() {
  };
  _proto.onStart = function onStart() {
  };
  _proto.onUpdate = function onUpdate(deltaTime) {
  };
  _proto.onLateUpdate = function onLateUpdate(deltaTime) {
  };
  _proto.onBeginRender = function onBeginRender(camera) {
  };
  _proto.onEndRender = function onEndRender(camera) {
  };
  _proto.onTriggerEnter = function onTriggerEnter(other) {
  };
  _proto.onTriggerStay = function onTriggerStay(other) {
  };
  _proto.onTriggerExit = function onTriggerExit(other) {
  };
  _proto.onPointerDown = function onPointerDown() {
  };
  _proto.onPointerUp = function onPointerUp() {
  };
  _proto.onPointerClick = function onPointerClick() {
  };
  _proto.onPointerEnter = function onPointerEnter() {
  };
  _proto.onPointerExit = function onPointerExit() {
  };
  _proto.onPointerDrag = function onPointerDrag() {
  };
  _proto.onDisable = function onDisable() {
  };
  _proto.onDestroy = function onDestroy() {
  };
  _proto._onAwake = function _onAwake() {
    this.onAwake();
  };
  _proto._onEnable = function _onEnable() {
    var componentsManager = this.engine._componentsManager;
    var prototype = Script2.prototype;
    if (!this._started) {
      componentsManager.addOnStartScript(this);
    }
    if (this.onUpdate !== prototype.onUpdate) {
      componentsManager.addOnUpdateScript(this);
    }
    if (this.onLateUpdate !== prototype.onLateUpdate) {
      componentsManager.addOnLateUpdateScript(this);
    }
    this._entity._addScript(this);
    this.onEnable();
  };
  _proto._onDisable = function _onDisable() {
    var componentsManager = this.engine._componentsManager;
    if (this._onStartIndex !== -1) {
      componentsManager.removeOnStartScript(this);
    }
    if (this._onUpdateIndex !== -1) {
      componentsManager.removeOnUpdateScript(this);
    }
    if (this._onLateUpdateIndex !== -1) {
      componentsManager.removeOnLateUpdateScript(this);
    }
    if (this._entityCacheIndex !== -1) {
      this._entity._removeScript(this);
    }
    this.onDisable();
  };
  _proto._onDestroy = function _onDestroy() {
    this.engine._componentsManager.addDestroyComponent(this);
  };
  return Script2;
}(Component), _descriptor$3 = _applyDecoratedDescriptor(_class$3.prototype, "_started", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer40() {
    return false;
  }
}), _descriptor2$3 = _applyDecoratedDescriptor(_class$3.prototype, "_onStartIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer41() {
    return -1;
  }
}), _descriptor3$3 = _applyDecoratedDescriptor(_class$3.prototype, "_onUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer42() {
    return -1;
  }
}), _descriptor4$3 = _applyDecoratedDescriptor(_class$3.prototype, "_onLateUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer43() {
    return -1;
  }
}), _descriptor5$3 = _applyDecoratedDescriptor(_class$3.prototype, "_onPreRenderIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer44() {
    return -1;
  }
}), _descriptor6$3 = _applyDecoratedDescriptor(_class$3.prototype, "_onPostRenderIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer45() {
    return -1;
  }
}), _descriptor7$3 = _applyDecoratedDescriptor(_class$3.prototype, "_entityCacheIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer46() {
    return -1;
  }
}), _class$3);
var CameraClearFlags;
(function(CameraClearFlags2) {
  CameraClearFlags2[CameraClearFlags2["DepthColor"] = 0] = "DepthColor";
  CameraClearFlags2[CameraClearFlags2["Depth"] = 1] = "Depth";
  CameraClearFlags2[CameraClearFlags2["None"] = 2] = "None";
})(CameraClearFlags || (CameraClearFlags = {}));
var passNum = 0;
var RenderPass = function() {
  function RenderPass2(name, priority, renderTarget, replaceMaterial, mask) {
    if (name === void 0) {
      name = "RENDER_PASS" + passNum++;
    }
    if (priority === void 0) {
      priority = 0;
    }
    if (renderTarget === void 0) {
      renderTarget = null;
    }
    if (replaceMaterial === void 0) {
      replaceMaterial = null;
    }
    if (mask === void 0) {
      mask = null;
    }
    this.name = void 0;
    this.enabled = void 0;
    this.priority = void 0;
    this.renderTarget = void 0;
    this.replaceMaterial = void 0;
    this.mask = void 0;
    this.renderOverride = void 0;
    this.clearFlags = void 0;
    this.clearColor = void 0;
    this.name = name;
    this.enabled = true;
    this.priority = priority;
    this.renderTarget = renderTarget;
    this.replaceMaterial = replaceMaterial;
    this.mask = mask || Layer.Everything;
    this.renderOverride = false;
  }
  var _proto = RenderPass2.prototype;
  _proto.render = function render(camera, opaqueQueue, alphaTestQueue, transparentQueue) {
  };
  _proto.preRender = function preRender(camera, opaqueQueue, alphaTestQueue, transparentQueue) {
  };
  _proto.postRender = function postRender(camera, opaqueQueue, alphaTestQueue, transparentQueue) {
  };
  return RenderPass2;
}();
var SpriteBatcher = function(_Basic2DBatcher) {
  _inheritsLoose(SpriteBatcher2, _Basic2DBatcher);
  function SpriteBatcher2() {
    return _Basic2DBatcher.apply(this, arguments) || this;
  }
  var _proto = SpriteBatcher2.prototype;
  _proto.createVertexElements = function createVertexElements(vertexElements) {
    vertexElements[0] = new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0);
    vertexElements[1] = new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0);
    vertexElements[2] = new VertexElement("COLOR_0", 20, VertexElementFormat.Vector4, 0);
    return 36;
  };
  _proto.canBatch = function canBatch(preElement, curElement) {
    var preRenderer = preElement.component;
    var curRenderer = curElement.component;
    if (!this.checkBatchWithMask(preRenderer, curRenderer)) {
      return false;
    }
    var textureProperty = SpriteBatcher2._textureProperty;
    if (preRenderer.shaderData.getTexture(textureProperty) !== curRenderer.shaderData.getTexture(textureProperty)) {
      return false;
    }
    return preElement.material === curElement.material;
  };
  _proto.checkBatchWithMask = function checkBatchWithMask(left, right) {
    var leftMaskInteraction = left.maskInteraction;
    if (leftMaskInteraction !== right.maskInteraction) {
      return false;
    }
    if (leftMaskInteraction === SpriteMaskInteraction.None) {
      return true;
    }
    return left.maskLayer === right.maskLayer;
  };
  _proto.updateVertices = function updateVertices(element, vertices, vertexIndex) {
    var positions = element.positions, uv = element.uv, color = element.color;
    var verticesNum = positions.length;
    for (var i = 0; i < verticesNum; i++) {
      var curPos = positions[i];
      var curUV = uv[i];
      vertices[vertexIndex++] = curPos.x;
      vertices[vertexIndex++] = curPos.y;
      vertices[vertexIndex++] = curPos.z;
      vertices[vertexIndex++] = curUV.x;
      vertices[vertexIndex++] = curUV.y;
      vertices[vertexIndex++] = color.r;
      vertices[vertexIndex++] = color.g;
      vertices[vertexIndex++] = color.b;
      vertices[vertexIndex++] = color.a;
    }
    return vertexIndex;
  };
  _proto.drawBatches = function drawBatches(engine) {
    var mesh = this._meshes[this._flushId];
    var subMeshes = mesh.subMeshes;
    var batchedQueue = this._batchedQueue;
    var maskManager = engine._spriteMaskManager;
    for (var i = 0, len = subMeshes.length; i < len; i++) {
      var subMesh = subMeshes[i];
      var spriteElement = batchedQueue[i];
      if (!subMesh || !spriteElement) {
        return;
      }
      var renderer = spriteElement.component;
      var camera = spriteElement.camera;
      var material = spriteElement.material;
      maskManager.preRender(camera, renderer);
      var compileMacros = Shader._compileMacros;
      ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, material.shaderData._macroCollection, compileMacros);
      var program = material.shader._getShaderProgram(engine, compileMacros);
      if (!program.isValid) {
        return;
      }
      program.bind();
      program.groupingOtherUniformBlock();
      program.uploadAll(program.sceneUniformBlock, camera.scene.shaderData);
      program.uploadAll(program.cameraUniformBlock, camera.shaderData);
      program.uploadAll(program.rendererUniformBlock, renderer.shaderData);
      program.uploadAll(program.materialUniformBlock, material.shaderData);
      material.renderState._apply(engine);
      engine._hardwareRenderer.drawPrimitive(mesh, subMesh, program);
      maskManager.postRender(renderer);
    }
  };
  _proto.destroy = function destroy() {
    this._batchedQueue = null;
    var meshes = this._meshes, vertexBuffers = this._vertexBuffers, indiceBuffers = this._indiceBuffers;
    for (var i = 0, n = meshes.length; i < n; ++i) {
      meshes[i].destroy();
    }
    this._meshes = null;
    for (var _i = 0, _n = vertexBuffers.length; _i < _n; ++_i) {
      vertexBuffers[_i].destroy();
    }
    this._vertexBuffers = null;
    for (var _i2 = 0, _n2 = indiceBuffers.length; _i2 < _n2; ++_i2) {
      indiceBuffers[_i2].destroy();
    }
    this._indiceBuffers = null;
  };
  return SpriteBatcher2;
}(Basic2DBatcher);
SpriteBatcher._textureProperty = Shader.getPropertyByName("u_spriteTexture");
var RenderQueue = function() {
  RenderQueue2._compareFromNearToFar = function _compareFromNearToFar(a, b) {
    return a.material.renderQueueType - b.material.renderQueueType || a.component._distanceForSort - b.component._distanceForSort || b.component._renderSortId - a.component._renderSortId;
  };
  RenderQueue2._compareFromFarToNear = function _compareFromFarToNear(a, b) {
    return a.material.renderQueueType - b.material.renderQueueType || b.component._distanceForSort - a.component._distanceForSort || b.component._renderSortId - a.component._renderSortId;
  };
  function RenderQueue2(engine) {
    this.items = [];
    this._spriteBatcher = void 0;
    this._spriteBatcher = new SpriteBatcher(engine);
  }
  var _proto = RenderQueue2.prototype;
  _proto.pushPrimitive = function pushPrimitive(element) {
    this.items.push(element);
  };
  _proto.render = function render(camera, replaceMaterial, mask) {
    var items = this.items;
    if (items.length === 0) {
      return;
    }
    var engine = camera.engine, scene = camera.scene;
    var renderCount = engine._renderCount;
    var rhi = engine._hardwareRenderer;
    var sceneData = scene.shaderData;
    var cameraData = camera.shaderData;
    for (var i = 0, n = items.length; i < n; i++) {
      var item = items[i];
      var renderPassFlag = item.component.entity.layer;
      if (!(renderPassFlag & mask)) {
        continue;
      }
      if (!!item.mesh) {
        this._spriteBatcher.flush(engine);
        var compileMacros = Shader._compileMacros;
        var element = item;
        var renderer = element.component;
        var material = replaceMaterial ? replaceMaterial : element.material;
        var rendererData = renderer.shaderData;
        var materialData = material.shaderData;
        material._preRender(element);
        ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, materialData._macroCollection, compileMacros);
        var program = material.shader._getShaderProgram(engine, compileMacros);
        if (!program.isValid) {
          continue;
        }
        var switchProgram = program.bind();
        var switchRenderCount = renderCount !== program._uploadRenderCount;
        if (switchRenderCount) {
          program.groupingOtherUniformBlock();
          program.uploadAll(program.sceneUniformBlock, sceneData);
          program.uploadAll(program.cameraUniformBlock, cameraData);
          program.uploadAll(program.rendererUniformBlock, rendererData);
          program.uploadAll(program.materialUniformBlock, materialData);
          program.uploadUngroupTextures();
          program._uploadCamera = camera;
          program._uploadRenderer = renderer;
          program._uploadMaterial = material;
          program._uploadRenderCount = renderCount;
        } else {
          if (program._uploadCamera !== camera) {
            program.uploadAll(program.cameraUniformBlock, cameraData);
            program._uploadCamera = camera;
          } else if (switchProgram) {
            program.uploadTextures(program.cameraUniformBlock, cameraData);
          }
          if (program._uploadRenderer !== renderer) {
            program.uploadAll(program.rendererUniformBlock, rendererData);
            program._uploadRenderer = renderer;
          } else if (switchProgram) {
            program.uploadTextures(program.rendererUniformBlock, rendererData);
          }
          if (program._uploadMaterial !== material) {
            program.uploadAll(program.materialUniformBlock, materialData);
            program._uploadMaterial = material;
          } else if (switchProgram) {
            program.uploadTextures(program.materialUniformBlock, materialData);
          }
          if (switchProgram) {
            program.uploadUngroupTextures();
          }
        }
        material.renderState._apply(camera.engine);
        rhi.drawPrimitive(element.mesh, element.subMesh, program);
      } else {
        var spriteElement = item;
        this._spriteBatcher.drawElement(spriteElement);
      }
    }
    this._spriteBatcher.flush(engine);
  };
  _proto.clear = function clear() {
    this.items.length = 0;
    this._spriteBatcher.clear();
  };
  _proto.destroy = function destroy() {
    this._spriteBatcher.destroy();
    this._spriteBatcher = null;
  };
  _proto.sort = function sort(compareFunc) {
    this._quickSort(this.items, 0, this.items.length, compareFunc);
  };
  _proto._quickSort = function _quickSort(a, from, to, compareFunc) {
    while (true) {
      if (to - from <= 10) {
        this._insertionSort(a, from, to, compareFunc);
        return;
      }
      var third_index = from + to >> 1;
      var v0 = a[from];
      var v1 = a[to - 1];
      var v2 = a[third_index];
      var c01 = compareFunc(v0, v1);
      if (c01 > 0) {
        var tmp = v0;
        v0 = v1;
        v1 = tmp;
      }
      var c02 = compareFunc(v0, v2);
      if (c02 >= 0) {
        var _tmp = v0;
        v0 = v2;
        v2 = v1;
        v1 = _tmp;
      } else {
        var c12 = compareFunc(v1, v2);
        if (c12 > 0) {
          var _tmp2 = v1;
          v1 = v2;
          v2 = _tmp2;
        }
      }
      a[from] = v0;
      a[to - 1] = v2;
      var pivot = v1;
      var low_end = from + 1;
      var high_start = to - 1;
      a[third_index] = a[low_end];
      a[low_end] = pivot;
      partition:
        for (var i = low_end + 1; i < high_start; i++) {
          var element = a[i];
          var order = compareFunc(element, pivot);
          if (order < 0) {
            a[i] = a[low_end];
            a[low_end] = element;
            low_end++;
          } else if (order > 0) {
            do {
              high_start--;
              if (high_start == i)
                break partition;
              var top_elem = a[high_start];
              order = compareFunc(top_elem, pivot);
            } while (order > 0);
            a[i] = a[high_start];
            a[high_start] = element;
            if (order < 0) {
              element = a[i];
              a[i] = a[low_end];
              a[low_end] = element;
              low_end++;
            }
          }
        }
      if (to - high_start < low_end - from) {
        this._quickSort(a, high_start, to, compareFunc);
        to = low_end;
      } else {
        this._quickSort(a, from, low_end, compareFunc);
        from = high_start;
      }
    }
  };
  _proto._insertionSort = function _insertionSort(a, from, to, compareFunc) {
    for (var i = from + 1; i < to; i++) {
      var j = void 0;
      var element = a[i];
      for (j = i - 1; j >= from; j--) {
        var tmp = a[j];
        var order = compareFunc(tmp, element);
        if (order > 0) {
          a[j + 1] = tmp;
        } else {
          break;
        }
      }
      a[j + 1] = element;
    }
  };
  return RenderQueue2;
}();
var BasicRenderPipeline = function() {
  function BasicRenderPipeline2(camera) {
    this._opaqueQueue = void 0;
    this._transparentQueue = void 0;
    this._alphaTestQueue = void 0;
    this._allSpriteMasks = new DisorderedArray();
    this._camera = void 0;
    this._defaultPass = void 0;
    this._renderPassArray = void 0;
    this._lastCanvasSize = new Vector2();
    this._camera = camera;
    var engine = camera.engine;
    this._opaqueQueue = new RenderQueue(engine);
    this._alphaTestQueue = new RenderQueue(engine);
    this._transparentQueue = new RenderQueue(engine);
    this._renderPassArray = [];
    this._defaultPass = new RenderPass("default", 0, null, null, 0);
    this.addRenderPass(this._defaultPass);
  }
  var _proto = BasicRenderPipeline2.prototype;
  _proto.addRenderPass = function addRenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask) {
    if (priority === void 0) {
      priority = null;
    }
    if (renderTarget === void 0) {
      renderTarget = null;
    }
    if (replaceMaterial === void 0) {
      replaceMaterial = null;
    }
    if (mask === void 0) {
      mask = null;
    }
    if (typeof nameOrPass === "string") {
      var renderPass = new RenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask);
      this._renderPassArray.push(renderPass);
    } else if (nameOrPass instanceof RenderPass) {
      this._renderPassArray.push(nameOrPass);
    }
    this._renderPassArray.sort(function(p1, p2) {
      return p1.priority - p2.priority;
    });
  };
  _proto.removeRenderPass = function removeRenderPass(nameOrPass) {
    var pass;
    if (typeof nameOrPass === "string")
      pass = this.getRenderPass(nameOrPass);
    else if (nameOrPass instanceof RenderPass)
      pass = nameOrPass;
    if (pass) {
      var idx = this._renderPassArray.indexOf(pass);
      this._renderPassArray.splice(idx, 1);
    }
  };
  _proto.getRenderPass = function getRenderPass(name) {
    for (var i = 0, len = this._renderPassArray.length; i < len; i++) {
      var pass = this._renderPassArray[i];
      if (pass.name === name)
        return pass;
    }
    return null;
  };
  _proto.destroy = function destroy() {
    this._opaqueQueue.destroy();
    this._alphaTestQueue.destroy();
    this._transparentQueue.destroy();
    this._allSpriteMasks = null;
    this._renderPassArray = null;
    this._defaultPass = null;
    this._camera = null;
  };
  _proto.render = function render(context, cubeFace) {
    var camera = this._camera;
    var opaqueQueue = this._opaqueQueue;
    var alphaTestQueue = this._alphaTestQueue;
    var transparentQueue = this._transparentQueue;
    camera.engine._spriteMaskManager.clear();
    opaqueQueue.clear();
    alphaTestQueue.clear();
    transparentQueue.clear();
    this._allSpriteMasks.length = 0;
    camera.engine._componentsManager.callRender(context);
    opaqueQueue.sort(RenderQueue._compareFromNearToFar);
    alphaTestQueue.sort(RenderQueue._compareFromNearToFar);
    transparentQueue.sort(RenderQueue._compareFromFarToNear);
    for (var i = 0, len = this._renderPassArray.length; i < len; i++) {
      this._drawRenderPass(this._renderPassArray[i], camera, cubeFace);
    }
  };
  _proto._drawRenderPass = function _drawRenderPass(pass, camera, cubeFace) {
    pass.preRender(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
    if (pass.enabled) {
      var _pass$clearFlags, _pass$clearColor;
      var engine = camera.engine, scene = camera.scene;
      var background = scene.background;
      var rhi = engine._hardwareRenderer;
      var renderTarget = camera.renderTarget || pass.renderTarget;
      rhi.activeRenderTarget(renderTarget, camera);
      renderTarget === null || renderTarget === void 0 ? void 0 : renderTarget._setRenderTargetFace(cubeFace);
      var clearFlags = (_pass$clearFlags = pass.clearFlags) != null ? _pass$clearFlags : camera.clearFlags;
      var color = (_pass$clearColor = pass.clearColor) != null ? _pass$clearColor : background.solidColor;
      if (clearFlags !== CameraClearFlags.None) {
        rhi.clearRenderTarget(camera.engine, clearFlags, color);
      }
      if (pass.renderOverride) {
        pass.render(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
      } else {
        this._opaqueQueue.render(camera, pass.replaceMaterial, pass.mask);
        this._alphaTestQueue.render(camera, pass.replaceMaterial, pass.mask);
        if (background.mode === BackgroundMode.Sky) {
          this._drawSky(engine, camera, background.sky);
        } else if (background.mode === BackgroundMode.Texture && background.texture) {
          this._drawBackgroundTexture(engine, background);
        }
        this._transparentQueue.render(camera, pass.replaceMaterial, pass.mask);
      }
      renderTarget === null || renderTarget === void 0 ? void 0 : renderTarget._blitRenderTarget();
      renderTarget === null || renderTarget === void 0 ? void 0 : renderTarget.generateMipmaps();
    }
    pass.postRender(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
  };
  _proto.pushPrimitive = function pushPrimitive(element) {
    var renderQueueType = element.material.renderQueueType;
    if (renderQueueType > RenderQueueType.Transparent + RenderQueueType.AlphaTest >> 1) {
      this._transparentQueue.pushPrimitive(element);
    } else if (renderQueueType > RenderQueueType.AlphaTest + RenderQueueType.Opaque >> 1) {
      this._alphaTestQueue.pushPrimitive(element);
    } else {
      this._opaqueQueue.pushPrimitive(element);
    }
  };
  _proto._drawBackgroundTexture = function _drawBackgroundTexture(engine, background) {
    var rhi = engine._hardwareRenderer;
    var _backgroundTextureMaterial = engine._backgroundTextureMaterial, _backgroundTextureMesh = engine._backgroundTextureMesh, canvas = engine.canvas;
    if ((this._lastCanvasSize.x !== canvas.width || this._lastCanvasSize.y !== canvas.height) && background._textureFillMode !== BackgroundTextureFillMode.Fill) {
      this._lastCanvasSize.setValue(canvas.width, canvas.height);
      background._resizeBackgroundTexture();
    }
    var program = _backgroundTextureMaterial.shader._getShaderProgram(engine, Shader._compileMacros);
    program.bind();
    program.uploadAll(program.materialUniformBlock, _backgroundTextureMaterial.shaderData);
    program.uploadUngroupTextures();
    _backgroundTextureMaterial.renderState._apply(engine);
    rhi.drawPrimitive(_backgroundTextureMesh, _backgroundTextureMesh.subMesh, program);
  };
  _proto._drawSky = function _drawSky(engine, camera, sky) {
    var material = sky.material, mesh = sky.mesh, _matrix = sky._matrix;
    if (!material) {
      Logger.warn("The material of sky is not defined.");
      return;
    }
    if (!mesh) {
      Logger.warn("The mesh of sky is not defined.");
      return;
    }
    var rhi = engine._hardwareRenderer;
    var shaderData = material.shaderData, shader = material.shader, renderState = material.renderState;
    var compileMacros = Shader._compileMacros;
    ShaderMacroCollection.unionCollection(camera._globalShaderMacro, shaderData._macroCollection, compileMacros);
    var viewMatrix = camera.viewMatrix, projectionMatrix = camera.projectionMatrix;
    viewMatrix.cloneTo(_matrix);
    var e = _matrix.elements;
    e[12] = e[13] = e[14] = 0;
    Matrix.multiply(projectionMatrix, _matrix, _matrix);
    shaderData.setMatrix("u_mvpNoscale", _matrix);
    var program = shader._getShaderProgram(engine, compileMacros);
    program.bind();
    program.groupingOtherUniformBlock();
    program.uploadAll(program.materialUniformBlock, shaderData);
    program.uploadUngroupTextures();
    renderState._apply(engine);
    rhi.drawPrimitive(mesh, mesh.subMesh, program);
  };
  _createClass(BasicRenderPipeline2, [{
    key: "defaultRenderPass",
    get: function get4() {
      return this._defaultPass;
    }
  }]);
  return BasicRenderPipeline2;
}();
var _dec;
var _class$2;
var _class2$2;
var _descriptor$2;
var _descriptor2$2;
var _descriptor3$2;
var _descriptor4$2;
var _descriptor5$2;
var _descriptor6$2;
var _descriptor7$2;
var _descriptor8$1;
var _descriptor9$1;
var _descriptor10$1;
var _descriptor11$1;
var _descriptor12$1;
var _class3;
var _temp$2;
var MathTemp = function MathTemp2() {
};
MathTemp.tempMat4 = new Matrix();
MathTemp.tempVec4 = new Vector4();
MathTemp.tempVec3 = new Vector3();
MathTemp.tempVec2 = new Vector2();
var Camera = (_dec = dependencies(Transform), _dec(_class$2 = (_class2$2 = (_temp$2 = _class3 = function(_Component) {
  _inheritsLoose(Camera2, _Component);
  function Camera2(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _this.shaderData = new ShaderData(ShaderDataGroup.Camera);
    _this.priority = 0;
    _this.enableFrustumCulling = true;
    _this.clearFlags = CameraClearFlags.DepthColor;
    _this.cullingMask = Layer.Everything;
    _this._globalShaderMacro = new ShaderMacroCollection();
    _initializerDefineProperty(_this, "_frustum", _descriptor$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_renderPipeline", _descriptor2$2, _assertThisInitialized(_this));
    _this._isOrthographic = false;
    _this._isProjMatSetting = false;
    _this._nearClipPlane = 0.1;
    _this._farClipPlane = 100;
    _this._fieldOfView = 45;
    _this._orthographicSize = 10;
    _this._isProjectionDirty = true;
    _this._isInvProjMatDirty = true;
    _this._isFrustumProjectDirty = true;
    _this._customAspectRatio = void 0;
    _this._renderTarget = null;
    _initializerDefineProperty(_this, "_frustumViewChangeFlag", _descriptor3$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_transform", _descriptor4$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_isViewMatrixDirty", _descriptor5$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_isInvViewProjDirty", _descriptor6$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_projectionMatrix", _descriptor7$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_viewMatrix", _descriptor8$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_viewport", _descriptor9$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_inverseProjectionMatrix", _descriptor10$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_lastAspectSize", _descriptor11$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_invViewProjMat", _descriptor12$1, _assertThisInitialized(_this));
    var transform = _this.entity.transform;
    _this._transform = transform;
    _this._isViewMatrixDirty = transform.registerWorldChangeFlag();
    _this._isInvViewProjDirty = transform.registerWorldChangeFlag();
    _this._frustumViewChangeFlag = transform.registerWorldChangeFlag();
    _this._renderPipeline = new BasicRenderPipeline(_assertThisInitialized(_this));
    _this.shaderData._addRefCount(1);
    return _this;
  }
  var _proto = Camera2.prototype;
  _proto.resetProjectionMatrix = function resetProjectionMatrix() {
    this._isProjMatSetting = false;
    this._projMatChange();
  };
  _proto.resetAspectRatio = function resetAspectRatio() {
    this._customAspectRatio = void 0;
    this._projMatChange();
  };
  _proto.worldToViewportPoint = function worldToViewportPoint(point, out) {
    Matrix.multiply(this.projectionMatrix, this.viewMatrix, MathTemp.tempMat4);
    MathTemp.tempVec4.setValue(point.x, point.y, point.z, 1);
    Vector4.transform(MathTemp.tempVec4, MathTemp.tempMat4, MathTemp.tempVec4);
    var w = MathTemp.tempVec4.w;
    var nx = MathTemp.tempVec4.x / w;
    var ny = MathTemp.tempVec4.y / w;
    var nz = MathTemp.tempVec4.z / w;
    out.x = (nx + 1) * 0.5;
    out.y = (1 - ny) * 0.5;
    out.z = nz;
    out.w = w;
    return out;
  };
  _proto.viewportToWorldPoint = function viewportToWorldPoint(point, out) {
    var invViewProjMat = this.invViewProjMat;
    return this._innerViewportToWorldPoint(point, invViewProjMat, out);
  };
  _proto.viewportPointToRay = function viewportPointToRay(point, out) {
    var clipPoint = MathTemp.tempVec3;
    clipPoint.setValue(point.x, point.y, 0);
    var origin = this.viewportToWorldPoint(clipPoint, out.origin);
    clipPoint.z = 1;
    var farPoint = this._innerViewportToWorldPoint(clipPoint, this._invViewProjMat, clipPoint);
    Vector3.subtract(farPoint, origin, out.direction);
    out.direction.normalize();
    return out;
  };
  _proto.screenToViewportPoint = function screenToViewportPoint(point, out) {
    var canvas = this.engine.canvas;
    var viewport = this.viewport;
    out.x = (point.x / canvas.width - viewport.x) / viewport.z;
    out.y = (point.y / canvas.height - viewport.y) / viewport.w;
    return out;
  };
  _proto.viewportToScreenPoint = function viewportToScreenPoint(point, out) {
    var canvas = this.engine.canvas;
    var viewport = this.viewport;
    out.x = (viewport.x + point.x * viewport.z) * canvas.width;
    out.y = (viewport.y + point.y * viewport.w) * canvas.height;
    return out;
  };
  _proto.worldToScreenPoint = function worldToScreenPoint(point, out) {
    this.worldToViewportPoint(point, out);
    return this.viewportToScreenPoint(out, out);
  };
  _proto.screenToWorldPoint = function screenToWorldPoint(point, out) {
    this.screenToViewportPoint(point, out);
    return this.viewportToWorldPoint(out, out);
  };
  _proto.screenPointToRay = function screenPointToRay(point, out) {
    var viewportPoint = MathTemp.tempVec2;
    this.screenToViewportPoint(point, viewportPoint);
    return this.viewportPointToRay(viewportPoint, out);
  };
  _proto.render = function render(cubeFace) {
    var context = this.engine._renderContext;
    context._setContext(this);
    if (this.enableFrustumCulling && (this._frustumViewChangeFlag.flag || this._isFrustumProjectDirty)) {
      this._frustum.calculateFromMatrix(context._viewProjectMatrix);
      this._frustumViewChangeFlag.flag = false;
      this._isFrustumProjectDirty = false;
    }
    this._updateShaderData(context);
    ShaderMacroCollection.unionCollection(this.scene.shaderData._macroCollection, this.shaderData._macroCollection, this._globalShaderMacro);
    this._renderPipeline.render(context, cubeFace);
    this._engine._renderCount++;
  };
  _proto._onActive = function _onActive() {
    this.entity.scene._attachRenderCamera(this);
  };
  _proto._onInActive = function _onInActive() {
    this.entity.scene._detachRenderCamera(this);
  };
  _proto._onDestroy = function _onDestroy() {
    var _this$_renderPipeline;
    (_this$_renderPipeline = this._renderPipeline) === null || _this$_renderPipeline === void 0 ? void 0 : _this$_renderPipeline.destroy();
    this._isInvViewProjDirty.destroy();
    this._isViewMatrixDirty.destroy();
    this.shaderData._addRefCount(-1);
  };
  _proto._projMatChange = function _projMatChange() {
    this._isFrustumProjectDirty = true;
    this._isProjectionDirty = true;
    this._isInvProjMatDirty = true;
    this._isInvViewProjDirty.flag = true;
  };
  _proto._innerViewportToWorldPoint = function _innerViewportToWorldPoint(point, invViewProjMat, out) {
    var depth = point.z * 2 - 1;
    var clipPoint = MathTemp.tempVec4;
    clipPoint.setValue(point.x * 2 - 1, 1 - point.y * 2, depth, 1);
    Vector4.transform(clipPoint, invViewProjMat, clipPoint);
    var invW = 1 / clipPoint.w;
    out.x = clipPoint.x * invW;
    out.y = clipPoint.y * invW;
    out.z = clipPoint.z * invW;
    return out;
  };
  _proto._updateShaderData = function _updateShaderData(context) {
    var shaderData = this.shaderData;
    shaderData.setMatrix(Camera2._viewMatrixProperty, this.viewMatrix);
    shaderData.setMatrix(Camera2._projectionMatrixProperty, this.projectionMatrix);
    shaderData.setMatrix(Camera2._vpMatrixProperty, context._viewProjectMatrix);
    shaderData.setMatrix(Camera2._inverseViewMatrixProperty, this._transform.worldMatrix);
    shaderData.setMatrix(Camera2._inverseProjectionMatrixProperty, this.inverseProjectionMatrix);
    shaderData.setVector3(Camera2._cameraPositionProperty, this._transform.worldPosition);
  };
  _createClass(Camera2, [{
    key: "nearClipPlane",
    get: function get4() {
      return this._nearClipPlane;
    },
    set: function set4(value) {
      this._nearClipPlane = value;
      this._projMatChange();
    }
  }, {
    key: "farClipPlane",
    get: function get4() {
      return this._farClipPlane;
    },
    set: function set4(value) {
      this._farClipPlane = value;
      this._projMatChange();
    }
  }, {
    key: "fieldOfView",
    get: function get4() {
      return this._fieldOfView;
    },
    set: function set4(value) {
      this._fieldOfView = value;
      this._projMatChange();
    }
  }, {
    key: "aspectRatio",
    get: function get4() {
      var _this$_customAspectRa;
      var canvas = this._entity.engine.canvas;
      return (_this$_customAspectRa = this._customAspectRatio) != null ? _this$_customAspectRa : canvas.width * this._viewport.z / (canvas.height * this._viewport.w);
    },
    set: function set4(value) {
      this._customAspectRatio = value;
      this._projMatChange();
    }
  }, {
    key: "viewport",
    get: function get4() {
      return this._viewport;
    },
    set: function set4(value) {
      if (value !== this._viewport) {
        value.cloneTo(this._viewport);
      }
      this._projMatChange();
    }
  }, {
    key: "isOrthographic",
    get: function get4() {
      return this._isOrthographic;
    },
    set: function set4(value) {
      this._isOrthographic = value;
      this._projMatChange();
    }
  }, {
    key: "orthographicSize",
    get: function get4() {
      return this._orthographicSize;
    },
    set: function set4(value) {
      this._orthographicSize = value;
      this._projMatChange();
    }
  }, {
    key: "viewMatrix",
    get: function get4() {
      if (this._isViewMatrixDirty.flag) {
        this._isViewMatrixDirty.flag = false;
        Matrix.invert(this._transform.worldMatrix, this._viewMatrix);
      }
      return this._viewMatrix;
    }
  }, {
    key: "projectionMatrix",
    get: function get4() {
      var canvas = this._entity.engine.canvas;
      if ((!this._isProjectionDirty || this._isProjMatSetting) && this._lastAspectSize.x === canvas.width && this._lastAspectSize.y === canvas.height) {
        return this._projectionMatrix;
      }
      this._isProjectionDirty = false;
      this._lastAspectSize.x = canvas.width;
      this._lastAspectSize.y = canvas.height;
      var aspectRatio = this.aspectRatio;
      if (!this._isOrthographic) {
        Matrix.perspective(MathUtil.degreeToRadian(this._fieldOfView), aspectRatio, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);
      } else {
        var width = this._orthographicSize * aspectRatio;
        var height = this._orthographicSize;
        Matrix.ortho(-width, width, -height, height, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);
      }
      return this._projectionMatrix;
    },
    set: function set4(value) {
      this._projectionMatrix = value;
      this._isProjMatSetting = true;
      this._projMatChange();
    }
  }, {
    key: "enableHDR",
    get: function get4() {
      console.log("not implementation");
      return false;
    },
    set: function set4(value) {
      console.log("not implementation");
    }
  }, {
    key: "renderTarget",
    get: function get4() {
      return this._renderTarget;
    },
    set: function set4(value) {
      this._renderTarget = value;
    }
  }, {
    key: "invViewProjMat",
    get: function get4() {
      if (this._isInvViewProjDirty.flag) {
        this._isInvViewProjDirty.flag = false;
        Matrix.multiply(this._transform.worldMatrix, this.inverseProjectionMatrix, this._invViewProjMat);
      }
      return this._invViewProjMat;
    }
  }, {
    key: "inverseProjectionMatrix",
    get: function get4() {
      if (this._isInvProjMatDirty) {
        this._isInvProjMatDirty = false;
        Matrix.invert(this.projectionMatrix, this._inverseProjectionMatrix);
      }
      return this._inverseProjectionMatrix;
    }
  }]);
  return Camera2;
}(Component), _class3._viewMatrixProperty = Shader.getPropertyByName("u_viewMat"), _class3._projectionMatrixProperty = Shader.getPropertyByName("u_projMat"), _class3._vpMatrixProperty = Shader.getPropertyByName("u_VPMat"), _class3._inverseViewMatrixProperty = Shader.getPropertyByName("u_viewInvMat"), _class3._inverseProjectionMatrixProperty = Shader.getPropertyByName("u_projInvMat"), _class3._cameraPositionProperty = Shader.getPropertyByName("u_cameraPos"), _temp$2), _descriptor$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_frustum", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer47() {
    return new BoundingFrustum();
  }
}), _descriptor2$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_renderPipeline", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_frustumViewChangeFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_transform", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_isViewMatrixDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_isInvViewProjDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor7$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_projectionMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer48() {
    return new Matrix();
  }
}), _descriptor8$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_viewMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer49() {
    return new Matrix();
  }
}), _descriptor9$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_viewport", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer50() {
    return new Vector4(0, 0, 1, 1);
  }
}), _descriptor10$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_inverseProjectionMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer51() {
    return new Matrix();
  }
}), _descriptor11$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_lastAspectSize", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer52() {
    return new Vector2(0, 0);
  }
}), _descriptor12$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_invViewProjMat", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer53() {
    return new Matrix();
  }
}), _class2$2)) || _class$2);
var mimeType = {
  json: "json",
  gltf: "json",
  mtl: "json",
  prefab: "json",
  txt: "text",
  bin: "arraybuffer",
  png: "image",
  webp: "image",
  jpg: "image"
};
var defaultRetryCount = 4;
var defaultTimeout = 15e3;
var defaultInterval = 500;
function request(url, config) {
  if (config === void 0) {
    config = {};
  }
  return new AssetPromise(function(resolve, reject, setProgress) {
    var _config$retryCount, _config$retryInterval, _config$timeout, _config$type;
    var retryCount = (_config$retryCount = config.retryCount) != null ? _config$retryCount : defaultRetryCount;
    var retryInterval = (_config$retryInterval = config.retryInterval) != null ? _config$retryInterval : defaultInterval;
    config.timeout = (_config$timeout = config.timeout) != null ? _config$timeout : defaultTimeout;
    config.type = (_config$type = config.type) != null ? _config$type : getMimeTypeFromUrl(url);
    var realRequest = config.type === "image" ? requestImage : requestRes;
    var lastError;
    var executor = new MultiExecutor(function() {
      return realRequest(url, config).onProgress(setProgress).then(function(res) {
        resolve(res);
        executor.stop();
      }).catch(function(err) {
        return lastError = err;
      });
    }, retryCount, retryInterval);
    executor.start(function() {
      reject(lastError);
    });
  });
}
function requestImage(url, config) {
  return new AssetPromise(function(resolve, reject) {
    var timeout = config.timeout;
    var img = new Image();
    var onerror = function onerror2() {
      reject(new Error("request " + url + " fail"));
    };
    img.onerror = onerror;
    img.onabort = onerror;
    var timeoutId = setTimeout(function() {
      reject(new Error("request " + url + " timeout"));
    }, timeout);
    img.onload = function(timeoutId2) {
      return function() {
        requestAnimationFrame(function() {
          resolve(img);
          img.onload = null;
          img.onerror = null;
          img.onabort = null;
        });
        clearTimeout(timeoutId2);
      };
    }(timeoutId);
    img.crossOrigin = "anonymous";
    img.src = url;
  });
}
function requestRes(url, config) {
  return new AssetPromise(function(resolve, reject, setProgress) {
    var _config$method;
    var xhr = new XMLHttpRequest();
    xhr.timeout = config.timeout;
    config.method = (_config$method = config.method) != null ? _config$method : "get";
    xhr.onload = function() {
      var _xhr$response;
      if (xhr.status < 200 || xhr.status >= 300) {
        reject(new Error("request failed from: " + url));
        return;
      }
      var result = (_xhr$response = xhr.response) != null ? _xhr$response : xhr.responseText;
      resolve(result);
    };
    xhr.onerror = function() {
      reject(new Error("request failed from: " + url));
    };
    xhr.ontimeout = function() {
      reject(new Error("request timeout from: " + url));
    };
    xhr.onprogress = function(e) {
      setProgress(e.loaded / e.total);
    };
    xhr.open(config.method, url, true);
    xhr.withCredentials = config.credentials === "include";
    xhr.responseType = config.type;
    var headers = config.headers;
    if (headers) {
      Object.keys(headers).forEach(function(name) {
        xhr.setRequestHeader(name, headers[name]);
      });
    }
    xhr.send(config.body);
  });
}
function getMimeTypeFromUrl(url) {
  var extname = url.substring(url.lastIndexOf(".") + 1);
  return mimeType[extname];
}
var MultiExecutor = function() {
  function MultiExecutor2(execFunc, totalCount, interval) {
    this.execFunc = execFunc;
    this.totalCount = totalCount;
    this.interval = interval;
    this._timeoutId = -100;
    this._currentCount = 0;
    this.done = void 0;
    this.exec = this.exec.bind(this);
  }
  var _proto = MultiExecutor2.prototype;
  _proto.start = function start(done) {
    this.done = done;
    this.exec();
  };
  _proto.stop = function stop() {
    clearTimeout(this._timeoutId);
  };
  _proto.exec = function exec() {
    var _this = this;
    if (this._currentCount >= this.totalCount) {
      this.done && this.done();
      return;
    }
    this._currentCount++;
    this.execFunc(this._currentCount).then(function() {
      _this._timeoutId = setTimeout(_this.exec, _this.interval);
    });
  };
  return MultiExecutor2;
}();
var Loader = function Loader2(useCache) {
  this.useCache = useCache;
  this.request = request;
};
var AssetType;
(function(AssetType2) {
  AssetType2["Text"] = "text";
  AssetType2["JSON"] = "json";
  AssetType2["Buffer"] = "buffer";
  AssetType2["Texture2D"] = "texture2d";
  AssetType2["TextureCube"] = "texture-cube";
  AssetType2["Material"] = "material";
  AssetType2["Mesh"] = "mesh";
  AssetType2["AnimationClip"] = "animation-clip";
  AssetType2["Prefab"] = "prefab";
  AssetType2["KTX"] = "ktx";
  AssetType2["KTXCube"] = "ktx-cube";
  AssetType2["SpriteAtlas"] = "sprite-atlas";
})(AssetType || (AssetType = {}));
var RenderFace;
(function(RenderFace2) {
  RenderFace2[RenderFace2["Front"] = 0] = "Front";
  RenderFace2[RenderFace2["Back"] = 1] = "Back";
  RenderFace2[RenderFace2["Double"] = 2] = "Double";
})(RenderFace || (RenderFace = {}));
var BlendMode;
(function(BlendMode2) {
  BlendMode2[BlendMode2["Normal"] = 0] = "Normal";
  BlendMode2[BlendMode2["Additive"] = 1] = "Additive";
})(BlendMode || (BlendMode = {}));
var BaseMaterial = function(_Material) {
  _inheritsLoose(BaseMaterial2, _Material);
  function BaseMaterial2(engine, shader) {
    var _this;
    _this = _Material.call(this, engine, shader) || this;
    _this._renderFace = RenderFace.Front;
    _this._isTransparent = false;
    _this._blendMode = void 0;
    _this.blendMode = BlendMode.Normal;
    _this.shaderData.setFloat(BaseMaterial2._alphaCutoffProp, 0);
    return _this;
  }
  var _proto = BaseMaterial2.prototype;
  _proto.clone = function clone2() {
    var dest = new BaseMaterial2(this._engine, this.shader);
    this.cloneTo(dest);
    return dest;
  };
  _proto.cloneTo = function cloneTo(target) {
    _Material.prototype.cloneTo.call(this, target);
    target._renderFace = this._renderFace;
    target._isTransparent = this._isTransparent;
    target._blendMode = this._blendMode;
  };
  _createClass(BaseMaterial2, [{
    key: "isTransparent",
    get: function get4() {
      return this._isTransparent;
    },
    set: function set4(value) {
      if (value === this._isTransparent)
        return;
      this._isTransparent = value;
      var _this$renderState = this.renderState, depthState = _this$renderState.depthState, targetBlendState = _this$renderState.blendState.targetBlendState;
      if (value) {
        targetBlendState.enabled = true;
        depthState.writeEnabled = false;
        this.renderQueueType = RenderQueueType.Transparent;
      } else {
        targetBlendState.enabled = false;
        depthState.writeEnabled = true;
        this.renderQueueType = this.shaderData.getFloat(BaseMaterial2._alphaCutoffProp) ? RenderQueueType.AlphaTest : RenderQueueType.Opaque;
      }
    }
  }, {
    key: "alphaCutoff",
    get: function get4() {
      return this.shaderData.getFloat(BaseMaterial2._alphaCutoffProp);
    },
    set: function set4(value) {
      this.shaderData.setFloat(BaseMaterial2._alphaCutoffProp, value);
      if (value > 0) {
        this.shaderData.enableMacro(BaseMaterial2._alphaCutoffMacro);
        this.renderQueueType = this._isTransparent ? RenderQueueType.Transparent : RenderQueueType.AlphaTest;
      } else {
        this.shaderData.disableMacro(BaseMaterial2._alphaCutoffMacro);
        this.renderQueueType = this._isTransparent ? RenderQueueType.Transparent : RenderQueueType.Opaque;
      }
    }
  }, {
    key: "renderFace",
    get: function get4() {
      return this._renderFace;
    },
    set: function set4(value) {
      if (value === this._renderFace)
        return;
      this._renderFace = value;
      switch (value) {
        case RenderFace.Front:
          this.renderState.rasterState.cullMode = CullMode.Back;
          break;
        case RenderFace.Back:
          this.renderState.rasterState.cullMode = CullMode.Front;
          break;
        case RenderFace.Double:
          this.renderState.rasterState.cullMode = CullMode.Off;
          break;
      }
    }
  }, {
    key: "blendMode",
    get: function get4() {
      return this._blendMode;
    },
    set: function set4(value) {
      if (value === this._blendMode)
        return;
      this._blendMode = value;
      var target = this.renderState.blendState.targetBlendState;
      switch (value) {
        case BlendMode.Normal:
          target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
          target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
          target.sourceAlphaBlendFactor = BlendFactor.One;
          target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
          target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
          break;
        case BlendMode.Additive:
          target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
          target.destinationColorBlendFactor = BlendFactor.One;
          target.sourceAlphaBlendFactor = BlendFactor.One;
          target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
          target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
          break;
      }
    }
  }]);
  return BaseMaterial2;
}(Material);
BaseMaterial._alphaCutoffMacro = Shader.getMacroByName("ALPHA_CUTOFF");
BaseMaterial._alphaCutoffProp = Shader.getPropertyByName("u_alphaCutoff");
var BlinnPhongMaterial = function(_BaseMaterial) {
  _inheritsLoose(BlinnPhongMaterial2, _BaseMaterial);
  function BlinnPhongMaterial2(engine) {
    var _this;
    _this = _BaseMaterial.call(this, engine, Shader.find("blinn-phong")) || this;
    var shaderData = _this.shaderData;
    shaderData.enableMacro("O3_NEED_WORLDPOS");
    shaderData.enableMacro("O3_NEED_TILINGOFFSET");
    shaderData.setColor(BlinnPhongMaterial2._diffuseColorProp, new Color(1, 1, 1, 1));
    shaderData.setColor(BlinnPhongMaterial2._specularColorProp, new Color(1, 1, 1, 1));
    shaderData.setColor(BlinnPhongMaterial2._emissiveColorProp, new Color(0, 0, 0, 1));
    shaderData.setVector4(BlinnPhongMaterial2._tilingOffsetProp, new Vector4(1, 1, 0, 0));
    shaderData.setFloat(BlinnPhongMaterial2._shininessProp, 16);
    shaderData.setFloat(BlinnPhongMaterial2._normalIntensityProp, 1);
    return _this;
  }
  var _proto = BlinnPhongMaterial2.prototype;
  _proto.clone = function clone2() {
    var dest = new BlinnPhongMaterial2(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _createClass(BlinnPhongMaterial2, [{
    key: "baseColor",
    get: function get4() {
      return this.shaderData.getColor(BlinnPhongMaterial2._diffuseColorProp);
    },
    set: function set4(value) {
      var baseColor = this.shaderData.getColor(BlinnPhongMaterial2._diffuseColorProp);
      if (value !== baseColor) {
        value.cloneTo(baseColor);
      }
    }
  }, {
    key: "baseTexture",
    get: function get4() {
      return this.shaderData.getTexture(BlinnPhongMaterial2._baseTextureProp);
    },
    set: function set4(value) {
      this.shaderData.setTexture(BlinnPhongMaterial2._baseTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("O3_DIFFUSE_TEXTURE");
      } else {
        this.shaderData.disableMacro("O3_DIFFUSE_TEXTURE");
      }
    }
  }, {
    key: "specularColor",
    get: function get4() {
      return this.shaderData.getColor(BlinnPhongMaterial2._specularColorProp);
    },
    set: function set4(value) {
      var specularColor = this.shaderData.getColor(BlinnPhongMaterial2._specularColorProp);
      if (value !== specularColor) {
        value.cloneTo(specularColor);
      }
    }
  }, {
    key: "specularTexture",
    get: function get4() {
      return this.shaderData.getTexture(BlinnPhongMaterial2._specularTextureProp);
    },
    set: function set4(value) {
      this.shaderData.setTexture(BlinnPhongMaterial2._specularTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("O3_SPECULAR_TEXTURE");
      } else {
        this.shaderData.disableMacro("O3_SPECULAR_TEXTURE");
      }
    }
  }, {
    key: "emissiveColor",
    get: function get4() {
      return this.shaderData.getColor(BlinnPhongMaterial2._emissiveColorProp);
    },
    set: function set4(value) {
      var emissiveColor = this.shaderData.getColor(BlinnPhongMaterial2._emissiveColorProp);
      if (value !== emissiveColor) {
        value.cloneTo(emissiveColor);
      }
    }
  }, {
    key: "emissiveTexture",
    get: function get4() {
      return this.shaderData.getTexture(BlinnPhongMaterial2._emissiveTextureProp);
    },
    set: function set4(value) {
      this.shaderData.setTexture(BlinnPhongMaterial2._emissiveTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("O3_EMISSIVE_TEXTURE");
      } else {
        this.shaderData.disableMacro("O3_EMISSIVE_TEXTURE");
      }
    }
  }, {
    key: "normalTexture",
    get: function get4() {
      return this.shaderData.getTexture(BlinnPhongMaterial2._normalTextureProp);
    },
    set: function set4(value) {
      this.shaderData.setTexture(BlinnPhongMaterial2._normalTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("O3_NORMAL_TEXTURE");
      } else {
        this.shaderData.disableMacro("O3_NORMAL_TEXTURE");
      }
    }
  }, {
    key: "normalIntensity",
    get: function get4() {
      return this.shaderData.getFloat(BlinnPhongMaterial2._normalIntensityProp);
    },
    set: function set4(value) {
      this.shaderData.setFloat(BlinnPhongMaterial2._normalIntensityProp, value);
    }
  }, {
    key: "shininess",
    get: function get4() {
      return this.shaderData.getFloat(BlinnPhongMaterial2._shininessProp);
    },
    set: function set4(value) {
      this.shaderData.setFloat(BlinnPhongMaterial2._shininessProp, value);
    }
  }, {
    key: "tilingOffset",
    get: function get4() {
      return this.shaderData.getVector4(BlinnPhongMaterial2._tilingOffsetProp);
    },
    set: function set4(value) {
      var tilingOffset = this.shaderData.getVector4(BlinnPhongMaterial2._tilingOffsetProp);
      if (value !== tilingOffset) {
        value.cloneTo(tilingOffset);
      }
    }
  }]);
  return BlinnPhongMaterial2;
}(BaseMaterial);
BlinnPhongMaterial._diffuseColorProp = Shader.getPropertyByName("u_diffuseColor");
BlinnPhongMaterial._specularColorProp = Shader.getPropertyByName("u_specularColor");
BlinnPhongMaterial._emissiveColorProp = Shader.getPropertyByName("u_emissiveColor");
BlinnPhongMaterial._tilingOffsetProp = Shader.getPropertyByName("u_tilingOffset");
BlinnPhongMaterial._shininessProp = Shader.getPropertyByName("u_shininess");
BlinnPhongMaterial._normalIntensityProp = Shader.getPropertyByName("u_normalIntensity");
BlinnPhongMaterial._baseTextureProp = Shader.getPropertyByName("u_diffuseTexture");
BlinnPhongMaterial._specularTextureProp = Shader.getPropertyByName("u_specularTexture");
BlinnPhongMaterial._emissiveTextureProp = Shader.getPropertyByName("u_emissiveTexture");
BlinnPhongMaterial._normalTextureProp = Shader.getPropertyByName("u_normalTexture");
var PBRBaseMaterial = function(_BaseMaterial) {
  _inheritsLoose(PBRBaseMaterial2, _BaseMaterial);
  function PBRBaseMaterial2(engine) {
    var _this;
    _this = _BaseMaterial.call(this, engine, Shader.find("pbr")) || this;
    var shaderData = _this.shaderData;
    shaderData.enableMacro("O3_NEED_WORLDPOS");
    shaderData.enableMacro("O3_NEED_TILINGOFFSET");
    shaderData.setColor(PBRBaseMaterial2._baseColorProp, new Color(1, 1, 1, 1));
    shaderData.setColor(PBRBaseMaterial2._emissiveColorProp, new Color(0, 0, 0, 1));
    shaderData.setVector4(PBRBaseMaterial2._tilingOffsetProp, new Vector4(1, 1, 0, 0));
    shaderData.setFloat(PBRBaseMaterial2._normalTextureIntensityProp, 1);
    shaderData.setFloat(PBRBaseMaterial2._occlusionTextureIntensityProp, 1);
    return _this;
  }
  _createClass(PBRBaseMaterial2, [{
    key: "baseColor",
    get: function get4() {
      return this.shaderData.getColor(PBRBaseMaterial2._baseColorProp);
    },
    set: function set4(value) {
      var baseColor = this.shaderData.getColor(PBRBaseMaterial2._baseColorProp);
      if (value !== baseColor) {
        value.cloneTo(baseColor);
      }
    }
  }, {
    key: "baseTexture",
    get: function get4() {
      return this.shaderData.getTexture(PBRBaseMaterial2._baseTextureProp);
    },
    set: function set4(value) {
      this.shaderData.setTexture(PBRBaseMaterial2._baseTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("HAS_BASECOLORMAP");
      } else {
        this.shaderData.disableMacro("HAS_BASECOLORMAP");
      }
    }
  }, {
    key: "normalTexture",
    get: function get4() {
      return this.shaderData.getTexture(PBRBaseMaterial2._normalTextureProp);
    },
    set: function set4(value) {
      this.shaderData.setTexture(PBRBaseMaterial2._normalTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("O3_NORMAL_TEXTURE");
      } else {
        this.shaderData.disableMacro("O3_NORMAL_TEXTURE");
      }
    }
  }, {
    key: "normalTextureIntensity",
    get: function get4() {
      return this.shaderData.getFloat(PBRBaseMaterial2._normalTextureIntensityProp);
    },
    set: function set4(value) {
      this.shaderData.setFloat(PBRBaseMaterial2._normalTextureIntensityProp, value);
      this.shaderData.setFloat("u_normalIntensity", value);
    }
  }, {
    key: "emissiveColor",
    get: function get4() {
      return this.shaderData.getColor(PBRBaseMaterial2._emissiveColorProp);
    },
    set: function set4(value) {
      var emissiveColor = this.shaderData.getColor(PBRBaseMaterial2._emissiveColorProp);
      if (value !== emissiveColor) {
        value.cloneTo(emissiveColor);
      }
    }
  }, {
    key: "emissiveTexture",
    get: function get4() {
      return this.shaderData.getTexture(PBRBaseMaterial2._emissiveTextureProp);
    },
    set: function set4(value) {
      this.shaderData.setTexture(PBRBaseMaterial2._emissiveTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("HAS_EMISSIVEMAP");
      } else {
        this.shaderData.disableMacro("HAS_EMISSIVEMAP");
      }
    }
  }, {
    key: "occlusionTexture",
    get: function get4() {
      return this.shaderData.getTexture(PBRBaseMaterial2._occlusionTextureProp);
    },
    set: function set4(value) {
      this.shaderData.setTexture(PBRBaseMaterial2._occlusionTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("HAS_OCCLUSIONMAP");
      } else {
        this.shaderData.disableMacro("HAS_OCCLUSIONMAP");
      }
    }
  }, {
    key: "occlusionTextureIntensity",
    get: function get4() {
      return this.shaderData.getFloat(PBRBaseMaterial2._occlusionTextureIntensityProp);
    },
    set: function set4(value) {
      this.shaderData.setFloat(PBRBaseMaterial2._occlusionTextureIntensityProp, value);
    }
  }, {
    key: "tilingOffset",
    get: function get4() {
      return this.shaderData.getVector4(PBRBaseMaterial2._tilingOffsetProp);
    },
    set: function set4(value) {
      var tilingOffset = this.shaderData.getVector4(PBRBaseMaterial2._tilingOffsetProp);
      if (value !== tilingOffset) {
        value.cloneTo(tilingOffset);
      }
    }
  }]);
  return PBRBaseMaterial2;
}(BaseMaterial);
PBRBaseMaterial._baseColorProp = Shader.getPropertyByName("u_baseColor");
PBRBaseMaterial._emissiveColorProp = Shader.getPropertyByName("u_emissiveColor");
PBRBaseMaterial._tilingOffsetProp = Shader.getPropertyByName("u_tilingOffset");
PBRBaseMaterial._baseTextureProp = Shader.getPropertyByName("u_baseColorSampler");
PBRBaseMaterial._normalTextureProp = Shader.getPropertyByName("u_normalTexture");
PBRBaseMaterial._normalTextureIntensityProp = Shader.getPropertyByName("u_normalIntensity");
PBRBaseMaterial._occlusionTextureIntensityProp = Shader.getPropertyByName("u_occlusionStrength");
PBRBaseMaterial._emissiveTextureProp = Shader.getPropertyByName("u_emissiveSampler");
PBRBaseMaterial._occlusionTextureProp = Shader.getPropertyByName("u_occlusionSampler");
var PBRMaterial = function(_PBRBaseMaterial) {
  _inheritsLoose(PBRMaterial2, _PBRBaseMaterial);
  function PBRMaterial2(engine) {
    var _this;
    _this = _PBRBaseMaterial.call(this, engine) || this;
    _this.shaderData.enableMacro("IS_METALLIC_WORKFLOW");
    _this.shaderData.setFloat(PBRMaterial2._metallicProp, 1);
    _this.shaderData.setFloat(PBRMaterial2._roughnessProp, 1);
    return _this;
  }
  var _proto = PBRMaterial2.prototype;
  _proto.clone = function clone2() {
    var dest = new PBRMaterial2(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _createClass(PBRMaterial2, [{
    key: "metallic",
    get: function get4() {
      return this.shaderData.getFloat(PBRMaterial2._metallicProp);
    },
    set: function set4(value) {
      this.shaderData.setFloat(PBRMaterial2._metallicProp, value);
    }
  }, {
    key: "roughness",
    get: function get4() {
      return this.shaderData.getFloat(PBRMaterial2._roughnessProp);
    },
    set: function set4(value) {
      this.shaderData.setFloat(PBRMaterial2._roughnessProp, value);
    }
  }, {
    key: "roughnessMetallicTexture",
    get: function get4() {
      return this.shaderData.getTexture(PBRMaterial2._metallicRoughnessTextureProp);
    },
    set: function set4(value) {
      this.shaderData.setTexture(PBRMaterial2._metallicRoughnessTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("HAS_METALROUGHNESSMAP");
      } else {
        this.shaderData.disableMacro("HAS_METALROUGHNESSMAP");
      }
    }
  }]);
  return PBRMaterial2;
}(PBRBaseMaterial);
PBRMaterial._metallicProp = Shader.getPropertyByName("u_metal");
PBRMaterial._roughnessProp = Shader.getPropertyByName("u_roughness");
PBRMaterial._metallicRoughnessTextureProp = Shader.getPropertyByName("u_metallicRoughnessSampler");
var PBRSpecularMaterial = function(_PBRBaseMaterial) {
  _inheritsLoose(PBRSpecularMaterial2, _PBRBaseMaterial);
  function PBRSpecularMaterial2(engine) {
    var _this;
    _this = _PBRBaseMaterial.call(this, engine) || this;
    _this.shaderData.setColor(PBRSpecularMaterial2._specularColorProp, new Color(1, 1, 1, 1));
    _this.shaderData.setFloat(PBRSpecularMaterial2._glossinessProp, 1);
    return _this;
  }
  var _proto = PBRSpecularMaterial2.prototype;
  _proto.clone = function clone2() {
    var dest = new PBRSpecularMaterial2(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _createClass(PBRSpecularMaterial2, [{
    key: "specularColor",
    get: function get4() {
      return this.shaderData.getColor(PBRSpecularMaterial2._specularColorProp);
    },
    set: function set4(value) {
      var specularColor = this.shaderData.getColor(PBRSpecularMaterial2._specularColorProp);
      if (value !== specularColor) {
        value.cloneTo(specularColor);
      }
    }
  }, {
    key: "glossiness",
    get: function get4() {
      return this.shaderData.getFloat(PBRSpecularMaterial2._glossinessProp);
    },
    set: function set4(value) {
      this.shaderData.setFloat(PBRSpecularMaterial2._glossinessProp, value);
    }
  }, {
    key: "specularGlossinessTexture",
    get: function get4() {
      return this.shaderData.getTexture(PBRSpecularMaterial2._specularGlossinessTextureProp);
    },
    set: function set4(value) {
      this.shaderData.setTexture(PBRSpecularMaterial2._specularGlossinessTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("HAS_SPECULARGLOSSINESSMAP");
      } else {
        this.shaderData.disableMacro("HAS_SPECULARGLOSSINESSMAP");
      }
    }
  }]);
  return PBRSpecularMaterial2;
}(PBRBaseMaterial);
PBRSpecularMaterial._specularColorProp = Shader.getPropertyByName("u_specularColor");
PBRSpecularMaterial._glossinessProp = Shader.getPropertyByName("u_glossinessFactor");
PBRSpecularMaterial._specularGlossinessTextureProp = Shader.getPropertyByName("u_specularGlossinessSampler");
var UnlitMaterial = function(_BaseMaterial) {
  _inheritsLoose(UnlitMaterial2, _BaseMaterial);
  function UnlitMaterial2(engine) {
    var _this;
    _this = _BaseMaterial.call(this, engine, Shader.find("unlit")) || this;
    var shaderData = _this.shaderData;
    shaderData.enableMacro("OMIT_NORMAL");
    shaderData.enableMacro("O3_NEED_TILINGOFFSET");
    shaderData.setColor(UnlitMaterial2._baseColorProp, new Color(1, 1, 1, 1));
    shaderData.setVector4(UnlitMaterial2._tilingOffsetProp, new Vector4(1, 1, 0, 0));
    return _this;
  }
  var _proto = UnlitMaterial2.prototype;
  _proto.clone = function clone2() {
    var dest = new UnlitMaterial2(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _createClass(UnlitMaterial2, [{
    key: "baseColor",
    get: function get4() {
      return this.shaderData.getColor(UnlitMaterial2._baseColorProp);
    },
    set: function set4(value) {
      var baseColor = this.shaderData.getColor(UnlitMaterial2._baseColorProp);
      if (value !== baseColor) {
        value.cloneTo(baseColor);
      }
    }
  }, {
    key: "baseTexture",
    get: function get4() {
      return this.shaderData.getTexture(UnlitMaterial2._baseTextureProp);
    },
    set: function set4(value) {
      this.shaderData.setTexture(UnlitMaterial2._baseTextureProp, value);
      if (value) {
        this.shaderData.enableMacro("O3_BASE_TEXTURE");
      } else {
        this.shaderData.disableMacro("O3_BASE_TEXTURE");
      }
    }
  }, {
    key: "tilingOffset",
    get: function get4() {
      return this.shaderData.getVector4(UnlitMaterial2._tilingOffsetProp);
    },
    set: function set4(value) {
      var tilingOffset = this.shaderData.getVector4(UnlitMaterial2._tilingOffsetProp);
      if (value !== tilingOffset) {
        value.cloneTo(tilingOffset);
      }
    }
  }]);
  return UnlitMaterial2;
}(BaseMaterial);
UnlitMaterial._baseColorProp = Shader.getPropertyByName("u_baseColor");
UnlitMaterial._baseTextureProp = Shader.getPropertyByName("u_baseTexture");
UnlitMaterial._tilingOffsetProp = Shader.getPropertyByName("u_tilingOffset");
var SpriteAtlas = function(_RefObject) {
  _inheritsLoose(SpriteAtlas2, _RefObject);
  var _proto = SpriteAtlas2.prototype;
  _proto.getSprite = function getSprite(name) {
    var sprite = this._sprites[this._spriteNamesToIndex[name]];
    if (!sprite) {
      console.warn("There is no sprite named " + name + " in the atlas.");
    }
    return sprite;
  };
  _proto.getSprites = function getSprites(name, outSprites) {
    outSprites.length = 0;
    var i = this._spriteNamesToIndex[name];
    if (i !== void 0) {
      var _sprites = this._sprites;
      for (; i >= 0; i--) {
        var sprite = _sprites[i];
        sprite.name === name && outSprites.push(sprite);
      }
    } else {
      console.warn("The name of the sprite you want to find is not exit in SpriteAtlas.");
    }
    return outSprites;
  };
  function SpriteAtlas2(engine) {
    var _this;
    _this = _RefObject.call(this, engine) || this;
    _this._sprites = new Array();
    _this._spriteNamesToIndex = {};
    return _this;
  }
  _proto._addSprite = function _addSprite(sprite) {
    this._spriteNamesToIndex[sprite.name] = this._sprites.push(sprite) - 1;
  };
  _proto._onDestroy = function _onDestroy() {
    this._sprites = null;
    this._spriteNamesToIndex = null;
  };
  _createClass(SpriteAtlas2, [{
    key: "sprites",
    get: function get4() {
      return this._sprites;
    }
  }]);
  return SpriteAtlas2;
}(RefObject);
var Sprite = function(_RefObject) {
  _inheritsLoose(Sprite2, _RefObject);
  function Sprite2(engine, texture, region, pivot, pixelsPerUnit, name) {
    var _this;
    if (texture === void 0) {
      texture = null;
    }
    if (region === void 0) {
      region = null;
    }
    if (pivot === void 0) {
      pivot = null;
    }
    if (pixelsPerUnit === void 0) {
      pixelsPerUnit = 128;
    }
    if (name === void 0) {
      name = null;
    }
    _this = _RefObject.call(this, engine) || this;
    _this.name = void 0;
    _this._uv = [new Vector2(), new Vector2(), new Vector2(), new Vector2()];
    _this._positions = [new Vector2(), new Vector2(), new Vector2(), new Vector2()];
    _this._bounds = new BoundingBox();
    _this._triangles = void 0;
    _this._assetID = void 0;
    _this._pixelsPerUnit = void 0;
    _this._texture = null;
    _this._atlasRotated = false;
    _this._region = new Rect(0, 0, 1, 1);
    _this._pivot = new Vector2(0.5, 0.5);
    _this._atlasRegion = new Rect(0, 0, 1, 1);
    _this._atlasRegionOffset = new Vector4(0, 0, 0, 0);
    _this._dirtyFlag = DirtyFlag$1.all;
    _this.name = name;
    _this._texture = texture;
    _this._pixelsPerUnit = pixelsPerUnit;
    region && region.cloneTo(_this._region);
    pivot && pivot.cloneTo(_this._pivot);
    _this._triangles = Sprite2._rectangleTriangles;
    return _this;
  }
  var _proto = Sprite2.prototype;
  _proto._onDestroy = function _onDestroy() {
    if (this._texture) {
      this._texture = null;
    }
  };
  _proto._updatePositionsAndBounds = function _updatePositionsAndBounds() {
    var texture = this._texture, bounds = this._bounds;
    if (texture) {
      var atlasRegion = this._atlasRegion, pivot = this._pivot, atlasRegionOffset = this._atlasRegionOffset;
      var _this$_region = this._region, regionX = _this$_region.x, regionY = _this$_region.y, regionW = _this$_region.width, regionH = _this$_region.height;
      var pPUReciprocal = 1 / this._pixelsPerUnit;
      var lx, ty, rx, by;
      var textureW, textureH;
      if (this._atlasRotated) {
        textureW = texture.height * atlasRegion.height * pPUReciprocal;
        textureH = texture.width * atlasRegion.width * pPUReciprocal;
      } else {
        textureW = texture.width * atlasRegion.width * pPUReciprocal;
        textureH = texture.height * atlasRegion.height * pPUReciprocal;
      }
      if (atlasRegionOffset.x == 0 && atlasRegionOffset.y == 0 && atlasRegionOffset.z == 0 && atlasRegionOffset.w == 0) {
        var realRenderW = textureW * regionW;
        var realRenderH = textureH * regionH;
        lx = -pivot.x * realRenderW;
        by = -pivot.y * realRenderH;
        rx = realRenderW + lx;
        ty = realRenderH + by;
      } else {
        var blankLeft = atlasRegionOffset.x, blankTop = atlasRegionOffset.y, blankRight = atlasRegionOffset.z, blankBottom = atlasRegionOffset.w;
        var oriWidth = textureW / (1 - blankRight - blankLeft);
        var oriHeight = textureH / (1 - blankBottom - blankTop);
        lx = (-pivot.x * regionW + Math.max(blankLeft, regionX) - regionX) * oriWidth;
        ty = (pivot.y * regionH - Math.max(blankTop, regionY) + regionY) * oriHeight;
        rx = (-pivot.x * regionW + Math.min(1 - blankRight, regionX + regionW) - regionX) * oriWidth;
        by = (pivot.y * regionH - Math.min(1 - blankBottom, regionY + regionH) + regionY) * oriHeight;
      }
      var positions = this._positions;
      positions[0].setValue(lx, ty);
      positions[1].setValue(rx, ty);
      positions[2].setValue(rx, by);
      positions[3].setValue(lx, by);
      bounds.min.setValue(lx, by, 0);
      bounds.max.setValue(rx, ty, 0);
    } else {
      bounds.min.setValue(0, 0, 0);
      bounds.max.setValue(0, 0, 0);
    }
  };
  _proto._updateMesh = function _updateMesh() {
    if (this._isContainDirtyFlag(DirtyFlag$1.positions)) {
      this._updatePositionsAndBounds();
    }
    if (this._isContainDirtyFlag(DirtyFlag$1.uv)) {
      var _atlasRegion = this._atlasRegion, uv = this._uv, region = this._region, _atlasRotated = this._atlasRotated, atlasRegionOffset = this._atlasRegionOffset;
      var left, top, right, bottom;
      if (atlasRegionOffset.x == 0 && atlasRegionOffset.y == 0 && atlasRegionOffset.z == 0 && atlasRegionOffset.w == 0) {
        var atlasRegionW = _atlasRegion.width, atlasRegionH = _atlasRegion.height;
        if (_atlasRotated) {
          left = atlasRegionW * (1 - region.y - region.height) + _atlasRegion.x;
          top = atlasRegionH * region.x + _atlasRegion.y;
          right = atlasRegionW * region.height + left;
          bottom = atlasRegionH * region.width + top;
        } else {
          left = atlasRegionW * region.x + _atlasRegion.x;
          top = atlasRegionH * region.y + _atlasRegion.y;
          right = atlasRegionW * region.width + left;
          bottom = atlasRegionH * region.height + top;
        }
      } else {
        var regionX = region.x, regionY = region.y;
        var atlasRegionX = _atlasRegion.x, atlasRegionY = _atlasRegion.y;
        var blankLeft = atlasRegionOffset.x, blankTop = atlasRegionOffset.y, blankRight = atlasRegionOffset.z, blankBottom = atlasRegionOffset.w;
        if (_atlasRotated) {
          var textureW = _atlasRegion.width / (1 - blankBottom - blankTop);
          var textureH = _atlasRegion.height / (1 - blankRight - blankLeft);
          left = (Math.max(blankBottom, 1 - regionY - region.height) - blankBottom) * textureW + atlasRegionX;
          top = (Math.max(blankLeft, regionX) - blankLeft) * textureH + atlasRegionY;
          right = (Math.min(1 - blankTop, 1 - regionY) - blankBottom) * textureW + atlasRegionX;
          bottom = (Math.min(1 - blankRight, regionX + region.width) - blankLeft) * textureH + atlasRegionY;
        } else {
          var _textureW = _atlasRegion.width / (1 - blankRight - blankLeft);
          var _textureH = _atlasRegion.height / (1 - blankBottom - blankTop);
          left = (Math.max(blankLeft, regionX) - blankLeft) * _textureW + atlasRegionX;
          top = (Math.max(blankTop, regionY) - blankTop) * _textureH + atlasRegionY;
          right = (Math.min(1 - blankRight, regionX + region.width) - blankLeft) * _textureW + atlasRegionX;
          bottom = (Math.min(1 - blankBottom, regionY + region.height) - blankTop) * _textureH + atlasRegionY;
        }
      }
      if (_atlasRotated) {
        uv[0].setValue(right, top);
        uv[1].setValue(right, bottom);
        uv[2].setValue(left, bottom);
        uv[3].setValue(left, top);
      } else {
        uv[0].setValue(left, top);
        uv[1].setValue(right, top);
        uv[2].setValue(right, bottom);
        uv[3].setValue(left, bottom);
      }
    }
  };
  _proto._updateMeshData = function _updateMeshData() {
    if (this._isContainDirtyFlag(DirtyFlag$1.all)) {
      this._updateMesh();
      this._setDirtyFlagFalse(DirtyFlag$1.all);
      return true;
    }
    return false;
  };
  _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
    return (this._dirtyFlag & type) != 0;
  };
  _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
    this._dirtyFlag |= type;
  };
  _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
    this._dirtyFlag &= ~type;
  };
  _createClass(Sprite2, [{
    key: "texture",
    get: function get4() {
      return this._texture;
    },
    set: function set4(value) {
      if (this._texture !== value) {
        this._texture = value;
        this._setDirtyFlagTrue(DirtyFlag$1.positions);
      }
    }
  }, {
    key: "bounds",
    get: function get4() {
      if (this._isContainDirtyFlag(DirtyFlag$1.positions) && this._texture) {
        this._updatePositionsAndBounds();
        this._setDirtyFlagFalse(DirtyFlag$1.positions);
      }
      return this._bounds;
    }
  }, {
    key: "atlasRotated",
    get: function get4() {
      return this._atlasRotated;
    },
    set: function set4(value) {
      if (this._atlasRotated != value) {
        this._atlasRotated = value;
        this._setDirtyFlagTrue(DirtyFlag$1.positions | DirtyFlag$1.uv);
      }
    }
  }, {
    key: "atlasRegion",
    get: function get4() {
      return this._atlasRegion;
    },
    set: function set4(value) {
      var x = MathUtil.clamp(value.x, 0, 1);
      var y = MathUtil.clamp(value.y, 0, 1);
      this._atlasRegion.setValue(x, y, MathUtil.clamp(value.width, 0, 1 - x), MathUtil.clamp(value.height, 0, 1 - y));
      this._setDirtyFlagTrue(DirtyFlag$1.positions | DirtyFlag$1.uv);
    }
  }, {
    key: "atlasRegionOffset",
    get: function get4() {
      return this._atlasRegionOffset;
    },
    set: function set4(value) {
      var x = MathUtil.clamp(value.x, 0, 1);
      var y = MathUtil.clamp(value.y, 0, 1);
      this._atlasRegionOffset.setValue(x, y, MathUtil.clamp(value.z, 0, 1 - x), MathUtil.clamp(value.w, 0, 1 - y));
      this._setDirtyFlagTrue(DirtyFlag$1.positions | DirtyFlag$1.uv);
    }
  }, {
    key: "pivot",
    get: function get4() {
      return this._pivot;
    },
    set: function set4(value) {
      this._pivot.setValue(MathUtil.clamp(value.x, 0, 1), MathUtil.clamp(value.y, 0, 1));
      this._setDirtyFlagTrue(DirtyFlag$1.positions);
    }
  }, {
    key: "region",
    get: function get4() {
      return this._region;
    },
    set: function set4(value) {
      var region = this._region;
      var x = MathUtil.clamp(value.x, 0, 1);
      var y = MathUtil.clamp(value.y, 0, 1);
      region.setValue(x, y, MathUtil.clamp(value.width, 0, 1 - x), MathUtil.clamp(value.height, 0, 1 - y));
      this._setDirtyFlagTrue(DirtyFlag$1.positions | DirtyFlag$1.uv);
    }
  }, {
    key: "pixelsPerUnit",
    get: function get4() {
      return this._pixelsPerUnit;
    },
    set: function set4(value) {
      if (this._pixelsPerUnit !== value) {
        this._pixelsPerUnit = value;
        this._setDirtyFlagTrue(DirtyFlag$1.positions);
      }
    }
  }]);
  return Sprite2;
}(RefObject);
Sprite._rectangleTriangles = [0, 2, 1, 2, 0, 3];
var DirtyFlag$1;
(function(DirtyFlag2) {
  DirtyFlag2[DirtyFlag2["positions"] = 1] = "positions";
  DirtyFlag2[DirtyFlag2["uv"] = 2] = "uv";
  DirtyFlag2[DirtyFlag2["all"] = 3] = "all";
})(DirtyFlag$1 || (DirtyFlag$1 = {}));
var _class$1;
var _descriptor$1;
var _descriptor2$1;
var _descriptor3$1;
var _descriptor4$1;
var _descriptor5$1;
var _descriptor6$1;
var _descriptor7$1;
var _descriptor8;
var _descriptor9;
var _descriptor10;
var _descriptor11;
var _descriptor12;
var _descriptor13;
var _class2$1;
var _temp$1;
var SpriteRenderer = (_class$1 = (_temp$1 = _class2$1 = function(_Renderer) {
  _inheritsLoose(SpriteRenderer2, _Renderer);
  function SpriteRenderer2(entity) {
    var _this;
    _this = _Renderer.call(this, entity) || this;
    _initializerDefineProperty(_this, "_customLocalBounds", _descriptor$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_customRootEntity", _descriptor2$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_positions", _descriptor3$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_sprite", _descriptor4$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_color", _descriptor5$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_flipX", _descriptor6$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_flipY", _descriptor7$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_cacheFlipX", _descriptor8, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_cacheFlipY", _descriptor9, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_dirtyFlag", _descriptor10, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_isWorldMatrixDirty", _descriptor11, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_maskInteraction", _descriptor12, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_maskLayer", _descriptor13, _assertThisInitialized(_this));
    _this._isWorldMatrixDirty = entity.transform.registerWorldChangeFlag();
    _this.setMaterial(_this._engine._spriteDefaultMaterial);
    return _this;
  }
  var _proto = SpriteRenderer2.prototype;
  _proto._render = function _render(camera) {
    var sprite = this.sprite;
    if (!sprite) {
      return;
    }
    var texture = sprite.texture;
    if (!texture) {
      return;
    }
    var _positions = this._positions;
    var transform = this.entity.transform;
    var localDirty = sprite._updateMeshData();
    if (this._isWorldMatrixDirty.flag || localDirty || this._isContainDirtyFlag(DirtyFlag.Sprite)) {
      var localPositions = sprite._positions;
      var localVertexPos = SpriteRenderer2._tempVec3;
      var worldMatrix = transform.worldMatrix;
      var flipX = this.flipX, flipY = this.flipY;
      for (var i = 0, n = _positions.length; i < n; i++) {
        var curVertexPos = localPositions[i];
        localVertexPos.setValue(flipX ? -curVertexPos.x : curVertexPos.x, flipY ? -curVertexPos.y : curVertexPos.y, 0);
        Vector3.transformToVec3(localVertexPos, worldMatrix, _positions[i]);
      }
      this._setDirtyFlagFalse(DirtyFlag.Flip);
      this._setDirtyFlagFalse(DirtyFlag.Sprite);
      this._isWorldMatrixDirty.flag = false;
      this._cacheFlipX = flipX;
      this._cacheFlipY = flipY;
    } else if (this._isContainDirtyFlag(DirtyFlag.Flip)) {
      var _flipX = this.flipX, _flipY = this.flipY;
      var flipXChange = this._cacheFlipX !== _flipX;
      var flipYChange = this._cacheFlipY !== _flipY;
      if (flipXChange || flipYChange) {
        var _transform$worldPosit = transform.worldPosition, x = _transform$worldPosit.x, y = _transform$worldPosit.y;
        for (var _i = 0, _n = _positions.length; _i < _n; _i++) {
          var curPos = _positions[_i];
          if (flipXChange) {
            curPos.x = x * 2 - curPos.x;
          }
          if (flipYChange) {
            curPos.y = y * 2 - curPos.y;
          }
        }
      }
      this._setDirtyFlagFalse(DirtyFlag.Flip);
      this._cacheFlipX = _flipX;
      this._cacheFlipY = _flipY;
    }
    if (this._isContainDirtyFlag(DirtyFlag.MaskInteraction)) {
      this._updateStencilState();
      this._setDirtyFlagFalse(DirtyFlag.MaskInteraction);
    }
    this.shaderData.setTexture(SpriteRenderer2._textureProperty, texture);
    var material = this.getMaterial();
    var spriteElementPool = this._engine._spriteElementPool;
    var spriteElement = spriteElementPool.getFromPool();
    spriteElement.setValue(this, _positions, sprite._uv, sprite._triangles, this.color, material, camera);
    camera._renderPipeline.pushPrimitive(spriteElement);
  };
  _proto._onDestroy = function _onDestroy() {
    this._isWorldMatrixDirty.destroy();
    _Renderer.prototype._onDestroy.call(this);
  };
  _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
    return (this._dirtyFlag & type) != 0;
  };
  _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
    this._dirtyFlag |= type;
  };
  _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
    this._dirtyFlag &= ~type;
  };
  _proto._updateBounds = function _updateBounds(worldBounds) {
    var sprite = this._sprite;
    if (sprite) {
      if (this._customLocalBounds && this._customRootEntity) {
        var worldMatrix = this._customRootEntity.transform.worldMatrix;
        BoundingBox.transform(this._customLocalBounds, worldMatrix, worldBounds);
      } else {
        var localBounds = sprite.bounds;
        var _worldMatrix = this._entity.transform.worldMatrix;
        BoundingBox.transform(localBounds, _worldMatrix, worldBounds);
      }
    } else {
      worldBounds.min.setValue(0, 0, 0);
      worldBounds.max.setValue(0, 0, 0);
    }
  };
  _proto._updateStencilState = function _updateStencilState() {
    var material = this.getInstanceMaterial();
    var stencilState = material.renderState.stencilState;
    var maskInteraction = this._maskInteraction;
    if (maskInteraction === SpriteMaskInteraction.None) {
      stencilState.enabled = false;
      stencilState.writeMask = 255;
      stencilState.referenceValue = 0;
      stencilState.compareFunctionFront = stencilState.compareFunctionBack = CompareFunction.Always;
    } else {
      stencilState.enabled = true;
      stencilState.writeMask = 0;
      stencilState.referenceValue = 1;
      var compare = maskInteraction === SpriteMaskInteraction.VisibleInsideMask ? CompareFunction.LessEqual : CompareFunction.Greater;
      stencilState.compareFunctionFront = compare;
      stencilState.compareFunctionBack = compare;
    }
  };
  _createClass(SpriteRenderer2, [{
    key: "sprite",
    get: function get4() {
      return this._sprite;
    },
    set: function set4(value) {
      if (this._sprite !== value) {
        this._sprite = value;
        this._setDirtyFlagTrue(DirtyFlag.Sprite);
      }
    }
  }, {
    key: "color",
    get: function get4() {
      return this._color;
    },
    set: function set4(value) {
      if (this._color !== value) {
        value.cloneTo(this._color);
      }
    }
  }, {
    key: "flipX",
    get: function get4() {
      return this._flipX;
    },
    set: function set4(value) {
      if (this._flipX !== value) {
        this._flipX = value;
        this._setDirtyFlagTrue(DirtyFlag.Flip);
      }
    }
  }, {
    key: "flipY",
    get: function get4() {
      return this._flipY;
    },
    set: function set4(value) {
      if (this._flipY !== value) {
        this._flipY = value;
        this._setDirtyFlagTrue(DirtyFlag.Flip);
      }
    }
  }, {
    key: "maskInteraction",
    get: function get4() {
      return this._maskInteraction;
    },
    set: function set4(value) {
      if (this._maskInteraction !== value) {
        this._maskInteraction = value;
        this._setDirtyFlagTrue(DirtyFlag.MaskInteraction);
      }
    }
  }, {
    key: "maskLayer",
    get: function get4() {
      return this._maskLayer;
    },
    set: function set4(value) {
      this._maskLayer = value;
    }
  }]);
  return SpriteRenderer2;
}(Renderer), _class2$1._textureProperty = Shader.getPropertyByName("u_spriteTexture"), _class2$1._tempVec3 = new Vector3(), _temp$1), _descriptor$1 = _applyDecoratedDescriptor(_class$1.prototype, "_customLocalBounds", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer54() {
    return null;
  }
}), _descriptor2$1 = _applyDecoratedDescriptor(_class$1.prototype, "_customRootEntity", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer55() {
    return null;
  }
}), _descriptor3$1 = _applyDecoratedDescriptor(_class$1.prototype, "_positions", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer56() {
    return [new Vector3(), new Vector3(), new Vector3(), new Vector3()];
  }
}), _descriptor4$1 = _applyDecoratedDescriptor(_class$1.prototype, "_sprite", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer57() {
    return null;
  }
}), _descriptor5$1 = _applyDecoratedDescriptor(_class$1.prototype, "_color", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer58() {
    return new Color(1, 1, 1, 1);
  }
}), _descriptor6$1 = _applyDecoratedDescriptor(_class$1.prototype, "_flipX", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer59() {
    return false;
  }
}), _descriptor7$1 = _applyDecoratedDescriptor(_class$1.prototype, "_flipY", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer60() {
    return false;
  }
}), _descriptor8 = _applyDecoratedDescriptor(_class$1.prototype, "_cacheFlipX", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer61() {
    return false;
  }
}), _descriptor9 = _applyDecoratedDescriptor(_class$1.prototype, "_cacheFlipY", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer62() {
    return false;
  }
}), _descriptor10 = _applyDecoratedDescriptor(_class$1.prototype, "_dirtyFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer63() {
    return DirtyFlag.All;
  }
}), _descriptor11 = _applyDecoratedDescriptor(_class$1.prototype, "_isWorldMatrixDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor12 = _applyDecoratedDescriptor(_class$1.prototype, "_maskInteraction", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer64() {
    return SpriteMaskInteraction.None;
  }
}), _descriptor13 = _applyDecoratedDescriptor(_class$1.prototype, "_maskLayer", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer65() {
    return SpriteMaskLayer.Layer0;
  }
}), _class$1);
var DirtyFlag;
(function(DirtyFlag2) {
  DirtyFlag2[DirtyFlag2["Flip"] = 1] = "Flip";
  DirtyFlag2[DirtyFlag2["Sprite"] = 2] = "Sprite";
  DirtyFlag2[DirtyFlag2["All"] = 3] = "All";
  DirtyFlag2[DirtyFlag2["MaskInteraction"] = 4] = "MaskInteraction";
})(DirtyFlag || (DirtyFlag = {}));
var AnimationClipCurveBinding = function AnimationClipCurveBinding2() {
  this.relativePath = void 0;
  this.type = void 0;
  this.property = void 0;
  this.curve = void 0;
};
var AnimationProperty;
(function(AnimationProperty2) {
  AnimationProperty2[AnimationProperty2["Position"] = 0] = "Position";
  AnimationProperty2[AnimationProperty2["Rotation"] = 1] = "Rotation";
  AnimationProperty2[AnimationProperty2["Scale"] = 2] = "Scale";
  AnimationProperty2[AnimationProperty2["BlendShapeWeights"] = 3] = "BlendShapeWeights";
})(AnimationProperty || (AnimationProperty = {}));
var Motion = function Motion2() {
};
var AnimationClip = function(_Motion) {
  _inheritsLoose(AnimationClip2, _Motion);
  function AnimationClip2(name) {
    var _this;
    _this = _Motion.call(this) || this;
    _this.name = name;
    _this._curveBindings = [];
    _this._length = 0;
    _this._events = [];
    return _this;
  }
  var _proto = AnimationClip2.prototype;
  _proto.addEvent = function addEvent(event) {
    this._events.push(event);
    this._events.sort(function(a, b) {
      return a.time - b.time;
    });
  };
  _proto.clearEvents = function clearEvents() {
    this._events.length = 0;
  };
  _proto.addCurveBinding = function addCurveBinding(relativePath, type, propertyName, curve) {
    var property;
    switch (propertyName) {
      case "position":
        property = AnimationProperty.Position;
        break;
      case "rotation":
        property = AnimationProperty.Rotation;
        break;
      case "scale":
        property = AnimationProperty.Scale;
        break;
      case "blendShapeWeights":
        property = AnimationProperty.BlendShapeWeights;
        break;
    }
    var curveBinding = new AnimationClipCurveBinding();
    curveBinding.relativePath = relativePath;
    curveBinding.type = type;
    curveBinding.property = property;
    curveBinding.curve = curve;
    if (curve.length > this._length) {
      this._length = curve.length;
    }
    this._curveBindings.push(curveBinding);
  };
  _proto.clearCurveBindings = function clearCurveBindings() {
    this._curveBindings.length = 0;
    this._length = 0;
  };
  _proto._sampleAnimation = function _sampleAnimation(entity, time) {
    var length2 = this._curveBindings.length;
    for (var i = length2 - 1; i >= 0; i--) {
      var curveData = this._curveBindings[i];
      var curve = curveData.curve, property = curveData.property, relativePath = curveData.relativePath, type = curveData.type;
      var val = curve.evaluate(time);
      var target = entity.findByName(relativePath);
      var transform = target.transform;
      if (type === Transform) {
        switch (property) {
          case AnimationProperty.Position:
            transform.position = val;
            break;
          case AnimationProperty.Rotation:
            transform.rotationQuaternion = val;
            break;
          case AnimationProperty.Scale:
            transform.scale = val;
            break;
        }
      }
    }
  };
  _createClass(AnimationClip2, [{
    key: "events",
    get: function get4() {
      return this._events;
    }
  }, {
    key: "curveBindings",
    get: function get4() {
      return this._curveBindings;
    }
  }, {
    key: "length",
    get: function get4() {
      return this._length;
    }
  }]);
  return AnimationClip2;
}(Motion);
var AnimatorUtils = function() {
  function AnimatorUtils2() {
  }
  AnimatorUtils2.scaleWeight = function scaleWeight(s, w, out) {
    var sX = s.x;
    var sY = s.y;
    var sZ = s.z;
    out.x = sX > 0 ? Math.pow(Math.abs(sX), w) : -Math.pow(Math.abs(sX), w);
    out.y = sY > 0 ? Math.pow(Math.abs(sY), w) : -Math.pow(Math.abs(sY), w);
    out.z = sZ > 0 ? Math.pow(Math.abs(sZ), w) : -Math.pow(Math.abs(sZ), w);
  };
  AnimatorUtils2.scaleBlend = function scaleBlend(sa, sb, w, out) {
    var saw = AnimatorUtils2._tempVector30;
    var sbw = AnimatorUtils2._tempVector31;
    AnimatorUtils2.scaleWeight(sa, 1 - w, saw);
    AnimatorUtils2.scaleWeight(sb, w, sbw);
    var sng = w > 0.5 ? sb : sa;
    out.x = sng.x > 0 ? Math.abs(saw.x * sbw.x) : -Math.abs(saw.x * sbw.x);
    out.y = sng.y > 0 ? Math.abs(saw.y * sbw.y) : -Math.abs(saw.y * sbw.y);
    out.z = sng.z > 0 ? Math.abs(saw.z * sbw.z) : -Math.abs(saw.z * sbw.z);
  };
  AnimatorUtils2.quaternionWeight = function quaternionWeight(s, w, out) {
    out.x = s.x * w;
    out.y = s.y * w;
    out.z = s.z * w;
    out.w = s.w;
  };
  return AnimatorUtils2;
}();
AnimatorUtils._tempVector30 = new Vector3();
AnimatorUtils._tempVector31 = new Vector3();
var AnimatorLayerBlendingMode;
(function(AnimatorLayerBlendingMode2) {
  AnimatorLayerBlendingMode2[AnimatorLayerBlendingMode2["Override"] = 0] = "Override";
  AnimatorLayerBlendingMode2[AnimatorLayerBlendingMode2["Additive"] = 1] = "Additive";
})(AnimatorLayerBlendingMode || (AnimatorLayerBlendingMode = {}));
var LayerState;
(function(LayerState2) {
  LayerState2[LayerState2["Standby"] = 0] = "Standby";
  LayerState2[LayerState2["Playing"] = 1] = "Playing";
  LayerState2[LayerState2["CrossFading"] = 2] = "CrossFading";
  LayerState2[LayerState2["FixedCrossFading"] = 3] = "FixedCrossFading";
})(LayerState || (LayerState = {}));
var AnimationCurveOwner = function() {
  function AnimationCurveOwner2(target, type, property) {
    this.crossCurveMark = 0;
    this.crossCurveIndex = void 0;
    this.target = void 0;
    this.type = void 0;
    this.property = void 0;
    this.component = void 0;
    this.defaultValue = void 0;
    this.fixedPoseValue = void 0;
    this.target = target;
    this.type = type;
    this.property = property;
    switch (property) {
      case AnimationProperty.Position:
        this.defaultValue = new Vector3();
        this.fixedPoseValue = new Vector3();
        this.component = target.transform;
        break;
      case AnimationProperty.Rotation:
        this.defaultValue = new Quaternion();
        this.fixedPoseValue = new Quaternion();
        this.component = target.transform;
        break;
      case AnimationProperty.Scale:
        this.defaultValue = new Vector3();
        this.fixedPoseValue = new Vector3();
        this.component = target.transform;
        break;
      case AnimationProperty.BlendShapeWeights:
        this.defaultValue = new Float32Array(4);
        this.fixedPoseValue = new Float32Array(4);
        this.component = target.getComponent(SkinnedMeshRenderer);
        break;
    }
  }
  var _proto = AnimationCurveOwner2.prototype;
  _proto.saveDefaultValue = function saveDefaultValue() {
    switch (this.property) {
      case AnimationProperty.Position:
        this.target.transform.position.cloneTo(this.defaultValue);
        break;
      case AnimationProperty.Rotation:
        this.target.transform.rotationQuaternion.cloneTo(this.defaultValue);
        break;
      case AnimationProperty.Scale:
        this.target.transform.scale.cloneTo(this.defaultValue);
        break;
    }
  };
  _proto.saveFixedPoseValue = function saveFixedPoseValue() {
    switch (this.property) {
      case AnimationProperty.Position:
        this.target.transform.position.cloneTo(this.fixedPoseValue);
        break;
      case AnimationProperty.Rotation:
        this.target.transform.rotationQuaternion.cloneTo(this.fixedPoseValue);
        break;
      case AnimationProperty.Scale:
        this.target.transform.scale.cloneTo(this.fixedPoseValue);
        break;
    }
  };
  return AnimationCurveOwner2;
}();
var AnimationEventHandler = function AnimationEventHandler2() {
  this.event = void 0;
  this.handlers = [];
};
var AnimatorStateTransition = function AnimatorStateTransition2() {
  this.duration = 0;
  this.offset = 0;
  this.exitTime = 1;
  this.destinationState = void 0;
};
var WrapMode;
(function(WrapMode2) {
  WrapMode2[WrapMode2["Once"] = 0] = "Once";
  WrapMode2[WrapMode2["Loop"] = 1] = "Loop";
})(WrapMode || (WrapMode = {}));
var AnimatorStatePlayData = function() {
  function AnimatorStatePlayData2() {
    this.state = void 0;
    this.stateData = void 0;
    this.frameTime = void 0;
    this.finished = void 0;
    this.clipTime = void 0;
    this.currentEventIndex = void 0;
  }
  var _proto = AnimatorStatePlayData2.prototype;
  _proto.reset = function reset(state, stateData, offsetFrameTime) {
    this.state = state;
    this.frameTime = offsetFrameTime;
    this.stateData = stateData;
    this.finished = false;
    this.clipTime = this.state.clipStartTime;
    this.currentEventIndex = 0;
  };
  _proto.update = function update() {
    var state = this.state;
    var time = this.frameTime;
    var duration = state.clipEndTime - state.clipStartTime;
    if (time > duration) {
      if (state.wrapMode === WrapMode.Loop) {
        time = time % duration;
      } else {
        time = duration;
        this.finished = true;
      }
    }
    this.clipTime = time + this.state.clipStartTime;
  };
  return AnimatorStatePlayData2;
}();
var AnimatorLayerData = function() {
  function AnimatorLayerData2() {
    this.animatorStateDataMap = {};
    this.srcPlayData = new AnimatorStatePlayData();
    this.destPlayData = new AnimatorStatePlayData();
    this.layerState = LayerState.Standby;
    this.crossCurveMark = 0;
    this.manuallyTransition = new AnimatorStateTransition();
    this.crossFadeTransition = void 0;
  }
  var _proto = AnimatorLayerData2.prototype;
  _proto.switchPlayData = function switchPlayData() {
    var srcPlayData = this.destPlayData;
    var switchTemp = this.srcPlayData;
    this.srcPlayData = srcPlayData;
    this.destPlayData = switchTemp;
  };
  return AnimatorLayerData2;
}();
var AnimatorStateData = function AnimatorStateData2() {
  this.curveOwners = [];
  this.eventHandlers = [];
};
var AnimatorStateInfo = function AnimatorStateInfo2() {
  this.layerIndex = void 0;
  this.state = void 0;
};
var CrossCurveData = function CrossCurveData2() {
  this.curveOwner = void 0;
  this.srcCurveIndex = void 0;
  this.destCurveIndex = void 0;
};
var _class;
var _descriptor;
var _descriptor2;
var _descriptor3;
var _descriptor4;
var _descriptor5;
var _descriptor6;
var _descriptor7;
var _class2;
var _temp;
var Animator = (_class = (_temp = _class2 = function(_Component) {
  _inheritsLoose(Animator2, _Component);
  function Animator2(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _this._animatorController = void 0;
    _initializerDefineProperty(_this, "_speed", _descriptor, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_controllerUpdateFlag", _descriptor2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_animatorLayersData", _descriptor3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_crossCurveDataCollection", _descriptor4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_animationCurveOwners", _descriptor5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_crossCurveDataPool", _descriptor6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_animationEventHandlerPool", _descriptor7, _assertThisInitialized(_this));
    return _this;
  }
  var _proto = Animator2.prototype;
  _proto.play = function play(stateName, layerIndex, normalizedTimeOffset) {
    var _this$_controllerUpda;
    if (layerIndex === void 0) {
      layerIndex = -1;
    }
    if (normalizedTimeOffset === void 0) {
      normalizedTimeOffset = 0;
    }
    if ((_this$_controllerUpda = this._controllerUpdateFlag) !== null && _this$_controllerUpda !== void 0 && _this$_controllerUpda.flag) {
      this._clearPlayData();
    }
    var animatorInfo = this._getAnimatorStateInfo(stateName, layerIndex, Animator2._animatorInfo);
    var state = animatorInfo.state;
    if (!state) {
      return;
    }
    if (!state.clip) {
      console.warn("The state named " + stateName + " has no AnimationClip data.");
      return;
    }
    var animatorLayerData = this._getAnimatorLayerData(animatorInfo.layerIndex);
    var srcPlayData = animatorLayerData.srcPlayData;
    var curState = srcPlayData.state;
    if (curState && curState !== state) {
      this._revertDefaultValue(srcPlayData);
    }
    var animatorStateData = this._getAnimatorStateData(stateName, state, animatorLayerData);
    animatorLayerData.layerState = LayerState.Playing;
    srcPlayData.reset(state, animatorStateData, state._getDuration() * normalizedTimeOffset);
    this._saveDefaultValues(animatorStateData);
  };
  _proto.crossFade = function crossFade(stateName, normalizedTransitionDuration, layerIndex, normalizedTimeOffset) {
    var _this$_controllerUpda2;
    if (layerIndex === void 0) {
      layerIndex = -1;
    }
    if (normalizedTimeOffset === void 0) {
      normalizedTimeOffset = 0;
    }
    if ((_this$_controllerUpda2 = this._controllerUpdateFlag) !== null && _this$_controllerUpda2 !== void 0 && _this$_controllerUpda2.flag) {
      this._clearPlayData();
    }
    var _this$_getAnimatorSta = this._getAnimatorStateInfo(stateName, layerIndex, Animator2._animatorInfo), state = _this$_getAnimatorSta.state;
    var _this$_getAnimatorLay = this._getAnimatorLayerData(layerIndex), manuallyTransition = _this$_getAnimatorLay.manuallyTransition;
    manuallyTransition.duration = normalizedTransitionDuration;
    manuallyTransition.offset = normalizedTimeOffset;
    manuallyTransition.destinationState = state;
    this._crossFadeByTransition(manuallyTransition, layerIndex);
  };
  _proto.update = function update(deltaTime) {
    var _this$_controllerUpda3;
    if (this.speed === 0) {
      return;
    }
    var animatorController = this._animatorController;
    if (!animatorController) {
      return;
    }
    if ((_this$_controllerUpda3 = this._controllerUpdateFlag) !== null && _this$_controllerUpda3 !== void 0 && _this$_controllerUpda3.flag) {
      return;
    }
    deltaTime *= this.speed;
    for (var i = 0, n = animatorController.layers.length; i < n; i++) {
      var animatorLayerData = this._getAnimatorLayerData(i);
      if (animatorLayerData.layerState === LayerState.Standby) {
        continue;
      }
      this._updateLayer(i, i === 0, deltaTime / 1e3);
    }
  };
  _proto._onEnable = function _onEnable() {
    this.engine._componentsManager.addOnUpdateAnimations(this);
  };
  _proto._onDisable = function _onDisable() {
    this.engine._componentsManager.removeOnUpdateAnimations(this);
  };
  _proto._getAnimatorStateInfo = function _getAnimatorStateInfo(stateName, layerIndex, out) {
    var state = null;
    var animatorController = this._animatorController;
    if (animatorController) {
      var layers = animatorController.layers;
      if (layerIndex === -1) {
        for (var i = 0, n = layers.length; i < n; i++) {
          state = layers[i].stateMachine.findStateByName(stateName);
          if (state) {
            layerIndex = i;
            break;
          }
        }
      } else {
        state = layers[layerIndex].stateMachine.findStateByName(stateName);
      }
    }
    out.layerIndex = layerIndex;
    out.state = state;
    return out;
  };
  _proto._saveDefaultValues = function _saveDefaultValues(stateData) {
    var curveOwners = stateData.curveOwners;
    for (var i = curveOwners.length - 1; i >= 0; i--) {
      curveOwners[i].saveDefaultValue();
    }
  };
  _proto._getAnimatorStateData = function _getAnimatorStateData(stateName, animatorState, animatorLayerData) {
    var animatorStateDataCollection = animatorLayerData.animatorStateDataMap;
    var animatorStateData = animatorStateDataCollection[stateName];
    if (!animatorStateData) {
      animatorStateData = new AnimatorStateData();
      animatorStateDataCollection[stateName] = animatorStateData;
      this._saveAnimatorStateData(animatorState, animatorStateData);
      this._saveAnimatorEventHandlers(animatorState, animatorStateData);
    }
    return animatorStateData;
  };
  _proto._saveAnimatorStateData = function _saveAnimatorStateData(animatorState, animatorStateData) {
    var entity = this.entity, animationCureOwners = this._animationCurveOwners;
    var curveOwners = animatorStateData.curveOwners;
    var curves = animatorState.clip._curveBindings;
    for (var i = curves.length - 1; i >= 0; i--) {
      var curve = curves[i];
      var targetEntity = curve.relativePath === "" ? entity : entity.findByPath(curve.relativePath);
      var property = curve.property;
      var instanceId = targetEntity.instanceId;
      var propertyOwners = animationCureOwners[instanceId] || (animationCureOwners[instanceId] = []);
      curveOwners[i] = propertyOwners[property] || (propertyOwners[property] = new AnimationCurveOwner(targetEntity, curve.type, property));
    }
  };
  _proto._saveAnimatorEventHandlers = function _saveAnimatorEventHandlers(state, animatorStateData) {
    var eventHandlerPool = this._animationEventHandlerPool;
    var scripts = this._entity._scripts;
    var scriptCount = scripts.length;
    var eventHandlers = animatorStateData.eventHandlers;
    var events = state.clip.events;
    eventHandlerPool.resetPool();
    eventHandlers.length = 0;
    for (var i = 0, n = events.length; i < n; i++) {
      var event = events[i];
      var eventHandler = eventHandlerPool.getFromPool();
      var funcName = event.functionName;
      var handlers = eventHandler.handlers;
      eventHandler.event = event;
      handlers.length = 0;
      for (var j = scriptCount - 1; j >= 0; j--) {
        var handler = scripts.get(j)[funcName];
        handler && handlers.push(handler);
      }
      eventHandlers.push(eventHandler);
    }
  };
  _proto._clearCrossData = function _clearCrossData(animatorLayerData) {
    animatorLayerData.crossCurveMark++;
    this._crossCurveDataCollection.length = 0;
    this._crossCurveDataPool.resetPool();
  };
  _proto._addCrossCurveData = function _addCrossCurveData(crossCurveData, owner, curCurveIndex, nextCurveIndex) {
    var dataItem = this._crossCurveDataPool.getFromPool();
    dataItem.curveOwner = owner;
    dataItem.srcCurveIndex = curCurveIndex;
    dataItem.destCurveIndex = nextCurveIndex;
    crossCurveData.push(dataItem);
  };
  _proto._prepareCrossFading = function _prepareCrossFading(animatorLayerData) {
    var crossCurveData = this._crossCurveDataCollection;
    var crossCurveMark = animatorLayerData.crossCurveMark;
    this._prepareSrcCrossData(crossCurveData, animatorLayerData.srcPlayData, crossCurveMark, false);
    this._prepareDestCrossData(crossCurveData, animatorLayerData.destPlayData, crossCurveMark, false);
  };
  _proto._prepareStandbyCrossFading = function _prepareStandbyCrossFading(animatorLayerData) {
    var crossCurveData = this._crossCurveDataCollection;
    var srcPlayData = animatorLayerData.srcPlayData, crossCurveMark = animatorLayerData.crossCurveMark;
    srcPlayData && this._prepareSrcCrossData(crossCurveData, srcPlayData, crossCurveMark, true);
    this._prepareDestCrossData(crossCurveData, animatorLayerData.destPlayData, crossCurveMark, true);
  };
  _proto._prepareFixedPoseCrossFading = function _prepareFixedPoseCrossFading(animatorLayerData) {
    var crossCurveData = this._crossCurveDataCollection;
    for (var i = crossCurveData.length - 1; i >= 0; i--) {
      var item = crossCurveData[i];
      item.curveOwner.saveFixedPoseValue();
      item.destCurveIndex = -1;
    }
    this._prepareDestCrossData(crossCurveData, animatorLayerData.destPlayData, animatorLayerData.crossCurveMark, true);
  };
  _proto._prepareSrcCrossData = function _prepareSrcCrossData(crossCurveData, srcPlayData, crossCurveMark, saveFixed) {
    var curveOwners = srcPlayData.stateData.curveOwners;
    for (var i = curveOwners.length - 1; i >= 0; i--) {
      var owner = curveOwners[i];
      owner.crossCurveMark = crossCurveMark;
      owner.crossCurveIndex = crossCurveData.length;
      saveFixed && owner.saveFixedPoseValue();
      this._addCrossCurveData(crossCurveData, owner, i, -1);
    }
  };
  _proto._prepareDestCrossData = function _prepareDestCrossData(crossCurveData, destPlayData, crossCurveMark, saveFixed) {
    var curveOwners = destPlayData.stateData.curveOwners;
    for (var i = curveOwners.length - 1; i >= 0; i--) {
      var owner = curveOwners[i];
      if (owner.crossCurveMark === crossCurveMark) {
        crossCurveData[owner.crossCurveIndex].destCurveIndex = i;
      } else {
        saveFixed && owner.saveFixedPoseValue();
        owner.crossCurveMark = crossCurveMark;
        owner.crossCurveIndex = crossCurveData.length;
        this._addCrossCurveData(crossCurveData, owner, -1, i);
      }
    }
  };
  _proto._evaluateCurve = function _evaluateCurve(property, curve, time, additive) {
    var value = curve.evaluate(time);
    if (additive) {
      var baseValue = curve.keys[0].value;
      switch (property) {
        case AnimationProperty.Position:
          var pos = Animator2._tempVector3;
          Vector3.subtract(value, baseValue, pos);
          return pos;
        case AnimationProperty.Rotation:
          var rot = Animator2._tempQuaternion;
          Quaternion.conjugate(baseValue, rot);
          Quaternion.multiply(rot, value, rot);
          return rot;
        case AnimationProperty.Scale:
          var scale = Animator2._tempVector3;
          Vector3.divide(value, baseValue, scale);
          return scale;
      }
    }
    return value;
  };
  _proto._getAnimatorLayerData = function _getAnimatorLayerData(layerIndex) {
    var animatorLayerData = this._animatorLayersData[layerIndex];
    animatorLayerData || (this._animatorLayersData[layerIndex] = animatorLayerData = new AnimatorLayerData());
    return animatorLayerData;
  };
  _proto._updateLayer = function _updateLayer(layerIndex, firstLayer, deltaTime) {
    var _this$_animatorContro = this._animatorController.layers[layerIndex], blendingMode = _this$_animatorContro.blendingMode, weight = _this$_animatorContro.weight;
    var animLayerData = this._animatorLayersData[layerIndex];
    var srcPlayData = animLayerData.srcPlayData, destPlayData = animLayerData.destPlayData, crossFadeTransitionInfo = animLayerData.crossFadeTransition;
    var layerAdditive = blendingMode === AnimatorLayerBlendingMode.Additive;
    var layerWeight = firstLayer ? 1 : weight;
    this._checkTransition(srcPlayData, crossFadeTransitionInfo, layerIndex);
    switch (animLayerData.layerState) {
      case LayerState.Playing:
        this._updatePlayingState(srcPlayData, animLayerData, layerWeight, deltaTime, layerAdditive);
        break;
      case LayerState.FixedCrossFading:
        this._updateCrossFadeFromPose(destPlayData, animLayerData, layerWeight, deltaTime, layerAdditive);
        break;
      case LayerState.CrossFading:
        this._updateCrossFade(srcPlayData, destPlayData, animLayerData, layerWeight, deltaTime, layerAdditive);
        break;
    }
  };
  _proto._updatePlayingState = function _updatePlayingState(playData, layerData, weight, delta, additive) {
    var _playData$stateData = playData.stateData, curveOwners = _playData$stateData.curveOwners, eventHandlers = _playData$stateData.eventHandlers;
    var state = playData.state;
    var curves = state.clip._curveBindings;
    var lastClipTime = playData.clipTime;
    playData.update();
    var clipTime = playData.clipTime;
    eventHandlers.length && this._fireAnimationEvents(playData, eventHandlers, lastClipTime, clipTime);
    for (var i = curves.length - 1; i >= 0; i--) {
      var owner = curveOwners[i];
      var value = this._evaluateCurve(owner.property, curves[i].curve, clipTime, additive);
      if (additive) {
        this._applyClipValueAdditive(owner, value, weight);
      } else {
        this._applyClipValue(owner, value, weight);
      }
    }
    playData.frameTime += state.speed * delta;
    if (playData.finished) {
      layerData.layerState = LayerState.Standby;
    }
  };
  _proto._updateCrossFade = function _updateCrossFade(srcPlayData, destPlayData, layerData, weight, delta, additive) {
    var crossCurveDataCollection = this._crossCurveDataCollection;
    var srcCurves = srcPlayData.state.clip._curveBindings;
    var destState = destPlayData.state;
    var destCurves = destState.clip._curveBindings;
    var crossWeight = destPlayData.frameTime / (destState._getDuration() * layerData.crossFadeTransition.duration);
    crossWeight >= 1 && (crossWeight = 1);
    srcPlayData.update();
    destPlayData.update();
    var srcClipTime = srcPlayData.clipTime;
    var destClipTime = destPlayData.clipTime;
    for (var i = crossCurveDataCollection.length - 1; i >= 0; i--) {
      var _crossCurveDataCollec = crossCurveDataCollection[i], curveOwner = _crossCurveDataCollec.curveOwner, srcCurveIndex = _crossCurveDataCollec.srcCurveIndex, destCurveIndex = _crossCurveDataCollec.destCurveIndex;
      var property = curveOwner.property, defaultValue = curveOwner.defaultValue;
      var srcValue = srcCurveIndex >= 0 ? this._evaluateCurve(property, srcCurves[srcCurveIndex].curve, srcClipTime, additive) : defaultValue;
      var destValue = destCurveIndex >= 0 ? this._evaluateCurve(property, destCurves[destCurveIndex].curve, destClipTime, additive) : defaultValue;
      this._applyCrossClipValue(curveOwner, srcValue, destValue, crossWeight, weight, additive);
    }
    this._updateCrossFadeData(layerData, crossWeight, delta, false);
  };
  _proto._updateCrossFadeFromPose = function _updateCrossFadeFromPose(destPlayData, layerData, weight, delta, additive) {
    var crossCurveDataCollection = this._crossCurveDataCollection;
    var destState = destPlayData.state;
    var curves = destState.clip._curveBindings;
    var crossWeight = destPlayData.frameTime / (destState._getDuration() * layerData.crossFadeTransition.duration);
    crossWeight >= 1 && (crossWeight = 1);
    destPlayData.update();
    var destClipTime = destPlayData.clipTime;
    for (var i = crossCurveDataCollection.length - 1; i >= 0; i--) {
      var _crossCurveDataCollec2 = crossCurveDataCollection[i], curveOwner = _crossCurveDataCollec2.curveOwner, destCurveIndex = _crossCurveDataCollec2.destCurveIndex;
      var destValue = destCurveIndex >= 0 ? this._evaluateCurve(curveOwner.property, curves[destCurveIndex].curve, destClipTime, additive) : curveOwner.defaultValue;
      this._applyCrossClipValue(curveOwner, curveOwner.fixedPoseValue, destValue, crossWeight, weight, additive);
    }
    this._updateCrossFadeData(layerData, crossWeight, delta, true);
  };
  _proto._updateCrossFadeData = function _updateCrossFadeData(layerData, crossWeight, delta, fixed) {
    var destPlayData = layerData.destPlayData;
    destPlayData.frameTime += destPlayData.state.speed * delta;
    if (crossWeight === 1) {
      if (destPlayData.finished) {
        layerData.layerState = LayerState.Standby;
      } else {
        layerData.layerState = LayerState.Playing;
      }
      layerData.switchPlayData();
    } else {
      fixed || (layerData.srcPlayData.frameTime += layerData.srcPlayData.state.speed * delta);
    }
  };
  _proto._applyCrossClipValue = function _applyCrossClipValue(owner, srcValue, destValue, crossWeight, layerWeight, additive) {
    var value;
    if (owner.type === Transform) {
      var transform = owner.target.transform;
      switch (owner.property) {
        case AnimationProperty.Position:
          Vector3.lerp(srcValue, destValue, crossWeight, Animator2._tempVector3);
          value = Animator2._tempVector3;
          break;
        case AnimationProperty.Rotation:
          Quaternion.slerp(srcValue, destValue, crossWeight, Animator2._tempQuaternion);
          value = Animator2._tempQuaternion;
          break;
        case AnimationProperty.Scale: {
          var scale = transform.scale;
          Vector3.lerp(srcValue, destValue, crossWeight, Animator2._tempVector3);
          transform.scale = scale;
          value = Animator2._tempVector3;
          break;
        }
      }
    }
    if (additive) {
      this._applyClipValueAdditive(owner, value, layerWeight);
    } else {
      this._applyClipValue(owner, value, layerWeight);
    }
  };
  _proto._applyClipValue = function _applyClipValue(owner, value, weight) {
    if (owner.type === Transform) {
      var transform = owner.target.transform;
      switch (owner.property) {
        case AnimationProperty.Position:
          if (weight === 1) {
            transform.position = value;
          } else {
            var position = transform.position;
            Vector3.lerp(position, value, weight, position);
            transform.position = position;
          }
          break;
        case AnimationProperty.Rotation:
          if (weight === 1) {
            transform.rotationQuaternion = value;
          } else {
            var rotationQuaternion = transform.rotationQuaternion;
            Quaternion.slerp(rotationQuaternion, value, weight, rotationQuaternion);
            transform.rotationQuaternion = rotationQuaternion;
          }
          break;
        case AnimationProperty.Scale:
          if (weight === 1) {
            transform.scale = value;
          } else {
            var scale = transform.scale;
            Vector3.lerp(scale, value, weight, scale);
            transform.scale = scale;
          }
          break;
      }
    } else if (owner.type === SkinnedMeshRenderer) {
      switch (owner.property) {
        case AnimationProperty.BlendShapeWeights:
          owner.component.blendShapeWeights = value;
          break;
      }
    }
  };
  _proto._applyClipValueAdditive = function _applyClipValueAdditive(owner, additiveValue, weight) {
    if (owner.type === Transform) {
      var transform = owner.target.transform;
      switch (owner.property) {
        case AnimationProperty.Position:
          var position = transform.position;
          position.x += additiveValue.x * weight;
          position.y += additiveValue.y * weight;
          position.z += additiveValue.z * weight;
          transform.position = position;
          break;
        case AnimationProperty.Rotation:
          var rotationQuaternion = transform.rotationQuaternion;
          AnimatorUtils.quaternionWeight(additiveValue, weight, additiveValue);
          additiveValue.normalize();
          rotationQuaternion.multiply(additiveValue);
          transform.rotationQuaternion = rotationQuaternion;
          break;
        case AnimationProperty.Scale:
          var scale = transform.scale;
          AnimatorUtils.scaleWeight(scale, weight, scale);
          Vector3.multiply(scale, additiveValue, scale);
          transform.scale = scale;
          break;
      }
    }
  };
  _proto._revertDefaultValue = function _revertDefaultValue(playData) {
    var clip = playData.state.clip;
    if (clip) {
      var curves = clip._curveBindings;
      var curveOwners = playData.stateData.curveOwners;
      for (var i = curves.length - 1; i >= 0; i--) {
        var owner = curveOwners[i];
        var transform = owner.target.transform;
        switch (owner.property) {
          case AnimationProperty.Position:
            transform.position = owner.defaultValue;
            break;
          case AnimationProperty.Rotation:
            transform.rotationQuaternion = owner.defaultValue;
            break;
          case AnimationProperty.Scale:
            transform.scale = owner.defaultValue;
            break;
        }
      }
    }
  };
  _proto._checkTransition = function _checkTransition(stateData, crossFadeTransition, layerIndex) {
    var state = stateData.state, clipTime = stateData.clipTime;
    var duration = state._getDuration();
    var transitions = state.transitions;
    for (var i = 0, n = transitions.length; i < n; ++i) {
      var transition = transitions[i];
      if (duration * transition.exitTime <= clipTime) {
        crossFadeTransition !== transition && this._crossFadeByTransition(transition, layerIndex);
      }
    }
  };
  _proto._crossFadeByTransition = function _crossFadeByTransition(transition, layerIndex) {
    var name = transition.destinationState.name;
    var animatorStateInfo = this._getAnimatorStateInfo(name, layerIndex, Animator2._animatorInfo);
    var crossState = animatorStateInfo.state;
    if (!crossState) {
      return;
    }
    if (!crossState.clip) {
      console.warn("The state named " + name + " has no AnimationClip data.");
      return;
    }
    var animatorLayerData = this._getAnimatorLayerData(animatorStateInfo.layerIndex);
    var layerState = animatorLayerData.layerState;
    var destPlayData = animatorLayerData.destPlayData;
    var animatorStateData = this._getAnimatorStateData(name, crossState, animatorLayerData);
    var duration = crossState._getDuration();
    var offset = duration * transition.offset;
    destPlayData.reset(crossState, animatorStateData, offset);
    this._saveDefaultValues(animatorStateData);
    switch (layerState) {
      case LayerState.Standby:
        animatorLayerData.layerState = LayerState.FixedCrossFading;
        this._clearCrossData(animatorLayerData);
        this._prepareStandbyCrossFading(animatorLayerData);
        break;
      case LayerState.Playing:
        animatorLayerData.layerState = LayerState.CrossFading;
        this._clearCrossData(animatorLayerData);
        this._prepareCrossFading(animatorLayerData);
        break;
      case LayerState.CrossFading:
        animatorLayerData.layerState = LayerState.FixedCrossFading;
        this._prepareFixedPoseCrossFading(animatorLayerData);
        break;
      case LayerState.FixedCrossFading:
        this._prepareFixedPoseCrossFading(animatorLayerData);
        break;
    }
    animatorLayerData.crossFadeTransition = transition;
  };
  _proto._fireAnimationEvents = function _fireAnimationEvents(playState, eventHandlers, lastClipTime, clipTime) {
    if (clipTime < lastClipTime) {
      this._fireSubAnimationEvents(playState, eventHandlers, lastClipTime, playState.state.clipEndTime);
      playState.currentEventIndex = 0;
      this._fireSubAnimationEvents(playState, eventHandlers, playState.state.clipStartTime, clipTime);
    } else {
      this._fireSubAnimationEvents(playState, eventHandlers, lastClipTime, clipTime);
    }
  };
  _proto._fireSubAnimationEvents = function _fireSubAnimationEvents(playState, eventHandlers, lastClipTime, curClipTime) {
    for (var i = playState.currentEventIndex, n = eventHandlers.length; i < n; i++) {
      var eventHandler = eventHandlers[i];
      var _eventHandler$event = eventHandler.event, time = _eventHandler$event.time, parameter = _eventHandler$event.parameter;
      if (time > curClipTime) {
        break;
      }
      var handlers = eventHandler.handlers;
      if (time >= lastClipTime) {
        for (var j = handlers.length - 1; j >= 0; j--) {
          handlers[j](parameter);
        }
        playState.currentEventIndex = i + 1;
      }
    }
  };
  _proto._clearPlayData = function _clearPlayData() {
    this._animatorLayersData.length = 0;
    this._crossCurveDataCollection.length = 0;
    this._animationCurveOwners.length = 0;
    this._controllerUpdateFlag.flag = false;
  };
  _createClass(Animator2, [{
    key: "speed",
    get: function get4() {
      return this._speed;
    },
    set: function set4(value) {
      this._speed = value;
    }
  }, {
    key: "animatorController",
    get: function get4() {
      return this._animatorController;
    },
    set: function set4(animatorController) {
      if (animatorController !== this._animatorController) {
        this._controllerUpdateFlag && this._controllerUpdateFlag.destroy();
        this._controllerUpdateFlag = animatorController && animatorController._registerChangeFlag();
        this._animatorController = animatorController;
      }
    }
  }]);
  return Animator2;
}(Component), _class2._tempVector3 = new Vector3(), _class2._tempQuaternion = new Quaternion(), _class2._animatorInfo = new AnimatorStateInfo(), _temp), _descriptor = _applyDecoratedDescriptor(_class.prototype, "_speed", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer66() {
    return 1;
  }
}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "_controllerUpdateFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, "_animatorLayersData", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer67() {
    return [];
  }
}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, "_crossCurveDataCollection", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer68() {
    return [];
  }
}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, "_animationCurveOwners", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer69() {
    return [];
  }
}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, "_crossCurveDataPool", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer70() {
    return new ClassPool(CrossCurveData);
  }
}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, "_animationEventHandlerPool", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer71() {
    return new ClassPool(AnimationEventHandler);
  }
}), _class);
var AnimatorController = function() {
  function AnimatorController2() {
    this._updateFlagManager = new UpdateFlagManager();
    this._layers = [];
    this._layersMap = {};
  }
  var _proto = AnimatorController2.prototype;
  _proto.findLayerByName = function findLayerByName(name) {
    return this._layersMap[name];
  };
  _proto.addLayer = function addLayer(layer) {
    this._layers.push(layer);
    this._layersMap[layer.name] = layer;
    this._distributeUpdateFlag();
  };
  _proto.removeLayer = function removeLayer(layerIndex) {
    var theLayer = this.layers[layerIndex];
    this._layers.splice(layerIndex, 1);
    delete this._layersMap[theLayer.name];
    this._distributeUpdateFlag();
  };
  _proto.clearLayers = function clearLayers() {
    this._layers.length = 0;
    for (var name in this._layersMap) {
      delete this._layersMap[name];
    }
    this._distributeUpdateFlag();
  };
  _proto._registerChangeFlag = function _registerChangeFlag() {
    return this._updateFlagManager.register();
  };
  _proto._distributeUpdateFlag = function _distributeUpdateFlag() {
    this._updateFlagManager.distribute();
  };
  _createClass(AnimatorController2, [{
    key: "layers",
    get: function get4() {
      return this._layers;
    }
  }]);
  return AnimatorController2;
}();
var AnimatorControllerLayer = function AnimatorControllerLayer2(name) {
  this.name = name;
  this.weight = 1;
  this.blendingMode = AnimatorLayerBlendingMode.Override;
  this.stateMachine = void 0;
};
var AnimatorState = function() {
  function AnimatorState2(name) {
    this.name = name;
    this.speed = 1;
    this.wrapMode = WrapMode.Loop;
    this._clipStartTime = 0;
    this._clipEndTime = Infinity;
    this._clip = void 0;
    this._transitions = [];
  }
  var _proto = AnimatorState2.prototype;
  _proto.addTransition = function addTransition(transition) {
    this._transitions.push(transition);
  };
  _proto.removeTransition = function removeTransition(transition) {
    var index = this._transitions.indexOf(transition);
    index !== -1 && this._transitions.splice(index, 1);
  };
  _proto.clearTransitions = function clearTransitions() {
    this._transitions.length = 0;
  };
  _proto._getDuration = function _getDuration() {
    return this._clipEndTime - this._clipStartTime;
  };
  _createClass(AnimatorState2, [{
    key: "transitions",
    get: function get4() {
      return this._transitions;
    }
  }, {
    key: "clip",
    get: function get4() {
      return this._clip;
    },
    set: function set4(clip) {
      this._clip = clip;
      this._clipEndTime = Math.min(this._clipEndTime, clip.length);
    }
  }, {
    key: "clipStartTime",
    get: function get4() {
      return this._clipStartTime;
    },
    set: function set4(time) {
      this._clipStartTime = time < 0 ? 0 : time;
    }
  }, {
    key: "clipEndTime",
    get: function get4() {
      return this._clipEndTime;
    },
    set: function set4(time) {
      var clip = this._clip;
      if (clip) {
        this._clipEndTime = Math.min(time, clip.length);
      }
    }
  }]);
  return AnimatorState2;
}();
var AnimatorStateMachine = function() {
  function AnimatorStateMachine2() {
    this.states = [];
    this._statesMap = {};
  }
  var _proto = AnimatorStateMachine2.prototype;
  _proto.addState = function addState(name) {
    var state = this.findStateByName(name);
    if (!state) {
      state = new AnimatorState(name);
      this.states.push(state);
      this._statesMap[name] = state;
    } else {
      console.warn("The state named " + name + " has existed.");
    }
    return state;
  };
  _proto.removeState = function removeState(state) {
    var name = state.name;
    var index = this.states.indexOf(state);
    if (index > -1) {
      this.states.splice(index, 1);
    }
    delete this._statesMap[name];
  };
  _proto.findStateByName = function findStateByName(name) {
    return this._statesMap[name];
  };
  _proto.makeUniqueStateName = function makeUniqueStateName(name) {
    var _statesMap = this._statesMap;
    var originName = name;
    var index = 0;
    while (_statesMap[name]) {
      name = originName + " " + index;
      index++;
    }
    return name;
  };
  return AnimatorStateMachine2;
}();
var InterpolableValueType;
(function(InterpolableValueType2) {
  InterpolableValueType2[InterpolableValueType2["Float"] = 0] = "Float";
  InterpolableValueType2[InterpolableValueType2["FloatArray"] = 1] = "FloatArray";
  InterpolableValueType2[InterpolableValueType2["Vector2"] = 2] = "Vector2";
  InterpolableValueType2[InterpolableValueType2["Vector3"] = 3] = "Vector3";
  InterpolableValueType2[InterpolableValueType2["Vector4"] = 4] = "Vector4";
  InterpolableValueType2[InterpolableValueType2["Quaternion"] = 5] = "Quaternion";
})(InterpolableValueType || (InterpolableValueType = {}));
var InterpolationType;
(function(InterpolationType2) {
  InterpolationType2[InterpolationType2["Linear"] = 0] = "Linear";
  InterpolationType2[InterpolationType2["CubicSpine"] = 1] = "CubicSpine";
  InterpolationType2[InterpolationType2["Step"] = 2] = "Step";
  InterpolationType2[InterpolationType2["Hermite"] = 3] = "Hermite";
})(InterpolationType || (InterpolationType = {}));
var AnimationCurve = function() {
  function AnimationCurve2() {
    this.keys = [];
    this.interpolation = void 0;
    this._valueSize = void 0;
    this._valueType = void 0;
    this._currentValue = void 0;
    this._length = 0;
    this._currentIndex = 0;
  }
  var _proto = AnimationCurve2.prototype;
  _proto.addKey = function addKey(key) {
    var time = key.time;
    this.keys.push(key);
    if (time > this._length) {
      this._length = time;
    }
    if (!this._valueSize) {
      if (typeof key.value == "number") {
        this._valueSize = 1;
        this._valueType = InterpolableValueType.Float;
        this._currentValue = 0;
      }
      if (key.value instanceof Vector2) {
        this._valueSize = 2;
        this._valueType = InterpolableValueType.Vector2;
        this._currentValue = new Vector2();
      }
      if (key.value instanceof Vector3) {
        this._valueSize = 3;
        this._valueType = InterpolableValueType.Vector3;
        this._currentValue = new Vector3();
      }
      if (key.value instanceof Vector4) {
        this._valueSize = 4;
        this._valueType = InterpolableValueType.Vector4;
        this._currentValue = new Vector4();
      }
      if (key.value instanceof Quaternion) {
        this._valueSize = 4;
        this._valueType = InterpolableValueType.Quaternion;
        this._currentValue = new Quaternion();
      }
      if (key.value instanceof Float32Array) {
        var size = key.value.length;
        this._valueSize = size;
        this._valueType = InterpolableValueType.FloatArray;
        this._currentValue = new Float32Array(size);
      }
    }
    this.keys.sort(function(a, b) {
      return a.time - b.time;
    });
  };
  _proto.evaluate = function evaluate(time) {
    var keys = this.keys, interpolation = this.interpolation;
    var length2 = this.keys.length;
    var curIndex = this._currentIndex;
    if (curIndex !== -1 && time < keys[curIndex].time) {
      curIndex = -1;
    }
    var nextIndex = curIndex + 1;
    while (nextIndex < length2) {
      if (time < keys[nextIndex].time) {
        break;
      }
      curIndex++;
      nextIndex++;
    }
    this._currentIndex = curIndex;
    var value;
    if (curIndex === -1) {
      value = keys[0].value;
    } else if (nextIndex === length2) {
      value = keys[curIndex].value;
    } else {
      var curFrameTime = keys[curIndex].time;
      var duration = keys[nextIndex].time - curFrameTime;
      var t = (time - curFrameTime) / duration;
      var dur = duration;
      switch (interpolation) {
        case InterpolationType.Linear:
          value = this._evaluateLinear(curIndex, nextIndex, t);
          break;
        case InterpolationType.Step:
          value = this._evaluateStep(nextIndex);
          break;
        case InterpolationType.CubicSpine:
        case InterpolationType.Hermite:
          value = this._evaluateHermite(curIndex, nextIndex, t, dur);
      }
    }
    return value;
  };
  _proto.moveKey = function moveKey(index, key) {
    this.keys[index] = key;
  };
  _proto.removeKey = function removeKey(index) {
    this.keys.splice(index, 1);
    var keys = this.keys;
    var count = this.keys.length;
    var newLength = 0;
    for (var i = count - 1; i >= 0; i--) {
      if (keys[i].time > length) {
        newLength = keys[i].time;
      }
    }
    this._length = newLength;
  };
  _proto._evaluateLinear = function _evaluateLinear(frameIndex, nextFrameIndex, t) {
    var _valueType = this._valueType, keys = this.keys;
    switch (_valueType) {
      case InterpolableValueType.Float:
        return keys[frameIndex].value * (1 - t) + keys[nextFrameIndex].value * t;
      case InterpolableValueType.FloatArray:
        var curValue = this._currentValue;
        var value = keys[frameIndex].value;
        var nextValue = keys[nextFrameIndex].value;
        for (var i = 0, n = value.length; i < n; i++) {
          curValue[i] = value[i] * (1 - t) + nextValue[i] * t;
        }
        return curValue;
      case InterpolableValueType.Vector2:
        Vector2.lerp(keys[frameIndex].value, keys[nextFrameIndex].value, t, this._currentValue);
        return this._currentValue;
      case InterpolableValueType.Vector3:
        Vector3.lerp(keys[frameIndex].value, keys[nextFrameIndex].value, t, this._currentValue);
        return this._currentValue;
      case InterpolableValueType.Quaternion:
        Quaternion.slerp(keys[frameIndex].value, keys[nextFrameIndex].value, t, this._currentValue);
        return this._currentValue;
    }
  };
  _proto._evaluateStep = function _evaluateStep(nextFrameIndex) {
    var _valueSize = this._valueSize, keys = this.keys;
    if (_valueSize === 1) {
      return keys[nextFrameIndex].value;
    } else {
      return keys[nextFrameIndex].value;
    }
  };
  _proto._evaluateHermite = function _evaluateHermite(frameIndex, nextFrameIndex, t, dur) {
    var _valueSize = this._valueSize, keys = this.keys;
    var curKey = keys[frameIndex];
    var nextKey = keys[nextFrameIndex];
    switch (_valueSize) {
      case 1: {
        var t0 = curKey.outTangent, t1 = nextKey.inTangent, p0 = curKey.value, p1 = nextKey.value;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
          var t2 = t * t;
          var t3 = t2 * t;
          var a = 2 * t3 - 3 * t2 + 1;
          var b = t3 - 2 * t2 + t;
          var c = t3 - t2;
          var d = -2 * t3 + 3 * t2;
          return a * p0 + b * t0 * dur + c * t1 * dur + d * p1;
        } else {
          return curKey.value;
        }
      }
      case 2: {
        var _p = curKey.value;
        var tan0 = curKey.outTangent;
        var _p2 = nextKey.value;
        var tan1 = nextKey.inTangent;
        var _t = t * t;
        var _t2 = _t * t;
        var _a = 2 * _t2 - 3 * _t + 1;
        var _b = _t2 - 2 * _t + t;
        var _c = _t2 - _t;
        var _d = -2 * _t2 + 3 * _t;
        var _t3 = tan0.x, _t4 = tan1.x;
        if (Number.isFinite(_t3) && Number.isFinite(_t4)) {
          this._currentValue.x = _a * _p.x + _b * _t3 * dur + _c * _t4 * dur + _d * _p2.x;
        } else {
          this._currentValue.x = _p.x;
        }
        _t3 = tan0.y, _t4 = tan1.y;
        if (Number.isFinite(_t3) && Number.isFinite(_t4))
          this._currentValue.y = _a * _p.y + _b * _t3 * dur + _c * _t4 * dur + _d * _p2.y;
        else {
          this._currentValue.y = _p.y;
        }
        return this._currentValue;
      }
      case 3: {
        var _p3 = curKey.value;
        var _tan = curKey.outTangent;
        var _p4 = nextKey.value;
        var _tan2 = nextKey.inTangent;
        var _t5 = t * t;
        var _t6 = _t5 * t;
        var _a2 = 2 * _t6 - 3 * _t5 + 1;
        var _b2 = _t6 - 2 * _t5 + t;
        var _c2 = _t6 - _t5;
        var _d2 = -2 * _t6 + 3 * _t5;
        var _t7 = _tan.x, _t8 = _tan2.x;
        if (Number.isFinite(_t7) && Number.isFinite(_t8)) {
          this._currentValue.x = _a2 * _p3.x + _b2 * _t7 * dur + _c2 * _t8 * dur + _d2 * _p4.x;
        } else {
          this._currentValue.x = _p3.x;
        }
        _t7 = _tan.y, _t8 = _tan2.y;
        if (Number.isFinite(_t7) && Number.isFinite(_t8)) {
          this._currentValue.y = _a2 * _p3.y + _b2 * _t7 * dur + _c2 * _t8 * dur + _d2 * _p4.y;
        } else {
          this._currentValue.y = _p3.y;
        }
        _t7 = _tan.z, _t8 = _tan2.z;
        if (Number.isFinite(_t7) && Number.isFinite(_t8)) {
          this._currentValue.z = _a2 * _p3.z + _b2 * _t7 * dur + _c2 * _t8 * dur + _d2 * _p4.z;
        } else {
          this._currentValue.z = _p3.z;
        }
        return this._currentValue;
      }
      case 4: {
        var _p5 = curKey.value;
        var _tan3 = curKey.outTangent;
        var _p6 = nextKey.value;
        var _tan4 = nextKey.inTangent;
        var _t9 = t * t;
        var _t10 = _t9 * t;
        var _a3 = 2 * _t10 - 3 * _t9 + 1;
        var _b3 = _t10 - 2 * _t9 + t;
        var _c3 = _t10 - _t9;
        var _d3 = -2 * _t10 + 3 * _t9;
        var _t11 = _tan3.x, _t12 = _tan4.x;
        if (Number.isFinite(_t11) && Number.isFinite(_t12)) {
          this._currentValue.x = _a3 * _p5.x + _b3 * _t11 * dur + _c3 * _t12 * dur + _d3 * _p6.x;
        } else {
          this._currentValue.x = _p5.x;
        }
        _t11 = _tan3.y, _t12 = _tan4.y;
        if (Number.isFinite(_t11) && Number.isFinite(_t12)) {
          this._currentValue.y = _a3 * _p5.y + _b3 * _t11 * dur + _c3 * _t12 * dur + _d3 * _p6.y;
        } else {
          this._currentValue.y = _p5.y;
        }
        _t11 = _tan3.z, _t12 = _tan4.z;
        if (Number.isFinite(_t11) && Number.isFinite(_t12)) {
          this._currentValue.z = _a3 * _p5.z + _b3 * _t11 * dur + _c3 * _t12 * dur + _d3 * _p6.z;
        } else {
          this._currentValue.z = _p5.z;
        }
        _t11 = _tan3.w, _t12 = _tan4.w;
        if (Number.isFinite(_t11) && Number.isFinite(_t12)) {
          this._currentValue.w = _a3 * _p5.w + _b3 * _t11 * dur + _c3 * _t12 * dur + _d3 * _p6.w;
        } else {
          this._currentValue.w = _p5.w;
        }
        return this._currentValue;
      }
    }
  };
  _createClass(AnimationCurve2, [{
    key: "length",
    get: function get4() {
      return this._length;
    }
  }]);
  return AnimationCurve2;
}();
var Keyframe = function Keyframe2() {
  this.time = void 0;
  this.value = void 0;
};
var InterpolableKeyframe = function(_Keyframe) {
  _inheritsLoose(InterpolableKeyframe2, _Keyframe);
  function InterpolableKeyframe2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Keyframe.call.apply(_Keyframe, [this].concat(args)) || this;
    _this.inTangent = void 0;
    _this.outTangent = void 0;
    return _this;
  }
  return InterpolableKeyframe2;
}(Keyframe);
var AnimationEvent = function AnimationEvent2() {
  this.time = void 0;
  this.functionName = void 0;
  this.parameter = void 0;
};
var AnimatorConditionMode;
(function(AnimatorConditionMode2) {
  AnimatorConditionMode2[AnimatorConditionMode2["If"] = 0] = "If";
  AnimatorConditionMode2[AnimatorConditionMode2["IfNot"] = 1] = "IfNot";
  AnimatorConditionMode2[AnimatorConditionMode2["Greater"] = 2] = "Greater";
  AnimatorConditionMode2[AnimatorConditionMode2["Less"] = 3] = "Less";
  AnimatorConditionMode2[AnimatorConditionMode2["Equals"] = 4] = "Equals";
  AnimatorConditionMode2[AnimatorConditionMode2["NotEquals"] = 5] = "NotEquals";
})(AnimatorConditionMode || (AnimatorConditionMode = {}));
var SkyBoxMaterial = function(_Material) {
  _inheritsLoose(SkyBoxMaterial2, _Material);
  function SkyBoxMaterial2(engine) {
    var _this;
    _this = _Material.call(this, engine, Shader.find("skybox")) || this;
    _this.renderState.rasterState.cullMode = CullMode.Off;
    _this.renderState.depthState.compareFunction = CompareFunction.LessEqual;
    return _this;
  }
  _createClass(SkyBoxMaterial2, [{
    key: "textureCubeMap",
    get: function get4() {
      return this.shaderData.getTexture("u_cube");
    },
    set: function set4(v) {
      this.shaderData.setTexture("u_cube", v);
    }
  }]);
  return SkyBoxMaterial2;
}(Material);
var DirtyFlagType;
(function(DirtyFlagType2) {
  DirtyFlagType2[DirtyFlagType2["Position"] = 1] = "Position";
  DirtyFlagType2[DirtyFlagType2["Velocity"] = 2] = "Velocity";
  DirtyFlagType2[DirtyFlagType2["Acceleration"] = 4] = "Acceleration";
  DirtyFlagType2[DirtyFlagType2["Color"] = 8] = "Color";
  DirtyFlagType2[DirtyFlagType2["Alpha"] = 16] = "Alpha";
  DirtyFlagType2[DirtyFlagType2["Size"] = 32] = "Size";
  DirtyFlagType2[DirtyFlagType2["StartAngle"] = 64] = "StartAngle";
  DirtyFlagType2[DirtyFlagType2["StartTime"] = 128] = "StartTime";
  DirtyFlagType2[DirtyFlagType2["LifeTime"] = 256] = "LifeTime";
  DirtyFlagType2[DirtyFlagType2["RotateVelocity"] = 512] = "RotateVelocity";
  DirtyFlagType2[DirtyFlagType2["Scale"] = 1024] = "Scale";
  DirtyFlagType2[DirtyFlagType2["Everything"] = 4294967295] = "Everything";
})(DirtyFlagType || (DirtyFlagType = {}));
var ParticleRendererBlendMode;
(function(ParticleRendererBlendMode2) {
  ParticleRendererBlendMode2[ParticleRendererBlendMode2["Transparent"] = 0] = "Transparent";
  ParticleRendererBlendMode2[ParticleRendererBlendMode2["Additive"] = 1] = "Additive";
})(ParticleRendererBlendMode || (ParticleRendererBlendMode = {}));
var ParticleRenderer = function(_MeshRenderer) {
  _inheritsLoose(ParticleRenderer2, _MeshRenderer);
  ParticleRenderer2._getRandom = function _getRandom() {
    return Math.random() - 0.5;
  };
  function ParticleRenderer2(props) {
    var _this;
    _this = _MeshRenderer.call(this, props) || this;
    _this._vertexStride = void 0;
    _this._vertices = void 0;
    _this._vertexBuffer = void 0;
    _this._maxCount = 1e3;
    _this._position = new Vector3();
    _this._positionRandomness = new Vector3();
    _this._positionArray = void 0;
    _this._velocity = new Vector3();
    _this._velocityRandomness = new Vector3();
    _this._acceleration = new Vector3();
    _this._accelerationRandomness = new Vector3();
    _this._color = new Color(1, 1, 1, 1);
    _this._colorRandomness = 0;
    _this._size = 1;
    _this._sizeRandomness = 0;
    _this._alpha = 1;
    _this._alphaRandomness = 0;
    _this._startAngle = 0;
    _this._startAngleRandomness = 0;
    _this._rotateVelocity = 0;
    _this._rotateVelocityRandomness = 0;
    _this._lifetime = 5;
    _this._startTimeRandomness = 0;
    _this._scale = 1;
    _this._isOnce = false;
    _this._onceTime = 0;
    _this._time = 0;
    _this._isInit = false;
    _this._isStart = false;
    _this._updateDirtyFlag = DirtyFlagType.Everything;
    _this._isRotateToVelocity = false;
    _this._isUseOriginColor = false;
    _this._isScaleByLifetime = false;
    _this._is2d = true;
    _this._isFadeIn = false;
    _this._isFadeOut = false;
    _this._playOnEnable = true;
    _this._blendMode = ParticleRendererBlendMode.Transparent;
    _this.spriteSheet = void 0;
    _this.setMaterial(_this._createMaterial());
    return _this;
  }
  var _proto = ParticleRenderer2.prototype;
  _proto.update = function update(deltaTime) {
    if (!this._isInit || !this._isStart) {
      return;
    }
    if (this._isOnce && this._time > this._onceTime) {
      return this.stop();
    }
    if (this._updateDirtyFlag) {
      this._updateBuffer();
      this._updateDirtyFlag = 0;
    }
    this._time += deltaTime / 1e3;
    this.shaderData.setFloat("u_time", this._time);
  };
  _proto._onEnable = function _onEnable() {
    _MeshRenderer.prototype._onEnable.call(this);
    if (this._playOnEnable) {
      this.start();
    }
  };
  _proto.start = function start() {
    this._isStart = true;
    this._time = 0;
  };
  _proto.stop = function stop() {
    this._isStart = false;
  };
  _proto._createMaterial = function _createMaterial() {
    var material = new Material(this.engine, Shader.find("particle-shader"));
    var renderState = material.renderState;
    var target = renderState.blendState.targetBlendState;
    target.enabled = true;
    target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
    target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
    target.sourceAlphaBlendFactor = BlendFactor.One;
    target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
    renderState.depthState.writeEnabled = false;
    material.renderQueueType = RenderQueueType.Transparent;
    this.isUseOriginColor = true;
    this.is2d = true;
    this.isFadeOut = true;
    return material;
  };
  _proto._createMesh = function _createMesh() {
    var mesh = new BufferMesh(this._entity.engine, "particleMesh");
    var vertexStride = 96;
    var vertexCount = this._maxCount * 4;
    var vertexFloatCount = vertexCount * vertexStride;
    var vertices = new Float32Array(vertexFloatCount);
    var indices = null;
    var useUint32 = false;
    if (vertexCount > ParticleRenderer2._uint16VertexLimit) {
      if (this.engine._hardwareRenderer.canIUse(GLCapabilityType.elementIndexUint)) {
        useUint32 = true;
        indices = new Uint32Array(6 * this._maxCount);
      } else {
        throw Error("The vertex count is over limit.");
      }
    } else {
      indices = new Uint16Array(6 * this._maxCount);
    }
    for (var i = 0, idx = 0; i < this._maxCount; ++i) {
      var startIndex = i * 4;
      indices[idx++] = startIndex;
      indices[idx++] = startIndex + 1;
      indices[idx++] = startIndex + 2;
      indices[idx++] = startIndex;
      indices[idx++] = startIndex + 2;
      indices[idx++] = startIndex + 3;
    }
    var vertexElements = [new VertexElement("a_position", 0, VertexElementFormat.Vector3, 0), new VertexElement("a_velocity", 12, VertexElementFormat.Vector3, 0), new VertexElement("a_acceleration", 24, VertexElementFormat.Vector3, 0), new VertexElement("a_color", 36, VertexElementFormat.Vector4, 0), new VertexElement("a_lifeAndSize", 52, VertexElementFormat.Vector4, 0), new VertexElement("a_rotation", 68, VertexElementFormat.Vector2, 0), new VertexElement("a_uv", 76, VertexElementFormat.Vector3, 0), new VertexElement("a_normalizedUv", 88, VertexElementFormat.Vector2, 0)];
    var vertexBuffer = new Buffer(this.engine, BufferBindFlag.VertexBuffer, vertexFloatCount * 4, BufferUsage.Dynamic);
    var indexBuffer = new Buffer(this.engine, BufferBindFlag.IndexBuffer, indices, BufferUsage.Dynamic);
    mesh.setVertexBufferBinding(vertexBuffer, vertexStride);
    mesh.setIndexBufferBinding(indexBuffer, useUint32 ? IndexFormat.UInt32 : IndexFormat.UInt16);
    mesh.setVertexElements(vertexElements);
    mesh.addSubMesh(0, indices.length);
    this._vertexBuffer = vertexBuffer;
    this._vertexStride = vertexStride / 4;
    this._vertices = vertices;
    return mesh;
  };
  _proto._updateBuffer = function _updateBuffer() {
    for (var x = 0; x < this._maxCount; x++) {
      this._updateSingleBuffer(x);
    }
    this._vertexBuffer.setData(this._vertices);
  };
  _proto._updateSingleBuffer = function _updateSingleBuffer(i) {
    var _updateDirtyFlag = this._updateDirtyFlag, vertices = this._vertices, vertexStride = this._vertexStride;
    var getRandom = ParticleRenderer2._getRandom;
    var offset = i * 4;
    var k0 = offset * vertexStride;
    var k1 = (offset + 1) * vertexStride;
    var k2 = (offset + 2) * vertexStride;
    var k3 = (offset + 3) * vertexStride;
    if (_updateDirtyFlag & DirtyFlagType.Position) {
      var _this$_position = this._position, x = _this$_position.x, y = _this$_position.y, z = _this$_position.z;
      var _positionArray = this._positionArray, _positionRandomness = this._positionRandomness;
      if (_positionArray) {
        if (_positionArray.length !== this._maxCount) {
          throw Error("The length of positionArray must be equal to maxCount.");
        }
        var pos = _positionArray[i];
        x += pos.x;
        y += pos.y;
        z += pos.z;
      } else {
        x += getRandom() * _positionRandomness.x;
        y += getRandom() * _positionRandomness.y;
        z += getRandom() * _positionRandomness.z;
      }
      vertices[k0] = vertices[k1] = vertices[k2] = vertices[k3] = x;
      vertices[k0 + 1] = vertices[k1 + 1] = vertices[k2 + 1] = vertices[k3 + 1] = y;
      vertices[k0 + 2] = vertices[k1 + 2] = vertices[k2 + 2] = vertices[k3 + 2] = z;
    }
    if (_updateDirtyFlag & DirtyFlagType.Velocity) {
      var _velocity = this._velocity, _velocityRandomness = this._velocityRandomness;
      vertices[k0 + 3] = vertices[k1 + 3] = vertices[k2 + 3] = vertices[k3 + 3] = _velocity.x + getRandom() * _velocityRandomness.x;
      vertices[k0 + 4] = vertices[k1 + 4] = vertices[k2 + 4] = vertices[k3 + 4] = _velocity.y + getRandom() * _velocityRandomness.y;
      vertices[k0 + 5] = vertices[k1 + 5] = vertices[k2 + 5] = vertices[k3 + 5] = _velocity.z + getRandom() * _velocityRandomness.z;
    }
    if (_updateDirtyFlag & DirtyFlagType.Acceleration) {
      var _acceleration = this._acceleration, _accelerationRandomness = this._accelerationRandomness;
      vertices[k0 + 6] = vertices[k1 + 6] = vertices[k2 + 6] = vertices[k3 + 6] = _acceleration.x + getRandom() * _accelerationRandomness.x;
      vertices[k0 + 7] = vertices[k1 + 7] = vertices[k2 + 7] = vertices[k3 + 7] = _acceleration.y + getRandom() * _accelerationRandomness.y;
      vertices[k0 + 8] = vertices[k1 + 8] = vertices[k2 + 8] = vertices[k3 + 8] = _acceleration.z + getRandom() * _accelerationRandomness.z;
    }
    if (_updateDirtyFlag & DirtyFlagType.Color) {
      var _color = this._color, _colorRandomness = this._colorRandomness;
      vertices[k0 + 9] = vertices[k1 + 9] = vertices[k2 + 9] = vertices[k3 + 9] = MathUtil.clamp(_color.r + getRandom() * _colorRandomness, 0, 1);
      vertices[k0 + 10] = vertices[k1 + 10] = vertices[k2 + 10] = vertices[k3 + 10] = MathUtil.clamp(_color.g + getRandom() * _colorRandomness, 0, 1);
      vertices[k0 + 11] = vertices[k1 + 11] = vertices[k2 + 11] = vertices[k3 + 11] = MathUtil.clamp(_color.b + getRandom() * _colorRandomness, 0, 1);
    }
    if (_updateDirtyFlag & DirtyFlagType.Alpha) {
      vertices[k0 + 12] = vertices[k1 + 12] = vertices[k2 + 12] = vertices[k3 + 12] = MathUtil.clamp(this._alpha + getRandom() * this._alphaRandomness, 0, 1);
    }
    if (_updateDirtyFlag & DirtyFlagType.StartTime) {
      vertices[k0 + 13] = vertices[k1 + 13] = vertices[k2 + 13] = vertices[k3 + 13] = Math.random() * this._startTimeRandomness;
    }
    if (_updateDirtyFlag & DirtyFlagType.LifeTime) {
      var _lifetime = this._lifetime;
      vertices[k0 + 14] = vertices[k1 + 14] = vertices[k2 + 14] = vertices[k3 + 14] = _lifetime + getRandom() * _lifetime;
    }
    if (_updateDirtyFlag & DirtyFlagType.StartTime || _updateDirtyFlag & DirtyFlagType.LifeTime) {
      this._onceTime = Math.max(this._onceTime, vertices[k0 + 13] + vertices[k0 + 14]);
    }
    if (_updateDirtyFlag & DirtyFlagType.Size) {
      var _size = this._size;
      vertices[k0 + 15] = vertices[k1 + 15] = vertices[k2 + 15] = vertices[k3 + 15] = Math.max(_size + getRandom() * this._sizeRandomness * _size * 2, 0);
    }
    if (_updateDirtyFlag & DirtyFlagType.Scale) {
      vertices[k0 + 16] = vertices[k1 + 16] = vertices[k2 + 16] = vertices[k3 + 16] = this._scale;
    }
    if (_updateDirtyFlag & DirtyFlagType.StartAngle) {
      vertices[k0 + 17] = vertices[k1 + 17] = vertices[k2 + 17] = vertices[k3 + 17] = this._startAngle + getRandom() * Math.PI * this._startAngleRandomness * 2;
    }
    if (_updateDirtyFlag & DirtyFlagType.RotateVelocity) {
      vertices[k0 + 18] = vertices[k1 + 18] = vertices[k2 + 18] = vertices[k3 + 18] = this._rotateVelocity + getRandom() * this._rotateVelocityRandomness;
    }
    this._updateSingleUv(i, k0, k1, k2, k3);
  };
  _proto._updateSingleUv = function _updateSingleUv(i, k0, k1, k2, k3) {
    var spriteSheet = this.spriteSheet;
    var texture = this.getMaterial().shaderData.getTexture("u_texture");
    var vertices = this._vertices;
    if (texture) {
      var width = texture.width;
      var height = texture.height;
      if (spriteSheet) {
        var _spriteSheet = spriteSheet[i % spriteSheet.length], x = _spriteSheet.x, y = _spriteSheet.y, w = _spriteSheet.w, h = _spriteSheet.h;
        var u = x / width;
        var v = y / height;
        var p = u + w / width;
        var q = v + h / height;
        var ratio = h / w;
        vertices[k0 + 19] = u;
        vertices[k0 + 20] = q;
        vertices[k0 + 21] = ratio;
        vertices[k1 + 19] = p;
        vertices[k1 + 20] = q;
        vertices[k1 + 21] = ratio;
        vertices[k2 + 19] = p;
        vertices[k2 + 20] = v;
        vertices[k2 + 21] = ratio;
        vertices[k3 + 19] = u;
        vertices[k3 + 20] = v;
        vertices[k3 + 21] = ratio;
      } else {
        var _ratio = height / width;
        vertices[k0 + 19] = 0;
        vertices[k0 + 20] = 1;
        vertices[k0 + 21] = _ratio;
        vertices[k1 + 19] = 1;
        vertices[k1 + 20] = 1;
        vertices[k1 + 21] = _ratio;
        vertices[k2 + 19] = 1;
        vertices[k2 + 20] = 0;
        vertices[k2 + 21] = _ratio;
        vertices[k3 + 19] = 0;
        vertices[k3 + 20] = 0;
        vertices[k3 + 21] = _ratio;
      }
    } else {
      vertices[k0 + 19] = 0;
      vertices[k0 + 20] = 0;
      vertices[k0 + 21] = 1;
      vertices[k1 + 19] = 1;
      vertices[k1 + 20] = 0;
      vertices[k1 + 21] = 1;
      vertices[k2 + 19] = 1;
      vertices[k2 + 20] = 1;
      vertices[k2 + 21] = 1;
      vertices[k3 + 19] = 0;
      vertices[k3 + 20] = 1;
      vertices[k3 + 21] = 1;
    }
    vertices[k0 + 22] = -0.5;
    vertices[k0 + 23] = -0.5;
    vertices[k1 + 22] = 0.5;
    vertices[k1 + 23] = -0.5;
    vertices[k2 + 22] = 0.5;
    vertices[k2 + 23] = 0.5;
    vertices[k3 + 22] = -0.5;
    vertices[k3 + 23] = 0.5;
  };
  _createClass(ParticleRenderer2, [{
    key: "texture",
    get: function get4() {
      return this.getMaterial().shaderData.getTexture("u_texture");
    },
    set: function set4(texture) {
      if (texture) {
        this.shaderData.enableMacro("particleTexture");
        this.getMaterial().shaderData.setTexture("u_texture", texture);
      } else {
        this.shaderData.disableMacro("particleTexture");
      }
    }
  }, {
    key: "position",
    get: function get4() {
      return this._position;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Position;
      this._position = value;
    }
  }, {
    key: "positionRandomness",
    get: function get4() {
      return this._positionRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Position;
      this._positionRandomness = value;
    }
  }, {
    key: "positionArray",
    get: function get4() {
      return this._positionArray;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Position;
      this._positionArray = value;
    }
  }, {
    key: "velocity",
    get: function get4() {
      return this._velocity;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Velocity;
      this._velocity = value;
    }
  }, {
    key: "velocityRandomness",
    get: function get4() {
      return this._velocityRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Velocity;
      this._velocityRandomness = value;
    }
  }, {
    key: "acceleration",
    get: function get4() {
      return this._acceleration;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Acceleration;
      this._acceleration = value;
    }
  }, {
    key: "accelerationRandomness",
    get: function get4() {
      return this._accelerationRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Acceleration;
      this._accelerationRandomness = value;
    }
  }, {
    key: "color",
    get: function get4() {
      return this._color;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Color;
      this._color = value;
    }
  }, {
    key: "colorRandomness",
    get: function get4() {
      return this._colorRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Color;
      this._colorRandomness = value;
    }
  }, {
    key: "size",
    get: function get4() {
      return this._size;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Size;
      this._size = value;
    }
  }, {
    key: "sizeRandomness",
    get: function get4() {
      return this._sizeRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Size;
      this._sizeRandomness = value;
    }
  }, {
    key: "alpha",
    get: function get4() {
      return this._alpha;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Alpha;
      this._alpha = value;
    }
  }, {
    key: "alphaRandomness",
    get: function get4() {
      return this._alphaRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Alpha;
      this._alphaRandomness = value;
    }
  }, {
    key: "angle",
    get: function get4() {
      return this._startAngle;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.StartAngle;
      this._startAngle = value;
    }
  }, {
    key: "angleRandomness",
    get: function get4() {
      return this._startAngleRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.StartAngle;
      this._startAngleRandomness = value;
    }
  }, {
    key: "rotateVelocity",
    get: function get4() {
      return this._rotateVelocity;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.RotateVelocity;
      this._rotateVelocity = value;
    }
  }, {
    key: "rotateVelocityRandomness",
    get: function get4() {
      return this._rotateVelocityRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.RotateVelocity;
      this._rotateVelocityRandomness = value;
    }
  }, {
    key: "lifetime",
    get: function get4() {
      return this._lifetime;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.LifeTime;
      this._lifetime = value;
      this._onceTime = 0;
    }
  }, {
    key: "startTimeRandomness",
    get: function get4() {
      return this._startTimeRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.StartTime;
      this._startTimeRandomness = value;
      this._onceTime = 0;
    }
  }, {
    key: "scale",
    get: function get4() {
      return this._scale;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Scale;
      this._scale = value;
    }
  }, {
    key: "maxCount",
    get: function get4() {
      return this._maxCount;
    },
    set: function set4(value) {
      this._isStart = false;
      this._isInit = false;
      this._maxCount = value;
      this._updateDirtyFlag = DirtyFlagType.Everything;
      this.mesh = this._createMesh();
      this._updateBuffer();
      this._isInit = true;
      this.shaderData.setFloat("u_time", 0);
    }
  }, {
    key: "isOnce",
    get: function get4() {
      return this._isOnce;
    },
    set: function set4(value) {
      this._time = 0;
      this.shaderData.setInt("u_once", value ? 1 : 0);
      this._isOnce = value;
    }
  }, {
    key: "isRotateToVelocity",
    get: function get4() {
      return this._isRotateToVelocity;
    },
    set: function set4(value) {
      if (value) {
        this.shaderData.enableMacro("rotateToVelocity");
      } else {
        this.shaderData.disableMacro("rotateToVelocity");
      }
      this._isRotateToVelocity = value;
    }
  }, {
    key: "isUseOriginColor",
    get: function get4() {
      return this._isUseOriginColor;
    },
    set: function set4(value) {
      if (value) {
        this.shaderData.enableMacro("useOriginColor");
      } else {
        this.shaderData.disableMacro("useOriginColor");
      }
      this._isUseOriginColor = value;
    }
  }, {
    key: "isScaleByLifetime",
    get: function get4() {
      return this._isScaleByLifetime;
    },
    set: function set4(value) {
      if (value) {
        this.shaderData.enableMacro("isScaleByLifetime");
      } else {
        this.shaderData.disableMacro("isScaleByLifetime");
      }
      this._isScaleByLifetime = value;
    }
  }, {
    key: "is2d",
    get: function get4() {
      return this._is2d;
    },
    set: function set4(value) {
      if (value) {
        this.shaderData.enableMacro("is2d");
      } else {
        this.shaderData.disableMacro("is2d");
        this.getMaterial().renderState.rasterState.cullMode = CullMode.Off;
      }
      this._is2d = value;
    }
  }, {
    key: "isFadeIn",
    get: function get4() {
      return this._isFadeIn;
    },
    set: function set4(value) {
      if (value) {
        this.shaderData.enableMacro("fadeIn");
      } else {
        this.shaderData.disableMacro("fadeIn");
      }
      this._isFadeIn = value;
    }
  }, {
    key: "isFadeOut",
    get: function get4() {
      return this._isFadeOut;
    },
    set: function set4(value) {
      if (value) {
        this.shaderData.enableMacro("fadeOut");
      } else {
        this.shaderData.disableMacro("fadeOut");
      }
      this._isFadeOut = value;
    }
  }, {
    key: "playOnEnable",
    get: function get4() {
      return this._playOnEnable;
    },
    set: function set4(value) {
      this._playOnEnable = value;
      if (value) {
        this.start();
      } else {
        this.stop();
      }
    }
  }, {
    key: "blendMode",
    get: function get4() {
      return this._blendMode;
    },
    set: function set4(value) {
      var blendState = this.getMaterial().renderState.blendState;
      var target = blendState.targetBlendState;
      if (value === ParticleRendererBlendMode.Transparent) {
        target.enabled = true;
        target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
        target.sourceAlphaBlendFactor = BlendFactor.One;
        target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
      } else if (value === ParticleRendererBlendMode.Additive) {
        target.enabled = true;
        target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = BlendFactor.One;
        target.sourceAlphaBlendFactor = BlendFactor.One;
        target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
      }
      this._blendMode = value;
    }
  }]);
  return ParticleRenderer2;
}(MeshRenderer);
ParticleRenderer._uint16VertexLimit = 65535;
var FRAG_SHADER = "#define GLSLIFY 1\nvarying vec2 v_uv;uniform sampler2D u_texture;void main(void){gl_FragColor=texture2D(u_texture,v_uv);}";
var VERT_SHADER = "#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;uniform mat4 u_projMat;uniform mat4 u_viewMat;void main(){gl_Position=u_projMat*u_viewMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}";
Shader.create("trail", VERT_SHADER, FRAG_SHADER);
var TrailMaterial = function(_Material) {
  _inheritsLoose(TrailMaterial2, _Material);
  function TrailMaterial2(engine) {
    var _this;
    _this = _Material.call(this, engine, Shader.find("trail")) || this;
    var target = _this.renderState.blendState.targetBlendState;
    target.enabled = true;
    target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.SourceAlpha;
    target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.One;
    _this.renderState.depthState.writeEnabled = false;
    return _this;
  }
  return TrailMaterial2;
}(Material);
var _tempVector3 = new Vector3();
var TrailRenderer = function(_MeshRenderer) {
  _inheritsLoose(TrailRenderer2, _MeshRenderer);
  function TrailRenderer2(entity, props) {
    var _this;
    _this = _MeshRenderer.call(this, entity) || this;
    _this._vertexStride = void 0;
    _this._vertices = void 0;
    _this._vertexBuffer = void 0;
    _this._stroke = void 0;
    _this._minSeg = void 0;
    _this._lifetime = void 0;
    _this._maxPointNum = void 0;
    _this._points = void 0;
    _this._pointStates = void 0;
    _this._strapPoints = void 0;
    _this._curPointNum = void 0;
    _this._prePointsNum = void 0;
    _this._stroke = props.stroke || 0.2;
    _this._minSeg = props.minSeg || 0.02;
    _this._lifetime = props.lifetime || 1e3;
    _this._maxPointNum = _this._lifetime / 1e3 * entity.engine.targetFrameRate;
    _this._points = [];
    _this._pointStates = [];
    _this._strapPoints = [];
    for (var i = 0; i < _this._maxPointNum; i++) {
      _this._points.push(new Vector3());
      _this._pointStates.push(_this._lifetime);
      _this._strapPoints.push(new Vector3());
      _this._strapPoints.push(new Vector3());
    }
    _this._curPointNum = 0;
    var mtl = props.material || new TrailMaterial(_this.engine);
    _this.setMaterial(mtl);
    _this.setTexture(props.texture);
    _this._initGeometry();
    return _this;
  }
  var _proto = TrailRenderer2.prototype;
  _proto.update = function update(deltaTime) {
    var mov = 0, newIdx = 0;
    for (var i = 0; i < this._curPointNum; i++) {
      this._pointStates[i] -= deltaTime;
      if (this._pointStates[i] < 0) {
        mov++;
      } else if (mov > 0) {
        newIdx = i - mov;
        this._pointStates[newIdx] = this._pointStates[i];
        this._points[i].cloneTo(this._points[newIdx]);
      }
    }
    this._curPointNum -= mov;
    var appendNewPoint = true;
    if (this._curPointNum === this._maxPointNum) {
      appendNewPoint = false;
    } else if (this._curPointNum > 0) {
      var lastPoint = this._points[this._points.length - 1];
      if (Vector3.distance(this.entity.worldPosition, lastPoint) < this._minSeg) {
        appendNewPoint = false;
      }
    }
    if (appendNewPoint) {
      this._pointStates[this._curPointNum] = this._lifetime;
      this.entity.worldPosition.cloneTo(this._points[this._curPointNum]);
      this._curPointNum++;
    }
  };
  _proto._render = function _render(camera) {
    this._updateStrapVertices(camera, this._points);
    this._updateStrapCoords();
    this._vertexBuffer.setData(this._vertices);
    _MeshRenderer.prototype._render.call(this, camera);
  };
  _proto.setTexture = function setTexture(texture) {
    if (texture) {
      this.getMaterial().shaderData.setTexture("u_texture", texture);
    }
  };
  _proto._initGeometry = function _initGeometry() {
    var mesh = new BufferMesh(this._entity.engine);
    var vertexStride = 20;
    var vertexCount = this._maxPointNum * 2;
    var vertexFloatCount = vertexCount * vertexStride;
    var vertices = new Float32Array(vertexFloatCount);
    var vertexElements = [new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0), new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0)];
    var vertexBuffer = new Buffer(this.engine, vertexFloatCount * 4, BufferUsage.Dynamic);
    mesh.setVertexBufferBinding(vertexBuffer, vertexStride);
    mesh.setVertexElements(vertexElements);
    mesh.addSubMesh(0, vertexCount, MeshTopology.TriangleStrip);
    this._vertexBuffer = vertexBuffer;
    this._vertexStride = vertexStride;
    this._vertices = vertices;
    this.mesh = mesh;
  };
  _proto._updateStrapVertices = function _updateStrapVertices(camera, points) {
    var m = camera.viewMatrix;
    var e = m.elements;
    var vx = new Vector3(e[0], e[4], e[8]);
    var vy = new Vector3(e[1], e[5], e[9]);
    var vz = new Vector3(e[2], e[6], e[10]);
    var s = this._stroke;
    vy.scale(s);
    var up = new Vector3();
    var down = new Vector3();
    var rotation = new Quaternion();
    Vector3.transformByQuat(vx, rotation, vx);
    Vector3.transformByQuat(vy, rotation, vy);
    var dy = new Vector3();
    var cross = new Vector3();
    var perpVector = new Vector3();
    vx.normalize();
    var vertices = this._vertices;
    for (var i = 0; i < this._maxPointNum; i++) {
      if (i < this._curPointNum) {
        var p = points[i];
        if (i === this._curPointNum - 1 && i !== 0) {
          Vector3.subtract(p, points[i - 1], perpVector);
        } else {
          Vector3.subtract(points[i + 1], p, perpVector);
        }
        this._projectOnPlane(perpVector, vz, perpVector);
        perpVector.normalize();
        var angle = Math.acos(Vector3.dot(vx, perpVector));
        Vector3.cross(vx, perpVector, cross);
        if (Vector3.dot(cross, vz) <= 0) {
          angle = Math.PI * 2 - angle;
        }
        Quaternion.rotationAxisAngle(vz, angle, rotation);
        Vector3.transformByQuat(vy, rotation, dy);
        Vector3.add(p, dy, up);
        Vector3.subtract(p, dy, down);
      }
      var p0 = i * 2 * this._vertexStride / 4;
      var p1 = (i * 2 + 1) * this._vertexStride / 4;
      vertices[p0] = up.x;
      vertices[p0 + 1] = up.y;
      vertices[p0 + 2] = up.z;
      vertices[p1] = down.x;
      vertices[p1 + 1] = down.y;
      vertices[p1 + 2] = down.z;
    }
  };
  _proto._updateStrapCoords = function _updateStrapCoords() {
    if (this._prePointsNum === this._curPointNum) {
      return;
    }
    this._prePointsNum = this._curPointNum;
    var count = this._curPointNum;
    var texDelta = 1 / count;
    var vertices = this._vertices;
    for (var i = 0; i < count; i++) {
      var d = 1 - i * texDelta;
      var p0 = i * 2 * this._vertexStride / 4;
      var p1 = (i * 2 + 1) * this._vertexStride / 4;
      vertices[p0] = 0;
      vertices[p0 + 1] = d;
      vertices[p1] = 1;
      vertices[p1 + 1] = d;
    }
  };
  _proto._projectOnVector = function _projectOnVector(a, p, out) {
    var n_p = p.clone();
    Vector3.normalize(n_p, n_p);
    var cosine = Vector3.dot(a, n_p);
    out.x = n_p.x * cosine;
    out.y = n_p.y * cosine;
    out.z = n_p.z * cosine;
  };
  _proto._projectOnPlane = function _projectOnPlane(a, n, out) {
    this._projectOnVector(a, n, _tempVector3);
    Vector3.subtract(a, _tempVector3, out);
  };
  return TrailRenderer2;
}(MeshRenderer);
function intersectBox2Box(boxA, boxB) {
  return boxA.min.x <= boxB.max.x && boxA.max.x >= boxB.min.x && boxA.min.y <= boxB.max.y && boxA.max.y >= boxB.min.y && boxA.min.z <= boxB.max.z && boxA.max.z >= boxB.min.z;
}
function intersectSphere2Sphere(sphereA, sphereB) {
  var distance = Vector3.distance(sphereA.center, sphereB.center);
  return distance < sphereA.radius + sphereA.radius;
}
function intersectSphere2Box(sphere, box) {
  var center = sphere.center;
  var closestPoint = new Vector3(Math.max(box.min.x, Math.min(center.x, box.max.x)), Math.max(box.min.y, Math.min(center.y, box.max.y)), Math.max(box.min.z, Math.min(center.z, box.max.z)));
  var distance = Vector3.distance(center, closestPoint);
  return distance < sphere.radius;
}
var CollisionDetection = function(_Script) {
  _inheritsLoose(CollisionDetection2, _Script);
  function CollisionDetection2(entity) {
    var _this;
    _this = _Script.call(this, entity) || this;
    _this._colliderManager = void 0;
    _this._myCollider = void 0;
    _this._overlappedCollider = void 0;
    _this._sphere = void 0;
    _this._box = new BoundingBox();
    return _this;
  }
  var _proto = CollisionDetection2.prototype;
  _proto.onUpdate = function onUpdate(deltaTime) {
    _Script.prototype.onUpdate.call(this, deltaTime);
    var overlappedCollider = null;
    if (this._colliderManager && this._myCollider) {
      var colliders = this._colliderManager.colliders;
      if (this._myCollider instanceof ABoxCollider) {
        this._updateWorldBox(this._myCollider, this._box);
        for (var i = 0, len = colliders.length; i < len; i++) {
          var collider = colliders[i];
          if (collider != this._myCollider && this._boxCollision(collider)) {
            overlappedCollider = collider;
            var scripts = this.entity._scripts;
            for (var _i = 0, _len = scripts.length; _i < _len; _i++) {
              scripts.get(_i).onTriggerStay(collider);
            }
          }
        }
      } else if (this._myCollider instanceof ASphereCollider) {
        this._sphere = this._getWorldSphere(this._myCollider);
        for (var _i2 = 0, _len2 = colliders.length; _i2 < _len2; _i2++) {
          var _collider = colliders[_i2];
          if (_collider != this._myCollider && this._sphereCollision(_collider)) {
            overlappedCollider = _collider;
            var _scripts = this.entity._scripts;
            for (var _i3 = 0, _len3 = _scripts.length; _i3 < _len3; _i3++) {
              _scripts.get(_i3).onTriggerStay(_collider);
            }
          }
        }
      }
    }
    if (overlappedCollider != null && this._overlappedCollider != overlappedCollider) {
      var _scripts2 = this.entity._scripts;
      for (var _i4 = 0, _len4 = _scripts2.length; _i4 < _len4; _i4++) {
        _scripts2.get(_i4).onTriggerEnter(overlappedCollider);
      }
    }
    if (this._overlappedCollider != null && this._overlappedCollider != overlappedCollider) {
      var _scripts3 = this.entity._scripts;
      for (var _i5 = 0, _len5 = _scripts3.length; _i5 < _len5; _i5++) {
        _scripts3.get(_i5).onTriggerExit(this._overlappedCollider);
      }
    }
    this._overlappedCollider = overlappedCollider;
  };
  _proto._updateWorldBox = function _updateWorldBox(boxCollider, out) {
    var mat = boxCollider.entity.transform.worldMatrix;
    var source = CollisionDetection2._tempBox1;
    boxCollider.boxMax.cloneTo(source.max);
    boxCollider.boxMin.cloneTo(source.min);
    BoundingBox.transform(source, mat, out);
  };
  _proto._getWorldSphere = function _getWorldSphere(sphereCollider) {
    var center = new Vector3();
    Vector3.transformCoordinate(sphereCollider.center, sphereCollider.entity.transform.worldMatrix, center);
    return {
      radius: sphereCollider.radius,
      center
    };
  };
  _proto._boxCollision = function _boxCollision(other) {
    if (other instanceof ABoxCollider) {
      var box = CollisionDetection2._tempBox2;
      this._updateWorldBox(other, box);
      return intersectBox2Box(box, this._box);
    } else if (other instanceof ASphereCollider) {
      var sphere = this._getWorldSphere(other);
      return intersectSphere2Box(sphere, this._box);
    }
    return false;
  };
  _proto._sphereCollision = function _sphereCollision(other) {
    if (other instanceof ABoxCollider) {
      var box = CollisionDetection2._tempBox2;
      this._updateWorldBox(other, box);
      return intersectSphere2Box(this._sphere, box);
    } else if (other instanceof ASphereCollider) {
      var sphere = this._getWorldSphere(other);
      return intersectSphere2Sphere(sphere, this._sphere);
    }
    return false;
  };
  _proto.onAwake = function onAwake() {
    this._colliderManager = this.scene.findFeature(ColliderFeature);
    this._myCollider = this.entity.getComponent(Collider);
  };
  _createClass(CollisionDetection2, [{
    key: "overlappedCollider",
    get: function get4() {
      return this._overlappedCollider;
    }
  }]);
  return CollisionDetection2;
}(Script);
CollisionDetection._tempBox1 = new BoundingBox();
CollisionDetection._tempBox2 = new BoundingBox();
var Fog = function(_Component) {
  _inheritsLoose(Fog2, _Component);
  function Fog2(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _this._color = new Color(1, 0, 0, 1);
    _this.color = _this._color;
    return _this;
  }
  var _proto = Fog2.prototype;
  _proto._onEnable = function _onEnable() {
    this.scene.shaderData.enableMacro("O3_HAS_FOG");
  };
  _proto._onDisable = function _onDisable() {
    this.scene.shaderData.disableMacro("O3_HAS_FOG");
  };
  _createClass(Fog2, [{
    key: "color",
    get: function get4() {
      return this._color;
    },
    set: function set4(value) {
      this._color = value;
      this.scene.shaderData.setColor(Fog2._colorProperty, value);
    }
  }]);
  return Fog2;
}(Component);
Fog._colorProperty = Shader.getPropertyByName("u_fogColor");
var EXP2Fog = function(_Fog) {
  _inheritsLoose(EXP2Fog2, _Fog);
  function EXP2Fog2(entity) {
    var _this;
    _this = _Fog.call(this, entity) || this;
    _this._density = 25e-4;
    _this.density = _this._density;
    return _this;
  }
  var _proto = EXP2Fog2.prototype;
  _proto._onEnable = function _onEnable() {
    this.scene.shaderData.enableMacro("O3_FOG_EXP2");
  };
  _proto._onDisable = function _onDisable() {
    this.scene.shaderData.disableMacro("O3_FOG_EXP2");
  };
  _createClass(EXP2Fog2, [{
    key: "density",
    get: function get4() {
      return this._density;
    },
    set: function set4(value) {
      this._density = value;
      this.scene.shaderData.setFloat(EXP2Fog2._densityProperty, value);
    }
  }]);
  return EXP2Fog2;
}(Fog);
EXP2Fog._densityProperty = Shader.getPropertyByName("u_fogDensity");
var LinearFog = function(_Fog) {
  _inheritsLoose(LinearFog2, _Fog);
  function LinearFog2(entity) {
    var _this;
    _this = _Fog.call(this, entity) || this;
    _this._near = 1;
    _this._far = 1e3;
    _this.near = _this._near;
    _this.far = _this._far;
    return _this;
  }
  _createClass(LinearFog2, [{
    key: "near",
    get: function get4() {
      return this._near;
    },
    set: function set4(value) {
      this._near = value;
      this.scene.shaderData.setFloat(LinearFog2._nearProperty, value);
    }
  }, {
    key: "far",
    get: function get4() {
      return this._far;
    },
    set: function set4(value) {
      this._far = value;
      this.scene.shaderData.setFloat(LinearFog2._farProperty, value);
    }
  }]);
  return LinearFog2;
}(Fog);
LinearFog._nearProperty = Shader.getPropertyByName("u_fogNear");
LinearFog._farProperty = Shader.getPropertyByName("u_fogFar");
var Probe = function(_Script) {
  _inheritsLoose(Probe2, _Script);
  function Probe2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Script.call.apply(_Script, [this].concat(args)) || this;
    _this.probeLayer = Layer.Everything;
    _this.width = 1024;
    _this.height = 1024;
    _this.antiAliasing = 1;
    _this._isCube = false;
    _this._oriCameraRenderTarget = void 0;
    _this._renderTarget = void 0;
    _this._renderTargetSwap = void 0;
    _this._activeRenderTarget = void 0;
    _this._camera = void 0;
    _this._oriCameraCullingMask = void 0;
    return _this;
  }
  var _proto = Probe2.prototype;
  _proto.onTextureChange = function onTextureChange(renderColorTexture) {
  };
  _proto.onBeginRender = function onBeginRender(camera) {
    if (!this.enabled)
      return;
    this._camera = camera;
    this._oriCameraCullingMask = camera.cullingMask;
    camera.cullingMask = this.probeLayer;
    if (!this._activeRenderTarget || this._activeRenderTarget.width !== this.width || this._activeRenderTarget.height !== this.height || this._activeRenderTarget.antiAliasing !== this.antiAliasing) {
      this._renderTarget = new RenderTarget(this.engine, this.width, this.height, new RenderColorTexture(this.engine, this.width, this.height, void 0, void 0, this._isCube), RenderBufferDepthFormat.Depth, this.antiAliasing);
      this._renderTargetSwap = new RenderTarget(this.engine, this.width, this.height, new RenderColorTexture(this.engine, this.width, this.height, void 0, void 0, this._isCube), RenderBufferDepthFormat.Depth, this.antiAliasing);
      this._activeRenderTarget = this._renderTarget;
    }
    this._oriCameraRenderTarget = camera.renderTarget;
    camera.renderTarget = this._activeRenderTarget;
  };
  _proto.onEndRender = function onEndRender(camera) {
    if (!this.enabled)
      return;
    this.onTextureChange && this.onTextureChange(this._texture);
    this._activeRenderTarget = this._activeRenderTarget === this._renderTarget ? this._renderTargetSwap : this._renderTarget;
  };
  _proto._reset = function _reset() {
    if (!this.enabled)
      return;
    this._camera.renderTarget = this._oriCameraRenderTarget;
    this._camera.cullingMask = this._oriCameraCullingMask;
  };
  _createClass(Probe2, [{
    key: "_texture",
    get: function get4() {
      var _this$_activeRenderTa;
      return (_this$_activeRenderTa = this._activeRenderTarget) === null || _this$_activeRenderTa === void 0 ? void 0 : _this$_activeRenderTa.getColorTexture();
    }
  }]);
  return Probe2;
}(Script);
var cacheTarget = new Vector3();
var cacheUp = new Vector3();
var cacheDir = new Vector3();
var CubeProbe = function(_Probe) {
  _inheritsLoose(CubeProbe2, _Probe);
  function CubeProbe2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Probe.call.apply(_Probe, [this].concat(args)) || this;
    _this.position = new Vector3(0, 0, 0);
    _this._isCube = true;
    _this.oriViewMatrix = new Matrix();
    _this._oriFieldOfView = void 0;
    return _this;
  }
  var _proto = CubeProbe2.prototype;
  _proto.onBeginRender = function onBeginRender(camera) {
    if (!this.enabled)
      return;
    _Probe.prototype.onBeginRender.call(this, camera);
    this._storeCamera(camera);
    for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
      this._setCamera(faceIndex, camera);
      camera.render(TextureCubeFace.PositiveX + faceIndex);
    }
    this._restoreCamera(camera);
    _Probe.prototype._reset.call(this);
  };
  _proto._storeCamera = function _storeCamera(camera) {
    camera.viewMatrix.cloneTo(this.oriViewMatrix);
    this._oriFieldOfView = camera.fieldOfView;
  };
  _proto._restoreCamera = function _restoreCamera(camera) {
    this.oriViewMatrix.cloneTo(camera.viewMatrix);
    camera.fieldOfView = this._oriFieldOfView;
  };
  _proto._setCamera = function _setCamera(faceIndex, camera) {
    switch (faceIndex) {
      case 0:
        cacheUp.setValue(0, -1, 0);
        cacheDir.setValue(1, 0, 0);
        break;
      case 1:
        cacheUp.setValue(0, -1, 0);
        cacheDir.setValue(-1, 0, 0);
        break;
      case 2:
        cacheUp.setValue(0, 0, 1);
        cacheDir.setValue(0, 1, 0);
        break;
      case 3:
        cacheUp.setValue(0, 0, -1);
        cacheDir.setValue(0, -1, 0);
        break;
      case 4:
        cacheUp.setValue(0, -1, 0);
        cacheDir.setValue(0, 0, 1);
        break;
      case 5:
        cacheUp.setValue(0, -1, 0);
        cacheDir.setValue(0, 0, -1);
        break;
    }
    Vector3.add(this.position, cacheDir, cacheTarget);
    Matrix.lookAt(this.position, cacheTarget, cacheUp, camera.viewMatrix);
    camera.fieldOfView = 90;
  };
  return CubeProbe2;
}(Probe);
var LightShadow = function() {
  LightShadow2._updateShaderData = function _updateShaderData(shaderData) {
    var data = LightShadow2._combinedData;
    shaderData.setFloatArray(LightShadow2._viewMatFromLightProperty, data.viewMatrix);
    shaderData.setFloatArray(LightShadow2._projMatFromLightProperty, data.projectionMatrix);
    shaderData.setFloatArray(LightShadow2._shadowBiasProperty, data.bias);
    shaderData.setFloatArray(LightShadow2._shadowIntensityProperty, data.intensity);
    shaderData.setFloatArray(LightShadow2._shadowRadiusProperty, data.radius);
    shaderData.setFloatArray(LightShadow2._shadowMapSizeProperty, data.mapSize);
    shaderData.setTextureArray(LightShadow2._shadowMapsProperty, data.map);
  };
  LightShadow2.clearMap = function clearMap() {
    LightShadow2._combinedData.map.length = 0;
  };
  function LightShadow2(light, props) {
    if (props === void 0) {
      props = {
        engine: null,
        width: 512,
        height: 512
      };
    }
    this._mapSize = void 0;
    this._renderTarget = void 0;
    this.light = void 0;
    this.bias = 5e-3;
    this.intensity = 0.2;
    this.radius = 1;
    this.projectionMatrix = new Matrix();
    this.light = light;
    var _props = props, engine = _props.engine, width = _props.width, height = _props.height;
    this._mapSize = new Vector2(width, height);
    this._renderTarget = new RenderTarget(engine, width, height, new RenderColorTexture(engine, width, height));
  }
  var _proto = LightShadow2.prototype;
  _proto.initShadowProjectionMatrix = function initShadowProjectionMatrix(light) {
    if (light instanceof DirectLight) {
      Matrix.ortho(-5, 5, -5, 5, 0.1, 50, this.projectionMatrix);
    }
    if (light instanceof PointLight) {
      Matrix.perspective(MathUtil.degreeToRadian(50), 1, 0.5, 50, this.projectionMatrix);
    }
    if (light instanceof SpotLight) {
      var fov = Math.min(Math.PI / 2, light.angle * 2 * Math.sqrt(2));
      Matrix.perspective(fov, 1, 0.1, light.distance + 5, this.projectionMatrix);
    }
  };
  _proto.appendData = function appendData(lightIndex) {
    var viewStart = lightIndex * 16;
    var projectionStart = lightIndex * 16;
    var biasStart = lightIndex;
    var intensityStart = lightIndex;
    var radiusStart = lightIndex;
    var mapSizeStart = lightIndex * 2;
    var mapStart = lightIndex;
    var data = LightShadow2._combinedData;
    data.viewMatrix.set(this.light.viewMatrix.elements, viewStart);
    data.projectionMatrix.set(this.projectionMatrix.elements, projectionStart);
    data.bias[biasStart] = this.bias;
    data.intensity[intensityStart] = this.intensity;
    data.radius[radiusStart] = this.radius;
    data.mapSize[mapSizeStart] = this.mapSize.x;
    data.mapSize[mapSizeStart + 1] = this.mapSize.y;
    data.map[mapStart] = this.map;
  };
  _createClass(LightShadow2, [{
    key: "renderTarget",
    get: function get4() {
      return this._renderTarget;
    }
  }, {
    key: "map",
    get: function get4() {
      return this._renderTarget.getColorTexture();
    }
  }, {
    key: "mapSize",
    get: function get4() {
      return this._mapSize;
    }
  }]);
  return LightShadow2;
}();
LightShadow._viewMatFromLightProperty = Shader.getPropertyByName("u_viewMatFromLight");
LightShadow._projMatFromLightProperty = Shader.getPropertyByName("u_projMatFromLight");
LightShadow._shadowBiasProperty = Shader.getPropertyByName("u_shadowBias");
LightShadow._shadowIntensityProperty = Shader.getPropertyByName("u_shadowIntensity");
LightShadow._shadowRadiusProperty = Shader.getPropertyByName("u_shadowRadius");
LightShadow._shadowMapSizeProperty = Shader.getPropertyByName("u_shadowMapSize");
LightShadow._shadowMapsProperty = Shader.getPropertyByName("u_shadowMaps");
LightShadow._maxLight = 3;
LightShadow._combinedData = {
  viewMatrix: new Float32Array(16 * LightShadow._maxLight),
  projectionMatrix: new Float32Array(16 * LightShadow._maxLight),
  bias: new Float32Array(LightShadow._maxLight),
  intensity: new Float32Array(LightShadow._maxLight),
  radius: new Float32Array(LightShadow._maxLight),
  mapSize: new Float32Array(2 * LightShadow._maxLight),
  map: []
};
Object.defineProperty(Light.prototype, "enableShadow", {
  get: function get() {
    return this._enableShadow;
  },
  set: function set(enabled) {
    this._enableShadow = enabled;
    if (this._enableShadow) {
      if (this instanceof AmbientLight) {
        this._enableShadow = false;
        Logger.warn("Has no shadow!");
        return;
      }
      this.shadow = this.shadow || new LightShadow(this, {
        engine: this.engine,
        width: 512,
        height: 512
      });
      this.shadow.initShadowProjectionMatrix(this);
    }
  }
});
Object.defineProperty(Component.prototype, "receiveShadow", {
  get: function get2() {
    return this._recieveShadow;
  },
  set: function set2(enabled) {
    this._recieveShadow = enabled;
  }
});
Object.defineProperty(Component.prototype, "castShadow", {
  get: function get3() {
    return this._castShadow;
  },
  set: function set3(enabled) {
    this._castShadow = enabled;
  }
});
var ShadowMapMaterial = function(_Material) {
  _inheritsLoose(ShadowMapMaterial2, _Material);
  function ShadowMapMaterial2(engine) {
    var _this;
    _this = _Material.call(this, engine, Shader.find("shadow-map")) || this;
    _this.shaderData.enableMacro("O3_GENERATE_SHADOW_MAP");
    return _this;
  }
  return ShadowMapMaterial2;
}(Material);
var ShadowMapPass = function(_RenderPass) {
  _inheritsLoose(ShadowMapPass2, _RenderPass);
  function ShadowMapPass2(name, priority, renderTarget, replaceMaterial, mask, light) {
    var _this;
    _this = _RenderPass.call(this, name, priority, renderTarget, replaceMaterial, mask) || this;
    _this.light = void 0;
    _this.light = light;
    _this.clearColor = new Color(1, 1, 1, 1);
    return _this;
  }
  var _proto = ShadowMapPass2.prototype;
  _proto.preRender = function preRender(camera, queue) {
    var shaderData = this.replaceMaterial.shaderData;
    shaderData.setMatrix(ShadowMapPass2._viewMatFromLightProperty, this.light.viewMatrix);
    shaderData.setMatrix(ShadowMapPass2._projMatFromLightProperty, this.light.shadow.projectionMatrix);
  };
  return ShadowMapPass2;
}(RenderPass);
ShadowMapPass._viewMatFromLightProperty = Shader.getPropertyByName("u_viewMatFromLight");
ShadowMapPass._projMatFromLightProperty = Shader.getPropertyByName("u_projMatFromLight");
var ShadowMaterial = function(_Material) {
  _inheritsLoose(ShadowMaterial2, _Material);
  function ShadowMaterial2(engine) {
    var _this;
    _this = _Material.call(this, engine, Shader.find("shadow")) || this;
    var targetBlendState = _this.renderState.blendState.targetBlendState;
    targetBlendState.enabled = true;
    targetBlendState.sourceColorBlendFactor = targetBlendState.sourceAlphaBlendFactor = BlendFactor.DestinationColor;
    targetBlendState.destinationColorBlendFactor = targetBlendState.destinationAlphaBlendFactor = BlendFactor.Zero;
    _this.renderState.depthState.compareFunction = CompareFunction.LessEqual;
    _this.renderQueueType = RenderQueueType.Transparent;
    return _this;
  }
  return ShadowMaterial2;
}(Material);
var ShadowPass = function(_RenderPass) {
  _inheritsLoose(ShadowPass2, _RenderPass);
  function ShadowPass2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _RenderPass.call.apply(_RenderPass, [this].concat(args)) || this;
    _this.clearFlags = CameraClearFlags.None;
    return _this;
  }
  var _proto = ShadowPass2.prototype;
  _proto.preRender = function preRender(camera, queue) {
    this.enabled = false;
    var lightMgr = camera.scene.findFeature(LightFeature);
    var lights = lightMgr.visibleLights;
    var shaderData = this.replaceMaterial.shaderData;
    var pass = camera._renderPipeline.defaultRenderPass;
    this.renderTarget = pass.renderTarget;
    var shadowMapCount = 0;
    LightShadow.clearMap();
    for (var i = 0, len = lights.length; i < len; i++) {
      var lgt = lights[i];
      if (lgt.enableShadow) {
        lgt.shadow.appendData(shadowMapCount++);
      }
    }
    if (shadowMapCount) {
      this.enabled = true;
      LightShadow._updateShaderData(shaderData);
      shaderData.enableMacro("O3_SHADOW_MAP_COUNT", shadowMapCount.toString());
    } else {
      shaderData.disableMacro("O3_SHADOW_MAP_COUNT");
    }
  };
  return ShadowPass2;
}(RenderPass);
var ShadowFeature = function(_SceneFeature) {
  _inheritsLoose(ShadowFeature2, _SceneFeature);
  function ShadowFeature2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _SceneFeature.call.apply(_SceneFeature, [this].concat(args)) || this;
    _this._shadowPass = void 0;
    _this._shadowMapMaterial = void 0;
    return _this;
  }
  var _proto = ShadowFeature2.prototype;
  _proto.preRender = function preRender(scene, camera) {
    var lights = scene.findFeature(LightFeature).visibleLights;
    if (lights.length > 0) {
      if (!this._shadowPass) {
        this.addShadowPass(camera);
      }
      var renderPipeline = camera._renderPipeline;
      for (var i = 0, len = lights.length; i < len; i++) {
        var lgt = lights[i];
        if (lgt.enableShadow && !lgt.shadowMapPass) {
          lgt.shadowMapPass = this.addShadowMapPass(camera, lgt);
        } else if (!lgt.enableShadow && lgt.shadowMapPass) {
          renderPipeline.removeRenderPass(lgt.shadowMapPass);
          lgt.shadowMapPass = null;
        }
      }
      this.updatePassRenderFlag(renderPipeline._opaqueQueue);
      this.updatePassRenderFlag(renderPipeline._alphaTestQueue);
      this.updatePassRenderFlag(renderPipeline._transparentQueue);
    }
  };
  _proto.addShadowPass = function addShadowPass(camera) {
    var shadowMaterial = new ShadowMaterial(camera.engine);
    this._shadowPass = new ShadowPass("ShadowPass", 1, null, shadowMaterial, Layer.Layer30);
    var renderer = camera._renderPipeline;
    renderer.addRenderPass(this._shadowPass);
  };
  _proto.addShadowMapPass = function addShadowMapPass(camera, light) {
    this._shadowMapMaterial = this._shadowMapMaterial || new ShadowMapMaterial(camera.engine);
    var shadowMapPass = new ShadowMapPass("ShadowMapPass", -1, light.shadow.renderTarget, this._shadowMapMaterial, Layer.Layer31, light);
    var renderer = camera._renderPipeline;
    renderer.addRenderPass(shadowMapPass);
    return shadowMapPass;
  };
  _proto.updatePassRenderFlag = function updatePassRenderFlag(renderQueue) {
    var items = renderQueue.items;
    for (var i = 0, len = items.length; i < len; i++) {
      var item = items[i];
      var ability = item.component;
      var receiveShadow = ability.recieveShadow;
      var castShadow = ability.castShadow;
      if (receiveShadow === true) {
        ability.entity.layer |= Layer.Layer30;
      } else if (receiveShadow === false) {
        ability.entity.layer &= ~Layer.Layer30;
      }
      if (castShadow === true) {
        ability.entity.layer |= Layer.Layer31;
      } else if (castShadow === false) {
        ability.entity.layer &= ~Layer.Layer31;
      }
    }
  };
  return ShadowFeature2;
}(SceneFeature);
Scene.registerFeature(ShadowFeature);
Scene.registerFeature(LightFeature);
Scene.prototype.hasLight = hasLight;

// node_modules/@oasis-engine/rhi-webgl/dist/module.js
var GLCompressedTextureInternalFormat;
(function(GLCompressedTextureInternalFormat2) {
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_4X4_KHR"] = 37808] = "RGBA_ASTC_4X4_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_5X4_KHR"] = 37809] = "RGBA_ASTC_5X4_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_5X5_KHR"] = 37810] = "RGBA_ASTC_5X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_6X5_KHR"] = 37811] = "RGBA_ASTC_6X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_6X6_KHR"] = 37812] = "RGBA_ASTC_6X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_8X5_KHR"] = 37813] = "RGBA_ASTC_8X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_8X6_KHR"] = 37814] = "RGBA_ASTC_8X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_8X8_KHR"] = 37815] = "RGBA_ASTC_8X8_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X5_KHR"] = 37816] = "RGBA_ASTC_10X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X6_KHR"] = 37817] = "RGBA_ASTC_10X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X8_KHR"] = 37818] = "RGBA_ASTC_10X8_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X10_KHR"] = 37819] = "RGBA_ASTC_10X10_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_12X10_KHR"] = 37820] = "RGBA_ASTC_12X10_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_12X12_KHR"] = 37821] = "RGBA_ASTC_12X12_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_4X4_KHR"] = 37840] = "SRGB8_ALPHA8_ASTC_4X4_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_5X4_KHR"] = 37841] = "SRGB8_ALPHA8_ASTC_5X4_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_5X5_KHR"] = 37842] = "SRGB8_ALPHA8_ASTC_5X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_6X5_KHR"] = 37843] = "SRGB8_ALPHA8_ASTC_6X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_6X6_KHR"] = 37844] = "SRGB8_ALPHA8_ASTC_6X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_8X5_KHR"] = 37845] = "SRGB8_ALPHA8_ASTC_8X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_8X6_KHR"] = 37846] = "SRGB8_ALPHA8_ASTC_8X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_8X8_KHR"] = 37847] = "SRGB8_ALPHA8_ASTC_8X8_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X5_KHR"] = 37848] = "SRGB8_ALPHA8_ASTC_10X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X6_KHR"] = 37849] = "SRGB8_ALPHA8_ASTC_10X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X8_KHR"] = 37850] = "SRGB8_ALPHA8_ASTC_10X8_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X10_KHR"] = 37851] = "SRGB8_ALPHA8_ASTC_10X10_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_12X10_KHR"] = 37852] = "SRGB8_ALPHA8_ASTC_12X10_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_12X12_KHR"] = 37853] = "SRGB8_ALPHA8_ASTC_12X12_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_ETC1_WEBGL"] = 36196] = "RGB_ETC1_WEBGL";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["R11_EAC"] = 37488] = "R11_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SIGNED_R11_EAC"] = 37489] = "SIGNED_R11_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RG11_EAC"] = 37490] = "RG11_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SIGNED_RG11_EAC"] = 37491] = "SIGNED_RG11_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB8_ETC2"] = 37492] = "RGB8_ETC2";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ETC2"] = 37493] = "SRGB8_ETC2";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA8_ETC2_EAC"] = 37496] = "RGBA8_ETC2_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "SRGB8_ALPHA8_ETC2_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_PVRTC_4BPPV1_IMG"] = 35840] = "RGB_PVRTC_4BPPV1_IMG";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_PVRTC_2BPPV1_IMG"] = 35841] = "RGB_PVRTC_2BPPV1_IMG";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "RGBA_PVRTC_4BPPV1_IMG";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "RGBA_PVRTC_2BPPV1_IMG";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_S3TC_DXT1_EXT"] = 33776] = "RGB_S3TC_DXT1_EXT";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_S3TC_DXT1_EXT"] = 33777] = "RGBA_S3TC_DXT1_EXT";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_S3TC_DXT3_EXT"] = 33778] = "RGBA_S3TC_DXT3_EXT";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_S3TC_DXT5_EXT"] = 33779] = "RGBA_S3TC_DXT5_EXT";
})(GLCompressedTextureInternalFormat || (GLCompressedTextureInternalFormat = {}));
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread22(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  return Constructor;
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf2(subClass, superClass);
}
function _setPrototypeOf2(o, p) {
  _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf4(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf2(o, p);
}
var WebCanvas = function() {
  var _proto = WebCanvas2.prototype;
  _proto.resizeByClientSize = function resizeByClientSize(pixelRatio) {
    if (pixelRatio === void 0) {
      pixelRatio = window.devicePixelRatio;
    }
    var webCanvas = this._webCanvas;
    if (webCanvas instanceof HTMLCanvasElement) {
      var width = webCanvas.clientWidth;
      var height = webCanvas.clientHeight;
      this.width = width * pixelRatio;
      this.height = height * pixelRatio;
    }
  };
  function WebCanvas2(webCanvas) {
    this._webCanvas = void 0;
    this._width = void 0;
    this._height = void 0;
    this._scale = new Vector2();
    var width = webCanvas.width;
    var height = webCanvas.height;
    this._webCanvas = webCanvas;
    this._width = width;
    this._height = height;
  }
  _proto.setScale = function setScale(x, y) {
    this._scale.setValue(x, y);
    this.scale = this._scale;
  };
  _createClass2(WebCanvas2, [{
    key: "width",
    get: function get4() {
      return this._width;
    },
    set: function set4(value) {
      if (this._width !== value) {
        this._webCanvas.width = value;
        this._width = value;
      }
    }
  }, {
    key: "height",
    get: function get4() {
      return this._height;
    },
    set: function set4(value) {
      if (this._height !== value) {
        this._webCanvas.height = value;
        this._height = value;
      }
    }
  }, {
    key: "scale",
    get: function get4() {
      var webCanvas = this._webCanvas;
      if (webCanvas instanceof HTMLCanvasElement) {
        this._scale.setValue(webCanvas.clientWidth * devicePixelRatio / webCanvas.width, webCanvas.clientHeight * devicePixelRatio / webCanvas.height);
      }
      return this._scale;
    },
    set: function set4(value) {
      var webCanvas = this._webCanvas;
      if (webCanvas instanceof HTMLCanvasElement) {
        webCanvas.style.transformOrigin = "left top";
        webCanvas.style.transform = "scale(" + value.x + ", " + value.y + ")";
      }
    }
  }]);
  return WebCanvas2;
}();
var GLCapability = function() {
  function GLCapability2(rhi) {
    this._maxDrawBuffers = void 0;
    this._maxAnisoLevel = void 0;
    this._maxAntiAliasing = void 0;
    this._rhi = void 0;
    this.capabilityList = void 0;
    this._rhi = rhi;
    this.capabilityList = new Map();
    this._init();
    this._compatibleAllInterface();
  }
  var _proto = GLCapability2.prototype;
  _proto.canIUse = function canIUse(capabilityType) {
    return this.capabilityList.get(capabilityType);
  };
  _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(internalType) {
    var RGBA_ASTC_4X4_KHR = GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR, RGBA_ASTC_12X12_KHR = GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR, SRGB8_ALPHA8_ASTC_4X4_KHR = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_4X4_KHR, SRGB8_ALPHA8_ASTC_12X12_KHR = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_12X12_KHR, RGB_ETC1_WEBGL = GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL, R11_EAC = GLCompressedTextureInternalFormat.R11_EAC, SRGB8_ALPHA8_ETC2_EAC = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ETC2_EAC, RGB_PVRTC_4BPPV1_IMG = GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG, RGBA_PVRTC_2BPPV1_IMG = GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG, RGB_S3TC_DXT1_EXT = GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT, RGBA_S3TC_DXT5_EXT = GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT;
    if (internalType >= RGBA_ASTC_4X4_KHR && RGBA_ASTC_12X12_KHR <= RGBA_ASTC_12X12_KHR || internalType >= SRGB8_ALPHA8_ASTC_4X4_KHR && internalType <= SRGB8_ALPHA8_ASTC_12X12_KHR) {
      return this.canIUse(GLCapabilityType.astc);
    } else if (internalType === RGB_ETC1_WEBGL) {
      return this.canIUse(GLCapabilityType.etc1);
    } else if (internalType >= R11_EAC && internalType <= SRGB8_ALPHA8_ETC2_EAC) {
      return this.canIUse(GLCapabilityType.etc);
    } else if (internalType >= RGB_PVRTC_4BPPV1_IMG && internalType <= RGBA_PVRTC_2BPPV1_IMG) {
      return this.canIUse(GLCapabilityType.pvrtc);
    } else if (internalType >= RGB_S3TC_DXT1_EXT && internalType <= RGBA_S3TC_DXT5_EXT) {
      return this.canIUse(GLCapabilityType.s3tc);
    }
    return false;
  };
  _proto._init = function _init() {
    var cap = this.capabilityList;
    var isWebGL2 = this.rhi.isWebGL2;
    var requireExtension = this.rhi.requireExtension.bind(this.rhi);
    var shaderVertexID = GLCapabilityType.shaderVertexID, standardDerivatives = GLCapabilityType.standardDerivatives, shaderTextureLod = GLCapabilityType.shaderTextureLod, elementIndexUint = GLCapabilityType.elementIndexUint, depthTexture = GLCapabilityType.depthTexture, vertexArrayObject = GLCapabilityType.vertexArrayObject, instancedArrays = GLCapabilityType.instancedArrays, multipleSample = GLCapabilityType.multipleSample, drawBuffers = GLCapabilityType.drawBuffers, astc = GLCapabilityType.astc, astc_webkit = GLCapabilityType.astc_webkit, etc = GLCapabilityType.etc, etc_webkit = GLCapabilityType.etc_webkit, etc1 = GLCapabilityType.etc1, etc1_webkit = GLCapabilityType.etc1_webkit, pvrtc = GLCapabilityType.pvrtc, pvrtc_webkit = GLCapabilityType.pvrtc_webkit, s3tc = GLCapabilityType.s3tc, s3tc_webkit = GLCapabilityType.s3tc_webkit, textureFloat = GLCapabilityType.textureFloat, textureHalfFloat = GLCapabilityType.textureHalfFloat, textureFloatLinear = GLCapabilityType.textureFloatLinear, textureHalfFloatLinear = GLCapabilityType.textureHalfFloatLinear, WEBGL_colorBufferFloat = GLCapabilityType.WEBGL_colorBufferFloat, colorBufferFloat = GLCapabilityType.colorBufferFloat, colorBufferHalfFloat = GLCapabilityType.colorBufferHalfFloat, textureFilterAnisotropic = GLCapabilityType.textureFilterAnisotropic;
    cap.set(shaderVertexID, isWebGL2);
    cap.set(standardDerivatives, isWebGL2 || !!requireExtension(standardDerivatives));
    cap.set(shaderTextureLod, isWebGL2 || !!requireExtension(shaderTextureLod));
    cap.set(elementIndexUint, isWebGL2 || !!requireExtension(elementIndexUint));
    cap.set(depthTexture, isWebGL2 || !!requireExtension(depthTexture));
    cap.set(vertexArrayObject, isWebGL2 || !!requireExtension(vertexArrayObject));
    cap.set(instancedArrays, isWebGL2 || !!requireExtension(instancedArrays));
    cap.set(multipleSample, isWebGL2);
    cap.set(drawBuffers, isWebGL2 || !!requireExtension(drawBuffers));
    cap.set(textureFloat, isWebGL2 || !!requireExtension(textureFloat));
    cap.set(textureHalfFloat, isWebGL2 || !!requireExtension(textureHalfFloat));
    cap.set(textureFloatLinear, !!requireExtension(textureFloatLinear));
    cap.set(textureHalfFloatLinear, isWebGL2 || !!requireExtension(textureHalfFloatLinear));
    cap.set(colorBufferFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(WEBGL_colorBufferFloat));
    cap.set(colorBufferHalfFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(colorBufferHalfFloat));
    cap.set(textureFilterAnisotropic, !!requireExtension(textureFilterAnisotropic));
    cap.set(astc, !!(requireExtension(astc) || requireExtension(astc_webkit)));
    cap.set(etc, !!(requireExtension(etc) || requireExtension(etc_webkit)));
    cap.set(etc1, !!(requireExtension(etc1) || requireExtension(etc1_webkit)));
    cap.set(pvrtc, !!(requireExtension(pvrtc) || requireExtension(pvrtc_webkit)));
    cap.set(s3tc, !!(requireExtension(s3tc) || requireExtension(s3tc_webkit)));
  };
  _proto._compatibleInterface = function _compatibleInterface(capabilityType, flatItem) {
    var rhi = this.rhi;
    var gl = rhi.gl;
    var ext = null;
    if (ext = rhi.requireExtension(capabilityType)) {
      for (var _glKey in flatItem) {
        var _extensionKey = flatItem[_glKey];
        var extensionVal = ext[_extensionKey];
        if (extensionVal !== null && extensionVal !== void 0 && extensionVal.bind) {
          gl[_glKey] = extensionVal.bind(ext);
        } else {
          gl[_glKey] = extensionVal;
        }
      }
    }
  };
  _proto._compatibleAllInterface = function _compatibleAllInterface() {
    var depthTexture = GLCapabilityType.depthTexture, vertexArrayObject = GLCapabilityType.vertexArrayObject, instancedArrays = GLCapabilityType.instancedArrays, drawBuffers = GLCapabilityType.drawBuffers, textureFilterAnisotropic = GLCapabilityType.textureFilterAnisotropic, textureHalfFloat = GLCapabilityType.textureHalfFloat, colorBufferHalfFloat = GLCapabilityType.colorBufferHalfFloat, WEBGL_colorBufferFloat = GLCapabilityType.WEBGL_colorBufferFloat;
    var isWebGL2 = this.rhi.isWebGL2;
    if (!isWebGL2) {
      this._compatibleInterface(depthTexture, {
        UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
      });
      this._compatibleInterface(vertexArrayObject, {
        createVertexArray: "createVertexArrayOES",
        deleteVertexArray: "deleteVertexArrayOES",
        isVertexArray: "isVertexArrayOES",
        bindVertexArray: "bindVertexArrayOES"
      });
      this._compatibleInterface(instancedArrays, {
        drawArraysInstanced: "drawArraysInstancedANGLE",
        drawElementsInstanced: "drawElementsInstancedANGLE",
        vertexAttribDivisor: "vertexAttribDivisorANGLE"
      });
      this._compatibleInterface(drawBuffers, {
        MAX_DRAW_BUFFERS: "MAX_DRAW_BUFFERS_WEBGL"
      });
      var items = {};
      if (this.canIUse(GLCapabilityType.drawBuffers)) {
        var maxDrawBuffers = this.maxDrawBuffers;
        for (var i = 0; i < maxDrawBuffers; i++) {
          i != 0 && (items["COLOR_ATTACHMENT" + i] = "COLOR_ATTACHMENT" + i + "_WEBGL");
          items["DRAW_BUFFER" + i] = "DRAW_BUFFER" + i + "_WEBGL";
        }
        this._compatibleInterface(drawBuffers, _objectSpread22({
          drawBuffers: "drawBuffersWEBGL"
        }, items));
      }
      this._compatibleInterface(textureHalfFloat, {
        HAFL_FLOAT: "HALF_FLOAT_OES"
      });
      this._compatibleInterface(colorBufferHalfFloat, {
        RGBA16F: "RBGA16F_EXT"
      });
      this._compatibleInterface(WEBGL_colorBufferFloat, {
        RGBA32F: "RBGA32F_EXT"
      });
    }
    this._compatibleInterface(textureFilterAnisotropic, {
      TEXTURE_MAX_ANISOTROPY_EXT: "TEXTURE_MAX_ANISOTROPY_EXT"
    });
  };
  _createClass2(GLCapability2, [{
    key: "canUseFloatTextureBlendShape",
    get: function get4() {
      return this.canIUse(GLCapabilityType.shaderVertexID) && this.canIUse(GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
    }
  }, {
    key: "canIUseMoreJoints",
    get: function get4() {
      return this.canIUse(GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
    }
  }, {
    key: "maxDrawBuffers",
    get: function get4() {
      if (!this._maxDrawBuffers) {
        if (this.canIUse(GLCapabilityType.drawBuffers)) {
          this._maxDrawBuffers = this._rhi.gl.getParameter(this._rhi.gl.MAX_DRAW_BUFFERS);
        } else {
          this._maxDrawBuffers = 1;
        }
      }
      return this._maxDrawBuffers;
    }
  }, {
    key: "maxAnisoLevel",
    get: function get4() {
      if (!this._maxAnisoLevel) {
        var ext = this._rhi.requireExtension(GLCapabilityType.textureFilterAnisotropic);
        this._maxAnisoLevel = ext ? this._rhi.gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
      }
      return this._maxAnisoLevel;
    }
  }, {
    key: "maxAntiAliasing",
    get: function get4() {
      if (!this._maxAntiAliasing) {
        var gl = this._rhi.gl;
        var canMSAA = this.canIUse(GLCapabilityType.multipleSample);
        this._maxAntiAliasing = canMSAA ? gl.getParameter(gl.MAX_SAMPLES) : 1;
      }
      return this._maxAntiAliasing;
    }
  }, {
    key: "rhi",
    get: function get4() {
      return this._rhi;
    }
  }]);
  return GLCapability2;
}();
var GLExtensions = function() {
  function GLExtensions2(rhi) {
    this.rhi = void 0;
    this._requireResult = void 0;
    this.rhi = rhi;
    this._requireResult = {};
  }
  var _proto = GLExtensions2.prototype;
  _proto.requireExtension = function requireExtension(ext) {
    if (this._requireResult[ext] !== void 0) {
      return this._requireResult[ext];
    }
    this._requireResult[ext] = this.rhi.gl.getExtension(ext);
    return this._requireResult[ext];
  };
  return GLExtensions2;
}();
var GLPrimitive = function() {
  function GLPrimitive2(rhi, primitive) {
    this.attribLocArray = void 0;
    this._primitive = void 0;
    this.canUseInstancedArrays = void 0;
    this.gl = void 0;
    this.vao = new Map();
    this._useVao = void 0;
    this._primitive = primitive;
    this.canUseInstancedArrays = rhi.canIUse(GLCapabilityType.instancedArrays);
    this._useVao = rhi.canIUse(GLCapabilityType.vertexArrayObject);
    this.gl = rhi.gl;
  }
  var _proto = GLPrimitive2.prototype;
  _proto.draw = function draw(shaderProgram, subMesh) {
    var gl = this.gl;
    var primitive = this._primitive;
    if (this._useVao) {
      if (!this.vao.has(shaderProgram.id)) {
        this.registerVAO(shaderProgram);
      }
      var vao = this.vao.get(shaderProgram.id);
      gl.bindVertexArray(vao);
    } else {
      this.bindBufferAndAttrib(shaderProgram);
    }
    var _indexBufferBinding = primitive._indexBufferBinding, _instanceCount = primitive._instanceCount, _glIndexType = primitive._glIndexType, _glIndexByteCount = primitive._glIndexByteCount;
    var topology = subMesh.topology, start = subMesh.start, count = subMesh.count;
    if (!_instanceCount) {
      if (_indexBufferBinding) {
        if (this._useVao) {
          gl.drawElements(topology, count, _glIndexType, start * _glIndexByteCount);
        } else {
          var _nativeBuffer = _indexBufferBinding.buffer._nativeBuffer;
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer);
          gl.drawElements(topology, count, _glIndexType, start * _glIndexByteCount);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
      } else {
        gl.drawArrays(topology, start, count);
      }
    } else {
      if (this.canUseInstancedArrays) {
        if (_indexBufferBinding) {
          if (this._useVao) {
            gl.drawElementsInstanced(topology, count, _glIndexType, start * _glIndexByteCount, _instanceCount);
          } else {
            var _nativeBuffer2 = _indexBufferBinding.buffer._nativeBuffer;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer2);
            gl.drawElementsInstanced(topology, count, _glIndexType, start * _glIndexByteCount, _instanceCount);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }
        } else {
          gl.drawArraysInstanced(topology, start, count, _instanceCount);
        }
      } else {
        Logger.error("ANGLE_instanced_arrays extension is not supported");
      }
    }
    if (this._useVao) {
      gl.bindVertexArray(null);
    } else {
      this.disableAttrib();
    }
  };
  _proto.destroy = function destroy() {
    if (this._useVao) {
      var gl = this.gl;
      this.vao.forEach(function(vao) {
        gl.deleteVertexArray(vao);
      });
      this.vao.clear();
    }
  };
  _proto.bindBufferAndAttrib = function bindBufferAndAttrib(shaderProgram) {
    var gl = this.gl;
    var primitive = this._primitive;
    var vertexBufferBindings = primitive._vertexBufferBindings;
    this.attribLocArray = [];
    var attributeLocation = shaderProgram.attributeLocation;
    var attributes = primitive._vertexElementMap;
    var vbo;
    var lastBoundVbo;
    for (var name in attributeLocation) {
      var loc = attributeLocation[name];
      if (loc === -1)
        continue;
      var element = attributes[name];
      if (element) {
        var _vertexBufferBindings = vertexBufferBindings[element.bindingIndex], buffer = _vertexBufferBindings.buffer, stride = _vertexBufferBindings.stride;
        vbo = buffer._nativeBuffer;
        if (lastBoundVbo !== vbo) {
          lastBoundVbo = vbo;
          gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        }
        gl.enableVertexAttribArray(loc);
        var _element$_glElementIn = element._glElementInfo, size = _element$_glElementIn.size, type = _element$_glElementIn.type, normalized = _element$_glElementIn.normalized;
        gl.vertexAttribPointer(loc, size, type, normalized, stride, element.offset);
        if (this.canUseInstancedArrays) {
          gl.vertexAttribDivisor(loc, element.instanceStepRate);
        }
        this.attribLocArray.push(loc);
      } else {
        Logger.warn("vertex attribute not found: " + name);
      }
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
  };
  _proto.disableAttrib = function disableAttrib() {
    var gl = this.gl;
    for (var i = 0, l = this.attribLocArray.length; i < l; i++) {
      gl.disableVertexAttribArray(this.attribLocArray[i]);
    }
  };
  _proto.registerVAO = function registerVAO(shaderProgram) {
    var gl = this.gl;
    var vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    var _indexBufferBinding = this._primitive._indexBufferBinding;
    if (_indexBufferBinding) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _indexBufferBinding.buffer._nativeBuffer);
    }
    this.bindBufferAndAttrib(shaderProgram);
    gl.bindVertexArray(null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    this.disableAttrib();
    this.vao.set(shaderProgram.id, vao);
  };
  return GLPrimitive2;
}();
var GLTexture = function() {
  GLTexture2._isPowerOf2 = function _isPowerOf2(v) {
    return (v & v - 1) === 0;
  };
  GLTexture2._getFormatDetail = function _getFormatDetail(format, gl, isWebGL2) {
    switch (format) {
      case TextureFormat.R8G8B8:
        return {
          internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case TextureFormat.R8G8B8A8:
        return {
          internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case TextureFormat.R4G4B4A4:
        return {
          internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_4_4_4_4,
          isCompressed: false
        };
      case TextureFormat.R5G5B5A1:
        return {
          internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_5_5_5_1,
          isCompressed: false
        };
      case TextureFormat.R5G6B5:
        return {
          internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_SHORT_5_6_5,
          isCompressed: false
        };
      case TextureFormat.Alpha8:
        return {
          internalFormat: gl.ALPHA,
          baseFormat: gl.ALPHA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case TextureFormat.LuminanceAlpha:
        return {
          internalFormat: gl.LUMINANCE_ALPHA,
          baseFormat: gl.LUMINANCE_ALPHA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case TextureFormat.R32G32B32A32:
        return {
          internalFormat: gl.RGBA32F,
          baseFormat: gl.RGBA,
          dataType: gl.FLOAT,
          isCompressed: false
        };
      case TextureFormat.DXT1:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
          isCompressed: true
        };
      case TextureFormat.DXT5:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT,
          isCompressed: true
        };
      case TextureFormat.ETC1_RGB:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
          isCompressed: true
        };
      case TextureFormat.ETC2_RGB:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB8_ETC2,
          isCompressed: true
        };
      case TextureFormat.ETC2_RGBA5:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
          isCompressed: true
        };
      case TextureFormat.ETC2_RGBA8:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC,
          isCompressed: true
        };
      case TextureFormat.PVRTC_RGB2:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG,
          isCompressed: true
        };
      case TextureFormat.PVRTC_RGBA2:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
          isCompressed: true
        };
      case TextureFormat.PVRTC_RGB4:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
          isCompressed: true
        };
      case TextureFormat.PVRTC_RGBA4:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG,
          isCompressed: true
        };
      case TextureFormat.ASTC_4x4:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_5x5:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_6x6:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_8x8:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_10x10:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_12x12:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
          isCompressed: true
        };
      default:
        throw new Error("this TextureFormat is not supported in Oasis Engine: " + format);
    }
  };
  GLTexture2._getRenderBufferColorFormatDetail = function _getRenderBufferColorFormatDetail(format, gl, isWebGL2) {
    switch (format) {
      case RenderBufferColorFormat.R8G8B8:
        return {
          internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case RenderBufferColorFormat.R8G8B8A8:
        return {
          internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case RenderBufferColorFormat.R4G4B4A4:
        return {
          internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_4_4_4_4,
          isCompressed: false
        };
      case RenderBufferColorFormat.R5G5B5A1:
        return {
          internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_5_5_5_1,
          isCompressed: false
        };
      case RenderBufferColorFormat.R5G6B5:
        return {
          internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_SHORT_5_6_5,
          isCompressed: false
        };
      case RenderBufferColorFormat.Alpha8:
        return {
          internalFormat: gl.ALPHA,
          baseFormat: gl.ALPHA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case RenderBufferColorFormat.R16G16B16A16:
        return {
          internalFormat: gl.RGBA16F,
          baseFormat: gl.RGBA,
          dataType: gl.HALF_FLOAT,
          isCompressed: false
        };
      case RenderBufferColorFormat.R32G32B32A32:
        return {
          internalFormat: gl.RGBA32F,
          baseFormat: gl.RGBA,
          dataType: gl.FLOAT,
          isCompressed: false
        };
      default:
        throw new Error("this RenderBufferColorFormat is not supported in Oasis Engine: " + format);
    }
  };
  GLTexture2._getRenderBufferDepthFormatDetail = function _getRenderBufferDepthFormatDetail(format, gl, isWebGL2) {
    switch (format) {
      case RenderBufferDepthFormat.Depth:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_INT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case RenderBufferDepthFormat.DepthStencil:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: gl.UNSIGNED_INT_24_8,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };
      case RenderBufferDepthFormat.Stencil:
        return {
          internalFormat: gl.STENCIL_INDEX8,
          baseFormat: gl.STENCIL_ATTACHMENT,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false,
          attachment: gl.STENCIL_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth16:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT16,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.UNSIGNED_INT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth24:
        return {
          internalFormat: gl.DEPTH_COMPONENT24,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.UNSIGNED_INT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth32:
        return {
          internalFormat: gl.DEPTH_COMPONENT32F,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.FLOAT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth24Stencil8:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: gl.UNSIGNED_INT_24_8,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth32Stencil8:
        return {
          internalFormat: gl.DEPTH32F_STENCIL8,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };
      default:
        throw new Error("this RenderBufferDepthFormat is not supported in Oasis Engine: " + format);
    }
  };
  GLTexture2._supportTextureFormat = function _supportTextureFormat(format, rhi) {
    var isSupported = true;
    switch (format) {
      case TextureFormat.R32G32B32A32:
        {
          if (!rhi.canIUse(GLCapabilityType.textureFloat)) {
            isSupported = false;
          }
        }
        break;
    }
    return isSupported;
  };
  GLTexture2._supportRenderBufferColorFormat = function _supportRenderBufferColorFormat(format, rhi) {
    var isSupported = true;
    switch (format) {
      case RenderBufferColorFormat.R32G32B32A32:
        {
          if (!rhi.canIUse(GLCapabilityType.colorBufferFloat) || !rhi.canIUse(GLCapabilityType.textureFloat)) {
            isSupported = false;
          }
        }
        break;
      case RenderBufferColorFormat.R16G16B16A16:
        {
          if (!rhi.canIUse(GLCapabilityType.colorBufferHalfFloat) || !rhi.canIUse(GLCapabilityType.textureHalfFloat)) {
            isSupported = false;
          }
        }
        break;
    }
    return isSupported;
  };
  GLTexture2._supportRenderBufferDepthFormat = function _supportRenderBufferDepthFormat(format, rhi, isTexture) {
    var isWebGL2 = rhi.isWebGL2;
    var isSupported = true;
    if (isTexture && !rhi.canIUse(GLCapabilityType.depthTexture)) {
      return false;
    }
    switch (format) {
      case RenderBufferDepthFormat.Stencil:
        {
          isSupported = false;
        }
        break;
      case RenderBufferDepthFormat.Depth24:
      case RenderBufferDepthFormat.Depth32:
      case RenderBufferDepthFormat.Depth32Stencil8:
        {
          if (!isWebGL2) {
            isSupported = false;
          }
        }
        break;
    }
    return isSupported;
  };
  function GLTexture2(rhi, texture, target) {
    this._texture = void 0;
    this._glTexture = void 0;
    this._rhi = void 0;
    this._gl = void 0;
    this._isWebGL2 = void 0;
    this._target = void 0;
    this._formatDetail = void 0;
    this._texture = texture;
    this._rhi = rhi;
    this._gl = rhi.gl;
    this._isWebGL2 = rhi.isWebGL2;
    this._target = target;
    this._glTexture = this._gl.createTexture();
  }
  var _proto = GLTexture2.prototype;
  _proto.destroy = function destroy() {
    this._gl.deleteTexture(this._glTexture);
    this._texture = null;
    this._glTexture = null;
    this._formatDetail = null;
  };
  _proto.generateMipmaps = function generateMipmaps() {
    this._bind();
    this._gl.generateMipmap(this._target);
  };
  _proto._bind = function _bind() {
    this._rhi.bindTexture(this);
  };
  _proto._initMipmap = function _initMipmap(isCube) {
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var _this$_formatDetail = this._formatDetail, internalFormat = _this$_formatDetail.internalFormat, baseFormat = _this$_formatDetail.baseFormat, dataType = _this$_formatDetail.dataType;
    var _this$_texture = this._texture, mipmapCount = _this$_texture.mipmapCount, width = _this$_texture.width, height = _this$_texture.height;
    this._bind();
    if (isWebGL2 && !(baseFormat === gl.LUMINANCE_ALPHA || baseFormat === gl.ALPHA)) {
      gl.texStorage2D(this._target, mipmapCount, internalFormat, width, height);
    } else {
      if (baseFormat !== internalFormat) {
        internalFormat = baseFormat;
      }
      if (!isCube) {
        for (var i = 0; i < mipmapCount; i++) {
          var mipWidth = Math.max(1, width >> i);
          var mipHeight = Math.max(1, height >> i);
          gl.texImage2D(this._target, i, internalFormat, mipWidth, mipHeight, 0, baseFormat, dataType, null);
        }
      } else {
        for (var _i = 0; _i < mipmapCount; _i++) {
          var size = Math.max(1, width >> _i);
          for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, _i, internalFormat, size, size, 0, baseFormat, dataType, null);
          }
        }
      }
    }
  };
  _proto._getPixelBuffer = function _getPixelBuffer(face, x, y, width, height, out) {
    var gl = this._gl;
    var _this$_formatDetail2 = this._formatDetail, baseFormat = _this$_formatDetail2.baseFormat, dataType = _this$_formatDetail2.dataType;
    if (!GLTexture2._readFrameBuffer) {
      GLTexture2._readFrameBuffer = gl.createFramebuffer();
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, GLTexture2._readFrameBuffer);
    if (face != null) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, this._glTexture, 0);
    } else {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._glTexture, 0);
    }
    gl.readPixels(x, y, width, height, baseFormat, dataType, out);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  };
  _proto._setWrapMode = function _setWrapMode(value, pname) {
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var target = this._target;
    var _this$_texture2 = this._texture, width = _this$_texture2.width, height = _this$_texture2.height;
    if (!isWebGL2 && value !== TextureWrapMode.Clamp && (!GLTexture2._isPowerOf2(width) || !GLTexture2._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for REPEAT or MIRRORED_REPEAT in WebGL1,and has automatically downgraded to CLAMP_TO_EDGE");
      value = TextureWrapMode.Clamp;
    }
    switch (value) {
      case TextureWrapMode.Clamp:
        gl.texParameteri(target, pname, gl.CLAMP_TO_EDGE);
        break;
      case TextureWrapMode.Repeat:
        gl.texParameteri(target, pname, gl.REPEAT);
        break;
      case TextureWrapMode.Mirror:
        gl.texParameteri(target, pname, gl.MIRRORED_REPEAT);
        break;
    }
  };
  _createClass2(GLTexture2, [{
    key: "wrapModeU",
    set: function set4(value) {
      this._bind();
      this._setWrapMode(value, this._gl.TEXTURE_WRAP_S);
    }
  }, {
    key: "wrapModeV",
    set: function set4(value) {
      this._bind();
      this._setWrapMode(value, this._gl.TEXTURE_WRAP_T);
    }
  }, {
    key: "filterMode",
    set: function set4(value) {
      var gl = this._gl;
      var target = this._target;
      var _mipmap = this._texture._mipmap;
      this._bind();
      switch (value) {
        case TextureFilterMode.Point:
          gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST);
          break;
        case TextureFilterMode.Bilinear:
          gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR);
          break;
        case TextureFilterMode.Trilinear:
          gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
          break;
      }
    }
  }, {
    key: "anisoLevel",
    set: function set4(value) {
      var gl = this._gl;
      this._bind();
      gl.texParameterf(this._target, gl.TEXTURE_MAX_ANISOTROPY_EXT, value);
    }
  }]);
  return GLTexture2;
}();
GLTexture._readFrameBuffer = null;
var GLRenderColorTexture = function(_GLTexture) {
  _inheritsLoose2(GLRenderColorTexture2, _GLTexture);
  function GLRenderColorTexture2(rhi, texture) {
    var _this;
    _this = _GLTexture.call(this, rhi, texture, texture.isCube ? rhi.gl.TEXTURE_CUBE_MAP : rhi.gl.TEXTURE_2D) || this;
    var format = texture.format, _mipmap = texture._mipmap, width = texture.width, height = texture.height, isCube = texture.isCube;
    var isWebGL2 = _this._isWebGL2;
    if (!GLTexture._supportRenderBufferColorFormat(format, rhi)) {
      throw new Error("RenderBufferColorFormat is not supported:" + RenderBufferColorFormat[format]);
    }
    if (isCube && width !== height) {
      throw new Error("The cube texture must have the same width and height");
    }
    if (_mipmap && !isWebGL2 && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      texture._mipmap = false;
      texture._mipmapCount = texture._getMipmapCount();
    }
    _this._formatDetail = GLTexture._getRenderBufferColorFormatDetail(format, _this._gl, isWebGL2);
    _this._initMipmap(isCube);
    return _this;
  }
  var _proto = GLRenderColorTexture2.prototype;
  _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, out) {
    _GLTexture.prototype._getPixelBuffer.call(this, face, x, y, width, height, out);
  };
  return GLRenderColorTexture2;
}(GLTexture);
var GLRenderDepthTexture = function(_GLTexture) {
  _inheritsLoose2(GLRenderDepthTexture2, _GLTexture);
  function GLRenderDepthTexture2(rhi, texture) {
    var _this;
    _this = _GLTexture.call(this, rhi, texture, texture.isCube ? rhi.gl.TEXTURE_CUBE_MAP : rhi.gl.TEXTURE_2D) || this;
    var format = texture.format, _mipmap = texture._mipmap, width = texture.width, height = texture.height, isCube = texture.isCube;
    var isWebGL2 = _this._isWebGL2;
    if (!GLTexture._supportRenderBufferDepthFormat(format, rhi, true)) {
      throw new Error("RenderBufferDepthFormat is not supported:" + RenderBufferDepthFormat[format]);
    }
    if (isCube && width !== height) {
      throw new Error("The cube texture must have the same width and height");
    }
    if (_mipmap && !isWebGL2 && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      texture._mipmap = false;
      texture._mipmapCount = texture._getMipmapCount();
    }
    _this._formatDetail = GLTexture._getRenderBufferDepthFormatDetail(format, _this._gl, isWebGL2);
    _this._initMipmap(isCube);
    return _this;
  }
  return GLRenderDepthTexture2;
}(GLTexture);
var GLRenderStates = function() {
  function GLRenderStates2(gl) {
    this._gl = void 0;
    this._parameters = {};
    this._gl = gl;
    this._parameters = {};
    this._parameters[gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    this._parameters[gl.MAX_VERTEX_UNIFORM_VECTORS] = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    this._parameters[gl.MAX_VERTEX_ATTRIBS] = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    this._parameters[gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    this._parameters[gl.MAX_TEXTURE_SIZE] = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    gl.colorMask(true, true, true, true);
    gl.blendColor(0, 0, 0, 0);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LESS);
    gl.depthMask(true);
    gl.disable(gl.STENCIL_TEST);
    gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 0, 255);
    gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 0, 255);
    gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilMask(255);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.polygonOffset(0, 0);
  }
  var _proto = GLRenderStates2.prototype;
  _proto.getParameter = function getParameter(pname) {
    return this._parameters[pname];
  };
  return GLRenderStates2;
}();
var GLRenderTarget = function() {
  function GLRenderTarget2(rhi, target) {
    this._gl = void 0;
    this._isWebGL2 = void 0;
    this._target = void 0;
    this._frameBuffer = void 0;
    this._MSAAFrameBuffer = void 0;
    this._depthRenderBuffer = void 0;
    this._MSAAColorRenderBuffers = [];
    this._MSAADepthRenderBuffer = void 0;
    this._oriDrawBuffers = void 0;
    this._blitDrawBuffers = void 0;
    this._gl = rhi.gl;
    this._isWebGL2 = rhi.isWebGL2;
    this._target = target;
    var _colorTextures = target._colorTextures, _depth = target._depth, width = target.width, height = target.height;
    if (!(_depth instanceof RenderDepthTexture) && !GLTexture._supportRenderBufferDepthFormat(_depth, rhi, false)) {
      throw new Error("RenderBufferDepthFormat is not supported:" + RenderBufferDepthFormat[_depth]);
    }
    if (_colorTextures.length > 1 && !rhi.canIUse(GLCapabilityType.drawBuffers)) {
      throw new Error("MRT is not supported");
    }
    if (_colorTextures.some(function(v) {
      return v.width !== width || v.height !== height;
    })) {
      throw new Error("RenderColorTexture's size must as same as RenderTarget");
    }
    if (_depth instanceof RenderDepthTexture && (_depth.width !== width || _depth.height !== height)) {
      throw new Error("RenderDepthTexture's size must as same as RenderTarget");
    }
    if (_colorTextures.length > 1 && _colorTextures.some(function(v) {
      return v.isCube;
    })) {
      throw new Error("MRT+Cube+[,MSAA] is not supported");
    }
    var maxAntiAliasing = rhi.capability.maxAntiAliasing;
    if (target.antiAliasing > maxAntiAliasing) {
      Logger.warn("MSAA antiAliasing exceeds the limit and is automatically downgraded to:" + maxAntiAliasing);
      target._antiAliasing = maxAntiAliasing;
    }
    this._frameBuffer = this._gl.createFramebuffer();
    this._bindMainFBO();
    if (target.antiAliasing > 1) {
      this._MSAAFrameBuffer = this._gl.createFramebuffer();
      this._bindMSAAFBO();
    }
  }
  var _proto = GLRenderTarget2.prototype;
  _proto.setRenderTargetFace = function setRenderTargetFace(faceIndex) {
    var gl = this._gl;
    var colorTexture = this._target.getColorTexture(0);
    var depthTexture = this._target.depthTexture;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    if (colorTexture !== null && colorTexture !== void 0 && colorTexture.isCube) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, colorTexture._platformTexture._glTexture, 0);
    }
    if (depthTexture !== null && depthTexture !== void 0 && depthTexture.isCube) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, depthTexture._platformTexture._formatDetail.attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, depthTexture._platformTexture._glTexture, 0);
    }
    this._activeRenderTarget();
  };
  _proto.blitRenderTarget = function blitRenderTarget() {
    if (!this._MSAAFrameBuffer)
      return;
    var gl = this._gl;
    var mask = gl.COLOR_BUFFER_BIT | (this._target.depthTexture ? gl.DEPTH_BUFFER_BIT : 0);
    var _this$_target = this._target, colorTextureCount = _this$_target.colorTextureCount, width = _this$_target.width, height = _this$_target.height;
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._MSAAFrameBuffer);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);
    for (var textureIndex = 0; textureIndex < colorTextureCount; textureIndex++) {
      var attachment = gl.COLOR_ATTACHMENT0 + textureIndex;
      this._blitDrawBuffers[textureIndex] = attachment;
      gl.readBuffer(attachment);
      gl.drawBuffers(this._blitDrawBuffers);
      gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);
      this._blitDrawBuffers[textureIndex] = gl.NONE;
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  };
  _proto.destroy = function destroy() {
    var gl = this._gl;
    this._frameBuffer && gl.deleteFramebuffer(this._frameBuffer);
    this._depthRenderBuffer && gl.deleteRenderbuffer(this._depthRenderBuffer);
    this._MSAAFrameBuffer && gl.deleteFramebuffer(this._MSAAFrameBuffer);
    this._MSAADepthRenderBuffer && gl.deleteRenderbuffer(this._MSAADepthRenderBuffer);
    for (var i = 0; i < this._MSAAColorRenderBuffers.length; i++) {
      gl.deleteRenderbuffer(this._MSAAColorRenderBuffers[i]);
    }
    this._frameBuffer = null;
    this._depthRenderBuffer = null;
    this._MSAAFrameBuffer = null;
    this._MSAAColorRenderBuffers.length = 0;
    this._MSAADepthRenderBuffer = null;
  };
  _proto._activeRenderTarget = function _activeRenderTarget() {
    var gl = this._gl;
    if (this._MSAAFrameBuffer) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    }
  };
  _proto._bindMainFBO = function _bindMainFBO() {
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var _this$_target2 = this._target, _depth = _this$_target2._depth, colorTextureCount = _this$_target2.colorTextureCount, width = _this$_target2.width, height = _this$_target2.height;
    var drawBuffers = new Array(colorTextureCount);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    for (var i = 0; i < colorTextureCount; i++) {
      var colorTexture = this._target.getColorTexture(i);
      var attachment = gl.COLOR_ATTACHMENT0 + i;
      drawBuffers[i] = attachment;
      if (!colorTexture.isCube) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, colorTexture._platformTexture._glTexture, 0);
      }
    }
    if (colorTextureCount > 1) {
      gl.drawBuffers(drawBuffers);
    }
    this._oriDrawBuffers = drawBuffers;
    if (_depth !== null) {
      if (_depth instanceof RenderDepthTexture) {
        if (!_depth.isCube) {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, _depth._platformTexture._formatDetail.attachment, gl.TEXTURE_2D, _depth._platformTexture._glTexture, 0);
        }
      } else if (this._target.antiAliasing <= 1) {
        var _GLTexture$_getRender = GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2), internalFormat = _GLTexture$_getRender.internalFormat, _attachment = _GLTexture$_getRender.attachment;
        var depthRenderBuffer = gl.createRenderbuffer();
        this._depthRenderBuffer = depthRenderBuffer;
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, _attachment, gl.RENDERBUFFER, depthRenderBuffer);
      }
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  };
  _proto._bindMSAAFBO = function _bindMSAAFBO() {
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var MSAADepthRenderBuffer = gl.createRenderbuffer();
    var _this$_target3 = this._target, _depth = _this$_target3._depth, colorTextureCount = _this$_target3.colorTextureCount, antiAliasing = _this$_target3.antiAliasing, width = _this$_target3.width, height = _this$_target3.height;
    this._blitDrawBuffers = new Array(colorTextureCount);
    this._MSAADepthRenderBuffer = MSAADepthRenderBuffer;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
    for (var i = 0; i < colorTextureCount; i++) {
      var MSAAColorRenderBuffer = gl.createRenderbuffer();
      this._MSAAColorRenderBuffers[i] = MSAAColorRenderBuffer;
      this._blitDrawBuffers[i] = gl.NONE;
      gl.bindRenderbuffer(gl.RENDERBUFFER, MSAAColorRenderBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, antiAliasing, this._target.getColorTexture(i)._platformTexture._formatDetail.internalFormat, width, height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, MSAAColorRenderBuffer);
    }
    gl.drawBuffers(this._oriDrawBuffers);
    if (_depth !== null) {
      var _ref = _depth instanceof RenderDepthTexture ? _depth._platformTexture._formatDetail : GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2), internalFormat = _ref.internalFormat, attachment = _ref.attachment;
      gl.bindRenderbuffer(gl.RENDERBUFFER, MSAADepthRenderBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, antiAliasing, internalFormat, width, height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, MSAADepthRenderBuffer);
    }
    this._checkFrameBuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  };
  _proto._checkFrameBuffer = function _checkFrameBuffer() {
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    switch (e) {
      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete");
      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        throw new Error("There is no attachment");
      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        throw new Error(" Height and width of the attachment are not the same.");
      case gl.FRAMEBUFFER_UNSUPPORTED:
        throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer");
    }
    if (isWebGL2 && e === gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {
      throw new Error("The values of gl.RENDERBUFFER_SAMPLES are different among attached renderbuffers, or are non-zero if the attached images are a mix of renderbuffers and textures.");
    }
  };
  return GLRenderTarget2;
}();
var GLTexture2D = function(_GLTexture) {
  _inheritsLoose2(GLTexture2D2, _GLTexture);
  function GLTexture2D2(rhi, texture2D) {
    var _this;
    _this = _GLTexture.call(this, rhi, texture2D, rhi.gl.TEXTURE_2D) || this;
    _this._compressedMipFilled = 0;
    var format = texture2D.format, _mipmap = texture2D._mipmap, width = texture2D.width, height = texture2D.height;
    var isWebGL2 = _this._isWebGL2;
    if (!GLTexture._supportTextureFormat(format, rhi)) {
      throw new Error("Texture format is not supported:" + TextureFormat[format]);
    }
    if (_mipmap && !isWebGL2 && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      texture2D._mipmap = false;
      texture2D._mipmapCount = texture2D._getMipmapCount();
    }
    _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, isWebGL2);
    _this._formatDetail.isCompressed && !isWebGL2 || _this._initMipmap(false);
    return _this;
  }
  var _proto = GLTexture2D2.prototype;
  _proto.setPixelBuffer = function setPixelBuffer(colorBuffer, mipLevel, x, y, width, height) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var _this$_formatDetail = this._formatDetail, internalFormat = _this$_formatDetail.internalFormat, baseFormat = _this$_formatDetail.baseFormat, dataType = _this$_formatDetail.dataType, isCompressed = _this$_formatDetail.isCompressed;
    var mipWidth = Math.max(1, this._texture.width >> mipLevel);
    var mipHeight = Math.max(1, this._texture.height >> mipLevel);
    x = x || 0;
    y = y || 0;
    width = width || mipWidth - x;
    height = height || mipHeight - y;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
    if (isCompressed) {
      var mipBit = 1 << mipLevel;
      if (isWebGL2 || this._compressedMipFilled & mipBit) {
        gl.compressedTexSubImage2D(this._target, mipLevel, x, y, width, height, internalFormat, colorBuffer);
      } else {
        gl.compressedTexImage2D(this._target, mipLevel, internalFormat, width, height, 0, colorBuffer);
        this._compressedMipFilled |= mipBit;
      }
    } else {
      gl.texSubImage2D(this._target, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
    }
  };
  _proto.setImageSource = function setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    if (flipY === void 0) {
      flipY = false;
    }
    if (premultiplyAlpha === void 0) {
      premultiplyAlpha = false;
    }
    var gl = this._gl;
    var _this$_formatDetail2 = this._formatDetail, baseFormat = _this$_formatDetail2.baseFormat, dataType = _this$_formatDetail2.dataType;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
    gl.texSubImage2D(this._target, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
  };
  _proto.getPixelBuffer = function getPixelBuffer(x, y, width, height, out) {
    if (this._formatDetail.isCompressed) {
      throw new Error("Unable to read compressed texture");
    }
    _GLTexture.prototype._getPixelBuffer.call(this, null, x, y, width, height, out);
  };
  return GLTexture2D2;
}(GLTexture);
var GLTextureCubeMap = function(_GLTexture) {
  _inheritsLoose2(GLTextureCubeMap2, _GLTexture);
  function GLTextureCubeMap2(rhi, textureCube) {
    var _this;
    _this = _GLTexture.call(this, rhi, textureCube, rhi.gl.TEXTURE_CUBE_MAP) || this;
    _this._compressedFaceFilled = [0, 0, 0, 0, 0, 0];
    var format = textureCube.format, _mipmap = textureCube._mipmap, size = textureCube.width;
    var isWebGL2 = _this._isWebGL2;
    if (!GLTexture._supportTextureFormat(format, rhi)) {
      throw new Error("Texture format is not supported:" + TextureFormat[format]);
    }
    if (_mipmap && !isWebGL2 && !GLTexture._isPowerOf2(size)) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      textureCube._mipmap = false;
      textureCube._mipmapCount = textureCube._getMipmapCount();
    }
    _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, isWebGL2);
    _this._formatDetail.isCompressed && !isWebGL2 || _this._initMipmap(true);
    return _this;
  }
  var _proto = GLTextureCubeMap2.prototype;
  _proto.setPixelBuffer = function setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var _this$_formatDetail = this._formatDetail, internalFormat = _this$_formatDetail.internalFormat, baseFormat = _this$_formatDetail.baseFormat, dataType = _this$_formatDetail.dataType, isCompressed = _this$_formatDetail.isCompressed;
    var mipSize = Math.max(1, this._texture.width >> mipLevel);
    x = x || 0;
    y = y || 0;
    width = width || mipSize - x;
    height = height || mipSize - y;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
    if (isCompressed) {
      var mipBit = 1 << mipLevel;
      if (isWebGL2 || this._compressedFaceFilled[face] & mipBit) {
        gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, internalFormat, colorBuffer);
      } else {
        gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, internalFormat, width, height, 0, colorBuffer);
        this._compressedFaceFilled[face] |= mipBit;
      }
    } else {
      gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
    }
  };
  _proto.setImageSource = function setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    if (flipY === void 0) {
      flipY = false;
    }
    if (premultiplyAlpha === void 0) {
      premultiplyAlpha = false;
    }
    var gl = this._gl;
    var _this$_formatDetail2 = this._formatDetail, baseFormat = _this$_formatDetail2.baseFormat, dataType = _this$_formatDetail2.dataType;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
    gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
  };
  _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, out) {
    if (this._formatDetail.isCompressed) {
      throw new Error("Unable to read compressed texture");
    }
    _GLTexture.prototype._getPixelBuffer.call(this, face, x, y, width, height, out);
  };
  return GLTextureCubeMap2;
}(GLTexture);
var WebGLMode;
(function(WebGLMode2) {
  WebGLMode2[WebGLMode2["Auto"] = 0] = "Auto";
  WebGLMode2[WebGLMode2["WebGL2"] = 1] = "WebGL2";
  WebGLMode2[WebGLMode2["WebGL1"] = 2] = "WebGL1";
})(WebGLMode || (WebGLMode = {}));
var WebGLRenderer = function() {
  function WebGLRenderer2(options) {
    if (options === void 0) {
      options = {};
    }
    this._currentBind = void 0;
    this._options = void 0;
    this._gl = void 0;
    this._renderStates = void 0;
    this._extensions = void 0;
    this._capability = void 0;
    this._isWebGL2 = void 0;
    this._activeTextureID = void 0;
    this._activeTextures = new Array(32);
    this._lastViewport = new Vector4(null, null, null, null);
    this._lastClearColor = new Color(null, null, null, null);
    this._options = options;
  }
  var _proto = WebGLRenderer2.prototype;
  _proto.init = function init(canvas) {
    var option = this._options;
    option.alpha === void 0 && (option.alpha = false);
    option.stencil === void 0 && (option.stencil = true);
    var webCanvas = canvas._webCanvas;
    var webGLMode = option.webGLMode || WebGLMode.Auto;
    var gl;
    if (webGLMode == WebGLMode.Auto || webGLMode == WebGLMode.WebGL2) {
      gl = webCanvas.getContext("webgl2", option);
      if (!gl && webCanvas instanceof HTMLCanvasElement) {
        gl = webCanvas.getContext("experimental-webgl2", option);
      }
      this._isWebGL2 = true;
      if (gl && !gl.deleteQuery) {
        this._isWebGL2 = false;
      }
    }
    if (!gl) {
      if (webGLMode == WebGLMode.Auto || webGLMode == WebGLMode.WebGL1) {
        gl = webCanvas.getContext("webgl", option);
        if (!gl && webCanvas instanceof HTMLCanvasElement) {
          gl = webCanvas.getContext("experimental-webgl", option);
        }
        this._isWebGL2 = false;
      }
    }
    if (!gl) {
      throw new Error("Get GL Context FAILED.");
    }
    this._gl = gl;
    this._activeTextureID = gl.TEXTURE0;
    this._renderStates = new GLRenderStates(gl);
    this._extensions = new GLExtensions(this);
    this._capability = new GLCapability(this);
    gl.activeTexture(gl.TEXTURE0);
    this._options = null;
  };
  _proto.createPlatformPrimitive = function createPlatformPrimitive(primitive) {
    return new GLPrimitive(this, primitive);
  };
  _proto.createPlatformTexture2D = function createPlatformTexture2D(texture2D) {
    return new GLTexture2D(this, texture2D);
  };
  _proto.createPlatformTextureCubeMap = function createPlatformTextureCubeMap(textureCube) {
    return new GLTextureCubeMap(this, textureCube);
  };
  _proto.createPlatformRenderColorTexture = function createPlatformRenderColorTexture(texture) {
    return new GLRenderColorTexture(this, texture);
  };
  _proto.createPlatformRenderDepthTexture = function createPlatformRenderDepthTexture(texture) {
    return new GLRenderDepthTexture(this, texture);
  };
  _proto.createPlatformRenderTarget = function createPlatformRenderTarget(target) {
    return new GLRenderTarget(this, target);
  };
  _proto.requireExtension = function requireExtension(ext) {
    return this._extensions.requireExtension(ext);
  };
  _proto.canIUse = function canIUse(capabilityType) {
    return this.capability.canIUse(capabilityType);
  };
  _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(type) {
    return this.capability.canIUseCompressedTextureInternalFormat(type);
  };
  _proto.viewport = function viewport(x, y, width, height) {
    var gl = this._gl;
    var lv = this._lastViewport;
    if (x !== lv.x || y !== lv.y || width !== lv.z || height !== lv.w) {
      gl.viewport(x, y, width, height);
      lv.setValue(x, y, width, height);
    }
  };
  _proto.colorMask = function colorMask(r, g, b, a) {
    this._gl.colorMask(r, g, b, a);
  };
  _proto.clearRenderTarget = function clearRenderTarget(engine, clearFlags, clearColor) {
    var gl = this._gl;
    var _engine$_lastRenderSt = engine._lastRenderState, targetBlendState = _engine$_lastRenderSt.blendState.targetBlendState, depthState = _engine$_lastRenderSt.depthState, stencilState = _engine$_lastRenderSt.stencilState;
    var clearFlag = gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT;
    if (clearFlags === CameraClearFlags.DepthColor) {
      clearFlag |= gl.COLOR_BUFFER_BIT;
      var lc = this._lastClearColor;
      var r = clearColor.r, g = clearColor.g, b = clearColor.b, a = clearColor.a;
      if (clearColor && (r !== lc.r || g !== lc.g || b !== lc.b || a !== lc.a)) {
        gl.clearColor(r, g, b, a);
        lc.setValue(r, g, b, a);
      }
      if (targetBlendState.colorWriteMask !== ColorWriteMask.All) {
        gl.colorMask(true, true, true, true);
        targetBlendState.colorWriteMask = ColorWriteMask.All;
      }
    }
    if (depthState.writeEnabled !== true) {
      gl.depthMask(true);
      depthState.writeEnabled = true;
    }
    if (stencilState.writeMask !== 255) {
      gl.stencilMask(255);
      stencilState.writeMask = 255;
    }
    gl.clear(clearFlag);
  };
  _proto.drawPrimitive = function drawPrimitive(primitive, subPrimitive, shaderProgram) {
    if (primitive) {
      primitive._draw(shaderProgram, subPrimitive);
    } else {
      Logger.error("draw primitive failed.");
    }
  };
  _proto.activeRenderTarget = function activeRenderTarget(renderTarget, camera) {
    var gl = this._gl;
    if (renderTarget) {
      var _renderTarget$_platfo;
      (_renderTarget$_platfo = renderTarget._platformRenderTarget) === null || _renderTarget$_platfo === void 0 ? void 0 : _renderTarget$_platfo._activeRenderTarget();
      var width = renderTarget.width, height = renderTarget.height;
      this.viewport(0, 0, width, height);
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      var viewport = camera.viewport;
      var drawingBufferWidth = gl.drawingBufferWidth, drawingBufferHeight = gl.drawingBufferHeight;
      var _width = drawingBufferWidth * viewport.z;
      var _height = drawingBufferHeight * viewport.w;
      var x = viewport.x * drawingBufferWidth;
      var y = drawingBufferHeight - viewport.y * drawingBufferHeight - _height;
      this.viewport(x, y, _width, _height);
    }
  };
  _proto.destroy = function destroy() {
  };
  _proto.activeTexture = function activeTexture(textureID) {
    if (this._activeTextureID !== textureID) {
      this._gl.activeTexture(textureID);
      this._activeTextureID = textureID;
    }
  };
  _proto.bindTexture = function bindTexture(texture) {
    var index = this._activeTextureID - this._gl.TEXTURE0;
    if (this._activeTextures[index] !== texture) {
      this._gl.bindTexture(texture._target, texture._glTexture);
      this._activeTextures[index] = texture;
    }
  };
  _createClass2(WebGLRenderer2, [{
    key: "isWebGL2",
    get: function get4() {
      return this._isWebGL2;
    }
  }, {
    key: "gl",
    get: function get4() {
      return this._gl;
    }
  }, {
    key: "renderStates",
    get: function get4() {
      return this._renderStates;
    }
  }, {
    key: "capability",
    get: function get4() {
      return this._capability;
    }
  }, {
    key: "canIUseMoreJoints",
    get: function get4() {
      return this.capability.canIUseMoreJoints;
    }
  }]);
  return WebGLRenderer2;
}();
var WebGLEngine = function(_Engine) {
  _inheritsLoose2(WebGLEngine2, _Engine);
  function WebGLEngine2(canvas, webGLRendererOptions) {
    var webCanvas = new WebCanvas(typeof canvas === "string" ? document.getElementById(canvas) : canvas);
    var hardwareRenderer = new WebGLRenderer(webGLRendererOptions);
    return _Engine.call(this, webCanvas, hardwareRenderer) || this;
  }
  _createClass2(WebGLEngine2, [{
    key: "canvas",
    get: function get4() {
      return this._canvas;
    }
  }]);
  return WebGLEngine2;
}(Engine);

// node_modules/@oasis-engine/draco/dist/module.js
function _defineProperties3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties3(Constructor, staticProps);
  return Constructor;
}
var DRACOWorker = function() {
  function DRACOWorker2(workerSourceURL, decoderWASMBinary) {
    var _this = this;
    this._worker = void 0;
    this._costs = {};
    this._currentLoad = 0;
    this._callbacks = {};
    this._worker = new Worker(workerSourceURL);
    this._worker.onmessage = function(e) {
      var message = e.data;
      switch (message.type) {
        case "decode":
          _this._callbacks[message.id].resolve(message.geometry);
          break;
        case "error":
          _this._callbacks[message.id].reject(message);
          break;
        default:
          Logger.error('DRACOWorker: Unexpected message, "' + message.type + '"');
      }
    };
    if (decoderWASMBinary) {
      this._worker.postMessage({
        type: "init",
        decoderConfig: {
          wasmBinary: decoderWASMBinary
        }
      });
    } else {
      this._worker.postMessage({
        type: "init",
        decoderConfig: {}
      });
    }
  }
  var _proto = DRACOWorker2.prototype;
  _proto.setCosts = function setCosts(taskId, cost) {
    this._costs[taskId] = cost;
  };
  _proto.addCurrentLoad = function addCurrentLoad(cost) {
    this._currentLoad += cost;
  };
  _proto.setCallback = function setCallback(taskId, resolve, reject) {
    this._callbacks[taskId] = {
      resolve,
      reject
    };
  };
  _proto.decode = function decode(taskId, taskConfig, buffer) {
    this._worker.postMessage({
      type: "decode",
      id: taskId,
      taskConfig,
      buffer
    }, [buffer]);
  };
  _proto.releaseTask = function releaseTask(taskId) {
    this._currentLoad -= this._costs[taskId];
    delete this._callbacks[taskId];
    delete this._costs[taskId];
  };
  _createClass3(DRACOWorker2, [{
    key: "currentLoad",
    get: function get4() {
      return this._currentLoad;
    }
  }]);
  return DRACOWorker2;
}();
var workerString = 'let decoderPending;\nlet decoderConfig;\n\nonmessage = function(e) {\n  const message = e.data;\n\n  switch (message.type) {\n    case "init":\n      decoderConfig = message.decoderConfig;\n      decoderPending = new Promise(function(resolve /*, reject*/) {\n        decoderConfig.onModuleLoaded = function(draco) {\n          // Module is Promise-like. Wrap before resolving to avoid loop.\n          resolve({ draco: draco });\n        };\n        DracoDecoderModule(decoderConfig);\n      });\n      break;\n\n    case "decode":\n      const buffer = message.buffer;\n      const taskConfig = message.taskConfig;\n      decoderPending.then(module => {\n        const draco = module.draco;\n        const decoder = new draco.Decoder();\n        const decoderBuffer = new draco.DecoderBuffer();\n        decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n        try {\n          const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n          const buffers = geometry.attributes.map(attr => attr.array.buffer);\n          if (geometry.index) buffers.push(geometry.index.array.buffer);\n          self.postMessage({ type: "decode", id: message.id, geometry }, buffers);\n        } catch (error) {\n          console.error(error);\n          self.postMessage({ type: "error", id: message.id, error: error.message });\n        } finally {\n          draco.destroy(decoderBuffer);\n          draco.destroy(decoder);\n        }\n      });\n      break;\n  }\n};\n\nfunction decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n  const attributeIDs = taskConfig.attributeIDs;\n  const attributeTypes = taskConfig.attributeTypes;\n\n  let dracoGeometry;\n  let decodingStatus;\n\n  const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    dracoGeometry = new draco.Mesh();\n    decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n  } else {\n    throw new Error("DRACODecoder worker: Unexpected geometry type.");\n  }\n\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new Error("DRACODecoder worker: Decoding failed: " + decodingStatus.error_msg());\n  }\n\n  const geometry = { index: null, attributes: [] };\n\n  // Gather all vertex attributes.\n  for (let attributeName in attributeIDs) {\n    const attributeType = self[attributeTypes[attributeName]];\n\n    let attribute;\n    let attributeID;\n\n    // A Draco file may be created with default vertex attributes, whose attribute IDs\n    // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n    // a Draco file may contain a custom set of attributes, identified by known unique\n    // IDs. glTF files always do the latter, and .drc files typically do the former.\n    if (taskConfig.useUniqueIDs) {\n      attributeID = attributeIDs[attributeName];\n      attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n    } else {\n      attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n      if (attributeID === -1) continue;\n      attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n    }\n    geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n  }\n  // Add index.\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    // Generate mesh faces.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    let dataSize;\n    let ptr;\n    let index;\n    const indexType = self[taskConfig.indexType];\n\n    switch (indexType) {\n      case Uint16Array:\n        dataSize = numIndices * 2;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt16Array(dracoGeometry, dataSize, ptr);\n        index = new Uint16Array(draco.HEAPU16.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      case Uint32Array:\n        dataSize = numIndices * 4;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, dataSize, ptr);\n        index = new Uint32Array(draco.HEAPU32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      default:\n        throw new Error("DRACODecoder: Unexpected index type.");\n    }\n    geometry.index = { array: index, itemSize: 1 };\n  }\n  draco.destroy(dracoGeometry);\n  return geometry;\n}\n\nfunction decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n  const numComponents = attribute.num_components();\n  const numPoints = dracoGeometry.num_points();\n  const numValues = numPoints * numComponents;\n  let ptr;\n  let array;\n  let dataSize;\n  switch (attributeType) {\n    case Float32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr);\n      array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT8, numValues, ptr);\n      array = new Int8Array(draco.HEAP8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr);\n      array = new Int16Array(draco.HEAP16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr);\n      array = new Int32Array(draco.HEAP32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr);\n      array = new Uint8Array(draco.HEAPU8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr);\n      array = new Uint16Array(draco.HEAPU16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr);\n      array = new Uint32Array(draco.HEAPU32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    default:\n      throw new Error("DRACODecoder: Unexpected attribute type.");\n  }\n\n  return {\n    name: attributeName,\n    array: array,\n    itemSize: numComponents\n  };\n}\n';
var LIB_PATH = "https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/";
var JS_FILE = "draco_decoder_gltf.js";
var WASM_FILE = "draco_decoder_gltf.r3bin";
var WASM_WRAPPER_FILE = "draco_wasm_wrapper_gltf.js";
var DRACODecoder = function() {
  function DRACODecoder2(config) {
    if (config === void 0) {
      config = {
        type: "wasm",
        workerLimit: 4
      };
    }
    this.pool = [];
    this.workerLimit = Math.min(navigator.hardwareConcurrency || 4, 4);
    this.useJS = void 0;
    this.currentTaskId = 1;
    this.taskCache = new WeakMap();
    this.loadLibPromise = void 0;
    if (config.workerLimit > this.workerLimit) {
      Logger.warn("DRACOWorkerPool: Can not initialize worker pool with limit:" + config.workerLimit);
    } else {
      var _config$workerLimit;
      this.workerLimit = (_config$workerLimit = config.workerLimit) != null ? _config$workerLimit : 4;
    }
    this.useJS = typeof WebAssembly !== "object" || config.type === "js";
    this.loadLibPromise = this.preloadLib();
  }
  var _proto = DRACODecoder2.prototype;
  _proto.preloadLib = function preloadLib() {
    var _this = this;
    if (this.loadLibPromise) {
      return this.loadLibPromise;
    }
    return new Promise(function(resolve, reject) {
      if (_this.useJS) {
        request("" + LIB_PATH + JS_FILE, {
          type: "text"
        }).then(function(jsSource) {
          var body = [jsSource, workerString].join("\n");
          var workerSourceURL = URL.createObjectURL(new Blob([body]));
          resolve({
            workerSourceURL,
            decoderWASMBinary: null
          });
        }).catch(function(reason) {
          reject(reason);
        });
      } else {
        Promise.all([request("" + LIB_PATH + WASM_WRAPPER_FILE, {
          type: "text"
        }), request("" + LIB_PATH + WASM_FILE, {
          type: "arraybuffer"
        })]).then(function(resources) {
          var wrapperSource = resources[0], decoderWASMBinary = resources[1];
          var body = [wrapperSource, workerString].join("\n");
          var workerSourceURL = URL.createObjectURL(new Blob([body]));
          resolve({
            workerSourceURL,
            decoderWASMBinary
          });
        }).catch(function(reason) {
          reject(reason);
        });
      }
    });
  };
  _proto.getWorker = function getWorker() {
    var _this2 = this;
    return this.preloadLib().then(function(worderResources) {
      if (_this2.pool.length < _this2.workerLimit) {
        var dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);
        _this2.pool.push(dracoWorker);
      } else {
        _this2.pool.sort(function(a, b) {
          return a.currentLoad > b.currentLoad ? -1 : 1;
        });
      }
      return _this2.pool[_this2.pool.length - 1];
    });
  };
  _proto.decode = function decode(buffer, taskConfig) {
    var _this3 = this;
    var taskKey = JSON.stringify(taskConfig);
    if (this.taskCache.has(buffer)) {
      var cachedTask = this.taskCache.get(buffer);
      if (cachedTask.key === taskKey) {
        return cachedTask.promise;
      } else if (buffer.byteLength === 0) {
        throw new Error("DRACODecoder: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
      }
    }
    var taskId = this.currentTaskId++;
    var cost = buffer.byteLength;
    var taskWorker;
    var task = new Promise(function(resolve, reject) {
      _this3.getWorker().then(function(worker) {
        taskWorker = worker;
        worker.setCosts(taskId, cost);
        worker.addCurrentLoad(cost);
        worker.setCallback(taskId, resolve, reject);
        worker.decode(taskId, taskConfig, buffer);
      }).catch(function(e) {
        reject(e);
      });
    });
    task.finally(function() {
      if (taskWorker && taskId) {
        taskWorker.releaseTask(taskId);
      }
    });
    this.taskCache.set(buffer, {
      key: taskKey,
      promise: task
    });
    return task;
  };
  return DRACODecoder2;
}();

// node_modules/@oasis-engine/loader/dist/module.js
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread23(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys3(Object(source), true).forEach(function(key) {
        _defineProperty3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperties4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties4(Constructor, staticProps);
  return Constructor;
}
function _defineProperty3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _inheritsLoose3(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf3(subClass, superClass);
}
function _setPrototypeOf3(o, p) {
  _setPrototypeOf3 = Object.setPrototypeOf || function _setPrototypeOf4(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf3(o, p);
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct2(Parent, args, Class) {
  if (_isNativeReflectConstruct2()) {
    _construct2 = Reflect.construct;
  } else {
    _construct2 = function _construct3(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf3(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct2.apply(null, arguments);
}
function _assertThisInitialized2(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose2(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _applyDecoratedDescriptor2(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function(key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;
  if ("value" in desc || desc.initializer) {
    desc.writable = true;
  }
  desc = decorators.slice().reverse().reduce(function(desc2, decorator) {
    return decorator(target, property, desc2) || desc2;
  }, desc);
  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = void 0;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }
  return desc;
}
var _dec$j;
var _class$j;
function isBase64(url) {
  return /^data:(.+?);base64,/.test(url);
}
_dec$j = resourceLoader(AssetType.Buffer, ["bin", "r3bin"], false), _dec$j(_class$j = function(_Loader) {
  _inheritsLoose3(BufferLoader, _Loader);
  function BufferLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = BufferLoader.prototype;
  _proto.load = function load(item) {
    var url = item.url;
    if (isBase64(url)) {
      return new AssetPromise(function(resolve) {
        var base64Str = url.slice(13 + RegExp.$1.length);
        var result = Uint8Array.from(atob(base64Str), function(c) {
          return c.charCodeAt(0);
        });
        resolve(result.buffer);
      });
    }
    return this.request(url, _objectSpread23(_objectSpread23({}, item), {}, {
      type: "arraybuffer"
    }));
  };
  return BufferLoader;
}(Loader)) || _class$j;
var AccessorComponentType;
(function(AccessorComponentType2) {
  AccessorComponentType2[AccessorComponentType2["BYTE"] = 5120] = "BYTE";
  AccessorComponentType2[AccessorComponentType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  AccessorComponentType2[AccessorComponentType2["SHORT"] = 5122] = "SHORT";
  AccessorComponentType2[AccessorComponentType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  AccessorComponentType2[AccessorComponentType2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  AccessorComponentType2[AccessorComponentType2["FLOAT"] = 5126] = "FLOAT";
})(AccessorComponentType || (AccessorComponentType = {}));
var AccessorType;
(function(AccessorType2) {
  AccessorType2["SCALAR"] = "SCALAR";
  AccessorType2["VEC2"] = "VEC2";
  AccessorType2["VEC3"] = "VEC3";
  AccessorType2["VEC4"] = "VEC4";
  AccessorType2["MAT2"] = "MAT2";
  AccessorType2["MAT3"] = "MAT3";
  AccessorType2["MAT4"] = "MAT4";
})(AccessorType || (AccessorType = {}));
var AnimationChannelTargetPath;
(function(AnimationChannelTargetPath2) {
  AnimationChannelTargetPath2["TRANSLATION"] = "translation";
  AnimationChannelTargetPath2["ROTATION"] = "rotation";
  AnimationChannelTargetPath2["SCALE"] = "scale";
  AnimationChannelTargetPath2["WEIGHTS"] = "weights";
})(AnimationChannelTargetPath || (AnimationChannelTargetPath = {}));
var AnimationSamplerInterpolation;
(function(AnimationSamplerInterpolation2) {
  AnimationSamplerInterpolation2["Linear"] = "LINEAR";
  AnimationSamplerInterpolation2["Step"] = "STEP";
  AnimationSamplerInterpolation2["CubicSpine"] = "CUBICSPLINE";
})(AnimationSamplerInterpolation || (AnimationSamplerInterpolation = {}));
var CameraType;
(function(CameraType2) {
  CameraType2["PERSPECTIVE"] = "perspective";
  CameraType2["ORTHOGRAPHIC"] = "orthographic";
})(CameraType || (CameraType = {}));
var ImageMimeType;
(function(ImageMimeType2) {
  ImageMimeType2["JPEG"] = "image/jpeg";
  ImageMimeType2["PNG"] = "image/png";
})(ImageMimeType || (ImageMimeType = {}));
var MaterialAlphaMode;
(function(MaterialAlphaMode2) {
  MaterialAlphaMode2["OPAQUE"] = "OPAQUE";
  MaterialAlphaMode2["MASK"] = "MASK";
  MaterialAlphaMode2["BLEND"] = "BLEND";
})(MaterialAlphaMode || (MaterialAlphaMode = {}));
var TextureMagFilter;
(function(TextureMagFilter2) {
  TextureMagFilter2[TextureMagFilter2["NEAREST"] = 9728] = "NEAREST";
  TextureMagFilter2[TextureMagFilter2["LINEAR"] = 9729] = "LINEAR";
})(TextureMagFilter || (TextureMagFilter = {}));
var TextureMinFilter;
(function(TextureMinFilter2) {
  TextureMinFilter2[TextureMinFilter2["NEAREST"] = 9728] = "NEAREST";
  TextureMinFilter2[TextureMinFilter2["LINEAR"] = 9729] = "LINEAR";
  TextureMinFilter2[TextureMinFilter2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
  TextureMinFilter2[TextureMinFilter2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  TextureMinFilter2[TextureMinFilter2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
  TextureMinFilter2[TextureMinFilter2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(TextureMinFilter || (TextureMinFilter = {}));
var TextureWrapMode2;
(function(TextureWrapMode3) {
  TextureWrapMode3[TextureWrapMode3["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
  TextureWrapMode3[TextureWrapMode3["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  TextureWrapMode3[TextureWrapMode3["REPEAT"] = 10497] = "REPEAT";
})(TextureWrapMode2 || (TextureWrapMode2 = {}));
var GLTFUtil = function() {
  function GLTFUtil2() {
  }
  GLTFUtil2.floatBufferToVector2Array = function floatBufferToVector2Array(buffer) {
    var bufferLen = buffer.length;
    var array = new Array(bufferLen / 2);
    for (var i = 0; i < bufferLen; i += 2) {
      array[i / 2] = new Vector2(buffer[i], buffer[i + 1]);
    }
    return array;
  };
  GLTFUtil2.floatBufferToVector3Array = function floatBufferToVector3Array(buffer) {
    var bufferLen = buffer.length;
    var array = new Array(bufferLen / 3);
    for (var i = 0; i < bufferLen; i += 3) {
      array[i / 3] = new Vector3(buffer[i], buffer[i + 1], buffer[i + 2]);
    }
    return array;
  };
  GLTFUtil2.floatBufferToVector4Array = function floatBufferToVector4Array(buffer) {
    var bufferLen = buffer.length;
    var array = new Array(bufferLen / 4);
    for (var i = 0; i < bufferLen; i += 4) {
      array[i / 4] = new Vector4(buffer[i], buffer[i + 1], buffer[i + 2], buffer[i + 3]);
    }
    return array;
  };
  GLTFUtil2.decodeText = function decodeText(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    var s = "";
    for (var i = 0, il = array.length; i < il; i++) {
      s += String.fromCharCode(array[i]);
    }
    return decodeURIComponent(encodeURIComponent(s));
  };
  GLTFUtil2.getAccessorTypeSize = function getAccessorTypeSize(accessorType) {
    switch (accessorType) {
      case AccessorType.SCALAR:
        return 1;
      case AccessorType.VEC2:
        return 2;
      case AccessorType.VEC3:
        return 3;
      case AccessorType.VEC4:
        return 4;
      case AccessorType.MAT2:
        return 4;
      case AccessorType.MAT3:
        return 9;
      case AccessorType.MAT4:
        return 16;
    }
  };
  GLTFUtil2.getComponentType = function getComponentType(componentType) {
    switch (componentType) {
      case AccessorComponentType.BYTE:
        return Int8Array;
      case AccessorComponentType.UNSIGNED_BYTE:
        return Uint8Array;
      case AccessorComponentType.SHORT:
        return Int16Array;
      case AccessorComponentType.UNSIGNED_SHORT:
        return Uint16Array;
      case AccessorComponentType.UNSIGNED_INT:
        return Uint32Array;
      case AccessorComponentType.FLOAT:
        return Float32Array;
    }
  };
  GLTFUtil2.getAccessorData = function getAccessorData(gltf, accessor, buffers) {
    var _bufferView$byteStrid;
    var bufferViews = gltf.bufferViews;
    var bufferView = bufferViews[accessor.bufferView];
    var arrayBuffer = buffers[bufferView.buffer];
    var accessorByteOffset = accessor.hasOwnProperty("byteOffset") ? accessor.byteOffset : 0;
    var bufferViewByteOffset = bufferView.hasOwnProperty("byteOffset") ? bufferView.byteOffset : 0;
    var byteOffset = accessorByteOffset + bufferViewByteOffset;
    var accessorTypeSize = GLTFUtil2.getAccessorTypeSize(accessor.type);
    var length2 = accessorTypeSize * accessor.count;
    var byteStride = (_bufferView$byteStrid = bufferView.byteStride) != null ? _bufferView$byteStrid : 0;
    var arrayType = GLTFUtil2.getComponentType(accessor.componentType);
    var uint8Array;
    if (byteStride) {
      var accessorByteSize = accessorTypeSize * arrayType.BYTES_PER_ELEMENT;
      uint8Array = new Uint8Array(accessor.count * accessorByteSize);
      var originalBufferView = new Uint8Array(arrayBuffer, bufferViewByteOffset, bufferView.byteLength);
      for (var i = 0; i < accessor.count; i++) {
        for (var j = 0; j < accessorByteSize; j++) {
          uint8Array[i * accessorByteSize + j] = originalBufferView[i * byteStride + accessorByteOffset + j];
        }
      }
    } else {
      uint8Array = new Uint8Array(arrayBuffer.slice(byteOffset, byteOffset + length2 * arrayType.BYTES_PER_ELEMENT));
    }
    var typedArray = new arrayType(uint8Array.buffer);
    if (accessor.sparse) {
      var _indices$byteOffset, _indicesBufferView$by, _values$byteOffset, _valuesBufferView$byt;
      var _accessor$sparse = accessor.sparse, count = _accessor$sparse.count, indices = _accessor$sparse.indices, values = _accessor$sparse.values;
      var indicesBufferView = bufferViews[indices.bufferView];
      var valuesBufferView = bufferViews[values.bufferView];
      var indicesArrayBuffer = buffers[indicesBufferView.buffer];
      var valuesArrayBuffer = buffers[valuesBufferView.buffer];
      var indicesByteOffset = ((_indices$byteOffset = indices.byteOffset) != null ? _indices$byteOffset : 0) + ((_indicesBufferView$by = indicesBufferView.byteOffset) != null ? _indicesBufferView$by : 0);
      var indicesByteLength = indicesBufferView.byteLength;
      var valuesByteOffset = ((_values$byteOffset = values.byteOffset) != null ? _values$byteOffset : 0) + ((_valuesBufferView$byt = valuesBufferView.byteOffset) != null ? _valuesBufferView$byt : 0);
      var valuesByteLength = valuesBufferView.byteLength;
      var indicesType = GLTFUtil2.getComponentType(indices.componentType);
      var indicesArray = new indicesType(indicesArrayBuffer, indicesByteOffset, indicesByteLength / indicesType.BYTES_PER_ELEMENT);
      var valuesArray = new arrayType(valuesArrayBuffer, valuesByteOffset, valuesByteLength / arrayType.BYTES_PER_ELEMENT);
      for (var _i = 0; _i < count; _i++) {
        var replaceIndex = indicesArray[_i];
        for (var _j = 0; _j < accessorTypeSize; _j++) {
          typedArray[replaceIndex * accessorTypeSize + _j] = valuesArray[_i * accessorTypeSize + _j];
        }
      }
    }
    return typedArray;
  };
  GLTFUtil2.getBufferViewData = function getBufferViewData(bufferView, buffers) {
    var buffer = bufferView.buffer, _bufferView$byteOffse = bufferView.byteOffset, byteOffset = _bufferView$byteOffse === void 0 ? 0 : _bufferView$byteOffse, byteLength = bufferView.byteLength;
    var arrayBuffer = buffers[buffer];
    return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
  };
  GLTFUtil2.getVertexStride = function getVertexStride(gltf, accessor) {
    var _accessor$bufferView;
    var stride = gltf.bufferViews[(_accessor$bufferView = accessor.bufferView) != null ? _accessor$bufferView : 0].byteStride;
    if (stride) {
      return stride;
    }
    var size = GLTFUtil2.getAccessorTypeSize(accessor.type);
    var componentType = GLTFUtil2.getComponentType(accessor.componentType);
    return size * componentType.BYTES_PER_ELEMENT;
  };
  GLTFUtil2.createVertexElement = function createVertexElement(semantic, accessor, index) {
    var size = GLTFUtil2.getAccessorTypeSize(accessor.type);
    return new VertexElement(semantic, 0, GLTFUtil2.getElementFormat(accessor.componentType, size, accessor.normalized), index);
  };
  GLTFUtil2.getIndexFormat = function getIndexFormat(type) {
    switch (type) {
      case AccessorComponentType.UNSIGNED_BYTE:
        return IndexFormat.UInt8;
      case AccessorComponentType.UNSIGNED_SHORT:
        return IndexFormat.UInt16;
      case AccessorComponentType.UNSIGNED_INT:
        return IndexFormat.UInt32;
    }
  };
  GLTFUtil2.getElementFormat = function getElementFormat(type, size, normalized) {
    if (normalized === void 0) {
      normalized = false;
    }
    if (type == AccessorComponentType.FLOAT) {
      switch (size) {
        case 1:
          return VertexElementFormat.Float;
        case 2:
          return VertexElementFormat.Vector2;
        case 3:
          return VertexElementFormat.Vector3;
        case 4:
          return VertexElementFormat.Vector4;
      }
    }
    if (type == AccessorComponentType.SHORT) {
      switch (size) {
        case 2:
          return normalized ? VertexElementFormat.NormalizedShort2 : VertexElementFormat.Short2;
        case 3:
        case 4:
          return normalized ? VertexElementFormat.NormalizedShort4 : VertexElementFormat.Short4;
      }
    }
    if (type == AccessorComponentType.UNSIGNED_SHORT) {
      switch (size) {
        case 2:
          return normalized ? VertexElementFormat.NormalizedUShort2 : VertexElementFormat.UShort2;
        case 3:
        case 4:
          return normalized ? VertexElementFormat.NormalizedUShort4 : VertexElementFormat.UShort4;
      }
    }
    if (type == AccessorComponentType.BYTE) {
      switch (size) {
        case 2:
        case 3:
        case 4:
          return normalized ? VertexElementFormat.NormalizedByte4 : VertexElementFormat.Byte4;
      }
    }
    if (type == AccessorComponentType.UNSIGNED_BYTE) {
      switch (size) {
        case 2:
        case 3:
        case 4:
          return normalized ? VertexElementFormat.NormalizedUByte4 : VertexElementFormat.UByte4;
      }
    }
  };
  GLTFUtil2.loadImageBuffer = function loadImageBuffer(imageBuffer, type) {
    return new Promise(function(resolve, reject) {
      var blob = new window.Blob([imageBuffer], {
        type
      });
      var img = new Image();
      img.src = URL.createObjectURL(blob);
      img.crossOrigin = "anonymous";
      img.onerror = function() {
        reject(new Error("Failed to load image buffer"));
      };
      img.onload = function() {
        requestAnimationFrame(function() {
          resolve(img);
          img.onload = null;
          img.onerror = null;
          img.onabort = null;
        });
      };
    });
  };
  GLTFUtil2.isAbsoluteUrl = function isAbsoluteUrl(url) {
    return /^(?:http|blob|data:|\/)/.test(url);
  };
  GLTFUtil2.parseRelativeUrl = function parseRelativeUrl(baseUrl, relativeUrl) {
    if (GLTFUtil2.isAbsoluteUrl(relativeUrl)) {
      return relativeUrl;
    }
    var char0 = relativeUrl.charAt(0);
    if (char0 === ".") {
      return GLTFUtil2._formatRelativePath(relativeUrl + relativeUrl);
    }
    return baseUrl.substring(0, baseUrl.lastIndexOf("/") + 1) + relativeUrl;
  };
  GLTFUtil2.parseGLB = function parseGLB(glb) {
    var UINT32_LENGTH = 4;
    var GLB_HEADER_MAGIC = 1179937895;
    var GLB_HEADER_LENGTH = 12;
    var GLB_CHUNK_TYPES = {
      JSON: 1313821514,
      BIN: 5130562
    };
    var dataView = new DataView(glb);
    var header = {
      magic: dataView.getUint32(0, true),
      version: dataView.getUint32(UINT32_LENGTH, true),
      length: dataView.getUint32(2 * UINT32_LENGTH, true)
    };
    if (header.magic !== GLB_HEADER_MAGIC) {
      console.error("Invalid glb magic number. Expected 0x46546C67, found 0x" + header.magic.toString(16));
      return null;
    }
    var chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);
    var chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true);
    if (chunkType !== GLB_CHUNK_TYPES.JSON) {
      console.error("Invalid glb chunk type. Expected 0x4E4F534A, found 0x" + chunkType.toString(16));
      return null;
    }
    var glTFData = new Uint8Array(glb, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);
    var gltf = JSON.parse(GLTFUtil2.decodeText(glTFData));
    var buffers = [];
    var byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;
    while (byteOffset < header.length) {
      chunkLength = dataView.getUint32(byteOffset, true);
      chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);
      if (chunkType !== GLB_CHUNK_TYPES.BIN) {
        console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
        return null;
      }
      var currentOffset = byteOffset + 2 * UINT32_LENGTH;
      var buffer = glb.slice(currentOffset, currentOffset + chunkLength);
      buffers.push(buffer);
      byteOffset += chunkLength + 2 * UINT32_LENGTH;
    }
    return {
      gltf,
      buffers
    };
  };
  GLTFUtil2._formatRelativePath = function _formatRelativePath(value) {
    var parts = value.split("/");
    for (var i = 0, n = parts.length; i < n; i++) {
      if (parts[i] == "..") {
        parts.splice(i - 1, 2);
        i -= 2;
      }
    }
    return parts.join("/");
  };
  return GLTFUtil2;
}();
var Parser$1 = function() {
  function Parser2() {
  }
  Parser2.parseEngineResource = function parseEngineResource(extensionName, extensionSchema, parseResource, context) {
    var parsers = Parser2._extensionParsers[extensionName];
    if (parsers !== null && parsers !== void 0 && parsers.length) {
      for (var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
        extra[_key - 4] = arguments[_key];
      }
      for (var i = 0; i < parsers.length; i++) {
        var _parsers$i;
        (_parsers$i = parsers[i]).parseEngineResource.apply(_parsers$i, [extensionSchema, parseResource, context].concat(extra));
      }
    }
  };
  Parser2.createEngineResource = function createEngineResource(extensionName, extensionSchema, context) {
    var parsers = Parser2._extensionParsers[extensionName];
    if (parsers !== null && parsers !== void 0 && parsers.length) {
      var _parsers$;
      for (var _len2 = arguments.length, extra = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
        extra[_key2 - 3] = arguments[_key2];
      }
      return (_parsers$ = parsers[0]).createEngineResource.apply(_parsers$, [extensionSchema, context].concat(extra));
    }
  };
  Parser2.hasExtensionParser = function hasExtensionParser(extensionName) {
    var parsers = Parser2._extensionParsers[extensionName];
    return !!(parsers !== null && parsers !== void 0 && parsers.length);
  };
  Parser2.initialize = function initialize(extensionName) {
    var parsers = Parser2._extensionParsers[extensionName];
    if (parsers !== null && parsers !== void 0 && parsers.length) {
      for (var i = 0; i < parsers.length; i++) {
        parsers[i].initialize();
      }
    }
  };
  Parser2._addExtensionParser = function _addExtensionParser(extensionName, extensionParser) {
    if (!Parser2._extensionParsers[extensionName]) {
      Parser2._extensionParsers[extensionName] = [];
    }
    Parser2._extensionParsers[extensionName].push(extensionParser);
  };
  return Parser2;
}();
Parser$1._extensionParsers = {};
function registerExtension(extensionName) {
  return function(parser2) {
    var extensionParser = new parser2();
    Parser$1._addExtensionParser(extensionName, extensionParser);
  };
}
var AnimationParser = function(_Parser) {
  _inheritsLoose3(AnimationParser2, _Parser);
  function AnimationParser2() {
    return _Parser.apply(this, arguments) || this;
  }
  var _proto = AnimationParser2.prototype;
  _proto.parse = function parse2(context) {
    var gltf = context.gltf, buffers = context.buffers, entities = context.entities;
    var animations = gltf.animations, accessors = gltf.accessors;
    if (!animations) {
      return;
    }
    var animationClipCount = animations.length;
    var animationClips = new Array(animationClipCount);
    var animationsIndices = new Array(animationClipCount);
    for (var i = 0; i < animationClipCount; i++) {
      var gltfAnimation = animations[i];
      var channels = gltfAnimation.channels, samplers = gltfAnimation.samplers, _gltfAnimation$name = gltfAnimation.name, name = _gltfAnimation$name === void 0 ? "AnimationClip" + i : _gltfAnimation$name;
      var animationClip = new AnimationClip(name);
      var sampleDataCollection = new Array();
      for (var _i = 0; _i < samplers.length; _i++) {
        var _gltfSampler$interpol;
        var gltfSampler = samplers[_i];
        var inputAccessor = accessors[gltfSampler.input];
        var outputAccessor = accessors[gltfSampler.output];
        var input = GLTFUtil.getAccessorData(gltf, inputAccessor, buffers);
        var output = GLTFUtil.getAccessorData(gltf, outputAccessor, buffers);
        var outputAccessorSize = output.length / input.length;
        var interpolation = (_gltfSampler$interpol = gltfSampler.interpolation) != null ? _gltfSampler$interpol : AnimationSamplerInterpolation.Linear;
        var samplerInterpolation = void 0;
        switch (interpolation) {
          case AnimationSamplerInterpolation.CubicSpine:
            samplerInterpolation = InterpolationType.CubicSpine;
            break;
          case AnimationSamplerInterpolation.Step:
            samplerInterpolation = InterpolationType.Step;
            break;
          case AnimationSamplerInterpolation.Linear:
            samplerInterpolation = InterpolationType.Linear;
            break;
        }
        input[input.length - 1];
        sampleDataCollection.push({
          type: outputAccessor.type,
          interpolation: samplerInterpolation,
          input,
          output,
          outputSize: outputAccessorSize
        });
      }
      for (var _i2 = 0; _i2 < channels.length; _i2++) {
        var gltfChannel = channels[_i2];
        var target = gltfChannel.target;
        var channelTargetEntity = entities[target.node];
        var relativePath = "";
        var entity = channelTargetEntity;
        while (entity.parent) {
          relativePath = relativePath === "" ? "" + entity.name : entity.name + "/" + relativePath;
          entity = entity.parent;
        }
        var compType = void 0;
        var propertyName = void 0;
        switch (target.path) {
          case AnimationChannelTargetPath.TRANSLATION:
            compType = Transform;
            propertyName = "position";
            break;
          case AnimationChannelTargetPath.ROTATION:
            compType = Transform;
            propertyName = "rotation";
            break;
          case AnimationChannelTargetPath.SCALE:
            compType = Transform;
            propertyName = "scale";
            break;
          case AnimationChannelTargetPath.WEIGHTS:
            compType = SkinnedMeshRenderer;
            propertyName = "blendShapeWeights";
            break;
        }
        var curve = this._addCurve(gltfChannel, sampleDataCollection);
        animationClip.addCurveBinding(relativePath, compType, propertyName, curve);
      }
      animationClips[i] = animationClip;
      animationsIndices[i] = {
        name,
        index: i
      };
    }
    context.animations = animationClips;
    context._animationsIndices = animationsIndices;
  };
  _proto._addCurve = function _addCurve(gltfChannel, sampleDataCollection) {
    var curve = new AnimationCurve();
    var sampleData = sampleDataCollection[gltfChannel.sampler];
    var type = sampleData.type, input = sampleData.input, output = sampleData.output, outputSize = sampleData.outputSize;
    curve.interpolation = sampleData.interpolation;
    for (var j = 0, n = input.length; j < n; j++) {
      var offset = j * outputSize;
      if (type === AccessorType.SCALAR) {
        var keyframe = outputSize > 1 ? new InterpolableKeyframe() : new InterpolableKeyframe();
        keyframe.time = input[j];
        keyframe.inTangent = 0;
        keyframe.outTangent = 0;
        keyframe.value = outputSize > 1 ? output.subarray(offset, offset + outputSize) : output[offset];
        curve.addKey(keyframe);
      }
      if (type === AccessorType.VEC2) {
        var _keyframe = new InterpolableKeyframe();
        _keyframe.time = input[j];
        _keyframe.value = new Vector2(output[offset], output[offset + 1]);
        _keyframe.inTangent = new Vector2();
        _keyframe.outTangent = new Vector2();
        curve.addKey(_keyframe);
      }
      if (type === AccessorType.VEC3) {
        var _keyframe2 = new InterpolableKeyframe();
        _keyframe2.time = input[j];
        _keyframe2.value = new Vector3(output[offset], output[offset + 1], output[offset + 2]);
        _keyframe2.inTangent = new Vector3();
        _keyframe2.outTangent = new Vector3();
        curve.addKey(_keyframe2);
      }
      if (type === AccessorType.VEC4) {
        var _keyframe3 = new InterpolableKeyframe();
        _keyframe3.time = input[j];
        _keyframe3.value = new Quaternion(output[offset], output[offset + 1], output[offset + 2], output[offset + 3]);
        _keyframe3.inTangent = new Vector4();
        _keyframe3.outTangent = new Vector4();
        curve.addKey(_keyframe3);
      }
    }
    return curve;
  };
  return AnimationParser2;
}(Parser$1);
var BufferParser = function(_Parser) {
  _inheritsLoose3(BufferParser2, _Parser);
  function BufferParser2() {
    return _Parser.apply(this, arguments) || this;
  }
  var _proto = BufferParser2.prototype;
  _proto.parse = function parse2(context) {
    var url = context.url, engine = context.engine;
    if (this._isGLB(url)) {
      return engine.resourceManager.load({
        url,
        type: AssetType.Buffer
      }).then(GLTFUtil.parseGLB).then(function(_ref) {
        var gltf = _ref.gltf, buffers = _ref.buffers;
        context.gltf = gltf;
        context.buffers = buffers;
      });
    } else {
      return engine.resourceManager.load({
        url,
        type: AssetType.JSON
      }).then(function(gltf) {
        context.gltf = gltf;
        return Promise.all(gltf.buffers.map(function(buffer) {
          return engine.resourceManager.load({
            type: AssetType.Buffer,
            url: GLTFUtil.parseRelativeUrl(url, buffer.uri)
          });
        })).then(function(buffers) {
          context.buffers = buffers;
        });
      });
    }
  };
  _proto._isGLB = function _isGLB(url) {
    return url.substring(url.lastIndexOf(".") + 1) === "glb";
  };
  return BufferParser2;
}(Parser$1);
var EntityParser = function(_Parser) {
  _inheritsLoose3(EntityParser2, _Parser);
  function EntityParser2() {
    return _Parser.apply(this, arguments) || this;
  }
  var _proto = EntityParser2.prototype;
  _proto.parse = function parse2(context) {
    var engine = context.engine, nodes = context.gltf.nodes;
    if (!nodes)
      return;
    var entities = [];
    for (var i = 0; i < nodes.length; i++) {
      var gltfNode = nodes[i];
      var matrix = gltfNode.matrix, translation = gltfNode.translation, rotation = gltfNode.rotation, scale = gltfNode.scale;
      var entity = new Entity(engine, gltfNode.name || "" + EntityParser2._defaultName + i);
      var transform = entity.transform;
      if (matrix) {
        var localMatrix = transform.localMatrix;
        localMatrix.setValueByArray(matrix);
        transform.localMatrix = localMatrix;
      } else {
        if (translation) {
          transform.setPosition(translation[0], translation[1], translation[2]);
        }
        if (rotation) {
          transform.setRotationQuaternion(rotation[0], rotation[1], rotation[2], rotation[3]);
        }
        if (scale) {
          transform.setScale(scale[0], scale[1], scale[2]);
        }
      }
      entities[i] = entity;
    }
    context.entities = entities;
    this._buildEntityTree(context);
    this._createSceneRoots(context);
  };
  _proto._buildEntityTree = function _buildEntityTree(context) {
    var nodes = context.gltf.nodes, entities = context.entities;
    for (var i = 0; i < nodes.length; i++) {
      var children = nodes[i].children;
      var entity = entities[i];
      if (children) {
        for (var j = 0; j < children.length; j++) {
          var childEntity = entities[children[j]];
          entity.addChild(childEntity);
        }
      }
    }
  };
  _proto._createSceneRoots = function _createSceneRoots(context) {
    var engine = context.engine, _context$gltf = context.gltf, _context$gltf$scene = _context$gltf.scene, sceneID = _context$gltf$scene === void 0 ? 0 : _context$gltf$scene, scenes = _context$gltf.scenes, entities = context.entities;
    if (!scenes)
      return;
    var sceneRoots = [];
    for (var i = 0; i < scenes.length; i++) {
      var nodes = scenes[i].nodes;
      if (!nodes)
        continue;
      if (nodes.length === 1) {
        sceneRoots[i] = entities[nodes[0]];
      } else {
        var rootEntity = new Entity(engine, "GLTF_ROOT");
        for (var j = 0; j < nodes.length; j++) {
          rootEntity.addChild(entities[nodes[j]]);
        }
        sceneRoots[i] = rootEntity;
      }
    }
    context.sceneRoots = sceneRoots;
    context.defaultSceneRoot = sceneRoots[sceneID];
  };
  return EntityParser2;
}(Parser$1);
EntityParser._defaultName = "_GLTF_ENTITY_";
var MaterialParser = function(_Parser) {
  _inheritsLoose3(MaterialParser2, _Parser);
  function MaterialParser2() {
    return _Parser.apply(this, arguments) || this;
  }
  MaterialParser2._parseTextureTransform = function _parseTextureTransform(material, extensions, context) {
    if (extensions === void 0) {
      extensions = {};
    }
    var schema = extensions.KHR_texture_transform;
    if (schema) {
      Parser$1.parseEngineResource("KHR_texture_transform", schema, material, context);
    }
  };
  var _proto = MaterialParser2.prototype;
  _proto.parse = function parse2(context) {
    var gltf = context.gltf, engine = context.engine, textures = context.textures;
    if (!gltf.materials)
      return;
    var materials = [];
    for (var i = 0; i < gltf.materials.length; i++) {
      var _gltf$materials$i = gltf.materials[i], _gltf$materials$i$ext = _gltf$materials$i.extensions, extensions = _gltf$materials$i$ext === void 0 ? {} : _gltf$materials$i$ext, pbrMetallicRoughness = _gltf$materials$i.pbrMetallicRoughness, normalTexture = _gltf$materials$i.normalTexture, occlusionTexture = _gltf$materials$i.occlusionTexture, emissiveTexture = _gltf$materials$i.emissiveTexture, emissiveFactor = _gltf$materials$i.emissiveFactor, alphaMode = _gltf$materials$i.alphaMode, alphaCutoff = _gltf$materials$i.alphaCutoff, doubleSided = _gltf$materials$i.doubleSided, _gltf$materials$i$nam = _gltf$materials$i.name, name = _gltf$materials$i$nam === void 0 ? "" : _gltf$materials$i$nam;
      var KHR_materials_unlit = extensions.KHR_materials_unlit, KHR_materials_pbrSpecularGlossiness = extensions.KHR_materials_pbrSpecularGlossiness;
      var material = null;
      if (KHR_materials_unlit) {
        material = Parser$1.createEngineResource("KHR_materials_unlit", KHR_materials_unlit, context);
      } else if (KHR_materials_pbrSpecularGlossiness) {
        material = Parser$1.createEngineResource("KHR_materials_pbrSpecularGlossiness", KHR_materials_pbrSpecularGlossiness, context);
      } else {
        material = new PBRMaterial(engine);
      }
      material.name = name;
      if (pbrMetallicRoughness) {
        var baseColorFactor = pbrMetallicRoughness.baseColorFactor, baseColorTexture = pbrMetallicRoughness.baseColorTexture, metallicFactor = pbrMetallicRoughness.metallicFactor, roughnessFactor = pbrMetallicRoughness.roughnessFactor, metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;
        if (baseColorFactor) {
          material.baseColor = _construct2(Color, baseColorFactor);
        }
        if (baseColorTexture) {
          material.baseTexture = textures[baseColorTexture.index];
          MaterialParser2._parseTextureTransform(material, baseColorTexture.extensions, context);
        }
        if (!KHR_materials_unlit && !KHR_materials_pbrSpecularGlossiness) {
          var m = material;
          m.metallic = metallicFactor != null ? metallicFactor : 1;
          m.roughness = roughnessFactor != null ? roughnessFactor : 1;
          if (metallicRoughnessTexture) {
            m.roughnessMetallicTexture = textures[metallicRoughnessTexture.index];
            MaterialParser2._parseTextureTransform(material, metallicRoughnessTexture.extensions, context);
          }
        }
      }
      if (!KHR_materials_unlit) {
        var _m = material;
        if (emissiveTexture) {
          _m.emissiveTexture = textures[emissiveTexture.index];
          MaterialParser2._parseTextureTransform(material, emissiveTexture.extensions, context);
        }
        if (emissiveFactor) {
          _m.emissiveColor = _construct2(Color, emissiveFactor);
        }
        if (normalTexture) {
          var index = normalTexture.index, scale = normalTexture.scale;
          _m.normalTexture = textures[index];
          MaterialParser2._parseTextureTransform(material, normalTexture.extensions, context);
          if (scale !== void 0) {
            _m.normalTextureIntensity = scale;
          }
        }
        if (occlusionTexture) {
          var _index = occlusionTexture.index, strength = occlusionTexture.strength;
          _m.occlusionTexture = textures[_index];
          MaterialParser2._parseTextureTransform(material, occlusionTexture.extensions, context);
          if (strength !== void 0) {
            _m.occlusionTextureIntensity = strength;
          }
        }
      }
      if (doubleSided) {
        material.renderFace = RenderFace.Double;
      } else {
        material.renderFace = RenderFace.Front;
      }
      switch (alphaMode) {
        case MaterialAlphaMode.OPAQUE:
          material.isTransparent = false;
          break;
        case MaterialAlphaMode.BLEND:
          material.isTransparent = true;
          break;
        case MaterialAlphaMode.MASK:
          material.alphaCutoff = alphaCutoff != null ? alphaCutoff : 0.5;
          break;
      }
      materials[i] = material;
    }
    context.materials = materials;
  };
  return MaterialParser2;
}(Parser$1);
var MeshParser = function(_Parser) {
  _inheritsLoose3(MeshParser2, _Parser);
  function MeshParser2() {
    return _Parser.apply(this, arguments) || this;
  }
  var _proto = MeshParser2.prototype;
  _proto.parse = function parse2(context) {
    var _this = this;
    var engine = context.engine, gltf = context.gltf, buffers = context.buffers;
    if (!gltf.meshes)
      return;
    var meshPromises = [];
    var _loop = function _loop2(i2) {
      var gltfMesh = gltf.meshes[i2];
      var primitivePromises = [];
      var _loop22 = function _loop23(j2) {
        var gltfPrimitive = gltfMesh.primitives[j2];
        var _gltfPrimitive$extens = gltfPrimitive.extensions, extensions = _gltfPrimitive$extens === void 0 ? {} : _gltfPrimitive$extens;
        var KHR_draco_mesh_compression = extensions.KHR_draco_mesh_compression;
        primitivePromises.push(new Promise(function(resolve) {
          var mesh = new ModelMesh(engine, gltfMesh.name || j2 + "");
          if (KHR_draco_mesh_compression) {
            Parser$1.createEngineResource("KHR_draco_mesh_compression", KHR_draco_mesh_compression, context, gltfPrimitive).then(function(decodedGeometry) {
              return _this._parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, function(attributeSemantic) {
                for (var _j = 0; _j < decodedGeometry.attributes.length; _j++) {
                  if (decodedGeometry.attributes[_j].name === attributeSemantic) {
                    return decodedGeometry.attributes[_j].array;
                  }
                }
                return null;
              }, function(attributeSemantic, shapeIndex) {
                throw "BlendShape animation is not supported when using draco.";
              }, function() {
                return decodedGeometry.index.array;
              }, engine);
            }).then(resolve);
          } else {
            _this._parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, function(attributeSemantic) {
              var accessorIdx = gltfPrimitive.attributes[attributeSemantic];
              var accessor = gltf.accessors[accessorIdx];
              return GLTFUtil.getAccessorData(gltf, accessor, buffers);
            }, function(attributeName, shapeIndex) {
              var shapeAccessorIdx = gltfPrimitive.targets[shapeIndex];
              var attributeAccessorIdx = shapeAccessorIdx[attributeName];
              if (attributeAccessorIdx) {
                var accessor = gltf.accessors[attributeAccessorIdx];
                return GLTFUtil.getAccessorData(gltf, accessor, buffers);
              } else {
                return null;
              }
            }, function() {
              var indexAccessor = gltf.accessors[gltfPrimitive.indices];
              return GLTFUtil.getAccessorData(gltf, indexAccessor, buffers);
            }, engine).then(resolve);
          }
        }));
      };
      for (var j = 0; j < gltfMesh.primitives.length; j++) {
        _loop22(j);
      }
      meshPromises.push(Promise.all(primitivePromises));
    };
    for (var i = 0; i < gltf.meshes.length; i++) {
      _loop(i);
    }
    return Promise.all(meshPromises).then(function(meshes) {
      context.meshes = meshes;
    });
  };
  _proto._parseMeshFromGLTFPrimitive = function _parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, getVertexBufferData, getBlendShapeData, getIndexBufferData, engine) {
    var attributes = gltfPrimitive.attributes, targets = gltfPrimitive.targets, indices = gltfPrimitive.indices, mode = gltfPrimitive.mode;
    var vertexCount;
    var accessor = gltf.accessors[attributes["POSITION"]];
    var positionBuffer = getVertexBufferData("POSITION");
    var positions = GLTFUtil.floatBufferToVector3Array(positionBuffer);
    mesh.setPositions(positions);
    var bounds = mesh.bounds;
    vertexCount = accessor.count;
    if (accessor.min && accessor.max) {
      bounds.min.setValueByArray(accessor.min);
      bounds.max.setValueByArray(accessor.max);
    } else {
      var position = MeshParser2._tempVector3;
      var min = bounds.min, max = bounds.max;
      min.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      max.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
      var stride = positionBuffer.length / vertexCount;
      for (var j = 0; j < vertexCount; j++) {
        var offset = j * stride;
        position.setValueByArray(positionBuffer, offset);
        Vector3.min(min, position, min);
        Vector3.max(max, position, max);
      }
    }
    for (var attributeSemantic in attributes) {
      if (attributeSemantic === "POSITION") {
        continue;
      }
      var bufferData = getVertexBufferData(attributeSemantic);
      switch (attributeSemantic) {
        case "NORMAL":
          var normals = GLTFUtil.floatBufferToVector3Array(bufferData);
          mesh.setNormals(normals);
          break;
        case "TANGENT":
          var tangents = GLTFUtil.floatBufferToVector4Array(bufferData);
          mesh.setTangents(tangents);
          break;
        case "TEXCOORD_0":
          var texturecoords = GLTFUtil.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords, 0);
          break;
        case "JOINTS_0":
          var joints = GLTFUtil.floatBufferToVector4Array(bufferData);
          mesh.setBoneIndices(joints);
          break;
        case "WEIGHTS_0":
          var weights = GLTFUtil.floatBufferToVector4Array(bufferData);
          mesh.setBoneWeights(weights);
          break;
      }
    }
    if (indices !== void 0) {
      var indexAccessor = gltf.accessors[indices];
      var indexData = getIndexBufferData();
      mesh.setIndices(indexData);
      mesh.addSubMesh(0, indexAccessor.count, mode);
    } else {
      mesh.addSubMesh(0, vertexCount, mode);
    }
    targets && this._createBlendShape(mesh, gltfMesh, targets, getBlendShapeData);
    mesh.uploadData(true);
    return Promise.resolve(mesh);
  };
  _proto._createBlendShape = function _createBlendShape(mesh, glTFMesh, glTFTargets, getBlendShapeData) {
    var blendShapeNames = glTFMesh.extras ? glTFMesh.extras.targetNames : null;
    for (var i = 0, n = glTFTargets.length; i < n; i++) {
      var _name = blendShapeNames ? blendShapeNames[i] : "blendShape" + i;
      var deltaPosBuffer = getBlendShapeData("POSITION", i);
      var deltaNorBuffer = getBlendShapeData("NORMAL", i);
      var deltaTanBuffer = getBlendShapeData("TANGENT", i);
      var deltaPositions = deltaPosBuffer ? GLTFUtil.floatBufferToVector3Array(deltaPosBuffer) : null;
      var deltaNormals = deltaNorBuffer ? GLTFUtil.floatBufferToVector3Array(deltaNorBuffer) : null;
      var deltaTangents = deltaTanBuffer ? GLTFUtil.floatBufferToVector3Array(deltaTanBuffer) : null;
      var blendShape = new BlendShape(_name);
      blendShape.addFrame(1, deltaPositions, deltaNormals, deltaTangents);
      mesh.addBlendShape(blendShape);
    }
  };
  return MeshParser2;
}(Parser$1);
MeshParser._tempVector3 = new Vector3();
var SceneParser = function(_Parser) {
  _inheritsLoose3(SceneParser2, _Parser);
  function SceneParser2() {
    return _Parser.apply(this, arguments) || this;
  }
  SceneParser2._getDefaultMaterial = function _getDefaultMaterial(engine) {
    if (!SceneParser2._defaultMaterial) {
      SceneParser2._defaultMaterial = new BlinnPhongMaterial(engine);
    }
    return SceneParser2._defaultMaterial;
  };
  var _proto = SceneParser2.prototype;
  _proto.parse = function parse2(context) {
    var _context$gltf = context.gltf, nodes = _context$gltf.nodes, gltfCameras = _context$gltf.cameras, entities = context.entities;
    if (!nodes)
      return;
    for (var i = 0; i < nodes.length; i++) {
      var gltfNode = nodes[i];
      var cameraID = gltfNode.camera, meshID = gltfNode.mesh, _gltfNode$extensions = gltfNode.extensions, extensions = _gltfNode$extensions === void 0 ? {} : _gltfNode$extensions;
      var KHR_lights_punctual = extensions.KHR_lights_punctual;
      var entity = entities[i];
      if (cameraID !== void 0) {
        this._createCamera(context, gltfCameras[cameraID], entity);
      }
      if (meshID !== void 0) {
        this._createRenderer(context, gltfNode, entity);
      }
      if (KHR_lights_punctual) {
        var lightIndex = KHR_lights_punctual.light;
        var lights = context.gltf.extensions.KHR_lights_punctual.lights;
        Parser$1.parseEngineResource("KHR_lights_punctual", lights[lightIndex], entity, context);
      }
    }
    if (context.defaultSceneRoot) {
      this._createAnimator(context);
    }
  };
  _proto._createCamera = function _createCamera(context, cameraSchema, entity) {
    var orthographic = cameraSchema.orthographic, perspective = cameraSchema.perspective, type = cameraSchema.type;
    var camera = entity.addComponent(Camera);
    if (type === CameraType.ORTHOGRAPHIC) {
      var xmag = orthographic.xmag, ymag = orthographic.ymag, zfar = orthographic.zfar, znear = orthographic.znear;
      camera.isOrthographic = true;
      if (znear !== void 0) {
        camera.nearClipPlane = znear;
      }
      if (zfar !== void 0) {
        camera.farClipPlane = zfar;
      }
      camera.orthographicSize = Math.max(ymag != null ? ymag : 0, xmag != null ? xmag : 0) / 2;
    } else if (type === CameraType.PERSPECTIVE) {
      var aspectRatio = perspective.aspectRatio, yfov = perspective.yfov, _zfar = perspective.zfar, _znear = perspective.znear;
      if (aspectRatio !== void 0) {
        camera.aspectRatio = aspectRatio;
      }
      if (yfov !== void 0) {
        camera.fieldOfView = yfov * 180 / Math.PI;
      }
      if (_zfar !== void 0) {
        camera.farClipPlane = _zfar;
      }
      if (_znear !== void 0) {
        camera.nearClipPlane = _znear;
      }
    }
    if (!context.cameras)
      context.cameras = [];
    context.cameras.push(camera);
    camera.enabled = false;
  };
  _proto._createRenderer = function _createRenderer(context, gltfNode, entity) {
    var engine = context.engine, gltfMeshes = context.gltf.meshes, meshes = context.meshes, materials = context.materials, skins = context.skins;
    var meshID = gltfNode.mesh, skinID = gltfNode.skin;
    var glTFMesh = gltfMeshes[meshID];
    var gltfMeshPrimitives = glTFMesh.primitives;
    var blendShapeWeights = gltfNode.weights || glTFMesh.weights;
    for (var i = 0; i < gltfMeshPrimitives.length; i++) {
      var mesh = meshes[meshID][i];
      var renderer = void 0;
      if (skinID !== void 0 || blendShapeWeights) {
        var skinRenderer = entity.addComponent(SkinnedMeshRenderer);
        skinRenderer.mesh = mesh;
        if (skinID !== void 0) {
          skinRenderer.skin = skins[skinID];
        }
        if (blendShapeWeights) {
          skinRenderer.blendShapeWeights = new Float32Array(blendShapeWeights);
        }
        renderer = skinRenderer;
      } else {
        renderer = entity.addComponent(MeshRenderer);
        renderer.mesh = mesh;
      }
      var materialIndex = gltfMeshPrimitives[i].material;
      var material = (materials === null || materials === void 0 ? void 0 : materials[materialIndex]) || SceneParser2._getDefaultMaterial(engine);
      renderer.setMaterial(material);
      var _gltfMeshPrimitives$i = gltfMeshPrimitives[i].extensions, extensions = _gltfMeshPrimitives$i === void 0 ? {} : _gltfMeshPrimitives$i;
      var KHR_materials_variants = extensions.KHR_materials_variants;
      if (KHR_materials_variants) {
        Parser$1.parseEngineResource("KHR_materials_variants", KHR_materials_variants, renderer, context);
      }
    }
  };
  _proto._createAnimator = function _createAnimator(context) {
    var defaultSceneRoot = context.defaultSceneRoot, animations = context.animations;
    if (!animations)
      return;
    var animator = defaultSceneRoot.addComponent(Animator);
    var animatorController = new AnimatorController();
    var layer = new AnimatorControllerLayer("layer");
    var animatorStateMachine = new AnimatorStateMachine();
    animatorController.addLayer(layer);
    animator.animatorController = animatorController;
    layer.stateMachine = animatorStateMachine;
    if (animations) {
      for (var i = 0; i < animations.length; i++) {
        var animationClip = animations[i];
        var name = animationClip.name;
        var uniqueName = animatorStateMachine.makeUniqueStateName(name);
        if (uniqueName !== name) {
          console.warn("AnimatorState name is existed, name: " + name + " reset to " + uniqueName);
        }
        var animatorState = animatorStateMachine.addState(uniqueName);
        animatorState.clip = animationClip;
      }
    }
  };
  return SceneParser2;
}(Parser$1);
SceneParser._defaultMaterial = void 0;
var SkinParser = function(_Parser) {
  _inheritsLoose3(SkinParser2, _Parser);
  function SkinParser2() {
    return _Parser.apply(this, arguments) || this;
  }
  var _proto = SkinParser2.prototype;
  _proto.parse = function parse2(context) {
    var gltf = context.gltf, buffers = context.buffers, entities = context.entities, defaultSceneRoot = context.defaultSceneRoot;
    var gltfSkins = gltf.skins;
    if (!gltfSkins)
      return;
    var skins = [];
    for (var i = 0; i < gltfSkins.length; i++) {
      var _gltfSkins$i = gltfSkins[i], inverseBindMatrices = _gltfSkins$i.inverseBindMatrices, skeleton = _gltfSkins$i.skeleton, joints = _gltfSkins$i.joints, _gltfSkins$i$name = _gltfSkins$i.name, name = _gltfSkins$i$name === void 0 ? "SKIN_" + i : _gltfSkins$i$name;
      var jointCount = joints.length;
      var skin = new Skin(name);
      skin.inverseBindMatrices.length = jointCount;
      var accessor = gltf.accessors[inverseBindMatrices];
      var buffer = GLTFUtil.getAccessorData(gltf, accessor, buffers);
      for (var _i = 0; _i < jointCount; _i++) {
        var inverseBindMatrix = new Matrix();
        inverseBindMatrix.setValueByArray(buffer, _i * 16);
        skin.inverseBindMatrices[_i] = inverseBindMatrix;
      }
      for (var _i2 = 0; _i2 < jointCount; _i2++) {
        skin.joints[_i2] = entities[joints[_i2]].name;
      }
      if (skeleton !== void 0) {
        skin.skeleton = entities[skeleton].name;
      } else {
        skin.skeleton = defaultSceneRoot.name;
      }
      skins[i] = skin;
    }
    context.skins = skins;
  };
  return SkinParser2;
}(Parser$1);
var TextureParser = function(_Parser) {
  _inheritsLoose3(TextureParser2, _Parser);
  function TextureParser2() {
    return _Parser.apply(this, arguments) || this;
  }
  var _proto = TextureParser2.prototype;
  _proto.parse = function parse2(context) {
    var _this = this;
    var gltf = context.gltf, buffers = context.buffers, engine = context.engine, url = context.url;
    if (gltf.textures) {
      return Promise.all(gltf.textures.map(function(_ref, index) {
        var sampler = _ref.sampler, _ref$source = _ref.source, source = _ref$source === void 0 ? 0 : _ref$source, textureName = _ref.name;
        var _gltf$images$source = gltf.images[source], uri = _gltf$images$source.uri, bufferViewIndex = _gltf$images$source.bufferView, mimeType2 = _gltf$images$source.mimeType, imageName = _gltf$images$source.name;
        if (uri) {
          return engine.resourceManager.load({
            url: GLTFUtil.parseRelativeUrl(url, uri),
            type: AssetType.Texture2D
          }).then(function(texture) {
            if (!texture.name) {
              texture.name = textureName || imageName || "texture_" + index;
            }
            if (sampler !== void 0) {
              _this._parseSampler(texture, gltf.samplers[sampler]);
            }
            return texture;
          });
        } else {
          var bufferView = gltf.bufferViews[bufferViewIndex];
          var bufferViewData = GLTFUtil.getBufferViewData(bufferView, buffers);
          return GLTFUtil.loadImageBuffer(bufferViewData, mimeType2).then(function(image) {
            var texture = new Texture2D(engine, image.width, image.height);
            texture.setImageSource(image);
            texture.generateMipmaps();
            texture.name = textureName || imageName || "texture_" + index;
            if (sampler !== void 0) {
              _this._parseSampler(texture, gltf.samplers[sampler]);
            }
            return texture;
          });
        }
      })).then(function(textures) {
        context.textures = textures;
      });
    }
  };
  _proto._parseSampler = function _parseSampler(texture, sampler) {
    var magFilter = sampler.magFilter, minFilter = sampler.minFilter, wrapS = sampler.wrapS, wrapT = sampler.wrapT;
    if (magFilter || minFilter) {
      Logger.warn("texture use filterMode in engine");
    }
    if (wrapS) {
      texture.wrapModeU = TextureParser2._wrapMap[wrapS];
    }
    if (wrapT) {
      texture.wrapModeV = TextureParser2._wrapMap[wrapT];
    }
  };
  return TextureParser2;
}(Parser$1);
TextureParser._wrapMap = {
  33071: TextureWrapMode.Clamp,
  33648: TextureWrapMode.Mirror,
  10497: TextureWrapMode.Repeat
};
var Validator = function(_Parser) {
  _inheritsLoose3(Validator2, _Parser);
  function Validator2() {
    return _Parser.apply(this, arguments) || this;
  }
  var _proto = Validator2.prototype;
  _proto.parse = function parse2(context) {
    var _context$gltf = context.gltf, version2 = _context$gltf.asset.version, extensionsUsed = _context$gltf.extensionsUsed, extensionsRequired = _context$gltf.extensionsRequired;
    var gltfVersion = Number(version2);
    if (!(gltfVersion >= 2 && gltfVersion < 3)) {
      throw "Only support gltf 2.x.";
    }
    if (extensionsUsed) {
      Logger.info("extensionsUsed: ", extensionsUsed);
      for (var i = 0; i < extensionsUsed.length; i++) {
        if (!Parser$1.hasExtensionParser(extensionsUsed[i])) {
          Logger.warn("Extension " + extensionsUsed[i] + " is not implemented, you can customize this extension in gltf.");
        }
      }
    }
    if (extensionsRequired) {
      Logger.info("extensionsRequired: " + extensionsRequired);
      for (var _i = 0; _i < extensionsRequired.length; _i++) {
        var extensionRequired = extensionsRequired[_i];
        if (!Parser$1.hasExtensionParser(extensionRequired)) {
          Logger.error("GLTF parser has not supported required extension " + extensionRequired + ".");
        } else {
          Parser$1.initialize(extensionRequired);
        }
      }
    }
  };
  return Validator2;
}(Parser$1);
var GLTFParser = function() {
  function GLTFParser2(pipes) {
    var _this = this;
    this._pipes = [];
    pipes.forEach(function(pipe, index) {
      _this._pipes[index] = new pipe();
    });
  }
  var _proto = GLTFParser2.prototype;
  _proto.parse = function parse2(context) {
    var _this2 = this;
    var lastPipe;
    return new Promise(function(resolve, reject) {
      _this2._pipes.forEach(function(parser2) {
        if (lastPipe) {
          lastPipe = lastPipe.then(function() {
            return parser2.parse(context);
          });
        } else {
          lastPipe = parser2.parse(context);
        }
      });
      if (lastPipe) {
        lastPipe.then(function() {
          resolve(context);
        }).catch(reject);
      } else {
        resolve(context);
      }
    });
  };
  return GLTFParser2;
}();
GLTFParser.instance = new GLTFParser([BufferParser, Validator, TextureParser, MaterialParser, MeshParser, EntityParser, SkinParser, AnimationParser, SceneParser]);
var GLTFResource$1 = function(_EngineObject) {
  _inheritsLoose3(GLTFResource2, _EngineObject);
  function GLTFResource2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _EngineObject.call.apply(_EngineObject, [this].concat(args)) || this;
    _this.url = void 0;
    _this.gltf = void 0;
    _this.buffers = void 0;
    _this.textures = void 0;
    _this.materials = void 0;
    _this.meshes = void 0;
    _this.skins = void 0;
    _this.animations = void 0;
    _this.entities = void 0;
    _this.cameras = void 0;
    _this.lights = void 0;
    _this.sceneRoots = void 0;
    _this.defaultSceneRoot = void 0;
    _this.variants = void 0;
    return _this;
  }
  return GLTFResource2;
}(EngineObject);
var _dec$i;
var _class$i;
_dec$i = resourceLoader(AssetType.Prefab, ["gltf", "glb"]), _dec$i(_class$i = function(_Loader) {
  _inheritsLoose3(GLTFLoader, _Loader);
  function GLTFLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = GLTFLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var url = item.url;
    return new AssetPromise(function(resolve, reject) {
      var resource = new GLTFResource$1(resourceManager.engine);
      resource.url = url;
      GLTFParser.instance.parse(resource).then(resolve).catch(function(e) {
        console.error(e);
        reject("Error loading glTF model from " + url + " .");
      });
    });
  };
  return GLTFLoader;
}(Loader)) || _class$i;
var _dec$h;
var _class$h;
_dec$h = resourceLoader(AssetType.JSON, ["json"], false), _dec$h(_class$h = function(_Loader) {
  _inheritsLoose3(JSONLoader, _Loader);
  function JSONLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = JSONLoader.prototype;
  _proto.load = function load(item) {
    return this.request(item.url, _objectSpread23(_objectSpread23({}, item), {}, {
      type: "json"
    }));
  };
  return JSONLoader;
}(Loader)) || _class$h;
var HEADER_LEN = 12 + 13 * 4;
var COMPRESSED_2D = 0;
function getMipmaps(ktxContainer, loadMipmaps) {
  var mipmaps = [];
  var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;
  var width = ktxContainer.pixelWidth;
  var height = ktxContainer.pixelHeight;
  var mipmapCount = loadMipmaps ? ktxContainer.numberOfMipmapLevels : 1;
  for (var level = 0; level < mipmapCount; level++) {
    var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0];
    dataOffset += 4;
    for (var face = 0; face < ktxContainer.numberOfFaces; face++) {
      var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);
      mipmaps.push({
        data: byteArray,
        width,
        height
      });
      dataOffset += imageSize;
      dataOffset += 3 - (imageSize + 3) % 4;
    }
    width = Math.max(1, width * 0.5);
    height = Math.max(1, height * 0.5);
  }
  return mipmaps;
}
function isValid(data) {
  if (data.byteLength >= 12) {
    var identifier = new Uint8Array(data, 0, 12);
    if (identifier[0] === 171 && identifier[1] === 75 && identifier[2] === 84 && identifier[3] === 88 && identifier[4] === 32 && identifier[5] === 49 && identifier[6] === 49 && identifier[7] === 187 && identifier[8] === 13 && identifier[9] === 10 && identifier[10] === 26 && identifier[11] === 10) {
      return true;
    }
  }
  return false;
}
function getEngineFormat(internalFormat) {
  switch (internalFormat) {
    case GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:
      return TextureFormat.DXT1;
    case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
      return TextureFormat.DXT5;
    case GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:
      return TextureFormat.ETC1_RGB;
    case GLCompressedTextureInternalFormat.RGB8_ETC2:
      return TextureFormat.ETC2_RGB;
    case GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return TextureFormat.ETC2_RGBA5;
    case GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:
      return TextureFormat.ETC2_RGBA8;
    case GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:
      return TextureFormat.PVRTC_RGB2;
    case GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:
      return TextureFormat.PVRTC_RGBA2;
    case GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:
      return TextureFormat.PVRTC_RGB4;
    case GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:
      return TextureFormat.PVRTC_RGBA4;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:
      return TextureFormat.ASTC_4x4;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:
      return TextureFormat.ASTC_5x5;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:
      return TextureFormat.ASTC_6x6;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:
      return TextureFormat.ASTC_8x8;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:
      return TextureFormat.ASTC_10x10;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:
      return TextureFormat.ASTC_12x12;
    default:
      var formatName = GLCompressedTextureInternalFormat[internalFormat];
      throw new Error("this format is not supported in Oasis Engine: " + formatName);
  }
}
var khronosTextureContainerParser = {
  parse: function parse(buffer, facesExpected, withMipmaps, mapEngineFormat) {
    if (mapEngineFormat === void 0) {
      mapEngineFormat = false;
    }
    if (!isValid(buffer)) {
      throw new Error("khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier");
    }
    var dataSize = Uint32Array.BYTES_PER_ELEMENT;
    var headerDataView = new DataView(buffer, 12, 13 * dataSize);
    var endianness = headerDataView.getUint32(0, true);
    var littleEndian = endianness === 67305985;
    var parsedResult = {
      buffer,
      glType: headerDataView.getUint32(1 * dataSize, littleEndian),
      glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian),
      glFormat: headerDataView.getUint32(3 * dataSize, littleEndian),
      glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian),
      glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian),
      pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian),
      pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian),
      pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian),
      numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian),
      numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian),
      numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian),
      bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian),
      loadType: COMPRESSED_2D
    };
    if (parsedResult.glType !== 0) {
      throw new Error("only compressed formats currently supported");
    } else {
      parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);
    }
    if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {
      throw new Error("only 2D textures currently supported");
    }
    if (parsedResult.numberOfArrayElements !== 0) {
      throw new Error("texture arrays not currently supported");
    }
    if (parsedResult.numberOfFaces !== facesExpected) {
      throw new Error("number of faces expected" + facesExpected + ", but found " + parsedResult.numberOfFaces);
    }
    if (withMipmaps) {
      parsedResult.mipmaps = getMipmaps(parsedResult, true);
    }
    if (mapEngineFormat) {
      parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);
    }
    return parsedResult;
  }
};
function parseSingleKTX(data) {
  var ktx = khronosTextureContainerParser.parse(data, 1, true, true);
  return {
    mipmaps: ktx.mipmaps,
    engineFormat: ktx.engineFormat,
    internalFormat: ktx.glInternalFormat,
    width: ktx.pixelWidth,
    height: ktx.pixelHeight
  };
}
function parseCubeKTX(dataArray) {
  var mipmapsFaces = [];
  var internalFormat;
  var engineFormat;
  var width;
  var height;
  for (var i = 0; i < dataArray.length; i++) {
    var ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);
    mipmapsFaces.push(ktx.mipmaps);
    if (i === 0) {
      width = ktx.pixelWidth;
      height = ktx.pixelHeight;
      internalFormat = ktx.glInternalFormat;
      engineFormat = ktx.engineFormat;
    }
  }
  return {
    mipmapsFaces,
    engineFormat,
    internalFormat,
    width,
    height
  };
}
var _dec$g;
var _class$g;
_dec$g = resourceLoader(AssetType.KTXCube, []), _dec$g(_class$g = function(_Loader) {
  _inheritsLoose3(KTXCubeLoader, _Loader);
  function KTXCubeLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = KTXCubeLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      Promise.all(item.urls.map(function(url) {
        return _this.request(url, _objectSpread23(_objectSpread23({}, item), {}, {
          type: "arraybuffer"
        }));
      })).then(function(data) {
        var parsedData = parseCubeKTX(data);
        var width = parsedData.width, mipmapsFaces = parsedData.mipmapsFaces, engineFormat = parsedData.engineFormat;
        var mipmap = mipmapsFaces[0].length > 1;
        var texture = new TextureCubeMap(resourceManager.engine, width, engineFormat, mipmap);
        for (var face = 0; face < 6; face++) {
          var length2 = mipmapsFaces[face].length;
          for (var miplevel = 0; miplevel < length2; miplevel++) {
            var _mipmapsFaces$face$mi = mipmapsFaces[face][miplevel], _data = _mipmapsFaces$face$mi.data, _width = _mipmapsFaces$face$mi.width, height = _mipmapsFaces$face$mi.height;
            texture.setPixelBuffer(TextureCubeFace.PositiveX + face, _data, miplevel, 0, 0, _width, height);
          }
        }
        resolve(texture);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  return KTXCubeLoader;
}(Loader)) || _class$g;
var _dec$f;
var _class$f;
_dec$f = resourceLoader(AssetType.KTX, ["ktx"]), _dec$f(_class$f = function(_Loader) {
  _inheritsLoose3(KTXLoader, _Loader);
  function KTXLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = KTXLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      _this.request(item.url, _objectSpread23(_objectSpread23({}, item), {}, {
        type: "arraybuffer"
      })).then(function(bin) {
        var parsedData = parseSingleKTX(bin);
        var width = parsedData.width, height = parsedData.height, mipmaps = parsedData.mipmaps, engineFormat = parsedData.engineFormat;
        var mipmap = mipmaps.length > 1;
        var texture = new Texture2D(resourceManager.engine, width, height, engineFormat, mipmap);
        for (var miplevel = 0; miplevel < mipmaps.length; miplevel++) {
          var _mipmaps$miplevel = mipmaps[miplevel], _width = _mipmaps$miplevel.width, _height = _mipmaps$miplevel.height, data = _mipmaps$miplevel.data;
          texture.setPixelBuffer(data, miplevel, 0, 0, _width, _height);
        }
        resolve(texture);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  return KTXLoader;
}(Loader)) || _class$f;
var _dec$e;
var _class$e;
_dec$e = resourceLoader(AssetType.Texture2D, ["png", "jpg", "webp", "jpeg"]), _dec$e(_class$e = function(_Loader) {
  _inheritsLoose3(Texture2DLoader, _Loader);
  function Texture2DLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = Texture2DLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      _this.request(item.url, _objectSpread23(_objectSpread23({}, item), {}, {
        type: "image"
      })).then(function(image) {
        var texture = new Texture2D(resourceManager.engine, image.width, image.height);
        if (!texture._platformTexture)
          return;
        texture.setImageSource(image);
        texture.generateMipmaps();
        if (item.url.indexOf("data:") !== 0) {
          var splitPath = item.url.split("/");
          texture.name = splitPath[splitPath.length - 1];
        }
        resolve(texture);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  return Texture2DLoader;
}(Loader)) || _class$e;
var _dec$d;
var _class$d;
_dec$d = resourceLoader(AssetType.TextureCube, [""]), _dec$d(_class$d = function(_Loader) {
  _inheritsLoose3(TextureCubeLoader, _Loader);
  function TextureCubeLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = TextureCubeLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      Promise.all(item.urls.map(function(url) {
        return _this.request(url, _objectSpread23(_objectSpread23({}, item), {}, {
          type: "image"
        }));
      })).then(function(images) {
        var _images$ = images[0], width = _images$.width, height = _images$.height;
        if (width !== height) {
          console.error("The cube texture must have the same width and height");
          return;
        }
        var tex = new TextureCubeMap(resourceManager.engine, width);
        if (!tex._platformTexture)
          return;
        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
          tex.setImageSource(TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
        }
        tex.generateMipmaps();
        resolve(tex);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  return TextureCubeLoader;
}(Loader)) || _class$d;
var _dec$c;
var _class$c;
_dec$c = resourceLoader(AssetType.SpriteAtlas, ["atlas"], false), _dec$c(_class$c = function(_Loader) {
  _inheritsLoose3(SpriteAtlasLoader, _Loader);
  function SpriteAtlasLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = SpriteAtlasLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      _this.request(item.url, _objectSpread23(_objectSpread23({}, item), {}, {
        type: "json"
      })).then(function(atlasData) {
        var atlasItems = atlasData.atlasItems, format = atlasData.format;
        var atlasItemsLen = atlasItems.length;
        Promise.all(atlasItems.map(function(_ref) {
          var img = _ref.img;
          return _this.request(GLTFUtil.parseRelativeUrl(item.url, img), _objectSpread23(_objectSpread23({}, item), {}, {
            type: "image"
          }));
        })).then(function(imgs) {
          var engine = resourceManager.engine;
          var tempRect = new Rect();
          var tempVect2 = new Vector2();
          var spriteAtlas = new SpriteAtlas(engine);
          for (var i = 0; i < atlasItemsLen; i++) {
            var originalImg = imgs[i];
            var width = originalImg.width, height = originalImg.height;
            var texture = new Texture2D(engine, width, height, format);
            texture.setImageSource(originalImg);
            texture.generateMipmaps();
            var atlasItem = atlasItems[i];
            var sprites = atlasItem.sprites;
            var sourceWidthReciprocal = 1 / width;
            var sourceHeightReciprocal = 1 / height;
            for (var j = sprites.length - 1; j >= 0; j--) {
              var atlasSprite = sprites[j];
              var region = atlasSprite.region, pivot = atlasSprite.pivot, atlasRegionOffset = atlasSprite.atlasRegionOffset, atlasRegion = atlasSprite.atlasRegion, id = atlasSprite.id;
              var sprite = new Sprite(engine, texture, region ? tempRect.setValue(region.x, region.y, region.w, region.h) : void 0, pivot ? tempVect2.setValue(pivot.x, pivot.y) : void 0, atlasSprite.pixelsPerUnit || void 0, atlasSprite.name);
              sprite.atlasRegion.setValue(atlasRegion.x * sourceWidthReciprocal, atlasRegion.y * sourceHeightReciprocal, atlasRegion.w * sourceWidthReciprocal, atlasRegion.h * sourceHeightReciprocal);
              atlasSprite.atlasRotated && (sprite.atlasRotated = true);
              if (atlasRegionOffset) {
                var offsetLeft = atlasRegionOffset.x, offsetTop = atlasRegionOffset.y, offsetRight = atlasRegionOffset.z, offsetBottom = atlasRegionOffset.w;
                var originalWReciprocal = void 0, originalHReciprocal = void 0;
                if (atlasSprite.atlasRotated) {
                  originalWReciprocal = 1 / (offsetLeft + atlasRegion.h + offsetRight);
                  originalHReciprocal = 1 / (offsetTop + atlasRegion.w + offsetBottom);
                } else {
                  originalWReciprocal = 1 / (offsetLeft + atlasRegion.w + offsetRight);
                  originalHReciprocal = 1 / (offsetTop + atlasRegion.h + offsetBottom);
                }
                sprite.atlasRegionOffset.setValue(offsetLeft * originalWReciprocal, offsetTop * originalHReciprocal, offsetRight * originalWReciprocal, offsetBottom * originalHReciprocal);
              }
              if (id !== void 0) {
                sprite._assetID = id;
              }
              spriteAtlas._addSprite(sprite);
            }
          }
          resolve(spriteAtlas);
        });
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  return SpriteAtlasLoader;
}(Loader)) || _class$c;
var ExtensionParser = function() {
  function ExtensionParser2() {
  }
  var _proto = ExtensionParser2.prototype;
  _proto.initialize = function initialize() {
  };
  _proto.parseEngineResource = function parseEngineResource(schema, parseResource, context) {
  };
  _proto.createEngineResource = function createEngineResource(schema, context) {
    return null;
  };
  return ExtensionParser2;
}();
var _dec$b;
var _class$b2;
var _class22;
var _temp2;
_dec$b = registerExtension("KHR_draco_mesh_compression"), _dec$b(_class$b2 = (_temp2 = _class22 = function(_ExtensionParser) {
  _inheritsLoose3(KHR_draco_mesh_compression, _ExtensionParser);
  function KHR_draco_mesh_compression() {
    return _ExtensionParser.apply(this, arguments) || this;
  }
  var _proto = KHR_draco_mesh_compression.prototype;
  _proto.initialize = function initialize() {
    if (!KHR_draco_mesh_compression._decoder) {
      KHR_draco_mesh_compression._decoder = new DRACODecoder();
    }
  };
  _proto.createEngineResource = function createEngineResource(schema, context, gltfPrimitive) {
    var gltf = context.gltf, buffers = context.buffers;
    var bufferViews = gltf.bufferViews, accessors = gltf.accessors;
    var bufferViewIndex = schema.bufferView, gltfAttributeMap = schema.attributes;
    var attributeMap = {};
    var attributeTypeMap = {};
    for (var attributeName in gltfAttributeMap) {
      attributeMap[attributeName] = gltfAttributeMap[attributeName];
    }
    for (var _attributeName in gltfPrimitive.attributes) {
      if (gltfAttributeMap[_attributeName] !== void 0) {
        var accessorDef = accessors[gltfPrimitive.attributes[_attributeName]];
        attributeTypeMap[_attributeName] = GLTFUtil.getComponentType(accessorDef.componentType).name;
      }
    }
    var indexAccessor = accessors[gltfPrimitive.indices];
    var indexType = GLTFUtil.getComponentType(indexAccessor.componentType).name;
    var taskConfig = {
      attributeIDs: attributeMap,
      attributeTypes: attributeTypeMap,
      useUniqueIDs: true,
      indexType
    };
    var buffer = GLTFUtil.getBufferViewData(bufferViews[bufferViewIndex], buffers);
    return KHR_draco_mesh_compression._decoder.decode(buffer, taskConfig).then(function(parsedGeometry) {
      return parsedGeometry;
    });
  };
  return KHR_draco_mesh_compression;
}(ExtensionParser), _class22._decoder = void 0, _temp2)) || _class$b2;
var _dec$a;
var _class$a2;
_dec$a = registerExtension("KHR_lights_punctual"), _dec$a(_class$a2 = function(_ExtensionParser) {
  _inheritsLoose3(KHR_lights_punctual, _ExtensionParser);
  function KHR_lights_punctual() {
    return _ExtensionParser.apply(this, arguments) || this;
  }
  var _proto = KHR_lights_punctual.prototype;
  _proto.parseEngineResource = function parseEngineResource(schema, entity, context) {
    var color = schema.color, _schema$intensity = schema.intensity, intensity = _schema$intensity === void 0 ? 1 : _schema$intensity, type = schema.type, range = schema.range, spot = schema.spot;
    var light;
    if (type === "directional") {
      light = entity.addComponent(DirectLight);
    } else if (type === "point") {
      light = entity.addComponent(PointLight);
    } else if (type === "spot") {
      light = entity.addComponent(SpotLight);
    }
    if (color) {
      light.color.setValue(color[0], color[1], color[2], 1);
    }
    light.intensity = intensity;
    if (range && !(light instanceof DirectLight)) {
      light.distance = range;
    }
    if (spot && light instanceof SpotLight) {
      var _spot$innerConeAngle = spot.innerConeAngle, innerConeAngle = _spot$innerConeAngle === void 0 ? 0 : _spot$innerConeAngle, _spot$outerConeAngle = spot.outerConeAngle, outerConeAngle = _spot$outerConeAngle === void 0 ? Math.PI / 4 : _spot$outerConeAngle;
      light.angle = innerConeAngle;
      light.penumbra = outerConeAngle - innerConeAngle;
    }
    if (!context.lights)
      context.lights = [];
    context.lights.push(light);
  };
  return KHR_lights_punctual;
}(ExtensionParser)) || _class$a2;
var _dec$9;
var _class$92;
_dec$9 = registerExtension("KHR_materials_pbrSpecularGlossiness"), _dec$9(_class$92 = function(_ExtensionParser) {
  _inheritsLoose3(KHR_materials_pbrSpecularGlossiness, _ExtensionParser);
  function KHR_materials_pbrSpecularGlossiness() {
    return _ExtensionParser.apply(this, arguments) || this;
  }
  var _proto = KHR_materials_pbrSpecularGlossiness.prototype;
  _proto.createEngineResource = function createEngineResource(schema, context) {
    var engine = context.engine, textures = context.textures;
    var material = new PBRSpecularMaterial(engine);
    var diffuseFactor = schema.diffuseFactor, diffuseTexture = schema.diffuseTexture, specularFactor = schema.specularFactor, glossinessFactor = schema.glossinessFactor, specularGlossinessTexture = schema.specularGlossinessTexture;
    if (diffuseFactor) {
      material.baseColor = _construct2(Color, diffuseFactor);
    }
    if (diffuseTexture) {
      material.baseTexture = textures[diffuseTexture.index];
      MaterialParser._parseTextureTransform(material, diffuseTexture.extensions, context);
    }
    if (specularFactor) {
      material.specularColor = _construct2(Color, specularFactor);
    }
    if (glossinessFactor !== void 0) {
      material.glossiness = glossinessFactor;
    }
    if (specularGlossinessTexture) {
      material.specularGlossinessTexture = textures[specularGlossinessTexture.index];
      MaterialParser._parseTextureTransform(material, specularGlossinessTexture.extensions, context);
    }
    return material;
  };
  return KHR_materials_pbrSpecularGlossiness;
}(ExtensionParser)) || _class$92;
var _dec$8;
var _class$82;
_dec$8 = registerExtension("KHR_materials_unlit"), _dec$8(_class$82 = function(_ExtensionParser) {
  _inheritsLoose3(KHR_materials_unlit, _ExtensionParser);
  function KHR_materials_unlit() {
    return _ExtensionParser.apply(this, arguments) || this;
  }
  var _proto = KHR_materials_unlit.prototype;
  _proto.createEngineResource = function createEngineResource(schema, context) {
    var engine = context.engine;
    var material = new UnlitMaterial(engine);
    return material;
  };
  return KHR_materials_unlit;
}(ExtensionParser)) || _class$82;
var _dec$7;
var _class$72;
_dec$7 = registerExtension("KHR_materials_variants"), _dec$7(_class$72 = function(_ExtensionParser) {
  _inheritsLoose3(KHR_materials_variants, _ExtensionParser);
  function KHR_materials_variants() {
    return _ExtensionParser.apply(this, arguments) || this;
  }
  var _proto = KHR_materials_variants.prototype;
  _proto.parseEngineResource = function parseEngineResource(schema, renderer, context) {
    var variantNames = context.gltf.extensions.KHR_materials_variants.variants, materials = context.materials;
    var mappings = schema.mappings;
    for (var i = 0; i < mappings.length; i++) {
      var _mappings$i = mappings[i], material = _mappings$i.material, variants = _mappings$i.variants;
      if (!context.variants)
        context.variants = [];
      context.variants.push({
        renderer,
        material: materials[material],
        variants: variants.map(function(index) {
          return variantNames[index].name;
        })
      });
    }
  };
  return KHR_materials_variants;
}(ExtensionParser)) || _class$72;
var _dec$6;
var _class$62;
_dec$6 = registerExtension("KHR_mesh_quantization"), _dec$6(_class$62 = function(_ExtensionParser) {
  _inheritsLoose3(KHR_mesh_quantization, _ExtensionParser);
  function KHR_mesh_quantization() {
    return _ExtensionParser.apply(this, arguments) || this;
  }
  return KHR_mesh_quantization;
}(ExtensionParser)) || _class$62;
var _dec$5;
var _class$52;
_dec$5 = registerExtension("KHR_texture_transform"), _dec$5(_class$52 = function(_ExtensionParser) {
  _inheritsLoose3(KHR_texture_transform, _ExtensionParser);
  function KHR_texture_transform() {
    return _ExtensionParser.apply(this, arguments) || this;
  }
  var _proto = KHR_texture_transform.prototype;
  _proto.parseEngineResource = function parseEngineResource(schema, material, context) {
    var offset = schema.offset, rotation = schema.rotation, scale = schema.scale, texCoord = schema.texCoord;
    if (offset) {
      material.tilingOffset.z = offset[0];
      material.tilingOffset.w = offset[1];
    }
    if (scale) {
      material.tilingOffset.x = scale[0];
      material.tilingOffset.y = scale[1];
    }
    if (rotation) {
      Logger.warn("rotation in KHR_texture_transform is not supported now");
    }
    if (texCoord) {
      Logger.warn("texCoord in KHR_texture_transform is not supported now");
    }
  };
  return KHR_texture_transform;
}(ExtensionParser)) || _class$52;
var GLTFModel = function(_Component) {
  _inheritsLoose3(GLTFModel2, _Component);
  function GLTFModel2(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _this._animatorController = void 0;
    _this._speed = 1;
    _this._animator = void 0;
    _this._asset = void 0;
    _this._glTFEntity = void 0;
    _this._clipPreview = void 0;
    _this._hasBuiltNode = false;
    _this._controllerUpdateFlag = void 0;
    return _this;
  }
  var _proto = GLTFModel2.prototype;
  _proto.init = function init(props) {
    var _props$asset = props.asset, asset = _props$asset === void 0 ? null : _props$asset, speed = props.speed, animatorController = props.animatorController, clipPreview = props.clipPreview, isClone = props.isClone;
    if (isClone) {
      var rootName = props.gltfRootName;
      if (rootName) {
        this._glTFEntity = this.entity.findByName(rootName);
      }
    }
    if (!this._glTFEntity) {
      var _rootName = "GLTF-" + Date.now();
      props.gltfRootName = _rootName;
      this._glTFEntity = this.entity.createChild(_rootName);
      this._hasBuiltNode = false;
    } else {
      this._hasBuiltNode = true;
    }
    this.asset = asset;
    this.animatorController = animatorController;
    this.speed = speed;
    this.clipPreview = clipPreview;
  };
  _proto.update = function update() {
    if (this._animator) {
      var _this$_controllerUpda;
      if ((_this$_controllerUpda = this._controllerUpdateFlag) !== null && _this$_controllerUpda !== void 0 && _this$_controllerUpda.flag) {
        this._playState();
      }
    }
  };
  _proto._onEnable = function _onEnable() {
    this._glTFEntity && (this._glTFEntity.isActive = true);
    this.engine._componentsManager.addOnUpdateAnimations(this);
  };
  _proto._onDisable = function _onDisable() {
    this._glTFEntity && (this._glTFEntity.isActive = false);
    this.engine._componentsManager.removeOnUpdateAnimations(this);
  };
  _proto._playState = function _playState() {
    var playStateName = this._clipPreview;
    if (playStateName) {
      var _this$_controllerUpda2;
      this._animator.play(playStateName, 0);
      if ((_this$_controllerUpda2 = this._controllerUpdateFlag) !== null && _this$_controllerUpda2 !== void 0 && _this$_controllerUpda2.flag) {
        this._controllerUpdateFlag.flag = false;
      }
    } else {
      this._playDefaultState();
    }
  };
  _proto._playDefaultState = function _playDefaultState() {
    var animatorController = this._animatorController, animator = this._animator;
    if (!animator)
      return;
    if (animatorController) {
      var layers = animatorController.layers;
      for (var i = 0, length2 = layers.length; i < length2; ++i) {
        var _layers$i$stateMachin, _layers$i, _layers$i$stateMachin2, _layers$i2, _layers$i2$stateMachi;
        var defaultState = (_layers$i$stateMachin = (_layers$i = layers[i]) === null || _layers$i === void 0 ? void 0 : (_layers$i$stateMachin2 = _layers$i.stateMachine) === null || _layers$i$stateMachin2 === void 0 ? void 0 : _layers$i$stateMachin2._defaultState) != null ? _layers$i$stateMachin : (_layers$i2 = layers[i]) === null || _layers$i2 === void 0 ? void 0 : (_layers$i2$stateMachi = _layers$i2.stateMachine) === null || _layers$i2$stateMachi === void 0 ? void 0 : _layers$i2$stateMachi.states[0];
        var defaultStateName = defaultState === null || defaultState === void 0 ? void 0 : defaultState.name;
        if (defaultStateName) {
          var _this$_controllerUpda3;
          animator.play(defaultStateName, i);
          if ((_this$_controllerUpda3 = this._controllerUpdateFlag) !== null && _this$_controllerUpda3 !== void 0 && _this$_controllerUpda3.flag) {
            this._controllerUpdateFlag.flag = false;
          }
        }
      }
    }
  };
  _createClass4(GLTFModel2, [{
    key: "asset",
    get: function get4() {
      return this._asset;
    },
    set: function set4(value) {
      var animatorController = this._animatorController, speed = this._speed;
      var entity = this._glTFEntity;
      if (value && value.defaultSceneRoot === this._glTFEntity) {
        return;
      }
      if (!this._hasBuiltNode) {
        entity.clearChildren();
        if (value !== null) {
          entity === null || entity === void 0 ? void 0 : entity.destroy();
          var gltfEntity = value.defaultSceneRoot.clone();
          this._animator = gltfEntity.getComponent(Animator);
          this.entity.addChild(gltfEntity);
          gltfEntity.isActive = this.enabled;
          this._glTFEntity = gltfEntity;
        }
      }
      if (animatorController) {
        this._animator.animatorController = animatorController;
        this._animator.speed = speed;
        this._playState();
      }
      this._asset = value;
    }
  }, {
    key: "animatorController",
    get: function get4() {
      return this._animatorController;
    },
    set: function set4(animatorController) {
      var animator = this._animator;
      if (animatorController !== this._animatorController) {
        this._controllerUpdateFlag && this._controllerUpdateFlag.destroy();
        this._controllerUpdateFlag = animatorController && animatorController._registerChangeFlag();
        this._animatorController = animatorController;
        if (animator) {
          animator.animatorController = animatorController;
          this._playState();
        }
      }
    }
  }, {
    key: "speed",
    get: function get4() {
      return this._speed;
    },
    set: function set4(speed) {
      var animator = this._animator;
      this._speed = speed;
      if (animator) {
        animator.speed = speed;
        this._playState();
      }
    }
  }, {
    key: "animator",
    get: function get4() {
      return this._animator;
    }
  }, {
    key: "clipPreview",
    get: function get4() {
      return this._clipPreview;
    },
    set: function set4(value) {
      if (this._animator) {
        if (value) {
          this._animator.play(value, 0);
        } else {
          this._playDefaultState();
        }
      }
      this._clipPreview = value;
    }
  }]);
  return GLTFModel2;
}(Component);
var Model = function(_MeshRenderer) {
  _inheritsLoose3(Model2, _MeshRenderer);
  function Model2(entity) {
    var _this;
    _this = _MeshRenderer.call(this, entity) || this;
    _this._props = null;
    _this.setMaterial(new BlinnPhongMaterial(_this.engine));
    return _this;
  }
  var _proto = Model2.prototype;
  _proto.setProps = function setProps(props) {
    if (props === void 0) {
      props = {};
    }
    if (this._props !== props) {
      this._props = props;
    }
    switch (props.geometryType) {
      case "Sphere":
        this.mesh = PrimitiveMesh.createSphere(this._engine, props.sphereRadius, props.sphereSegments);
        break;
      case "Cylinder":
        this.mesh = PrimitiveMesh.createCylinder(this._engine, props.cylinderRadiusTop, props.cylinderRadiusBottom, props.cylinderHeight, props.cylinderRadialSegments, props.cylinderHeightSegments);
        break;
      case "Plane":
        this.mesh = PrimitiveMesh.createPlane(this._engine, props.planeWidth, props.planeHeight, props.planeHorizontalSegments, props.planeVerticalSegments);
        break;
      case "Box":
        this.mesh = PrimitiveMesh.createCuboid(this._engine, props.boxWidth, props.boxHeight, props.boxDepth);
        break;
    }
  };
  _proto.updateProp = function updateProp(key, value) {
    var props = this._props;
    props[key] = value;
    this.setProps(props);
  };
  _createClass4(Model2, [{
    key: "material",
    get: function get4() {
      return this.getMaterial();
    },
    set: function set4(mtl) {
      this.setMaterial(mtl);
    }
  }]);
  return Model2;
}(MeshRenderer);
var PluginManager = function() {
  function PluginManager2() {
    this.registeredPlugins = new Set();
    this.plugins = [];
  }
  var _proto = PluginManager2.prototype;
  _proto.register = function register(plugin) {
    this.registeredPlugins.add(plugin);
  };
  _proto.boot = function boot(oasis) {
    for (var _iterator = _createForOfIteratorHelperLoose2(this.registeredPlugins.values()), _step; !(_step = _iterator()).done; ) {
      var plugin = _step.value;
      if (typeof plugin === "function") {
        plugin = plugin(oasis);
      }
      this.plugins.push(plugin);
    }
  };
  _proto.reset = function reset() {
    this.registeredPlugins.clear();
    this.plugins = [];
  };
  _proto.nodeAdded = function nodeAdded(entity) {
    this.delegateMethod("nodeAdded", entity);
  };
  _proto.delegateMethod = function delegateMethod(name) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    this.plugins.forEach(function(plugin) {
      return plugin[name] && plugin[name].apply(plugin, args);
    });
  };
  return PluginManager2;
}();
function pluginHook(options) {
  return function(target, propertyName, descriptor) {
    var method = descriptor.value;
    descriptor.value = function() {
      var _this$oasis$pluginMan, _this = this;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      options.before && (_this$oasis$pluginMan = this.oasis.pluginManager).delegateMethod.apply(_this$oasis$pluginMan, [options.before].concat(args));
      return Promise.resolve(method.apply(this, arguments)).then(function(returnObj) {
        options.after && _this.oasis.pluginManager.delegateMethod(options.after, returnObj);
        return returnObj;
      });
    };
  };
}
function compatibleToV2(config) {
  var _config$abilities = config.abilities, abilities = _config$abilities === void 0 ? {} : _config$abilities, _config$assets = config.assets, assets = _config$assets === void 0 ? {} : _config$assets, _config$scene = config.scene, scene = _config$scene === void 0 ? {} : _config$scene;
  var ids = Object.keys(abilities);
  var assetKeys = Object.keys(assets);
  var sceneKeys = Object.keys(scene || {});
  for (var i = 0, l = ids.length; i < l; ++i) {
    handleComponents(abilities[ids[i]].props);
  }
  for (var _i = 0, _l = assetKeys.length; _i < _l; ++_i) {
    handleAssets(assets[assetKeys[_i]].props);
  }
  for (var _i2 = 0, _l2 = sceneKeys.length; _i2 < _l2; ++_i2) {
    handleSceneProps(scene[sceneKeys[_i2]].props);
  }
  return config;
}
function handleComponents(props) {
  var keys = Object.keys(props);
  for (var i = 0, l = keys.length; i < l; ++i) {
    var k = keys[i];
    var v = props[k];
    if (Array.isArray(v) && typeof v[0] !== "object") {
      if (["color", "diffuseColor", "specularColor"].indexOf(k) !== -1) {
        props[k] = new Color(v[0], v[1], v[2], v[3]);
      } else if (v.length === 4) {
        props[k] = new Vector4(v[0], v[1], v[2], v[3]);
      } else if (v.length === 3) {
        props[k] = new Vector3(v[0], v[1], v[2]);
      } else if (v.length === 2) {
        props[k] = new Vector2(v[0], v[1]);
      }
    }
  }
}
var sh = new SphericalHarmonics3();
function handleSceneProps(props) {
  var keys = Object.keys(props);
  for (var i = 0, l = keys.length; i < l; ++i) {
    var k = keys[i];
    var v = props[k];
    if (Array.isArray(v) && typeof v[0] !== "object") {
      if (/color/i.test(k)) {
        props[k] = new Color(v[0], v[1], v[2], v[3]);
      } else if (v.length === 4) {
        props[k] = new Vector4(v[0], v[1], v[2], v[3]);
      } else if (v.length === 3) {
        props[k] = new Vector3(v[0], v[1], v[2]);
      } else if (v.length === 2) {
        props[k] = new Vector2(v[0], v[1]);
      }
    } else if (v && k === "diffuseSphericalHarmonics") {
      sh.setValueByArray(JSON.parse(v));
      props[k] = sh;
    }
  }
}
function handleAssets(props) {
  if (props === void 0) {
    props = {};
  }
  if (!props) {
    return;
  }
  var keys = Object.keys(props);
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    var value = props[key];
    if (key === "newMaterial" || key === "scripts") {
      continue;
    }
    if (Array.isArray(value) && typeof value[0] !== "object") {
      if (["emissiveColor", "diffuseColor", "specularColor", "baseColor"].indexOf(key) !== -1) {
        props[key] = new Color(value[0], value[1], value[2], value[3]);
      } else if (value.length === 4) {
        props[key] = new Vector4(value[0], value[1], value[2], value[3]);
      } else if (value.length === 3) {
        props[key] = new Vector3(value[0], value[1], value[2]);
      } else if (value.length === 2) {
        props[key] = new Vector2(value[0], value[1]);
      }
    }
  }
}
var CURRENT_SCHEMA_VERSION = 3;
var Parser = function() {
  var _proto = Parser2.prototype;
  _proto.parse = function parse2(options) {
    var _options$config;
    if ((options === null || options === void 0 ? void 0 : (_options$config = options.config) === null || _options$config === void 0 ? void 0 : _options$config.version) !== CURRENT_SCHEMA_VERSION) {
      var _options$config2;
      console.warn('schema-parser: schema version "' + (options === null || options === void 0 ? void 0 : (_options$config2 = options.config) === null || _options$config2 === void 0 ? void 0 : _options$config2.version) + '" is out of date, please re-pull the latest version (version ' + CURRENT_SCHEMA_VERSION + ") of the schema");
    }
    compatibleToV2(options.config);
    return Oasis.create(options, this.pluginManager);
  };
  _proto.register = function register(plugin) {
    this.pluginManager.register(plugin);
  };
  _proto.resetPlugins = function resetPlugins() {
    this.pluginManager.reset();
  };
  function Parser2() {
    this.pluginManager = new PluginManager();
  }
  Parser2.create = function create() {
    var parser2 = new Parser2();
    return parser2;
  };
  Parser2.registerComponents = function registerComponents(namespace, components) {
    if (!this._components[namespace]) {
      this._components[namespace] = {};
    }
    _extends2(this._components[namespace], components);
  };
  return Parser2;
}();
Parser._components = {};
var parser = Parser.create();
function switchElementsIndex(elements, currentIndex, targetIndex) {
  if (currentIndex === targetIndex || targetIndex === null || targetIndex === void 0) {
    return;
  }
  var _ref = [elements[targetIndex], elements[currentIndex]];
  elements[currentIndex] = _ref[0];
  elements[targetIndex] = _ref[1];
}
function isAsset(config) {
  return config && config.type === "asset";
}
function getAllGetters(obj) {
  var result = [];
  var prototype = Object.getPrototypeOf(obj);
  var prototype_property_descriptors = Object.getOwnPropertyDescriptors(prototype);
  for (var _i = 0, _Object$entries = Object.entries(prototype_property_descriptors); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _Object$entries[_i], property = _Object$entries$_i[0], descriptor = _Object$entries$_i[1];
    if (typeof descriptor.get === "function") {
      result.push(property);
    }
  }
  return result;
}
var SchemaResource = function() {
  var _proto = SchemaResource2.prototype;
  _proto.setMeta = function setMeta() {
  };
  function SchemaResource2(resourceManager, _resource) {
    this.resourceManager = resourceManager;
    this._resource = _resource;
    this._meta = {};
    this._attachedResources = [];
    this.setMeta();
  }
  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceLoader2, assetConfig, oasis) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this.load(resourceLoader2, assetConfig, oasis).then(function() {
        resolve({
          resources: [_this],
          structure: {
            index: 0,
            props: {}
          }
        });
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  _proto.getProps = function getProps() {
    return {};
  };
  _proto.bind = function bind() {
  };
  _proto.attach = function attach() {
  };
  _proto.update = function update(key, value) {
    if (isAsset(value)) {
      var resource = this.resourceManager.get(value.id);
      if (resource) {
        this._resource[key] = resource.resource;
      } else {
        Logger.warn("SchemaResource: " + this.meta.name + " can't find asset, which id is: " + value.id);
      }
    } else {
      this._resource[key] = value;
    }
  };
  _proto.updateMeta = function updateMeta(key, value) {
    this._meta[key] = value;
  };
  _proto.onDestroy = function onDestroy() {
  };
  _createClass4(SchemaResource2, [{
    key: "resource",
    get: function get4() {
      return this._resource;
    }
  }, {
    key: "meta",
    get: function get4() {
      return this._meta;
    }
  }, {
    key: "attachedResources",
    get: function get4() {
      return this._attachedResources;
    }
  }]);
  return SchemaResource2;
}();
var AnimationClipResource = function(_SchemaResource) {
  _inheritsLoose3(AnimationClipResource2, _SchemaResource);
  function AnimationClipResource2() {
    return _SchemaResource.apply(this, arguments) || this;
  }
  var _proto = AnimationClipResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig) {
    var _this = this;
    return new Promise(function(resolve) {
      _this._resource = assetConfig.props || {};
      _this.setMeta();
      resolve(_this);
    });
  };
  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      var loadPromise;
      if (assetConfig.props) {
        loadPromise = _this2.load(resourceManager, assetConfig);
      } else {
        reject("Load AnimationClip Error");
      }
      if (loadPromise) {
        loadPromise.then(function() {
          var result = {
            resources: [_this2],
            structure: {
              index: 0,
              props: {}
            }
          };
          resolve(result);
        });
      }
    });
  };
  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };
  _proto.getProps = function getProps() {
    return this._resource;
  };
  return AnimationClipResource2;
}(SchemaResource);
var AnimatorControllerResource = function(_SchemaResource) {
  _inheritsLoose3(AnimatorControllerResource2, _SchemaResource);
  function AnimatorControllerResource2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.gltf = void 0;
    _this.animatorControllerData = void 0;
    _this.animationClipAssets = void 0;
    _this.animationsIndices = void 0;
    return _this;
  }
  var _proto = AnimatorControllerResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig) {
    var _this2 = this;
    return new Promise(function(resolve) {
      var _ref = assetConfig.props || {}, animatorController = _ref.animatorController, animationClipAssets = _ref.animationClips, animationsIndices = _ref.animationsIndices, gltf = _ref.gltf;
      _this2._resource = new AnimatorController();
      _this2.animatorControllerData = animatorController;
      _this2.animationsIndices = animationsIndices || [];
      _this2.animationClipAssets = animationClipAssets || [];
      _this2.gltf = gltf;
      !animatorController && _this2._setDefaultDataByAnimationClip();
      _this2.setMetaData("name", assetConfig.name);
      resolve(_this2);
    });
  };
  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this3 = this;
    return new Promise(function(resolve, reject) {
      var clipLoadPromises = [];
      _this3.load(resourceManager, assetConfig).then(function() {
        var result = {
          resources: [_this3],
          structure: {
            index: 0,
            props: {
              animationClips: []
            }
          }
        };
        var animations = _this3.animationsIndices;
        for (var i = 0, length2 = animations.length; i < length2; ++i) {
          var clip = animations[i];
          var clipResourse = new AnimationClipResource(_this3.resourceManager);
          _this3.attachedResources.push(clipResourse);
          clipLoadPromises.push(clipResourse.loadWithAttachedResources(resourceManager, {
            type: "animationClip",
            name: clip.name,
            props: clip
          }));
        }
        Promise.all(clipLoadPromises).then(function(res) {
          var animationClips = result.structure.props.animationClips;
          res.forEach(function(clip2) {
            var clipStructure = clip2.structure;
            var clipResource = clip2.resources[clipStructure.index];
            result.resources.push(clipResource);
            clipStructure.index = result.resources.length - 1;
            animationClips.push(clipStructure);
          });
          resolve(result);
        });
      });
    });
  };
  _proto.setMetaData = function setMetaData(key, value) {
    this._meta[key] = value;
  };
  _proto.update = function update(key, value) {
    this._initAnimatorController(value);
  };
  _proto.bind = function bind() {
    var animatorControllerData = this.animatorControllerData, animationClipAssets = this.animationClipAssets;
    this._bindClips(animationClipAssets);
    if (animatorControllerData) {
      this._initAnimatorController(animatorControllerData);
    } else {
      this._setDefaultDataByAnimationClipAsset();
    }
  };
  _proto._initAnimatorController = function _initAnimatorController(animatorControllerData) {
    var _ref2 = this.gltf || {}, animations = _ref2.animations;
    var layers = animatorControllerData.layers;
    if (!animations || !layers)
      return;
    this._resource.clearLayers();
    for (var i = 0, length2 = layers.length; i < length2; ++i) {
      var _layers$i = layers[i], name = _layers$i.name, blending = _layers$i.blending, weight = _layers$i.weight, stateMachineData = _layers$i.stateMachine;
      if (!stateMachineData)
        continue;
      var layer = new AnimatorControllerLayer(name);
      layer.blendingMode = blending;
      layer.weight = weight;
      var states = stateMachineData.states;
      var stateMachine = new AnimatorStateMachine();
      var stateMachineTransitions = [];
      for (var j = 0, _length = states.length; j < _length; ++j) {
        var stateData = states[j];
        var _name = stateData.name, transitions = stateData.transitions, clip = stateData.clip, speed = stateData.speed, wrapMode = stateData.wrapMode, clipStartNormalizedTime = stateData.clipStartNormalizedTime, clipEndNormalizedTime = stateData.clipEndNormalizedTime, isDefaultState = stateData.isDefaultState;
        var _ref3 = clip || {}, clipAssetId = _ref3.id;
        if (!clipAssetId)
          continue;
        var uniqueName = stateMachine.makeUniqueStateName(_name);
        if (uniqueName !== _name) {
          console.warn("AnimatorState name is existed, name: " + _name + " reset to " + uniqueName);
        }
        var state = stateMachine.addState(uniqueName);
        state.speed = speed;
        state.wrapMode = wrapMode;
        var animationIndex = this.resourceManager.get(clipAssetId).resource;
        var animationClip = animations[animationIndex.index];
        if (!animationClip)
          continue;
        state.clip = animationClip;
        state.clipStartTime = animationClip.length * clipStartNormalizedTime;
        state.clipEndTime = animationClip.length * clipEndNormalizedTime;
        for (var _j = 0, _length2 = transitions.length; _j < _length2; ++_j) {
          var transition = transitions[_j];
          transitions[_j].srcState = state;
          stateMachineTransitions.push(transition);
        }
        if (isDefaultState) {
          stateMachine._defaultState = state;
        }
      }
      for (var _j2 = 0, _length3 = stateMachineTransitions.length; _j2 < _length3; ++_j2) {
        var transitionData = stateMachineTransitions[_j2];
        var _transition = new AnimatorStateTransition();
        _transition.duration = transitionData.duration;
        _transition.offset = transitionData.offset;
        _transition.exitTime = transitionData.exitTime;
        _transition.destinationState = stateMachine.findStateByName(transitionData.targetStateName);
        transitionData.srcState.addTransition(_transition);
        delete transitionData.srcState;
      }
      layer.stateMachine = stateMachine;
      this._resource.addLayer(layer);
    }
  };
  _proto._bindClips = function _bindClips(animationClips) {
    for (var i = 0, length2 = animationClips.length; i < length2; i++) {
      var clipAsset = animationClips[i];
      var clipResource = this.resourceManager.get(clipAsset.id);
      if (clipResource) {
        this._attachedResources.push(clipResource);
      } else {
        "AnimatorResource: " + this.meta.name + ` can't find asset "animationClip", which id is: ` + clipAsset.id;
      }
    }
  };
  _proto._setDefaultDataByAnimationClipAsset = function _setDefaultDataByAnimationClipAsset() {
    var animationClipAssets = this.animationClipAssets;
    if (!animationClipAssets.length) {
      return;
    }
    var clips = [];
    for (var i = 0, length2 = animationClipAssets.length; i < length2; i++) {
      var clipAsset = this.resourceManager.get(animationClipAssets[i].id);
      clips.push(clipAsset.resource);
    }
    this.animationsIndices = clips;
    this._setDefaultDataByAnimationClip();
  };
  _proto._setDefaultDataByAnimationClip = function _setDefaultDataByAnimationClip() {
    var animationsIndices = this.animationsIndices, animatorController = this._resource, gltf = this.gltf;
    if (!animationsIndices.length || !gltf) {
      return;
    }
    var animations = gltf.animations;
    var layer = new AnimatorControllerLayer("layer");
    var animatorStateMachine = new AnimatorStateMachine();
    animatorController.addLayer(layer);
    layer.stateMachine = animatorStateMachine;
    for (var i = 0, length2 = animationsIndices.length; i < length2; i++) {
      var animationIndex = animationsIndices[i];
      var name = animationIndex.name, index = animationIndex.index;
      var uniqueName = animatorStateMachine.makeUniqueStateName(name);
      if (uniqueName !== name) {
        console.warn("AnimatorState name is existed, name: " + name + " reset to " + uniqueName);
      }
      var animatorState = animatorStateMachine.addState(uniqueName);
      animatorState.clip = animations[index];
    }
  };
  return AnimatorControllerResource2;
}(SchemaResource);
var TextureResource = function(_SchemaResource) {
  _inheritsLoose3(TextureResource2, _SchemaResource);
  function TextureResource2() {
    return _SchemaResource.apply(this, arguments) || this;
  }
  var _proto = TextureResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig, oasis) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      var _assetConfig$props, _assetConfig$props$co, _url;
      var url;
      var assetType = AssetType.Texture2D;
      if (_this.resourceManager.useCompressedTexture && assetConfig !== null && assetConfig !== void 0 && (_assetConfig$props = assetConfig.props) !== null && _assetConfig$props !== void 0 && (_assetConfig$props$co = _assetConfig$props.compression) !== null && _assetConfig$props$co !== void 0 && _assetConfig$props$co.compressions.length) {
        var rhi = oasis.engine._hardwareRenderer;
        var compressions = assetConfig.props.compression.compressions;
        for (var i = 0; i < compressions.length; i++) {
          var compression = compressions[i];
          if (compression.container === "ktx" && rhi.canIUse(GLCapabilityType[compression.type])) {
            url = compression.url;
            assetType = AssetType.KTX;
            break;
          }
        }
      }
      url = (_url = url) != null ? _url : assetConfig.url;
      resourceManager.load({
        url,
        type: assetType
      }).then(function(res) {
        _this._resource = res;
        resolve(_this);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this._meta.name = this.resource.name;
    }
  };
  return TextureResource2;
}(SchemaResource);
var BlinnPhongMaterialResource = function(_SchemaResource) {
  _inheritsLoose3(BlinnPhongMaterialResource2, _SchemaResource);
  function BlinnPhongMaterialResource2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.configProps = void 0;
    return _this;
  }
  var _proto = BlinnPhongMaterialResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig) {
    var _this2 = this;
    return new Promise(function(resolve) {
      var assetObj = new BlinnPhongMaterial(resourceManager.engine);
      _this2.configProps = assetConfig.props;
      _this2._resource = assetObj;
      for (var k in _this2.configProps) {
        if (!isAsset(_this2.configProps[k])) {
          assetObj[k] = _this2.configProps[k];
        }
      }
      _this2.setMeta();
      resolve(_this2);
    });
  };
  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this3 = this;
    return new Promise(function(resolve, reject) {
      var loadPromise;
      if (assetConfig.resource instanceof BlinnPhongMaterial) {
        loadPromise = new Promise(function(resolve2) {
          _this3._resource = assetConfig.resource;
          _this3.setMeta();
          resolve2(_this3);
        });
      } else if (assetConfig.props) {
        loadPromise = _this3.load(resourceManager, assetConfig);
      } else {
        reject("Load BlinnPhongMaterial Error");
      }
      if (loadPromise) {
        loadPromise.then(function() {
          var result = {
            resources: [_this3],
            structure: {
              index: 0,
              props: {}
            }
          };
          var material = _this3._resource;
          getAllGetters(_this3._resource).forEach(function(attr) {
            if (!(material[attr] instanceof Texture))
              return;
            var textureResource = new TextureResource(_this3.resourceManager, material[attr]);
            _this3.attachedResources.push(textureResource);
            result.resources.push(textureResource);
            result.structure.props[attr] = {
              index: result.resources.length - 1
            };
          });
          resolve(result);
        });
      }
    });
  };
  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };
  _proto.bind = function bind() {
    var _this4 = this;
    var resource = this._resource;
    Object.keys(this.configProps).forEach(function(attr) {
      var value = _this4.configProps[attr];
      if (isAsset(value)) {
        var textureResource = _this4.resourceManager.get(value.id);
        if (textureResource && textureResource instanceof TextureResource) {
          resource[attr] = textureResource.resource;
          _this4._attachedResources.push(textureResource);
        } else {
          resource[attr] = null;
          Logger.warn("BlinnPhongMaterialResource: " + _this4.meta.name + ` can't find asset "` + attr + '", which id is: ' + value.id);
        }
      } else {
        resource[attr] = value;
      }
    });
  };
  return BlinnPhongMaterialResource2;
}(SchemaResource);
var attrs$1 = [
  "metallic",
  "roughness",
  "roughnessMetallicTexture",
  "tilingOffset",
  "baseColor",
  "normalTextureIntensity",
  "emissiveColor",
  "occlusionTextureIntensity",
  "baseTexture",
  "normalTexture",
  "emissiveTexture",
  "occlusionTexture",
  "isTransparent",
  "alphaCutoff",
  "renderFace",
  "blendMode"
];
var PBRMaterialResource = function(_SchemaResource) {
  _inheritsLoose3(PBRMaterialResource2, _SchemaResource);
  function PBRMaterialResource2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.configProps = void 0;
    return _this;
  }
  var _proto = PBRMaterialResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig) {
    var _this2 = this;
    return new Promise(function(resolve) {
      var assetObj = new PBRMaterial(resourceManager.engine);
      _this2.configProps = assetConfig.props;
      for (var k in _this2.configProps) {
        if (!isAsset(_this2.configProps[k])) {
          assetObj[k] = _this2.configProps[k];
        }
      }
      _this2._resource = assetObj;
      _this2.setMeta();
      resolve(_this2);
    });
  };
  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this3 = this;
    return new Promise(function(resolve, reject) {
      var loadPromise;
      if (assetConfig.resource instanceof PBRMaterial) {
        loadPromise = new Promise(function(resolve2) {
          _this3._resource = assetConfig.resource;
          _this3.setMeta();
          resolve2(_this3);
        });
      } else if (assetConfig.props) {
        loadPromise = _this3.load(resourceManager, assetConfig);
      } else {
        reject("Load PBRMaterial Error");
      }
      if (loadPromise) {
        loadPromise.then(function() {
          var result = {
            resources: [_this3],
            structure: {
              index: 0,
              props: {}
            }
          };
          var material = _this3._resource;
          attrs$1.forEach(function(attr) {
            if (!(material[attr] instanceof Texture))
              return;
            var textureResource = new TextureResource(_this3.resourceManager, material[attr]);
            _this3.attachedResources.push(textureResource);
            result.resources.push(textureResource);
            result.structure.props[attr] = {
              index: result.resources.length - 1
            };
          });
          resolve(result);
        });
      }
    });
  };
  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };
  _proto.getProps = function getProps() {
    var _this4 = this;
    var result = {};
    attrs$1.forEach(function(prop) {
      return result[prop] = _this4.resource[prop];
    });
    return result;
  };
  _proto.bind = function bind() {
    var _this5 = this;
    var resource = this._resource;
    Object.keys(this.configProps).forEach(function(attr) {
      var value = _this5.configProps[attr];
      if (isAsset(value)) {
        var textureResource = _this5.resourceManager.get(value.id);
        if (textureResource && textureResource instanceof TextureResource) {
          resource[attr] = textureResource.resource;
          _this5._attachedResources.push(textureResource);
        } else {
          resource[attr] = null;
          Logger.warn("PBRMaterialResource: " + _this5.meta.name + ` can't find asset "` + attr + '", which id is: ' + value.id);
        }
      } else {
        resource[attr] = value;
      }
    });
  };
  return PBRMaterialResource2;
}(SchemaResource);
var attrs = [
  "specularColor",
  "glossiness",
  "specularGlossinessTexture",
  "tilingOffset",
  "baseColor",
  "normalTextureIntensity",
  "emissiveColor",
  "occlusionTextureIntensity",
  "baseTexture",
  "normalTexture",
  "emissiveTexture",
  "occlusionTexture",
  "isTransparent",
  "alphaCutoff",
  "renderFace",
  "blendMode"
];
var PBRSpecularMaterialResource = function(_SchemaResource) {
  _inheritsLoose3(PBRSpecularMaterialResource2, _SchemaResource);
  function PBRSpecularMaterialResource2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.configProps = void 0;
    return _this;
  }
  var _proto = PBRSpecularMaterialResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig) {
    var _this2 = this;
    return new Promise(function(resolve) {
      var assetObj = new PBRSpecularMaterial(resourceManager.engine);
      _this2.configProps = assetConfig.props;
      _this2._resource = assetObj;
      for (var k in _this2.configProps) {
        if (!isAsset(_this2.configProps[k])) {
          assetObj[k] = _this2.configProps[k];
        }
      }
      _this2.setMeta();
      resolve(_this2);
    });
  };
  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this3 = this;
    return new Promise(function(resolve, reject) {
      var loadPromise;
      if (assetConfig.resource instanceof PBRSpecularMaterial) {
        loadPromise = new Promise(function(resolve2) {
          _this3._resource = assetConfig.resource;
          _this3.setMeta();
          resolve2(_this3);
        });
      } else if (assetConfig.props) {
        loadPromise = _this3.load(resourceManager, assetConfig);
      } else {
        reject("Load PBRSpecularMaterial Error");
      }
      if (loadPromise) {
        loadPromise.then(function() {
          var result = {
            resources: [_this3],
            structure: {
              index: 0,
              props: {}
            }
          };
          var material = _this3._resource;
          Object.keys(_this3._resource).forEach(function(attr) {
            if (!(material[attr] instanceof Texture))
              return;
            var textureResource = new TextureResource(_this3.resourceManager, material[attr]);
            _this3.attachedResources.push(textureResource);
            result.resources.push(textureResource);
            result.structure.props[attr] = {
              index: result.resources.length - 1
            };
          });
          resolve(result);
        });
      }
    });
  };
  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };
  _proto.getProps = function getProps() {
    var _this4 = this;
    var result = {};
    attrs.forEach(function(prop) {
      return result[prop] = _this4.resource[prop];
    });
    return result;
  };
  _proto.bind = function bind() {
    var _this5 = this;
    var resource = this._resource;
    Object.keys(this.configProps).forEach(function(attr) {
      var value = _this5.configProps[attr];
      if (isAsset(value)) {
        var textureResource = _this5.resourceManager.get(value.id);
        if (textureResource && textureResource instanceof TextureResource) {
          resource[attr] = textureResource.resource;
          _this5._attachedResources.push(textureResource);
        } else {
          resource[attr] = null;
          Logger.warn("PBRSpecularMaterialResource: " + _this5.meta.name + ` can't find asset "` + attr + '", which id is: ' + value.id);
        }
      } else {
        resource[attr] = value;
      }
    });
  };
  return PBRSpecularMaterialResource2;
}(SchemaResource);
var UnlitMaterialResource = function(_SchemaResource) {
  _inheritsLoose3(UnlitMaterialResource2, _SchemaResource);
  function UnlitMaterialResource2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.configProps = void 0;
    return _this;
  }
  var _proto = UnlitMaterialResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig) {
    var _this2 = this;
    return new Promise(function(resolve) {
      var assetObj = new UnlitMaterial(resourceManager.engine);
      _this2.configProps = assetConfig.props;
      for (var k in _this2.configProps) {
        if (!isAsset(_this2.configProps[k])) {
          assetObj[k] = _this2.configProps[k];
        }
      }
      _this2._resource = assetObj;
      _this2.setMeta();
      resolve(_this2);
    });
  };
  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this3 = this;
    return new Promise(function(resolve, reject) {
      var loadPromise;
      if (assetConfig.resource instanceof UnlitMaterial) {
        loadPromise = new Promise(function(resolve2) {
          _this3._resource = assetConfig.resource;
          _this3.setMeta();
          resolve2(_this3);
        });
      } else if (assetConfig.props) {
        loadPromise = _this3.load(resourceManager, assetConfig);
      } else {
        reject("Load PBRMaterial Error");
      }
      if (loadPromise) {
        loadPromise.then(function() {
          var result = {
            resources: [_this3],
            structure: {
              index: 0,
              props: {}
            }
          };
          var material = _this3._resource;
          getAllGetters(_this3._resource).forEach(function(attr) {
            if (!(material[attr] instanceof Texture))
              return;
            var textureResource = new TextureResource(_this3.resourceManager, material[attr]);
            _this3.attachedResources.push(textureResource);
            result.resources.push(textureResource);
            result.structure.props[attr] = {
              index: result.resources.length - 1
            };
          });
          resolve(result);
        });
      }
    });
  };
  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };
  _proto.getProps = function getProps() {
    var _this4 = this;
    var result = {};
    var props = getAllGetters(this.resource);
    props.forEach(function(prop) {
      return result[prop] = _this4.resource[prop];
    });
    return result;
  };
  _proto.bind = function bind() {
    var _this5 = this;
    var resource = this._resource;
    Object.keys(this.configProps).forEach(function(attr) {
      var value = _this5.configProps[attr];
      if (isAsset(value)) {
        var textureResource = _this5.resourceManager.get(value.id);
        if (textureResource && textureResource instanceof TextureResource) {
          resource[attr] = textureResource.resource;
          _this5._attachedResources.push(textureResource);
        } else {
          resource[attr] = null;
          Logger.warn("PBRMaterialResource: " + _this5.meta.name + ` can't find asset "` + attr + '", which id is: ' + value.id);
        }
      } else {
        resource[attr] = value;
      }
    });
  };
  return UnlitMaterialResource2;
}(SchemaResource);
var GLTFResource = function(_SchemaResource) {
  _inheritsLoose3(GLTFResource2, _SchemaResource);
  function GLTFResource2() {
    return _SchemaResource.apply(this, arguments) || this;
  }
  var _proto = GLTFResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig, oasis) {
    var _this = this;
    return resourceManager.load({
      url: assetConfig.url,
      type: AssetType.Prefab
    }).then(function(res) {
      var gltf = res;
      if (assetConfig.props) {
        gltf.newMaterial = assetConfig.props.newMaterial;
        gltf.animatorControllers = assetConfig.props.animatorControllers;
      }
      _this._resource = gltf;
    });
  };
  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig, oasis) {
    var _this2 = this;
    return new Promise(function(resolve) {
      _this2.load(resourceManager, assetConfig, oasis).then(function() {
        var gltf = _this2.resource;
        var _gltf$materials = gltf.materials, materials = _gltf$materials === void 0 ? [] : _gltf$materials, _gltf$_animationsIndi = gltf._animationsIndices, _animationsIndices = _gltf$_animationsIndi === void 0 ? [] : _gltf$_animationsIndi;
        var materialLoadPromises = [];
        var animatorControllerLoadPromise;
        var result = {
          resources: [_this2],
          structure: {
            index: 0,
            props: {
              newMaterial: [],
              animatorControllers: []
            }
          }
        };
        if (materials !== null && materials !== void 0 && materials.length) {
          for (var i = 0; i < materials.length; i++) {
            var material = materials[i];
            var materialResource = null;
            var type = "";
            if (material instanceof PBRMaterial) {
              materialResource = new PBRMaterialResource(_this2.resourceManager);
              type = "PBRMaterial";
            } else if (material instanceof UnlitMaterial) {
              materialResource = new UnlitMaterialResource(_this2.resourceManager);
              type = "UnlitMaterial";
            } else if (material instanceof PBRSpecularMaterial) {
              materialResource = new PBRSpecularMaterialResource(_this2.resourceManager);
              type = "PBRSpecularMaterial";
            } else {
              materialResource = new BlinnPhongMaterialResource(_this2.resourceManager);
              type = "BlinnPhongMaterial";
            }
            _this2._attachedResources.push(materialResource);
            materialLoadPromises.push(materialResource.loadWithAttachedResources(resourceManager, {
              type,
              name: material.name,
              resource: material
            }));
          }
        }
        if (_animationsIndices.length) {
          var animatorControllerResource = new AnimatorControllerResource(_this2.resourceManager);
          _this2._attachedResources.push(animatorControllerResource);
          animatorControllerLoadPromise = animatorControllerResource.loadWithAttachedResources(resourceManager, {
            type: "animatorController",
            name: "AnimatorController",
            props: {
              animationsIndices: _animationsIndices,
              gltf: _this2._resource
            }
          });
        }
        var loadAttachedMaterial = Promise.all(materialLoadPromises).then(function(res) {
          var newMaterial = result.structure.props.newMaterial;
          res.forEach(function(mat) {
            var matStructure = mat.structure;
            var matResource = mat.resources[matStructure.index];
            result.resources.push(matResource);
            matStructure.index = result.resources.length - 1;
            for (var key in matStructure.props) {
              if (matStructure.props.hasOwnProperty(key)) {
                var textureStructure = matStructure.props[key];
                var textureResource = mat.resources[textureStructure.index];
                result.resources.push(textureResource);
                textureStructure.index = result.resources.length - 1;
              }
            }
            newMaterial.push(matStructure);
          });
        });
        var loadAttachedController = animatorControllerLoadPromise ? animatorControllerLoadPromise.then(function(res) {
          var animatorControllers = result.structure.props.animatorControllers;
          var controllerStructure = res.structure;
          var controllerResource = res.resources[controllerStructure.index];
          result.resources.push(controllerResource);
          controllerStructure.index = result.resources.length - 1;
          var animationClips = controllerStructure.props.animationClips;
          if (animationClips) {
            for (var _i = 0, length2 = animationClips.length; _i < length2; ++_i) {
              var clipStructure = animationClips[_i];
              var clipResource = res.resources[clipStructure.index];
              result.resources.push(clipResource);
              clipStructure.index = result.resources.length - 1;
            }
          }
          animatorControllers.push(controllerStructure);
        }) : Promise.resolve();
        Promise.all([loadAttachedMaterial, loadAttachedController]).then(function() {
          resolve(result);
        });
      });
    });
  };
  _proto.setMeta = function setMeta(assetConfig) {
    if (assetConfig) {
      this.meta.name = assetConfig.name;
    }
  };
  _proto.bind = function bind() {
    var resource = this._resource;
    this.bindMaterials(resource.newMaterial);
    this.bindAnimatorControllers(resource.animatorControllers);
  };
  _proto.update = function update(key, value) {
    if (key === "newMaterial") {
      this.bindMaterials(value);
    } else {
      this._resource[key] = value;
    }
  };
  _proto.bindMaterials = function bindMaterials(newMaterialsConfig) {
    var newMaterialCount = newMaterialsConfig.length;
    if (!newMaterialsConfig || !newMaterialsConfig.length) {
      return;
    }
    var gltf = this._resource;
    var newMaterials = new Array(newMaterialCount);
    gltf.newMaterial = newMaterials;
    for (var i = 0; i < newMaterialsConfig.length; i++) {
      var mtlResource = this.resourceManager.get(newMaterialsConfig[i].id);
      if (mtlResource) {
        this._attachedResources.push(mtlResource);
        newMaterials[i] = mtlResource.resource;
      } else {
        Logger.warn("GLTFResource: " + this.meta.name + ` can't find asset "material", which id is: ` + newMaterialsConfig[i].id);
      }
    }
    var gltfRoot = gltf.defaultSceneRoot;
    var originMaterials = gltf.materials;
    var meshRenderers = gltfRoot.getComponentsIncludeChildren(MeshRenderer, []);
    for (var _i2 = 0; _i2 < newMaterialCount; _i2++) {
      var newMaterial = newMaterials[_i2];
      var originMaterial = originMaterials[_i2];
      for (var j = 0; j < meshRenderers.length; j++) {
        var meshRenderer = meshRenderers[j];
        var meshMaterials = meshRenderer.getMaterials();
        for (var k = 0; k < meshMaterials.length; k++) {
          if (originMaterial === meshMaterials[k]) {
            meshRenderer.setMaterial(k, newMaterial);
          }
        }
      }
    }
  };
  _proto.bindAnimatorControllers = function bindAnimatorControllers(animatorControllers) {
    for (var i = 0, length2 = animatorControllers.length; i < length2; i++) {
      var animatorControllerAsset = animatorControllers[i];
      var controllerResource = this.resourceManager.get(animatorControllerAsset.id);
      controllerResource.gltf = this._resource;
      if (controllerResource) {
        this._attachedResources.push(controllerResource);
      } else {
        "GLTFResource: " + this.meta.name + ` can't find asset "animatorController", which id is: ` + animatorControllerAsset.id;
      }
    }
  };
  return GLTFResource2;
}(SchemaResource);
var scriptAbility = {};
function script(name) {
  return function(target) {
    scriptAbility[name] = target;
  };
}
var ScriptResource = function(_SchemaResource) {
  _inheritsLoose3(ScriptResource2, _SchemaResource);
  function ScriptResource2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.isInit = false;
    return _this;
  }
  var _proto = ScriptResource2.prototype;
  _proto.initScriptContext = function initScriptContext() {
    if (this.isInit) {
      return;
    }
    this.isInit = true;
    window.__o3_script_context__ = {
      o3: Parser._components["o3"],
      script: function script2(name) {
        return function(target) {
          scriptAbility[name] = target;
        };
      }
    };
  };
  _proto.load = function load(resourceLoader2, assetConfig, oasis) {
    var _this2 = this;
    this.initScriptContext();
    return new Promise(function(resolve) {
      var config = assetConfig;
      var scripts = config.props.scripts;
      if (!_this2.resourceManager.isLocal) {
        var scriptDom = document.createElement("script");
        scriptDom.crossOrigin = "anonymous";
        _this2.setMeta(assetConfig);
        scriptDom.onload = function() {
          var o3Scripts = window.o3Scripts;
          for (var i2 = 0; i2 < scripts.length; i2++) {
            var name2 = scripts[i2].name;
            _this2._resource = o3Scripts && o3Scripts[name2];
            scriptAbility[name2] = _this2._resource;
          }
          resolve(_this2);
        };
        scriptDom.src = assetConfig.url;
        document.body.appendChild(scriptDom);
      } else {
        for (var i = 0; i < scripts.length; i++) {
          var _oasis$options;
          var name = scripts[i].name;
          scriptAbility[name] = (_oasis$options = oasis.options) === null || _oasis$options === void 0 ? void 0 : _oasis$options.scripts[name];
        }
        resolve(_this2);
      }
    });
  };
  _proto.setMeta = function setMeta(assetConfig) {
    if (assetConfig) {
      this._meta.name = assetConfig.name;
      this._meta.url = assetConfig.url;
      this._meta.source = assetConfig.source;
    }
  };
  return ScriptResource2;
}(SchemaResource);
var SpriteResource = function(_SchemaResource) {
  _inheritsLoose3(SpriteResource2, _SchemaResource);
  function SpriteResource2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.configProps = void 0;
    return _this;
  }
  var _proto = SpriteResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig) {
    var _this2 = this;
    return new Promise(function(resolve) {
      var assetObj = new Sprite(resourceManager.engine);
      _this2.configProps = assetConfig.props;
      var configProps = _this2.configProps;
      var pivotType = configProps.pivotType, pivot = configProps.pivot;
      if (typeof pivot !== "undefined" && typeof pivotType !== "undefined" && pivotType !== SpritePivotType.Custom) {
        switch (pivotType) {
          case SpritePivotType.Center:
            pivot.x = 0.5;
            pivot.y = 0.5;
            break;
          case SpritePivotType.TopLeft:
            pivot.x = 0;
            pivot.y = 1;
            break;
          case SpritePivotType.Top:
            pivot.x = 0.5;
            pivot.y = 1;
            break;
          case SpritePivotType.TopRight:
            pivot.x = 1;
            pivot.y = 1;
            break;
          case SpritePivotType.Left:
            pivot.x = 0;
            pivot.y = 0.5;
            break;
          case SpritePivotType.Right:
            pivot.x = 1;
            pivot.y = 0.5;
            break;
          case SpritePivotType.BottomLeft:
            pivot.x = 0;
            pivot.y = 0;
            break;
          case SpritePivotType.Bottom:
            pivot.x = 0.5;
            pivot.y = 0;
            break;
          case SpritePivotType.BottomRight:
            pivot.x = 1;
            pivot.y = 0;
            break;
        }
      }
      for (var k in configProps) {
        if (!isAsset(configProps[k]) && typeof configProps[k] !== "undefined") {
          assetObj[k] = configProps[k];
        }
      }
      _this2._resource = assetObj;
      _this2.setMeta();
      resolve(_this2);
    });
  };
  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this3 = this;
    return new Promise(function(resolve, reject) {
      var loadPromise;
      if (assetConfig.resource instanceof SpriteResource2) {
        loadPromise = new Promise(function(resolve2) {
          _this3._resource = assetConfig.resource;
          _this3.setMeta();
          resolve2(_this3);
        });
      } else if (assetConfig.props) {
        loadPromise = _this3.load(resourceManager, assetConfig);
      } else {
        reject("Load Sprite Error");
      }
      if (loadPromise) {
        loadPromise.then(function() {
          var result = {
            resources: [_this3],
            structure: {
              index: 0,
              props: {}
            }
          };
          var sprite = _this3._resource;
          getAllGetters(_this3._resource).forEach(function(attr) {
            if (!(sprite[attr] instanceof Texture))
              return;
            var textureResource = new TextureResource(_this3.resourceManager, sprite[attr]);
            _this3.attachedResources.push(textureResource);
            result.resources.push(textureResource);
            result.structure.props[attr] = {
              index: result.resources.length - 1
            };
          });
          resolve(result);
        });
      }
    });
  };
  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };
  _proto.getProps = function getProps() {
    var _this4 = this;
    var result = {};
    var props = getAllGetters(this.resource);
    props.forEach(function(prop) {
      return result[prop] = _this4.resource[prop];
    });
    return result;
  };
  _proto.bind = function bind() {
    var _this5 = this;
    var resource = this._resource;
    this.configProps && Object.keys(this.configProps).forEach(function(attr) {
      var value = _this5.configProps[attr];
      if (isAsset(value)) {
        var textureResource = _this5.resourceManager.get(value.id);
        if (textureResource && textureResource instanceof TextureResource) {
          resource[attr] = textureResource.resource;
          _this5._attachedResources.push(textureResource);
        } else {
          resource[attr] = null;
          Logger.warn("SpriteResource: " + _this5.meta.name + ` can't find asset "` + attr + '", which id is: ' + value.id);
        }
      } else {
        resource[attr] = value;
      }
    });
  };
  return SpriteResource2;
}(SchemaResource);
var SpritePivotType;
(function(SpritePivotType2) {
  SpritePivotType2[SpritePivotType2["Center"] = 0] = "Center";
  SpritePivotType2[SpritePivotType2["TopLeft"] = 1] = "TopLeft";
  SpritePivotType2[SpritePivotType2["Top"] = 2] = "Top";
  SpritePivotType2[SpritePivotType2["TopRight"] = 3] = "TopRight";
  SpritePivotType2[SpritePivotType2["Left"] = 4] = "Left";
  SpritePivotType2[SpritePivotType2["Right"] = 5] = "Right";
  SpritePivotType2[SpritePivotType2["BottomLeft"] = 6] = "BottomLeft";
  SpritePivotType2[SpritePivotType2["Bottom"] = 7] = "Bottom";
  SpritePivotType2[SpritePivotType2["BottomRight"] = 8] = "BottomRight";
  SpritePivotType2[SpritePivotType2["Custom"] = 9] = "Custom";
})(SpritePivotType || (SpritePivotType = {}));
var imageOrderMap = {
  px: 0,
  nx: 1,
  py: 2,
  ny: 3,
  pz: 4,
  nz: 5
};
var TextureCubeMapResource = function(_SchemaResource) {
  _inheritsLoose3(TextureCubeMapResource2, _SchemaResource);
  function TextureCubeMapResource2() {
    return _SchemaResource.apply(this, arguments) || this;
  }
  var _proto = TextureCubeMapResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig, oasis) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      var _assetConfig$props, _assetConfig$props$co;
      var imageUrls = [];
      var type = AssetType.TextureCube;
      if (_this.resourceManager.useCompressedTexture && assetConfig !== null && assetConfig !== void 0 && (_assetConfig$props = assetConfig.props) !== null && _assetConfig$props !== void 0 && (_assetConfig$props$co = _assetConfig$props.compression) !== null && _assetConfig$props$co !== void 0 && _assetConfig$props$co.compressions.length) {
        var rhi = oasis.engine._hardwareRenderer;
        var compressions = assetConfig.props.compression.compressions;
        for (var i = 0; i < compressions.length; i++) {
          var compression = compressions[i];
          if (compression.container === "ktx" && rhi.canIUse(GLCapabilityType[compression.type])) {
            for (var key in compression.files) {
              if (compression.files.hasOwnProperty(key)) {
                var image = compression.files[key];
                imageUrls[imageOrderMap[key]] = image.url;
              }
            }
            console.warn(compression.type);
            type = AssetType.KTXCube;
            break;
          }
        }
      }
      if (type === AssetType.TextureCube) {
        for (var _key in assetConfig.props.images) {
          if (assetConfig.props.images.hasOwnProperty(_key)) {
            var _image = assetConfig.props.images[_key];
            imageUrls[imageOrderMap[_key]] = _image.url;
          }
        }
      }
      resourceManager.load({
        urls: imageUrls,
        type
      }).then(function(res) {
        _this._resource = res;
        resolve(_this);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };
  return TextureCubeMapResource2;
}(SchemaResource);
var BaseResource = function(_SchemaResource) {
  _inheritsLoose3(BaseResource2, _SchemaResource);
  function BaseResource2() {
    return _SchemaResource.apply(this, arguments) || this;
  }
  var _proto = BaseResource2.prototype;
  _proto.load = function load(resourceLoader2, assetConfig) {
    var _this = this;
    return new Promise(function(resolve) {
      _this._resource = assetConfig;
      _this.setMetaData("name", _this.resource.name);
      _this.setMetaData("url", _this.resource.url);
      resolve(_this);
    });
  };
  _proto.setMetaData = function setMetaData(key, value) {
    this._meta[key] = value;
  };
  return BaseResource2;
}(SchemaResource);
var _dec$4;
var _dec2$2;
var _dec3$1;
var _class$42;
var AbilityManager = (_dec$4 = pluginHook({
  after: "abilityAdded",
  before: "beforeAbilityAdded"
}), _dec2$2 = pluginHook({
  before: "beforeAbilityUpdated",
  after: "abilityUpdated"
}), _dec3$1 = pluginHook({
  after: "abilityDeleted",
  before: "beforeAbilityDeleted"
}), _class$42 = function() {
  function AbilityManager2(oasis) {
    this.oasis = oasis;
    this.abilityMap = {};
  }
  var _proto = AbilityManager2.prototype;
  _proto.add = function add(abilityConfig) {
    var type = abilityConfig.type, nodeId = abilityConfig.node, props = abilityConfig.props, id = abilityConfig.id, index = abilityConfig.index;
    var node = this.oasis.nodeManager.get(nodeId);
    var AbilityConstructor = this.getCompConstructor(type);
    if (!AbilityConstructor) {
      Logger.error(type + " abiltiy is not defined");
      return;
    }
    var abilityProps = this.mixPropsToExplicitProps(props);
    var ability = node.addComponent(AbilityConstructor);
    var enabled = abilityProps.enabled;
    if (enabled !== void 0) {
      ability.enabled = enabled;
    }
    if (type === "GLTFModel") {
      ability.init(abilityProps);
    } else if (type === "Model") {
      ability.setProps(abilityProps);
      if (abilityProps.material) {
        ability.material = abilityProps.material;
      }
    } else {
      for (var k in abilityProps) {
        if (abilityProps[k] !== null) {
          ability[k] = abilityProps[k];
        }
      }
    }
    var abilityArray = node._components;
    var currentIndex = abilityArray.length - 1;
    switchElementsIndex(abilityArray, currentIndex, index);
    ability.id = id;
    this.abilityMap[id] = ability;
    return ability;
  };
  _proto.update = function update(id, key, value) {
    if (value && this.checkIsAsset(value)) {
      this.get(id)[key] = this.oasis.resourceManager.get(value.id).resource;
    } else {
      if (this.get(id).constructor === Model) {
        this.get(id).updateProp(key, value);
      } else {
        this.get(id)[key] = value;
      }
    }
    return {
      id,
      key,
      value
    };
  };
  _proto.addRuntimeComponent = function addRuntimeComponent(componentId, component) {
    component.id = componentId;
    this.abilityMap[componentId] = component;
    return component;
  };
  _proto.get = function get4(id) {
    return this.abilityMap[id];
  };
  _proto.delete = function _delete(id) {
    var ability = this.abilityMap[id];
    ability.destroy();
    delete this.abilityMap[id];
    return id;
  };
  _proto.getCompConstructor = function getCompConstructor(type) {
    var splits = type.split(".");
    if (splits[0] === "script") {
      return scriptAbility[splits[1]];
    }
    var constructor = Parser._components["o3"][type];
    if (!constructor) {
      console.warn(type + " is not defined");
    }
    return constructor;
  };
  _proto.mixPropsToExplicitProps = function mixPropsToExplicitProps(props) {
    var explicitProps = _objectSpread23({}, props);
    for (var k in props) {
      var prop = props[k];
      if (prop && this.checkIsAsset(prop)) {
        var res = this.oasis.resourceManager.get(prop.id);
        if (res) {
          explicitProps[k] = res.resource;
        } else {
          explicitProps[k] = null;
          Logger.warn(`AbilityManager: can't get asset "` + k + '", which id is ' + prop.id);
        }
      }
    }
    return explicitProps;
  };
  _proto.checkIsAsset = function checkIsAsset(prop) {
    return prop.type === "asset";
  };
  return AbilityManager2;
}(), _applyDecoratedDescriptor2(_class$42.prototype, "add", [_dec$4], Object.getOwnPropertyDescriptor(_class$42.prototype, "add"), _class$42.prototype), _applyDecoratedDescriptor2(_class$42.prototype, "update", [_dec2$2], Object.getOwnPropertyDescriptor(_class$42.prototype, "update"), _class$42.prototype), _applyDecoratedDescriptor2(_class$42.prototype, "delete", [_dec3$1], Object.getOwnPropertyDescriptor(_class$42.prototype, "delete"), _class$42.prototype), _class$42);
var _dec$3;
var _dec2$1;
var _dec3;
var _class$32;
var NodeManager = (_dec$3 = pluginHook({
  after: "nodeAdded"
}), _dec2$1 = pluginHook({
  before: "beforeNodeUpdated",
  after: "nodeUpdated"
}), _dec3 = pluginHook({
  before: "beforeNodeDeleted"
}), _class$32 = function() {
  function NodeManager2(oasis) {
    this.oasis = oasis;
    this.nodeMap = {};
    this.root = void 0;
    this.root = new Entity(this.oasis.engine, "root");
  }
  var _proto = NodeManager2.prototype;
  _proto.addRootEntity = function addRootEntity() {
    this.oasis.engine.sceneManager.activeScene.addRootEntity(this.root);
  };
  _proto.add = function add(nodeConfig) {
    this.create(nodeConfig);
    this.append(nodeConfig.id, nodeConfig.parent, nodeConfig.index);
    return this.get(nodeConfig.id);
  };
  _proto.update = function update(id, key, value) {
    this.get(id)[key] = value;
    return {
      id,
      key,
      value
    };
  };
  _proto.get = function get4(id) {
    return this.nodeMap[id];
  };
  _proto.reset = function reset() {
    this.nodeMap = {};
  };
  _proto.delete = function _delete(id) {
    this.nodeMap[id].destroy();
    delete this.nodeMap[id];
  };
  _proto.create = function create(nodeConfig) {
    var isActive = nodeConfig.isActive, position = nodeConfig.position, rotation = nodeConfig.rotation, scale = nodeConfig.scale, id = nodeConfig.id, name = nodeConfig.name;
    var entity = new Entity(this.oasis.engine, name);
    entity.isActive = isActive;
    entity.transform.position = new Vector3(position[0], position[1], position[2]);
    entity.transform.rotation = new Vector3(rotation[0], rotation[1], rotation[2]);
    entity.transform.scale = new Vector3(scale[0], scale[1], scale[2]);
    entity.id = id;
    this.nodeMap[id] = entity;
    return entity;
  };
  _proto.append = function append(childId, parentId, index) {
    var child = this.nodeMap[childId];
    var parent = this.nodeMap[parentId] || this.root;
    parent.addChild(child);
    var children = parent._children;
    var currentIndex = children.length - 1;
    switchElementsIndex(children, currentIndex, index);
  };
  return NodeManager2;
}(), _applyDecoratedDescriptor2(_class$32.prototype, "add", [_dec$3], Object.getOwnPropertyDescriptor(_class$32.prototype, "add"), _class$32.prototype), _applyDecoratedDescriptor2(_class$32.prototype, "update", [_dec2$1], Object.getOwnPropertyDescriptor(_class$32.prototype, "update"), _class$32.prototype), _applyDecoratedDescriptor2(_class$32.prototype, "delete", [_dec3], Object.getOwnPropertyDescriptor(_class$32.prototype, "delete"), _class$32.prototype), _class$32);
var _dec$2;
var _class$22;
var SceneManager2 = (_dec$2 = pluginHook({
  before: "beforeSceneUpdated",
  after: "sceneUpdated"
}), _class$22 = function() {
  function SceneManager3(oasis) {
    this.oasis = oasis;
  }
  var _proto = SceneManager3.prototype;
  _proto.init = function init() {
    var _this = this;
    var scene = this.oasis.options.config.scene;
    if (scene) {
      Object.keys(scene).forEach(function(field) {
        var fieldConfig = scene[field];
        Object.keys(fieldConfig.props).forEach(function(key) {
          var prop = fieldConfig.props[key];
          _this.setProp(field, key, prop);
        });
      });
    }
  };
  _proto.update = function update(field, key, value) {
    this.setProp(field, key, value);
    return {
      field,
      key,
      value
    };
  };
  _proto.setProp = function setProp(field, key, prop) {
    var scene = this.oasis.engine.sceneManager.activeScene;
    if (field === "background" && key === "skyboxTexture") {
      var sky = scene.background.sky;
      if (prop) {
        sky.mesh = PrimitiveMesh.createCuboid(scene.engine, 2, 2, 2);
        var skyMaterial = new SkyBoxMaterial(scene.engine);
        skyMaterial.textureCubeMap = this.oasis.resourceManager.get(prop.id).resource;
        sky.material = skyMaterial;
      } else {
        sky.mesh = null;
        sky.material = null;
      }
    } else if (scene[field]) {
      if (prop && prop.type === "asset") {
        scene[field][key] = this.oasis.resourceManager.get(prop.id).resource;
      } else {
        scene[field][key] = prop;
      }
    }
  };
  return SceneManager3;
}(), _applyDecoratedDescriptor2(_class$22.prototype, "update", [_dec$2], Object.getOwnPropertyDescriptor(_class$22.prototype, "update"), _class$22.prototype), _class$22);
var SpriteAtlasResource = function(_SchemaResource) {
  _inheritsLoose3(SpriteAtlasResource2, _SchemaResource);
  function SpriteAtlasResource2() {
    return _SchemaResource.apply(this, arguments) || this;
  }
  var _proto = SpriteAtlasResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig) {
    var _this = this;
    return new Promise(function(resolve) {
      _this.setMeta();
      if (assetConfig.source) {
        resourceManager.load({
          url: assetConfig.source,
          type: AssetType.SpriteAtlas
        }).then(function(spriteAtlas) {
          _this._resource = spriteAtlas;
          var sprites = spriteAtlas.sprites;
          var schemaResourceManager = _this.resourceManager;
          for (var index = sprites.length - 1; index >= 0; index--) {
            var sprite = sprites[index];
            var spriteResource = new SpriteResource(schemaResourceManager, sprite);
            var assetID = sprite._assetID;
            schemaResourceManager.maxId = Math.max(assetID, schemaResourceManager.maxId);
            schemaResourceManager.resourceMap[assetID] = spriteResource;
            schemaResourceManager.resourceIdMap.set(spriteResource, "" + assetID);
          }
          resolve(_this);
        });
      } else {
        if (!SpriteAtlasResource2.defaultAtlas) {
          SpriteAtlasResource2.defaultAtlas = new SpriteAtlas(resourceManager.engine);
        }
        _this._resource = SpriteAtlasResource2.defaultAtlas;
        resolve(_this);
      }
    });
  };
  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };
  _proto.getProps = function getProps() {
    var _this2 = this;
    var result = {};
    var props = getAllGetters(this.resource);
    props.forEach(function(prop) {
      return result[prop] = _this2.resource[prop];
    });
    return result;
  };
  _proto.update = function update() {
  };
  return SpriteAtlasResource2;
}(SchemaResource);
SpriteAtlasResource.defaultAtlas = void 0;
var _dec$1;
var _dec2;
var _class$12;
var RESOURCE_CLASS = {
  script: ScriptResource,
  gltf: GLTFResource,
  texture: TextureResource,
  cubeTexture: TextureCubeMapResource,
  PBRMaterial: PBRMaterialResource,
  PBRSpecularMaterial: PBRSpecularMaterialResource,
  UnlitMaterial: UnlitMaterialResource,
  BlinnPhongMaterial: BlinnPhongMaterialResource,
  base: BaseResource,
  sprite: SpriteResource,
  SpriteAtlas: SpriteAtlasResource,
  animatorController: AnimatorControllerResource,
  animationClip: AnimationClipResource
};
var RESOURCE_TYPE = new Map();
for (key in RESOURCE_CLASS) {
  if (RESOURCE_CLASS.hasOwnProperty(key)) {
    element = RESOURCE_CLASS[key];
    RESOURCE_TYPE.set(element, key);
  }
}
var element;
var key;
var resourceFactory = {
  createResource: function createResource(resourceManager, type) {
    return new RESOURCE_CLASS[type](resourceManager);
  }
};
function registerResource(type, resource) {
  if (!RESOURCE_CLASS.hasOwnProperty(type)) {
    RESOURCE_CLASS[type] = resource;
    RESOURCE_TYPE.set(resource, type);
  }
}
var SchemaResourceManager = (_dec$1 = pluginHook({
  before: "beforeResourceRemove"
}), _dec2 = pluginHook({
  after: "resourceUpdated",
  before: "beforeResourceUpdate"
}), _class$12 = function() {
  function SchemaResourceManager2(oasis) {
    this.oasis = oasis;
    this.resourceMap = {};
    this.resourceIdMap = new WeakMap();
    this.maxId = 0;
    this.engineResourceManager = void 0;
    this.engineResourceManager = this.oasis.engine.resourceManager;
  }
  var _proto = SchemaResourceManager2.prototype;
  _proto.load = function load(asset) {
    var _this = this;
    var resource = resourceFactory.createResource(this, asset.type);
    var loadPromise = resource.load(this.oasis.engine.resourceManager, asset, this.oasis);
    this.maxId = Math.max(+asset.id, this.maxId);
    loadPromise.then(function() {
      _this.resourceMap[asset.id] = resource;
      _this.resourceIdMap.set(resource, asset.id);
    });
    return loadPromise;
  };
  _proto.add = function add(asset) {
    var _this2 = this;
    var resource = resourceFactory.createResource(this, asset.type);
    return new Promise(function(resolve) {
      resource.loadWithAttachedResources(_this2.oasis.engine.resourceManager, asset, _this2.oasis).then(function(result) {
        resolve(_this2.getAddResourceResult(result.resources, result.structure));
      });
    });
  };
  _proto.remove = function remove(id) {
    var _this3 = this;
    return new Promise(function(resolve) {
      var resource = _this3.resourceMap[id];
      var result = [id];
      var hasAttachedResource = false;
      delete _this3.resourceMap[id];
      if (resource) {
        var attached = resource.attachedResources;
        for (var index = 0; index < attached.length; index++) {
          var attachedResource = attached[index];
          var attachedResourceId = _this3.resourceIdMap.get(attachedResource);
          if (attachedResourceId) {
            hasAttachedResource = true;
            _this3.remove(attachedResourceId).then(function(attachedResourceRemoveResult) {
              result.push.apply(result, attachedResourceRemoveResult);
              resolve(result);
            });
          }
        }
      }
      if (!hasAttachedResource) {
        resolve(result);
      }
    });
  };
  _proto.update = function update(id, key, value) {
    var resource = this.get(id);
    if (resource) {
      resource.update(key, value);
    }
    return {
      resource,
      id,
      key,
      value
    };
  };
  _proto.updateMeta = function updateMeta(id, key, value) {
    var resource = this.get(id);
    if (resource) {
      resource.updateMeta(key, value);
    }
  };
  _proto.get = function get4(id) {
    return this.resourceMap[id];
  };
  _proto.getAll = function getAll() {
    return ObjectValues(this.resourceMap);
  };
  _proto.getAddResourceResult = function getAddResourceResult(resources, structure) {
    var _this4 = this;
    var addResourceResult = {};
    var resource = resources[structure.index];
    var id = "" + ++this.maxId;
    this.resourceMap[id] = resource;
    this.resourceIdMap.set(resource, id);
    addResourceResult.id = this.maxId;
    addResourceResult.type = RESOURCE_TYPE.get(resource.constructor);
    addResourceResult.meta = resource.meta;
    addResourceResult.props = {};
    for (var _key in structure.props) {
      if (structure.props.hasOwnProperty(_key)) {
        var _element = structure.props[_key];
        if (_element) {
          if (Array.isArray(_element)) {
            addResourceResult.props[_key] = _element.map(function(child) {
              return _this4.getAddResourceResult(resources, child);
            });
          } else {
            addResourceResult.props[_key] = this.getAddResourceResult(resources, _element);
          }
        }
      }
    }
    return addResourceResult;
  };
  _createClass4(SchemaResourceManager2, [{
    key: "isLocal",
    get: function get4() {
      return this.oasis.options.local;
    }
  }, {
    key: "useCompressedTexture",
    get: function get4() {
      var _this$oasis$options$u;
      return (_this$oasis$options$u = this.oasis.options.useCompressedTexture) != null ? _this$oasis$options$u : true;
    }
  }]);
  return SchemaResourceManager2;
}(), _applyDecoratedDescriptor2(_class$12.prototype, "remove", [_dec$1], Object.getOwnPropertyDescriptor(_class$12.prototype, "remove"), _class$12.prototype), _applyDecoratedDescriptor2(_class$12.prototype, "update", [_dec2], Object.getOwnPropertyDescriptor(_class$12.prototype, "update"), _class$12.prototype), _class$12);
var _dec4;
var _class4;
var Oasis = (_dec4 = pluginHook({
  after: "schemaParsed"
}), _class4 = function(_EventDispatcher) {
  _inheritsLoose3(Oasis2, _EventDispatcher);
  function Oasis2(_options, pluginManager) {
    var _options$scripts;
    var _this;
    _this = _EventDispatcher.call(this, _options.engine) || this;
    _this._options = _options;
    _this.pluginManager = pluginManager;
    _this.nodeManager = void 0;
    _this.abilityManager = void 0;
    _this.sceneManager = void 0;
    _this.resourceManager = void 0;
    _this._canvas = void 0;
    _this.schema = void 0;
    _this.timeout = void 0;
    _this.oasis = _assertThisInitialized2(_this);
    _this.schema = _options.config;
    _this.timeout = _options.timeout;
    _options.scripts = (_options$scripts = _options.scripts) != null ? _options$scripts : {};
    _this.nodeManager = new NodeManager(_assertThisInitialized2(_this));
    _this.abilityManager = new AbilityManager(_assertThisInitialized2(_this));
    _this.nodeManager.add = _this.nodeManager.add.bind(_this.nodeManager);
    _this.abilityManager.add = _this.abilityManager.add.bind(_this.abilityManager);
    _this.resourceManager = new SchemaResourceManager(_assertThisInitialized2(_this));
    _this.sceneManager = new SceneManager2(_assertThisInitialized2(_this));
    if (_options.fps) {
      _this.engine.targetFrameRate = _options.fps;
      _this.engine.vSyncCount = 0;
    }
    return _this;
  }
  var _proto = Oasis2.prototype;
  _proto.updateConfig = function updateConfig(config) {
    this.schema = config;
    this.init();
  };
  _proto.init = function init() {
    var _this2 = this;
    return this.loadResources().then(function() {
      _this2.bindResources();
      _this2.parseEntities();
      _this2.attach();
      _this2.nodeManager.addRootEntity();
      _this2.sceneManager.init();
      _this2.parseNodeAbilities();
      _this2.pluginManager.boot(_this2);
    });
  };
  _proto.loadResources = function loadResources() {
    var _this3 = this;
    var _this$schema$assets = this.schema.assets, assets = _this$schema$assets === void 0 ? {} : _this$schema$assets;
    var loadingPromises = ObjectValues(assets).filter(function(asset) {
      if (RESOURCE_CLASS[asset.type]) {
        return true;
      }
      console.warn(asset.type + " loader is not defined. the " + asset.type + " type will be ignored.");
      return false;
    }).map(function(asset) {
      return _this3.resourceManager.load(asset);
    });
    return Promise.all(loadingPromises);
  };
  _proto.bindResources = function bindResources() {
    this.resourceManager.getAll().forEach(function(resource) {
      resource.bind();
    });
  };
  _proto.parseEntities = function parseEntities() {
    var nodes = this.schema.nodes;
    var indices = this.bfsNodes();
    indices.map(function(index) {
      return nodes[index];
    }).forEach(this.nodeManager.add);
  };
  _proto.parseNodeAbilities = function parseNodeAbilities() {
    var abilities = this.schema.abilities;
    Object.keys(abilities).map(function(id) {
      return _objectSpread23({
        id
      }, abilities[id]);
    }).forEach(this.abilityManager.add);
  };
  _proto.bfsNodes = function bfsNodes() {
    var nodes = this.schema.nodes;
    var roots = ObjectValues(nodes).filter(function(node) {
      return !nodes[node.parent];
    }).map(function(node) {
      return node.id;
    });
    var result = [];
    var traverseChildren = function traverseChildren2(roots2) {
      result = result.concat(roots2);
      roots2.forEach(function(id) {
        var children = nodes[id].children;
        children && traverseChildren2(children);
      });
    };
    traverseChildren(roots);
    return result;
  };
  _proto.attach = function attach() {
    this.resourceManager.getAll().forEach(function(resource) {
      resource.attach();
    });
  };
  Oasis2.create = function create(options, pluginManager) {
    var oasis = new Oasis2(options, pluginManager);
    return oasis.init().then(function() {
      options.autoPlay && oasis.engine.run();
      return oasis;
    });
  };
  _createClass4(Oasis2, [{
    key: "canvas",
    get: function get4() {
      return this._options.canvas;
    }
  }, {
    key: "options",
    get: function get4() {
      return this._options;
    }
  }]);
  return Oasis2;
}(EventDispatcher), _applyDecoratedDescriptor2(_class4.prototype, "init", [_dec4], Object.getOwnPropertyDescriptor(_class4.prototype, "init"), _class4.prototype), _class4);

// node_modules/oasis-engine/dist/module.js
Parser.registerComponents("o3", {
  GLTFModel,
  SpriteRenderer,
  SpriteMask,
  PointLight,
  AmbientLight,
  DirectLight,
  ParticleRenderer,
  BoxCollider,
  Camera,
  Model,
  Component,
  SphereCollider,
  Animator
});
var version = "0.5.7";
console.log("oasis engine version: " + version);

export {
  ContainmentType,
  PlaneIntersectionType,
  MathUtil,
  Vector3,
  BoundingSphere,
  BoundingBox,
  CollisionUtil,
  Plane,
  BoundingFrustum,
  Matrix3x3,
  Quaternion,
  Matrix,
  Ray,
  Vector2,
  Vector4,
  Color,
  Rect,
  SphericalHarmonics3,
  AssetPromiseStatus,
  AssetPromise,
  Util,
  ObjectValues,
  ResourceManager,
  resourceLoader,
  Event,
  ignoreClone,
  assignmentClone,
  shallowClone,
  deepClone,
  CloneManager,
  EngineObject,
  EventDispatcher,
  Logger,
  Time,
  DataType,
  GLCapabilityType,
  dependencies,
  Layer,
  Component,
  UpdateFlag,
  Transform,
  Entity,
  RenderQueueType,
  RefObject,
  Texture,
  ShaderFactory,
  Shader,
  ShaderData,
  BlendFactor,
  BlendOperation,
  ColorWriteMask,
  CompareFunction,
  CullMode,
  StencilOperation,
  Material,
  RenderElement,
  SpriteElement,
  SpriteMaskInteraction,
  Renderer,
  SpriteMaskLayer,
  SpriteMask,
  VertexElementFormat,
  BufferUsage,
  IndexFormat,
  BufferUtil,
  VertexElement,
  BufferBindFlag,
  SetDataOptions,
  Buffer,
  MeshTopology,
  IndexBufferBinding,
  SubMesh,
  Mesh,
  VertexBufferBinding,
  TextureFilterMode,
  TextureFormat,
  TextureWrapMode,
  Texture2D,
  RenderBufferColorFormat,
  RenderBufferDepthFormat,
  TextureCubeFace,
  TextureCubeMap,
  RenderDepthTexture,
  RenderTarget,
  RenderColorTexture,
  ModelMesh,
  Skin,
  MeshRenderer,
  SkinnedMeshRenderer,
  PrimitiveMesh,
  BufferMesh,
  BlendShapeFrame,
  BlendShape,
  BackgroundMode,
  Sky,
  Background,
  DiffuseMode,
  AmbientLight,
  SceneFeature,
  Light,
  DirectLight,
  PointLight,
  SpotLight,
  Scene,
  SceneManager,
  ColliderFeature,
  Collider,
  ABoxCollider,
  PlaneCollider,
  ASphereCollider,
  BoxCollider,
  SphereCollider,
  HitResult,
  PhysicsManager,
  Engine,
  SystemInfo,
  EngineFeature,
  Script,
  CameraClearFlags,
  RenderPass,
  RenderQueue,
  BasicRenderPipeline,
  Camera,
  request,
  Loader,
  AssetType,
  RenderFace,
  BlendMode,
  BaseMaterial,
  BlinnPhongMaterial,
  PBRBaseMaterial,
  PBRMaterial,
  PBRSpecularMaterial,
  UnlitMaterial,
  SpriteAtlas,
  Sprite,
  SpriteRenderer,
  AnimationClipCurveBinding,
  AnimationProperty,
  AnimationClip,
  AnimatorLayerBlendingMode,
  AnimatorStateTransition,
  WrapMode,
  Animator,
  AnimatorController,
  AnimatorControllerLayer,
  AnimatorState,
  AnimatorStateMachine,
  InterpolableValueType,
  InterpolationType,
  AnimationCurve,
  Keyframe,
  InterpolableKeyframe,
  AnimationEvent,
  AnimatorConditionMode,
  SkyBoxMaterial,
  ParticleRendererBlendMode,
  ParticleRenderer,
  TrailMaterial,
  TrailRenderer,
  CollisionDetection,
  Fog,
  EXP2Fog,
  LinearFog,
  Probe,
  CubeProbe,
  GLCompressedTextureInternalFormat,
  WebCanvas,
  WebGLMode,
  WebGLRenderer,
  WebGLEngine,
  GLTFResource$1,
  parseSingleKTX,
  GLTFModel,
  Model,
  Parser,
  parser,
  SchemaResource,
  script,
  SpritePivotType,
  registerResource,
  Oasis,
  version
};
//# sourceMappingURL=chunk-Q6OTXCGN.js.map
