import {
  Collider,
  Component,
  HitResult,
  Ray,
  Vector2
} from "./chunk-Q6OTXCGN.js";
import "./chunk-FIIV5JC7.js";

// node_modules/@oasis-engine/touch/dist/index.module.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
var TouchManager = function() {
  function TouchManager2() {
    var _this = this;
    this.CanvasEvent = {
      touchend: "touchend",
      touchstart: "touchstart",
      mouseup: "mouseup",
      mousedown: "mousedown",
      click: "click"
    };
    this.nowListenHash = void 0;
    this.webCanvas = void 0;
    this.tempVPVec = void 0;
    this.tempCameraVPVec = void 0;
    this.tempRay = void 0;
    this.tempHit = void 0;
    this.listenerState = 0;
    this.engine = void 0;
    this.touchToVPPos = function(touchEvt, pos) {
      var _touchEvt$changedTouc = touchEvt.changedTouches, changedTouches = _touchEvt$changedTouc === void 0 ? [] : _touchEvt$changedTouc, target = touchEvt.target;
      if (changedTouches.length > 0) {
        var _ref = target && target.getBoundingClientRect(), _ref$left = _ref.left, left = _ref$left === void 0 ? 0 : _ref$left, _ref$top = _ref.top, top = _ref$top === void 0 ? 0 : _ref$top;
        var touchPos = changedTouches[0];
        var webCanvas = _this.webCanvas;
        pos.setValue((touchPos.clientX - left) / webCanvas.clientWidth, (touchPos.clientY - top) / webCanvas.clientHeight);
        return true;
      } else {
        return false;
      }
    };
    this.mouseToVPPos = function(mouseEvt, pos) {
      var pageX = mouseEvt.pageX, pageY = mouseEvt.pageY, target = mouseEvt.target;
      if (target) {
        var _target$offsetLeft = target.offsetLeft, offsetLeft = _target$offsetLeft === void 0 ? 0 : _target$offsetLeft, _target$offsetTop = target.offsetTop, offsetTop = _target$offsetTop === void 0 ? 0 : _target$offsetTop;
        var webCanvas = _this.webCanvas;
        pos.setValue((pageX - offsetLeft) / webCanvas.clientWidth, (pageY - offsetTop) / webCanvas.clientHeight);
        return true;
      } else {
        return false;
      }
    };
    this.pointToRay = function(camera, pos) {
      var tempVPVec = _this.tempVPVec, tempRay = _this.tempRay;
      var viewport = camera.viewport;
      pos.setValue((tempVPVec.x - viewport.x) / viewport.z, (tempVPVec.y - viewport.y) / viewport.w);
      if (pos.x >= 0 && pos.x <= 1 && pos.y >= 0 && pos.y <= 1) {
        camera.viewportPointToRay(pos, tempRay);
        return true;
      } else {
        return false;
      }
    };
    this.checkHit = function(touchType, evt) {
      if (!_this.engine) {
        console.warn("Please call the TouchManager.init method to initialize before use");
      }
      var scene = _this.engine.sceneManager.activeScene;
      var actCameras = scene._activeCameras;
      actCameras.sort(function(camera1, camera2) {
        return camera1.priority - camera2.priority;
      });
      var tempCameraVPVec = _this.tempCameraVPVec, tempRay = _this.tempRay;
      for (var index = actCameras.length - 1; index >= 0; index--) {
        var tempCamera = actCameras[index];
        if (tempCamera.enabled && _this.pointToRay(tempCamera, tempCameraVPVec)) {
          var colliderList = _this.nowListenHash[touchType];
          var collider = _this.hitCollider(tempRay, colliderList);
          if (collider) {
            var cbListHash = collider.touchCBListHash;
            var cbList = cbListHash ? cbListHash[touchType] : null;
            var cbLen = cbList ? cbList.length : 0;
            if (cbLen > 0) {
              for (var i = 0; i < cbLen; i++) {
                cbList[i](evt);
              }
            }
          }
          break;
        }
      }
    };
    this.updateListener = function(optType, touchType) {
      var preState = (_this.listenerState & touchType) !== 0;
      if (preState && optType == OptType.Add) {
        return;
      }
      if (!preState && optType == OptType.Del) {
        return;
      }
      var CanvasEvent = _this.CanvasEvent, webCanvas = _this.webCanvas;
      switch (optType) {
        case OptType.Add:
          switch (touchType) {
            case TouchType.MouseDown:
              webCanvas.addEventListener(CanvasEvent.mousedown, _this.onMouseDown);
              webCanvas.addEventListener(CanvasEvent.touchstart, _this.onTouchStart);
              break;
            case TouchType.MouseUp:
              webCanvas.addEventListener(CanvasEvent.mouseup, _this.onMouseUp);
              webCanvas.addEventListener(CanvasEvent.touchend, _this.onTouchEnd);
              break;
          }
          _this.listenerState |= touchType;
          break;
        case OptType.Del:
          if (_this.checkNeedListen(touchType) != preState) {
            switch (touchType) {
              case TouchType.MouseDown:
                webCanvas.removeEventListener(CanvasEvent.mousedown, _this.onMouseDown);
                webCanvas.removeEventListener(CanvasEvent.touchstart, _this.onTouchStart);
                break;
              case TouchType.MouseUp:
                webCanvas.removeEventListener(CanvasEvent.mouseup, _this.onMouseUp);
                webCanvas.removeEventListener(CanvasEvent.touchend, _this.onTouchEnd);
                break;
            }
            _this.listenerState &= ~touchType;
          }
          break;
      }
    };
    this.checkNeedListen = function(touchType) {
      var colliderList = _this.nowListenHash[touchType];
      return colliderList && colliderList.length > 0;
    };
    this.onMouseDown = function(mouseEvt) {
      if (mouseEvt && _this.mouseToVPPos(mouseEvt, _this.tempVPVec)) {
        _this.checkHit(TouchType.MouseDown, mouseEvt);
      }
    };
    this.onTouchStart = function(touchEvt) {
      if (touchEvt && _this.touchToVPPos(touchEvt, _this.tempVPVec)) {
        _this.checkHit(TouchType.MouseDown, touchEvt);
      }
    };
    this.onMouseUp = function(mouseEvt) {
      if (mouseEvt && _this.mouseToVPPos(mouseEvt, _this.tempVPVec)) {
        _this.checkHit(TouchType.MouseUp, mouseEvt);
      }
    };
    this.onTouchEnd = function(touchEvt) {
      if (touchEvt && _this.touchToVPPos(touchEvt, _this.tempVPVec)) {
        _this.checkHit(TouchType.MouseUp, touchEvt);
      }
    };
    this.nowListenHash = {};
    this.tempVPVec = new Vector2();
    this.tempCameraVPVec = new Vector2();
    this.tempRay = new Ray();
    this.tempHit = new HitResult();
  }
  var _proto = TouchManager2.prototype;
  _proto.initEngine = function initEngine(engine) {
    if (this.engine != engine) {
      this.engine = engine;
      this.webCanvas = this.engine.canvas._webCanvas;
    }
  };
  _proto.addTouch = function addTouch(type, collider) {
    var nowListenHash = this.nowListenHash;
    if (nowListenHash[type]) {
      var index = nowListenHash[type].indexOf(collider);
      if (index < 0) {
        nowListenHash[type].push(collider);
      }
    } else {
      nowListenHash[type] = [collider];
    }
    this.updateListener(OptType.Add, type);
  };
  _proto.removeTouch = function removeTouch(type, collider) {
    var colliderList = this.nowListenHash[type];
    if (colliderList) {
      var index = colliderList.indexOf(collider);
      if (index >= 0) {
        colliderList.splice(index, 1);
      }
    }
    this.updateListener(OptType.Del, type);
  };
  _proto.hitCollider = function hitCollider(ray, colliders) {
    var nearestHit = new HitResult();
    nearestHit.distance = Number.MAX_VALUE;
    var hit = this.tempHit;
    for (var i = 0, len = colliders.length; i < len; i++) {
      var collider = colliders[i];
      if (!collider.entity.isActiveInHierarchy) {
        continue;
      }
      if (collider._raycast(ray, hit)) {
        if (hit.distance < nearestHit.distance) {
          nearestHit = hit;
        }
      }
    }
    return nearestHit.collider;
  };
  _createClass(TouchManager2, null, [{
    key: "ins",
    get: function get() {
      if (!this._ins) {
        this._ins = new TouchManager2();
      }
      return this._ins;
    }
  }]);
  return TouchManager2;
}();
TouchManager._ins = void 0;
var OptType;
(function(OptType2) {
  OptType2[OptType2["Add"] = 0] = "Add";
  OptType2[OptType2["Del"] = 1] = "Del";
})(OptType || (OptType = {}));
var TouchType;
(function(TouchType2) {
  TouchType2[TouchType2["MouseDown"] = 1] = "MouseDown";
  TouchType2[TouchType2["MouseUp"] = 2] = "MouseUp";
  TouchType2[TouchType2["Click"] = 4] = "Click";
})(TouchType || (TouchType = {}));
var Touch = function(_Component) {
  _inheritsLoose(Touch2, _Component);
  function Touch2(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _this.collider = void 0;
    _this.collider = _this.entity.getComponent(Collider);
    if (_this.collider) {
      _this.collider.touchCBListHash = {};
    } else {
      console.warn("Please set the collider first");
    }
    return _this;
  }
  var _proto = Touch2.prototype;
  _proto.on = function on(type, cbFun) {
    var touchCBListHash = this.collider.touchCBListHash;
    if (!touchCBListHash[type]) {
      touchCBListHash[type] = [];
    }
    var cbList = touchCBListHash[type];
    if (cbList.indexOf(cbFun) < 0) {
      cbList.push(cbFun);
      TouchManager.ins.addTouch(type, this.collider);
    }
  };
  _proto.off = function off(type, cbFun) {
    var cbList = this.collider.touchCBListHash[type];
    if (cbFun) {
      var index = cbList ? cbList.indexOf(cbFun) : -1;
      if (index >= 0) {
        cbList.splice(index, 1);
        TouchManager.ins.removeTouch(type, this.collider);
      }
    } else {
      cbList && (cbList.length = 0);
    }
  };
  return Touch2;
}(Component);
export {
  Touch,
  TouchManager,
  TouchType
};
//# sourceMappingURL=@oasis-engine_touch.js.map
