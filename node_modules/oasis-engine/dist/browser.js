(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.oasisEngine = {}));
})(this, (function (exports) { 'use strict';

  /**
   * Defines how the bounding volumes intersects or contain one another.
   */
  exports.ContainmentType = void 0;

  (function (ContainmentType) {
    ContainmentType[ContainmentType["Disjoint"] = 0] = "Disjoint";
    ContainmentType[ContainmentType["Contains"] = 1] = "Contains";
    ContainmentType[ContainmentType["Intersects"] = 2] = "Intersects";
  })(exports.ContainmentType || (exports.ContainmentType = {}));
  /**
   * Defines the intersection between a plane and a bounding volume.
   */


  exports.PlaneIntersectionType = void 0;

  (function (PlaneIntersectionType) {
    PlaneIntersectionType[PlaneIntersectionType["Back"] = 0] = "Back";
    PlaneIntersectionType[PlaneIntersectionType["Front"] = 1] = "Front";
    PlaneIntersectionType[PlaneIntersectionType["Intersecting"] = 2] = "Intersecting";
  })(exports.PlaneIntersectionType || (exports.PlaneIntersectionType = {}));
  /**
   * Common utility methods for math operations.
   */


  var MathUtil = /*#__PURE__*/function () {
    function MathUtil() {}
    /** The value for which all absolute numbers smaller than are considered equal to zero. */

    /** The conversion factor that radian to degree. */

    /** The conversion factor that degree to radian. */

    /**
     * Clamps the specified value.
     * @param v - The specified value
     * @param min - The min value
     * @param max - The max value
     * @returns The result of clamping a value between min and max
     */


    MathUtil.clamp = function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }
    /**
     * Checks if a and b are almost equals.
     * The absolute value of the difference between a and b is close to zero.
     * @param a - The left value to compare
     * @param b - The right value to compare
     * @returns True if a almost equal to b, false otherwise
     */
    ;

    MathUtil.equals = function equals(a, b) {
      return Math.abs(a - b) <= MathUtil.zeroTolerance;
    }
    /**
     * Determines whether the specified v is pow2.
     * @param v - The specified v
     * @returns True if the specified v is pow2, false otherwise
     */
    ;

    MathUtil.isPowerOf2 = function isPowerOf2(v) {
      return (v & v - 1) === 0;
    }
    /**
     * Modify the specified r from radian to degree.
     * @param r - The specified r
     * @returns The degree value
     */
    ;

    MathUtil.radianToDegree = function radianToDegree(r) {
      return r * MathUtil.radToDegreeFactor;
    }
    /**
     * Modify the specified d from degree to radian.
     * @param d - The specified d
     * @returns The radian value
     */
    ;

    MathUtil.degreeToRadian = function degreeToRadian(d) {
      return d * MathUtil.degreeToRadFactor;
    };

    return MathUtil;
  }();

  MathUtil.zeroTolerance = 1e-6;
  MathUtil.radToDegreeFactor = 180 / Math.PI;
  MathUtil.degreeToRadFactor = Math.PI / 180;
  /**
   * Describes a 3D-vector.
   */

  var Vector3 = /*#__PURE__*/function () {
    /** @internal */

    /** @internal */

    /**
     * Determines the sum of two vectors.
     * @param left - The first vector to add
     * @param right - The second vector to add
     * @param out - The sum of two vectors
     */
    Vector3.add = function add(left, right, out) {
      out.x = left.x + right.x;
      out.y = left.y + right.y;
      out.z = left.z + right.z;
    }
    /**
     * Determines the difference between two vectors.
     * @param left - The first vector to subtract
     * @param right - The second vector to subtract
     * @param out - The difference between two vectors
     */
    ;

    Vector3.subtract = function subtract(left, right, out) {
      out.x = left.x - right.x;
      out.y = left.y - right.y;
      out.z = left.z - right.z;
    }
    /**
     * Determines the product of two vectors.
     * @param left - The first vector to multiply
     * @param right - The second vector to multiply
     * @param out - The product of two vectors
     */
    ;

    Vector3.multiply = function multiply(left, right, out) {
      out.x = left.x * right.x;
      out.y = left.y * right.y;
      out.z = left.z * right.z;
    }
    /**
     * Determines the divisor of two vectors.
     * @param left - The first vector to divide
     * @param right - The second vector to divide
     * @param out - The divisor of two vectors
     */
    ;

    Vector3.divide = function divide(left, right, out) {
      out.x = left.x / right.x;
      out.y = left.y / right.y;
      out.z = left.z / right.z;
    }
    /**
     * Determines the dot product of two vectors.
     * @param left - The first vector to dot
     * @param right - The second vector to dot
     * @returns The dot product of two vectors
     */
    ;

    Vector3.dot = function dot(left, right) {
      return left.x * right.x + left.y * right.y + left.z * right.z;
    }
    /**
     * Determines the cross product of two vectors.
     * @param left - The first vector to cross
     * @param right - The second vector to cross
     * @param out - The cross product of two vectors
     */
    ;

    Vector3.cross = function cross(left, right, out) {
      var ax = left.x;
      var ay = left.y;
      var az = left.z;
      var bx = right.x;
      var by = right.y;
      var bz = right.z;
      out.x = ay * bz - az * by;
      out.y = az * bx - ax * bz;
      out.z = ax * by - ay * bx;
    }
    /**
     * Determines the distance of two vectors.
     * @param a - The first vector
     * @param b - The second vector
     * @returns The distance of two vectors
     */
    ;

    Vector3.distance = function distance(a, b) {
      var x = b.x - a.x;
      var y = b.y - a.y;
      var z = b.z - a.z;
      return Math.sqrt(x * x + y * y + z * z);
    }
    /**
     * Determines the squared distance of two vectors.
     * @param a - The first vector
     * @param b - The second vector
     * @returns The squared distance of two vectors
     */
    ;

    Vector3.distanceSquared = function distanceSquared(a, b) {
      var x = b.x - a.x;
      var y = b.y - a.y;
      var z = b.z - a.z;
      return x * x + y * y + z * z;
    }
    /**
     * Determines whether the specified vectors are equals.
     * @param left - The first vector to compare
     * @param right - The second vector to compare
     * @returns True if the specified vectors are equals, false otherwise
     */
    ;

    Vector3.equals = function equals(left, right) {
      return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z);
    }
    /**
     * Performs a linear interpolation between two vectors.
     * @param start - The first vector
     * @param end - The second vector
     * @param t - The blend amount where 0 returns start and 1 end
     * @param out - The result of linear blending between two vectors
     */
    ;

    Vector3.lerp = function lerp(start, end, t, out) {
      var x = start.x,
          y = start.y,
          z = start.z;
      out.x = x + (end.x - x) * t;
      out.y = y + (end.y - y) * t;
      out.z = z + (end.z - z) * t;
    }
    /**
     * Calculate a vector containing the largest components of the specified vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @param out - The vector containing the largest components of the specified vectors
     */
    ;

    Vector3.max = function max(left, right, out) {
      out.x = Math.max(left.x, right.x);
      out.y = Math.max(left.y, right.y);
      out.z = Math.max(left.z, right.z);
    }
    /**
     * Calculate a vector containing the smallest components of the specified vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @param out - The vector containing the smallest components of the specified vectors
     */
    ;

    Vector3.min = function min(left, right, out) {
      out.x = Math.min(left.x, right.x);
      out.y = Math.min(left.y, right.y);
      out.z = Math.min(left.z, right.z);
    }
    /**
     * Reverses the direction of a given vector.
     * @param a - The vector to negate
     * @param out - The vector facing in the opposite direction
     */
    ;

    Vector3.negate = function negate(a, out) {
      out.x = -a.x;
      out.y = -a.y;
      out.z = -a.z;
    }
    /**
     * Converts the vector into a unit vector.
     * @param a - The vector to normalize
     * @param out - The normalized vector
     */
    ;

    Vector3.normalize = function normalize(a, out) {
      var x = a.x,
          y = a.y,
          z = a.z;
      var len = Math.sqrt(x * x + y * y + z * z);

      if (len > 0) {
        // TODO
        len = 1 / len;
        out.x = x * len;
        out.y = y * len;
        out.z = z * len;
      }
    }
    /**
     * Scale a vector by the given value.
     * @param a - The vector to scale
     * @param s - The amount by which to scale the vector
     * @param out - The scaled vector
     */
    ;

    Vector3.scale = function scale(a, s, out) {
      out.x = a.x * s;
      out.y = a.y * s;
      out.z = a.z * s;
    }
    /**
     * Performs a normal transformation using the given 4x4 matrix.
     * @remarks
     * A normal transform performs the transformation with the assumption that the w component
     * is zero. This causes the fourth row and fourth column of the matrix to be unused. The
     * end result is a vector that is not translated, but all other transformation properties
     * apply. This is often preferred for normal vectors as normals purely represent direction
     * rather than location because normal vectors should not be translated.
     * @param v - The normal vector to transform
     * @param m - The transform matrix
     * @param out - The transformed normal
     */
    ;

    Vector3.transformNormal = function transformNormal(v, m, out) {
      var x = v.x,
          y = v.y,
          z = v.z;
      var e = m.elements;
      out.x = x * e[0] + y * e[4] + z * e[8];
      out.y = x * e[1] + y * e[5] + z * e[9];
      out.z = x * e[2] + y * e[6] + z * e[10];
    }
    /**
     * Performs a transformation using the given 4x4 matrix.
     * @param v - The vector to transform
     * @param m - The transform matrix
     * @param out - The transformed vector3
     */
    ;

    Vector3.transformToVec3 = function transformToVec3(v, m, out) {
      var x = v.x,
          y = v.y,
          z = v.z;
      var e = m.elements;
      out.x = x * e[0] + y * e[4] + z * e[8] + e[12];
      out.y = x * e[1] + y * e[5] + z * e[9] + e[13];
      out.z = x * e[2] + y * e[6] + z * e[10] + e[14];
    }
    /**
     * Performs a transformation from vector3 to vector4 using the given 4x4 matrix.
     * @param v - The vector to transform
     * @param m - The transform matrix
     * @param out - The transformed vector4
     */
    ;

    Vector3.transformToVec4 = function transformToVec4(v, m, out) {
      var x = v.x,
          y = v.y,
          z = v.z;
      var e = m.elements;
      out.x = x * e[0] + y * e[4] + z * e[8] + e[12];
      out.y = x * e[1] + y * e[5] + z * e[9] + e[13];
      out.z = x * e[2] + y * e[6] + z * e[10] + e[14];
      out.w = x * e[3] + y * e[7] + z * e[11] + e[15];
    }
    /**
     * Performs a coordinate transformation using the given 4x4 matrix.
     *
     * @remarks
     * A coordinate transform performs the transformation with the assumption that the w component
     * is one. The four dimensional vector obtained from the transformation operation has each
     * component in the vector divided by the w component. This forces the w-component to be one and
     * therefore makes the vector homogeneous. The homogeneous vector is often preferred when working
     * with coordinates as the w component can safely be ignored.
     * @param v - The coordinate vector to transform
     * @param m - The transform matrix
     * @param out - The transformed coordinates
     */
    ;

    Vector3.transformCoordinate = function transformCoordinate(v, m, out) {
      var x = v.x,
          y = v.y,
          z = v.z;
      var e = m.elements;
      var w = x * e[3] + y * e[7] + z * e[11] + e[15];
      w = 1.0 / w;
      out.x = (x * e[0] + y * e[4] + z * e[8] + e[12]) * w;
      out.y = (x * e[1] + y * e[5] + z * e[9] + e[13]) * w;
      out.z = (x * e[2] + y * e[6] + z * e[10] + e[14]) * w;
    }
    /**
     * Performs a transformation using the given quaternion.
     * @param v - The vector to transform
     * @param quaternion - The transform quaternion
     * @param out - The transformed vector
     */
    ;

    Vector3.transformByQuat = function transformByQuat(v, quaternion, out) {
      var x = v.x,
          y = v.y,
          z = v.z;
      var qx = quaternion.x,
          qy = quaternion.y,
          qz = quaternion.z,
          qw = quaternion.w; // calculate quat * vec

      var ix = qw * x + qy * z - qz * y;
      var iy = qw * y + qz * x - qx * z;
      var iz = qw * z + qx * y - qy * x;
      var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

      out.x = ix * qw - iw * qx - iy * qz + iz * qy;
      out.y = iy * qw - iw * qy - iz * qx + ix * qz;
      out.z = iz * qw - iw * qz - ix * qy + iy * qx;
    }
    /** The x component of the vector.*/
    ;
    /**
     * Constructor of Vector3.
     * @param x - The x component of the vector, default 0
     * @param y - The y component of the vector, default 0
     * @param z - The z component of the vector, default 0
     */


    function Vector3(x, y, z) {
      if (x === void 0) {
        x = 0;
      }

      if (y === void 0) {
        y = 0;
      }

      if (z === void 0) {
        z = 0;
      }

      this.x = void 0;
      this.y = void 0;
      this.z = void 0;
      this.x = x;
      this.y = y;
      this.z = z;
    }
    /**
     * Set the value of this vector.
     * @param x - The x component of the vector
     * @param y - The y component of the vector
     * @param z - The z component of the vector
     * @returns This vector
     */


    var _proto = Vector3.prototype;

    _proto.setValue = function setValue(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    }
    /**
     * Set the value of this vector by an array.
     * @param array - The array
     * @param offset - The start offset of the array
     * @returns This vector
     */
    ;

    _proto.setValueByArray = function setValueByArray(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }

      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    }
    /**
     * Determines the sum of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */
    ;

    _proto.add = function add(right) {
      this.x += right.x;
      this.y += right.y;
      this.z += right.z;
      return this;
    }
    /**
     * Determines the difference of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */
    ;

    _proto.subtract = function subtract(right) {
      this.x -= right.x;
      this.y -= right.y;
      this.z -= right.z;
      return this;
    }
    /**
     * Determines the product of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */
    ;

    _proto.multiply = function multiply(right) {
      this.x *= right.x;
      this.y *= right.y;
      this.z *= right.z;
      return this;
    }
    /**
     * Determines the divisor of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */
    ;

    _proto.divide = function divide(right) {
      this.x /= right.x;
      this.y /= right.y;
      this.z /= right.z;
      return this;
    }
    /**
     * Calculate the length of this vector.
     * @returns The length of this vector
     */
    ;

    _proto.length = function length() {
      var x = this.x,
          y = this.y,
          z = this.z;
      return Math.sqrt(x * x + y * y + z * z);
    }
    /**
     * Calculate the squared length of this vector.
     * @returns The squared length of this vector
     */
    ;

    _proto.lengthSquared = function lengthSquared() {
      var x = this.x,
          y = this.y,
          z = this.z;
      return x * x + y * y + z * z;
    }
    /**
     * Reverses the direction of this vector.
     * @returns This vector
     */
    ;

    _proto.negate = function negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
    /**
     * Converts this vector into a unit vector.
     * @returns This vector
     */
    ;

    _proto.normalize = function normalize() {
      Vector3.normalize(this, this);
      return this;
    }
    /**
     * Scale this vector by the given value.
     * @param s - The amount by which to scale the vector
     * @returns This vector
     */
    ;

    _proto.scale = function scale(s) {
      this.x *= s;
      this.y *= s;
      this.z *= s;
      return this;
    }
    /**
     * Clone the value of this vector to an array.
     * @param out - The array
     * @param outOffset - The start offset of the array
     */
    ;

    _proto.toArray = function toArray(out, outOffset) {
      if (outOffset === void 0) {
        outOffset = 0;
      }

      out[outOffset] = this.x;
      out[outOffset + 1] = this.y;
      out[outOffset + 2] = this.z;
    }
    /**
     * Creates a clone of this vector.
     * @returns A clone of this vector
     */
    ;

    _proto.clone = function clone() {
      return new Vector3(this.x, this.y, this.z);
    }
    /**
     * Clones this vector to the specified vector.
     * @param out - The specified vector
     * @returns The specified vector
     */
    ;

    _proto.cloneTo = function cloneTo(out) {
      out.x = this.x;
      out.y = this.y;
      out.z = this.z;
      return out;
    }
    /**
     * This vector performs a normal transformation using the given 4x4 matrix.
     * @remarks
     * A normal transform performs the transformation with the assumption that the w component
     * is zero. This causes the fourth row and fourth column of the matrix to be unused. The
     * end result is a vector that is not translated, but all other transformation properties
     * apply. This is often preferred for normal vectors as normals purely represent direction
     * rather than location because normal vectors should not be translated.
     * @param m - The transform matrix
     * @returns This vector
     */
    ;

    _proto.transformNormal = function transformNormal(m) {
      Vector3.transformNormal(this, m, this);
      return this;
    }
    /**
     * This vector performs a transformation using the given 4x4 matrix.
     * @param m - The transform matrix
     * @returns This vector
     */
    ;

    _proto.transformToVec3 = function transformToVec3(m) {
      Vector3.transformToVec3(this, m, this);
      return this;
    }
    /**
     * This vector performs a coordinate transformation using the given 4x4 matrix.
     * @remarks
     * A coordinate transform performs the transformation with the assumption that the w component
     * is one. The four dimensional vector obtained from the transformation operation has each
     * component in the vector divided by the w component. This forces the w-component to be one and
     * therefore makes the vector homogeneous. The homogeneous vector is often preferred when working
     * with coordinates as the w component can safely be ignored.
     * @param m - The transform matrix
     * @returns This vector
     */
    ;

    _proto.transformCoordinate = function transformCoordinate(m) {
      Vector3.transformCoordinate(this, m, this);
      return this;
    }
    /**
     * This vector performs a transformation using the given quaternion.
     * @param quaternion - The transform quaternion
     * @returns This vector
     */
    ;

    _proto.transformByQuat = function transformByQuat(quaternion) {
      Vector3.transformByQuat(this, quaternion, this);
      return this;
    };

    return Vector3;
  }();

  Vector3._zero = new Vector3(0.0, 0.0, 0.0);
  Vector3._one = new Vector3(1.0, 1.0, 1.0);
  /**
   * A bounding sphere.
   * */

  var BoundingSphere = /*#__PURE__*/function () {
    /**
     * Calculate a bounding sphere that fully contains the given points.
     * @param points - The given points
     * @param out - The calculated bounding sphere
     */
    BoundingSphere.fromPoints = function fromPoints(points, out) {
      if (!points || points.length === 0) {
        throw new Error("points must be array and length must > 0");
      }

      var len = points.length;
      var center = BoundingSphere._tempVec30;
      center.x = center.y = center.z = 0; // Calculate the center of the sphere.

      for (var i = 0; i < len; ++i) {
        Vector3.add(points[i], center, center);
      } // The center of the sphere.


      Vector3.scale(center, 1 / len, out.center); // Calculate the radius of the sphere.

      var radius = 0.0;

      for (var _i = 0; _i < len; ++_i) {
        var distance = Vector3.distanceSquared(center, points[_i]);
        distance > radius && (radius = distance);
      } // The radius of the sphere.


      out.radius = Math.sqrt(radius);
    }
    /**
     * Calculate a bounding sphere from a given box.
     * @param box - The given box
     * @param out - The calculated bounding sphere
     */
    ;

    BoundingSphere.fromBox = function fromBox(box, out) {
      var center = out.center;
      var min = box.min,
          max = box.max;
      center.x = (min.x + max.x) * 0.5;
      center.y = (min.y + max.y) * 0.5;
      center.z = (min.z + max.z) * 0.5;
      out.radius = Vector3.distance(center, max);
    }
    /** The center point of the sphere. */
    ;
    /**
     * Constructor of BoundingSphere.
     * @param center - The center point of the sphere
     * @param radius - The radius of the sphere
     */


    function BoundingSphere(center, radius) {
      if (center === void 0) {
        center = null;
      }

      if (radius === void 0) {
        radius = 0;
      }

      this.center = new Vector3();
      this.radius = 0;
      center && center.cloneTo(this.center);
      this.radius = radius;
    }
    /**
     * Creates a clone of this sphere.
     * @returns A clone of this sphere
     */


    var _proto = BoundingSphere.prototype;

    _proto.clone = function clone() {
      return new BoundingSphere(this.center, this.radius);
    }
    /**
     * Clones this sphere to the specified sphere.
     * @param out - The specified sphere
     * @returns The specified sphere
     */
    ;

    _proto.cloneTo = function cloneTo(out) {
      this.center.cloneTo(out.center);
      out.radius = this.radius;
      return out;
    };

    return BoundingSphere;
  }();

  BoundingSphere._tempVec30 = new Vector3();
  /**
   * Axis Aligned Bound Box (AABB).
   */

  var BoundingBox = /*#__PURE__*/function () {
    /**
     * Calculate a bounding box from the center point and the extent of the bounding box.
     * @param center - The center point
     * @param extent - The extent of the bounding box
     * @param out - The calculated bounding box
     */
    BoundingBox.fromCenterAndExtent = function fromCenterAndExtent(center, extent, out) {
      Vector3.subtract(center, extent, out.min);
      Vector3.add(center, extent, out.max);
    }
    /**
     * Calculate a bounding box that fully contains the given points.
     * @param points - The given points
     * @param out - The calculated bounding box
     */
    ;

    BoundingBox.fromPoints = function fromPoints(points, out) {
      if (!points || points.length === 0) {
        throw new Error("points must be array and length must > 0");
      }

      var min = out.min,
          max = out.max;
      min.x = min.y = min.z = Number.MAX_VALUE;
      max.x = max.y = max.z = -Number.MAX_VALUE;

      for (var i = 0, l = points.length; i < l; ++i) {
        var point = points[i];
        Vector3.min(min, point, min);
        Vector3.max(max, point, max);
      }
    }
    /**
     * Calculate a bounding box from a given sphere.
     * @param sphere - The given sphere
     * @param out - The calculated bounding box
     */
    ;

    BoundingBox.fromSphere = function fromSphere(sphere, out) {
      var center = sphere.center,
          radius = sphere.radius;
      var min = out.min,
          max = out.max;
      min.x = center.x - radius;
      min.y = center.y - radius;
      min.z = center.z - radius;
      max.x = center.x + radius;
      max.y = center.y + radius;
      max.z = center.z + radius;
    }
    /**
     * Transform a bounding box.
     * @param source - The original bounding box
     * @param matrix - The transform to apply to the bounding box
     * @param out - The transformed bounding box
     */
    ;

    BoundingBox.transform = function transform(source, matrix, out) {
      // https://zeux.io/2010/10/17/aabb-from-obb-with-component-wise-abs/
      var center = BoundingBox._tempVec30;
      var extent = BoundingBox._tempVec31;
      source.getCenter(center);
      source.getExtent(extent);
      Vector3.transformCoordinate(center, matrix, center);
      var x = extent.x,
          y = extent.y,
          z = extent.z;
      var e = matrix.elements;
      extent.x = Math.abs(x * e[0]) + Math.abs(y * e[4]) + Math.abs(z * e[8]);
      extent.y = Math.abs(x * e[1]) + Math.abs(y * e[5]) + Math.abs(z * e[9]);
      extent.z = Math.abs(x * e[2]) + Math.abs(y * e[6]) + Math.abs(z * e[10]); // set min、max

      Vector3.subtract(center, extent, out.min);
      Vector3.add(center, extent, out.max);
    }
    /**
     * Calculate a bounding box that is as large as the total combined area of the two specified boxes.
     * @param box1 - The first box to merge
     * @param box2 - The second box to merge
     * @param out - The merged bounding box
     * @returns The merged bounding box
     */
    ;

    BoundingBox.merge = function merge(box1, box2, out) {
      Vector3.min(box1.min, box2.min, out.min);
      Vector3.max(box1.max, box2.max, out.max);
      return out;
    }
    /** The minimum point of the box. */
    ;
    /**
     * Constructor of BoundingBox.
     * @param min - The minimum point of the box
     * @param max - The maximum point of the box
     */


    function BoundingBox(min, max) {
      if (min === void 0) {
        min = null;
      }

      if (max === void 0) {
        max = null;
      }

      this.min = new Vector3();
      this.max = new Vector3();
      min && min.cloneTo(this.min);
      max && max.cloneTo(this.max);
    }
    /**
     * Creates a clone of this box.
     * @returns A clone of this box
     */


    var _proto = BoundingBox.prototype;

    _proto.clone = function clone() {
      return new BoundingBox(this.min, this.max);
    }
    /**
     * Clones this box to the specified box.
     * @param out - The specified box
     * @returns The specified box
     */
    ;

    _proto.cloneTo = function cloneTo(out) {
      this.min.cloneTo(out.min);
      this.max.cloneTo(out.max);
      return out;
    }
    /**
     * Get the center point of this bounding box.
     * @param out - The center point of this bounding box
     * @returns The center point of this bounding box
     */
    ;

    _proto.getCenter = function getCenter(out) {
      Vector3.add(this.min, this.max, out);
      Vector3.scale(out, 0.5, out);
      return out;
    }
    /**
     * Get the extent of this bounding box.
     * @param out - The extent of this bounding box
     * @returns The extent of this bounding box
     */
    ;

    _proto.getExtent = function getExtent(out) {
      Vector3.subtract(this.max, this.min, out);
      Vector3.scale(out, 0.5, out);
      return out;
    }
    /**
     * Get the eight corners of this bounding box.
     * @param out - An array of points representing the eight corners of this bounding box
     * @returns An array of points representing the eight corners of this bounding box
     */
    ;

    _proto.getCorners = function getCorners(out) {
      if (out === void 0) {
        out = [];
      }

      var min = this.min,
          max = this.max;
      var minX = min.x;
      var minY = min.y;
      var minZ = min.z;
      var maxX = max.x;
      var maxY = max.y;
      var maxZ = max.z;
      var len = out.length; // The array length is less than 8 to make up

      if (len < 8) {
        for (var i = 0, l = 8 - len; i < l; ++i) {
          out[len + i] = new Vector3();
        }
      }

      out[0].setValue(minX, maxY, maxZ);
      out[1].setValue(maxX, maxY, maxZ);
      out[2].setValue(maxX, minY, maxZ);
      out[3].setValue(minX, minY, maxZ);
      out[4].setValue(minX, maxY, minZ);
      out[5].setValue(maxX, maxY, minZ);
      out[6].setValue(maxX, minY, minZ);
      out[7].setValue(minX, minY, minZ);
      return out;
    }
    /**
     * Transform a bounding box.
     * @param matrix - The transform to apply to the bounding box
     * @returns The transformed bounding box
     */
    ;

    _proto.transform = function transform(matrix) {
      BoundingBox.transform(this, matrix, this);
      return this;
    };

    return BoundingBox;
  }();

  BoundingBox._tempVec30 = new Vector3();
  BoundingBox._tempVec31 = new Vector3();
  /**
   * Contains static methods to help in determining intersections, containment, etc.
   */

  var CollisionUtil = /*#__PURE__*/function () {
    function CollisionUtil() {}
    /**
     * Calculate the distance from a point to a plane.
     * @param plane - The plane
     * @param point - The point
     * @returns The distance from a point to a plane
     */


    CollisionUtil.distancePlaneAndPoint = function distancePlaneAndPoint(plane, point) {
      return Vector3.dot(plane.normal, point) + plane.distance;
    }
    /**
     * Get the intersection type between a plane and a point.
     * @param plane - The plane
     * @param point - The point
     * @returns The intersection type
     */
    ;

    CollisionUtil.intersectsPlaneAndPoint = function intersectsPlaneAndPoint(plane, point) {
      var distance = CollisionUtil.distancePlaneAndPoint(plane, point);

      if (distance > 0) {
        return exports.PlaneIntersectionType.Front;
      }

      if (distance < 0) {
        return exports.PlaneIntersectionType.Back;
      }

      return exports.PlaneIntersectionType.Intersecting;
    }
    /**
     * Get the intersection type between a plane and a box (AABB).
     * @param plane - The plane
     * @param box - The box
     * @returns The intersection type
     */
    ;

    CollisionUtil.intersectsPlaneAndBox = function intersectsPlaneAndBox(plane, box) {
      var min = box.min,
          max = box.max;
      var normal = plane.normal;
      var front = CollisionUtil._tempVec30;
      var back = CollisionUtil._tempVec31;

      if (normal.x >= 0) {
        front.x = max.x;
        back.x = min.x;
      } else {
        front.x = min.x;
        back.x = max.x;
      }

      if (normal.y >= 0) {
        front.y = max.y;
        back.y = min.y;
      } else {
        front.y = min.y;
        back.y = max.y;
      }

      if (normal.z >= 0) {
        front.z = max.z;
        back.z = min.z;
      } else {
        front.z = min.z;
        back.z = max.z;
      }

      if (CollisionUtil.distancePlaneAndPoint(plane, front) < 0) {
        return exports.PlaneIntersectionType.Back;
      }

      if (CollisionUtil.distancePlaneAndPoint(plane, back) > 0) {
        return exports.PlaneIntersectionType.Front;
      }

      return exports.PlaneIntersectionType.Intersecting;
    }
    /**
     * Get the intersection type between a plane and a sphere.
     * @param plane - The plane
     * @param sphere - The sphere
     * @returns The intersection type
     */
    ;

    CollisionUtil.intersectsPlaneAndSphere = function intersectsPlaneAndSphere(plane, sphere) {
      var center = sphere.center,
          radius = sphere.radius;
      var distance = CollisionUtil.distancePlaneAndPoint(plane, center);

      if (distance > radius) {
        return exports.PlaneIntersectionType.Front;
      }

      if (distance < -radius) {
        return exports.PlaneIntersectionType.Back;
      }

      return exports.PlaneIntersectionType.Intersecting;
    }
    /**
     * Get the intersection type between a ray and a plane.
     * @param ray - The ray
     * @param plane - The plane
     * @returns The distance from ray to plane if intersecting, -1 otherwise
     */
    ;

    CollisionUtil.intersectsRayAndPlane = function intersectsRayAndPlane(ray, plane) {
      var normal = plane.normal;
      var zeroTolerance = MathUtil.zeroTolerance;
      var dir = Vector3.dot(normal, ray.direction); // Parallel

      if (Math.abs(dir) < zeroTolerance) {
        return -1;
      }

      var position = Vector3.dot(normal, ray.origin);
      var distance = (-plane.distance - position) / dir;

      if (distance < 0) {
        if (distance < -zeroTolerance) {
          return -1;
        }

        distance = 0;
      }

      return distance;
    }
    /**
     * Get the intersection type between a ray and a box (AABB).
     * @param ray - The ray
     * @param box - The box
     * @returns The distance from ray to box if intersecting, -1 otherwise
     */
    ;

    CollisionUtil.intersectsRayAndBox = function intersectsRayAndBox(ray, box) {
      var zeroTolerance = MathUtil.zeroTolerance;
      var origin = ray.origin,
          direction = ray.direction;
      var min = box.min,
          max = box.max;
      var dirX = direction.x;
      var dirY = direction.y;
      var dirZ = direction.z;
      var oriX = origin.x;
      var oriY = origin.y;
      var oriZ = origin.z;
      var distance = 0;
      var tmax = Number.MAX_VALUE;

      if (Math.abs(dirX) < zeroTolerance) {
        if (oriX < min.x || oriX > max.x) {
          return -1;
        }
      } else {
        var inverse = 1.0 / dirX;
        var t1 = (min.x - oriX) * inverse;
        var t2 = (max.x - oriX) * inverse;

        if (t1 > t2) {
          var temp = t1;
          t1 = t2;
          t2 = temp;
        }

        distance = Math.max(t1, distance);
        tmax = Math.min(t2, tmax);

        if (distance > tmax) {
          return -1;
        }
      }

      if (Math.abs(dirY) < zeroTolerance) {
        if (oriY < min.y || oriY > max.y) {
          return -1;
        }
      } else {
        var _inverse = 1.0 / dirY;

        var _t = (min.y - oriY) * _inverse;

        var _t2 = (max.y - oriY) * _inverse;

        if (_t > _t2) {
          var _temp = _t;
          _t = _t2;
          _t2 = _temp;
        }

        distance = Math.max(_t, distance);
        tmax = Math.min(_t2, tmax);

        if (distance > tmax) {
          return -1;
        }
      }

      if (Math.abs(dirZ) < zeroTolerance) {
        if (oriZ < min.z || oriZ > max.z) {
          return -1;
        }
      } else {
        var _inverse2 = 1.0 / dirZ;

        var _t3 = (min.z - oriZ) * _inverse2;

        var _t4 = (max.z - oriZ) * _inverse2;

        if (_t3 > _t4) {
          var _temp2 = _t3;
          _t3 = _t4;
          _t4 = _temp2;
        }

        distance = Math.max(_t3, distance);
        tmax = Math.min(_t4, tmax);

        if (distance > tmax) {
          return -1;
        }
      }

      return distance;
    }
    /**
     * Get the intersection type between a ray and a sphere.
     * @param ray - The ray
     * @param sphere - The sphere
     * @returns The distance from ray to sphere if intersecting, -1 otherwise
     */
    ;

    CollisionUtil.intersectsRayAndSphere = function intersectsRayAndSphere(ray, sphere) {
      var origin = ray.origin,
          direction = ray.direction;
      var center = sphere.center,
          radius = sphere.radius;
      var m = CollisionUtil._tempVec30;
      Vector3.subtract(origin, center, m);
      var b = Vector3.dot(m, direction);
      var c = Vector3.dot(m, m) - radius * radius;

      if (b > 0 && c > 0) {
        return -1;
      }

      var discriminant = b * b - c;

      if (discriminant < 0) {
        return -1;
      }

      var distance = -b - Math.sqrt(discriminant);

      if (distance < 0) {
        distance = 0;
      }

      return distance;
    }
    /**
     * Get whether or not a specified bounding box intersects with this frustum (Contains or Intersects).
     * @param frustum - The frustum
     * @param box - The box
     * @returns True if bounding box intersects with this frustum, false otherwise
     */
    ;

    CollisionUtil.intersectsFrustumAndBox = function intersectsFrustumAndBox(frustum, box) {
      var min = box.min,
          max = box.max;
      var back = CollisionUtil._tempVec30;

      for (var i = 0; i < 6; ++i) {
        var plane = frustum.getPlane(i);
        var normal = plane.normal;
        back.x = normal.x >= 0 ? min.x : max.x;
        back.y = normal.y >= 0 ? min.y : max.y;
        back.z = normal.z >= 0 ? min.z : max.z;

        if (Vector3.dot(plane.normal, back) > -plane.distance) {
          return false;
        }
      }

      return true;
    }
    /**
     * Get the containment type between a frustum and a box (AABB).
     * @param frustum - The frustum
     * @param box - The box
     * @returns The containment type
     */
    ;

    CollisionUtil.frustumContainsBox = function frustumContainsBox(frustum, box) {
      var min = box.min,
          max = box.max;
      var front = CollisionUtil._tempVec30;
      var back = CollisionUtil._tempVec31;
      var result = exports.ContainmentType.Contains;

      for (var i = 0; i < 6; ++i) {
        var plane = frustum.getPlane(i);
        var normal = plane.normal;

        if (normal.x >= 0) {
          front.x = max.x;
          back.x = min.x;
        } else {
          front.x = min.x;
          back.x = max.x;
        }

        if (normal.y >= 0) {
          front.y = max.y;
          back.y = min.y;
        } else {
          front.y = min.y;
          back.y = max.y;
        }

        if (normal.z >= 0) {
          front.z = max.z;
          back.z = min.z;
        } else {
          front.z = min.z;
          back.z = max.z;
        }

        if (CollisionUtil.intersectsPlaneAndPoint(plane, back) === exports.PlaneIntersectionType.Front) {
          return exports.ContainmentType.Disjoint;
        }

        if (CollisionUtil.intersectsPlaneAndPoint(plane, front) === exports.PlaneIntersectionType.Front) {
          result = exports.ContainmentType.Intersects;
        }
      }

      return result;
    }
    /**
     * Get the containment type between a frustum and a sphere.
     * @param frustum - The frustum
     * @param sphere - The sphere
     * @returns The containment type
     */
    ;

    CollisionUtil.frustumContainsSphere = function frustumContainsSphere(frustum, sphere) {
      var result = exports.ContainmentType.Contains;

      for (var i = 0; i < 6; ++i) {
        var plane = frustum.getPlane(i);
        var intersectionType = CollisionUtil.intersectsPlaneAndSphere(plane, sphere);

        if (intersectionType === exports.PlaneIntersectionType.Front) {
          return exports.ContainmentType.Disjoint;
        } else if (intersectionType === exports.PlaneIntersectionType.Intersecting) {
          result = exports.ContainmentType.Intersects;
          break;
        }
      }

      return result;
    };

    return CollisionUtil;
  }();

  CollisionUtil._tempVec30 = new Vector3();
  CollisionUtil._tempVec31 = new Vector3();
  /**
   * Represents a plane in three dimensional space.
   */

  var Plane = /*#__PURE__*/function () {
    /**
     * Normalize the normal vector of the specified plane.
     * @param p - The specified plane
     * @param out - A normalized version of the specified plane
     */
    Plane.normalize = function normalize(p, out) {
      var normal = p.normal;
      var factor = 1.0 / normal.length();
      var outNormal = out.normal;
      outNormal.x = normal.x * factor;
      outNormal.y = normal.y * factor;
      outNormal.z = normal.z * factor;
      out.distance = p.distance * factor;
    }
    /**
     * Calculate the plane that contains the three specified points.
     * @param point0 - The first point
     * @param point1 - The second point
     * @param point2 - The third point
     * @param out - The calculated plane
     */
    ;

    Plane.fromPoints = function fromPoints(point0, point1, point2, out) {
      var x0 = point0.x;
      var y0 = point0.y;
      var z0 = point0.z;
      var x1 = point1.x - x0;
      var y1 = point1.y - y0;
      var z1 = point1.z - z0;
      var x2 = point2.x - x0;
      var y2 = point2.y - y0;
      var z2 = point2.z - z0;
      var yz = y1 * z2 - z1 * y2;
      var xz = z1 * x2 - x1 * z2;
      var xy = x1 * y2 - y1 * x2;
      var invPyth = 1.0 / Math.sqrt(yz * yz + xz * xz + xy * xy);
      var x = yz * invPyth;
      var y = xz * invPyth;
      var z = xy * invPyth;
      var normal = out.normal;
      normal.x = x;
      normal.y = y;
      normal.z = z;
      out.distance = -(x * x0 + y * y0 + z * z0);
    }
    /** The normal of the plane. */
    ;
    /**
     * Constructor of Plane.
     * @param normal - The normal vector
     * @param distance - The distance of the plane along its normal to the origin
     */


    function Plane(normal, distance) {
      if (normal === void 0) {
        normal = null;
      }

      if (distance === void 0) {
        distance = 0;
      }

      this.normal = new Vector3();
      this.distance = 0;
      normal && normal.cloneTo(this.normal);
      this.distance = distance;
    }
    /**
     * Normalize the normal vector of this plane.
     * @returns The plane after normalize
     */


    var _proto = Plane.prototype;

    _proto.normalize = function normalize() {
      Plane.normalize(this, this);
      return this;
    }
    /**
     * Creates a clone of this plane.
     * @returns A clone of this plane
     */
    ;

    _proto.clone = function clone() {
      var out = new Plane();
      this.cloneTo(out);
      return out;
    }
    /**
     * Clones this plane to the specified plane.
     * @param out - The specified plane
     * @returns The specified plane
     */
    ;

    _proto.cloneTo = function cloneTo(out) {
      this.normal.cloneTo(out.normal);
      out.distance = this.distance;
      return out;
    };

    return Plane;
  }();
  /**
   * A bounding frustum.
   */


  var BoundingFrustum = /*#__PURE__*/function () {
    /** The near plane of this frustum. */

    /** The far plane of this frustum. */

    /** The left plane of this frustum. */

    /** The right plane of this frustum. */

    /** The top plane of this frustum. */

    /** The bottom plane of this frustum. */

    /**
     * Constructor of BoundingFrustum.
     * @param matrix - The view-projection matrix
     */
    function BoundingFrustum(matrix) {
      if (matrix === void 0) {
        matrix = null;
      }

      this.near = void 0;
      this.far = void 0;
      this.left = void 0;
      this.right = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.near = new Plane();
      this.far = new Plane();
      this.left = new Plane();
      this.right = new Plane();
      this.top = new Plane();
      this.bottom = new Plane();
      matrix && this.calculateFromMatrix(matrix);
    }
    /**
     * Creates a clone of this frustum.
     * @returns A clone of this frustum
     */


    var _proto = BoundingFrustum.prototype;

    _proto.clone = function clone() {
      var bf = new BoundingFrustum();
      this.cloneTo(bf);
      return bf;
    }
    /**
     * Clones this frustum to the specified frustum.
     * @param out - The specified frustum
     * @returns The specified frustum
     */
    ;

    _proto.cloneTo = function cloneTo(out) {
      this.near.cloneTo(out.near);
      this.far.cloneTo(out.far);
      this.left.cloneTo(out.left);
      this.right.cloneTo(out.right);
      this.top.cloneTo(out.top);
      this.bottom.cloneTo(out.bottom);
      return out;
    }
    /**
     * Get the plane by the given index.
     * 0: near
     * 1: far
     * 2: left
     * 3: right
     * 4: top
     * 5: bottom
     * @param index - The index
     * @returns The plane get
     */
    ;

    _proto.getPlane = function getPlane(index) {
      switch (index) {
        case 0:
          return this.near;

        case 1:
          return this.far;

        case 2:
          return this.left;

        case 3:
          return this.right;

        case 4:
          return this.top;

        case 5:
          return this.bottom;

        default:
          return null;
      }
    }
    /**
     * Update all planes from the given matrix.
     * @param matrix - The given view-projection matrix
     */
    ;

    _proto.calculateFromMatrix = function calculateFromMatrix(matrix) {
      var me = matrix.elements;
      var m11 = me[0];
      var m12 = me[1];
      var m13 = me[2];
      var m14 = me[3];
      var m21 = me[4];
      var m22 = me[5];
      var m23 = me[6];
      var m24 = me[7];
      var m31 = me[8];
      var m32 = me[9];
      var m33 = me[10];
      var m34 = me[11];
      var m41 = me[12];
      var m42 = me[13];
      var m43 = me[14];
      var m44 = me[15]; // near

      var nearNormal = this.near.normal;
      nearNormal.x = -m14 - m13;
      nearNormal.y = -m24 - m23;
      nearNormal.z = -m34 - m33;
      this.near.distance = -m44 - m43;
      this.near.normalize(); // far

      var farNormal = this.far.normal;
      farNormal.x = m13 - m14;
      farNormal.y = m23 - m24;
      farNormal.z = m33 - m34;
      this.far.distance = m43 - m44;
      this.far.normalize(); // left

      var leftNormal = this.left.normal;
      leftNormal.x = -m14 - m11;
      leftNormal.y = -m24 - m21;
      leftNormal.z = -m34 - m31;
      this.left.distance = -m44 - m41;
      this.left.normalize(); // right

      var rightNormal = this.right.normal;
      rightNormal.x = m11 - m14;
      rightNormal.y = m21 - m24;
      rightNormal.z = m31 - m34;
      this.right.distance = m41 - m44;
      this.right.normalize(); // top

      var topNormal = this.top.normal;
      topNormal.x = m12 - m14;
      topNormal.y = m22 - m24;
      topNormal.z = m32 - m34;
      this.top.distance = m42 - m44;
      this.top.normalize(); // bottom

      var bottomNormal = this.bottom.normal;
      bottomNormal.x = -m14 - m12;
      bottomNormal.y = -m24 - m22;
      bottomNormal.z = -m34 - m32;
      this.bottom.distance = -m44 - m42;
      this.bottom.normalize();
    }
    /**
     * Get whether or not a specified bounding box intersects with this frustum (Contains or Intersects).
     * @param box - The box for testing
     * @returns True if bounding box intersects with this frustum, false otherwise
     */
    ;

    _proto.intersectsBox = function intersectsBox(box) {
      return CollisionUtil.intersectsFrustumAndBox(this, box);
    }
    /**
     * Get whether or not a specified bounding sphere intersects with this frustum (Contains or Intersects).
     * @param sphere - The sphere for testing
     * @returns True if bounding sphere intersects with this frustum, false otherwise
     */
    ;

    _proto.intersectsSphere = function intersectsSphere(sphere) {
      return CollisionUtil.frustumContainsSphere(this, sphere) !== exports.ContainmentType.Disjoint;
    };

    return BoundingFrustum;
  }();
  /**
   * Represents a 3x3 mathematical matrix.
   */


  var Matrix3x3 = /*#__PURE__*/function () {
    /**
     * Determines the sum of two matrices.
     * @param left - The first matrix to add
     * @param right - The second matrix to add
     * @param out - The sum of two matrices
     */
    Matrix3x3.add = function add(left, right, out) {
      var le = left.elements;
      var re = right.elements;
      var oe = out.elements;
      oe[0] = le[0] + re[0];
      oe[1] = le[1] + re[1];
      oe[2] = le[2] + re[2];
      oe[3] = le[3] + re[3];
      oe[4] = le[4] + re[4];
      oe[5] = le[5] + re[5];
      oe[6] = le[6] + re[6];
      oe[7] = le[7] + re[7];
      oe[8] = le[8] + re[8];
    }
    /**
     * Determines the difference between two matrices.
     * @param left - The first matrix to subtract
     * @param right - The second matrix to subtract
     * @param out - The difference between two matrices
     */
    ;

    Matrix3x3.subtract = function subtract(left, right, out) {
      var le = left.elements;
      var re = right.elements;
      var oe = out.elements;
      oe[0] = le[0] - re[0];
      oe[1] = le[1] - re[1];
      oe[2] = le[2] - re[2];
      oe[3] = le[3] - re[3];
      oe[4] = le[4] - re[4];
      oe[5] = le[5] - re[5];
      oe[6] = le[6] - re[6];
      oe[7] = le[7] - re[7];
      oe[8] = le[8] - re[8];
    }
    /**
     * Determines the product of two matrices.
     * @param left - The first matrix to multiply
     * @param right - The second matrix to multiply
     * @param out - The product of two matrices
     */
    ;

    Matrix3x3.multiply = function multiply(left, right, out) {
      var le = left.elements;
      var re = right.elements;
      var oe = out.elements;
      var l11 = le[0],
          l12 = le[1],
          l13 = le[2];
      var l21 = le[3],
          l22 = le[4],
          l23 = le[5];
      var l31 = le[6],
          l32 = le[7],
          l33 = le[8];
      var r11 = re[0],
          r12 = re[1],
          r13 = re[2];
      var r21 = re[3],
          r22 = re[4],
          r23 = re[5];
      var r31 = re[6],
          r32 = re[7],
          r33 = re[8];
      oe[0] = l11 * r11 + l21 * r12 + l31 * r13;
      oe[1] = l12 * r11 + l22 * r12 + l32 * r13;
      oe[2] = l13 * r11 + l23 * r12 + l33 * r13;
      oe[3] = l11 * r21 + l21 * r22 + l31 * r23;
      oe[4] = l12 * r21 + l22 * r22 + l32 * r23;
      oe[5] = l13 * r21 + l23 * r22 + l33 * r23;
      oe[6] = l11 * r31 + l21 * r32 + l31 * r33;
      oe[7] = l12 * r31 + l22 * r32 + l32 * r33;
      oe[8] = l13 * r31 + l23 * r32 + l33 * r33;
    }
    /**
     * Determines whether the specified matrices are equals.
     * @param left - The first matrix to compare
     * @param right - The second matrix to compare
     * @returns True if the specified matrices are equals, false otherwise
     */
    ;

    Matrix3x3.equals = function equals(left, right) {
      var le = left.elements;
      var re = right.elements;
      return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]);
    }
    /**
     * Performs a linear interpolation between two matrices.
     * @param start - The first matrix
     * @param end - The second matrix
     * @param t - The blend amount where 0 returns start and 1 end
     * @param out - The result of linear blending between two matrices
     */
    ;

    Matrix3x3.lerp = function lerp(start, end, t, out) {
      var se = start.elements;
      var ee = end.elements;
      var oe = out.elements;
      var inv = 1.0 - t;
      oe[0] = se[0] * inv + ee[0] * t;
      oe[1] = se[1] * inv + ee[1] * t;
      oe[2] = se[2] * inv + ee[2] * t;
      oe[3] = se[3] * inv + ee[3] * t;
      oe[4] = se[4] * inv + ee[4] * t;
      oe[5] = se[5] * inv + ee[5] * t;
      oe[6] = se[6] * inv + ee[6] * t;
      oe[7] = se[7] * inv + ee[7] * t;
      oe[8] = se[8] * inv + ee[8] * t;
    }
    /**
     * Calculate a rotation matrix from a quaternion.
     * @param quaternion - The quaternion used to calculate the matrix
     * @param out - The calculated rotation matrix
     */
    ;

    Matrix3x3.rotationQuaternion = function rotationQuaternion(quaternion, out) {
      var oe = out.elements;
      var x = quaternion.x,
          y = quaternion.y,
          z = quaternion.z,
          w = quaternion.w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var yx = y * x2;
      var yy = y * y2;
      var zx = z * x2;
      var zy = z * y2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      oe[0] = 1 - yy - zz;
      oe[3] = yx - wz;
      oe[6] = zx + wy;
      oe[1] = yx + wz;
      oe[4] = 1 - xx - zz;
      oe[7] = zy - wx;
      oe[2] = zx - wy;
      oe[5] = zy + wx;
      oe[8] = 1 - xx - yy;
    }
    /**
     * Calculate a matrix from scale vector.
     * @param s - The scale vector
     * @param out - The calculated matrix
     */
    ;

    Matrix3x3.scaling = function scaling(s, out) {
      var oe = out.elements;
      oe[0] = s.x;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = s.y;
      oe[5] = 0;
      oe[6] = 0;
      oe[7] = 0;
      oe[8] = 1;
    }
    /**
     * Calculate a matrix from translation vector.
     * @param translation - The translation vector
     * @param out - The calculated matrix
     */
    ;

    Matrix3x3.translation = function translation(_translation, out) {
      var oe = out.elements;
      oe[0] = 1;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = 1;
      oe[5] = 0;
      oe[6] = _translation.x;
      oe[7] = _translation.y;
      oe[8] = 1;
    }
    /**
     * Calculate the inverse of the specified matrix.
     * @param a - The matrix whose inverse is to be calculated
     * @param out - The inverse of the specified matrix
     */
    ;

    Matrix3x3.invert = function invert(a, out) {
      var ae = a.elements;
      var oe = out.elements;
      var a11 = ae[0],
          a12 = ae[1],
          a13 = ae[2];
      var a21 = ae[3],
          a22 = ae[4],
          a23 = ae[5];
      var a31 = ae[6],
          a32 = ae[7],
          a33 = ae[8];
      var b12 = a33 * a22 - a23 * a32;
      var b22 = -a33 * a21 + a23 * a31;
      var b32 = a32 * a21 - a22 * a31;
      var det = a11 * b12 + a12 * b22 + a13 * b32;

      if (!det) {
        return;
      }

      det = 1.0 / det;
      oe[0] = b12 * det;
      oe[1] = (-a33 * a12 + a13 * a32) * det;
      oe[2] = (a23 * a12 - a13 * a22) * det;
      oe[3] = b22 * det;
      oe[4] = (a33 * a11 - a13 * a31) * det;
      oe[5] = (-a23 * a11 + a13 * a21) * det;
      oe[6] = b32 * det;
      oe[7] = (-a32 * a11 + a12 * a31) * det;
      oe[8] = (a22 * a11 - a12 * a21) * det;
    }
    /**
     * Calculate a 3x3 normal matrix from a 4x4 matrix.
     * @remarks The calculation process is the transpose matrix of the inverse matrix.
     * @param mat4 - The 4x4 matrix
     * @param out - THe 3x3 normal matrix
     */
    ;

    Matrix3x3.normalMatrix = function normalMatrix(mat4, out) {
      var ae = mat4.elements;
      var oe = out.elements;
      var a11 = ae[0],
          a12 = ae[1],
          a13 = ae[2],
          a14 = ae[3];
      var a21 = ae[4],
          a22 = ae[5],
          a23 = ae[6],
          a24 = ae[7];
      var a31 = ae[8],
          a32 = ae[9],
          a33 = ae[10],
          a34 = ae[11];
      var a41 = ae[12],
          a42 = ae[13],
          a43 = ae[14],
          a44 = ae[15];
      var b00 = a11 * a22 - a12 * a21;
      var b01 = a11 * a23 - a13 * a21;
      var b02 = a11 * a24 - a14 * a21;
      var b03 = a12 * a23 - a13 * a22;
      var b04 = a12 * a24 - a14 * a22;
      var b05 = a13 * a24 - a14 * a23;
      var b06 = a31 * a42 - a32 * a41;
      var b07 = a31 * a43 - a33 * a41;
      var b08 = a31 * a44 - a34 * a41;
      var b09 = a32 * a43 - a33 * a42;
      var b10 = a32 * a44 - a34 * a42;
      var b11 = a33 * a44 - a34 * a43;
      var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

      if (!det) {
        return null;
      }

      det = 1.0 / det;
      oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
      oe[1] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
      oe[2] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
      oe[3] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
      oe[4] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
      oe[5] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
      oe[6] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
      oe[7] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
      oe[8] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
    }
    /**
     * The specified matrix rotates around an angle.
     * @param a - The specified matrix
     * @param r - The rotation angle in radians
     * @param out - The rotated matrix
     */
    ;

    Matrix3x3.rotate = function rotate(a, r, out) {
      var ae = a.elements;
      var oe = out.elements;
      var s = Math.sin(r);
      var c = Math.cos(r);
      var a11 = ae[0],
          a12 = ae[1],
          a13 = ae[2];
      var a21 = ae[3],
          a22 = ae[4],
          a23 = ae[5];
      var a31 = ae[6],
          a32 = ae[7],
          a33 = ae[8];
      oe[0] = c * a11 + s * a21;
      oe[1] = c * a12 + s * a22;
      oe[2] = c * a13 + s * a23;
      oe[3] = c * a21 - s * a11;
      oe[4] = c * a22 - s * a12;
      oe[5] = c * a23 - s * a13;
      oe[6] = a31;
      oe[7] = a32;
      oe[8] = a33;
    }
    /**
     * Scale a matrix by a given vector.
     * @param m - The matrix
     * @param s - The given vector
     * @param out - The scaled matrix
     */
    ;

    Matrix3x3.scale = function scale(m, s, out) {
      var x = s.x,
          y = s.y;
      var ae = m.elements;
      var oe = out.elements;
      oe[0] = x * ae[0];
      oe[1] = x * ae[1];
      oe[2] = x * ae[2];
      oe[3] = y * ae[3];
      oe[4] = y * ae[4];
      oe[5] = y * ae[5];
      oe[6] = ae[6];
      oe[7] = ae[7];
      oe[8] = ae[8];
    }
    /**
     * Translate a matrix by a given vector.
     * @param m - The matrix
     * @param translation - The given vector
     * @param out - The translated matrix
     */
    ;

    Matrix3x3.translate = function translate(m, translation, out) {
      var x = translation.x,
          y = translation.y;
      var ae = m.elements;
      var oe = out.elements;
      var a11 = ae[0],
          a12 = ae[1],
          a13 = ae[2];
      var a21 = ae[3],
          a22 = ae[4],
          a23 = ae[5];
      var a31 = ae[6],
          a32 = ae[7],
          a33 = ae[8];
      oe[0] = a11;
      oe[1] = a12;
      oe[2] = a13;
      oe[3] = a21;
      oe[4] = a22;
      oe[5] = a23;
      oe[6] = x * a11 + y * a21 + a31;
      oe[7] = x * a12 + y * a22 + a32;
      oe[8] = x * a13 + y * a23 + a33;
    }
    /**
     * Calculate the transpose of the specified matrix.
     * @param a - The specified matrix
     * @param out - The transpose of the specified matrix
     */
    ;

    Matrix3x3.transpose = function transpose(a, out) {
      var ae = a.elements;
      var oe = out.elements;

      if (out === a) {
        var a12 = ae[1];
        var a13 = ae[2];
        var a23 = ae[5];
        oe[1] = ae[3];
        oe[2] = ae[6];
        oe[3] = a12;
        oe[5] = ae[7];
        oe[6] = a13;
        oe[7] = a23;
      } else {
        oe[0] = ae[0];
        oe[1] = ae[3];
        oe[2] = ae[6];
        oe[3] = ae[1];
        oe[4] = ae[4];
        oe[5] = ae[7];
        oe[6] = ae[2];
        oe[7] = ae[5];
        oe[8] = ae[8];
      }
    }
    /**
     * An array containing the elements of the matrix (column matrix).
     * @remarks
     * elements[0] first column and first row value m11
     * elements[1] first column and second row value m12
     * elements[2] first column and third row value m13
     * elements[3] second column and first row value m21
     * and so on
     */
    ;
    /**
     * Constructor of 3*3 matrix.
     * @param m11 - Default 1 column 1, row 1
     * @param m12 - Default 0 column 1, row 2
     * @param m13 - Default 0 column 1, row 3
     * @param m21 - Default 0 column 2, row 1
     * @param m22 - Default 1 column 2, row 2
     * @param m23 - Default 0 column 2, row 3
     * @param m31 - Default 0 column 3, row 1
     * @param m32 - Default 0 column 3, row 2
     * @param m33 - Default 1 column 3, row 3
     */


    function Matrix3x3(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
      if (m11 === void 0) {
        m11 = 1;
      }

      if (m12 === void 0) {
        m12 = 0;
      }

      if (m13 === void 0) {
        m13 = 0;
      }

      if (m21 === void 0) {
        m21 = 0;
      }

      if (m22 === void 0) {
        m22 = 1;
      }

      if (m23 === void 0) {
        m23 = 0;
      }

      if (m31 === void 0) {
        m31 = 0;
      }

      if (m32 === void 0) {
        m32 = 0;
      }

      if (m33 === void 0) {
        m33 = 1;
      }

      this.elements = new Float32Array(9);
      var e = this.elements;
      e[0] = m11;
      e[1] = m12;
      e[2] = m13;
      e[3] = m21;
      e[4] = m22;
      e[5] = m23;
      e[6] = m31;
      e[7] = m32;
      e[8] = m33;
    }
    /**
     * Set the value of this matrix, and return this matrix.
     * @param m11
     * @param m12
     * @param m13
     * @param m21
     * @param m22
     * @param m23
     * @param m31
     * @param m32
     * @param m33
     * @returns This matrix
     */


    var _proto = Matrix3x3.prototype;

    _proto.setValue = function setValue(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
      var e = this.elements;
      e[0] = m11;
      e[1] = m12;
      e[2] = m13;
      e[3] = m21;
      e[4] = m22;
      e[5] = m23;
      e[6] = m31;
      e[7] = m32;
      e[8] = m33;
      return this;
    }
    /**
     * Set the value of this matrix by an array.
     * @param array - The array
     * @param offset - The start offset of the array
     * @returns This matrix
     */
    ;

    _proto.setValueByArray = function setValueByArray(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }

      var srce = this.elements;

      for (var i = 0; i < 12; i++) {
        srce[i] = array[i + offset];
      }

      return this;
    }
    /**
     * Set the value of this 3x3 matrix by the specified 4x4 matrix.
     * upper-left principle
     * @param a - The specified 4x4 matrix
     * @returns This 3x3 matrix
     */
    ;

    _proto.setValueByMatrix = function setValueByMatrix(a) {
      var ae = a.elements;
      var e = this.elements;
      e[0] = ae[0];
      e[1] = ae[1];
      e[2] = ae[2];
      e[3] = ae[4];
      e[4] = ae[5];
      e[5] = ae[6];
      e[6] = ae[8];
      e[7] = ae[9];
      e[8] = ae[10];
      return this;
    }
    /**
     * Clone the value of this matrix to an array.
     * @param out - The array
     * @param outOffset - The start offset of the array
     */
    ;

    _proto.toArray = function toArray(out, outOffset) {
      if (outOffset === void 0) {
        outOffset = 0;
      }

      var e = this.elements;
      out[outOffset] = e[0];
      out[outOffset + 1] = e[1];
      out[outOffset + 2] = e[2];
      out[outOffset + 3] = e[3];
      out[outOffset + 4] = e[4];
      out[outOffset + 5] = e[5];
      out[outOffset + 6] = e[6];
      out[outOffset + 7] = e[7];
      out[outOffset + 8] = e[8];
    }
    /**
     * Creates a clone of this matrix.
     * @returns A clone of this matrix
     */
    ;

    _proto.clone = function clone() {
      var e = this.elements;
      var ret = new Matrix3x3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
      return ret;
    }
    /**
     * Clones this matrix to the specified matrix.
     * @param out - The specified matrix
     * @returns The specified matrix
     */
    ;

    _proto.cloneTo = function cloneTo(out) {
      var e = this.elements;
      var oe = out.elements;
      oe[0] = e[0];
      oe[1] = e[1];
      oe[2] = e[2];
      oe[3] = e[3];
      oe[4] = e[4];
      oe[5] = e[5];
      oe[6] = e[6];
      oe[7] = e[7];
      oe[8] = e[8];
      return out;
    }
    /**
     * Determines the sum of this matrix and the specified matrix.
     * @param right - The specified matrix
     * @returns This matrix that store the sum of the two matrices
     */
    ;

    _proto.add = function add(right) {
      Matrix3x3.add(this, right, this);
      return this;
    }
    /**
     * Determines the difference between this matrix and the specified matrix.
     * @param right - The specified matrix
     * @returns This matrix that store the difference between the two matrices
     */
    ;

    _proto.subtract = function subtract(right) {
      Matrix3x3.subtract(this, right, this);
      return this;
    }
    /**
     * Determines the product of this matrix and the specified matrix.
     * @param right - The specified matrix
     * @returns This matrix that store the product of the two matrices
     */
    ;

    _proto.multiply = function multiply(right) {
      Matrix3x3.multiply(this, right, this);
      return this;
    }
    /**
     * Calculate a determinant of this matrix.
     * @returns The determinant of this matrix
     */
    ;

    _proto.determinant = function determinant() {
      var e = this.elements;
      var a11 = e[0],
          a12 = e[1],
          a13 = e[2];
      var a21 = e[3],
          a22 = e[4],
          a23 = e[5];
      var a31 = e[6],
          a32 = e[7],
          a33 = e[8];
      var b12 = a33 * a22 - a23 * a32;
      var b22 = -a33 * a21 + a23 * a31;
      var b32 = a32 * a21 - a22 * a31;
      return a11 * b12 + a12 * b22 + a13 * b32;
    }
    /**
     * Identity this matrix.
     * @returns This matrix after identity
     */
    ;

    _proto.identity = function identity() {
      var e = this.elements;
      e[0] = 1;
      e[1] = 0;
      e[2] = 0;
      e[3] = 0;
      e[4] = 1;
      e[5] = 0;
      e[6] = 0;
      e[7] = 0;
      e[8] = 1;
      return this;
    }
    /**
     * Invert the matrix.
     * @returns The matrix after invert
     */
    ;

    _proto.invert = function invert() {
      Matrix3x3.invert(this, this);
      return this;
    }
    /**
     * This matrix rotates around an angle.
     * @param r - The rotation angle in radians
     * @returns This matrix after rotate
     */
    ;

    _proto.rotate = function rotate(r) {
      Matrix3x3.rotate(this, r, this);
      return this;
    }
    /**
     * Scale this matrix by a given vector.
     * @param s - The given vector
     * @returns This matrix after scale
     */
    ;

    _proto.scale = function scale(s) {
      Matrix3x3.scale(this, s, this);
      return this;
    }
    /**
     * Translate this matrix by a given vector.
     * @param translation - The given vector
     * @returns This matrix after translate
     */
    ;

    _proto.translate = function translate(translation) {
      Matrix3x3.translate(this, translation, this);
      return this;
    }
    /**
     * Calculate the transpose of this matrix.
     * @returns This matrix after transpose
     */
    ;

    _proto.transpose = function transpose() {
      Matrix3x3.transpose(this, this);
      return this;
    };

    return Matrix3x3;
  }();
  /**
   * Represents a four dimensional mathematical quaternion.
   */


  var Quaternion = /*#__PURE__*/function () {
    /** @internal */

    /** @internal */

    /**
     * Determines the sum of two quaternions.
     * @param left - The first quaternion to add
     * @param right - The second quaternion to add
     * @param out - The sum of two quaternions
     */
    Quaternion.add = function add(left, right, out) {
      out.x = left.x + right.x;
      out.y = left.y + right.y;
      out.z = left.z + right.z;
      out.w = left.w + right.w;
    }
    /**
     * Determines the product of two quaternions.
     * @param left - The first quaternion to multiply
     * @param right - The second quaternion to multiply
     * @param out - The product of two quaternions
     */
    ;

    Quaternion.multiply = function multiply(left, right, out) {
      var ax = left.x,
          ay = left.y,
          az = left.z,
          aw = left.w;
      var bx = right.x,
          by = right.y,
          bz = right.z,
          bw = right.w;
      out.x = ax * bw + aw * bx + ay * bz - az * by;
      out.y = ay * bw + aw * by + az * bx - ax * bz;
      out.z = az * bw + aw * bz + ax * by - ay * bx;
      out.w = aw * bw - ax * bx - ay * by - az * bz;
    }
    /**
     * Calculate quaternion that contains conjugated version of the specified quaternion.
     * @param a - The specified quaternion
     * @param out - The conjugate version of the specified quaternion
     */
    ;

    Quaternion.conjugate = function conjugate(a, out) {
      out.x = -a.x;
      out.y = -a.y;
      out.z = -a.z;
      out.w = a.w;
    }
    /**
     * Determines the dot product of two quaternions.
     * @param left - The first quaternion to dot
     * @param right - The second quaternion to dot
     * @returns The dot product of two quaternions
     */
    ;

    Quaternion.dot = function dot(left, right) {
      return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
    }
    /**
     * Determines whether the specified quaternions are equals.
     * @param left - The first quaternion to compare
     * @param right - The second quaternion to compare
     * @returns True if the specified quaternions are equals, false otherwise
     */
    ;

    Quaternion.equals = function equals(left, right) {
      return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z) && MathUtil.equals(left.w, right.w);
    }
    /**
     * Calculate a quaternion rotates around an arbitrary axis.
     * @param axis - The axis
     * @param rad - The rotation angle in radians
     * @param out - The quaternion after rotate
     */
    ;

    Quaternion.rotationAxisAngle = function rotationAxisAngle(axis, rad, out) {
      var normalAxis = Quaternion._tempVector3;
      Vector3.normalize(axis, normalAxis);
      rad *= 0.5;
      var s = Math.sin(rad);
      out.x = normalAxis.x * s;
      out.y = normalAxis.y * s;
      out.z = normalAxis.z * s;
      out.w = Math.cos(rad);
    }
    /**
     * Calculate a quaternion rotates around x, y, z axis (pitch/yaw/roll).
     * @param x - The radian of rotation around X (pitch)
     * @param y - The radian of rotation around Y (yaw)
     * @param z - The radian of rotation around Z (roll)
     * @param out - The calculated quaternion
     */
    ;

    Quaternion.rotationEuler = function rotationEuler(x, y, z, out) {
      Quaternion.rotationYawPitchRoll(y, x, z, out);
    }
    /**
     * Calculate a quaternion from the specified yaw, pitch and roll angles.
     * @param yaw - Yaw around the y axis in radians
     * @param pitch - Pitch around the x axis in radians
     * @param roll - Roll around the z axis in radians
     * @param out - The calculated quaternion
     */
    ;

    Quaternion.rotationYawPitchRoll = function rotationYawPitchRoll(yaw, pitch, roll, out) {
      var halfRoll = roll * 0.5;
      var halfPitch = pitch * 0.5;
      var halfYaw = yaw * 0.5;
      var sinRoll = Math.sin(halfRoll);
      var cosRoll = Math.cos(halfRoll);
      var sinPitch = Math.sin(halfPitch);
      var cosPitch = Math.cos(halfPitch);
      var sinYaw = Math.sin(halfYaw);
      var cosYaw = Math.cos(halfYaw);
      var cosYawPitch = cosYaw * cosPitch;
      var sinYawPitch = sinYaw * sinPitch;
      out.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
      out.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
      out.z = cosYawPitch * sinRoll - sinYawPitch * cosRoll;
      out.w = cosYawPitch * cosRoll + sinYawPitch * sinRoll;
    }
    /**
     * Calculate a quaternion from the specified 3x3 matrix.
     * @param m - The specified 3x3 matrix
     * @param out - The calculated quaternion
     */
    ;

    Quaternion.rotationMatrix3x3 = function rotationMatrix3x3(m, out) {
      var me = m.elements;
      var m11 = me[0],
          m12 = me[1],
          m13 = me[2];
      var m21 = me[3],
          m22 = me[4],
          m23 = me[5];
      var m31 = me[6],
          m32 = me[7],
          m33 = me[8];
      var scale = m11 + m22 + m33;
      var sqrt, half;

      if (scale > 0) {
        sqrt = Math.sqrt(scale + 1.0);
        out.w = sqrt * 0.5;
        sqrt = 0.5 / sqrt;
        out.x = (m23 - m32) * sqrt;
        out.y = (m31 - m13) * sqrt;
        out.z = (m12 - m21) * sqrt;
      } else if (m11 >= m22 && m11 >= m33) {
        sqrt = Math.sqrt(1.0 + m11 - m22 - m33);
        half = 0.5 / sqrt;
        out.x = 0.5 * sqrt;
        out.y = (m12 + m21) * half;
        out.z = (m13 + m31) * half;
        out.w = (m23 - m32) * half;
      } else if (m22 > m33) {
        sqrt = Math.sqrt(1.0 + m22 - m11 - m33);
        half = 0.5 / sqrt;
        out.x = (m21 + m12) * half;
        out.y = 0.5 * sqrt;
        out.z = (m32 + m23) * half;
        out.w = (m31 - m13) * half;
      } else {
        sqrt = Math.sqrt(1.0 + m33 - m11 - m22);
        half = 0.5 / sqrt;
        out.x = (m13 + m31) * half;
        out.y = (m23 + m32) * half;
        out.z = 0.5 * sqrt;
        out.w = (m12 - m21) * half;
      }
    }
    /**
     * Calculate the inverse of the specified quaternion.
     * @param a - The quaternion whose inverse is to be calculated
     * @param out - The inverse of the specified quaternion
     */
    ;

    Quaternion.invert = function invert(a, out) {
      var x = a.x,
          y = a.y,
          z = a.z,
          w = a.w;
      var dot = x * x + y * y + z * z + w * w;

      if (dot > MathUtil.zeroTolerance) {
        var invDot = 1.0 / dot;
        out.x = -x * invDot;
        out.y = -y * invDot;
        out.z = -z * invDot;
        out.w = w * invDot;
      }
    }
    /**
     * Performs a linear blend between two quaternions.
     * @param start - The first quaternion
     * @param end - The second quaternion
     * @param t - The blend amount where 0 returns start and 1 end
     * @param out - The result of linear blending between two quaternions
     */
    ;

    Quaternion.lerp = function lerp(start, end, t, out) {
      var inv = 1.0 - t;

      if (Quaternion.dot(start, end) >= 0) {
        out.x = start.x * inv + end.x * t;
        out.y = start.y * inv + end.y * t;
        out.z = start.z * inv + end.z * t;
        out.w = start.w * inv + end.w * t;
      } else {
        out.x = start.x * inv - end.x * t;
        out.y = start.y * inv - end.y * t;
        out.z = start.z * inv - end.z * t;
        out.w = start.w * inv - end.w * t;
      }

      out.normalize();
    }
    /**
     * Performs a spherical linear blend between two quaternions.
     * @param start - The first quaternion
     * @param end - The second quaternion
     * @param t - The blend amount where 0 returns start and 1 end
     * @param out - The result of spherical linear blending between two quaternions
     */
    ;

    Quaternion.slerp = function slerp(start, end, t, out) {
      var ax = start.x;
      var ay = start.y;
      var az = start.z;
      var aw = start.w;
      var bx = end.x;
      var by = end.y;
      var bz = end.z;
      var bw = end.w;
      var scale0, scale1; // calc cosine

      var cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

      if (cosom < 0.0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
      } // calculate coefficients


      if (1.0 - cosom > MathUtil.zeroTolerance) {
        // standard case (slerp)
        var omega = Math.acos(cosom);
        var sinom = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
      } else {
        // "from" and "to" quaternions are very close
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
      } // calculate final values


      out.x = scale0 * ax + scale1 * bx;
      out.y = scale0 * ay + scale1 * by;
      out.z = scale0 * az + scale1 * bz;
      out.w = scale0 * aw + scale1 * bw;
    }
    /**
     * Scales the specified quaternion magnitude to unit length.
     * @param a - The specified quaternion
     * @param out - The normalized quaternion
     */
    ;

    Quaternion.normalize = function normalize(a, out) {
      var x = a.x,
          y = a.y,
          z = a.z,
          w = a.w;
      var len = Math.sqrt(x * x + y * y + z * z + w * w);

      if (len > MathUtil.zeroTolerance) {
        len = 1 / len;
        out.x = x * len;
        out.y = y * len;
        out.z = z * len;
        out.w = w * len;
      }
    }
    /**
     * Calculate a quaternion rotate around X axis.
     * @param rad - The rotation angle in radians
     * @param out - The calculated quaternion
     */
    ;

    Quaternion.rotationX = function rotationX(rad, out) {
      rad *= 0.5;
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      out.x = s;
      out.y = 0;
      out.z = 0;
      out.w = c;
    }
    /**
     * Calculate a quaternion rotate around Y axis.
     * @param rad - The rotation angle in radians
     * @param out - The calculated quaternion
     */
    ;

    Quaternion.rotationY = function rotationY(rad, out) {
      rad *= 0.5;
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      out.x = 0;
      out.y = s;
      out.z = 0;
      out.w = c;
    }
    /**
     * Calculate a quaternion rotate around Z axis.
     * @param rad - The rotation angle in radians
     * @param out - The calculated quaternion
     */
    ;

    Quaternion.rotationZ = function rotationZ(rad, out) {
      rad *= 0.5;
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      out.x = 0;
      out.y = 0;
      out.z = s;
      out.w = c;
    }
    /**
     * Calculate a quaternion that the specified quaternion rotate around X axis.
     * @param quaternion - The specified quaternion
     * @param rad - The rotation angle in radians
     * @param out - The calculated quaternion
     */
    ;

    Quaternion.rotateX = function rotateX(quaternion, rad, out) {
      var x = quaternion.x,
          y = quaternion.y,
          z = quaternion.z,
          w = quaternion.w;
      rad *= 0.5;
      var bx = Math.sin(rad);
      var bw = Math.cos(rad);
      out.x = x * bw + w * bx;
      out.y = y * bw + z * bx;
      out.z = z * bw - y * bx;
      out.w = w * bw - x * bx;
    }
    /**
     * Calculate a quaternion that the specified quaternion rotate around Y axis.
     * @param quaternion - The specified quaternion
     * @param rad - The rotation angle in radians
     * @param out - The calculated quaternion
     */
    ;

    Quaternion.rotateY = function rotateY(quaternion, rad, out) {
      var x = quaternion.x,
          y = quaternion.y,
          z = quaternion.z,
          w = quaternion.w;
      rad *= 0.5;
      var by = Math.sin(rad);
      var bw = Math.cos(rad);
      out.x = x * bw - z * by;
      out.y = y * bw + w * by;
      out.z = z * bw + x * by;
      out.w = w * bw - y * by;
    }
    /**
     * Calculate a quaternion that the specified quaternion rotate around Z axis.
     * @param quaternion - The specified quaternion
     * @param rad - The rotation angle in radians
     * @param out - The calculated quaternion
     */
    ;

    Quaternion.rotateZ = function rotateZ(quaternion, rad, out) {
      var x = quaternion.x,
          y = quaternion.y,
          z = quaternion.z,
          w = quaternion.w;
      rad *= 0.5;
      var bz = Math.sin(rad);
      var bw = Math.cos(rad);
      out.x = x * bw + y * bz;
      out.y = y * bw - x * bz;
      out.z = z * bw + w * bz;
      out.w = w * bw - z * bz;
    }
    /**
     * Scale a quaternion by a given number.
     * @param a - The quaternion
     * @param s - The given number
     * @param out - The scaled quaternion
     */
    ;

    Quaternion.scale = function scale(a, s, out) {
      out.x = a.x * s;
      out.y = a.y * s;
      out.z = a.z * s;
      out.w = a.w * s;
    }
    /** The x component of the quaternion. */
    ;
    /**
     * Constructor of Quaternion.
     * @param x - The x component of the quaternion, default 0
     * @param y - The y component of the quaternion, default 0
     * @param z - The z component of the quaternion, default 0
     * @param w - The w component of the quaternion, default 1
     */


    function Quaternion(x, y, z, w) {
      if (x === void 0) {
        x = 0;
      }

      if (y === void 0) {
        y = 0;
      }

      if (z === void 0) {
        z = 0;
      }

      if (w === void 0) {
        w = 1;
      }

      this.x = void 0;
      this.y = void 0;
      this.z = void 0;
      this.w = void 0;
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }
    /**
     * Set the value of this quaternion, and return this quaternion.
     * @param x - The x component of the quaternion
     * @param y - The y component of the quaternion
     * @param z - The z component of the quaternion
     * @param w - The w component of the quaternion
     * @returns This quaternion
     */


    var _proto = Quaternion.prototype;

    _proto.setValue = function setValue(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    }
    /**
     * Set the value of this quaternion by an array.
     * @param array - The array
     * @param offset - The start offset of the array
     * @returns This quaternion
     */
    ;

    _proto.setValueByArray = function setValueByArray(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }

      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    }
    /**
     * Transforms this quaternion into its conjugated version.
     * @returns This quaternion
     */
    ;

    _proto.conjugate = function conjugate() {
      this.x *= -1;
      this.y *= -1;
      this.z *= -1;
      return this;
    }
    /**
     * Get the rotation axis and rotation angle of the quaternion (unit: radians).
     * @param out - The axis as an output parameter
     * @returns The rotation angle (unit: radians)
     */
    ;

    _proto.getAxisAngle = function getAxisAngle(out) {
      var x = this.x,
          y = this.y,
          z = this.z;
      var length = x * x + y * y + z * z;

      if (length < MathUtil.zeroTolerance) {
        out.x = 1;
        out.y = 0;
        out.z = 0;
        return 0;
      } else {
        var inv = 1.0 / length;
        out.x = this.x * inv;
        out.y = this.y * inv;
        out.z = this.z * inv;
        return Math.acos(this.w) * 2.0;
      }
    }
    /**
     * Identity this quaternion.
     * @returns This quaternion after identity
     */
    ;

    _proto.identity = function identity() {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;
      return this;
    }
    /**
     * Calculate the length of this quaternion.
     * @returns The length of this quaternion
     */
    ;

    _proto.length = function length() {
      var x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;
      return Math.sqrt(x * x + y * y + z * z + w * w);
    }
    /**
     * Calculates the squared length of this quaternion.
     * @returns The squared length of this quaternion
     */
    ;

    _proto.lengthSquared = function lengthSquared() {
      var x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;
      return x * x + y * y + z * z + w * w;
    }
    /**
     * Converts this quaternion into a unit quaternion.
     * @returns This quaternion
     */
    ;

    _proto.normalize = function normalize() {
      Quaternion.normalize(this, this);
      return this;
    }
    /**
     * Get the euler of this quaternion.
     * @param out - The euler (in radians) as an output parameter
     * @returns Euler x->pitch y->yaw z->roll
     */
    ;

    _proto.toEuler = function toEuler(out) {
      this.toYawPitchRoll(out);
      var t = out.x;
      out.x = out.y;
      out.y = t;
      return out;
    }
    /**
     * Get the euler of this quaternion.
     * @param out - The euler (in radians) as an output parameter
     * @returns Euler x->yaw y->pitch z->roll
     */
    ;

    _proto.toYawPitchRoll = function toYawPitchRoll(out) {
      var x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;
      var xx = x * x;
      var yy = y * y;
      var zz = z * z;
      var xy = x * y;
      var zw = z * w;
      var zx = z * x;
      var yw = y * w;
      var yz = y * z;
      var xw = x * w;
      out.y = Math.asin(2.0 * (xw - yz));

      if (Math.cos(out.y) > MathUtil.zeroTolerance) {
        out.z = Math.atan2(2.0 * (xy + zw), 1.0 - 2.0 * (zz + xx));
        out.x = Math.atan2(2.0 * (zx + yw), 1.0 - 2.0 * (yy + xx));
      } else {
        out.z = Math.atan2(-2.0 * (xy - zw), 1.0 - 2.0 * (yy + zz));
        out.x = 0.0;
      }

      return out;
    }
    /**
     * Clone the value of this quaternion to an array.
     * @param out - The array
     * @param outOffset - The start offset of the array
     */
    ;

    _proto.toArray = function toArray(out, outOffset) {
      if (outOffset === void 0) {
        outOffset = 0;
      }

      out[outOffset] = this.x;
      out[outOffset + 1] = this.y;
      out[outOffset + 2] = this.z;
      out[outOffset + 3] = this.w;
    }
    /**
     * Creates a clone of this quaternion.
     * @returns A clone of this quaternion
     */
    ;

    _proto.clone = function clone() {
      return new Quaternion(this.x, this.y, this.z, this.w);
    }
    /**
     * Clones this quaternion to the specified quaternion.
     * @param out - The specified quaternion
     * @returns The specified quaternion
     */
    ;

    _proto.cloneTo = function cloneTo(out) {
      out.x = this.x;
      out.y = this.y;
      out.z = this.z;
      out.w = this.w;
      return out;
    }
    /**
     * Calculate this quaternion rotate around X axis.
     * @param rad - The rotation angle in radians
     * @returns This quaternion
     */
    ;

    _proto.rotateX = function rotateX(rad) {
      Quaternion.rotateX(this, rad, this);
      return this;
    }
    /**
     * Calculate this quaternion rotate around Y axis.
     * @param rad - The rotation angle in radians
     * @returns This quaternion
     */
    ;

    _proto.rotateY = function rotateY(rad) {
      Quaternion.rotateY(this, rad, this);
      return this;
    }
    /**
     * Calculate this quaternion rotate around Z axis.
     * @param rad - The rotation angle in radians
     * @returns This quaternion
     */
    ;

    _proto.rotateZ = function rotateZ(rad) {
      Quaternion.rotateZ(this, rad, this);
      return this;
    }
    /**
     * Calculate this quaternion rotates around an arbitrary axis.
     * @param axis - The axis
     * @param rad - The rotation angle in radians
     * @returns This quaternion
     */
    ;

    _proto.rotationAxisAngle = function rotationAxisAngle(axis, rad) {
      Quaternion.rotationAxisAngle(axis, rad, this);
      return this;
    }
    /**
     * Determines the product of this quaternion and the specified quaternion.
     * @param quat - The specified quaternion
     * @returns The product of the two quaternions
     */
    ;

    _proto.multiply = function multiply(quat) {
      Quaternion.multiply(this, quat, this);
      return this;
    }
    /**
     * Invert this quaternion.
     * @returns This quaternion after invert
     */
    ;

    _proto.invert = function invert() {
      Quaternion.invert(this, this);
      return this;
    }
    /**
     * Determines the dot product of this quaternion and the specified quaternion.
     * @param quat - The specified quaternion
     * @returns The dot product of two quaternions
     */
    ;

    _proto.dot = function dot(quat) {
      return Quaternion.dot(this, quat);
    }
    /**
     * Performs a linear blend between this quaternion and the specified quaternion.
     * @param quat - The specified quaternion
     * @param t - The blend amount where 0 returns this and 1 quat
     * @returns - The result of linear blending between two quaternions
     */
    ;

    _proto.lerp = function lerp(quat, t) {
      Quaternion.lerp(this, quat, t, this);
      return this;
    }
    /**
     * Calculate this quaternion rotation around an arbitrary axis.
     * @param axis - The axis
     * @param rad - The rotation angle in radians
     * @returns This quaternion
     */
    ;

    _proto.rotateAxisAngle = function rotateAxisAngle(axis, rad) {
      Quaternion._tempQuat1.rotationAxisAngle(axis, rad);

      this.multiply(Quaternion._tempQuat1);
      return this;
    };

    return Quaternion;
  }();

  Quaternion._tempVector3 = new Vector3();
  Quaternion._tempQuat1 = new Quaternion();
  /**
   * Represents a 4x4 mathematical matrix.
   */

  var Matrix = /*#__PURE__*/function () {
    /** @internal Identity matrix. */

    /**
     * Determines the product of two matrices.
     * @param left - The first matrix to multiply
     * @param right - The second matrix to multiply
     * @param out - The product of the two matrices
     */
    Matrix.multiply = function multiply(left, right, out) {
      var le = left.elements;
      var re = right.elements;
      var oe = out.elements;
      var l11 = le[0],
          l12 = le[1],
          l13 = le[2],
          l14 = le[3];
      var l21 = le[4],
          l22 = le[5],
          l23 = le[6],
          l24 = le[7];
      var l31 = le[8],
          l32 = le[9],
          l33 = le[10],
          l34 = le[11];
      var l41 = le[12],
          l42 = le[13],
          l43 = le[14],
          l44 = le[15];
      var r11 = re[0],
          r12 = re[1],
          r13 = re[2],
          r14 = re[3];
      var r21 = re[4],
          r22 = re[5],
          r23 = re[6],
          r24 = re[7];
      var r31 = re[8],
          r32 = re[9],
          r33 = re[10],
          r34 = re[11];
      var r41 = re[12],
          r42 = re[13],
          r43 = re[14],
          r44 = re[15];
      oe[0] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;
      oe[1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;
      oe[2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;
      oe[3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;
      oe[4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;
      oe[5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;
      oe[6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;
      oe[7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;
      oe[8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;
      oe[9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;
      oe[10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;
      oe[11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;
      oe[12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;
      oe[13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;
      oe[14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;
      oe[15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;
    }
    /**
     * Determines whether the specified matrices are equals.
     * @param left - The first matrix to compare
     * @param right - The second matrix to compare
     * @returns True if the specified matrices are equals, false otherwise
     */
    ;

    Matrix.equals = function equals(left, right) {
      var le = left.elements;
      var re = right.elements;
      return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]) && MathUtil.equals(le[9], re[9]) && MathUtil.equals(le[10], re[10]) && MathUtil.equals(le[11], re[11]) && MathUtil.equals(le[12], re[12]) && MathUtil.equals(le[13], re[13]) && MathUtil.equals(le[14], re[14]) && MathUtil.equals(le[15], re[15]);
    }
    /**
     * Performs a linear interpolation between two matrices.
     * @param start - The first matrix
     * @param end - The second matrix
     * @param t - The blend amount where 0 returns start and 1 end
     * @param out - The result of linear blending between two matrices
     */
    ;

    Matrix.lerp = function lerp(start, end, t, out) {
      var se = start.elements;
      var ee = end.elements;
      var oe = out.elements;
      var inv = 1.0 - t;
      oe[0] = se[0] * inv + ee[0] * t;
      oe[1] = se[1] * inv + ee[1] * t;
      oe[2] = se[2] * inv + ee[2] * t;
      oe[3] = se[3] * inv + ee[3] * t;
      oe[4] = se[4] * inv + ee[4] * t;
      oe[5] = se[5] * inv + ee[5] * t;
      oe[6] = se[6] * inv + ee[6] * t;
      oe[7] = se[7] * inv + ee[7] * t;
      oe[8] = se[8] * inv + ee[8] * t;
      oe[9] = se[9] * inv + ee[9] * t;
      oe[10] = se[10] * inv + ee[10] * t;
      oe[11] = se[11] * inv + ee[11] * t;
      oe[12] = se[12] * inv + ee[12] * t;
      oe[13] = se[13] * inv + ee[13] * t;
      oe[14] = se[14] * inv + ee[14] * t;
      oe[15] = se[15] * inv + ee[15] * t;
    }
    /**
     * Calculate a rotation matrix from a quaternion.
     * @param quaternion - The quaternion used to calculate the matrix
     * @param out - The calculated rotation matrix
     */
    ;

    Matrix.rotationQuaternion = function rotationQuaternion(quaternion, out) {
      var oe = out.elements;
      var x = quaternion.x,
          y = quaternion.y,
          z = quaternion.z,
          w = quaternion.w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var yx = y * x2;
      var yy = y * y2;
      var zx = z * x2;
      var zy = z * y2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      oe[0] = 1 - yy - zz;
      oe[1] = yx + wz;
      oe[2] = zx - wy;
      oe[3] = 0;
      oe[4] = yx - wz;
      oe[5] = 1 - xx - zz;
      oe[6] = zy + wx;
      oe[7] = 0;
      oe[8] = zx + wy;
      oe[9] = zy - wx;
      oe[10] = 1 - xx - yy;
      oe[11] = 0;
      oe[12] = 0;
      oe[13] = 0;
      oe[14] = 0;
      oe[15] = 1;
    }
    /**
     * Calculate a matrix rotates around an arbitrary axis.
     * @param axis - The axis
     * @param r - The rotation angle in radians
     * @param out - The matrix after rotate
     */
    ;

    Matrix.rotationAxisAngle = function rotationAxisAngle(axis, r, out) {
      var oe = out.elements;
      var x = axis.x,
          y = axis.y,
          z = axis.z;
      var len = Math.sqrt(x * x + y * y + z * z);
      var s, c, t;

      if (Math.abs(len) < MathUtil.zeroTolerance) {
        return;
      }

      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
      s = Math.sin(r);
      c = Math.cos(r);
      t = 1 - c; // Perform rotation-specific matrix multiplication

      oe[0] = x * x * t + c;
      oe[1] = y * x * t + z * s;
      oe[2] = z * x * t - y * s;
      oe[3] = 0;
      oe[4] = x * y * t - z * s;
      oe[5] = y * y * t + c;
      oe[6] = z * y * t + x * s;
      oe[7] = 0;
      oe[8] = x * z * t + y * s;
      oe[9] = y * z * t - x * s;
      oe[10] = z * z * t + c;
      oe[11] = 0;
      oe[12] = 0;
      oe[13] = 0;
      oe[14] = 0;
      oe[15] = 1;
    }
    /**
     * Calculate a matrix from a quaternion and a translation.
     * @param quaternion - The quaternion used to calculate the matrix
     * @param translation - The translation used to calculate the matrix
     * @param out - The calculated matrix
     */
    ;

    Matrix.rotationTranslation = function rotationTranslation(quaternion, translation, out) {
      Matrix.rotationQuaternion(quaternion, out);
      var oe = out.elements;
      oe[12] = translation.x;
      oe[13] = translation.y;
      oe[14] = translation.z;
    }
    /**
     * Calculate an affine matrix.
     * @param scale - The scale used to calculate matrix
     * @param rotation - The rotation used to calculate matrix
     * @param translation - The translation used to calculate matrix
     * @param out - The calculated matrix
     */
    ;

    Matrix.affineTransformation = function affineTransformation(scale, rotation, translation, out) {
      var oe = out.elements;
      var x = rotation.x,
          y = rotation.y,
          z = rotation.z,
          w = rotation.w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var xy = x * y2;
      var xz = x * z2;
      var yy = y * y2;
      var yz = y * z2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      var sx = scale.x;
      var sy = scale.y;
      var sz = scale.z;
      oe[0] = (1 - (yy + zz)) * sx;
      oe[1] = (xy + wz) * sx;
      oe[2] = (xz - wy) * sx;
      oe[3] = 0;
      oe[4] = (xy - wz) * sy;
      oe[5] = (1 - (xx + zz)) * sy;
      oe[6] = (yz + wx) * sy;
      oe[7] = 0;
      oe[8] = (xz + wy) * sz;
      oe[9] = (yz - wx) * sz;
      oe[10] = (1 - (xx + yy)) * sz;
      oe[11] = 0;
      oe[12] = translation.x;
      oe[13] = translation.y;
      oe[14] = translation.z;
      oe[15] = 1;
    }
    /**
     * Calculate a matrix from scale vector.
     * @param s - The scale vector
     * @param out - The calculated matrix
     */
    ;

    Matrix.scaling = function scaling(s, out) {
      var oe = out.elements;
      oe[0] = s.x;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = 0;
      oe[5] = s.y;
      oe[6] = 0;
      oe[7] = 0;
      oe[8] = 0;
      oe[9] = 0;
      oe[10] = s.z;
      oe[11] = 0;
      oe[12] = 0;
      oe[13] = 0;
      oe[14] = 0;
      oe[15] = 1;
    }
    /**
     * Calculate a matrix from translation vector.
     * @param translation - The translation vector
     * @param out - The calculated matrix
     */
    ;

    Matrix.translation = function translation(_translation, out) {
      var oe = out.elements;
      oe[0] = 1;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = 0;
      oe[5] = 1;
      oe[6] = 0;
      oe[7] = 0;
      oe[8] = 0;
      oe[9] = 0;
      oe[10] = 1;
      oe[11] = 0;
      oe[12] = _translation.x;
      oe[13] = _translation.y;
      oe[14] = _translation.z;
      oe[15] = 1;
    }
    /**
     * Calculate the inverse of the specified matrix.
     * @param a - The matrix whose inverse is to be calculated
     * @param out - The inverse of the specified matrix
     */
    ;

    Matrix.invert = function invert(a, out) {
      var ae = a.elements;
      var oe = out.elements;
      var a11 = ae[0],
          a12 = ae[1],
          a13 = ae[2],
          a14 = ae[3];
      var a21 = ae[4],
          a22 = ae[5],
          a23 = ae[6],
          a24 = ae[7];
      var a31 = ae[8],
          a32 = ae[9],
          a33 = ae[10],
          a34 = ae[11];
      var a41 = ae[12],
          a42 = ae[13],
          a43 = ae[14],
          a44 = ae[15];
      var b00 = a11 * a22 - a12 * a21;
      var b01 = a11 * a23 - a13 * a21;
      var b02 = a11 * a24 - a14 * a21;
      var b03 = a12 * a23 - a13 * a22;
      var b04 = a12 * a24 - a14 * a22;
      var b05 = a13 * a24 - a14 * a23;
      var b06 = a31 * a42 - a32 * a41;
      var b07 = a31 * a43 - a33 * a41;
      var b08 = a31 * a44 - a34 * a41;
      var b09 = a32 * a43 - a33 * a42;
      var b10 = a32 * a44 - a34 * a42;
      var b11 = a33 * a44 - a34 * a43;
      var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

      if (!det) {
        return null;
      }

      det = 1.0 / det;
      oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
      oe[1] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
      oe[2] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
      oe[3] = (a33 * b04 - a32 * b05 - a34 * b03) * det;
      oe[4] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
      oe[5] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
      oe[6] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
      oe[7] = (a31 * b05 - a33 * b02 + a34 * b01) * det;
      oe[8] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
      oe[9] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
      oe[10] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
      oe[11] = (a32 * b02 - a31 * b04 - a34 * b00) * det;
      oe[12] = (a22 * b07 - a21 * b09 - a23 * b06) * det;
      oe[13] = (a11 * b09 - a12 * b07 + a13 * b06) * det;
      oe[14] = (a42 * b01 - a41 * b03 - a43 * b00) * det;
      oe[15] = (a31 * b03 - a32 * b01 + a33 * b00) * det;
    }
    /**
     * Calculate a right-handed look-at matrix.
     * @param eye - The position of the viewer's eye
     * @param target - The camera look-at target
     * @param up - The camera's up vector
     * @param out - The calculated look-at matrix
     */
    ;

    Matrix.lookAt = function lookAt(eye, target, up, out) {
      var oe = out.elements;
      var xAxis = Matrix._tempVec30;
      var yAxis = Matrix._tempVec31;
      var zAxis = Matrix._tempVec32;
      Vector3.subtract(eye, target, zAxis);
      zAxis.normalize();
      Vector3.cross(up, zAxis, xAxis);
      xAxis.normalize();
      Vector3.cross(zAxis, xAxis, yAxis);
      oe[0] = xAxis.x;
      oe[1] = yAxis.x;
      oe[2] = zAxis.x;
      oe[3] = 0;
      oe[4] = xAxis.y;
      oe[5] = yAxis.y;
      oe[6] = zAxis.y;
      oe[7] = 0;
      oe[8] = xAxis.z;
      oe[9] = yAxis.z;
      oe[10] = zAxis.z;
      oe[11] = 0;
      oe[12] = -Vector3.dot(xAxis, eye);
      oe[13] = -Vector3.dot(yAxis, eye);
      oe[14] = -Vector3.dot(zAxis, eye);
      oe[15] = 1;
    }
    /**
     * Calculate an orthographic projection matrix.
     * @param left - The left edge of the viewing
     * @param right - The right edge of the viewing
     * @param bottom - The bottom edge of the viewing
     * @param top - The top edge of the viewing
     * @param near - The depth of the near plane
     * @param far - The depth of the far plane
     * @param out - The calculated orthographic projection matrix
     */
    ;

    Matrix.ortho = function ortho(left, right, bottom, top, near, far, out) {
      var oe = out.elements;
      var lr = 1 / (left - right);
      var bt = 1 / (bottom - top);
      var nf = 1 / (near - far);
      oe[0] = -2 * lr;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = 0;
      oe[5] = -2 * bt;
      oe[6] = 0;
      oe[7] = 0;
      oe[8] = 0;
      oe[9] = 0;
      oe[10] = 2 * nf;
      oe[11] = 0;
      oe[12] = (left + right) * lr;
      oe[13] = (top + bottom) * bt;
      oe[14] = (far + near) * nf;
      oe[15] = 1;
    }
    /**
     * Calculate a perspective projection matrix.
     * @param fovy - Field of view in the y direction, in radians
     * @param aspect - Aspect ratio, defined as view space width divided by height
     * @param near - The depth of the near plane
     * @param far - The depth of the far plane
     * @param out - The calculated perspective projection matrix
     */
    ;

    Matrix.perspective = function perspective(fovy, aspect, near, far, out) {
      var oe = out.elements;
      var f = 1.0 / Math.tan(fovy / 2);
      var nf = 1 / (near - far);
      oe[0] = f / aspect;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = 0;
      oe[5] = f;
      oe[6] = 0;
      oe[7] = 0;
      oe[8] = 0;
      oe[9] = 0;
      oe[10] = (far + near) * nf;
      oe[11] = -1;
      oe[12] = 0;
      oe[13] = 0;
      oe[14] = 2 * far * near * nf;
      oe[15] = 0;
    }
    /**
     * The specified matrix rotates around an arbitrary axis.
     * @param m - The specified matrix
     * @param axis - The axis
     * @param r - The rotation angle in radians
     * @param out - The rotated matrix
     */
    ;

    Matrix.rotateAxisAngle = function rotateAxisAngle(m, axis, r, out) {
      var x = axis.x,
          y = axis.y,
          z = axis.z;
      var len = Math.sqrt(x * x + y * y + z * z);

      if (Math.abs(len) < MathUtil.zeroTolerance) {
        return;
      }

      var me = m.elements;
      var oe = out.elements;
      var s, c, t;
      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
      s = Math.sin(r);
      c = Math.cos(r);
      t = 1 - c;
      var a11 = me[0],
          a12 = me[1],
          a13 = me[2],
          a14 = me[3];
      var a21 = me[4],
          a22 = me[5],
          a23 = me[6],
          a24 = me[7];
      var a31 = me[8],
          a32 = me[9],
          a33 = me[10],
          a34 = me[11]; // Construct the elements of the rotation matrix

      var b11 = x * x * t + c;
      var b12 = y * x * t + z * s;
      var b13 = z * x * t - y * s;
      var b21 = x * y * t - z * s;
      var b22 = y * y * t + c;
      var b23 = z * y * t + x * s;
      var b31 = x * z * t + y * s;
      var b32 = y * z * t - x * s;
      var b33 = z * z * t + c; // Perform rotation-specific matrix multiplication

      oe[0] = a11 * b11 + a21 * b12 + a31 * b13;
      oe[1] = a12 * b11 + a22 * b12 + a32 * b13;
      oe[2] = a13 * b11 + a23 * b12 + a33 * b13;
      oe[3] = a14 * b11 + a24 * b12 + a34 * b13;
      oe[4] = a11 * b21 + a21 * b22 + a31 * b23;
      oe[5] = a12 * b21 + a22 * b22 + a32 * b23;
      oe[6] = a13 * b21 + a23 * b22 + a33 * b23;
      oe[7] = a14 * b21 + a24 * b22 + a34 * b23;
      oe[8] = a11 * b31 + a21 * b32 + a31 * b33;
      oe[9] = a12 * b31 + a22 * b32 + a32 * b33;
      oe[10] = a13 * b31 + a23 * b32 + a33 * b33;
      oe[11] = a14 * b31 + a24 * b32 + a34 * b33;

      if (m !== out) {
        // If the source and destination differ, copy the unchanged last row
        oe[12] = me[12];
        oe[13] = me[13];
        oe[14] = me[14];
        oe[15] = me[15];
      }
    }
    /**
     * Scale a matrix by a given vector.
     * @param m - The matrix
     * @param s - The given vector
     * @param out - The scaled matrix
     */
    ;

    Matrix.scale = function scale(m, s, out) {
      var me = m.elements;
      var oe = out.elements;
      var x = s.x,
          y = s.y,
          z = s.z;
      oe[0] = me[0] * x;
      oe[1] = me[1] * x;
      oe[2] = me[2] * x;
      oe[3] = me[3] * x;
      oe[4] = me[4] * y;
      oe[5] = me[5] * y;
      oe[6] = me[6] * y;
      oe[7] = me[7] * y;
      oe[8] = me[8] * z;
      oe[9] = me[9] * z;
      oe[10] = me[10] * z;
      oe[11] = me[11] * z;
      oe[12] = me[12];
      oe[13] = me[13];
      oe[14] = me[14];
      oe[15] = me[15];
    }
    /**
     * Translate a matrix by a given vector.
     * @param m - The matrix
     * @param v - The given vector
     * @param out - The translated matrix
     */
    ;

    Matrix.translate = function translate(m, v, out) {
      var me = m.elements;
      var oe = out.elements;
      var x = v.x,
          y = v.y,
          z = v.z;

      if (m === out) {
        oe[12] = me[0] * x + me[4] * y + me[8] * z + me[12];
        oe[13] = me[1] * x + me[5] * y + me[9] * z + me[13];
        oe[14] = me[2] * x + me[6] * y + me[10] * z + me[14];
        oe[15] = me[3] * x + me[7] * y + me[11] * z + me[15];
      } else {
        var a11 = me[0],
            a12 = me[1],
            a13 = me[2],
            a14 = me[3];
        var a21 = me[4],
            a22 = me[5],
            a23 = me[6],
            a24 = me[7];
        var a31 = me[8],
            a32 = me[9],
            a33 = me[10],
            a34 = me[11];
        oe[0] = a11, oe[1] = a12, oe[2] = a13, oe[3] = a14;
        oe[4] = a21, oe[5] = a22, oe[6] = a23, oe[7] = a24;
        oe[8] = a31, oe[9] = a32, oe[10] = a33, oe[11] = a34;
        oe[12] = a11 * x + a21 * y + a31 * z + me[12];
        oe[13] = a12 * x + a22 * y + a32 * z + me[13];
        oe[14] = a13 * x + a23 * y + a33 * z + me[14];
        oe[15] = a14 * x + a24 * y + a34 * z + me[15];
      }
    }
    /**
     * Calculate the transpose of the specified matrix.
     * @param a - The specified matrix
     * @param out - The transpose of the specified matrix
     */
    ;

    Matrix.transpose = function transpose(a, out) {
      var ae = a.elements;
      var oe = out.elements;

      if (out === a) {
        var a12 = ae[1];
        var a13 = ae[2];
        var a14 = ae[3];
        var a23 = ae[6];
        var a24 = ae[7];
        var a34 = ae[11];
        oe[1] = ae[4];
        oe[2] = ae[8];
        oe[3] = ae[12];
        oe[4] = a12;
        oe[6] = ae[9];
        oe[7] = ae[13];
        oe[8] = a13;
        oe[9] = a23;
        oe[11] = ae[14];
        oe[12] = a14;
        oe[13] = a24;
        oe[14] = a34;
      } else {
        oe[0] = ae[0];
        oe[1] = ae[4];
        oe[2] = ae[8];
        oe[3] = ae[12];
        oe[4] = ae[1];
        oe[5] = ae[5];
        oe[6] = ae[9];
        oe[7] = ae[13];
        oe[8] = ae[2];
        oe[9] = ae[6];
        oe[10] = ae[10];
        oe[11] = ae[14];
        oe[12] = ae[3];
        oe[13] = ae[7];
        oe[14] = ae[11];
        oe[15] = ae[15];
      }
    }
    /**
     * An array containing the elements of the matrix (column matrix).
     * @remarks
     * elements[0] first column and first row value m11
     * elements[1] first column and second row value m12
     * elements[2] first column and third row value m13
     * elements[3] first column and fourth row value m14
     * elements[4] second column and first row value m21
     * and so on
     */
    ;
    /**
     * Constructor of 4x4 Matrix.
     * @param m11 - default 1, column 1, row 1
     * @param m12 - default 0, column 1, row 2
     * @param m13 - default 0, column 1, row 3
     * @param m14 - default 0, column 1, row 4
     * @param m21 - default 0, column 2, row 1
     * @param m22 - default 1, column 2, row 2
     * @param m23 - default 0, column 2, row 3
     * @param m24 - default 0, column 2, row 4
     * @param m31 - default 0, column 3, row 1
     * @param m32 - default 0, column 3, row 2
     * @param m33 - default 1, column 3, row 3
     * @param m34 - default 0, column 3, row 4
     * @param m41 - default 0, column 4, row 1
     * @param m42 - default 0, column 4, row 2
     * @param m43 - default 0, column 4, row 3
     * @param m44 - default 1, column 4, row 4
     */


    function Matrix(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
      if (m11 === void 0) {
        m11 = 1;
      }

      if (m12 === void 0) {
        m12 = 0;
      }

      if (m13 === void 0) {
        m13 = 0;
      }

      if (m14 === void 0) {
        m14 = 0;
      }

      if (m21 === void 0) {
        m21 = 0;
      }

      if (m22 === void 0) {
        m22 = 1;
      }

      if (m23 === void 0) {
        m23 = 0;
      }

      if (m24 === void 0) {
        m24 = 0;
      }

      if (m31 === void 0) {
        m31 = 0;
      }

      if (m32 === void 0) {
        m32 = 0;
      }

      if (m33 === void 0) {
        m33 = 1;
      }

      if (m34 === void 0) {
        m34 = 0;
      }

      if (m41 === void 0) {
        m41 = 0;
      }

      if (m42 === void 0) {
        m42 = 0;
      }

      if (m43 === void 0) {
        m43 = 0;
      }

      if (m44 === void 0) {
        m44 = 1;
      }

      this.elements = new Float32Array(16);
      var e = this.elements;
      e[0] = m11;
      e[1] = m12;
      e[2] = m13;
      e[3] = m14;
      e[4] = m21;
      e[5] = m22;
      e[6] = m23;
      e[7] = m24;
      e[8] = m31;
      e[9] = m32;
      e[10] = m33;
      e[11] = m34;
      e[12] = m41;
      e[13] = m42;
      e[14] = m43;
      e[15] = m44;
    }
    /**
     * Set the value of this matrix, and return this matrix.
     * @param m11 - column 1, row 1
     * @param m12 - column 1, row 2
     * @param m13 - column 1, row 3
     * @param m14 - column 1, row 4
     * @param m21 - column 2, row 1
     * @param m22 - column 2, row 2
     * @param m23 - column 2, row 3
     * @param m24 - column 2, row 4
     * @param m31 - column 3, row 1
     * @param m32 - column 3, row 2
     * @param m33 - column 3, row 3
     * @param m34 - column 3, row 4
     * @param m41 - column 4, row 1
     * @param m42 - column 4, row 2
     * @param m43 - column 4, row 3
     * @param m44 - column 4, row 4
     * @returns This matrix
     */


    var _proto = Matrix.prototype;

    _proto.setValue = function setValue(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
      var e = this.elements;
      e[0] = m11;
      e[1] = m12;
      e[2] = m13;
      e[3] = m14;
      e[4] = m21;
      e[5] = m22;
      e[6] = m23;
      e[7] = m24;
      e[8] = m31;
      e[9] = m32;
      e[10] = m33;
      e[11] = m34;
      e[12] = m41;
      e[13] = m42;
      e[14] = m43;
      e[15] = m44;
      return this;
    }
    /**
     * Set the value of this matrix by an array.
     * @param array - The array
     * @param offset - The start offset of the array
     * @returns This matrix
     */
    ;

    _proto.setValueByArray = function setValueByArray(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }

      var srce = this.elements;

      for (var i = 0; i < 16; i++) {
        srce[i] = array[i + offset];
      }

      return this;
    }
    /**
     * Clone the value of this matrix to an array.
     * @param out - The array
     * @param outOffset - The start offset of the array
     */
    ;

    _proto.toArray = function toArray(out, outOffset) {
      if (outOffset === void 0) {
        outOffset = 0;
      }

      var e = this.elements;
      out[outOffset] = e[0];
      out[outOffset + 1] = e[1];
      out[outOffset + 2] = e[2];
      out[outOffset + 3] = e[3];
      out[outOffset + 4] = e[4];
      out[outOffset + 5] = e[5];
      out[outOffset + 6] = e[6];
      out[outOffset + 7] = e[7];
      out[outOffset + 8] = e[8];
      out[outOffset + 9] = e[9];
      out[outOffset + 10] = e[10];
      out[outOffset + 11] = e[11];
      out[outOffset + 12] = e[12];
      out[outOffset + 13] = e[13];
      out[outOffset + 14] = e[14];
      out[outOffset + 15] = e[15];
    }
    /**
     * Creates a clone of this matrix.
     * @returns A clone of this matrix
     */
    ;

    _proto.clone = function clone() {
      var e = this.elements;
      var ret = new Matrix(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
      return ret;
    }
    /**
     * Clones this matrix to the specified matrix.
     * @param out - The specified matrix
     * @returns The specified matrix
     */
    ;

    _proto.cloneTo = function cloneTo(out) {
      var e = this.elements;
      var oe = out.elements;
      oe[0] = e[0];
      oe[1] = e[1];
      oe[2] = e[2];
      oe[3] = e[3];
      oe[4] = e[4];
      oe[5] = e[5];
      oe[6] = e[6];
      oe[7] = e[7];
      oe[8] = e[8];
      oe[9] = e[9];
      oe[10] = e[10];
      oe[11] = e[11];
      oe[12] = e[12];
      oe[13] = e[13];
      oe[14] = e[14];
      oe[15] = e[15];
      return out;
    }
    /**
     * Determines the product of this matrix and the specified matrix.
     * @param right - The specified matrix
     * @returns This matrix that store the product of the two matrices
     */
    ;

    _proto.multiply = function multiply(right) {
      Matrix.multiply(this, right, this);
      return this;
    }
    /**
     * Calculate a determinant of this matrix.
     * @returns The determinant of this matrix
     */
    ;

    _proto.determinant = function determinant() {
      var e = this.elements;
      var a11 = e[0],
          a12 = e[1],
          a13 = e[2],
          a14 = e[3];
      var a21 = e[4],
          a22 = e[5],
          a23 = e[6],
          a24 = e[7];
      var a31 = e[8],
          a32 = e[9],
          a33 = e[10],
          a34 = e[11];
      var a41 = e[12],
          a42 = e[13],
          a43 = e[14],
          a44 = e[15];
      var b00 = a11 * a22 - a12 * a21;
      var b01 = a11 * a23 - a13 * a21;
      var b02 = a11 * a24 - a14 * a21;
      var b03 = a12 * a23 - a13 * a22;
      var b04 = a12 * a24 - a14 * a22;
      var b05 = a13 * a24 - a14 * a23;
      var b06 = a31 * a42 - a32 * a41;
      var b07 = a31 * a43 - a33 * a41;
      var b08 = a31 * a44 - a34 * a41;
      var b09 = a32 * a43 - a33 * a42;
      var b10 = a32 * a44 - a34 * a42;
      var b11 = a33 * a44 - a34 * a43; // Calculate the determinant

      return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    }
    /**
     * Decompose this matrix to translation, rotation and scale elements.
     * @param translation - Translation vector as an output parameter
     * @param rotation - Rotation quaternion as an output parameter
     * @param scale - Scale vector as an output parameter
     * @returns True if this matrix can be decomposed, false otherwise
     */
    ;

    _proto.decompose = function decompose(translation, rotation, scale) {
      var rm = Matrix._tempMat30;
      var e = this.elements;
      var rme = rm.elements;
      var m11 = e[0];
      var m12 = e[1];
      var m13 = e[2];
      var m14 = e[3];
      var m21 = e[4];
      var m22 = e[5];
      var m23 = e[6];
      var m24 = e[7];
      var m31 = e[8];
      var m32 = e[9];
      var m33 = e[10];
      var m34 = e[11];
      translation.x = e[12];
      translation.y = e[13];
      translation.z = e[14];
      var xs = Math.sign(m11 * m12 * m13 * m14) < 0 ? -1 : 1;
      var ys = Math.sign(m21 * m22 * m23 * m24) < 0 ? -1 : 1;
      var zs = Math.sign(m31 * m32 * m33 * m34) < 0 ? -1 : 1;
      var sx = xs * Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
      var sy = ys * Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
      var sz = zs * Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;

      if (Math.abs(sx) < MathUtil.zeroTolerance || Math.abs(sy) < MathUtil.zeroTolerance || Math.abs(sz) < MathUtil.zeroTolerance) {
        rotation.identity();
        return false;
      } else {
        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;
        rme[0] = m11 * invSX;
        rme[1] = m12 * invSX;
        rme[2] = m13 * invSX;
        rme[3] = m21 * invSY;
        rme[4] = m22 * invSY;
        rme[5] = m23 * invSY;
        rme[6] = m31 * invSZ;
        rme[7] = m32 * invSZ;
        rme[8] = m33 * invSZ;
        Quaternion.rotationMatrix3x3(rm, rotation);
        return true;
      }
    }
    /**
     * Get rotation from this matrix.
     * @param out - Rotation quaternion as an output parameter
     * @returns The out
     */
    ;

    _proto.getRotation = function getRotation(out) {
      var e = this.elements;
      var trace = e[0] + e[5] + e[10];

      if (trace > MathUtil.zeroTolerance) {
        var S = Math.sqrt(trace + 1.0) * 2;
        out.w = 0.25 * S;
        out.x = (e[6] - e[9]) / S;
        out.y = (e[8] - e[2]) / S;
        out.z = (e[1] - e[4]) / S;
      } else if (e[0] > e[5] && e[0] > e[10]) {
        var _S = Math.sqrt(1.0 + e[0] - e[5] - e[10]) * 2;

        out.w = (e[6] - e[9]) / _S;
        out.x = 0.25 * _S;
        out.y = (e[1] + e[4]) / _S;
        out.z = (e[8] + e[2]) / _S;
      } else if (e[5] > e[10]) {
        var _S2 = Math.sqrt(1.0 + e[5] - e[0] - e[10]) * 2;

        out.w = (e[8] - e[2]) / _S2;
        out.x = (e[1] + e[4]) / _S2;
        out.y = 0.25 * _S2;
        out.z = (e[6] + e[9]) / _S2;
      } else {
        var _S3 = Math.sqrt(1.0 + e[10] - e[0] - e[5]) * 2;

        out.w = (e[1] - e[4]) / _S3;
        out.x = (e[8] + e[2]) / _S3;
        out.y = (e[6] + e[9]) / _S3;
        out.z = 0.25 * _S3;
      }

      return out;
    }
    /**
     * Get scale from this matrix.
     * @param out - Scale vector as an output parameter
     * @returns The out
     */
    ;

    _proto.getScaling = function getScaling(out) {
      //getScale()
      var e = this.elements;
      var m11 = e[0],
          m12 = e[1],
          m13 = e[2];
      var m21 = e[4],
          m22 = e[5],
          m23 = e[6];
      var m31 = e[8],
          m32 = e[9],
          m33 = e[10];
      out.x = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
      out.y = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
      out.z = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
      return out;
    }
    /**
     * Get translation from this matrix.
     * @param out - Translation vector as an output parameter
     * @returns The out
     */
    ;

    _proto.getTranslation = function getTranslation(out) {
      var e = this.elements;
      out.x = e[12];
      out.y = e[13];
      out.z = e[14];
      return out;
    }
    /**
     * Identity this matrix.
     * @returns This matrix after identity
     */
    ;

    _proto.identity = function identity() {
      var e = this.elements;
      e[0] = 1;
      e[1] = 0;
      e[2] = 0;
      e[3] = 0;
      e[4] = 0;
      e[5] = 1;
      e[6] = 0;
      e[7] = 0;
      e[8] = 0;
      e[9] = 0;
      e[10] = 1;
      e[11] = 0;
      e[12] = 0;
      e[13] = 0;
      e[14] = 0;
      e[15] = 1;
      return this;
    }
    /**
     * Invert the matrix.
     * @returns The matrix after invert
     */
    ;

    _proto.invert = function invert() {
      Matrix.invert(this, this);
      return this;
    }
    /**
     * This matrix rotates around an arbitrary axis.
     * @param axis - The axis
     * @param r - The rotation angle in radians
     * @returns This matrix after rotate
     */
    ;

    _proto.rotateAxisAngle = function rotateAxisAngle(axis, r) {
      Matrix.rotateAxisAngle(this, axis, r, this);
      return this;
    }
    /**
     * Scale this matrix by a given vector.
     * @param s - The given vector
     * @returns This matrix after scale
     */
    ;

    _proto.scale = function scale(s) {
      Matrix.scale(this, s, this);
      return this;
    }
    /**
     * Translate this matrix by a given vector.
     * @param v - The given vector
     * @returns This matrix after translate
     */
    ;

    _proto.translate = function translate(v) {
      Matrix.translate(this, v, this);
      return this;
    }
    /**
     * Calculate the transpose of this matrix.
     * @returns This matrix after transpose
     */
    ;

    _proto.transpose = function transpose() {
      Matrix.transpose(this, this);
      return this;
    };

    return Matrix;
  }();

  Matrix._tempVec30 = new Vector3();
  Matrix._tempVec31 = new Vector3();
  Matrix._tempVec32 = new Vector3();
  Matrix._tempMat30 = new Matrix3x3();
  Matrix._identity = new Matrix(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
  /**
   * Represents a ray with an origin and a direction in 3D space.
   */

  var Ray = /*#__PURE__*/function () {
    /** The origin of the ray. */

    /** The normalized direction of the ray. */

    /**
     * Constructor of Ray.
     * @param origin - The origin vector
     * @param direction - The direction vector
     */
    function Ray(origin, direction) {
      if (origin === void 0) {
        origin = null;
      }

      if (direction === void 0) {
        direction = null;
      }

      this.origin = new Vector3();
      this.direction = new Vector3();
      origin && origin.cloneTo(this.origin);
      direction && direction.cloneTo(this.direction);
    }
    /**
     * Check if this ray intersects the specified plane.
     * @param plane - The specified plane
     * @returns The distance from this ray to the specified plane if intersecting, -1 otherwise
     */


    var _proto = Ray.prototype;

    _proto.intersectPlane = function intersectPlane(plane) {
      return CollisionUtil.intersectsRayAndPlane(this, plane);
    }
    /**
     * Check if this ray intersects the specified sphere.
     * @param sphere - The specified sphere
     * @returns The distance from this ray to the specified sphere if intersecting, -1 otherwise
     */
    ;

    _proto.intersectSphere = function intersectSphere(sphere) {
      return CollisionUtil.intersectsRayAndSphere(this, sphere);
    }
    /**
     * Check if this ray intersects the specified box (AABB).
     * @param box - The specified box
     * @returns The distance from this ray to the specified box if intersecting, -1 otherwise
     */
    ;

    _proto.intersectBox = function intersectBox(box) {
      return CollisionUtil.intersectsRayAndBox(this, box);
    }
    /**
     * The coordinates of the specified distance from the origin in the ray direction.
     * @param distance - The specified distance
     * @param out - The coordinates as an output parameter
     * @returns The out
     */
    ;

    _proto.getPoint = function getPoint(distance, out) {
      Vector3.scale(this.direction, distance, out);
      return out.add(this.origin);
    };

    return Ray;
  }();
  /**
   * Describes a 2D-vector.
   */


  var Vector2 = /*#__PURE__*/function () {
    /** @internal */

    /** @internal */

    /**
     * Determines the sum of two vectors.
     * @param left - The first vector to add
     * @param right - The second vector to add
     * @param out - The sum of two vectors
     */
    Vector2.add = function add(left, right, out) {
      out.x = left.x + right.x;
      out.y = left.y + right.y;
    }
    /**
     * Determines the difference between two vectors.
     * @param left - The first vector to subtract
     * @param right - The second vector to subtract
     * @param out - The difference between two vectors
     */
    ;

    Vector2.subtract = function subtract(left, right, out) {
      out.x = left.x - right.x;
      out.y = left.y - right.y;
    }
    /**
     * Determines the product of two vectors.
     * @param left - The first vector to multiply
     * @param right - The second vector to multiply
     * @param out - The product of two vectors
     */
    ;

    Vector2.multiply = function multiply(left, right, out) {
      out.x = left.x * right.x;
      out.y = left.y * right.y;
    }
    /**
     * Determines the divisor of two vectors.
     * @param left - The first vector to divide
     * @param right - The second vector to divide
     * @param out - The divisor of two vectors
     */
    ;

    Vector2.divide = function divide(left, right, out) {
      out.x = left.x / right.x;
      out.y = left.y / right.y;
    }
    /**
     * Determines the dot product of two vectors.
     * @param left - The first vector to dot
     * @param right - The second vector to dot
     * @returns The dot product of two vectors
     */
    ;

    Vector2.dot = function dot(left, right) {
      return left.x * right.x + left.y * right.y;
    }
    /**
     * Determines the distance of two vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @returns The distance of two vectors
     */
    ;

    Vector2.distance = function distance(left, right) {
      var x = right.x - left.x;
      var y = right.y - left.y;
      return Math.sqrt(x * x + y * y);
    }
    /**
     * Determines the squared distance of two vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @returns The squared distance of two vectors
     */
    ;

    Vector2.distanceSquared = function distanceSquared(left, right) {
      var x = right.x - left.x;
      var y = right.y - left.y;
      return x * x + y * y;
    }
    /**
     * Determines whether the specified vectors are equals.
     * @param left - The first vector to compare
     * @param right - The second vector to compare
     * @returns True if the specified vectors are equals, false otherwise
     */
    ;

    Vector2.equals = function equals(left, right) {
      return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y);
    }
    /**
     * Performs a linear interpolation between two vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @param t - The blend amount where 0 returns left and 1 right
     * @param out - The result of linear blending between two vectors
     */
    ;

    Vector2.lerp = function lerp(left, right, t, out) {
      var x = left.x,
          y = left.y;
      out.x = x + (right.x - x) * t;
      out.y = y + (right.y - y) * t;
    }
    /**
     * Calculate a vector containing the largest components of the specified vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @param out - The vector containing the largest components of the specified vectors
     */
    ;

    Vector2.max = function max(left, right, out) {
      out.x = Math.max(left.x, right.x);
      out.y = Math.max(left.y, right.y);
    }
    /**
     * Calculate a vector containing the smallest components of the specified vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @param out - The vector containing the smallest components of the specified vectors
     */
    ;

    Vector2.min = function min(left, right, out) {
      out.x = Math.min(left.x, right.x);
      out.y = Math.min(left.y, right.y);
    }
    /**
     * Reverses the direction of a given vector.
     * @param left - The vector to negate
     * @param out - The vector facing in the opposite direction
     */
    ;

    Vector2.negate = function negate(left, out) {
      out.x = -left.x;
      out.y = -left.y;
    }
    /**
     * Converts the vector into a unit vector.
     * @param left - The vector to normalize
     * @param out - The normalized vector
     */
    ;

    Vector2.normalize = function normalize(left, out) {
      var x = left.x,
          y = left.y;
      var len = Math.sqrt(x * x + y * y);

      if (len > MathUtil.zeroTolerance) {
        len = 1 / len;
        out.x = x * len;
        out.y = y * len;
      }
    }
    /**
     * Scale a vector by the given value.
     * @param left - The vector to scale
     * @param s - The amount by which to scale the vector
     * @param out - The scaled vector
     */
    ;

    Vector2.scale = function scale(left, s, out) {
      out.x = left.x * s;
      out.y = left.y * s;
    }
    /** The x component of the vector. */
    ;
    /**
     * Constructor of Vector2.
     * @param x - The x component of the vector, default 0
     * @param y - The y component of the vector, default 0
     */


    function Vector2(x, y) {
      if (x === void 0) {
        x = 0;
      }

      if (y === void 0) {
        y = 0;
      }

      this.x = void 0;
      this.y = void 0;
      this.x = x;
      this.y = y;
    }
    /**
     * Set the value of this vector.
     * @param x - The x component of the vector
     * @param y - The y component of the vector
     * @returns This vector
     */


    var _proto = Vector2.prototype;

    _proto.setValue = function setValue(x, y) {
      this.x = x;
      this.y = y;
      return this;
    }
    /**
     * Set the value of this vector by an array.
     * @param array - The array
     * @param offset - The start offset of the array
     * @returns This vector
     */
    ;

    _proto.setValueByArray = function setValueByArray(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }

      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    }
    /**
     * Determines the sum of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */
    ;

    _proto.add = function add(right) {
      this.x += right.x;
      this.y += right.y;
      return this;
    }
    /**
     * Determines the difference of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */
    ;

    _proto.subtract = function subtract(right) {
      this.x -= right.x;
      this.y -= right.y;
      return this;
    }
    /**
     * Determines the product of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */
    ;

    _proto.multiply = function multiply(right) {
      this.x *= right.x;
      this.y *= right.y;
      return this;
    }
    /**
     * Determines the divisor of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */
    ;

    _proto.divide = function divide(right) {
      this.x /= right.x;
      this.y /= right.y;
      return this;
    }
    /**
     * Calculate the length of this vector.
     * @returns The length of this vector
     */
    ;

    _proto.length = function length() {
      var x = this.x,
          y = this.y;
      return Math.sqrt(x * x + y * y);
    }
    /**
     * Calculate the squared length of this vector.
     * @returns The squared length of this vector
     */
    ;

    _proto.lengthSquared = function lengthSquared() {
      var x = this.x,
          y = this.y;
      return x * x + y * y;
    }
    /**
     * Reverses the direction of this vector.
     * @returns This vector
     */
    ;

    _proto.negate = function negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
    /**
     * Converts this vector into a unit vector.
     * @returns This vector
     */
    ;

    _proto.normalize = function normalize() {
      Vector2.normalize(this, this);
      return this;
    }
    /**
     * Scale this vector by the given value.
     * @param s - The amount by which to scale the vector
     * @returns This vector
     */
    ;

    _proto.scale = function scale(s) {
      this.x *= s;
      this.y *= s;
      return this;
    }
    /**
     * Clone the value of this vector to an array.
     * @param out - The array
     * @param outOffset - The start offset of the array
     */
    ;

    _proto.toArray = function toArray(out, outOffset) {
      if (outOffset === void 0) {
        outOffset = 0;
      }

      out[outOffset] = this.x;
      out[outOffset + 1] = this.y;
    }
    /**
     * Creates a clone of this vector.
     * @returns A clone of this vector
     */
    ;

    _proto.clone = function clone() {
      return new Vector2(this.x, this.y);
    }
    /**
     * Clones this vector to the specified vector.
     * @param out - The specified vector
     * @returns The specified vector
     */
    ;

    _proto.cloneTo = function cloneTo(out) {
      out.x = this.x;
      out.y = this.y;
      return out;
    };

    return Vector2;
  }();

  Vector2._zero = new Vector2(0.0, 0.0);
  Vector2._one = new Vector2(1.0, 1.0);
  /**
   * Describes a 4D-vector.
   */

  var Vector4 = /*#__PURE__*/function () {
    /** @internal */

    /** @internal */

    /**
     * Determines the sum of two vectors.
     * @param left - The first vector to add
     * @param right - The second vector to add
     * @param out - The sum of two vectors
     */
    Vector4.add = function add(left, right, out) {
      out.x = left.x + right.x;
      out.y = left.y + right.y;
      out.z = left.z + right.z;
      out.w = left.w + right.w;
    }
    /**
     * Determines the difference between two vectors.
     * @param left - The first vector to subtract
     * @param right - The second vector to subtract
     * @param out - The difference between two vectors
     */
    ;

    Vector4.subtract = function subtract(left, right, out) {
      out.x = left.x - right.x;
      out.y = left.y - right.y;
      out.z = left.z - right.z;
      out.w = left.w - right.w;
    }
    /**
     * Determines the product of two vectors.
     * @param left - The first vector to multiply
     * @param right - The second vector to multiply
     * @param out - The product of two vectors
     */
    ;

    Vector4.multiply = function multiply(left, right, out) {
      out.x = left.x * right.x;
      out.y = left.y * right.y;
      out.z = left.z * right.z;
      out.w = left.w * right.w;
    }
    /**
     * Determines the divisor of two vectors.
     * @param left - The first vector to divide
     * @param right - The second vector to divide
     * @param out - The divisor of two vectors
     */
    ;

    Vector4.divide = function divide(left, right, out) {
      out.x = left.x / right.x;
      out.y = left.y / right.y;
      out.z = left.z / right.z;
      out.w = left.w / right.w;
    }
    /**
     * Determines the dot product of two vectors.
     * @param left - The first vector to dot
     * @param right - The second vector to dot
     * @returns The dot product of two vectors
     */
    ;

    Vector4.dot = function dot(left, right) {
      return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
    }
    /**
     * Determines the distance of two vectors.
     * @param a - The first vector
     * @param b - The second vector
     * @returns The distance of two vectors
     */
    ;

    Vector4.distance = function distance(a, b) {
      var x = b.x - a.x;
      var y = b.y - a.y;
      var z = b.z - a.z;
      var w = b.w - a.w;
      return Math.sqrt(x * x + y * y + z * z + w * w);
    }
    /**
     * Determines the squared distance of two vectors.
     * @param a - The first vector
     * @param b - The second vector
     * @returns The squared distance of two vectors
     */
    ;

    Vector4.distanceSquared = function distanceSquared(a, b) {
      var x = b.x - a.x;
      var y = b.y - a.y;
      var z = b.z - a.z;
      var w = b.w - a.w;
      return x * x + y * y + z * z + w * w;
    }
    /**
     * Determines whether the specified vectors are equals.
     * @param left - The first vector to compare
     * @param right - The second vector to compare
     * @returns True if the specified vectors are equals, false otherwise
     */
    ;

    Vector4.equals = function equals(left, right) {
      return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z) && MathUtil.equals(left.w, right.w);
    }
    /**
     * Performs a linear interpolation between two vectors.
     * @param start - The first vector
     * @param end - The second vector
     * @param t - The blend amount where 0 returns start and 1 end
     * @param out - The result of linear blending between two vectors
     */
    ;

    Vector4.lerp = function lerp(start, end, t, out) {
      var x = start.x,
          y = start.y,
          z = start.z,
          w = start.w;
      out.x = x + (end.x - x) * t;
      out.y = y + (end.y - y) * t;
      out.z = z + (end.z - z) * t;
      out.w = w + (end.w - w) * t;
    }
    /**
     * Calculate a vector containing the largest components of the specified vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @param out - The vector containing the largest components of the specified vectors
     */
    ;

    Vector4.max = function max(left, right, out) {
      out.x = Math.max(left.x, right.x);
      out.y = Math.max(left.y, right.y);
      out.z = Math.max(left.z, right.z);
      out.w = Math.max(left.w, right.w);
    }
    /**
     * Calculate a vector containing the smallest components of the specified vectors.
     * @param left - The first vector
     * @param right - The second vector
     * @param out - The vector containing the smallest components of the specified vectors
     */
    ;

    Vector4.min = function min(left, right, out) {
      out.x = Math.min(left.x, right.x);
      out.y = Math.min(left.y, right.y);
      out.z = Math.min(left.z, right.z);
      out.w = Math.min(left.w, right.w);
    }
    /**
     * Reverses the direction of a given vector.
     * @param a - The vector to negate
     * @param out - The vector facing in the opposite direction
     */
    ;

    Vector4.negate = function negate(a, out) {
      out.x = -a.x;
      out.y = -a.y;
      out.z = -a.z;
      out.w = -a.w;
    }
    /**
     * Converts the vector into a unit vector.
     * @param a - The vector to normalize
     * @param out - The normalized vector
     */
    ;

    Vector4.normalize = function normalize(a, out) {
      var x = a.x,
          y = a.y,
          z = a.z,
          w = a.w;
      var len = Math.sqrt(x * x + y * y + z * z + w * w);

      if (len > MathUtil.zeroTolerance) {
        len = 1 / len;
        out.x = x * len;
        out.y = y * len;
        out.z = z * len;
        out.w = w * len;
      }
    }
    /**
     * Scale a vector by the given value.
     * @param a - The vector to scale
     * @param s - The amount by which to scale the vector
     * @param out - The scaled vector
     */
    ;

    Vector4.scale = function scale(a, s, out) {
      out.x = a.x * s;
      out.y = a.y * s;
      out.z = a.z * s;
      out.w = a.w * s;
    }
    /**
     * Performs a transformation using the given 4x4 matrix.
     * @param v - The vector to transform
     * @param m - The transform matrix
     * @param out - The transformed vector3
     */
    ;

    Vector4.transform = function transform(v, m, out) {
      var x = v.x,
          y = v.y,
          z = v.z,
          w = v.w;
      var e = m.elements;
      out.x = x * e[0] + y * e[4] + z * e[8] + w * e[12];
      out.y = x * e[1] + y * e[5] + z * e[9] + w * e[13];
      out.z = x * e[2] + y * e[6] + z * e[10] + w * e[14];
      out.w = x * e[3] + y * e[7] + z * e[11] + w * e[15];
    }
    /**
     * Performs a transformation using the given quaternion.
     * @param v - The vector to transform
     * @param q - The transform quaternion
     * @param out - The transformed vector
     */
    ;

    Vector4.transformByQuat = function transformByQuat(v, q, out) {
      var x = v.x,
          y = v.y,
          z = v.z,
          w = v.w;
      var qx = q.x;
      var qy = q.y;
      var qz = q.z;
      var qw = q.w; // calculate quat * vec

      var ix = qw * x + qy * z - qz * y;
      var iy = qw * y + qz * x - qx * z;
      var iz = qw * z + qx * y - qy * x;
      var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

      out.x = ix * qw - iw * qx - iy * qz + iz * qy;
      out.y = iy * qw - iw * qy - iz * qx + ix * qz;
      out.z = iz * qw - iw * qz - ix * qy + iy * qx;
      out.w = w;
    }
    /** The x component of the vector. */
    ;
    /**
     * Constructor of Vector4.
     * @param x - The x component of the vector, default 0
     * @param y - The y component of the vector, default 0
     * @param z - The z component of the vector, default 0
     * @param w - The w component of the vector, default 0
     */


    function Vector4(x, y, z, w) {
      if (x === void 0) {
        x = 0;
      }

      if (y === void 0) {
        y = 0;
      }

      if (z === void 0) {
        z = 0;
      }

      if (w === void 0) {
        w = 0;
      }

      this.x = void 0;
      this.y = void 0;
      this.z = void 0;
      this.w = void 0;
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }
    /**
     * Set the value of this vector.
     * @param x - The x component of the vector
     * @param y - The y component of the vector
     * @param z - The z component of the vector
     * @param w - The w component of the vector
     * @returns This vector
     */


    var _proto = Vector4.prototype;

    _proto.setValue = function setValue(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    }
    /**
     * Set the value of this vector by an array.
     * @param array - The array
     * @param offset - The start offset of the array
     * @returns This vector
     */
    ;

    _proto.setValueByArray = function setValueByArray(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }

      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    }
    /**
     * Determines the sum of this vector and the specified vector.
     * @param right - The specified vector
     * @returns This vector
     */
    ;

    _proto.add = function add(right) {
      this.x += right.x;
      this.y += right.y;
      this.z += right.z;
      this.w += right.w;
      return this;
    }
    /**
     * Determines the difference of this vector and the specified vector.
     * @param right - the specified vector
     * @returns This vector
     */
    ;

    _proto.subtract = function subtract(right) {
      this.x -= right.x;
      this.y -= right.y;
      this.z -= right.z;
      this.w -= right.w;
      return this;
    }
    /**
     * Determines the product of this vector and the specified vector.
     * @param right - the specified vector
     * @returns This vector
     */
    ;

    _proto.multiply = function multiply(right) {
      this.x *= right.x;
      this.y *= right.y;
      this.z *= right.z;
      this.w *= right.w;
      return this;
    }
    /**
     * Determines the divisor of this vector and the specified vector.
     * @param right - the specified vector
     * @returns This vector
     */
    ;

    _proto.divide = function divide(right) {
      this.x /= right.x;
      this.y /= right.y;
      this.z /= right.z;
      this.w /= right.w;
      return this;
    }
    /**
     * Calculate the length of this vector.
     * @returns The length of this vector
     */
    ;

    _proto.length = function length() {
      var x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;
      return Math.sqrt(x * x + y * y + z * z + w * w);
    }
    /**
     * Calculate the squared length of this vector.
     * @returns The squared length of this vector
     */
    ;

    _proto.lengthSquared = function lengthSquared() {
      var x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;
      return x * x + y * y + z * z + w * w;
    }
    /**
     * Reverses the direction of this vector.
     * @returns This vector
     */
    ;

    _proto.negate = function negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    }
    /**
     * Converts this vector into a unit vector.
     * @returns This vector
     */
    ;

    _proto.normalize = function normalize() {
      Vector4.normalize(this, this);
      return this;
    }
    /**
     * Scale this vector by the given value.
     * @param s - The amount by which to scale the vector
     * @returns This vector
     */
    ;

    _proto.scale = function scale(s) {
      this.x *= s;
      this.y *= s;
      this.z *= s;
      this.w *= s;
      return this;
    }
    /**
     * Clone the value of this vector to an array.
     * @param out - The array
     * @param outOffset - The start offset of the array
     */
    ;

    _proto.toArray = function toArray(out, outOffset) {
      if (outOffset === void 0) {
        outOffset = 0;
      }

      out[outOffset] = this.x;
      out[outOffset + 1] = this.y;
      out[outOffset + 2] = this.z;
      out[outOffset + 3] = this.w;
    }
    /**
     * Creates a clone of this vector.
     * @returns A clone of this vector
     */
    ;

    _proto.clone = function clone() {
      var ret = new Vector4(this.x, this.y, this.z, this.w);
      return ret;
    }
    /**
     * Clones this vector to the specified vector.
     * @param out - The specified vector
     * @returns The specified vector
     */
    ;

    _proto.cloneTo = function cloneTo(out) {
      out.x = this.x;
      out.y = this.y;
      out.z = this.z;
      out.w = this.w;
      return out;
    };

    return Vector4;
  }();

  Vector4._zero = new Vector4(0.0, 0.0, 0.0, 0.0);
  Vector4._one = new Vector4(1.0, 1.0, 1.0, 1.0);
  /**
   * Describes a color in the from of RGBA (in order: R, G, B, A).
   */

  var Color = /*#__PURE__*/function () {
    /**
     * Modify a value from the gamma space to the linear space.
     * @param value - The value in gamma space
     * @returns The value in linear space
     */
    Color.gammaToLinearSpace = function gammaToLinearSpace(value) {
      // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_sRGB.txt
      // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_sRGB_decode.txt
      if (value <= 0.0) return 0.0;else if (value <= 0.04045) return value / 12.92;else if (value < 1.0) return Math.pow((value + 0.055) / 1.055, 2.4);else return Math.pow(value, 2.4);
    }
    /**
     * Modify a value from the linear space to the gamma space.
     * @param value - The value in linear space
     * @returns The value in gamma space
     */
    ;

    Color.linearToGammaSpace = function linearToGammaSpace(value) {
      // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_sRGB.txt
      // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_sRGB_decode.txt
      if (value <= 0.0) return 0.0;else if (value < 0.0031308) return 12.92 * value;else if (value < 1.0) return 1.055 * Math.pow(value, 0.41666) - 0.055;else return Math.pow(value, 0.41666);
    }
    /**
     * Determines whether the specified colors are equals.
     * @param left - The first color to compare
     * @param right - The second color to compare
     * @returns True if the specified colors are equals, false otherwise
     */
    ;

    Color.equals = function equals(left, right) {
      return MathUtil.equals(left.r, right.r) && MathUtil.equals(left.g, right.g) && MathUtil.equals(left.b, right.b) && MathUtil.equals(left.a, right.a);
    }
    /**
     * Determines the sum of two colors.
     * @param left - The first color to add
     * @param right - The second color to add
     * @param out - The sum of two colors
     * @returns The added color
     */
    ;

    Color.add = function add(left, right, out) {
      out.r = left.r + right.r;
      out.g = left.g + right.g;
      out.b = left.b + right.b;
      out.a = left.a + right.a;
      return out;
    }
    /**
     * Scale a color by the given value.
     * @param left - The color to scale
     * @param s - The amount by which to scale the color
     * @param out - The scaled color
     * @returns The scaled color
     */
    ;

    Color.scale = function scale(left, s, out) {
      out.r = left.r * s;
      out.g = left.g * s;
      out.b = left.b * s;
      out.a = left.a * s;
      return out;
    }
    /** The red component of the color, 0~1. */
    ;
    /**
     * Constructor of Color.
     * @param r - The red component of the color
     * @param g - The green component of the color
     * @param b - The blue component of the color
     * @param a - The alpha component of the color
     */


    function Color(r, g, b, a) {
      if (r === void 0) {
        r = 1;
      }

      if (g === void 0) {
        g = 1;
      }

      if (b === void 0) {
        b = 1;
      }

      if (a === void 0) {
        a = 1;
      }

      this.r = void 0;
      this.g = void 0;
      this.b = void 0;
      this.a = void 0;
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
    }
    /**
     * Set the value of this color.
     * @param r - The red component of the color
     * @param g - The green component of the color
     * @param b - The blue component of the color
     * @param a - The alpha component of the color
     * @returns This color.
     */


    var _proto = Color.prototype;

    _proto.setValue = function setValue(r, g, b, a) {
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
      return this;
    }
    /**
     * Determines the sum of this color and the specified color.
     * @param color - The specified color
     * @returns The added color
     */
    ;

    _proto.add = function add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      this.a += color.a;
      return this;
    }
    /**
     * Scale this color by the given value.
     * @param s - The amount by which to scale the color
     * @returns The scaled color
     */
    ;

    _proto.scale = function scale(s) {
      this.r *= s;
      this.g *= s;
      this.b *= s;
      this.a *= s;
      return this;
    }
    /**
     * Creates a clone of this color.
     * @returns A clone of this color
     */
    ;

    _proto.clone = function clone() {
      var ret = new Color(this.r, this.g, this.b, this.a);
      return ret;
    }
    /**
     * Clones this color to the specified color.
     * @param out - The specified color
     * @returns The specified color
     */
    ;

    _proto.cloneTo = function cloneTo(out) {
      out.r = this.r;
      out.g = this.g;
      out.b = this.b;
      out.a = this.a;
      return out;
    }
    /**
     * Modify components (r, g, b) of this color from gamma space to linear space.
     * @param out - The color in linear space
     * @returns The color in linear space
     */
    ;

    _proto.toLinear = function toLinear(out) {
      out.r = Color.gammaToLinearSpace(this.r);
      out.g = Color.gammaToLinearSpace(this.g);
      out.b = Color.gammaToLinearSpace(this.b);
      return out;
    }
    /**
     * Modify components (r, g, b) of this color from linear space to gamma space.
     * @param out - The color in gamma space
     * @returns The color in gamma space
     */
    ;

    _proto.toGamma = function toGamma(out) {
      out.r = Color.linearToGammaSpace(this.r);
      out.g = Color.linearToGammaSpace(this.g);
      out.b = Color.linearToGammaSpace(this.b);
      return out;
    };

    return Color;
  }(); // A 2d rectangle defined by x and y position, width and height.


  var Rect = /*#__PURE__*/function () {
    /** The x coordinate of the rectangle. */

    /** The y coordinate of the rectangle. */

    /** The width of the rectangle, measured from the x position. */

    /** The height of the rectangle, measured from the y position. */

    /**
     * Constructor of Rect.
     * @param x - The x coordinate of the rectangle, default 0
     * @param y - The y coordinate of the rectangle, default 0
     * @param width - The width of the rectangle, measured from the x position, default 0
     * @param height - The height of the rectangle, measured from the y position, default 0
     */
    function Rect(x, y, width, height) {
      if (x === void 0) {
        x = 0;
      }

      if (y === void 0) {
        y = 0;
      }

      if (width === void 0) {
        width = 0;
      }

      if (height === void 0) {
        height = 0;
      }

      this.x = void 0;
      this.y = void 0;
      this.width = void 0;
      this.height = void 0;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }
    /**
     * Set the value of this rectangle.
     * @param x - The x coordinate of the rectangle
     * @param y - The y coordinate of the rectangle
     * @param width - The width of the rectangle, measured from the x position
     * @param height - The height of the rectangle, measured from the y position
     * @returns This rectangle
     */


    var _proto = Rect.prototype;

    _proto.setValue = function setValue(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      return this;
    }
    /**
     * Creates a clone of this rect.
     * @returns A clone of this rect
     */
    ;

    _proto.clone = function clone() {
      return new Rect(this.x, this.y, this.width, this.height);
    }
    /**
     * Clones this rect to the specified rect.
     * @param out - The specified rect
     * @returns The specified rect
     */
    ;

    _proto.cloneTo = function cloneTo(out) {
      out.x = this.x;
      out.y = this.y;
      out.width = this.width;
      out.height = this.height;
      return out;
    };

    return Rect;
  }();
  /**
   * Use SH3 to represent irradiance environment maps efficiently, allowing for interactive rendering of diffuse objects under distant illumination.
   * @remarks
   * https://graphics.stanford.edu/papers/envmap/envmap.pdf
   * http://www.ppsloan.org/publications/StupidSH36.pdf
   * https://google.github.io/filament/Filament.md.html#annex/sphericalharmonics
   */


  var SphericalHarmonics3 = /*#__PURE__*/function () {
    function SphericalHarmonics3() {
      this.coefficients = new Float32Array(27);
    }

    var _proto = SphericalHarmonics3.prototype;
    /**
     * Add light to SphericalHarmonics3.
     * @param direction - Light direction
     * @param color - Light color
     * @param deltaSolidAngle - The delta solid angle of the light
     */

    _proto.addLight = function addLight(direction, color, deltaSolidAngle) {
      /**
       * Implements `EvalSHBasis` from [Projection from Cube maps] in http://www.ppsloan.org/publications/StupidSH36.pdf.
       *
       * Basis constants
       * 0: Math.sqrt(1/(4 * Math.PI))
       *
       * 1: -Math.sqrt(3 / (4 * Math.PI))
       * 2: Math.sqrt(3 / (4 * Math.PI))
       * 3: -Math.sqrt(3 / (4 * Math.PI))
       *
       * 4: Math.sqrt(15 / (4 * Math.PI))
       * 5: -Math.sqrt(15 / (4 * Math.PI))
       * 6: Math.sqrt(5 / (16 * Math.PI))
       * 7: -Math.sqrt(15 / (4 * Math.PI)）
       * 8: Math.sqrt(15 / (16 * Math.PI))
       */
      color.scale(deltaSolidAngle);
      var coe = this.coefficients;
      var x = direction.x,
          y = direction.y,
          z = direction.z;
      var r = color.r,
          g = color.g,
          b = color.b;
      var bv0 = 0.282095; // basis0 = 0.886227

      var bv1 = -0.488603 * y; // basis1 = -0.488603

      var bv2 = 0.488603 * z; // basis2 = 0.488603

      var bv3 = -0.488603 * x; // basis3 = -0.488603

      var bv4 = 1.092548 * (x * y); // basis4 = 1.092548

      var bv5 = -1.092548 * (y * z); // basis5 = -1.092548

      var bv6 = 0.315392 * (3 * z * z - 1); // basis6 = 0.315392

      var bv7 = -1.092548 * (x * z); // basis7 = -1.092548

      var bv8 = 0.546274 * (x * x - y * y); // basis8 = 0.546274

      coe[0] += r * bv0, coe[1] += g * bv0, coe[2] += b * bv0;
      coe[3] += r * bv1, coe[4] += g * bv1, coe[5] += b * bv1;
      coe[6] += r * bv2, coe[7] += g * bv2, coe[8] += b * bv2;
      coe[9] += r * bv3, coe[10] += g * bv3, coe[11] += b * bv3;
      coe[12] += r * bv4, coe[13] += g * bv4, coe[14] += b * bv4;
      coe[15] += r * bv5, coe[16] += g * bv5, coe[17] += b * bv5;
      coe[18] += r * bv6, coe[19] += g * bv6, coe[20] += b * bv6;
      coe[21] += r * bv7, coe[22] += g * bv7, coe[23] += b * bv7;
      coe[24] += r * bv8, coe[25] += g * bv8, coe[26] += b * bv8;
    }
    /**
     * Evaluates the color for the specified direction.
     * @param direction - Specified direction
     * @param out - Out color
     */
    ;

    _proto.evaluate = function evaluate(direction, out) {
      /**
       * Equations based on data from: http://ppsloan.org/publications/StupidSH36.pdf
       *
       *
       * Basis constants
       * 0: Math.sqrt(1/(4 * Math.PI))
       *
       * 1: -Math.sqrt(3 / (4 * Math.PI))
       * 2: Math.sqrt(3 / (4 * Math.PI))
       * 3: -Math.sqrt(3 / (4 * Math.PI))
       *
       * 4: Math.sqrt(15 / (4 * Math.PI)）
       * 5: -Math.sqrt(15 / (4 * Math.PI))
       * 6: Math.sqrt(5 / (16 * Math.PI)）
       * 7: -Math.sqrt(15 / (4 * Math.PI)）
       * 8: Math.sqrt(15 / (16 * Math.PI)）
       *
       *
       * Convolution kernel
       * 0: Math.PI
       * 1: (2 * Math.PI) / 3
       * 2: Math.PI / 4
       */
      var coe = this.coefficients;
      var x = direction.x,
          y = direction.y,
          z = direction.z;
      var bv0 = 0.886227; // kernel0 * basis0 = 0.886227

      var bv1 = -1.023327 * y; // kernel1 * basis1 = -1.023327

      var bv2 = 1.023327 * z; // kernel1 * basis2 = 1.023327

      var bv3 = -1.023327 * x; // kernel1 * basis3 = -1.023327

      var bv4 = 0.858086 * y * x; // kernel2 * basis4 = 0.858086

      var bv5 = -0.858086 * y * z; // kernel2 * basis5 = -0.858086

      var bv6 = 0.247708 * (3 * z * z - 1); // kernel2 * basis6 = 0.247708

      var bv7 = -0.858086 * z * x; // kernel2 * basis7 = -0.858086

      var bv8 = 0.429042 * (x * x - y * y); // kernel2 * basis8 = 0.429042
      // l0

      var r = coe[0] * bv0;
      var g = coe[1] * bv0;
      var b = coe[2] * bv0; // l1

      r += coe[3] * bv1 + coe[6] * bv2 + coe[9] * bv3;
      g += coe[4] * bv1 + coe[7] * bv2 + coe[10] * bv3;
      b += coe[5] * bv1 + coe[8] * bv2 + coe[11] * bv3; // l2

      r += coe[12] * bv4 + coe[15] * bv5 + coe[18] * bv6 + coe[21] * bv7 + coe[24] * bv8;
      g += coe[13] * bv4 + coe[16] * bv5 + coe[19] * bv6 + coe[22] * bv7 + coe[25] * bv8;
      b += coe[14] * bv4 + coe[17] * bv5 + coe[20] * bv6 + coe[23] * bv7 + coe[26] * bv8;
      out.setValue(r, g, b, 1.0);
      return out;
    }
    /**
     * Scale the coefficients.
     * @param s - The amount by which to scale the SphericalHarmonics3
     */
    ;

    _proto.scale = function scale(s) {
      var src = this.coefficients;
      src[0] *= s, src[1] *= s, src[2] *= s;
      src[3] *= s, src[4] *= s, src[5] *= s;
      src[6] *= s, src[7] *= s, src[8] *= s;
      src[9] *= s, src[10] *= s, src[11] *= s;
      src[12] *= s, src[13] *= s, src[14] *= s;
      src[15] *= s, src[16] *= s, src[17] *= s;
      src[18] *= s, src[19] *= s, src[20] *= s;
      src[21] *= s, src[22] *= s, src[23] *= s;
      src[24] *= s, src[25] *= s, src[26] *= s;
    }
    /**
     * Set the value of this spherical harmonics by an array.
     * @param array - The array
     * @param offset - The start offset of the array
     */
    ;

    _proto.setValueByArray = function setValueByArray(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }

      var s = this.coefficients;
      s[0] = array[offset], s[1] = array[1 + offset], s[2] = array[2 + offset];
      s[3] = array[3 + offset], s[4] = array[4 + offset], s[5] = array[5 + offset];
      s[6] = array[6 + offset], s[7] = array[7 + offset], s[8] = array[8 + offset];
      s[9] = array[9 + offset], s[10] = array[10 + offset], s[11] = array[11 + offset];
      s[12] = array[12 + offset], s[13] = array[13 + offset], s[14] = array[14 + offset];
      s[15] = array[15 + offset], s[16] = array[16 + offset], s[17] = array[17 + offset];
      s[18] = array[18 + offset], s[19] = array[19 + offset], s[20] = array[20 + offset];
      s[21] = array[21 + offset], s[22] = array[22 + offset], s[23] = array[23 + offset];
      s[24] = array[24 + offset], s[25] = array[25 + offset], s[26] = array[26 + offset];
    }
    /**
     * Clone the value of this spherical harmonics to an array.
     * @param out - The array
     * @param outOffset - The start offset of the array
     */
    ;

    _proto.toArray = function toArray(out, outOffset) {
      if (outOffset === void 0) {
        outOffset = 0;
      }

      var s = this.coefficients;
      out[0 + outOffset] = s[0], out[1 + outOffset] = s[1], out[2 + outOffset] = s[2];
      out[3 + outOffset] = s[3], out[4 + outOffset] = s[4], out[5 + outOffset] = s[5];
      out[6 + outOffset] = s[6], out[7 + outOffset] = s[7], out[8 + outOffset] = s[8];
      out[9 + outOffset] = s[9], out[10 + outOffset] = s[10], out[11 + outOffset] = s[11];
      out[12 + outOffset] = s[12], out[13 + outOffset] = s[13], out[14 + outOffset] = s[14];
      out[15 + outOffset] = s[15], out[16 + outOffset] = s[16], out[17 + outOffset] = s[17];
      out[18 + outOffset] = s[18], out[19 + outOffset] = s[19], out[20 + outOffset] = s[20];
      out[21 + outOffset] = s[21], out[22 + outOffset] = s[22], out[23 + outOffset] = s[23];
      out[24 + outOffset] = s[24], out[25 + outOffset] = s[25], out[26 + outOffset] = s[26];
    }
    /**
     * Creates a clone of this SphericalHarmonics3.
     * @returns A clone of this SphericalHarmonics3
     */
    ;

    _proto.clone = function clone() {
      var v = new SphericalHarmonics3();
      this.cloneTo(v);
      return v;
    }
    /**
     * Clones this SphericalHarmonics3 to the specified SphericalHarmonics3.
     * @param out - The specified SphericalHarmonics3
     * @returns The specified SphericalHarmonics3
     */
    ;

    _proto.cloneTo = function cloneTo(out) {
      this.toArray(out.coefficients);
    };

    return SphericalHarmonics3;
  }();

  function ownKeys$2(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread2$2(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys$2(Object(source),true).forEach(function(key){_defineProperty$2(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else {ownKeys$2(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperties$3(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass$3(Constructor,protoProps,staticProps){if(protoProps)_defineProperties$3(Constructor.prototype,protoProps);if(staticProps)_defineProperties$3(Constructor,staticProps);return Constructor;}function _defineProperty$2(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else {obj[key]=value;}return obj;}function _extends$1(){_extends$1=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends$1.apply(this,arguments);}function _inheritsLoose$2(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;_setPrototypeOf$2(subClass,superClass);}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _setPrototypeOf$2(o,p){_setPrototypeOf$2=Object.setPrototypeOf||function _setPrototypeOf(o,p){o.__proto__=p;return o;};return _setPrototypeOf$2(o,p);}function _isNativeReflectConstruct$1(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}function _construct$1(Parent,args,Class){if(_isNativeReflectConstruct$1()){_construct$1=Reflect.construct;}else {_construct$1=function _construct(Parent,args,Class){var a=[null];a.push.apply(a,args);var Constructor=Function.bind.apply(Parent,a);var instance=new Constructor();if(Class)_setPrototypeOf$2(instance,Class.prototype);return instance;};}return _construct$1.apply(null,arguments);}function _isNativeFunction(fn){return Function.toString.call(fn).indexOf("[native code]")!==-1;}function _wrapNativeSuper(Class){var _cache=typeof Map==="function"?new Map():undefined;_wrapNativeSuper=function _wrapNativeSuper(Class){if(Class===null||!_isNativeFunction(Class))return Class;if(typeof Class!=="function"){throw new TypeError("Super expression must either be null or a function");}if(typeof _cache!=="undefined"){if(_cache.has(Class))return _cache.get(Class);_cache.set(Class,Wrapper);}function Wrapper(){return _construct$1(Class,arguments,_getPrototypeOf(this).constructor);}Wrapper.prototype=Object.create(Class.prototype,{constructor:{value:Wrapper,enumerable:false,writable:true,configurable:true}});return _setPrototypeOf$2(Wrapper,Class);};return _wrapNativeSuper(Class);}function _assertThisInitialized$1(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _unsupportedIterableToArray$1(o,minLen){if(!o)return;if(typeof o==="string")return _arrayLikeToArray$1(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray$1(o,minLen);}function _arrayLikeToArray$1(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}function _createForOfIteratorHelperLoose$1(o,allowArrayLike){var it=typeof Symbol!=="undefined"&&o[Symbol.iterator]||o["@@iterator"];if(it)return (it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=_unsupportedIterableToArray$1(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;return function(){if(i>=o.length)return {done:true};return {done:false,value:o[i++]};};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _initializerDefineProperty(target,property,descriptor,context){if(!descriptor)return;Object.defineProperty(target,property,{enumerable:descriptor.enumerable,configurable:descriptor.configurable,writable:descriptor.writable,value:descriptor.initializer?descriptor.initializer.call(context):void 0});}function _applyDecoratedDescriptor$1(target,property,decorators,descriptor,context){var desc={};Object.keys(descriptor).forEach(function(key){desc[key]=descriptor[key];});desc.enumerable=!!desc.enumerable;desc.configurable=!!desc.configurable;if('value'in desc||desc.initializer){desc.writable=true;}desc=decorators.slice().reverse().reduce(function(desc,decorator){return decorator(target,property,desc)||desc;},desc);if(context&&desc.initializer!==void 0){desc.value=desc.initializer?desc.initializer.call(context):void 0;desc.initializer=undefined;}if(desc.initializer===void 0){Object.defineProperty(target,property,desc);desc=null;}return desc;}/**
   * Asset Promise Status
   */exports.AssetPromiseStatus = void 0;/**
   * Asset Loading Promise.
   */(function(AssetPromiseStatus){AssetPromiseStatus[AssetPromiseStatus["Success"]=0]="Success";AssetPromiseStatus[AssetPromiseStatus["Pending"]=1]="Pending";AssetPromiseStatus[AssetPromiseStatus["Failed"]=2]="Failed";})(exports.AssetPromiseStatus||(exports.AssetPromiseStatus={}));var AssetPromise=/*#__PURE__*/function(_Promise){_inheritsLoose$2(AssetPromise,_Promise);/**
     * Return a new resource Promise through the provided asset promise collection.
     * The resolved of the new AssetPromise will be triggered when all the Promises in the provided set are completed.
     * @param - AssetPromise Collection
     * @returns AssetPromise
     */AssetPromise.all=function all(promises){return new AssetPromise(function(resolve,reject,setProgress){if(!Array.isArray(promises)){return resolve([promises]);}var completed=0;var total=promises.length;var results=new Array(total);promises.forEach(function(value,index){Promise.resolve(value).then(function(result){results[index]=result;completed+=1;setProgress(completed/total);if(completed==total){resolve(results);}}).catch(function(err){return reject(err);});});});};var _proto=AssetPromise.prototype;/**
     * Progress callback.
     * @param callback - Progress callback
     * @returns Asset Promise
     */_proto.onProgress=function onProgress(callback){this._listeners.add(callback);return this;}/**
     * Cancel promise request.
     * @returns Asset promise
     */;_proto.cancel=function cancel(){if(this._status!==exports.AssetPromiseStatus.Pending){return this;}this._reject("Promise Canceled");return this;}/**
     * Create an asset loading Promise.
     * @param executor - A callback used to initialize the promise. This callback is passed two arguments:
     * a resolve callback used to resolve the promise with a value or the result of another promise,
     * and a reject callback used to reject the promise with a provided reason or error.
     * and a setProgress callback used to set promise progress with a percent.
     */;function AssetPromise(executor){var _this;var newReject;var setProgress=function setProgress(progress){if(progress<=_this._progress){return;}_this._progress=progress;for(var _iterator=_createForOfIteratorHelperLoose$1(_this._listeners),_step;!(_step=_iterator()).done;){var listener=_step.value;listener(progress);}};_this=_Promise.call(this,function(resolve,reject){newReject=function newReject(reason){// Add it to the micro task to avoid reporting an error when calling this directly.
  Promise.resolve().then(function(){_this._status=exports.AssetPromiseStatus.Failed;reject(reason);});};executor(function(value){// Add it to the micro task to avoid reporting an error when calling this directly.
  Promise.resolve().then(function(){setProgress(1);_this._status=exports.AssetPromiseStatus.Success;resolve(value);});},newReject,function(progress){// Add it to the micro task to avoid reporting an error when calling this directly
  Promise.resolve().then(function(){setProgress(progress);});});})||this;_this._status=void 0;_this._progress=void 0;_this._reject=void 0;_this._listeners=void 0;_this._reject=newReject;_this._listeners=new Set();_this._progress=0;_this._status=exports.AssetPromiseStatus.Pending;return _this;}_createClass$3(AssetPromise,[{key:"status",get:/**
       * Current promise state.
       */function get(){return this._status;}/**
       * Loading progress.
       */},{key:"progress",get:function get(){return this._progress;}}]);return AssetPromise;}(/*#__PURE__*/_wrapNativeSuper(Promise));var Util={isArray:"isArray"in Array?Array.isArray:function(value){return toString.call(value)==="[object Array]";},isArrayLike:function isArrayLike(x){return !!x&&typeof x.length==="number"&&typeof x!=="function";},clone:function clone(obj){if(typeof obj!=="object"||obj===null){return obj;}var rst;if(Util.isArrayLike(obj)){rst=obj.slice();for(var i=0,l=obj.length;i<l;i++){rst[i]=Util.clone(obj[i]);}}else {rst={};for(var k in obj){if(obj.hasOwnProperty(k)){rst[k]=Util.clone(obj[k]);}}}return rst;},downloadBlob:function downloadBlob(blob,fileName){if(fileName===void 0){fileName="";}if(navigator&&navigator.msSaveBlob){navigator.msSaveBlob(blob,fileName);return;}var url=window.URL.createObjectURL(blob);var a=document.createElement("a");document.body.appendChild(a);a.style.display="none";a.href=url;a.download=fileName;a.addEventListener("click",function(){if(a.parentElement){a.parentElement.removeChild(a);}});a.click();window.URL.revokeObjectURL(url);}};/**
   * Fastly remove an element from array.
   * @param array - Array
   * @param item - Element
   */function removeFromArray(array,item){var index=array.indexOf(item);if(index<0){return false;}var last=array.length-1;if(index!==last){var end=array[last];array[index]=end;}array.length--;return true;}function ObjectValues(obj){return Object.keys(obj).map(function(key){return obj[key];});}/**
   * ResourceManager
   */var ResourceManager=/*#__PURE__*/function(){/** Loader collection. */ /**
     * @internal
     */ResourceManager._addLoader=function _addLoader(type,loader,extnames){this._loaders[type]=loader;for(var i=0,len=extnames.length;i<len;i++){this._extTypeMapping[extnames[i]]=type;}};ResourceManager._getTypeByUrl=function _getTypeByUrl(url){var path=url.split("?")[0];return this._extTypeMapping[path.substring(path.lastIndexOf(".")+1)];}/** The number of retries after failing to load assets. */;/**
     * Create a ResourceManager.
     * @param engine - Engine to which the current ResourceManager belongs
     */function ResourceManager(engine){this.engine=engine;this.retryCount=1;this.retryInterval=0;this.timeout=20000;this._assetPool=Object.create(null);this._assetUrlPool=Object.create(null);this._refObjectPool=Object.create(null);this._loadingPromises={};}/**
     * Load asset asynchronously through the path.
     * @param path - Path
     * @returns Asset promise
     */var _proto=ResourceManager.prototype;_proto.load=function load(assetInfo){var _this=this;// single item
  if(!Array.isArray(assetInfo)){return this._loadSingleItem(assetInfo);}// multi items
  var promises=assetInfo.map(function(item){return _this._loadSingleItem(item);});return AssetPromise.all(promises);}/**
     * Cancel all assets that have not finished loading.
     */;_proto.cancelNotLoaded=function cancelNotLoaded(url){var _this2=this;if(!url){ObjectValues(this._loadingPromises).forEach(function(promise){promise.cancel();});}else if(typeof url==="string"){var _this$_loadingPromise;(_this$_loadingPromise=this._loadingPromises[url])===null||_this$_loadingPromise===void 0?void 0:_this$_loadingPromise.cancel();}else {url.forEach(function(p){var _this2$_loadingPromis;(_this2$_loadingPromis=_this2._loadingPromises[p])===null||_this2$_loadingPromis===void 0?void 0:_this2$_loadingPromis.cancel();});}}/**
     * Garbage collection will release resource objects managed by reference counting.
     * @remarks The release principle is that it is not referenced by the components, including direct and indirect reference.
     */;_proto.gc=function gc(){var objects=ObjectValues(this._refObjectPool);for(var i=0,len=objects.length;i<len;i++){if(!objects[i].isGCIgnored){objects[i].destroy();}}}/**
     * Get asset url from instanceId.
     * @param instanceId - Engine instance id
     * @returns Asset url
     */;_proto.getAssetPath=function getAssetPath(instanceId){return this._assetPool[instanceId];}/**
     * @internal
     */;_proto._addAsset=function _addAsset(path,asset){this._assetPool[asset.instanceId]=path;this._assetUrlPool[path]=asset;}/**
     * @internal
     */;_proto._deleteAsset=function _deleteAsset(asset){var id=asset.instanceId;var path=this._assetPool[id];if(path){delete this._assetPool[id];delete this._assetUrlPool[path];}}/**
     * @internal
     */;_proto._addRefObject=function _addRefObject(id,asset){this._refObjectPool[id]=asset;}/**
     * @internal
     */;_proto._deleteRefObject=function _deleteRefObject(id){delete this._refObjectPool[id];};_proto._assignDefaultOptions=function _assignDefaultOptions(assetInfo){var _assetInfo$type,_assetInfo$retryCount,_assetInfo$timeout,_assetInfo$retryInter,_assetInfo$url;assetInfo.type=(_assetInfo$type=assetInfo.type)!=null?_assetInfo$type:ResourceManager._getTypeByUrl(assetInfo.url);if(assetInfo.type===undefined){throw "asset type should be specified: "+assetInfo.url;}assetInfo.retryCount=(_assetInfo$retryCount=assetInfo.retryCount)!=null?_assetInfo$retryCount:this.retryCount;assetInfo.timeout=(_assetInfo$timeout=assetInfo.timeout)!=null?_assetInfo$timeout:this.timeout;assetInfo.retryInterval=(_assetInfo$retryInter=assetInfo.retryInterval)!=null?_assetInfo$retryInter:this.retryInterval;assetInfo.url=(_assetInfo$url=assetInfo.url)!=null?_assetInfo$url:assetInfo.urls.join(",");return assetInfo;};_proto._loadSingleItem=function _loadSingleItem(item){var _this3=this;var info=this._assignDefaultOptions(typeof item==="string"?{url:item}:item);var url=info.url;// has cache
  if(this._assetUrlPool[url]){return new AssetPromise(function(resolve){resolve(_this3._assetUrlPool[url]);});}// loading
  if(this._loadingPromises[url]){return this._loadingPromises[info.url];}var loader=ResourceManager._loaders[info.type];var promise=loader.load(info,this);this._loadingPromises[url]=promise;promise.then(function(res){if(loader.useCache)_this3._addAsset(url,res);delete _this3._loadingPromises[url];}).catch(function(){});return promise;};return ResourceManager;}();/**
   * Declare ResourceLoader's decorator.
   * @param assetType - Type of asset
   * @param extnames - Name of file extension
   */ResourceManager._loaders={};ResourceManager._extTypeMapping={};function resourceLoader(assetType,extnames,useCache){if(useCache===void 0){useCache=true;}return function(Target){var loader=new Target(useCache);ResourceManager._addLoader(assetType,loader,extnames);};}/** Event Object. * @class */var Event=/*#__PURE__*/function(){function Event(type,target,data,bubbles){if(target===void 0){target=null;}if(data===void 0){data={};}if(bubbles===void 0){bubbles=true;}this.data=void 0;this._timeStamp=void 0;this._target=void 0;this._currentTarget=void 0;this._bubbles=void 0;this._propagationStopped=void 0;this._type=void 0;this._timeStamp=new Date().getTime();this._target=target;this.data=data;this._currentTarget=null;this._bubbles=bubbles;this._propagationStopped=false;this._type=type;}var _proto=Event.prototype;_proto.stopPropagation=function stopPropagation(){this._propagationStopped=true;};_createClass$3(Event,[{key:"propagationStopped",get:function get(){return this._propagationStopped;}},{key:"target",get:function get(){return this._target;},set:function set(t){this._target=t;}},{key:"timeStamp",get:function get(){return this._timeStamp;}},{key:"currentTarget",get:function get(){return this._currentTarget;},set:function set(t){this._currentTarget=t;}},{key:"bubbles",get:function get(){return this._bubbles;}},{key:"type",get:function get(){return this._type;}}]);return Event;}();/**
   * Clone mode.
   */var CloneMode;(function(CloneMode){CloneMode[CloneMode["Ignore"]=0]="Ignore";CloneMode[CloneMode["Assignment"]=1]="Assignment";CloneMode[CloneMode["Shallow"]=2]="Shallow";CloneMode[CloneMode["Deep"]=3]="Deep";})(CloneMode||(CloneMode={}));/**
   * Property decorator, ignore the property when cloning.
   */function ignoreClone(target,propertyKey){CloneManager.registerCloneMode(target,propertyKey,CloneMode.Ignore);}/**
   * Property decorator, assign value to the property when cloning.
   *
   * @remarks
   * If it's a primitive type, the value will be copied.
   * If it's a class type, the reference will be copied.
   */function assignmentClone(target,propertyKey){CloneManager.registerCloneMode(target,propertyKey,CloneMode.Assignment);}/**
   * Property decorator, shallow clone the property when cloning.
   * After cloning, it will keep its own reference independent, and use the method of assignment to clone all its internal properties.
   * if the internal property is a primitive type, the value will be copied, if the internal property is a reference type, its reference address will be copied.。
   *
   * @remarks
   * Applicable to Object, Array, TypedArray and Class types.
   */function shallowClone(target,propertyKey){CloneManager.registerCloneMode(target,propertyKey,CloneMode.Shallow);}/**
   * Property decorator, deep clone the property when cloning.
   * After cloning, it will maintain its own reference independence, and all its internal deep properties will remain completely independent.
   *
   * @remarks
   * Applicable to Object, Array, TypedArray and Class types.
   * If Class is encountered during the deep cloning process, the custom cloning function of the object will be called first.
   * Custom cloning requires the object to implement the IClone interface.
   */function deepClone(target,propertyKey){CloneManager.registerCloneMode(target,propertyKey,CloneMode.Deep);}/**
   * @internal
   * Clone manager.
   */var CloneManager=/*#__PURE__*/function(){function CloneManager(){}/** @internal */ /** @internal */ /**
     * Register clone mode.
     * @param target - Clone target
     * @param propertyKey - Clone property name
     * @param mode - Clone mode
     */CloneManager.registerCloneMode=function registerCloneMode(target,propertyKey,mode){var targetMap=CloneManager._subCloneModeMap.get(target.constructor);if(!targetMap){targetMap=Object.create(null);CloneManager._subCloneModeMap.set(target.constructor,targetMap);}targetMap[propertyKey]=mode;}/**
     * Get the clone mode according to the prototype chain.
     */;CloneManager.getCloneMode=function getCloneMode(type){var cloneModes=CloneManager._cloneModeMap.get(type);if(!cloneModes){cloneModes=Object.create(null);CloneManager._cloneModeMap.set(type,cloneModes);var objectType=CloneManager._objectType;var cloneModeMap=CloneManager._subCloneModeMap;while(type!==objectType){var subCloneModes=cloneModeMap.get(type);if(subCloneModes){_extends$1(cloneModes,subCloneModes);}type=Object.getPrototypeOf(type);}}return cloneModes;}/**
     * Deep clone the object.
     * @param source - Clone source
     * @param target - Clone target
     */;CloneManager.deepCloneObject=function deepCloneObject(source,target){var type=source.constructor;switch(type){case Uint8Array:case Uint16Array:case Uint32Array:case Int8Array:case Int16Array:case Int32Array:case Float32Array:case Float64Array:// Type array clone.
  target.set(source);break;case Array:// Array clone.
  for(var i=0,n=source.length;i<n;i++){CloneManager._deepCloneObjectItem(source,target,i);}break;default:var customSource=source;if(customSource.clone&&customSource.cloneTo){// Custom clone.
  customSource.cloneTo(target);}else {// Object or other class not implements custom clone.
  var keys=Object.keys(source);for(var _i=0,_n=keys.length;_i<_n;_i++){CloneManager._deepCloneObjectItem(source,target,keys[_i]);}}}};CloneManager._deepCloneObjectItem=function _deepCloneObjectItem(source,target,k){var sourceItem=source[k];if(sourceItem instanceof Object){var itemType=sourceItem.constructor;switch(itemType){case Uint8Array:case Uint16Array:case Uint32Array:case Int8Array:case Int16Array:case Int32Array:case Float32Array:case Float64Array:// Type array clone.
  var sourceTypeArrayItem=sourceItem;var targetTypeArrayItem=target[k];if(targetTypeArrayItem==null){target[k]=sourceTypeArrayItem.slice();}else {targetTypeArrayItem.set(sourceTypeArrayItem);}break;case Array:// Array clone.
  var sourceArrayItem=sourceItem;var targetArrayItem=target[k];if(targetArrayItem==null){target[k]=new Array(sourceArrayItem.length);}else {targetArrayItem.length=sourceArrayItem.length;}CloneManager.deepCloneObject(sourceArrayItem,targetArrayItem);break;default:if(sourceItem.clone&&sourceItem.cloneTo){// Custom clone.
  var sourceCustomItem=sourceItem;var targetCustomItem=target[k];if(targetCustomItem){sourceCustomItem.cloneTo(targetCustomItem);}else {target[k]=sourceCustomItem.clone();}}else {// Object or other class not implements custom clone.
  var targetItem=target[k];targetItem==null&&(target[k]=targetItem=new sourceItem.constructor());CloneManager.deepCloneObject(sourceItem,targetItem);break;}}}else {// Null or undefined and primitive type.
  target[k]=sourceItem;}};return CloneManager;}();CloneManager._subCloneModeMap=new Map();CloneManager._cloneModeMap=new Map();CloneManager._objectType=Object.getPrototypeOf(Object);var _class$b$1,_descriptor$b,_descriptor2$a,_class2$8,_temp$8;/**
   * EngineObject.
   */var EngineObject=(_class$b$1=(_temp$8=_class2$8=/*#__PURE__*/function(){function EngineObject(engine){_initializerDefineProperty(this,"instanceId",_descriptor$b,this);_initializerDefineProperty(this,"_engine",_descriptor2$a,this);this._engine=engine;}_createClass$3(EngineObject,[{key:"engine",get:/** Engine unique id. */ /** Engine to which the object belongs. */ /**
       * Get the engine which the object belongs.
       */function get(){return this._engine;}}]);return EngineObject;}(),_class2$8._instanceIdCounter=0,_temp$8),(_descriptor$b=_applyDecoratedDescriptor$1(_class$b$1.prototype,"instanceId",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return ++EngineObject._instanceIdCounter;}}),_descriptor2$a=_applyDecoratedDescriptor$1(_class$b$1.prototype,"_engine",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null})),_class$b$1);var _class$a$1,_descriptor$a;/**
   * EventDispatcher, which can be inherited as a base class.
   */var EventDispatcher=(_class$a$1=/*#__PURE__*/function(_EngineObject){_inheritsLoose$2(EventDispatcher,_EngineObject);function EventDispatcher(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_EngineObject.call.apply(_EngineObject,[this].concat(args))||this;_initializerDefineProperty(_this,"_evts",_descriptor$a,_assertThisInitialized$1(_this));_this._evtCount=0;return _this;}var _proto=EventDispatcher.prototype;/**
     * Determine whether there is event listening.
     * @param event - Event name
     * @returns Returns whether there is a corresponding event
     */_proto.hasEvent=function hasEvent(event){return this._evts[event]!=null;}/**
     * Returns the names of all registered events.
     * @returns All event names
     */;_proto.eventNames=function eventNames(){if(this._evtCount===0)return [];return Object.keys(this._evts);}/**
     * Returns the number of listeners with the specified event name.
     * @param event - Event name
     * @returns The count of listeners
     */;_proto.listenerCount=function listenerCount(event){var listeners=this._evts[event];if(!listeners)return 0;if(listeners.fn)return 1;return listeners.length;}/**
     * Dispatch the event with the specified event name.
     * @param event - Event name
     * @param data - Data
     * @returns - Whether the dispatching is successful
     */;_proto.dispatch=function dispatch(event,data){if(!this._evts[event]){return false;}var listeners=this._evts[event];if(listeners.fn){if(listeners.once)this.removeEventListener(event,listeners.fn);listeners.fn(data);}else {var l=listeners.length;for(var i=0;i<l;i++){if(listeners[i].once)this.removeEventListener(event,listeners[i].fn);listeners[i].fn(data);}}return true;}/**
     * Add a listener/
     * @param event - Event name
     * @param fn - Function
     * @returns This
     */;_proto.on=function on(event,fn){return this.addEventListener(event,fn);}/**
     * Add a one-time listener.
     * @param event - Event name
     * @param fn - Function
     * @returns This
     */;_proto.once=function once(event,fn){return this.addEventListener(event,fn,true);}/**
     * @deprecated Use `on/once` instead.
     * Add a listener function with the specified event name.
     * @param event - Event name
     * @param fn - Function
     * @param once - Is it a one-time listener
     * @returns this
     */;_proto.addEventListener=function addEventListener(event,fn,once){var listener={fn:fn,once:once};var events=this._evts;if(!events[event]){events[event]=listener;this._evtCount++;}else if(!events[event].fn){events[event].push(listener);}else {events[event]=[events[event],listener];}return this;}/**
     * Remove the event listener(s) of the specified event name.
     * @param event - Event name
     * @param fn - Function, If is undefined, delete all corresponding event listeners.
     */;_proto.off=function off(event,fn){if(!this._evts[event])return this;if(!fn){this._clearEvent(event);return this;}var listeners=this._evts[event];if(listeners.fn&&listeners.fn===fn){this._clearEvent(event);}else {var index=listeners.indexOf(fn);if(index>-1){var temp=listeners[listeners.length-1];listeners[index]=temp;listeners.length--;if(listeners.length===1){this._evts[event]=listeners[0];}}}return this;}/**
     * @deprecated Use `off` instead.
     * Remove the event listener(s) of the specified event name.
     * @param event - Event name
     * @param fn - Function, If is undefined, delete all corresponding event listeners.
     */;_proto.removeEventListener=function removeEventListener(event,fn){return this.off(event,fn);}/**
     * Remove all event listeners.
     * @param event - Event name, delete all events if not passed
     */;_proto.removeAllEventListeners=function removeAllEventListeners(event){if(event){if(this._evts[event])this._clearEvent(event);}else {this._evts=Object.create(null);this._evtCount=0;}}/**
     * @deprecated Use `dispatch` instead.
     */;_proto.trigger=function trigger(e){this.dispatch(e.type,e.data);};_proto._clearEvent=function _clearEvent(event){if(--this._evtCount===0){this._evts=Object.create(null);}else {delete this._evts[event];}};return EventDispatcher;}(EngineObject),_descriptor$a=_applyDecoratedDescriptor$1(_class$a$1.prototype,"_evts",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return Object.create(null);}}),_class$a$1);/**
   * @class
   * @private
   */ /* tslint:disable */var noop=function noop(message){};var debug=console.log.bind(console);var info=console.info.bind(console);var warn=console.warn.bind(console);var error=console.error.bind(console);var Logger={debug:noop,info:noop,warn:noop,error:noop,isEnabled:false,/** Turn on log */enable:function enable(){this.debug=debug;this.info=info;this.warn=warn;this.error=error;this.isEnabled=true;},/** Turn off log */disable:function disable(){this.debug=noop;this.info=noop;this.warn=noop;this.error=noop;this.isEnabled=false;}};/**
   * Tools for calculating the time per frame.
   */var Time=/*#__PURE__*/function(){/**
     * Constructor of the Time.
     */function Time(){this._clock=void 0;this._timeScale=void 0;this._deltaTime=void 0;this._startTime=void 0;this._lastTickTime=void 0;this._clock=performance?performance:Date;this._timeScale=1.0;this._deltaTime=0.0001;var now=this._clock.now();this._startTime=now;this._lastTickTime=now;}var _proto=Time.prototype;_proto.reset=function reset(){this._lastTickTime=this._clock.now();}/**
     * Current Time
     */;/**
     * Call every frame, update delta time and other data.
     */_proto.tick=function tick(){var now=this.nowTime;this._deltaTime=(now-this._lastTickTime)*this._timeScale;this._lastTickTime=now;};_createClass$3(Time,[{key:"nowTime",get:function get(){return this._clock.now();}/**
       * Time between two ticks
       */},{key:"deltaTime",get:function get(){return this._deltaTime;}/**
       * Scaled delta time.
       */},{key:"timeScale",get:function get(){return this._timeScale;},set:function set(s){this._timeScale=s;}/**
       * Unscaled delta time.
       */},{key:"unscaledDeltaTime",get:function get(){return this._deltaTime/this._timeScale;}/**
       * The elapsed time, after the clock is initialized.
       */},{key:"timeSinceStartup",get:function get(){return this.nowTime-this._startTime;}}]);return Time;}();/**
   * Data type enumeration
   */exports.DataType = void 0;/**
   * GL Capabilities
   * Some capabilities can be smoothed out by extension, and some capabilities must use WebGL 2.0.
   * */(function(DataType){DataType[DataType["FLOAT"]=5126]="FLOAT";DataType[DataType["FLOAT_VEC2"]=35664]="FLOAT_VEC2";DataType[DataType["FLOAT_VEC3"]=35665]="FLOAT_VEC3";DataType[DataType["FLOAT_VEC4"]=35666]="FLOAT_VEC4";DataType[DataType["INT"]=5124]="INT";DataType[DataType["INT_VEC2"]=35667]="INT_VEC2";DataType[DataType["INT_VEC3"]=35668]="INT_VEC3";DataType[DataType["INT_VEC4"]=35669]="INT_VEC4";DataType[DataType["BOOL"]=35670]="BOOL";DataType[DataType["BOOL_VEC2"]=35671]="BOOL_VEC2";DataType[DataType["BOOL_VEC3"]=35672]="BOOL_VEC3";DataType[DataType["BOOL_VEC4"]=35673]="BOOL_VEC4";DataType[DataType["FLOAT_MAT2"]=35674]="FLOAT_MAT2";DataType[DataType["FLOAT_MAT3"]=35675]="FLOAT_MAT3";DataType[DataType["FLOAT_MAT4"]=35676]="FLOAT_MAT4";DataType[DataType["FLOAT_ARRAY"]=35677]="FLOAT_ARRAY";DataType[DataType["FLOAT_VEC2_ARRAY"]=100000]="FLOAT_VEC2_ARRAY";DataType[DataType["FLOAT_VEC3_ARRAY"]=100001]="FLOAT_VEC3_ARRAY";DataType[DataType["FLOAT_VEC4_ARRAY"]=100002]="FLOAT_VEC4_ARRAY";DataType[DataType["INT_ARRAY"]=100003]="INT_ARRAY";DataType[DataType["INT_VEC2_ARRAY"]=100004]="INT_VEC2_ARRAY";DataType[DataType["INT_VEC3_ARRAY"]=100005]="INT_VEC3_ARRAY";DataType[DataType["INT_VEC4_ARRAY"]=100006]="INT_VEC4_ARRAY";DataType[DataType["FLOAT_MAT2_ARRAY"]=100007]="FLOAT_MAT2_ARRAY";DataType[DataType["FLOAT_MAT3_ARRAY"]=100008]="FLOAT_MAT3_ARRAY";DataType[DataType["FLOAT_MAT4_ARRAY"]=100009]="FLOAT_MAT4_ARRAY";DataType[DataType["SAMPLER_2D_ARRAY"]=100010]="SAMPLER_2D_ARRAY";DataType[DataType["SAMPLER_CUBE_ARRAY"]=100011]="SAMPLER_CUBE_ARRAY";DataType[DataType["SAMPLER_2D"]=35678]="SAMPLER_2D";DataType[DataType["SAMPLER_CUBE"]=35680]="SAMPLER_CUBE";DataType[DataType["BYTE"]=5120]="BYTE";DataType[DataType["UNSIGNED_BYTE"]=5121]="UNSIGNED_BYTE";DataType[DataType["SHORT"]=5122]="SHORT";DataType[DataType["UNSIGNED_SHORT"]=5123]="UNSIGNED_SHORT";DataType[DataType["UNSIGNED_INT"]=5125]="UNSIGNED_INT";})(exports.DataType||(exports.DataType={}));exports.GLCapabilityType = void 0;(function(GLCapabilityType){GLCapabilityType["shaderVertexID"]="shaderVertexID";GLCapabilityType["standardDerivatives"]="OES_standard_derivatives";GLCapabilityType["shaderTextureLod"]="EXT_shader_texture_lod";GLCapabilityType["elementIndexUint"]="OES_element_index_uint";GLCapabilityType["depthTexture"]="WEBGL_depth_texture";GLCapabilityType["drawBuffers"]="WEBGL_draw_buffers";GLCapabilityType["vertexArrayObject"]="OES_vertex_array_object";GLCapabilityType["instancedArrays"]="ANGLE_instanced_arrays";GLCapabilityType["multipleSample"]="multipleSampleOnlySupportedInWebGL2";GLCapabilityType["textureFloat"]="OES_texture_float";GLCapabilityType["textureFloatLinear"]="OES_texture_float_linear";GLCapabilityType["textureHalfFloat"]="OES_texture_half_float";GLCapabilityType["textureHalfFloatLinear"]="OES_texture_half_float_linear";GLCapabilityType["WEBGL_colorBufferFloat"]="WEBGL_color_buffer_float";GLCapabilityType["colorBufferFloat"]="EXT_color_buffer_float";GLCapabilityType["colorBufferHalfFloat"]="EXT_color_buffer_half_float";GLCapabilityType["textureFilterAnisotropic"]="EXT_texture_filter_anisotropic";GLCapabilityType["blendMinMax"]="EXT_blend_minmax";GLCapabilityType["astc"]="WEBGL_compressed_texture_astc";GLCapabilityType["astc_webkit"]="WEBKIT_WEBGL_compressed_texture_astc";GLCapabilityType["etc"]="WEBGL_compressed_texture_etc";GLCapabilityType["etc_webkit"]="WEBKIT_WEBGL_compressed_texture_etc";GLCapabilityType["etc1"]="WEBGL_compressed_texture_etc1";GLCapabilityType["etc1_webkit"]="WEBKIT_WEBGL_compressed_texture_etc1";GLCapabilityType["pvrtc"]="WEBGL_compressed_texture_pvrtc";GLCapabilityType["pvrtc_webkit"]="WEBKIT_WEBGL_compressed_texture_pvrtc";GLCapabilityType["s3tc"]="WEBGL_compressed_texture_s3tc";GLCapabilityType["s3tc_webkit"]="WEBKIT_WEBGL_compressed_texture_s3tc";})(exports.GLCapabilityType||(exports.GLCapabilityType={}));/**
   * High-performance unordered array, delete uses exchange method to improve performance, internal capacity only increases.
   */var DisorderedArray=/*#__PURE__*/function(){function DisorderedArray(count){if(count===void 0){count=0;}this._elements=void 0;this.length=0;this._elements=new Array(count);}var _proto=DisorderedArray.prototype;_proto.add=function add(element){if(this.length===this._elements.length)this._elements.push(element);else this._elements[this.length]=element;this.length++;};_proto.delete=function _delete(element){//TODO: It can be optimized for custom binary search and other algorithms, currently this._elements>=this.length wastes performance.
  var index=this._elements.indexOf(element);this.deleteByIndex(index);};_proto.get=function get(index){if(index>=this.length){throw "Index is out of range.";}return this._elements[index];}/**
     *
     * @param index
     * @returns The replaced item is used to reset its index.
     */;_proto.deleteByIndex=function deleteByIndex(index){var elements=this._elements;var end=null;var lastIndex=this.length-1;if(index!==lastIndex){end=elements[lastIndex];elements[index]=end;}this.length--;return end;};_proto.garbageCollection=function garbageCollection(){this._elements.length=this.length;};return DisorderedArray;}();/**
   * Shader macro collection.
   * @internal
   */var ShaderMacroCollection=/*#__PURE__*/function(){function ShaderMacroCollection(){this._mask=[];this._length=0;}/**
     * Union of two macro collection.
     * @param left - input macro collection
     * @param right - input macro collection
     * @param out - union output macro collection
     */ShaderMacroCollection.unionCollection=function unionCollection(left,right,out){var outMask=out._mask;var minSize,maxSize;var minMask,maxMask;if(left._length<right._length){minSize=left._length;maxSize=right._length;minMask=left._mask;maxMask=right._mask;}else {minSize=right._length;maxSize=left._length;minMask=right._mask;maxMask=left._mask;}var i=0;outMask.length<maxSize&&(outMask.length=maxSize);for(;i<minSize;i++){outMask[i]=minMask[i]|maxMask[i];}for(;i<maxSize;i++){outMask[i]=maxMask[i];}out._length=maxSize;}/** @internal */;var _proto=ShaderMacroCollection.prototype;/**
     * Enable one macro in this macro collection.
     * @param macro - ShaderMacro
     */_proto.enable=function enable(macro){var index=macro._index;var size=index+1;var mask=this._mask;var maskStart=this._length;// must from this._length because this._length maybe less than mask.length and have dirty data should clear.
  if(maskStart<size){mask.length<size&&(mask.length=size);// mask.length maybe small than size,maybe not.
  for(;maskStart<index;maskStart++){mask[maskStart]=0;}mask[index]=macro._value;this._length=size;}else {mask[index]|=macro._value;}}/**
     * Disable one macro in this macro collection.
     * @param macro - ShaderMacro
     */;_proto.disable=function disable(macro){var index=macro._index;var mask=this._mask;var endIndex=this._length-1;if(index>endIndex){return;}var newValue=mask[index]&~macro._value;if(index==endIndex&&newValue===0){this._length--;}else {mask[index]=newValue;}}/**
     * Union of this and other macro collection.
     * @param macroCollection - macro collection
     */;_proto.unionCollection=function unionCollection(macroCollection){var addMask=macroCollection._mask;var addSize=macroCollection._length;var mask=this._mask;var maskSize=this._length;if(maskSize<addSize){mask.length<addSize&&(mask.length=addSize);var i=0;for(;i<maskSize;i++){mask[i]|=addMask[i];}for(;i<addSize;i++){mask[i]=addMask[i];}this._length=addSize;}else {for(var _i=0;_i<addSize;_i++){mask[_i]|=addMask[_i];}}}/**
     * Complementarity of this and other macro collection.
     * @param macroCollection - macro collection
     */;_proto.complementaryCollection=function complementaryCollection(macroCollection){var removeMask=macroCollection._mask;var mask=this._mask;var endIndex=this._length-1;var i=Math.min(macroCollection._length-1,endIndex);for(;i>=0;i--){var newValue=mask[i]&~removeMask[i];if(i==endIndex&&newValue===0){endIndex--;this._length--;}else {mask[i]=newValue;}}}/**
     * Intersection of this and other macro collection.
     * @param macroCollection - macro collection
     */;_proto.intersectionCollection=function intersectionCollection(macroCollection){var unionMask=macroCollection._mask;var mask=this._mask;for(var i=this._length-1;i>=0;i--){var value=mask[i]&unionMask[i];if(value==0&&i==this._length-1){this._length--;}else {mask[i]=value;}}}/**
     * Whether macro is enabled in this macro collection.
     * @param macro - ShaderMacro
     */;_proto.isEnable=function isEnable(macro){var index=macro._index;if(index>=this._length){return false;}return (this._mask[index]&macro._value)!==0;}/**
     * Clear this macro collection.
     */;_proto.clear=function clear(){this._length=0;};return ShaderMacroCollection;}();/**
   * The manager of the components.
   */var ComponentsManager=/*#__PURE__*/function(){function ComponentsManager(){this._onStartScripts=new DisorderedArray();this._onUpdateScripts=new DisorderedArray();this._onLateUpdateScripts=new DisorderedArray();this._destroyComponents=[];this._onUpdateAnimations=new DisorderedArray();this._renderers=new DisorderedArray();this._onUpdateRenderers=new DisorderedArray();this._componentsContainerPool=[];}var _proto=ComponentsManager.prototype;_proto.addRenderer=function addRenderer(renderer){renderer._rendererIndex=this._renderers.length;this._renderers.add(renderer);};_proto.removeRenderer=function removeRenderer(renderer){var replaced=this._renderers.deleteByIndex(renderer._rendererIndex);replaced&&(replaced._rendererIndex=renderer._rendererIndex);renderer._rendererIndex=-1;};_proto.addOnStartScript=function addOnStartScript(script){script._onStartIndex=this._onStartScripts.length;this._onStartScripts.add(script);};_proto.removeOnStartScript=function removeOnStartScript(script){var replaced=this._onStartScripts.deleteByIndex(script._onStartIndex);replaced&&(replaced._onStartIndex=script._onStartIndex);script._onStartIndex=-1;};_proto.addOnUpdateScript=function addOnUpdateScript(script){script._onUpdateIndex=this._onUpdateScripts.length;this._onUpdateScripts.add(script);};_proto.removeOnUpdateScript=function removeOnUpdateScript(script){var replaced=this._onUpdateScripts.deleteByIndex(script._onUpdateIndex);replaced&&(replaced._onUpdateIndex=script._onUpdateIndex);script._onUpdateIndex=-1;};_proto.addOnLateUpdateScript=function addOnLateUpdateScript(script){script._onLateUpdateIndex=this._onLateUpdateScripts.length;this._onLateUpdateScripts.add(script);};_proto.removeOnLateUpdateScript=function removeOnLateUpdateScript(script){var replaced=this._onLateUpdateScripts.deleteByIndex(script._onLateUpdateIndex);replaced&&(replaced._onLateUpdateIndex=script._onLateUpdateIndex);script._onLateUpdateIndex=-1;};_proto.addOnUpdateAnimations=function addOnUpdateAnimations(animation){//@ts-ignore
  animation._onUpdateIndex=this._onUpdateAnimations.length;this._onUpdateAnimations.add(animation);};_proto.removeOnUpdateAnimations=function removeOnUpdateAnimations(animation){//@ts-ignore
  var replaced=this._onUpdateAnimations.deleteByIndex(animation._onUpdateIndex);//@ts-ignore
  replaced&&(replaced._onUpdateIndex=animation._onUpdateIndex);//@ts-ignore
  animation._onUpdateIndex=-1;};_proto.addOnUpdateRenderers=function addOnUpdateRenderers(renderer){renderer._onUpdateIndex=this._onUpdateRenderers.length;this._onUpdateRenderers.add(renderer);};_proto.removeOnUpdateRenderers=function removeOnUpdateRenderers(renderer){var replaced=this._onUpdateRenderers.deleteByIndex(renderer._onUpdateIndex);replaced&&(replaced._onUpdateIndex=renderer._onUpdateIndex);renderer._onUpdateIndex=-1;};_proto.addDestroyComponent=function addDestroyComponent(component){this._destroyComponents.push(component);};_proto.callScriptOnStart=function callScriptOnStart(){var onStartScripts=this._onStartScripts;if(onStartScripts.length>0){var elements=onStartScripts._elements;// The 'onStartScripts.length' maybe add if you add some Script with addComponent() in some Script's onStart()
  for(var i=0;i<onStartScripts.length;i++){var script=elements[i];script._started=true;script._onStartIndex=-1;script.onStart();}onStartScripts.length=0;}};_proto.callScriptOnUpdate=function callScriptOnUpdate(deltaTime){var elements=this._onUpdateScripts._elements;for(var i=this._onUpdateScripts.length-1;i>=0;--i){var element=elements[i];if(element._started){element.onUpdate(deltaTime);}}};_proto.callScriptOnLateUpdate=function callScriptOnLateUpdate(deltaTime){var elements=this._onLateUpdateScripts._elements;for(var i=this._onLateUpdateScripts.length-1;i>=0;--i){var element=elements[i];if(element._started){element.onLateUpdate(deltaTime);}}};_proto.callAnimationUpdate=function callAnimationUpdate(deltaTime){var elements=this._onUpdateAnimations._elements;for(var i=this._onUpdateAnimations.length-1;i>=0;--i){//@ts-ignore
  elements[i].update(deltaTime);}};_proto.callRendererOnUpdate=function callRendererOnUpdate(deltaTime){var elements=this._onUpdateRenderers._elements;for(var i=this._onUpdateRenderers.length-1;i>=0;--i){elements[i].update(deltaTime);}};_proto.callRender=function callRender(context){var camera=context._camera;var elements=this._renderers._elements;for(var i=this._renderers.length-1;i>=0;--i){var element=elements[i];// filter by camera culling mask.
  if(!(camera.cullingMask&element._entity.layer)){continue;}// filter by camera frustum.
  if(camera.enableFrustumCulling){element.isCulled=!camera._frustum.intersectsBox(element.bounds);if(element.isCulled){continue;}}var transform=camera.entity.transform;var position=transform.worldPosition;var center=element.bounds.getCenter(ComponentsManager._tempVector0);if(camera.isOrthographic){var forward=transform.getWorldForward(ComponentsManager._tempVector1);Vector3.subtract(center,position,center);element._distanceForSort=Vector3.dot(center,forward);}else {element._distanceForSort=Vector3.distanceSquared(center,position);}element._updateShaderData(context);element._render(camera);// union camera global macro and renderer macro.
  ShaderMacroCollection.unionCollection(camera._globalShaderMacro,element.shaderData._macroCollection,element._globalShaderMacro);}};_proto.callComponentDestroy=function callComponentDestroy(){var destroyComponents=this._destroyComponents;var length=destroyComponents.length;if(length>0){for(var i=length-1;i>=0;--i){destroyComponents[i].onDestroy();}destroyComponents.length=0;}};_proto.callCameraOnBeginRender=function callCameraOnBeginRender(camera){var camComps=camera.entity._components;for(var i=camComps.length-1;i>=0;--i){var camComp=camComps[i];camComp.onBeginRender&&camComp.onBeginRender(camera);}};_proto.callCameraOnEndRender=function callCameraOnEndRender(camera){var camComps=camera.entity._components;for(var i=camComps.length-1;i>=0;--i){var camComp=camComps[i];camComp.onBeginRender&&camComp.onEndRender(camera);}};_proto.getActiveChangedTempList=function getActiveChangedTempList(){return this._componentsContainerPool.length?this._componentsContainerPool.pop():[];};_proto.putActiveChangedTempList=function putActiveChangedTempList(componentContainer){componentContainer.length=0;this._componentsContainerPool.push(componentContainer);};return ComponentsManager;}();ComponentsManager._tempVector0=new Vector3();ComponentsManager._tempVector1=new Vector3();/**
   * Custom clone interface.
   */var ComponentCloner=/*#__PURE__*/function(){function ComponentCloner(){}/**
     * Clone component.
     * @param source - Clone source
     * @param target - Clone target
     */ComponentCloner.cloneComponent=function cloneComponent(source,target){var cloneModes=CloneManager.getCloneMode(source.constructor);var keys=Object.keys(source);for(var i=0,n=keys.length;i<n;i++){var k=keys[i];var cloneMode=cloneModes[k];switch(cloneMode){case undefined:case CloneMode.Assignment:target[k]=source[k];break;case CloneMode.Shallow:var sourcePropS=source[k];if(sourcePropS instanceof Object){var tarProp=target[k];tarProp==null&&(tarProp=target[k]=sourcePropS.constructor());_extends$1(tarProp,sourcePropS);}else {// Null or undefined and primitive type.
  target[k]=sourcePropS;}break;case CloneMode.Deep:var sourcePropD=source[k];if(sourcePropD instanceof Object){var _tarProp=target[k];_tarProp==null&&(_tarProp=target[k]=sourcePropD.constructor());CloneManager.deepCloneObject(sourcePropD,_tarProp);}else {// Null or undefined and primitive type.
  target[k]=sourcePropD;}break;}}if(source._cloneTo){source._cloneTo(target);}};return ComponentCloner;}();/**
   * Used for component dependency registration.
   */var ComponentsDependencies=/*#__PURE__*/function(){/**
     * @internal
     */ /**
     * Register component dependencies.
     * @param currentComponent - The component you want to be register.
     * @param dependentComponent - The component's dependencies.
     */ComponentsDependencies.register=function register(currentComponent,dependentComponent){this._addDependency(currentComponent,dependentComponent,this._dependenciesMap);this._addDependency(dependentComponent,currentComponent,this._invDependenciesMap);}/**
     * @internal
     */;ComponentsDependencies._addCheck=function _addCheck(entity,type){// Check if there are dependent components.
  var dependencies=ComponentsDependencies._dependenciesMap.get(type);if(dependencies){for(var i=0,len=dependencies.length;i<len;i++){if(!entity.getComponent(dependencies[i])){throw "you should add "+dependencies[i]+" before adding "+type;}}}}/**
     * @internal
     */;ComponentsDependencies._removeCheck=function _removeCheck(entity,type){var invDependencies=ComponentsDependencies._invDependenciesMap.get(type);if(invDependencies){for(var i=0,len=invDependencies.length;i<len;i++){if(entity.getComponent(invDependencies[i])){throw "you should remove "+invDependencies[i]+" before adding "+type;}}}};ComponentsDependencies._addDependency=function _addDependency(currentComponent,dependentComponent,map){var components=map.get(currentComponent);if(!components){components=[];map.set(currentComponent,components);}if(components.indexOf(dependentComponent)===-1){components.push(dependentComponent);}};function ComponentsDependencies(){}return ComponentsDependencies;}();ComponentsDependencies._dependenciesMap=new Map();ComponentsDependencies._invDependenciesMap=new Map();function dependencies(){for(var _len=arguments.length,abilityClass=new Array(_len),_key=0;_key<_len;_key++){abilityClass[_key]=arguments[_key];}return function(target){abilityClass.forEach(function(ability){return ComponentsDependencies.register(target,ability);});};}/**
   * Layer, used for bit operations.
   */exports.Layer = void 0;(function(Layer){Layer[Layer["Layer0"]=1]="Layer0";Layer[Layer["Layer1"]=2]="Layer1";Layer[Layer["Layer2"]=4]="Layer2";Layer[Layer["Layer3"]=8]="Layer3";Layer[Layer["Layer4"]=16]="Layer4";Layer[Layer["Layer5"]=32]="Layer5";Layer[Layer["Layer6"]=64]="Layer6";Layer[Layer["Layer7"]=128]="Layer7";Layer[Layer["Layer8"]=256]="Layer8";Layer[Layer["Layer9"]=512]="Layer9";Layer[Layer["Layer10"]=1024]="Layer10";Layer[Layer["Layer11"]=2048]="Layer11";Layer[Layer["Layer12"]=4096]="Layer12";Layer[Layer["Layer13"]=8192]="Layer13";Layer[Layer["Layer14"]=16384]="Layer14";Layer[Layer["Layer15"]=32768]="Layer15";Layer[Layer["Layer16"]=65536]="Layer16";Layer[Layer["Layer17"]=131072]="Layer17";Layer[Layer["Layer18"]=262144]="Layer18";Layer[Layer["Layer19"]=524288]="Layer19";Layer[Layer["Layer20"]=1048576]="Layer20";Layer[Layer["Layer21"]=2097152]="Layer21";Layer[Layer["Layer22"]=4194304]="Layer22";Layer[Layer["Layer23"]=8388608]="Layer23";Layer[Layer["Layer24"]=16777216]="Layer24";Layer[Layer["Layer25"]=33554432]="Layer25";Layer[Layer["Layer26"]=67108864]="Layer26";Layer[Layer["Layer27"]=134217728]="Layer27";Layer[Layer["Layer28"]=268435456]="Layer28";Layer[Layer["Layer29"]=536870912]="Layer29";Layer[Layer["Layer30"]=1073741824]="Layer30";Layer[Layer["Layer31"]=2147483648]="Layer31";Layer[Layer["Everything"]=4294967295]="Everything";Layer[Layer["Nothing"]=0]="Nothing";})(exports.Layer||(exports.Layer={}));var _class$9$1,_descriptor$9,_descriptor2$9,_descriptor3$8,_descriptor4$8;/**
   * The base class of the components.
   */var Component=(_class$9$1=/*#__PURE__*/function(_EngineObject){_inheritsLoose$2(Component,_EngineObject);function Component(entity){var _this;_this=_EngineObject.call(this,entity.engine)||this;_initializerDefineProperty(_this,"_entity",_descriptor$9,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_destroyed",_descriptor2$9,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_enabled",_descriptor3$8,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_awoken",_descriptor4$8,_assertThisInitialized$1(_this));_this._entity=entity;return _this;}/**
     * Destroy this instance.
     */var _proto=Component.prototype;_proto.destroy=function destroy(){if(this._destroyed){return;}this._entity._removeComponent(this);if(this._entity.isActiveInHierarchy){this._enabled&&this._onDisable();this._onInActive();}this._destroyed=true;this._onDestroy();}/**
     * @internal
     */;_proto._onAwake=function _onAwake(){}/**
     * @internal
     */;_proto._onEnable=function _onEnable(){}/**
     * @internal
     */;_proto._onDisable=function _onDisable(){}/**
     * @internal
     */;_proto._onDestroy=function _onDestroy(){}/**
     * @internal
     */;_proto._onActive=function _onActive(){}/**
     * @internal
     */;_proto._onInActive=function _onInActive(){}/**
     * @internal
     */;_proto._setActive=function _setActive(value){if(value){if(!this._awoken){this._awoken=true;this._onAwake();}// You can do isActive = false in onAwake function.
  if(this._entity._isActiveInHierarchy){this._onActive();this._enabled&&this._onEnable();}}else {this._enabled&&this._onDisable();this._onInActive();}};_createClass$3(Component,[{key:"enabled",get:/** @internal */ /** @internal */ /**
       * Indicates whether the component is enabled.
       */function get(){return this._enabled;},set:function set(value){if(value===this._enabled){return;}this._enabled=value;if(value){this._entity.isActiveInHierarchy&&this._onEnable();}else {this._entity.isActiveInHierarchy&&this._onDisable();}}/**
       * Indicates whether the component is destroyed.
       */},{key:"destroyed",get:function get(){return this._destroyed;}/**
       * The entity which the component belongs to.
       */},{key:"entity",get:function get(){return this._entity;}/**
       * The scene which the component's entity belongs to.
       */},{key:"scene",get:function get(){return this._entity.scene;}}]);return Component;}(EngineObject),(_descriptor$9=_applyDecoratedDescriptor$1(_class$9$1.prototype,"_entity",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor2$9=_applyDecoratedDescriptor$1(_class$9$1.prototype,"_destroyed",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor3$8=_applyDecoratedDescriptor$1(_class$9$1.prototype,"_enabled",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return true;}}),_descriptor4$8=_applyDecoratedDescriptor$1(_class$9$1.prototype,"_awoken",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}})),_class$9$1);/**
   * Used to update tags.
   */var UpdateFlag=/*#__PURE__*/function(){/** Flag. */function UpdateFlag(_flags){if(_flags===void 0){_flags=[];}this._flags=_flags;this.flag=true;this._flags.push(this);}/**
     * Destroy.
     */var _proto=UpdateFlag.prototype;_proto.destroy=function destroy(){var flags=this._flags;removeFromArray(flags,this);this._flags=null;};return UpdateFlag;}();/**
   * @internal
   */var UpdateFlagManager=/*#__PURE__*/function(){function UpdateFlagManager(){this._updateFlags=[];}var _proto=UpdateFlagManager.prototype;_proto.register=function register(){return new UpdateFlag(this._updateFlags);};_proto.distribute=function distribute(){var updateFlags=this._updateFlags;for(var i=updateFlags.length-1;i>=0;i--){updateFlags[i].flag=true;}};return UpdateFlagManager;}();var _class$8$1,_descriptor$8,_descriptor2$8,_descriptor3$7,_descriptor4$7,_descriptor5$7,_descriptor6$7,_descriptor7$5,_descriptor8$3,_descriptor9$3,_descriptor10$3,_descriptor11$3,_descriptor12$3,_descriptor13$2,_class2$7,_temp$7;/**
   * Used to implement transformation related functions.
   */var Transform=(_class$8$1=(_temp$7=_class2$7=/*#__PURE__*/function(_Component){_inheritsLoose$2(Transform,_Component);function Transform(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Component.call.apply(_Component,[this].concat(args))||this;_initializerDefineProperty(_this,"_position",_descriptor$8,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_rotation",_descriptor2$8,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_rotationQuaternion",_descriptor3$7,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_scale",_descriptor4$7,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_worldPosition",_descriptor5$7,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_worldRotation",_descriptor6$7,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_worldRotationQuaternion",_descriptor7$5,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_lossyWorldScale",_descriptor8$3,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_localMatrix",_descriptor9$3,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_worldMatrix",_descriptor10$3,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_updateFlagManager",_descriptor11$3,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_isParentDirty",_descriptor12$3,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_parentTransformCache",_descriptor13$2,_assertThisInitialized$1(_this));_this._dirtyFlag=TransformFlag.WmWpWeWqWs;return _this;}var _proto=Transform.prototype;/**
     * Set local position by X, Y, Z value.
     * @param x - X coordinate
     * @param y - Y coordinate
     * @param z - Z coordinate
     */_proto.setPosition=function setPosition(x,y,z){this._position.setValue(x,y,z);this.position=this._position;}/**
     * Set local rotation by the X, Y, Z components of the euler angle, unit in degrees.
     * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
     * @param x - The angle of rotation around the X axis
     * @param y - The angle of rotation around the Y axis
     * @param z - The angle of rotation around the Z axis
     */;_proto.setRotation=function setRotation(x,y,z){this._rotation.setValue(x,y,z);this.rotation=this._rotation;}/**
     * Set local rotation by the X, Y, Z, and W components of the quaternion.
     * @param x - X component of quaternion
     * @param y - Y component of quaternion
     * @param z - Z component of quaternion
     * @param w - W component of quaternion
     */;_proto.setRotationQuaternion=function setRotationQuaternion(x,y,z,w){this._rotationQuaternion.setValue(x,y,z,w);this.rotationQuaternion=this._rotationQuaternion;}/**
     * Set local scaling by scaling values along X, Y, Z axis.
     * @param x - Scaling along X axis
     * @param y - Scaling along Y axis
     * @param z - Scaling along Z axis
     */;_proto.setScale=function setScale(x,y,z){this._scale.setValue(x,y,z);this.scale=this._scale;}/**
     * Set world position by X, Y, Z value.
     * @param x - X coordinate
     * @param y - Y coordinate
     * @param z - Z coordinate
     */;_proto.setWorldPosition=function setWorldPosition(x,y,z){this._worldPosition.setValue(x,y,z);this.worldPosition=this._worldPosition;}/**
     * Set world rotation by the X, Y, Z components of the euler angle, unit in degrees, Yaw/Pitch/Roll sequence.
     * @param x - The angle of rotation around the X axis
     * @param y - The angle of rotation around the Y axis
     * @param z - The angle of rotation around the Z axis
     */;_proto.setWorldRotation=function setWorldRotation(x,y,z){this._worldRotation.setValue(x,y,z);this.worldRotation=this._worldRotation;}/**
     * Set local rotation by the X, Y, Z, and W components of the quaternion.
     * @param x - X component of quaternion
     * @param y - Y component of quaternion
     * @param z - Z component of quaternion
     * @param w - W component of quaternion
     */;_proto.setWorldRotationQuaternion=function setWorldRotationQuaternion(x,y,z,w){this._worldRotationQuaternion.setValue(x,y,z,w);this.worldRotationQuaternion=this._worldRotationQuaternion;}/**
     * Get the forward direction in world space.
     * @param forward - Forward vector
     * @returns Forward vector
     */;_proto.getWorldForward=function getWorldForward(forward){var e=this.worldMatrix.elements;forward.setValue(-e[8],-e[9],-e[10]);return forward.normalize();}/**
     * Get the right direction in world space.
     * @param right - Right vector
     * @returns Right vector
     */;_proto.getWorldRight=function getWorldRight(right){var e=this.worldMatrix.elements;right.setValue(e[0],e[1],e[2]);return right.normalize();}/**
     * Get the up direction in world space.
     * @param up - Up vector
     * @returns Up vector
     */;_proto.getWorldUp=function getWorldUp(up){var e=this.worldMatrix.elements;up.setValue(e[4],e[5],e[6]);return up.normalize();}/**
     * Translate along the passed Vector3.
     * @param translation - Direction and distance of translation
     * @param relativeToLocal - Relative to local space
     */;_proto.translate=function translate(translationOrX,relativeToLocalOrY,z,relativeToLocal){if(typeof translationOrX==="number"){var _translate2=Transform._tempVec3;_translate2.setValue(translationOrX,relativeToLocalOrY,z);this._translate(_translate2,relativeToLocal);}else {this._translate(translationOrX,relativeToLocalOrY);}}/**
     * Rotate around the passed Vector3.
     * @param rotation - Euler angle in degrees
     * @param relativeToLocal - Relative to local space
     */;_proto.rotate=function rotate(rotationOrX,relativeToLocalOrY,z,relativeToLocal){if(typeof rotationOrX==="number"){this._rotateXYZ(rotationOrX,relativeToLocalOrY,z,relativeToLocal);}else {this._rotateXYZ(rotationOrX.x,rotationOrX.y,rotationOrX.z,relativeToLocalOrY);}}/**
     * Rotate around the specified axis according to the specified angle.
     * @param axis - Rotate axis
     * @param angle - Rotate angle in degrees
     * @param relativeToLocal - Relative to local space
     */;_proto.rotateByAxis=function rotateByAxis(axis,angle,relativeToLocal){if(relativeToLocal===void 0){relativeToLocal=true;}var rad=angle*MathUtil.degreeToRadFactor;Quaternion.rotationAxisAngle(axis,rad,Transform._tempQuat0);this._rotateByQuat(Transform._tempQuat0,relativeToLocal);}/**
     * Rotate and ensure that the world front vector points to the target world position.
     * @param worldPosition - Target world position
     * @param worldUp - Up direction in world space, default is Vector3(0, 1, 0)
     */;_proto.lookAt=function lookAt(worldPosition,worldUp){var _worldUp;var position=this.worldPosition;var EPSILON=MathUtil.zeroTolerance;if(Math.abs(position.x-worldPosition.x)<EPSILON&&Math.abs(position.y-worldPosition.y)<EPSILON&&Math.abs(position.z-worldPosition.z)<EPSILON){return;}var rotMat=Transform._tempMat43;var worldRotationQuaternion=this._worldRotationQuaternion;worldUp=(_worldUp=worldUp)!=null?_worldUp:Transform._tempVec3.setValue(0,1,0);Matrix.lookAt(position,worldPosition,worldUp,rotMat);rotMat.getRotation(worldRotationQuaternion).invert();this.worldRotationQuaternion=worldRotationQuaternion;}/**
     * Register world transform change flag.
     * @returns Change flag
     */;_proto.registerWorldChangeFlag=function registerWorldChangeFlag(){return this._updateFlagManager.register();}/**
     * @internal
     */;_proto._parentChange=function _parentChange(){this._isParentDirty=true;this._updateAllWorldFlag();}/**
     * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
     * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
     * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
     */;_proto._updateWorldPositionFlag=function _updateWorldPositionFlag(){if(!this._isContainDirtyFlags(TransformFlag.WmWp)){this._worldAssociatedChange(TransformFlag.WmWp);var nodeChildren=this._entity._children;for(var i=0,n=nodeChildren.length;i<n;i++){var _nodeChildren$i$trans;(_nodeChildren$i$trans=nodeChildren[i].transform)===null||_nodeChildren$i$trans===void 0?void 0:_nodeChildren$i$trans._updateWorldPositionFlag();}}}/**
     * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
     * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
     * Get worldRotationQuaternion: Will trigger the world rotation (in quaternion) update of itself and all parent entities.
     * Get worldRotation: Will trigger the world rotation(in euler and quaternion) update of itself and world rotation(in quaternion) update of all parent entities.
     * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
     */;_proto._updateWorldRotationFlag=function _updateWorldRotationFlag(){if(!this._isContainDirtyFlags(TransformFlag.WmWeWq)){this._worldAssociatedChange(TransformFlag.WmWeWq);var nodeChildren=this._entity._children;for(var i=0,n=nodeChildren.length;i<n;i++){var _nodeChildren$i$trans2;(_nodeChildren$i$trans2=nodeChildren[i].transform)===null||_nodeChildren$i$trans2===void 0?void 0:_nodeChildren$i$trans2._updateWorldPositionAndRotationFlag();// Rotation update of parent entity will trigger world position and rotation update of all child entity.
  }}}/**
     * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
     * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
     * Get worldRotationQuaternion: Will trigger the world rotation (in quaternion) update of itself and all parent entities.
     * Get worldRotation: Will trigger the world rotation(in euler and quaternion) update of itself and world rotation(in quaternion) update of all parent entities.
     * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
     */;_proto._updateWorldPositionAndRotationFlag=function _updateWorldPositionAndRotationFlag(){if(!this._isContainDirtyFlags(TransformFlag.WmWpWeWq)){this._worldAssociatedChange(TransformFlag.WmWpWeWq);var nodeChildren=this._entity._children;for(var i=0,n=nodeChildren.length;i<n;i++){var _nodeChildren$i$trans3;(_nodeChildren$i$trans3=nodeChildren[i].transform)===null||_nodeChildren$i$trans3===void 0?void 0:_nodeChildren$i$trans3._updateWorldPositionAndRotationFlag();}}}/**
     * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
     * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
     * Get worldScale: Will trigger the scaling update of itself and all parent entities.
     * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix) to be false.
     */;_proto._updateWorldScaleFlag=function _updateWorldScaleFlag(){if(!this._isContainDirtyFlags(TransformFlag.WmWs)){this._worldAssociatedChange(TransformFlag.WmWs);var nodeChildren=this._entity._children;for(var i=0,n=nodeChildren.length;i<n;i++){var _nodeChildren$i$trans4;(_nodeChildren$i$trans4=nodeChildren[i].transform)===null||_nodeChildren$i$trans4===void 0?void 0:_nodeChildren$i$trans4._updateWorldPositionAndScaleFlag();}}}/**
     * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
     * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
     * Get worldScale: Will trigger the scaling update of itself and all parent entities.
     * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix) to be false.
     */;_proto._updateWorldPositionAndScaleFlag=function _updateWorldPositionAndScaleFlag(){if(!this._isContainDirtyFlags(TransformFlag.WmWpWs)){this._worldAssociatedChange(TransformFlag.WmWpWs);var nodeChildren=this._entity._children;for(var i=0,n=nodeChildren.length;i<n;i++){var _nodeChildren$i$trans5;(_nodeChildren$i$trans5=nodeChildren[i].transform)===null||_nodeChildren$i$trans5===void 0?void 0:_nodeChildren$i$trans5._updateWorldPositionAndScaleFlag();}}}/**
     * Update all world transform property dirty flag, the principle is the same as above.
     */;_proto._updateAllWorldFlag=function _updateAllWorldFlag(){if(!this._isContainDirtyFlags(TransformFlag.WmWpWeWqWs)){this._worldAssociatedChange(TransformFlag.WmWpWeWqWs);var nodeChildren=this._entity._children;for(var i=0,n=nodeChildren.length;i<n;i++){var _nodeChildren$i$trans6;(_nodeChildren$i$trans6=nodeChildren[i].transform)===null||_nodeChildren$i$trans6===void 0?void 0:_nodeChildren$i$trans6._updateAllWorldFlag();}}};_proto._getParentTransform=function _getParentTransform(){if(!this._isParentDirty){return this._parentTransformCache;}var parentCache=null;var parent=this._entity.parent;while(parent){var transform=parent.transform;if(transform){parentCache=transform;break;}else {parent=parent.parent;}}this._parentTransformCache=parentCache;this._isParentDirty=false;return parentCache;};_proto._getScaleMatrix=function _getScaleMatrix(){var invRotation=Transform._tempQuat0;var invRotationMat=Transform._tempMat30;var worldRotScaMat=Transform._tempMat31;var scaMat=Transform._tempMat32;worldRotScaMat.setValueByMatrix(this.worldMatrix);Quaternion.invert(this.worldRotationQuaternion,invRotation);Matrix3x3.rotationQuaternion(invRotation,invRotationMat);Matrix3x3.multiply(invRotationMat,worldRotScaMat,scaMat);return scaMat;};_proto._isContainDirtyFlags=function _isContainDirtyFlags(targetDirtyFlags){return (this._dirtyFlag&targetDirtyFlags)===targetDirtyFlags;};_proto._isContainDirtyFlag=function _isContainDirtyFlag(type){return (this._dirtyFlag&type)!=0;};_proto._setDirtyFlagTrue=function _setDirtyFlagTrue(type){this._dirtyFlag|=type;};_proto._setDirtyFlagFalse=function _setDirtyFlagFalse(type){this._dirtyFlag&=~type;};_proto._worldAssociatedChange=function _worldAssociatedChange(type){this._dirtyFlag|=type;this._updateFlagManager.distribute();};_proto._rotateByQuat=function _rotateByQuat(rotateQuat,relativeToLocal){if(relativeToLocal){Quaternion.multiply(this.rotationQuaternion,rotateQuat,this._rotationQuaternion);this.rotationQuaternion=this._rotationQuaternion;}else {Quaternion.multiply(this.worldRotationQuaternion,rotateQuat,this._worldRotationQuaternion);this.worldRotationQuaternion=this._worldRotationQuaternion;}};_proto._translate=function _translate(translation,relativeToLocal){if(relativeToLocal===void 0){relativeToLocal=true;}if(relativeToLocal){this.position=this._position.add(translation);}else {this.worldPosition=this._worldPosition.add(translation);}};_proto._rotateXYZ=function _rotateXYZ(x,y,z,relativeToLocal){if(relativeToLocal===void 0){relativeToLocal=true;}var radFactor=MathUtil.degreeToRadFactor;var rotQuat=Transform._tempQuat0;Quaternion.rotationEuler(x*radFactor,y*radFactor,z*radFactor,rotQuat);this._rotateByQuat(rotQuat,relativeToLocal);};_createClass$3(Transform,[{key:"position",get:/**
       * Local position.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */function get(){return this._position;},set:function set(value){if(this._position!==value){value.cloneTo(this._position);}this._setDirtyFlagTrue(TransformFlag.LocalMatrix);this._updateWorldPositionFlag();}/**
       * World position.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */},{key:"worldPosition",get:function get(){if(this._isContainDirtyFlag(TransformFlag.WorldPosition)){if(this._getParentTransform()){this.worldMatrix.getTranslation(this._worldPosition);}else {this._position.cloneTo(this._worldPosition);}this._setDirtyFlagFalse(TransformFlag.WorldPosition);}return this._worldPosition;},set:function set(value){if(this._worldPosition!==value){value.cloneTo(this._worldPosition);}var parent=this._getParentTransform();if(parent){Matrix.invert(parent.worldMatrix,Transform._tempMat41);Vector3.transformCoordinate(value,Transform._tempMat41,this._position);}else {value.cloneTo(this._position);}this.position=this._position;this._setDirtyFlagFalse(TransformFlag.WorldPosition);}/**
       * Local rotation, defining the rotation value in degrees.
       * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */},{key:"rotation",get:function get(){if(this._isContainDirtyFlag(TransformFlag.LocalEuler)){this._rotationQuaternion.toEuler(this._rotation);this._rotation.scale(MathUtil.radToDegreeFactor);// radians to degrees
  this._setDirtyFlagFalse(TransformFlag.LocalEuler);}return this._rotation;},set:function set(value){if(this._rotation!==value){value.cloneTo(this._rotation);}this._setDirtyFlagTrue(TransformFlag.LocalMatrix|TransformFlag.LocalQuat);this._setDirtyFlagFalse(TransformFlag.LocalEuler);this._updateWorldRotationFlag();}/**
       * World rotation, defining the rotation value in degrees.
       * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */},{key:"worldRotation",get:function get(){if(this._isContainDirtyFlag(TransformFlag.WorldEuler)){this.worldRotationQuaternion.toEuler(this._worldRotation);this._worldRotation.scale(MathUtil.radToDegreeFactor);// Radian to angle
  this._setDirtyFlagFalse(TransformFlag.WorldEuler);}return this._worldRotation;},set:function set(value){if(this._worldRotation!==value){value.cloneTo(this._worldRotation);}Quaternion.rotationEuler(MathUtil.degreeToRadian(value.x),MathUtil.degreeToRadian(value.y),MathUtil.degreeToRadian(value.z),this._worldRotationQuaternion);this.worldRotationQuaternion=this._worldRotationQuaternion;this._setDirtyFlagFalse(TransformFlag.WorldEuler);}/**
       * Local rotation, defining the rotation by using a unit quaternion.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */},{key:"rotationQuaternion",get:function get(){if(this._isContainDirtyFlag(TransformFlag.LocalQuat)){Quaternion.rotationEuler(MathUtil.degreeToRadian(this._rotation.x),MathUtil.degreeToRadian(this._rotation.y),MathUtil.degreeToRadian(this._rotation.z),this._rotationQuaternion);this._setDirtyFlagFalse(TransformFlag.LocalQuat);}return this._rotationQuaternion;},set:function set(value){if(this._rotationQuaternion!==value){value.cloneTo(this._rotationQuaternion);}this._setDirtyFlagTrue(TransformFlag.LocalMatrix|TransformFlag.LocalEuler);this._setDirtyFlagFalse(TransformFlag.LocalQuat);this._updateWorldRotationFlag();}/**
       * World rotation, defining the rotation by using a unit quaternion.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */},{key:"worldRotationQuaternion",get:function get(){if(this._isContainDirtyFlag(TransformFlag.WorldQuat)){var parent=this._getParentTransform();if(parent!=null){Quaternion.multiply(parent.worldRotationQuaternion,this.rotationQuaternion,this._worldRotationQuaternion);}else {this.rotationQuaternion.cloneTo(this._worldRotationQuaternion);}this._setDirtyFlagFalse(TransformFlag.WorldQuat);}return this._worldRotationQuaternion;},set:function set(value){if(this._worldRotationQuaternion!==value){value.cloneTo(this._worldRotationQuaternion);}var parent=this._getParentTransform();if(parent){Quaternion.invert(parent.worldRotationQuaternion,Transform._tempQuat0);Quaternion.multiply(value,Transform._tempQuat0,this._rotationQuaternion);}else {value.cloneTo(this._rotationQuaternion);}this.rotationQuaternion=this._rotationQuaternion;this._setDirtyFlagFalse(TransformFlag.WorldQuat);}/**
       * Local scaling.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */},{key:"scale",get:function get(){return this._scale;},set:function set(value){if(this._scale!==value){value.cloneTo(this._scale);}this._setDirtyFlagTrue(TransformFlag.LocalMatrix);this._updateWorldScaleFlag();}/**
       * Local lossy scaling.
       * @remarks The value obtained may not be correct under certain conditions(for example, the parent node has scaling,
       * and the child node has a rotation), the scaling will be tilted. Vector3 cannot be used to correctly represent the scaling. Must use Matrix3x3.
       */},{key:"lossyWorldScale",get:function get(){if(this._isContainDirtyFlag(TransformFlag.WorldScale)){if(this._getParentTransform()){var scaleMat=this._getScaleMatrix();var e=scaleMat.elements;this._lossyWorldScale.setValue(e[0],e[4],e[8]);}else {this._scale.cloneTo(this._lossyWorldScale);}this._setDirtyFlagFalse(TransformFlag.WorldScale);}return this._lossyWorldScale;}/**
       * Local matrix.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */},{key:"localMatrix",get:function get(){if(this._isContainDirtyFlag(TransformFlag.LocalMatrix)){Matrix.affineTransformation(this._scale,this.rotationQuaternion,this._position,this._localMatrix);this._setDirtyFlagFalse(TransformFlag.LocalMatrix);}return this._localMatrix;},set:function set(value){if(this._localMatrix!==value){value.cloneTo(this._localMatrix);}this._localMatrix.decompose(this._position,this._rotationQuaternion,this._scale);this._setDirtyFlagTrue(TransformFlag.LocalEuler);this._setDirtyFlagFalse(TransformFlag.LocalMatrix);this._updateAllWorldFlag();}/**
       * World matrix.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */},{key:"worldMatrix",get:function get(){if(this._isContainDirtyFlag(TransformFlag.WorldMatrix)){var parent=this._getParentTransform();if(parent){Matrix.multiply(parent.worldMatrix,this.localMatrix,this._worldMatrix);}else {this.localMatrix.cloneTo(this._worldMatrix);}this._setDirtyFlagFalse(TransformFlag.WorldMatrix);}return this._worldMatrix;},set:function set(value){if(this._worldMatrix!==value){value.cloneTo(this._worldMatrix);}var parent=this._getParentTransform();if(parent){Matrix.invert(parent.worldMatrix,Transform._tempMat42);Matrix.multiply(value,Transform._tempMat42,this._localMatrix);}else {value.cloneTo(this._localMatrix);}this.localMatrix=this._localMatrix;this._setDirtyFlagFalse(TransformFlag.WorldMatrix);}}]);return Transform;}(Component),_class2$7._tempQuat0=new Quaternion(),_class2$7._tempVec3=new Vector3(),_class2$7._tempMat30=new Matrix3x3(),_class2$7._tempMat31=new Matrix3x3(),_class2$7._tempMat32=new Matrix3x3(),_class2$7._tempMat40=new Matrix(),_class2$7._tempMat41=new Matrix(),_class2$7._tempMat42=new Matrix(),_class2$7._tempMat43=new Matrix(),_temp$7),(_descriptor$8=_applyDecoratedDescriptor$1(_class$8$1.prototype,"_position",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Vector3();}}),_descriptor2$8=_applyDecoratedDescriptor$1(_class$8$1.prototype,"_rotation",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Vector3();}}),_descriptor3$7=_applyDecoratedDescriptor$1(_class$8$1.prototype,"_rotationQuaternion",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Quaternion();}}),_descriptor4$7=_applyDecoratedDescriptor$1(_class$8$1.prototype,"_scale",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Vector3(1,1,1);}}),_descriptor5$7=_applyDecoratedDescriptor$1(_class$8$1.prototype,"_worldPosition",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Vector3();}}),_descriptor6$7=_applyDecoratedDescriptor$1(_class$8$1.prototype,"_worldRotation",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Vector3();}}),_descriptor7$5=_applyDecoratedDescriptor$1(_class$8$1.prototype,"_worldRotationQuaternion",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Quaternion();}}),_descriptor8$3=_applyDecoratedDescriptor$1(_class$8$1.prototype,"_lossyWorldScale",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Vector3(1,1,1);}}),_descriptor9$3=_applyDecoratedDescriptor$1(_class$8$1.prototype,"_localMatrix",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor10$3=_applyDecoratedDescriptor$1(_class$8$1.prototype,"_worldMatrix",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor11$3=_applyDecoratedDescriptor$1(_class$8$1.prototype,"_updateFlagManager",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new UpdateFlagManager();}}),_descriptor12$3=_applyDecoratedDescriptor$1(_class$8$1.prototype,"_isParentDirty",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return true;}}),_descriptor13$2=_applyDecoratedDescriptor$1(_class$8$1.prototype,"_parentTransformCache",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return null;}})),_class$8$1);/**
   * Dirty flag of transform.
   */var TransformFlag;(function(TransformFlag){TransformFlag[TransformFlag["LocalEuler"]=1]="LocalEuler";TransformFlag[TransformFlag["LocalQuat"]=2]="LocalQuat";TransformFlag[TransformFlag["WorldPosition"]=4]="WorldPosition";TransformFlag[TransformFlag["WorldEuler"]=8]="WorldEuler";TransformFlag[TransformFlag["WorldQuat"]=16]="WorldQuat";TransformFlag[TransformFlag["WorldScale"]=32]="WorldScale";TransformFlag[TransformFlag["LocalMatrix"]=64]="LocalMatrix";TransformFlag[TransformFlag["WorldMatrix"]=128]="WorldMatrix";TransformFlag[TransformFlag["WmWp"]=132]="WmWp";TransformFlag[TransformFlag["WmWeWq"]=152]="WmWeWq";TransformFlag[TransformFlag["WmWpWeWq"]=156]="WmWpWeWq";TransformFlag[TransformFlag["WmWs"]=160]="WmWs";TransformFlag[TransformFlag["WmWpWs"]=164]="WmWpWs";TransformFlag[TransformFlag["WmWpWeWqWs"]=188]="WmWpWeWqWs";})(TransformFlag||(TransformFlag={}));/**
   * Entity, be used as components container.
   */var Entity=/*#__PURE__*/function(_EngineObject){_inheritsLoose$2(Entity,_EngineObject);/**
     * @internal
     */Entity._findChildByName=function _findChildByName(root,name){var children=root._children;for(var i=children.length-1;i>=0;i--){var child=children[i];if(child.name===name){return child;}}return null;}/**
     * @internal
     */;Entity._traverseSetOwnerScene=function _traverseSetOwnerScene(entity,scene){entity._scene=scene;var children=entity._children;for(var i=entity.childCount-1;i>=0;i--){this._traverseSetOwnerScene(children[i],scene);}}/** The name of entity. */;/**
     * Create a entity.
     * @param engine - The engine the entity belongs to.
     */function Entity(engine,name){var _this;_this=_EngineObject.call(this,engine)||this;_this.name=void 0;_this.layer=exports.Layer.Layer0;_this.transform=void 0;_this._isActiveInHierarchy=false;_this._components=[];_this._scripts=new DisorderedArray();_this._children=[];_this._scene=void 0;_this._isRoot=false;_this._isActive=true;_this._parent=null;_this._activeChangedComponents=void 0;_this._invModelMatrix=new Matrix();_this._inverseWorldMatFlag=void 0;_this.name=name;_this.transform=_this.addComponent(Transform);_this._inverseWorldMatFlag=_this.transform.registerWorldChangeFlag();return _this;}/**
     * Add component based on the component type.
     * @param type - The type of the component.
     * @returns	The component which has been added.
     */var _proto=Entity.prototype;_proto.addComponent=function addComponent(type){ComponentsDependencies._addCheck(this,type);var component=new type(this);this._components.push(component);if(this._isActiveInHierarchy){component._setActive(true);}return component;}/**
     * Get component which match the type.
     * @param type - The type of the component.
     * @returns	The first component which match type.
     */;_proto.getComponent=function getComponent(type){for(var i=this._components.length-1;i>=0;i--){var component=this._components[i];if(component instanceof type){return component;}}}/**
     * Get components which match the type.
     * @param type - The type of the component.
     * @param results - The components which match type.
     * @returns	The components which match type.
     */;_proto.getComponents=function getComponents(type,results){results.length=0;for(var i=this._components.length-1;i>=0;i--){var component=this._components[i];if(component instanceof type){results.push(component);}}return results;}/**
     * Get the components which match the type of the entity and it's children.
     * @param type - The component type.
     * @param results - The components collection.
     * @returns	The components collection which match the type.
     */;_proto.getComponentsIncludeChildren=function getComponentsIncludeChildren(type,results){results.length=0;this._getComponentsInChildren(type,results);return results;}/**
     * Add child entity.
     * @param child - The child entity which want to be added.
     */;_proto.addChild=function addChild(child){child.parent=this;}/**
     * Remove child entity.
     * @param child - The child entity which want to be removed.
     */;_proto.removeChild=function removeChild(child){child.parent=null;}/**
     * Find child entity by index.
     * @param index - The index of the child entity.
     * @returns	The component which be found.
     */;_proto.getChild=function getChild(index){return this._children[index];}/**
     * Find child entity by name.
     * @param name - The name of the entity which want to be found.
     * @returns The component which be found.
     */;_proto.findByName=function findByName(name){var children=this._children;var child=Entity._findChildByName(this,name);if(child)return child;for(var i=children.length-1;i>=0;i--){var _child=children[i];var grandson=_child.findByName(name);if(grandson){return grandson;}}return null;}/**
     * Find the entity by path.
     * @param path - The path fo the entity eg: /entity.
     * @returns The component which be found.
     */;_proto.findByPath=function findByPath(path){var splits=path.split("/");var entity=this;for(var i=0,length=splits.length;i<length;++i){var split=splits[i];if(split){entity=Entity._findChildByName(entity,split);if(!entity){return null;}}}return entity;}/**
     * Create child entity.
     * @param name - The child entity's name.
     * @returns The child entity.
     */;_proto.createChild=function createChild(name){var child=new Entity(this.engine,name);child.layer=this.layer;child.parent=this;return child;}/**
     * Clear children entities.
     */;_proto.clearChildren=function clearChildren(){var children=this._children;for(var i=children.length-1;i>=0;i--){var child=children[i];child._parent=null;child._isActiveInHierarchy&&child._processInActive();Entity._traverseSetOwnerScene(child,null);// Must after child._processInActive().
  }children.length=0;}/**
     * Clone
     * @returns Cloned entity.
     */;_proto.clone=function clone(){var cloneEntity=new Entity(this._engine,this.name);cloneEntity._isActive=this._isActive;cloneEntity.transform.localMatrix=this.transform.localMatrix;var children=this._children;for(var i=0,len=this._children.length;i<len;i++){var child=children[i];cloneEntity.addChild(child.clone());}var components=this._components;for(var _i=0,n=components.length;_i<n;_i++){var sourceComp=components[_i];if(!(sourceComp instanceof Transform)){var targetComp=cloneEntity.addComponent(sourceComp.constructor);ComponentCloner.cloneComponent(sourceComp,targetComp);}}return cloneEntity;}/**
     * Destroy self.
     */;_proto.destroy=function destroy(){var abilityArray=this._components;for(var i=abilityArray.length-1;i>=0;i--){abilityArray[i].destroy();}this._components.length=0;var children=this._children;for(var _i2=children.length-1;_i2>=0;_i2--){children[_i2].destroy();}this._children.length=0;if(this._parent!=null){var parentChildren=this._parent._children;parentChildren.splice(parentChildren.indexOf(this),1);}this._parent=null;}/**
     * @internal
     */;_proto._removeComponent=function _removeComponent(component){ComponentsDependencies._removeCheck(this,component.constructor);var components=this._components;components.splice(components.indexOf(component),1);}/**
     * @internal
     */;_proto._addScript=function _addScript(script){script._entityCacheIndex=this._scripts.length;this._scripts.add(script);}/**
     * @internal
     */;_proto._removeScript=function _removeScript(script){var replaced=this._scripts.deleteByIndex(script._entityCacheIndex);replaced&&(replaced._entityCacheIndex=script._entityCacheIndex);script._entityCacheIndex=-1;}/**
     * @internal
     */;_proto._removeFromParent=function _removeFromParent(){var oldParent=this._parent;if(oldParent!=null){var oldParentChildren=oldParent._children;oldParentChildren.splice(oldParentChildren.indexOf(this),1);this._parent=null;}return oldParent;}/**
     * @internal
     */;_proto._processActive=function _processActive(){if(this._activeChangedComponents){throw "Note: can't set the 'main inActive entity' active in hierarchy, if the operation is in main inActive entity or it's children script's onDisable Event.";}this._activeChangedComponents=this._engine._componentsManager.getActiveChangedTempList();this._setActiveInHierarchy(this._activeChangedComponents);this._setActiveComponents(true);}/**
     * @internal
     */;_proto._processInActive=function _processInActive(){if(this._activeChangedComponents){throw "Note: can't set the 'main active entity' inActive in hierarchy, if the operation is in main active entity or it's children script's onEnable Event.";}this._activeChangedComponents=this._engine._componentsManager.getActiveChangedTempList();this._setInActiveInHierarchy(this._activeChangedComponents);this._setActiveComponents(false);};_proto._getComponentsInChildren=function _getComponentsInChildren(type,results){for(var i=this._components.length-1;i>=0;i--){var component=this._components[i];if(component instanceof type){results.push(component);}}for(var _i3=this._children.length-1;_i3>=0;_i3--){this._children[_i3]._getComponentsInChildren(type,results);}};_proto._setActiveComponents=function _setActiveComponents(isActive){var activeChangedComponents=this._activeChangedComponents;for(var i=0,length=activeChangedComponents.length;i<length;++i){activeChangedComponents[i]._setActive(isActive);}this._engine._componentsManager.putActiveChangedTempList(activeChangedComponents);this._activeChangedComponents=null;};_proto._setActiveInHierarchy=function _setActiveInHierarchy(activeChangedComponents){this._isActiveInHierarchy=true;var components=this._components;for(var i=components.length-1;i>=0;i--){activeChangedComponents.push(components[i]);}var children=this._children;for(var _i4=children.length-1;_i4>=0;_i4--){var child=children[_i4];child.isActive&&child._setActiveInHierarchy(activeChangedComponents);}};_proto._setInActiveInHierarchy=function _setInActiveInHierarchy(activeChangedComponents){this._isActiveInHierarchy=false;var components=this._components;for(var i=components.length-1;i>=0;i--){activeChangedComponents.push(components[i]);}var children=this._children;for(var _i5=children.length-1;_i5>=0;_i5--){var child=children[_i5];child.isActive&&child._setInActiveInHierarchy(activeChangedComponents);}};_proto._setTransformDirty=function _setTransformDirty(){if(this.transform){this.transform._parentChange();}else {for(var i=0,len=this._children.length;i<len;i++){this._children[i]._setTransformDirty();}}}//--------------------------------------------------------------deprecated----------------------------------------------------------------
  ;/**
     * @deprecated
     */_proto.getInvModelMatrix=function getInvModelMatrix(){if(this._inverseWorldMatFlag.flag){Matrix.invert(this.transform.worldMatrix,this._invModelMatrix);this._inverseWorldMatFlag.flag=false;}return this._invModelMatrix;};_createClass$3(Entity,[{key:"isActive",get:/**
       * Whether to activate locally.
       */function get(){return this._isActive;},set:function set(value){if(value!==this._isActive){this._isActive=value;if(value){var parent=this._parent;if(parent!==null&&parent!==void 0&&parent._isActiveInHierarchy||this._isRoot&&this._scene._isActiveInEngine){this._processActive();}}else {if(this._isActiveInHierarchy){this._processInActive();}}}}/**
       * Whether it is active in the hierarchy.
       */},{key:"isActiveInHierarchy",get:function get(){return this._isActiveInHierarchy;}/**
       * The parent entity.
       */},{key:"parent",get:function get(){return this._parent;},set:function set(entity){if(entity!==this._parent){var oldParent=this._removeFromParent();var newParent=this._parent=entity;if(newParent){newParent._children.push(this);var parentScene=newParent._scene;if(this._scene!==parentScene){Entity._traverseSetOwnerScene(this,parentScene);}if(newParent._isActiveInHierarchy){!this._isActiveInHierarchy&&this._isActive&&this._processActive();}else {this._isActiveInHierarchy&&this._processInActive();}}else {this._isActiveInHierarchy&&this._processInActive();if(oldParent){Entity._traverseSetOwnerScene(this,null);}}this._setTransformDirty();}}/**
       * The children entities
       */},{key:"children",get:function get(){return this._children;}/**
       * Number of the children entities
       */},{key:"childCount",get:function get(){return this._children.length;}/**
       * The scene the entity belongs to.
       */},{key:"scene",get:function get(){return this._scene;}},{key:"position",get:/**
       * @deprecated
       * Use transform.position instead.
       */function get(){return this.transform.position;},set:function set(val){this.transform.position=val;}/**
       * @deprecated
       * Use transform.worldPosition instead.
       */},{key:"worldPosition",get:function get(){return this.transform.worldPosition;},set:function set(val){this.transform.worldPosition=val;}/**
       * @deprecated
       * Use transform.rotationQuaternion instead.
       */},{key:"rotation",get:function get(){return this.transform.rotationQuaternion;},set:function set(val){this.transform.rotationQuaternion=val;}/**
       * @deprecated
       * Use transform.scale instead.
       */},{key:"scale",get:function get(){return this.transform.scale;},set:function set(val){this.transform.scale=val;}}]);return Entity;}(EngineObject);/**
   * Manage a set of feature objects.
   */var FeatureManager=/*#__PURE__*/function(){function FeatureManager(){this._features=[];this._objects=[];}var _proto=FeatureManager.prototype;/**
     * Register a feature.
     * @param {SceneFeature|EngineFeature} IFeature
     */_proto.registerFeature=function registerFeature(IFeature){var featureArray=this._features;// Search by type, avoid adding
  for(var i=0,len=featureArray.length;i<len;i++){if(featureArray[i]===IFeature){return;}}// Add to global array
  featureArray.push(IFeature);// Add to existing scene
  var objectArray=this._objects;for(var _i=0,_len=objectArray.length;_i<_len;_i++){objectArray[_i].features.push(new IFeature());}}/**
     * Add an feature with functional characteristics.
     * @param {Scene|Engine} obj - Scene or engine
     */;_proto.addObject=function addObject(obj){obj.features=[];for(var i=0,len=this._features.length;i<len;i++){var _engine;obj.features.push(new this._features[i]((_engine=obj.engine)!=null?_engine:obj));}this._objects.push(obj);}/**
     * Call the specified method of the feature.
     * @param obj - Scene or engine
     * @param method - Method name
     * @param args - Function args
     */;_proto.callFeatureMethod=function callFeatureMethod(obj,method,args){var features=obj.features;var count=features.length;for(var i=0;i<count;i++){var feature=features[i];if(feature[method]){feature[method].apply(feature,args);}}}/**
     * Find feature.
     * @param obj - Scene or engine
     * @param IFeature - plug-in
     */;_proto.findFeature=function findFeature(obj,IFeature){var features=obj.features;var count=features.length;for(var i=0;i<count;i++){var feature=features[i];if(feature.constructor===IFeature){return feature;}}return undefined;};return FeatureManager;}();/**
   * Render queue type.
   */exports.RenderQueueType = void 0;(function(RenderQueueType){RenderQueueType[RenderQueueType["Opaque"]=1000]="Opaque";RenderQueueType[RenderQueueType["AlphaTest"]=2000]="AlphaTest";RenderQueueType[RenderQueueType["Transparent"]=3000]="Transparent";})(exports.RenderQueueType||(exports.RenderQueueType={}));/**
   * The base class of assets, with reference counting capability.
   */var RefObject=/*#__PURE__*/function(_EngineObject){_inheritsLoose$2(RefObject,_EngineObject);function RefObject(engine){var _this;_this=_EngineObject.call(this,engine)||this;_this.isGCIgnored=false;_this._refCount=0;_this._destroyed=false;engine.resourceManager._addRefObject(_this.instanceId,_assertThisInitialized$1(_this));return _this;}/**
     * Destroy self.
     * @param force - Whether to force the destruction, if it is false, refCount = 0 can be released successfully.
     * @returns Whether the release was successful.
     */var _proto=RefObject.prototype;_proto.destroy=function destroy(force){if(force===void 0){force=false;}if(this._destroyed)return true;if(!force&&this._refCount!==0)return false;var resourceManager=this._engine.resourceManager;// resourceManager maybe null,because engine has destroyed.
  // TODO:the right way to fix this is to ensure destroy all when call engine.destroy,thus don't need to add this project.
  if(resourceManager){resourceManager._deleteAsset(this);resourceManager._deleteRefObject(this.instanceId);}var refCount=this._getRefCount();if(refCount>0){this._addRefCount(-refCount);}this._engine=null;this._onDestroy();this._destroyed=true;return true;}/**
     * @internal
     */;_proto._getRefCount=function _getRefCount(){return this._refCount;}/**
     * @internal
     * Add reference resource.
     */;_proto._addRefCount=function _addRefCount(value){this._refCount+=value;}/**
     * @internal
     * Remove reference resource.
     */;_proto._addToResourceManager=function _addToResourceManager(path){this._engine.resourceManager._addAsset(path,this);}/**
     * Called when the resource is destroyed.
     * Subclasses can override this function.
     */;_createClass$3(RefObject,[{key:"refCount",get:/** Whether to ignore the garbage collection check, if it is true, it will not be affected by ResourceManager.gc(). */ /**
       * Counted by valid references.
       */function get(){return this._refCount;}/**
       * Whether it has been destroyed.
       */},{key:"destroyed",get:function get(){return this._destroyed;}}]);return RefObject;}(EngineObject);/**
   * Shader data grouping.
   */var ShaderDataGroup;(function(ShaderDataGroup){ShaderDataGroup[ShaderDataGroup["Scene"]=0]="Scene";ShaderDataGroup[ShaderDataGroup["Camera"]=1]="Camera";ShaderDataGroup[ShaderDataGroup["Renderer"]=2]="Renderer";ShaderDataGroup[ShaderDataGroup["Material"]=3]="Material";})(ShaderDataGroup||(ShaderDataGroup={}));/**
   * The base class of texture, contains some common functions of texture-related classes.
   */var Texture=/*#__PURE__*/function(_RefObject){_inheritsLoose$2(Texture,_RefObject);function Texture(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_RefObject.call.apply(_RefObject,[this].concat(args))||this;_this.name=void 0;_this._platformTexture=void 0;_this._mipmap=void 0;_this._width=void 0;_this._height=void 0;_this._mipmapCount=void 0;_this._wrapModeU=void 0;_this._wrapModeV=void 0;_this._filterMode=void 0;_this._anisoLevel=1;return _this;}var _proto=Texture.prototype;/**
     * Generate multi-level textures based on the 0th level data.
     */_proto.generateMipmaps=function generateMipmaps(){if(!this._mipmap)return;this._platformTexture.generateMipmaps();}/**
     * @override
     */;_proto._onDestroy=function _onDestroy(){this._platformTexture.destroy();this._platformTexture=null;}/**
     * Get the maximum mip level of the corresponding size:rounding down.
     * @remarks http://download.nvidia.com/developer/Papers/2005/NP2_Mipmapping/NP2_Mipmap_Creation.pdf
     */;_proto._getMaxMiplevel=function _getMaxMiplevel(size){return Math.floor(Math.log2(size));};_proto._getMipmapCount=function _getMipmapCount(){return this._mipmap?Math.floor(Math.log2(Math.max(this._width,this._height)))+1:1;};_createClass$3(Texture,[{key:"width",get:/**
       * The width of the texture.
       */function get(){return this._width;}/**
       * The height of the texture.
       */},{key:"height",get:function get(){return this._height;}/**
       * Wrapping mode for texture coordinate S.
       */},{key:"wrapModeU",get:function get(){return this._wrapModeU;},set:function set(value){if(value===this._wrapModeU)return;this._wrapModeU=value;this._platformTexture.wrapModeU=value;}/**
       * Wrapping mode for texture coordinate T.
       */},{key:"wrapModeV",get:function get(){return this._wrapModeV;},set:function set(value){if(value===this._wrapModeV)return;this._wrapModeV=value;this._platformTexture.wrapModeV=value;}/**
       * Texture mipmapping count.
       */},{key:"mipmapCount",get:function get(){return this._mipmapCount;}/**
       * Filter mode for texture.
       */},{key:"filterMode",get:function get(){return this._filterMode;},set:function set(value){if(value===this._filterMode)return;this._filterMode=value;this._platformTexture.filterMode=value;}/**
       * Anisotropic level for texture.
       */},{key:"anisoLevel",get:function get(){return this._anisoLevel;},set:function set(value){var max=this._engine._hardwareRenderer.capability.maxAnisoLevel;if(value>max){Logger.warn("anisoLevel:"+value+", exceeds the limit and is automatically downgraded to:"+max);value=max;}if(value<1){Logger.warn("anisoLevel:"+value+", must be greater than 0, and is automatically downgraded to 1");value=1;}if(value===this._anisoLevel)return;this._anisoLevel=value;this._platformTexture.anisoLevel=value;}}]);return Texture;}(RefObject);var common="#define GLSLIFY 1\n#define PI 3.14159265359\n#define LOG2 1.442695\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n";// eslint-disable-line
  var common_vert="#define GLSLIFY 1\nattribute vec3 POSITION;\n#ifdef O3_HAS_UV\nattribute vec2 TEXCOORD_0;\n#endif\n#ifdef O3_HAS_SKIN\nattribute vec4 JOINTS_0;attribute vec4 WEIGHTS_0;\n#ifdef O3_USE_JOINT_TEXTURE\nuniform sampler2D u_jointSampler;uniform float u_jointCount;mat4 getJointMatrix(sampler2D smp,float index){float base=index/u_jointCount;float hf=0.5/u_jointCount;float v=base+hf;vec4 m0=texture2D(smp,vec2(0.125,v));vec4 m1=texture2D(smp,vec2(0.375,v));vec4 m2=texture2D(smp,vec2(0.625,v));vec4 m3=texture2D(smp,vec2(0.875,v));return mat4(m0,m1,m2,m3);}\n#else\nuniform mat4 u_jointMatrix[O3_JOINTS_NUM];\n#endif\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\nattribute vec4 COLOR_0;\n#endif\nuniform mat4 u_localMat;uniform mat4 u_modelMat;uniform mat4 u_viewMat;uniform mat4 u_projMat;uniform mat4 u_MVMat;uniform mat4 u_MVPMat;uniform mat4 u_normalMat;uniform vec3 u_cameraPos;uniform vec4 u_tilingOffset;\n#ifndef OMIT_NORMAL\n#ifdef O3_HAS_NORMAL\nattribute vec3 NORMAL;\n#endif\n#ifdef O3_HAS_TANGENT\nattribute vec4 TANGENT;\n#endif\n#endif\n";// eslint-disable-line
  var common_frag="#define GLSLIFY 1\nuniform O3_VERTEX_PRECISION mat4 u_localMat;uniform O3_VERTEX_PRECISION mat4 u_modelMat;uniform O3_VERTEX_PRECISION mat4 u_viewMat;uniform O3_VERTEX_PRECISION mat4 u_projMat;uniform O3_VERTEX_PRECISION mat4 u_MVMat;uniform O3_VERTEX_PRECISION mat4 u_MVPMat;uniform O3_VERTEX_PRECISION mat4 u_normalMat;uniform O3_VERTEX_PRECISION vec3 u_cameraPos;";// eslint-disable-line
  var color_share="#define GLSLIFY 1\n#ifdef O3_HAS_VERTEXCOLOR\nvarying vec4 v_color;\n#endif\n";// eslint-disable-line
  var normal_share="#define GLSLIFY 1\n#ifdef O3_HAS_NORMAL\n#if defined( O3_HAS_TANGENT ) && defined( O3_NORMAL_TEXTURE )\nvarying mat3 v_TBN;\n#else\nvarying vec3 v_normal;\n#endif\n#endif\n";// eslint-disable-line
  var uv_share="#define GLSLIFY 1\nvarying vec2 v_uv;";// eslint-disable-line
  var worldpos_share="#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvarying vec3 v_pos;\n#endif\n";// eslint-disable-line
  var shadow_share="#define GLSLIFY 1\n#ifdef O3_GENERATE_SHADOW_MAP\nuniform mat4 u_viewMatFromLight;uniform mat4 u_projMatFromLight;\n#endif\n#ifdef O3_SHADOW_MAP_COUNT\nuniform mat4 u_viewMatFromLight[O3_SHADOW_MAP_COUNT];uniform mat4 u_projMatFromLight[O3_SHADOW_MAP_COUNT];varying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];\n#endif\n";// eslint-disable-line
  var fog_share="#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nvarying vec3 v_fogDepth;uniform O3_VERTEX_PRECISION vec3 u_fogColor;\n#ifdef O3_FOG_EXP2\nuniform O3_VERTEX_PRECISION float u_fogDensity;\n#else\nuniform O3_VERTEX_PRECISION float u_fogNear;uniform O3_VERTEX_PRECISION float u_fogFar;\n#endif\n#endif\n";// eslint-disable-line
  var begin_normal_vert="#define GLSLIFY 1\n#ifdef O3_HAS_NORMAL\nvec3 normal=vec3(NORMAL);\n#if defined( O3_HAS_TANGENT ) && defined( O3_NORMAL_TEXTURE )\nvec4 tangent=vec4(TANGENT);\n#endif\n#endif\n";// eslint-disable-line
  var begin_position_vert="#define GLSLIFY 1\nvec4 position=vec4(POSITION,1.0);";// eslint-disable-line
  var position_vert="#define GLSLIFY 1\n#ifndef O3_GENERATE_SHADOW_MAP\ngl_Position=u_MVPMat*position;\n#endif\n";// eslint-disable-line
  var color_vert="#define GLSLIFY 1\n#ifdef O3_HAS_VERTEXCOLOR\nv_color=COLOR_0;\n#endif\n";// eslint-disable-line
  var normal_vert="#define GLSLIFY 1\n#ifdef O3_HAS_NORMAL\n#if defined( O3_HAS_TANGENT ) && defined( O3_NORMAL_TEXTURE )\nvec3 normalW=normalize(mat3(u_normalMat)*normal.xyz);vec3 tangentW=normalize(mat3(u_normalMat)*tangent.xyz);vec3 bitangentW=cross(normalW,tangentW)*tangent.w;v_TBN=mat3(tangentW,bitangentW,normalW);\n#else\nv_normal=normalize(mat3(u_normalMat)*normal);\n#endif\n#endif\n";// eslint-disable-line
  var skinning_vert="#define GLSLIFY 1\n#ifdef O3_HAS_SKIN\n#ifdef O3_USE_JOINT_TEXTURE\nmat4 skinMatrix=WEIGHTS_0.x*getJointMatrix(u_jointSampler,JOINTS_0.x)+WEIGHTS_0.y*getJointMatrix(u_jointSampler,JOINTS_0.y)+WEIGHTS_0.z*getJointMatrix(u_jointSampler,JOINTS_0.z)+WEIGHTS_0.w*getJointMatrix(u_jointSampler,JOINTS_0.w);\n#else\nmat4 skinMatrix=WEIGHTS_0.x*u_jointMatrix[int(JOINTS_0.x)]+WEIGHTS_0.y*u_jointMatrix[int(JOINTS_0.y)]+WEIGHTS_0.z*u_jointMatrix[int(JOINTS_0.z)]+WEIGHTS_0.w*u_jointMatrix[int(JOINTS_0.w)];\n#endif\nposition=skinMatrix*position;\n#if defined(O3_HAS_NORMAL) && !defined(OMIT_NORMAL)\nnormal=vec4(skinMatrix*vec4(normal,0.0)).xyz;\n#if defined( O3_HAS_TANGENT ) && defined( O3_NORMAL_TEXTURE )\ntangent.xyz=vec4(skinMatrix*vec4(tangent.xyz,0.0)).xyz;\n#endif\n#endif\n#endif\n";// eslint-disable-line
  var blendShape_input="#define GLSLIFY 1\n#ifdef OASIS_BLENDSHAPE\n#ifndef OASIS_BLENDSHAPE_TEXTURE\nattribute vec3 POSITION_BS0;attribute vec3 POSITION_BS1;attribute vec3 POSITION_BS2;attribute vec3 POSITION_BS3;\n#ifdef OASIS_BLENDSHAPE_NORMAL\nattribute vec3 NORMAL_BS0;attribute vec3 NORMAL_BS1;attribute vec3 NORMAL_BS2;attribute vec3 NORMAL_BS3;\n#endif\n#ifdef OASIS_BLENDSHAPE_TANGENT\nattribute vec3 TANGENT_BS0;attribute vec3 TANGENT_BS1;attribute vec3 TANGENT_BS2;attribute vec3 TANGENT_BS3;\n#endif\n#endif\nuniform float u_blendShapeWeights[4];\n#endif\n";// eslint-disable-line
  var blendShape_vert="#define GLSLIFY 1\n#ifdef OASIS_BLENDSHAPE\n#ifdef OASIS_BLENDSHAPE_TEXTURE\n#else\nposition.xyz+=POSITION_BS0*u_blendShapeWeights[0];position.xyz+=POSITION_BS1*u_blendShapeWeights[1];position.xyz+=POSITION_BS2*u_blendShapeWeights[2];position.xyz+=POSITION_BS3*u_blendShapeWeights[3];\n#if defined( O3_HAS_NORMAL ) && defined( OASIS_BLENDSHAPE_NORMAL )\nnormal.xyz+=NORMAL_BS0*u_blendShapeWeights[0];normal.xyz+=NORMAL_BS1*u_blendShapeWeights[1];normal.xyz+=NORMAL_BS2*u_blendShapeWeights[2];normal.xyz+=NORMAL_BS3*u_blendShapeWeights[3];\n#endif\n#if defined( O3_HAS_TANGENT ) && defined( O3_NORMAL_TEXTURE ) && defined(OASIS_BLENDSHAPE_TANGENT)\ntangent.xyz+=TANGENT_BS0*u_blendShapeWeights[0];tangent.xyz+=TANGENT_BS1*u_blendShapeWeights[1];tangent.xyz+=TANGENT_BS2*u_blendShapeWeights[2];tangent.xyz+=TANGENT_BS3*u_blendShapeWeights[3];\n#endif\n#endif\n#endif\n";// eslint-disable-line
  var uv_vert="#define GLSLIFY 1\n#ifdef O3_HAS_UV\nv_uv=TEXCOORD_0;\n#else\nv_uv=vec2(0.,0.);\n#endif\n#ifdef O3_NEED_TILINGOFFSET\nv_uv=v_uv*u_tilingOffset.xy+u_tilingOffset.zw;\n#endif\n";// eslint-disable-line
  var worldpos_vert="#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvec4 temp_pos=u_modelMat*position;v_pos=temp_pos.xyz/temp_pos.w;\n#endif\n";// eslint-disable-line
  var shadow_vert="#define GLSLIFY 1\n#ifdef O3_GENERATE_SHADOW_MAP\ngl_Position=u_projMatFromLight*u_viewMatFromLight*u_modelMat*position;\n#endif\n#ifdef O3_SHADOW_MAP_COUNT\nfor(int i=0;i<O3_SHADOW_MAP_COUNT;i++){v_PositionFromLight[i]=u_projMatFromLight[i]*u_viewMatFromLight[i]*u_modelMat*vec4(POSITION,1.0);}\n#endif\n";// eslint-disable-line
  var fog_vert="#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nv_fogDepth=(u_MVMat*position).xyz;\n#endif\n";// eslint-disable-line
  var direct_light_frag="#define GLSLIFY 1\n#ifdef O3_DIRECT_LIGHT_COUNT\nstruct DirectLight{vec3 color;vec3 direction;};uniform vec3 u_directLightColor[O3_DIRECT_LIGHT_COUNT];uniform vec3 u_directLightDirection[O3_DIRECT_LIGHT_COUNT];\n#endif\n";// eslint-disable-line
  var point_light_frag="#define GLSLIFY 1\n#ifdef O3_POINT_LIGHT_COUNT\nstruct PointLight{vec3 color;vec3 position;float distance;};uniform vec3 u_pointLightColor[O3_POINT_LIGHT_COUNT];uniform vec3 u_pointLightPosition[O3_POINT_LIGHT_COUNT];uniform float u_pointLightDistance[O3_POINT_LIGHT_COUNT];\n#endif\n";// eslint-disable-line
  var spot_light_frag="#define GLSLIFY 1\n#ifdef O3_SPOT_LIGHT_COUNT\nstruct SpotLight{vec3 color;vec3 position;vec3 direction;float distance;float angleCos;float penumbraCos;};uniform vec3 u_spotLightColor[O3_SPOT_LIGHT_COUNT];uniform vec3 u_spotLightPosition[O3_SPOT_LIGHT_COUNT];uniform vec3 u_spotLightDirection[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightDistance[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightAngleCos[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightPenumbraCos[O3_SPOT_LIGHT_COUNT];\n#endif\n";// eslint-disable-line
  var mobile_material_frag="#define GLSLIFY 1\nuniform vec4 u_emissiveColor;uniform vec4 u_diffuseColor;uniform vec4 u_specularColor;uniform float u_shininess;uniform float u_normalIntensity;uniform float u_alphaCutoff;\n#ifdef O3_EMISSIVE_TEXTURE\nuniform sampler2D u_emissiveTexture;\n#endif\n#ifdef O3_DIFFUSE_TEXTURE\nuniform sampler2D u_diffuseTexture;\n#endif\n#ifdef O3_SPECULAR_TEXTURE\nuniform sampler2D u_specularTexture;\n#endif\n#ifdef O3_NORMAL_TEXTURE\nuniform sampler2D u_normalTexture;\n#endif\n";// eslint-disable-line
  var fog_frag="#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nfloat fogDepth=length(v_fogDepth);\n#ifdef O3_FOG_EXP2\nfloat fogFactor=whiteCompliment(exp2(-u_fogDensity*u_fogDensity*fogDepth*fogDepth*LOG2));\n#else\nfloat fogFactor=smoothstep(u_fogNear,u_fogFar,fogDepth);\n#endif\ngl_FragColor.rgb=mix(gl_FragColor.rgb,u_fogColor,fogFactor);\n#endif\n";// eslint-disable-line
  var begin_mobile_frag="#define GLSLIFY 1\nvec4 ambient=vec4(0.0);vec4 emission=u_emissiveColor;vec4 diffuse=u_diffuseColor;vec4 specular=u_specularColor;\n#ifdef O3_EMISSIVE_TEXTURE\nemission*=texture2D(u_emissiveTexture,v_uv);\n#endif\n#ifdef O3_DIFFUSE_TEXTURE\ndiffuse*=texture2D(u_diffuseTexture,v_uv);\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\ndiffuse*=v_color;\n#endif\n#ifdef O3_SPECULAR_TEXTURE\nspecular*=texture2D(u_specularTexture,v_uv);\n#endif\nambient=vec4(u_envMapLight.diffuse*u_envMapLight.diffuseIntensity,1.0)*diffuse;";// eslint-disable-line
  var begin_viewdir_frag="#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvec3 V=normalize(u_cameraPos-v_pos);\n#endif\n";// eslint-disable-line
  var mobile_blinnphong_frag="#define GLSLIFY 1\nvec3 N=getNormal();vec3 lightDiffuse=vec3(0.0,0.0,0.0);vec3 lightSpecular=vec3(0.0,0.0,0.0);\n#ifdef O3_DIRECT_LIGHT_COUNT\nDirectLight directionalLight;for(int i=0;i<O3_DIRECT_LIGHT_COUNT;i++){directionalLight.color=u_directLightColor[i];directionalLight.direction=u_directLightDirection[i];float d=max(dot(N,-directionalLight.direction),0.0);lightDiffuse+=directionalLight.color*d;vec3 halfDir=normalize(V-directionalLight.direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess);lightSpecular+=directionalLight.color*s;}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nPointLight pointLight;for(int i=0;i<O3_POINT_LIGHT_COUNT;i++){pointLight.color=u_pointLightColor[i];pointLight.position=u_pointLightPosition[i];pointLight.distance=u_pointLightDistance[i];vec3 direction=v_pos-pointLight.position;float dist=length(direction);direction/=dist;float decay=clamp(1.0-pow(dist/pointLight.distance,4.0),0.0,1.0);float d=max(dot(N,-direction),0.0)*decay;lightDiffuse+=pointLight.color*d;vec3 halfDir=normalize(V-direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess)*decay;lightSpecular+=pointLight.color*s;}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nSpotLight spotLight;for(int i=0;i<O3_SPOT_LIGHT_COUNT;i++){spotLight.color=u_spotLightColor[i];spotLight.position=u_spotLightPosition[i];spotLight.direction=u_spotLightDirection[i];spotLight.distance=u_spotLightDistance[i];spotLight.angleCos=u_spotLightAngleCos[i];spotLight.penumbraCos=u_spotLightPenumbraCos[i];vec3 direction=spotLight.position-v_pos;float lightDistance=length(direction);direction/=lightDistance;float angleCos=dot(direction,-spotLight.direction);float decay=clamp(1.0-pow(lightDistance/spotLight.distance,4.0),0.0,1.0);float spotEffect=smoothstep(spotLight.penumbraCos,spotLight.angleCos,angleCos);float decayTotal=decay*spotEffect;float d=max(dot(N,direction),0.0)*decayTotal;lightDiffuse+=spotLight.color*d;vec3 halfDir=normalize(V+direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess)*decayTotal;lightSpecular+=spotLight.color*s;}\n#endif\ndiffuse*=vec4(lightDiffuse,1.0);specular*=vec4(lightSpecular,1.0);\n#ifdef ALPHA_CUTOFF\nif(diffuse.a<u_alphaCutoff){discard;}\n#endif\n";// eslint-disable-line
  var noise_common="#define GLSLIFY 1\nvec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec2 mod289(vec2 x){return x-floor(x*(1.0/289.0))*289.0;}float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod7(vec4 x){return x-floor(x*(1.0/7.0))*7.0;}vec3 mod7(vec3 x){return x-floor(x*(1.0/7.0))*7.0;}vec4 permute(vec4 x){return mod289((34.0*x+1.0)*x);}vec3 permute(vec3 x){return mod289((34.0*x+1.0)*x);}float permute(float x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}vec4 fade(vec4 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec2 fade(vec2 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}\n#define K 0.142857142857\n#define Ko 0.428571428571\n#define K2 0.020408163265306\n#define Kd2 0.0714285714285\n#define Kz 0.166666666667\n#define Kzo 0.416666666667\n#define jitter 1.0\n#define jitter1 0.8\n";// eslint-disable-line
  var noise_cellular_2D="#define GLSLIFY 1\nvec2 cellular(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec3 oi=vec3(-1.0,0.0,1.0);vec3 of=vec3(-0.5,0.5,1.5);vec3 px=permute(Pi.x+oi);vec3 p=permute(px.x+Pi.y+oi);vec3 ox=fract(p*K)-Ko;vec3 oy=mod7(floor(p*K))*K-Ko;vec3 dx=Pf.x+0.5+jitter*ox;vec3 dy=Pf.y-of+jitter*oy;vec3 d1=dx*dx+dy*dy;p=permute(px.y+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-0.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d2=dx*dx+dy*dy;p=permute(px.z+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-1.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d3=dx*dx+dy*dy;vec3 d1a=min(d1,d2);d2=max(d1,d2);d2=min(d2,d3);d1=min(d1a,d2);d2=max(d1a,d2);d1.xy=(d1.x<d1.y)? d1.xy : d1.yx;d1.xz=(d1.x<d1.z)? d1.xz : d1.zx;d1.yz=min(d1.yz,d2.yz);d1.y=min(d1.y,d1.z);d1.y=min(d1.y,d2.x);return sqrt(d1.xy);}";// eslint-disable-line
  var noise_cellular_2x2="#define GLSLIFY 1\nvec2 cellular2x2(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec4 Pfx=Pf.x+vec4(-0.5,-1.5,-0.5,-1.5);vec4 Pfy=Pf.y+vec4(-0.5,-0.5,-1.5,-1.5);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 ox=mod7(p)*K+Kd2;vec4 oy=mod7(floor(p*K))*K+Kd2;vec4 dx=Pfx+jitter1*ox;vec4 dy=Pfy+jitter1*oy;vec4 d=dx*dx+dy*dy;d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.y=min(d.y,d.z);d.y=min(d.y,d.w);return sqrt(d.xy);}";// eslint-disable-line
  var noise_cellular_2x2x2="#define GLSLIFY 1\nvec2 cellular2x2x2(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P);vec4 Pfx=Pf.x+vec4(0.0,-1.0,0.0,-1.0);vec4 Pfy=Pf.y+vec4(0.0,0.0,-1.0,-1.0);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 p1=permute(p+Pi.z);vec4 p2=permute(p+Pi.z+vec4(1.0));vec4 ox1=fract(p1*K)-Ko;vec4 oy1=mod7(floor(p1*K))*K-Ko;vec4 oz1=floor(p1*K2)*Kz-Kzo;vec4 ox2=fract(p2*K)-Ko;vec4 oy2=mod7(floor(p2*K))*K-Ko;vec4 oz2=floor(p2*K2)*Kz-Kzo;vec4 dx1=Pfx+jitter1*ox1;vec4 dy1=Pfy+jitter1*oy1;vec4 dz1=Pf.z+jitter1*oz1;vec4 dx2=Pfx+jitter1*ox2;vec4 dy2=Pfy+jitter1*oy2;vec4 dz2=Pf.z-1.0+jitter1*oz2;vec4 d1=dx1*dx1+dy1*dy1+dz1*dz1;vec4 d2=dx2*dx2+dy2*dy2+dz2*dz2;vec4 d=min(d1,d2);d2=max(d1,d2);d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.yzw=min(d.yzw,d2.yzw);d.y=min(d.y,d.z);d.y=min(d.y,d.w);d.y=min(d.y,d2.x);return sqrt(d.xy);}";// eslint-disable-line
  var noise_cellular_3D="#define GLSLIFY 1\nvec2 cellular(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P)-0.5;vec3 Pfx=Pf.x+vec3(1.0,0.0,-1.0);vec3 Pfy=Pf.y+vec3(1.0,0.0,-1.0);vec3 Pfz=Pf.z+vec3(1.0,0.0,-1.0);vec3 p=permute(Pi.x+vec3(-1.0,0.0,1.0));vec3 p1=permute(p+Pi.y-1.0);vec3 p2=permute(p+Pi.y);vec3 p3=permute(p+Pi.y+1.0);vec3 p11=permute(p1+Pi.z-1.0);vec3 p12=permute(p1+Pi.z);vec3 p13=permute(p1+Pi.z+1.0);vec3 p21=permute(p2+Pi.z-1.0);vec3 p22=permute(p2+Pi.z);vec3 p23=permute(p2+Pi.z+1.0);vec3 p31=permute(p3+Pi.z-1.0);vec3 p32=permute(p3+Pi.z);vec3 p33=permute(p3+Pi.z+1.0);vec3 ox11=fract(p11*K)-Ko;vec3 oy11=mod7(floor(p11*K))*K-Ko;vec3 oz11=floor(p11*K2)*Kz-Kzo;vec3 ox12=fract(p12*K)-Ko;vec3 oy12=mod7(floor(p12*K))*K-Ko;vec3 oz12=floor(p12*K2)*Kz-Kzo;vec3 ox13=fract(p13*K)-Ko;vec3 oy13=mod7(floor(p13*K))*K-Ko;vec3 oz13=floor(p13*K2)*Kz-Kzo;vec3 ox21=fract(p21*K)-Ko;vec3 oy21=mod7(floor(p21*K))*K-Ko;vec3 oz21=floor(p21*K2)*Kz-Kzo;vec3 ox22=fract(p22*K)-Ko;vec3 oy22=mod7(floor(p22*K))*K-Ko;vec3 oz22=floor(p22*K2)*Kz-Kzo;vec3 ox23=fract(p23*K)-Ko;vec3 oy23=mod7(floor(p23*K))*K-Ko;vec3 oz23=floor(p23*K2)*Kz-Kzo;vec3 ox31=fract(p31*K)-Ko;vec3 oy31=mod7(floor(p31*K))*K-Ko;vec3 oz31=floor(p31*K2)*Kz-Kzo;vec3 ox32=fract(p32*K)-Ko;vec3 oy32=mod7(floor(p32*K))*K-Ko;vec3 oz32=floor(p32*K2)*Kz-Kzo;vec3 ox33=fract(p33*K)-Ko;vec3 oy33=mod7(floor(p33*K))*K-Ko;vec3 oz33=floor(p33*K2)*Kz-Kzo;vec3 dx11=Pfx+jitter*ox11;vec3 dy11=Pfy.x+jitter*oy11;vec3 dz11=Pfz.x+jitter*oz11;vec3 dx12=Pfx+jitter*ox12;vec3 dy12=Pfy.x+jitter*oy12;vec3 dz12=Pfz.y+jitter*oz12;vec3 dx13=Pfx+jitter*ox13;vec3 dy13=Pfy.x+jitter*oy13;vec3 dz13=Pfz.z+jitter*oz13;vec3 dx21=Pfx+jitter*ox21;vec3 dy21=Pfy.y+jitter*oy21;vec3 dz21=Pfz.x+jitter*oz21;vec3 dx22=Pfx+jitter*ox22;vec3 dy22=Pfy.y+jitter*oy22;vec3 dz22=Pfz.y+jitter*oz22;vec3 dx23=Pfx+jitter*ox23;vec3 dy23=Pfy.y+jitter*oy23;vec3 dz23=Pfz.z+jitter*oz23;vec3 dx31=Pfx+jitter*ox31;vec3 dy31=Pfy.z+jitter*oy31;vec3 dz31=Pfz.x+jitter*oz31;vec3 dx32=Pfx+jitter*ox32;vec3 dy32=Pfy.z+jitter*oy32;vec3 dz32=Pfz.y+jitter*oz32;vec3 dx33=Pfx+jitter*ox33;vec3 dy33=Pfy.z+jitter*oy33;vec3 dz33=Pfz.z+jitter*oz33;vec3 d11=dx11*dx11+dy11*dy11+dz11*dz11;vec3 d12=dx12*dx12+dy12*dy12+dz12*dz12;vec3 d13=dx13*dx13+dy13*dy13+dz13*dz13;vec3 d21=dx21*dx21+dy21*dy21+dz21*dz21;vec3 d22=dx22*dx22+dy22*dy22+dz22*dz22;vec3 d23=dx23*dx23+dy23*dy23+dz23*dz23;vec3 d31=dx31*dx31+dy31*dy31+dz31*dz31;vec3 d32=dx32*dx32+dy32*dy32+dz32*dz32;vec3 d33=dx33*dx33+dy33*dy33+dz33*dz33;vec3 d1a=min(d11,d12);d12=max(d11,d12);d11=min(d1a,d13);d13=max(d1a,d13);d12=min(d12,d13);vec3 d2a=min(d21,d22);d22=max(d21,d22);d21=min(d2a,d23);d23=max(d2a,d23);d22=min(d22,d23);vec3 d3a=min(d31,d32);d32=max(d31,d32);d31=min(d3a,d33);d33=max(d3a,d33);d32=min(d32,d33);vec3 da=min(d11,d21);d21=max(d11,d21);d11=min(da,d31);d31=max(da,d31);d11.xy=(d11.x<d11.y)? d11.xy : d11.yx;d11.xz=(d11.x<d11.z)? d11.xz : d11.zx;d12=min(d12,d21);d12=min(d12,d22);d12=min(d12,d31);d12=min(d12,d32);d11.yz=min(d11.yz,d12.xy);d11.y=min(d11.y,d12.z);d11.y=min(d11.y,d11.z);return sqrt(d11.xy);}";// eslint-disable-line
  var noise_cellular="#define GLSLIFY 1\n#include <noise_cellular_2D>\n#include <noise_cellular_3D>\n#include <noise_cellular_2x2>\n#include <noise_cellular_2x2x2>\n";// eslint-disable-line
  var noise_perlin_2D="#define GLSLIFY 1\nfloat perlin(vec2 P){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}float perlin(vec2 P,vec2 rep){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod(Pi,rep.xyxy);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}";// eslint-disable-line
  var noise_perlin_3D="#define GLSLIFY 1\nfloat perlin(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}float perlin(vec3 P,vec3 rep){vec3 Pi0=mod(floor(P),rep);vec3 Pi1=mod(Pi0+vec3(1.0),rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}";// eslint-disable-line
  var noise_perlin_4D="#define GLSLIFY 1\nfloat perlin(vec4 P){vec4 Pi0=floor(P);vec4 Pi1=Pi0+1.0;Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}float perlin(vec4 P,vec4 rep){vec4 Pi0=mod(floor(P),rep);vec4 Pi1=mod(Pi0+1.0,rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}";// eslint-disable-line
  var noise_perlin="#define GLSLIFY 1\n#include <noise_perlin_2D>\n#include <noise_perlin_3D>\n#include <noise_perlin_4D>\n";// eslint-disable-line
  var noise_psrd_2D="#define GLSLIFY 1\nvec2 rgrad2(vec2 p,float rot){float u=permute(permute(p.x)+p.y)*0.0243902439+rot;u=fract(u)*6.28318530718;return vec2(cos(u),sin(u));}vec3 psrdnoise(vec2 pos,vec2 per,float rot){pos.y+=0.01;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 psdnoise(vec2 pos,vec2 per){return psrdnoise(pos,per,0.0);}float psrnoise(vec2 pos,vec2 per,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float psnoise(vec2 pos,vec2 per){return psrnoise(pos,per,0.0);}vec3 srdnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 sdnoise(vec2 pos){return srdnoise(pos,0.0);}float srnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float snoise(vec2 pos){return srnoise(pos,0.0);}";// eslint-disable-line
  var noise_simplex_2D="#define GLSLIFY 1\nfloat simplex(vec2 v){const vec4 C=vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);vec2 i=floor(v+dot(v,C.yy));vec2 x0=v-i+dot(i,C.xx);vec2 i1;i1=(x0.x>x0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec4 x12=x0.xyxy+C.xxzz;x12.xy-=i1;i=mod289(i);vec3 p=permute(permute(i.y+vec3(0.0,i1.y,1.0))+i.x+vec3(0.0,i1.x,1.0));vec3 m=max(0.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.0);m=m*m;m=m*m;vec3 x=2.0*fract(p*C.www)-1.0;vec3 h=abs(x)-0.5;vec3 ox=floor(x+0.5);vec3 a0=x-ox;m*=1.79284291400159-0.85373472095314*(a0*a0+h*h);vec3 g;g.x=a0.x*x0.x+h.x*x0.y;g.yz=a0.yz*x12.xz+h.yz*x12.yw;return 130.0*dot(m,g);}";// eslint-disable-line
  var noise_simplex_3D_grad="#define GLSLIFY 1\nfloat simplex(vec3 v,out vec3 gradient){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);vec4 m2=m*m;vec4 m4=m2*m2;vec4 pdotx=vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3));vec4 temp=m2*m*pdotx;gradient=-8.0*(temp.x*x0+temp.y*x1+temp.z*x2+temp.w*x3);gradient+=m4.x*p0+m4.y*p1+m4.z*p2+m4.w*p3;gradient*=42.0;return 42.0*dot(m4,pdotx);}";// eslint-disable-line
  var noise_simplex_3D="#define GLSLIFY 1\nfloat simplex(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}";// eslint-disable-line
  var noise_simplex_4D="#define GLSLIFY 1\nvec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}\n#define F4 0.309016994374947451\nfloat simplex(vec4 v){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v+dot(v,vec4(F4)));vec4 x0=v-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 m0=max(0.6-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.6-vec2(dot(x3,x3),dot(x4,x4)),0.0);m0=m0*m0;m1=m1*m1;return 49.0*(dot(m0*m0,vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2)))+dot(m1*m1,vec2(dot(p3,x3),dot(p4,x4))));}";// eslint-disable-line
  var noise_simplex="#define GLSLIFY 1\n#include <noise_simplex_2D>\n#include <noise_simplex_3D>\n#include <noise_simplex_3D_grad>\n#include <noise_simplex_4D>\n";// eslint-disable-line
  var gamma_frag="#define GLSLIFY 1\n#ifdef GAMMA\nfloat gamma=2.2;gl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(1.0/gamma));\n#endif\n";// eslint-disable-line
  var pbr_common_frag_define="#define GLSLIFY 1\n#ifndef EPSILON\n#define EPSILON 1e-6\n#endif\n#ifndef RECIPROCAL_PI\n#define RECIPROCAL_PI 0.31830988618\n#endif\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n#define RE_Direct RE_Direct_Physical\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material ) GGXRoughnessToBlinnExponent( material.specularRoughness )\n";// eslint-disable-line
  var pbr_util_frag_define="#define GLSLIFY 1\nvec4 SRGBtoLINEAR(vec4 srgbIn){\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\nvec3 linOut=pow(srgbIn.xyz,vec3(2.2));\n#else\nvec3 bLess=step(vec3(0.04045),srgbIn.xyz);vec3 linOut=mix(srgbIn.xyz/vec3(12.92),pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)),bLess);\n#endif\nreturn vec4(linOut,srgbIn.w);;\n#else\nreturn srgbIn;\n#endif\n}float pow2(const in float x){return x*x;}vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}vec3 BRDF_Diffuse_Lambert(const in vec3 diffuseColor){return RECIPROCAL_PI*diffuseColor;}float GGXRoughnessToBlinnExponent(const in float ggxRoughness){return(2.0/pow2(ggxRoughness+0.0001)-2.0);}float computeSpecularOcclusion(const in float dotNV,const in float ambientOcclusion,const in float roughness){return saturate(pow(dotNV+ambientOcclusion,exp2(-16.0*roughness-1.0))-1.0+ambientOcclusion);}";// eslint-disable-line
  var pbr_envmap_light_frag_define="#define GLSLIFY 1\nstruct EnvMapLight{vec3 diffuse;float mipMapLevel;float diffuseIntensity;float specularIntensity;mat4 transformMatrix;};uniform EnvMapLight u_envMapLight;\n#ifdef O3_USE_SH\nuniform vec3 u_env_sh[9];\n#endif\n#ifdef O3_USE_SPECULAR_ENV\nuniform samplerCube u_env_specularSampler;\n#endif\n";// eslint-disable-line
  var pbr_base_frag_define="#define GLSLIFY 1\nuniform float u_alphaCutoff;uniform vec4 u_baseColor;uniform float u_metal;uniform float u_roughness;uniform vec3 u_specularColor;uniform float u_glossinessFactor;uniform vec3 u_emissiveColor;uniform float u_normalIntensity;uniform float u_occlusionStrength;";// eslint-disable-line
  var pbr_texture_frag_define="#define GLSLIFY 1\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_baseColorSampler;\n#endif\n#ifdef O3_NORMAL_TEXTURE\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_emissiveSampler;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_metallicRoughnessSampler;\n#endif\n#ifdef HAS_SPECULARGLOSSINESSMAP\nuniform sampler2D u_specularGlossinessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_occlusionSampler;\n#endif\n";// eslint-disable-line
  var pbr_runtime_frag_define="#define GLSLIFY 1\nstruct IncidentLight{vec3 color;vec3 direction;};struct ReflectedLight{vec3 directDiffuse;vec3 directSpecular;vec3 indirectDiffuse;vec3 indirectSpecular;};struct GeometricContext{vec3 position;vec3 normal;vec3 viewDir;};struct PhysicalMaterial{vec3 diffuseColor;float specularRoughness;vec3 specularColor;};";// eslint-disable-line
  var pbr_brdf_cook_torrance_frag_define="#define GLSLIFY 1\nvec3 F_Schlick(const in vec3 specularColor,const in float dotLH){float fresnel=exp2((-5.55473*dotLH-6.98316)*dotLH);return(1.0-specularColor)*fresnel+specularColor;}float G_GGX_SmithCorrelated(const in float alpha,const in float dotNL,const in float dotNV){float a2=pow2(alpha);float gv=dotNL*sqrt(a2+(1.0-a2)*pow2(dotNV));float gl=dotNV*sqrt(a2+(1.0-a2)*pow2(dotNL));return 0.5/max(gv+gl,EPSILON);}float D_GGX(const in float alpha,const in float dotNH){float a2=pow2(alpha);float denom=pow2(dotNH)*(a2-1.0)+1.0;return RECIPROCAL_PI*a2/pow2(denom);}vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight,const in GeometricContext geometry,const in vec3 specularColor,const in float roughness){float alpha=pow2(roughness);vec3 halfDir=normalize(incidentLight.direction+geometry.viewDir);float dotNL=saturate(dot(geometry.normal,incidentLight.direction));float dotNV=saturate(dot(geometry.normal,geometry.viewDir));float dotNH=saturate(dot(geometry.normal,halfDir));float dotLH=saturate(dot(incidentLight.direction,halfDir));vec3 F=F_Schlick(specularColor,dotLH);float G=G_GGX_SmithCorrelated(alpha,dotNL,dotNV);float D=D_GGX(alpha,dotNH);return F*(G*D);}";// eslint-disable-line
  var pbr_direct_irradiance_frag_define="#define GLSLIFY 1\nvoid RE_Direct_Physical(const in IncidentLight directLight,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){float dotNL=saturate(dot(geometry.normal,directLight.direction));vec3 irradiance=dotNL*directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance*=PI;\n#endif\nreflectedLight.directSpecular+=irradiance*BRDF_Specular_GGX(directLight,geometry,material.specularColor,material.specularRoughness);reflectedLight.directDiffuse+=irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);}\n#ifdef O3_DIRECT_LIGHT_COUNT\nvoid getDirectionalDirectLightIrradiance(const in DirectLight directionalLight,const in GeometricContext geometry,out IncidentLight directLight){directLight.color=directionalLight.color;directLight.direction=-directionalLight.direction;}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nvoid getPointDirectLightIrradiance(const in PointLight pointLight,const in GeometricContext geometry,out IncidentLight directLight){vec3 lVector=pointLight.position-geometry.position;directLight.direction=normalize(lVector);float lightDistance=length(lVector);directLight.color=pointLight.color;directLight.color*=clamp(1.0-pow(lightDistance/pointLight.distance,4.0),0.0,1.0);}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nvoid getSpotDirectLightIrradiance(const in SpotLight spotLight,const in GeometricContext geometry,out IncidentLight directLight){vec3 lVector=spotLight.position-geometry.position;directLight.direction=normalize(lVector);float lightDistance=length(lVector);float angleCos=dot(directLight.direction,-spotLight.direction);float spotEffect=smoothstep(spotLight.penumbraCos,spotLight.angleCos,angleCos);float decayEffect=clamp(1.0-pow(lightDistance/spotLight.distance,4.0),0.0,1.0);directLight.color=spotLight.color;directLight.color*=spotEffect*decayEffect;}\n#endif\n";// eslint-disable-line
  var pbr_ibl_specular_frag_define="#define GLSLIFY 1\nvec3 BRDF_Specular_GGX_Environment(const in GeometricContext geometry,const in vec3 specularColor,const in float roughness){float dotNV=saturate(dot(geometry.normal,geometry.viewDir));const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}float getSpecularMIPLevel(const in float blinnShininessExponent,const in int maxMIPLevel){float maxMIPLevelScalar=float(maxMIPLevel);float desiredMIPLevel=maxMIPLevelScalar+0.79248-0.5*log2(pow2(blinnShininessExponent)+1.0);return clamp(desiredMIPLevel,0.0,maxMIPLevelScalar);}vec3 getLightProbeIndirectRadiance(const in GeometricContext geometry,const in float blinnShininessExponent,const in int maxMIPLevel){\n#ifndef O3_USE_SPECULAR_ENV\nreturn vec3(0.0);\n#else\nvec3 reflectVec=reflect(-geometry.viewDir,geometry.normal);float specularMIPLevel=getSpecularMIPLevel(blinnShininessExponent,maxMIPLevel);\n#ifdef HAS_TEX_LOD\nvec4 envMapColor=textureCubeLodEXT(u_env_specularSampler,reflectVec,specularMIPLevel);\n#else\nvec4 envMapColor=textureCube(u_env_specularSampler,reflectVec,specularMIPLevel);\n#endif\nenvMapColor.rgb=SRGBtoLINEAR(envMapColor*u_envMapLight.specularIntensity).rgb;return envMapColor.rgb;\n#endif\n}void RE_IndirectSpecular_Physical(const in vec3 radiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){float dotNV=saturate(dot(geometry.normal,geometry.viewDir));float dotNL=dotNV;reflectedLight.indirectSpecular+=radiance*BRDF_Specular_GGX_Environment(geometry,material.specularColor,material.specularRoughness);}";// eslint-disable-line
  var pbr_ibl_diffuse_frag_define="#define GLSLIFY 1\nvoid RE_IndirectDiffuse_Physical(const in vec3 irradiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){reflectedLight.indirectDiffuse+=irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);}vec3 getLightProbeIrradiance(vec3 sh[9],vec3 normal){vec3 result=sh[0]+sh[1]*(normal.y)+sh[2]*(normal.z)+sh[3]*(normal.x)+sh[4]*(normal.y*normal.x)+sh[5]*(normal.y*normal.z)+sh[6]*(3.0*normal.z*normal.z-1.0)+sh[7]*(normal.z*normal.x)+sh[8]*(normal.x*normal.x-normal.y*normal.y);return max(result,vec3(0.0));}";// eslint-disable-line
  var pbr_begin_frag="#define GLSLIFY 1\nvec3 normal=getNormal();vec4 diffuseColor=u_baseColor;vec3 totalEmissiveRadiance=u_emissiveColor;float metalnessFactor=u_metal;float roughnessFactor=u_roughness;vec3 specularFactor=u_specularColor;float glossinessFactor=u_glossinessFactor;ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));PhysicalMaterial material;GeometricContext geometry;IncidentLight directLight;\n#ifdef HAS_BASECOLORMAP\nvec4 baseMapColor=texture2D(u_baseColorSampler,v_uv);baseMapColor=SRGBtoLINEAR(baseMapColor);diffuseColor*=baseMapColor;\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\ndiffuseColor*=v_color;\n#endif\n#ifdef ALPHA_CUTOFF\nif(diffuseColor.a<u_alphaCutoff){discard;}\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nvec4 metalRoughMapColor=texture2D(u_metallicRoughnessSampler,v_uv);roughnessFactor*=metalRoughMapColor.g;metalnessFactor*=metalRoughMapColor.b;\n#endif\n#ifdef HAS_SPECULARGLOSSINESSMAP\nvec4 specularGlossinessColor=texture2D(u_specularGlossinessSampler,v_uv);specularFactor*=specularGlossinessColor.rgb;glossinessFactor*=specularGlossinessColor.a;\n#endif\n#ifdef IS_METALLIC_WORKFLOW\nmaterial.diffuseColor=diffuseColor.rgb*(1.0-metalnessFactor);material.specularRoughness=clamp(roughnessFactor,0.04,1.0);material.specularColor=mix(vec3(MAXIMUM_SPECULAR_COEFFICIENT),diffuseColor.rgb,metalnessFactor);\n#else\nfloat specularStrength=max(max(specularFactor.r,specularFactor.g),specularFactor.b);material.diffuseColor=diffuseColor.rgb*(1.0-specularStrength);material.specularRoughness=clamp(1.0-glossinessFactor,0.04,1.0);material.specularColor=specularFactor;\n#endif\ngeometry.position=v_pos;geometry.normal=normal;geometry.viewDir=normalize(u_cameraPos-v_pos);";// eslint-disable-line
  var pbr_direct_irradiance_frag="#define GLSLIFY 1\n#if defined( O3_DIRECT_LIGHT_COUNT ) && defined( RE_Direct )\nDirectLight directionalLight;for(int i=0;i<O3_DIRECT_LIGHT_COUNT;i++){directionalLight.color=u_directLightColor[i];directionalLight.direction=u_directLightDirection[i];getDirectionalDirectLightIrradiance(directionalLight,geometry,directLight);RE_Direct(directLight,geometry,material,reflectedLight);}\n#endif\n#if defined( O3_POINT_LIGHT_COUNT ) && defined( RE_Direct )\nPointLight pointLight;for(int i=0;i<O3_POINT_LIGHT_COUNT;i++){pointLight.color=u_pointLightColor[i];pointLight.position=u_pointLightPosition[i];pointLight.distance=u_pointLightDistance[i];getPointDirectLightIrradiance(pointLight,geometry,directLight);RE_Direct(directLight,geometry,material,reflectedLight);}\n#endif\n#if defined( O3_SPOT_LIGHT_COUNT ) && defined( RE_Direct )\nSpotLight spotLight;for(int i=0;i<O3_SPOT_LIGHT_COUNT;i++){spotLight.color=u_spotLightColor[i];spotLight.position=u_spotLightPosition[i];spotLight.direction=u_spotLightDirection[i];spotLight.distance=u_spotLightDistance[i];spotLight.angleCos=u_spotLightAngleCos[i];spotLight.penumbraCos=u_spotLightPenumbraCos[i];getSpotDirectLightIrradiance(spotLight,geometry,directLight);RE_Direct(directLight,geometry,material,reflectedLight);}\n#endif\n";// eslint-disable-line
  var pbr_ibl_diffuse_frag="#define GLSLIFY 1\n#ifdef O3_USE_SH\nvec3 irradiance=getLightProbeIrradiance(u_env_sh,normal)*u_envMapLight.diffuseIntensity;\n#else\nvec3 irradiance=u_envMapLight.diffuse*u_envMapLight.diffuseIntensity;\n#endif\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance*=PI;\n#endif\nRE_IndirectDiffuse_Physical(irradiance,geometry,material,reflectedLight);";// eslint-disable-line
  var pbr_ibl_specular_frag="#define GLSLIFY 1\n#if defined( RE_IndirectSpecular )\nvec3 radiance=vec3(0.0);\n#endif\n#if defined( RE_IndirectSpecular )\nradiance+=getLightProbeIndirectRadiance(geometry,Material_BlinnShininessExponent(material),int(u_envMapLight.mipMapLevel));\n#endif\n#if defined( RE_IndirectSpecular )\nRE_IndirectSpecular(radiance,geometry,material,reflectedLight);\n#endif\n";// eslint-disable-line
  var pbr_end_frag="#define GLSLIFY 1\n#ifdef HAS_OCCLUSIONMAP\nfloat ambientOcclusion=(texture2D(u_occlusionSampler,v_uv).r-1.0)*u_occlusionStrength+1.0;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined(O3_USE_SPECULAR_ENV)\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.specularRoughness);\n#endif\n#endif\n#ifdef HAS_EMISSIVEMAP\nvec4 emissiveMapColor=texture2D(u_emissiveSampler,v_uv);emissiveMapColor=SRGBtoLINEAR(emissiveMapColor);totalEmissiveRadiance*=emissiveMapColor.rgb;\n#endif\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+totalEmissiveRadiance;gl_FragColor=vec4(outgoingLight,diffuseColor.a);";// eslint-disable-line
  var PBRShaderLib={pbr_common_frag_define:pbr_common_frag_define,pbr_util_frag_define:pbr_util_frag_define,pbr_envmap_light_frag_define:pbr_envmap_light_frag_define,pbr_base_frag_define:pbr_base_frag_define,pbr_texture_frag_define:pbr_texture_frag_define,pbr_runtime_frag_define:pbr_runtime_frag_define,pbr_brdf_cook_torrance_frag_define:pbr_brdf_cook_torrance_frag_define,pbr_direct_irradiance_frag_define:pbr_direct_irradiance_frag_define,pbr_ibl_specular_frag_define:pbr_ibl_specular_frag_define,pbr_ibl_diffuse_frag_define:pbr_ibl_diffuse_frag_define,pbr_begin_frag:pbr_begin_frag,pbr_direct_irradiance_frag:pbr_direct_irradiance_frag,pbr_ibl_diffuse_frag:pbr_ibl_diffuse_frag,pbr_ibl_specular_frag:pbr_ibl_specular_frag,pbr_end_frag:pbr_end_frag};var normal_get="#define GLSLIFY 1\nvec3 getNormal(){\n#ifdef O3_NORMAL_TEXTURE\n#ifndef O3_HAS_TANGENT\n#ifdef HAS_DERIVATIVES\nvec3 pos_dx=dFdx(v_pos);vec3 pos_dy=dFdy(v_pos);vec3 tex_dx=dFdx(vec3(v_uv,0.0));vec3 tex_dy=dFdy(vec3(v_uv,0.0));vec3 t=(tex_dy.t*pos_dx-tex_dx.t*pos_dy)/(tex_dx.s*tex_dy.t-tex_dy.s*tex_dx.t);\n#ifdef O3_HAS_NORMAL\nvec3 ng=normalize(v_normal);\n#else\nvec3 ng=normalize(cross(pos_dx,pos_dy));\n#endif\nt=normalize(t-ng*dot(ng,t));vec3 b=normalize(cross(ng,t));mat3 tbn=mat3(t,b,ng);\n#else\n#ifdef O3_HAS_NORMAL\nvec3 ng=normalize(v_normal);\n#else\nvec3 ng=vec3(0.0,0.0,1.0);\n#endif\nmat3 tbn=mat3(vec3(0.0),vec3(0.0),ng);\n#endif\n#else\nmat3 tbn=v_TBN;\n#endif\nvec3 n=texture2D(u_normalTexture,v_uv).rgb;n=normalize(tbn*((2.0*n-1.0)*vec3(u_normalIntensity,u_normalIntensity,1.0)));\n#else\n#ifdef O3_HAS_NORMAL\nvec3 n=normalize(v_normal);\n#elif defined(HAS_DERIVATIVES)\nvec3 pos_dx=dFdx(v_pos);vec3 pos_dy=dFdy(v_pos);vec3 n=normalize(cross(pos_dx,pos_dy));\n#else\nvec3 n=vec3(0.0,0.0,1.0);\n#endif\n#endif\nn*=float(gl_FrontFacing)*2.0-1.0;return n;}";// eslint-disable-line
  var ShaderLib=_objectSpread2$2(_objectSpread2$2({common:common,common_vert:common_vert,common_frag:common_frag,color_share:color_share,normal_share:normal_share,uv_share:uv_share,worldpos_share:worldpos_share,shadow_share:shadow_share,fog_share:fog_share,begin_normal_vert:begin_normal_vert,begin_position_vert:begin_position_vert,position_vert:position_vert,color_vert:color_vert,normal_vert:normal_vert,skinning_vert:skinning_vert,blendShape_input:blendShape_input,blendShape_vert:blendShape_vert,uv_vert:uv_vert,worldpos_vert:worldpos_vert,shadow_vert:shadow_vert,fog_vert:fog_vert,direct_light_frag:direct_light_frag,point_light_frag:point_light_frag,spot_light_frag:spot_light_frag,mobile_material_frag:mobile_material_frag,fog_frag:fog_frag,begin_mobile_frag:begin_mobile_frag,begin_viewdir_frag:begin_viewdir_frag,mobile_blinnphong_frag:mobile_blinnphong_frag,noise_common:noise_common,noise_cellular_2D:noise_cellular_2D,noise_cellular_2x2:noise_cellular_2x2,noise_cellular_2x2x2:noise_cellular_2x2x2,noise_cellular_3D:noise_cellular_3D,noise_cellular:noise_cellular,noise_perlin_2D:noise_perlin_2D,noise_perlin_3D:noise_perlin_3D,noise_perlin_4D:noise_perlin_4D,noise_perlin:noise_perlin,noise_psrd_2D:noise_psrd_2D,noise_simplex_2D:noise_simplex_2D,noise_simplex_3D_grad:noise_simplex_3D_grad,noise_simplex_3D:noise_simplex_3D,noise_simplex_4D:noise_simplex_4D,noise_simplex:noise_simplex,gamma_frag:gamma_frag},PBRShaderLib),{},{normal_get:normal_get});var ShaderFactory=/*#__PURE__*/function(){function ShaderFactory(){}ShaderFactory.parseCustomMacros=function parseCustomMacros(macros){return macros.map(function(m){return "#define "+m+"\n";}).join("");};ShaderFactory.parseIncludes=function parseIncludes(src){var regex=/^[ \t]*#include +<([\w\d.]+)>/gm;function replace(match,slice){var replace=ShaderLib[slice];if(replace===undefined){Logger.error("Shader slice \""+match.trim()+"\" not founded.");return "";}return ShaderFactory.parseIncludes(replace);}return src.replace(regex,replace);}/**
     * GLSL extension.
     * @param {string[]} extensions - such as ["GL_EXT_shader_texture_lod"]
     * */;ShaderFactory.parseExtension=function parseExtension(extensions){return extensions.map(function(e){return "#extension "+e+" : enable\n";}).join("");}/**
     * Convert lower GLSL version to GLSL 300 es.
     * @param shader - code
     * @param isFrag - Whether it is a fragment shader.
     * */;ShaderFactory.convertTo300=function convertTo300(shader,isFrag){/** replace attribute and in */shader=shader.replace(/\battribute\b/g,"in");shader=shader.replace(/\bvarying\b/g,isFrag?"in":"out");/** replace api */shader=shader.replace(/\btexture(2D|Cube)\b/g,"texture");shader=shader.replace(/\btexture(2D|Cube)LodEXT\b/g,"textureLod");if(isFrag){var isMRT=/\bgl_FragData\[.+?\]/g.test(shader);if(isMRT){shader=shader.replace(/\bgl_FragColor\b/g,"gl_FragData[0]");var result=shader.match(/\bgl_FragData\[.+?\]/g);shader=this._replaceMRTShader(shader,result);}else {shader=shader.replace(/void\s+?main\s*\(/g,"out vec4 glFragColor;\nvoid main(");shader=shader.replace(/\bgl_FragColor\b/g,"glFragColor");}}return shader;};ShaderFactory._replaceMRTShader=function _replaceMRTShader(shader,result){var declaration="";var mrtIndexSet=new Set();for(var i=0;i<result.length;i++){var res=result[i].match(/\bgl_FragData\[(.+?)\]/);mrtIndexSet.add(res[1]);}mrtIndexSet.forEach(function(index){declaration+="layout(location="+index+") out vec4 fragOutColor"+index+";\n";});declaration+="void main(";shader=shader.replace(/\bgl_FragData\[(.+?)\]/g,"fragOutColor$1");shader=shader.replace(/void\s+?main\s*\(/g,declaration);return shader;};return ShaderFactory;}();/**
   * Shader macro。
   */var ShaderMacro=/** name */ /** @internal */ /** @internal */ /**
   * @internal
   */function ShaderMacro(name,index,value){this.name=void 0;this._index=void 0;this._value=void 0;this.name=name;this._index=index;this._value=value;};/**
   * Shader uniform。
   * @internal
   */var ShaderUniform=/*#__PURE__*/function(){function ShaderUniform(engine){this.name=void 0;this.propertyId=void 0;this.location=void 0;this.applyFunc=void 0;this.cacheValue=void 0;this.textureIndex=void 0;this.textureDefault=void 0;this._rhi=void 0;this._gl=void 0;var rhi=engine._hardwareRenderer;this._rhi=rhi;this._gl=rhi.gl;}var _proto=ShaderUniform.prototype;_proto.upload1f=function upload1f(shaderUniform,value){if(this.cacheValue!==value){this._gl.uniform1f(shaderUniform.location,value);this.cacheValue=value;}};_proto.upload1fv=function upload1fv(shaderUniform,value){this._gl.uniform1fv(shaderUniform.location,value);};_proto.upload2f=function upload2f(shaderUniform,value){var cacheValue=this.cacheValue;if(value.r!==undefined){if(cacheValue.x!==value.r||cacheValue.y!==value.g){this._gl.uniform2f(shaderUniform.location,value.r,value.g);cacheValue.x=value.r;cacheValue.y=value.g;}}else {if(cacheValue.x!==value.x||cacheValue.y!==value.y){this._gl.uniform2f(shaderUniform.location,value.x,value.y);cacheValue.x=value.x;cacheValue.y=value.y;}}};_proto.upload2fv=function upload2fv(shaderUniform,value){this._gl.uniform2fv(shaderUniform.location,value);};_proto.upload3f=function upload3f(shaderUniform,value){var cacheValue=this.cacheValue;if(value.r!==undefined){if(cacheValue.x!==value.r||cacheValue.y!==value.g||cacheValue.z!==value.b){this._gl.uniform3f(shaderUniform.location,value.r,value.g,value.b);cacheValue.x=value.r;cacheValue.y=value.g;cacheValue.z=value.b;}}else {if(cacheValue.x!==value.x||cacheValue.y!==value.y||cacheValue.z!==value.z){this._gl.uniform3f(shaderUniform.location,value.x,value.y,value.z);cacheValue.x=value.x;cacheValue.y=value.y;cacheValue.z=value.z;}}};_proto.upload3fv=function upload3fv(shaderUniform,value){this._gl.uniform3fv(shaderUniform.location,value);};_proto.upload4f=function upload4f(shaderUniform,value){var cacheValue=this.cacheValue;if(value.r!==undefined){if(cacheValue.x!==value.r||cacheValue.y!==value.g||cacheValue.z!==value.b||cacheValue.w!==value.a){this._gl.uniform4f(shaderUniform.location,value.r,value.g,value.b,value.a);cacheValue.x=value.r;cacheValue.y=value.g;cacheValue.z=value.b;cacheValue.w=value.a;}}else {if(cacheValue.x!==value.x||cacheValue.y!==value.y||cacheValue.z!==value.z||cacheValue.w!==value.w){this._gl.uniform4f(shaderUniform.location,value.x,value.y,value.z,value.w);cacheValue.x=value.x;cacheValue.y=value.y;cacheValue.z=value.z;cacheValue.w=value.w;}}};_proto.upload4fv=function upload4fv(shaderUniform,value){this._gl.uniform4fv(shaderUniform.location,value);};_proto.upload1i=function upload1i(shaderUniform,value){if(this.cacheValue!==value){this._gl.uniform1i(shaderUniform.location,value);this.cacheValue=value;}};_proto.upload1iv=function upload1iv(shaderUniform,value){this._gl.uniform1iv(shaderUniform.location,value);};_proto.upload2i=function upload2i(shaderUniform,value){var cacheValue=this.cacheValue;if(value.r!==undefined){if(cacheValue.x!==value.r||cacheValue.y!==value.g){this._gl.uniform2i(shaderUniform.location,value.r,value.g);cacheValue.x=value.r;cacheValue.y=value.g;}}else {if(cacheValue.x!==value.x||cacheValue.y!==value.y){this._gl.uniform2i(shaderUniform.location,value.x,value.y);cacheValue.x=value.x;cacheValue.y=value.y;}}};_proto.upload2iv=function upload2iv(shaderUniform,value){this._gl.uniform2iv(shaderUniform.location,value);};_proto.upload3i=function upload3i(shaderUniform,value){var cacheValue=this.cacheValue;if(value.r!==undefined){if(cacheValue.x!==value.r||cacheValue.y!==value.g||cacheValue.z!==value.b){this._gl.uniform3i(shaderUniform.location,value.r,value.g,value.b);cacheValue.x=value.r;cacheValue.y=value.g;cacheValue.z=value.b;}}else {if(cacheValue.x!==value.x||cacheValue.y!==value.y||cacheValue.z!==value.z){this._gl.uniform3i(shaderUniform.location,value.x,value.y,value.z);cacheValue.x=value.x;cacheValue.y=value.y;cacheValue.z=value.z;}}};_proto.upload3iv=function upload3iv(shaderUniform,value){this._gl.uniform3iv(shaderUniform.location,value);};_proto.upload4i=function upload4i(shaderUniform,value){var cacheValue=this.cacheValue;if(value.r!==undefined){if(cacheValue.x!==value.r||cacheValue.y!==value.g||cacheValue.z!==value.b||cacheValue.w!==value.a){this._gl.uniform4i(shaderUniform.location,value.r,value.g,value.b,value.a);cacheValue.x=value.r;cacheValue.y=value.g;cacheValue.z=value.b;cacheValue.w=value.a;}}else {if(cacheValue.x!==value.x||cacheValue.y!==value.y||cacheValue.z!==value.z||cacheValue.w!==value.w){this._gl.uniform4i(shaderUniform.location,value.x,value.y,value.z,value.w);cacheValue.x=value.x;cacheValue.y=value.y;cacheValue.z=value.z;cacheValue.w=value.w;}}};_proto.upload4iv=function upload4iv(shaderUniform,value){this._gl.uniform4iv(shaderUniform.location,value);};_proto.uploadMat4=function uploadMat4(shaderUniform,value){this._gl.uniformMatrix4fv(shaderUniform.location,false,value.elements);};_proto.uploadMat4v=function uploadMat4v(shaderUniform,value){this._gl.uniformMatrix4fv(shaderUniform.location,false,value);};_proto.uploadTexture=function uploadTexture(shaderUniform,value){var rhi=this._rhi;rhi.activeTexture(shaderUniform.textureIndex);rhi.bindTexture(value._platformTexture);};_proto.uploadTextureArray=function uploadTextureArray(shaderUniform,value){var rhi=this._rhi;var textureIndices=shaderUniform.textureIndex;for(var i=0;i<value.length;i++){var texture=value[i];rhi.activeTexture(textureIndices[i]);rhi.bindTexture(texture._platformTexture);}};return ShaderUniform;}();/**
   * Shader uniform block.
   * @internal
   */var ShaderUniformBlock=function ShaderUniformBlock(){this.constUniforms=[];this.textureUniforms=[];};/**
   * Shader program, corresponding to the GPU shader program.
   * @internal
   */var ShaderProgram=/*#__PURE__*/function(){ShaderProgram._addLineNum=function _addLineNum(str){var lines=str.split("\n");var limitLength=(lines.length+1).toString().length+6;var prefix;return lines.map(function(line,index){prefix="0:"+(index+1);if(prefix.length>=limitLength)return prefix.substring(0,limitLength)+line;for(var i=0;i<limitLength-prefix.length;i++){prefix+=" ";}return prefix+line;}).join("\n");};function ShaderProgram(engine,vertexSource,fragmentSource){this.id=void 0;this.sceneUniformBlock=new ShaderUniformBlock();this.cameraUniformBlock=new ShaderUniformBlock();this.rendererUniformBlock=new ShaderUniformBlock();this.materialUniformBlock=new ShaderUniformBlock();this.otherUniformBlock=new ShaderUniformBlock();this._uploadRenderCount=-1;this._uploadCamera=void 0;this._uploadRenderer=void 0;this._uploadMaterial=void 0;this.attributeLocation=Object.create(null);this._isValid=void 0;this._engine=void 0;this._gl=void 0;this._vertexShader=void 0;this._fragmentShader=void 0;this._glProgram=void 0;this._activeTextureUint=0;this._engine=engine;this._gl=engine._hardwareRenderer.gl;this._glProgram=this._createProgram(vertexSource,fragmentSource);if(this._glProgram){this._isValid=true;this._recordLocation();}else {this._isValid=false;}this.id=ShaderProgram._counter++;}/**
     * Upload all shader data in shader uniform block.
     * @param uniformBlock - shader Uniform block
     * @param shaderData - shader data
     */var _proto=ShaderProgram.prototype;_proto.uploadAll=function uploadAll(uniformBlock,shaderData){this.uploadUniforms(uniformBlock,shaderData);this.uploadTextures(uniformBlock,shaderData);}/**
     * Upload constant shader data in shader uniform block.
     * @param uniformBlock - shader Uniform block
     * @param shaderData - shader data
     */;_proto.uploadUniforms=function uploadUniforms(uniformBlock,shaderData){var properties=shaderData._properties;var constUniforms=uniformBlock.constUniforms;for(var i=0,n=constUniforms.length;i<n;i++){var uniform=constUniforms[i];var data=properties[uniform.propertyId];data!=null&&uniform.applyFunc(uniform,data);}}/**
     * Upload texture shader data in shader uniform block.
     * @param uniformBlock - shader Uniform block
     * @param shaderData - shader data
     */;_proto.uploadTextures=function uploadTextures(uniformBlock,shaderData){var properties=shaderData._properties;var textureUniforms=uniformBlock.textureUniforms;// textureUniforms property maybe null if ShaderUniformBlock not contain any texture.
  if(textureUniforms){for(var i=0,n=textureUniforms.length;i<n;i++){var uniform=textureUniforms[i];var texture=properties[uniform.propertyId];if(texture){uniform.applyFunc(uniform,texture);}else {uniform.applyFunc(uniform,uniform.textureDefault);}}}}/**
     * Upload ungroup texture shader data in shader uniform block.
     */;_proto.uploadUngroupTextures=function uploadUngroupTextures(){var textureUniforms=this.otherUniformBlock.textureUniforms;// textureUniforms property maybe null if ShaderUniformBlock not contain any texture.
  if(textureUniforms){for(var i=0,n=textureUniforms.length;i<n;i++){var uniform=textureUniforms[i];uniform.applyFunc(uniform,uniform.textureDefault);}}}/**
     * Grouping other data.
     */;_proto.groupingOtherUniformBlock=function groupingOtherUniformBlock(){var _this$otherUniformBlo=this.otherUniformBlock,constUniforms=_this$otherUniformBlo.constUniforms,textureUniforms=_this$otherUniformBlo.textureUniforms;constUniforms.length>0&&this._groupingSubOtherUniforms(constUniforms,false);textureUniforms.length>0&&this._groupingSubOtherUniforms(textureUniforms,true);}/**
     * Bind this shader program.
     * @returns Whether the shader program is switched.
     */;_proto.bind=function bind(){var rhi=this._engine._hardwareRenderer;if(rhi._currentBind!==this){this._gl.useProgram(this._glProgram);rhi._currentBind=this;return true;}else {return false;}}/**
     * Destroy this shader program.
     */;_proto.destroy=function destroy(){var gl=this._gl;this._vertexShader&&gl.deleteShader(this._vertexShader);this._fragmentShader&&gl.deleteShader(this._fragmentShader);this._glProgram&&gl.deleteProgram(this._glProgram);};_proto._groupingSubOtherUniforms=function _groupingSubOtherUniforms(uniforms,isTexture){for(var i=uniforms.length-1;i>=0;i--){var uniform=uniforms[i];var group=Shader._getShaderPropertyGroup(uniform.name);if(group!==undefined){uniforms.splice(uniforms.indexOf(uniform),1);this._groupingUniform(uniform,group,isTexture);}}};_proto._groupingUniform=function _groupingUniform(uniform,group,isTexture){switch(group){case ShaderDataGroup.Scene:if(isTexture){this.sceneUniformBlock.textureUniforms.push(uniform);}else {this.sceneUniformBlock.constUniforms.push(uniform);}break;case ShaderDataGroup.Camera:if(isTexture){this.cameraUniformBlock.textureUniforms.push(uniform);}else {this.cameraUniformBlock.constUniforms.push(uniform);}break;case ShaderDataGroup.Renderer:if(isTexture){this.rendererUniformBlock.textureUniforms.push(uniform);}else {this.rendererUniformBlock.constUniforms.push(uniform);}break;case ShaderDataGroup.Material:if(isTexture){this.materialUniformBlock.textureUniforms.push(uniform);}else {this.materialUniformBlock.constUniforms.push(uniform);}break;default:if(isTexture){this.otherUniformBlock.textureUniforms.push(uniform);}else {this.otherUniformBlock.constUniforms.push(uniform);}}}/**
     * init and link program with shader.
     */;_proto._createProgram=function _createProgram(vertexSource,fragmentSource){var gl=this._gl;// create and compile shader
  var vertexShader=this._createShader(gl.VERTEX_SHADER,vertexSource);if(!vertexShader){return null;}var fragmentShader=this._createShader(gl.FRAGMENT_SHADER,fragmentSource);if(!fragmentShader){return null;}// link program and shader
  var program=gl.createProgram();gl.attachShader(program,vertexShader);gl.attachShader(program,fragmentShader);gl.linkProgram(program);gl.validateProgram(program);if(gl.isContextLost()){Logger.error("Context lost while linking program.");gl.deleteShader(vertexShader);gl.deleteShader(fragmentShader);return null;}if(Logger.isEnabled&&!gl.getProgramParameter(program,gl.LINK_STATUS)){Logger.error("Could not link WebGL program. \n"+gl.getProgramInfoLog(program));gl.deleteProgram(program);return null;}this._vertexShader=vertexShader;this._fragmentShader=fragmentShader;return program;};_proto._createShader=function _createShader(shaderType,shaderSource){var gl=this._gl;var shader=gl.createShader(shaderType);if(!shader){Logger.error("Context lost while create shader.");return null;}gl.shaderSource(shader,shaderSource);gl.compileShader(shader);if(gl.isContextLost()){Logger.error("Context lost while compiling shader.");gl.deleteShader(shader);return null;}if(Logger.isEnabled&&!gl.getShaderParameter(shader,gl.COMPILE_STATUS)){Logger.error("Could not compile WebGL shader.\n"+gl.getShaderInfoLog(shader),ShaderProgram._addLineNum(shaderSource));gl.deleteShader(shader);return null;}return shader;}/**
     * record the location of uniform/attribute.
     */;_proto._recordLocation=function _recordLocation(){var _this=this;var gl=this._gl;var program=this._glProgram;var uniformInfos=this._getUniformInfos();var attributeInfos=this._getAttributeInfos();uniformInfos.forEach(function(_ref){var name=_ref.name,size=_ref.size,type=_ref.type;var shaderUniform=new ShaderUniform(_this._engine);var isArray=false;var isTexture=false;if(name.indexOf("[0]")>0){name=name.substr(0,name.length-3);isArray=true;}var group=Shader._getShaderPropertyGroup(name);var location=gl.getUniformLocation(program,name);shaderUniform.name=name;shaderUniform.propertyId=Shader.getPropertyByName(name)._uniqueId;shaderUniform.location=location;switch(type){case gl.FLOAT:if(isArray){shaderUniform.applyFunc=shaderUniform.upload1fv;}else {shaderUniform.applyFunc=shaderUniform.upload1f;shaderUniform.cacheValue=0;}break;case gl.FLOAT_VEC2:if(isArray){shaderUniform.applyFunc=shaderUniform.upload2fv;}else {shaderUniform.applyFunc=shaderUniform.upload2f;shaderUniform.cacheValue=new Vector2(0,0);}break;case gl.FLOAT_VEC3:if(isArray){shaderUniform.applyFunc=shaderUniform.upload3fv;}else {shaderUniform.applyFunc=shaderUniform.upload3f;shaderUniform.cacheValue=new Vector3(0,0,0);}break;case gl.FLOAT_VEC4:if(isArray){shaderUniform.applyFunc=shaderUniform.upload4fv;}else {shaderUniform.applyFunc=shaderUniform.upload4f;shaderUniform.cacheValue=new Vector4(0,0,0,0);}break;case gl.BOOL:case gl.INT:if(isArray){shaderUniform.applyFunc=shaderUniform.upload1iv;}else {shaderUniform.applyFunc=shaderUniform.upload1i;shaderUniform.cacheValue=0;}break;case gl.BOOL_VEC2:case gl.INT_VEC2:if(isArray){shaderUniform.applyFunc=shaderUniform.upload2iv;}else {shaderUniform.applyFunc=shaderUniform.upload2i;shaderUniform.cacheValue=new Vector2(0,0);}break;case gl.BOOL_VEC3:case gl.INT_VEC3:shaderUniform.applyFunc=isArray?shaderUniform.upload3iv:shaderUniform.upload3i;shaderUniform.cacheValue=new Vector3(0,0,0);break;case gl.BOOL_VEC4:case gl.INT_VEC4:if(isArray){shaderUniform.applyFunc=shaderUniform.upload4iv;}else {shaderUniform.applyFunc=shaderUniform.upload4i;shaderUniform.cacheValue=new Vector4(0,0,0);}break;case gl.FLOAT_MAT4:shaderUniform.applyFunc=isArray?shaderUniform.uploadMat4v:shaderUniform.uploadMat4;break;case gl.SAMPLER_2D:case gl.SAMPLER_CUBE:var defaultTexture=type===gl.SAMPLER_2D?_this._engine._whiteTexture2D:_this._engine._whiteTextureCube;isTexture=true;if(isArray){var defaultTextures=new Array(size);var textureIndices=new Int32Array(size);var glTextureIndices=new Array(size);for(var i=0;i<size;i++){defaultTextures[i]=defaultTexture;textureIndices[i]=_this._activeTextureUint;glTextureIndices[i]=gl.TEXTURE0+_this._activeTextureUint++;}shaderUniform.textureDefault=defaultTextures;shaderUniform.textureIndex=glTextureIndices;shaderUniform.applyFunc=shaderUniform.uploadTextureArray;_this.bind();gl.uniform1iv(location,textureIndices);shaderUniform.uploadTextureArray(shaderUniform,defaultTextures);}else {var textureIndex=gl.TEXTURE0+_this._activeTextureUint;shaderUniform.textureDefault=defaultTexture;shaderUniform.textureIndex=textureIndex;shaderUniform.applyFunc=shaderUniform.uploadTexture;_this.bind();gl.uniform1i(location,_this._activeTextureUint++);shaderUniform.uploadTexture(shaderUniform,defaultTexture);}break;}_this._groupingUniform(shaderUniform,group,isTexture);});attributeInfos.forEach(function(_ref2){var name=_ref2.name;_this.attributeLocation[name]=gl.getAttribLocation(program,name);});};_proto._getUniformInfos=function _getUniformInfos(){var gl=this._gl;var program=this._glProgram;var uniformInfos=[];var uniformCount=gl.getProgramParameter(program,gl.ACTIVE_UNIFORMS);for(var i=0;i<uniformCount;++i){var info=gl.getActiveUniform(program,i);uniformInfos[i]=info;}return uniformInfos;};_proto._getAttributeInfos=function _getAttributeInfos(){var gl=this._gl;var program=this._glProgram;var attributeInfos=[];var attributeCount=gl.getProgramParameter(program,gl.ACTIVE_ATTRIBUTES);for(var i=0;i<attributeCount;++i){var info=gl.getActiveAttrib(program,i);attributeInfos[i]=info;}return attributeInfos;};_createClass$3(ShaderProgram,[{key:"isValid",get:/**
       * Whether this shader program is valid.
       */function get(){return this._isValid;}}]);return ShaderProgram;}();ShaderProgram._counter=0;/**
   * Shader property.
   */var ShaderProperty=/** @internal */ /** @internal */ /** Shader property name. */ /**
   * @internal
   */function ShaderProperty(name){this._uniqueId=void 0;this._group=void 0;this.name=void 0;this.name=name;this._uniqueId=ShaderProperty._propertyNameCounter++;};ShaderProperty._propertyNameCounter=0;/**
   * Shader containing vertex and fragment source.
   */var Shader=/*#__PURE__*/function(){/** @internal */ /**
     * Create a shader.
     * @param name - Name of the shader
     * @param vertexSource - Vertex source code
     * @param fragmentSource - Fragment source code
     */Shader.create=function create(name,vertexSource,fragmentSource){var shaderMap=Shader._shaderMap;if(shaderMap[name]){throw "Shader named \""+name+"\" already exists.";}return shaderMap[name]=new Shader(name,vertexSource,fragmentSource);}/**
     * Find a shader by name.
     * @param name - Name of the shader
     */;Shader.find=function find(name){return Shader._shaderMap[name];}/**
     * Get shader macro by name.
     * @param name - Name of the shader macro
     * @returns Shader macro
     */;Shader.getMacroByName=function getMacroByName(name){var macro=Shader._macroMap[name];if(!macro){var maskMap=Shader._macroMaskMap;var counter=Shader._macroCounter;var index=Math.floor(counter/32);var bit=counter%32;macro=new ShaderMacro(name,index,1<<bit);Shader._macroMap[name]=macro;if(index==maskMap.length){maskMap.length++;maskMap[index]=new Array(32);}maskMap[index][bit]=name;Shader._macroCounter++;}return macro;}/**
     * Get shader property by name.
     * @param name - Name of the shader property
     * @returns Shader property
     */;Shader.getPropertyByName=function getPropertyByName(name){var propertyNameMap=Shader._propertyNameMap;if(propertyNameMap[name]!=null){return propertyNameMap[name];}else {var property=new ShaderProperty(name);propertyNameMap[name]=property;return property;}}/**
     * @internal
     */;Shader._getShaderPropertyGroup=function _getShaderPropertyGroup(propertyName){var shaderProperty=Shader._propertyNameMap[propertyName];return shaderProperty===null||shaderProperty===void 0?void 0:shaderProperty._group;};Shader._getNamesByMacros=function _getNamesByMacros(macros,out){var maskMap=Shader._macroMaskMap;var mask=macros._mask;out.length=0;for(var i=0,n=macros._length;i<n;i++){var subMaskMap=maskMap[i];var subMask=mask[i];var _n=subMask<0?32:Math.floor(Math.log2(subMask))+1;// if is negative must contain 1 << 31.
  for(var j=0;j<_n;j++){if(subMask&1<<j){out.push(subMaskMap[j]);}}}}/** The name of shader. */;function Shader(name,vertexSource,fragmentSource){this.name=void 0;this._shaderId=0;this._vertexSource=void 0;this._fragmentSource=void 0;this._shaderId=Shader._shaderCounter++;this.name=name;this._vertexSource=vertexSource;this._fragmentSource=fragmentSource;}/**
     * Compile shader variant by macro name list.
     *
     * @remarks
     * Usually a shader contains some macros,any combination of macros is called shader variant.
     *
     * @param engine - Engine to which the shader variant belongs
     * @param macros - Macro name list
     * @returns Is the compiled shader variant valid
     */var _proto=Shader.prototype;_proto.compileVariant=function compileVariant(engine,macros){var compileMacros=Shader._compileMacros;compileMacros.clear();for(var i=0,n=macros.length;i<n;i++){compileMacros.enable(Shader.getMacroByName(macros[i]));}return this._getShaderProgram(engine,compileMacros).isValid;}/**
     * @internal
     */;_proto._getShaderProgram=function _getShaderProgram(engine,macroCollection){var shaderProgramPool=engine._getShaderProgramPool(this);var shaderProgram=shaderProgramPool.get(macroCollection);if(shaderProgram){return shaderProgram;}var isWebGL2=engine._hardwareRenderer.isWebGL2;var macroNameList=[];Shader._getNamesByMacros(macroCollection,macroNameList);var macroNameStr=ShaderFactory.parseCustomMacros(macroNameList);var versionStr=isWebGL2?"#version 300 es":"#version 100";var precisionStr="\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      precision highp int;\n      #define O3_VERTEX_PRECISION highp\n      #define O3_FRAGMENT_PRECISION highp\n    #else\n      precision mediump float;\n      precision mediump int;\n      #define O3_VERTEX_PRECISION mediump\n      #define O3_FRAGMENT_PRECISION mediump\n    #endif\n    ";if(engine._hardwareRenderer.canIUse(exports.GLCapabilityType.shaderTextureLod)){precisionStr+="#define HAS_TEX_LOD\n";}if(engine._hardwareRenderer.canIUse(exports.GLCapabilityType.standardDerivatives)){precisionStr+="#define HAS_DERIVATIVES\n";}var vertexSource=ShaderFactory.parseIncludes(" "+versionStr+"\n        "+precisionStr+"\n        "+macroNameStr+"\n        "+this._vertexSource);var fragmentSource=ShaderFactory.parseIncludes(" "+versionStr+"\n        "+(isWebGL2?"":ShaderFactory.parseExtension(Shader._shaderExtension))+"\n        "+precisionStr+"\n        "+macroNameStr+"\n      "+this._fragmentSource);if(isWebGL2){vertexSource=ShaderFactory.convertTo300(vertexSource);fragmentSource=ShaderFactory.convertTo300(fragmentSource,true);}shaderProgram=new ShaderProgram(engine,vertexSource,fragmentSource);shaderProgramPool.cache(shaderProgram);return shaderProgram;};return Shader;}();Shader._compileMacros=new ShaderMacroCollection();Shader._shaderCounter=0;Shader._shaderMap=Object.create(null);Shader._propertyNameMap=Object.create(null);Shader._macroMaskMap=[];Shader._macroCounter=0;Shader._macroMap=Object.create(null);Shader._shaderExtension=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives","GL_EXT_draw_buffers"];/**
   * Shader data collection,Correspondence includes shader properties data and macros data.
   */var ShaderData=/*#__PURE__*/function(){/** @internal */ /** @internal */ /** @internal */ /**
     * @internal
     */function ShaderData(group){this._group=void 0;this._properties=Object.create(null);this._macroCollection=new ShaderMacroCollection();this._variableMacros=Object.create(null);this._refCount=0;this._group=group;}/**
     * Get float by shader property name.
     * @param propertyName - Shader property name
     * @returns Float
     */var _proto=ShaderData.prototype;_proto.getFloat=function getFloat(property){return this._getData(property);}/**
     * Set float by shader property name.
     * @remarks Corresponding float shader property type.
     * @param propertyName - Shader property name
     * @param value - Float
     */;_proto.setFloat=function setFloat(property,value){this._setData(property,value);}/**
     * Get int by shader property name.
     * @param propertyName - Shader property name
     * @returns Int
     */;_proto.getInt=function getInt(property){return this._getData(property);}/**
     * Set int by shader property name.
     * @remarks Correspondence includes int and bool shader property type.
     * @param propertyName - Shader property name
     * @param value - Int
     */;_proto.setInt=function setInt(property,value){this._setData(property,value);}/**
     * Get float array by shader property name.
     * @param propertyName - Shader property name
     * @returns Float array
     */;_proto.getFloatArray=function getFloatArray(property){return this._getData(property);}/**
     * Set float array by shader property name.
     * @remarks Correspondence includes float array、vec2 array、vec3 array、vec4 array and matrix array shader property type.
     * @param propertyName - Shader property name
     * @param value - Float array
     */;_proto.setFloatArray=function setFloatArray(property,value){this._setData(property,value);}/**
     * Get int array by shader property name.
     * @param propertyName - Shader property name
     * @returns Int Array
     */;_proto.getIntArray=function getIntArray(property){return this._getData(property);}/**
     * Set int array by shader property name.
     * @remarks Correspondence includes bool array、int array、bvec2 array、bvec3 array、bvec4 array、ivec2 array、ivec3 array and ivec4 array shader property type.
     * @param propertyName - Shader property name
     * @param value - Int Array
     */;_proto.setIntArray=function setIntArray(property,value){this._setData(property,value);}/**
     * Get two-dimensional from shader property name.
     * @param propertyName - Shader property name
     * @returns Two-dimensional vector
     */;_proto.getVector2=function getVector2(property){return this._getData(property);}/**
     * Set two-dimensional vector from shader property name.
     * @remarks Correspondence includes vec2、ivec2 and bvec2 shader property type.
     * @param property - Shader property name
     * @param value - Two-dimensional vector
     */;_proto.setVector2=function setVector2(property,value){this._setData(property,value);}/**
     * Get vector3 by shader property name.
     * @param propertyName - Shader property name
     * @returns Three-dimensional vector
     */;_proto.getVector3=function getVector3(property){return this._getData(property);}/**
     * Set three dimensional vector by shader property name.
     * @remarks Correspondence includes vec3、ivec3 and bvec3 shader property type.
     * @param property - Shader property name
     * @param value - Three-dimensional vector
     */;_proto.setVector3=function setVector3(property,value){this._setData(property,value);}/**
     * Get vector4 by shader property name.
     * @param propertyName - Shader property name
     * @returns Four-dimensional vector
     */;_proto.getVector4=function getVector4(property){return this._getData(property);}/**
     * Set four-dimensional vector by shader property name.
     * @remarks Correspondence includes vec4、ivec4 and bvec4 shader property type.
     * @param property - Shader property name
     * @param value - Four-dimensional vector
     */;_proto.setVector4=function setVector4(property,value){this._setData(property,value);}/**
     * Get matrix by shader property name.
     * @param propertyName - Shader property name
     * @returns Matrix
     */;_proto.getMatrix=function getMatrix(property){return this._getData(property);}/**
     * Set matrix by shader property name.
     * @remarks Correspondence includes matrix shader property type.
     * @param propertyName - Shader property name
     * @param value - Matrix
     */;_proto.setMatrix=function setMatrix(property,value){this._setData(property,value);}/**
     * Get color by shader property name.
     * @param propertyName - Shader property name
     * @returns Color
     */;_proto.getColor=function getColor(property){return this._getData(property);}/**
     * Set color by shader property name.
     * @remarks Correspondence includes vec4 shader property type.
     * @param propertyName - Shader property name
     * @param value - Color
     */;_proto.setColor=function setColor(property,value){this._setData(property,value);}/**
     * Get texture by shader property name.
     * @param propertyName - Shader property name
     * @returns Texture
     */;_proto.getTexture=function getTexture(property){return this._getData(property);}/**
     * Set texture by shader property name.
     * @param propertyName - Shader property name
     * @param value - Texture
     */;_proto.setTexture=function setTexture(property,value){if(this._getRefCount()>0){var lastValue=this._getData(property);lastValue&&lastValue._addRefCount(-1);value&&value._addRefCount(1);}this._setData(property,value);}/**
     * Get texture array by shader property name.
     * @param propertyName - Shader property name
     * @returns Texture array
     */;_proto.getTextureArray=function getTextureArray(property){return this._getData(property);}/**
     * Set texture array by shader property name.
     * @param propertyName - Shader property name
     * @param value - Texture array
     */;_proto.setTextureArray=function setTextureArray(property,value){if(this._getRefCount()>0){var lastValue=this._getData(property);if(lastValue){for(var i=0,n=lastValue.length;i<n;i++){lastValue[i]._addRefCount(-1);}}if(value){for(var _i=0,_n=value.length;_i<_n;_i++){value[_i]._addRefCount(1);}}}this._setData(property,value);}/**
     * Enable macro.
     * @param macroName - Macro name
     */;_proto.enableMacro=function enableMacro(macro,value){if(value===void 0){value=null;}if(value){this._enableVariableMacro(macro,value);}else {if(typeof macro==="string"){macro=Shader.getMacroByName(macro);}this._macroCollection.enable(macro);}}/**
     * Disable macro
     * @param macroName - Macro name
     */;_proto.disableMacro=function disableMacro(macro){if(typeof macro==="string"){// @todo: should optimization variable macros disable performance
  var variableValue=this._variableMacros[macro];if(variableValue){this._disableVariableMacro(macro,variableValue);}else {macro=Shader.getMacroByName(macro);this._macroCollection.disable(macro);}}else {this._macroCollection.disable(macro);}};_proto.clone=function clone(){var shaderData=new ShaderData(this._group);this.cloneTo(shaderData);return shaderData;};_proto.cloneTo=function cloneTo(target){CloneManager.deepCloneObject(this._macroCollection,target._macroCollection);_extends$1(target._variableMacros,this._variableMacros);var properties=this._properties;var targetProperties=target._properties;var keys=Object.keys(properties);for(var i=0,n=keys.length;i<n;i++){var k=keys[i];var _property=properties[k];if(_property!=null){if(typeof _property==="number"){targetProperties[k]=_property;}else if(_property instanceof Texture){targetProperties[k]=_property;}else if(_property instanceof Array||_property instanceof Float32Array||_property instanceof Int32Array){targetProperties[k]=_property.slice();}else {var targetProperty=targetProperties[k];if(targetProperty){_property.cloneTo(targetProperty);}else {targetProperties[k]=_property.clone();}}}else {targetProperties[k]=_property;}}}/**
     * @internal
     */;_proto._getData=function _getData(property){if(typeof property==="string"){property=Shader.getPropertyByName(property);}return this._properties[property._uniqueId];}/**
     * @internal
     */;_proto._setData=function _setData(property,value){if(typeof property==="string"){property=Shader.getPropertyByName(property);}if(property._group!==this._group){if(property._group===undefined){property._group=this._group;}else {throw "Shader property "+property.name+" has been used as "+ShaderDataGroup[property._group]+" property.";}}this._properties[property._uniqueId]=value;}/**
     * @internal
     */;_proto._getRefCount=function _getRefCount(){return this._refCount;}/**
     * @internal
     */;_proto._addRefCount=function _addRefCount(value){this._refCount+=value;var properties=this._properties;for(var k in properties){var _property2=properties[k];// @todo: Separate array to speed performance.
  if(_property2&&_property2 instanceof Texture){_property2._addRefCount(value);}}};_proto._enableVariableMacro=function _enableVariableMacro(name,value){var variableMacro=this._variableMacros;var variableValue=variableMacro[name];if(variableValue!==value){variableValue&&this._disableVariableMacro(name,variableValue);var _macro=Shader.getMacroByName(name+" "+value);this._macroCollection.enable(_macro);variableMacro[name]=value;}};_proto._disableVariableMacro=function _disableVariableMacro(name,value){var oldMacro=Shader.getMacroByName(name+" "+value);this._macroCollection.disable(oldMacro);delete this._variableMacros[name];};return ShaderData;}();/**
   * Blend factor.
   * @remarks defines which function is used for blending pixel arithmetic
   */exports.BlendFactor = void 0;(function(BlendFactor){BlendFactor[BlendFactor["Zero"]=0]="Zero";BlendFactor[BlendFactor["One"]=1]="One";BlendFactor[BlendFactor["SourceColor"]=2]="SourceColor";BlendFactor[BlendFactor["OneMinusSourceColor"]=3]="OneMinusSourceColor";BlendFactor[BlendFactor["DestinationColor"]=4]="DestinationColor";BlendFactor[BlendFactor["OneMinusDestinationColor"]=5]="OneMinusDestinationColor";BlendFactor[BlendFactor["SourceAlpha"]=6]="SourceAlpha";BlendFactor[BlendFactor["OneMinusSourceAlpha"]=7]="OneMinusSourceAlpha";BlendFactor[BlendFactor["DestinationAlpha"]=8]="DestinationAlpha";BlendFactor[BlendFactor["OneMinusDestinationAlpha"]=9]="OneMinusDestinationAlpha";BlendFactor[BlendFactor["SourceAlphaSaturate"]=10]="SourceAlphaSaturate";BlendFactor[BlendFactor["BlendColor"]=11]="BlendColor";BlendFactor[BlendFactor["OneMinusBlendColor"]=12]="OneMinusBlendColor";})(exports.BlendFactor||(exports.BlendFactor={}));/**
   * Blend operation function.
   * @remarks defines how a new pixel is combined with a pixel.
   */exports.BlendOperation = void 0;(function(BlendOperation){BlendOperation[BlendOperation["Add"]=0]="Add";BlendOperation[BlendOperation["Subtract"]=1]="Subtract";BlendOperation[BlendOperation["ReverseSubtract"]=2]="ReverseSubtract";BlendOperation[BlendOperation["Min"]=3]="Min";BlendOperation[BlendOperation["Max"]=4]="Max";})(exports.BlendOperation||(exports.BlendOperation={}));/**
   * Set which color channels can be rendered to frame buffer.
   * @remarks enumeration can be combined using bit operations.
   */exports.ColorWriteMask = void 0;(function(ColorWriteMask){ColorWriteMask[ColorWriteMask["None"]=0]="None";ColorWriteMask[ColorWriteMask["Red"]=1]="Red";ColorWriteMask[ColorWriteMask["Green"]=2]="Green";ColorWriteMask[ColorWriteMask["Blue"]=4]="Blue";ColorWriteMask[ColorWriteMask["Alpha"]=8]="Alpha";ColorWriteMask[ColorWriteMask["All"]=15]="All";})(exports.ColorWriteMask||(exports.ColorWriteMask={}));/**
   * The blend state of the render target.
   */var RenderTargetBlendState=function RenderTargetBlendState(){this.enabled=false;this.colorBlendOperation=exports.BlendOperation.Add;this.alphaBlendOperation=exports.BlendOperation.Add;this.sourceColorBlendFactor=exports.BlendFactor.One;this.sourceAlphaBlendFactor=exports.BlendFactor.One;this.destinationColorBlendFactor=exports.BlendFactor.Zero;this.destinationAlphaBlendFactor=exports.BlendFactor.Zero;this.colorWriteMask=exports.ColorWriteMask.All;};/**
   * Blend state.
   */var BlendState=/*#__PURE__*/function(){function BlendState(){this.targetBlendState=new RenderTargetBlendState();this.blendColor=new Color(0,0,0,0);this.alphaToCoverage=false;}BlendState._getGLBlendFactor=function _getGLBlendFactor(rhi,blendFactor){var gl=rhi.gl;switch(blendFactor){case exports.BlendFactor.Zero:return gl.ZERO;case exports.BlendFactor.One:return gl.ONE;case exports.BlendFactor.SourceColor:return gl.SRC_COLOR;case exports.BlendFactor.OneMinusSourceColor:return gl.ONE_MINUS_SRC_COLOR;case exports.BlendFactor.DestinationColor:return gl.DST_COLOR;case exports.BlendFactor.OneMinusDestinationColor:return gl.ONE_MINUS_DST_COLOR;case exports.BlendFactor.SourceAlpha:return gl.SRC_ALPHA;case exports.BlendFactor.OneMinusSourceAlpha:return gl.ONE_MINUS_SRC_ALPHA;case exports.BlendFactor.DestinationAlpha:return gl.DST_ALPHA;case exports.BlendFactor.OneMinusDestinationAlpha:return gl.ONE_MINUS_DST_ALPHA;case exports.BlendFactor.SourceAlphaSaturate:return gl.SRC_ALPHA_SATURATE;case exports.BlendFactor.BlendColor:return gl.CONSTANT_COLOR;case exports.BlendFactor.OneMinusBlendColor:return gl.ONE_MINUS_CONSTANT_COLOR;}};BlendState._getGLBlendOperation=function _getGLBlendOperation(rhi,blendOperation){var gl=rhi.gl;switch(blendOperation){case exports.BlendOperation.Add:return gl.FUNC_ADD;case exports.BlendOperation.Subtract:return gl.FUNC_SUBTRACT;case exports.BlendOperation.ReverseSubtract:return gl.FUNC_REVERSE_SUBTRACT;case exports.BlendOperation.Min:if(!rhi.canIUse(exports.GLCapabilityType.blendMinMax)){throw new Error("BlendOperation.Min is not supported in this context");}return gl.MIN;// in webgl1.0 is an extension
  case exports.BlendOperation.Max:if(!rhi.canIUse(exports.GLCapabilityType.blendMinMax)){throw new Error("BlendOperation.Max is not supported in this context");}return gl.MAX;// in webgl1.0 is an extension
  }}/** The blend state of the render target. */;var _proto=BlendState.prototype;/**
     * @internal
     * Apply the current blend state by comparing with the last blend state.
     */_proto._apply=function _apply(hardwareRenderer,lastRenderState){this._platformApply(hardwareRenderer,lastRenderState.blendState);};_proto._platformApply=function _platformApply(rhi,lastState){var gl=rhi.gl;var lastTargetBlendState=lastState.targetBlendState;var _this$targetBlendStat=this.targetBlendState,enabled=_this$targetBlendStat.enabled,colorBlendOperation=_this$targetBlendStat.colorBlendOperation,alphaBlendOperation=_this$targetBlendStat.alphaBlendOperation,sourceColorBlendFactor=_this$targetBlendStat.sourceColorBlendFactor,destinationColorBlendFactor=_this$targetBlendStat.destinationColorBlendFactor,sourceAlphaBlendFactor=_this$targetBlendStat.sourceAlphaBlendFactor,destinationAlphaBlendFactor=_this$targetBlendStat.destinationAlphaBlendFactor,colorWriteMask=_this$targetBlendStat.colorWriteMask;if(enabled!==lastTargetBlendState.enabled){if(enabled){gl.enable(gl.BLEND);}else {gl.disable(gl.BLEND);}lastTargetBlendState.enabled=enabled;}if(enabled){// apply blend factor.
  if(sourceColorBlendFactor!==lastTargetBlendState.sourceColorBlendFactor||destinationColorBlendFactor!==lastTargetBlendState.destinationColorBlendFactor||sourceAlphaBlendFactor!==lastTargetBlendState.sourceAlphaBlendFactor||destinationAlphaBlendFactor!==lastTargetBlendState.destinationAlphaBlendFactor){gl.blendFuncSeparate(BlendState._getGLBlendFactor(rhi,sourceColorBlendFactor),BlendState._getGLBlendFactor(rhi,destinationColorBlendFactor),BlendState._getGLBlendFactor(rhi,sourceAlphaBlendFactor),BlendState._getGLBlendFactor(rhi,destinationAlphaBlendFactor));lastTargetBlendState.sourceColorBlendFactor=sourceColorBlendFactor;lastTargetBlendState.destinationColorBlendFactor=destinationColorBlendFactor;lastTargetBlendState.sourceAlphaBlendFactor=sourceAlphaBlendFactor;lastTargetBlendState.destinationAlphaBlendFactor=destinationAlphaBlendFactor;}// apply blend operation.
  if(colorBlendOperation!==lastTargetBlendState.colorBlendOperation||alphaBlendOperation!==lastTargetBlendState.alphaBlendOperation){gl.blendEquationSeparate(BlendState._getGLBlendOperation(rhi,colorBlendOperation),BlendState._getGLBlendOperation(rhi,alphaBlendOperation));lastTargetBlendState.colorBlendOperation=colorBlendOperation;lastTargetBlendState.alphaBlendOperation=alphaBlendOperation;}// apply blend color.
  var blendColor=this.blendColor;if(!Color.equals(lastState.blendColor,blendColor)){gl.blendColor(blendColor.r,blendColor.g,blendColor.b,blendColor.a);blendColor.cloneTo(lastState.blendColor);}}// apply color mask.
  if(colorWriteMask!==lastTargetBlendState.colorWriteMask){gl.colorMask((colorWriteMask&exports.ColorWriteMask.Red)!==0,(colorWriteMask&exports.ColorWriteMask.Green)!==0,(colorWriteMask&exports.ColorWriteMask.Blue)!==0,(colorWriteMask&exports.ColorWriteMask.Alpha)!==0);lastTargetBlendState.colorWriteMask=colorWriteMask;}// apply alpha to coverage.
  var alphaToCoverage=this.alphaToCoverage;if(alphaToCoverage!==lastState.alphaToCoverage){if(alphaToCoverage){gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);}else {gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);}lastState.alphaToCoverage=alphaToCoverage;}};return BlendState;}();/**
   * Depth/Stencil comparison function.
   * @remarks Specifies a function that compares incoming pixel depth/stencil to the current depth/stencil buffer value.
   */exports.CompareFunction = void 0;(function(CompareFunction){CompareFunction[CompareFunction["Never"]=0]="Never";CompareFunction[CompareFunction["Less"]=1]="Less";CompareFunction[CompareFunction["Equal"]=2]="Equal";CompareFunction[CompareFunction["LessEqual"]=3]="LessEqual";CompareFunction[CompareFunction["Greater"]=4]="Greater";CompareFunction[CompareFunction["NotEqual"]=5]="NotEqual";CompareFunction[CompareFunction["GreaterEqual"]=6]="GreaterEqual";CompareFunction[CompareFunction["Always"]=7]="Always";})(exports.CompareFunction||(exports.CompareFunction={}));/**
   * Depth state.
   */var DepthState=/*#__PURE__*/function(){function DepthState(){this.enabled=true;this.writeEnabled=true;this.compareFunction=exports.CompareFunction.Less;}DepthState._getGLCompareFunction=function _getGLCompareFunction(rhi,compareFunction){var gl=rhi.gl;switch(compareFunction){case exports.CompareFunction.Never:return gl.NEVER;case exports.CompareFunction.Less:return gl.LESS;case exports.CompareFunction.Equal:return gl.EQUAL;case exports.CompareFunction.LessEqual:return gl.LEQUAL;case exports.CompareFunction.Greater:return gl.GREATER;case exports.CompareFunction.NotEqual:return gl.NOTEQUAL;case exports.CompareFunction.GreaterEqual:return gl.GEQUAL;case exports.CompareFunction.Always:return gl.ALWAYS;}}/** Whether to enable the depth test. */;var _proto=DepthState.prototype;/**
     * @internal
     * Apply the current depth state by comparing with the last depth state.
     */_proto._apply=function _apply(hardwareRenderer,lastRenderState){this._platformApply(hardwareRenderer,lastRenderState.depthState);};_proto._platformApply=function _platformApply(rhi,lastState){var gl=rhi.gl;var enabled=this.enabled,compareFunction=this.compareFunction,writeEnabled=this.writeEnabled;if(enabled!=lastState.enabled){if(enabled){gl.enable(gl.DEPTH_TEST);}else {gl.disable(gl.DEPTH_TEST);}lastState.enabled=enabled;}if(enabled){// apply compare func.
  if(compareFunction!=lastState.compareFunction){gl.depthFunc(DepthState._getGLCompareFunction(rhi,compareFunction));lastState.compareFunction=compareFunction;}// apply write enabled.
  if(writeEnabled!=lastState.writeEnabled){gl.depthMask(writeEnabled);lastState.writeEnabled=writeEnabled;}}};return DepthState;}();/**
   * Culling mode.
   * @remarks specifies whether or not front- and/or back-facing polygons can be culled.
   */exports.CullMode = void 0;(function(CullMode){CullMode[CullMode["Off"]=0]="Off";CullMode[CullMode["Front"]=1]="Front";CullMode[CullMode["Back"]=2]="Back";})(exports.CullMode||(exports.CullMode={}));/**
   * Raster state.
   */var RasterState=/*#__PURE__*/function(){function RasterState(){this.cullMode=exports.CullMode.Back;this.depthBias=0;this.slopeScaledDepthBias=0;this._cullFaceEnable=true;}var _proto=RasterState.prototype;/**
     * @internal
     */_proto._apply=function _apply(hardwareRenderer,lastRenderState){this._platformApply(hardwareRenderer,lastRenderState.rasterState);};_proto._platformApply=function _platformApply(rhi,lastState){var gl=rhi.gl;var cullMode=this.cullMode,depthBias=this.depthBias,slopeScaledDepthBias=this.slopeScaledDepthBias;var cullFaceEnable=cullMode!==exports.CullMode.Off;if(cullFaceEnable!==lastState._cullFaceEnable){if(cullFaceEnable){gl.enable(gl.CULL_FACE);}else {gl.disable(gl.CULL_FACE);}lastState._cullFaceEnable=cullFaceEnable;}// apply front face.
  if(cullFaceEnable){if(cullMode!==lastState.cullMode){if(cullMode==exports.CullMode.Back){gl.cullFace(gl.BACK);}else {gl.cullFace(gl.FRONT);}lastState.cullMode=cullMode;}}// apply polygonOffset.
  if(depthBias!==lastState.depthBias||slopeScaledDepthBias!==lastState.slopeScaledDepthBias){if(depthBias!==0||slopeScaledDepthBias!==0){gl.enable(gl.POLYGON_OFFSET_FILL);gl.polygonOffset(slopeScaledDepthBias,depthBias);}else {gl.disable(gl.POLYGON_OFFSET_FILL);}lastState.depthBias=depthBias;lastState.slopeScaledDepthBias=slopeScaledDepthBias;}};return RasterState;}();/**
   * Stencil operation mode.
   * @remarks sets the front and/or back-facing stencil test actions.
   */exports.StencilOperation = void 0;(function(StencilOperation){StencilOperation[StencilOperation["Keep"]=0]="Keep";StencilOperation[StencilOperation["Zero"]=1]="Zero";StencilOperation[StencilOperation["Replace"]=2]="Replace";StencilOperation[StencilOperation["IncrementSaturate"]=3]="IncrementSaturate";StencilOperation[StencilOperation["DecrementSaturate"]=4]="DecrementSaturate";StencilOperation[StencilOperation["Invert"]=5]="Invert";StencilOperation[StencilOperation["IncrementWrap"]=6]="IncrementWrap";StencilOperation[StencilOperation["DecrementWrap"]=7]="DecrementWrap";})(exports.StencilOperation||(exports.StencilOperation={}));/**
   * Stencil state.
   */var StencilState=/*#__PURE__*/function(){function StencilState(){this.enabled=false;this.referenceValue=0;this.mask=0xff;this.writeMask=0xff;this.compareFunctionFront=exports.CompareFunction.Always;this.compareFunctionBack=exports.CompareFunction.Always;this.passOperationFront=exports.StencilOperation.Keep;this.passOperationBack=exports.StencilOperation.Keep;this.failOperationFront=exports.StencilOperation.Keep;this.failOperationBack=exports.StencilOperation.Keep;this.zFailOperationFront=exports.StencilOperation.Keep;this.zFailOperationBack=exports.StencilOperation.Keep;}StencilState._getGLCompareFunction=function _getGLCompareFunction(rhi,compareFunction){var gl=rhi.gl;switch(compareFunction){case exports.CompareFunction.Never:return gl.NEVER;case exports.CompareFunction.Less:return gl.LESS;case exports.CompareFunction.Equal:return gl.EQUAL;case exports.CompareFunction.LessEqual:return gl.LEQUAL;case exports.CompareFunction.Greater:return gl.GREATER;case exports.CompareFunction.NotEqual:return gl.NOTEQUAL;case exports.CompareFunction.GreaterEqual:return gl.GEQUAL;case exports.CompareFunction.Always:return gl.ALWAYS;}};StencilState._getGLStencilOperation=function _getGLStencilOperation(rhi,compareFunction){var gl=rhi.gl;switch(compareFunction){case exports.StencilOperation.Keep:return gl.KEEP;case exports.StencilOperation.Zero:return gl.ZERO;case exports.StencilOperation.Replace:return gl.REPLACE;case exports.StencilOperation.IncrementSaturate:return gl.INCR;case exports.StencilOperation.DecrementSaturate:return gl.DECR;case exports.StencilOperation.Invert:return gl.INVERT;case exports.StencilOperation.IncrementWrap:return gl.INCR_WRAP;case exports.StencilOperation.DecrementWrap:return gl.DECR_WRAP;}}/** Whether to enable stencil test. */;var _proto=StencilState.prototype;/**
     * @internal
     */_proto._apply=function _apply(hardwareRenderer,lastRenderState){this._platformApply(hardwareRenderer,lastRenderState.stencilState);};_proto._platformApply=function _platformApply(rhi,lastState){var gl=rhi.gl;var enabled=this.enabled,referenceValue=this.referenceValue,mask=this.mask,compareFunctionFront=this.compareFunctionFront,compareFunctionBack=this.compareFunctionBack,failOperationFront=this.failOperationFront,zFailOperationFront=this.zFailOperationFront,passOperationFront=this.passOperationFront,failOperationBack=this.failOperationBack,zFailOperationBack=this.zFailOperationBack,passOperationBack=this.passOperationBack,writeMask=this.writeMask;if(enabled!=lastState.enabled){if(enabled){gl.enable(gl.STENCIL_TEST);}else {gl.disable(gl.STENCIL_TEST);}lastState.enabled=enabled;}if(enabled){// apply stencil func.
  var referenceOrMaskChange=referenceValue!==lastState.referenceValue||mask!==lastState.mask;if(referenceOrMaskChange||compareFunctionFront!==lastState.compareFunctionFront){gl.stencilFuncSeparate(gl.FRONT,StencilState._getGLCompareFunction(rhi,compareFunctionFront),referenceValue,mask);lastState.compareFunctionFront=compareFunctionFront;}if(referenceOrMaskChange||compareFunctionBack!==lastState.compareFunctionBack){gl.stencilFuncSeparate(gl.BACK,StencilState._getGLCompareFunction(rhi,compareFunctionBack),referenceValue,mask);lastState.compareFunctionBack=this.compareFunctionBack;}if(referenceOrMaskChange){lastState.referenceValue=this.referenceValue;lastState.mask=this.mask;}// apply stencil operation.
  if(failOperationFront!==lastState.failOperationFront||zFailOperationFront!==lastState.zFailOperationFront||passOperationFront!==lastState.passOperationFront){gl.stencilOpSeparate(gl.FRONT,StencilState._getGLStencilOperation(rhi,failOperationFront),StencilState._getGLStencilOperation(rhi,zFailOperationFront),StencilState._getGLStencilOperation(rhi,passOperationFront));lastState.failOperationFront=failOperationFront;lastState.zFailOperationFront=zFailOperationFront;lastState.passOperationFront=passOperationFront;}if(failOperationBack!==lastState.failOperationBack||zFailOperationBack!==lastState.zFailOperationBack||passOperationBack!==lastState.passOperationBack){gl.stencilOpSeparate(gl.BACK,StencilState._getGLStencilOperation(rhi,failOperationBack),StencilState._getGLStencilOperation(rhi,zFailOperationBack),StencilState._getGLStencilOperation(rhi,passOperationBack));lastState.failOperationBack=failOperationBack;lastState.zFailOperationBack=zFailOperationBack;lastState.passOperationBack=passOperationBack;}// apply write mask.
  if(writeMask!==lastState.writeMask){gl.stencilMask(writeMask);lastState.writeMask=writeMask;}}};return StencilState;}();/**
   * Render state.
   */var RenderState=/*#__PURE__*/function(){function RenderState(){this.blendState=new BlendState();this.depthState=new DepthState();this.stencilState=new StencilState();this.rasterState=new RasterState();}var _proto=RenderState.prototype;/** @internal */_proto._apply=function _apply(engine){var hardwareRenderer=engine._hardwareRenderer;var lastRenderState=engine._lastRenderState;this.blendState._apply(hardwareRenderer,lastRenderState);this.depthState._apply(hardwareRenderer,lastRenderState);this.stencilState._apply(hardwareRenderer,lastRenderState);this.rasterState._apply(hardwareRenderer,lastRenderState);};return RenderState;}();/**
   * Material.
   */var Material=/*#__PURE__*/function(_RefObject){_inheritsLoose$2(Material,_RefObject);/** Name. */ /** Shader used by the material. */ /** Render queue type. */ /** Shader data. */ /** Render state. */ // todo: later will as a part of shaderData when shader effect frame is OK, that is more powerful and flexible.
  /**
     * Create a material instance.
     * @param engine - Engine to which the material belongs
     * @param shader - Shader used by the material
     */function Material(engine,shader){var _this;_this=_RefObject.call(this,engine)||this;_this.name=void 0;_this.shader=void 0;_this.renderQueueType=exports.RenderQueueType.Opaque;_this.shaderData=new ShaderData(ShaderDataGroup.Material);_this.renderState=new RenderState();_this.shader=shader;return _this;}/**
     * Clone and return the instance.
     */var _proto=Material.prototype;_proto.clone=function clone(){var dest=new Material(this._engine,this.shader);this.cloneTo(dest);return dest;}/**
     * Clone to the target material.
     * @param target - target material
     */;_proto.cloneTo=function cloneTo(target){target.shader=this.shader;target.renderQueueType=this.renderQueueType;this.shaderData.cloneTo(target.shaderData);CloneManager.deepCloneObject(this.renderState,target.renderState);}/**
     * @override
     */;_proto._addRefCount=function _addRefCount(value){_RefObject.prototype._addRefCount.call(this,value);this.shaderData._addRefCount(value);}/**
     * @internal
     * @todo:temporary solution
     */;_proto._preRender=function _preRender(renderElement){}/**
     * @override
     */;_proto._onDestroy=function _onDestroy(){};return Material;}(RefObject);/**
   * Class pool utils.
   */var ClassPool=/*#__PURE__*/function(){function ClassPool(type){this._elementPoolIndex=0;this._elementPool=[];this._type=void 0;this._type=type;}/**
     * Get element from pool.
     */var _proto=ClassPool.prototype;_proto.getFromPool=function getFromPool(){var index=this._elementPoolIndex,pool=this._elementPool;this._elementPoolIndex++;if(pool.length===index){var element=new this._type();pool.push(element);return element;}else {return pool[index];}}/**
     * Reset pool.
     */;_proto.resetPool=function resetPool(){this._elementPoolIndex=0;};return ClassPool;}();/**
   * Rendering context.
   */var RenderContext=/*#__PURE__*/function(){function RenderContext(){this._camera=void 0;this._viewProjectMatrix=new Matrix();}var _proto=RenderContext.prototype;/**
     * @internal
     */_proto._setContext=function _setContext(camera){this._camera=camera;Matrix.multiply(camera.projectionMatrix,camera.viewMatrix,this._viewProjectMatrix);};return RenderContext;}();/**
   * Render element.
   */var RenderElement=/*#__PURE__*/function(){function RenderElement(){this.component=void 0;this.mesh=void 0;this.subMesh=void 0;this.material=void 0;}var _proto=RenderElement.prototype;_proto.setValue=function setValue(component,mesh,subMesh,material){this.component=component;this.mesh=mesh;this.subMesh=subMesh;this.material=material;};return RenderElement;}();var SpriteElement=/*#__PURE__*/function(){function SpriteElement(){this.component=void 0;this.positions=void 0;this.uv=void 0;this.triangles=void 0;this.color=void 0;this.material=void 0;this.camera=void 0;}var _proto=SpriteElement.prototype;_proto.setValue=function setValue(component,positions,uv,triangles,color,material,camera){this.component=component;this.positions=positions;this.uv=uv;this.triangles=triangles;this.color=color;this.material=material;this.camera=camera;};return SpriteElement;}();var SpriteMaskElement=/*#__PURE__*/function(){function SpriteMaskElement(){this.component=void 0;this.positions=void 0;this.uv=void 0;this.triangles=void 0;this.material=void 0;this.isAdd=true;this.camera=void 0;}var _proto=SpriteMaskElement.prototype;_proto.setValue=function setValue(component,positions,uv,triangles,material){this.component=component;this.positions=positions;this.uv=uv;this.triangles=triangles;this.material=material;};return SpriteMaskElement;}();/**
   * Sprite mask interaction.
   */exports.SpriteMaskInteraction = void 0;(function(SpriteMaskInteraction){SpriteMaskInteraction[SpriteMaskInteraction["None"]=0]="None";SpriteMaskInteraction[SpriteMaskInteraction["VisibleInsideMask"]=1]="VisibleInsideMask";SpriteMaskInteraction[SpriteMaskInteraction["VisibleOutsideMask"]=2]="VisibleOutsideMask";})(exports.SpriteMaskInteraction||(exports.SpriteMaskInteraction={}));var _class$7$1,_descriptor$7,_descriptor2$7,_descriptor3$6,_descriptor4$6,_descriptor5$6,_descriptor6$6,_descriptor7$4,_descriptor8$2,_descriptor9$2,_descriptor10$2,_descriptor11$2,_descriptor12$2,_descriptor13$1,_descriptor14,_descriptor15,_descriptor16,_class2$6,_temp$6;/**
   * Renderable component.
   */var Renderer=(_class$7$1=(_temp$6=_class2$6=/*#__PURE__*/function(_Component){_inheritsLoose$2(Renderer,_Component);/**
     * @internal
     */function Renderer(entity){var _this;_this=_Component.call(this,entity)||this;_initializerDefineProperty(_this,"shaderData",_descriptor$7,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"isCulled",_descriptor2$7,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_distanceForSort",_descriptor3$6,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_onUpdateIndex",_descriptor4$6,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_rendererIndex",_descriptor5$6,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_globalShaderMacro",_descriptor6$6,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_renderSortId",_descriptor7$4,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_overrideUpdate",_descriptor8$2,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_materials",_descriptor9$2,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_transformChangeFlag",_descriptor10$2,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_bounds",_descriptor11$2,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_mvMatrix",_descriptor12$2,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_mvpMatrix",_descriptor13$1,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_mvInvMatrix",_descriptor14,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_normalMatrix",_descriptor15,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_materialsInstanced",_descriptor16,_assertThisInitialized$1(_this));var prototype=Renderer.prototype;_this._overrideUpdate=_this.update!==prototype.update;_this._transformChangeFlag=_this.entity.transform.registerWorldChangeFlag();_this.shaderData._addRefCount(1);return _this;}/**
     * Get the first instance material.
     * @returns The first instance material
     */var _proto=Renderer.prototype;_proto.getInstanceMaterial=function getInstanceMaterial(index){if(index===void 0){index=0;}var materials=this._materials;if(materials.length>index){var _material=materials[index];if(_material){if(this._materialsInstanced[index]){return _material;}else {return this._createInstanceMaterial(_material,index);}}}return null;}/**
     * Get the first material.
     * @returns The first material
     */;_proto.getMaterial=function getMaterial(index){if(index===void 0){index=0;}return this._materials[index]||null;}/**
     * Set the first material.
     * @param material - The first material
     */;_proto.setMaterial=function setMaterial(indexOrMaterial,material){if(material===void 0){material=null;}var index;if(typeof indexOrMaterial==="number"){index=indexOrMaterial;}else {index=0;material=indexOrMaterial;}var materials=this._materials;if(index>=materials.length){materials.length=index+1;}var materialsInstance=this._materialsInstanced;var internalMaterial=materials[index];if(internalMaterial!==material){materials[index]=material;index<materialsInstance.length&&(materialsInstance[index]=false);internalMaterial&&internalMaterial._addRefCount(-1);material&&material._addRefCount(1);}}/**
     * Get all instance materials.
     * @remarks Calling this function for the first time after the material is set will create an instance material to ensure that it is unique to the renderer.
     * @returns All instance materials
     */;_proto.getInstanceMaterials=function getInstanceMaterials(){var materials=this._materials;var materialsInstance=this._materialsInstanced;for(var i=0,n=materials.length;i<n;i++){if(!materialsInstance[i]){this._createInstanceMaterial(this._materials[i],i);}}return materials;}/**
     * Get all materials.
     * @returns All materials
     */;_proto.getMaterials=function getMaterials(){return this._materials;}/**
     * Set all materials.
     * @param materials - All materials
     */;_proto.setMaterials=function setMaterials(materials){var count=materials.length;var internalMaterials=this._materials;var materialsInstanced=this._materialsInstanced;for(var i=count,n=internalMaterials.length;i<n;i++){var internalMaterial=internalMaterials[i];internalMaterial&&internalMaterial._addRefCount(-1);}internalMaterials.length!==count&&(internalMaterials.length=count);materialsInstanced.length!==0&&(materialsInstanced.length=0);for(var _i=0;_i<count;_i++){var _internalMaterial=internalMaterials[_i];var _material2=materials[_i];if(_internalMaterial!==_material2){internalMaterials[_i]=_material2;_internalMaterial&&_internalMaterial._addRefCount(-1);_material2&&_material2._addRefCount(1);}}};_proto.update=function update(deltaTime){}/**
     * @internal
     */;_proto._updateShaderData=function _updateShaderData(context){var shaderData=this.shaderData;var worldMatrix=this.entity.transform.worldMatrix;var mvMatrix=this._mvMatrix;var mvpMatrix=this._mvpMatrix;var mvInvMatrix=this._mvInvMatrix;var normalMatrix=this._normalMatrix;Matrix.multiply(context._camera.viewMatrix,worldMatrix,mvMatrix);Matrix.multiply(context._viewProjectMatrix,worldMatrix,mvpMatrix);Matrix.invert(mvMatrix,mvInvMatrix);Matrix.invert(worldMatrix,normalMatrix);normalMatrix.transpose();shaderData.setMatrix(Renderer._localMatrixProperty,this.entity.transform.localMatrix);shaderData.setMatrix(Renderer._worldMatrixProperty,worldMatrix);shaderData.setMatrix(Renderer._mvMatrixProperty,mvMatrix);shaderData.setMatrix(Renderer._mvpMatrixProperty,mvpMatrix);shaderData.setMatrix(Renderer._mvInvMatrixProperty,mvInvMatrix);shaderData.setMatrix(Renderer._normalMatrixProperty,normalMatrix);};_proto._onEnable=function _onEnable(){var componentsManager=this.engine._componentsManager;if(this._overrideUpdate){componentsManager.addOnUpdateRenderers(this);}componentsManager.addRenderer(this);};_proto._onDisable=function _onDisable(){var componentsManager=this.engine._componentsManager;if(this._overrideUpdate){componentsManager.removeOnUpdateRenderers(this);}componentsManager.removeRenderer(this);}/**
     * @internal
     */;/**
     * @internal
     */_proto._onDestroy=function _onDestroy(){var flag=this._transformChangeFlag;if(flag){flag.destroy();this._transformChangeFlag=null;}this.shaderData._addRefCount(-1);for(var i=0,n=this._materials.length;i<n;i++){this._materials[i]._addRefCount(-1);}};_proto._updateBounds=function _updateBounds(worldBounds){};_proto._createInstanceMaterial=function _createInstanceMaterial(material,index){var insMaterial=material.clone();insMaterial.name=insMaterial.name+"(Instance)";material._addRefCount(-1);insMaterial._addRefCount(1);this._materialsInstanced[index]=true;this._materials[index]=insMaterial;return insMaterial;};_createClass$3(Renderer,[{key:"materialCount",get:/** ShaderData related to renderer. */ /** Whether it is clipped by the frustum, needs to be turned on camera.enableFrustumCulling. */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal temp solution. */ /**
       * Material count.
       */function get(){return this._materials.length;},set:function set(value){var materials=this._materials;var materialsInstanced=this._materialsInstanced;materials.length!==value&&(materials.length=value);materialsInstanced.length>value&&(materialsInstanced.length=value);}/**
       * The bounding volume of the renderer.
       */},{key:"bounds",get:function get(){var changeFlag=this._transformChangeFlag;if(changeFlag.flag){this._updateBounds(this._bounds);changeFlag.flag=false;}return this._bounds;}}]);return Renderer;}(Component),_class2$6._localMatrixProperty=Shader.getPropertyByName("u_localMat"),_class2$6._worldMatrixProperty=Shader.getPropertyByName("u_modelMat"),_class2$6._mvMatrixProperty=Shader.getPropertyByName("u_MVMat"),_class2$6._mvpMatrixProperty=Shader.getPropertyByName("u_MVPMat"),_class2$6._mvInvMatrixProperty=Shader.getPropertyByName("u_MVInvMat"),_class2$6._normalMatrixProperty=Shader.getPropertyByName("u_normalMat"),_temp$6),(_descriptor$7=_applyDecoratedDescriptor$1(_class$7$1.prototype,"shaderData",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new ShaderData(ShaderDataGroup.Renderer);}}),_descriptor2$7=_applyDecoratedDescriptor$1(_class$7$1.prototype,"isCulled",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor3$6=_applyDecoratedDescriptor$1(_class$7$1.prototype,"_distanceForSort",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor4$6=_applyDecoratedDescriptor$1(_class$7$1.prototype,"_onUpdateIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_descriptor5$6=_applyDecoratedDescriptor$1(_class$7$1.prototype,"_rendererIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_descriptor6$6=_applyDecoratedDescriptor$1(_class$7$1.prototype,"_globalShaderMacro",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new ShaderMacroCollection();}}),_descriptor7$4=_applyDecoratedDescriptor$1(_class$7$1.prototype,"_renderSortId",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return 0;}}),_descriptor8$2=_applyDecoratedDescriptor$1(_class$7$1.prototype,"_overrideUpdate",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor9$2=_applyDecoratedDescriptor$1(_class$7$1.prototype,"_materials",[shallowClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return [];}}),_descriptor10$2=_applyDecoratedDescriptor$1(_class$7$1.prototype,"_transformChangeFlag",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor11$2=_applyDecoratedDescriptor$1(_class$7$1.prototype,"_bounds",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new BoundingBox(new Vector3(),new Vector3());}}),_descriptor12$2=_applyDecoratedDescriptor$1(_class$7$1.prototype,"_mvMatrix",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor13$1=_applyDecoratedDescriptor$1(_class$7$1.prototype,"_mvpMatrix",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor14=_applyDecoratedDescriptor$1(_class$7$1.prototype,"_mvInvMatrix",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor15=_applyDecoratedDescriptor$1(_class$7$1.prototype,"_normalMatrix",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor16=_applyDecoratedDescriptor$1(_class$7$1.prototype,"_materialsInstanced",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return [];}})),_class$7$1);/**
   * Sprite mask layer.
   */exports.SpriteMaskLayer = void 0;(function(SpriteMaskLayer){SpriteMaskLayer[SpriteMaskLayer["Layer0"]=1]="Layer0";SpriteMaskLayer[SpriteMaskLayer["Layer1"]=2]="Layer1";SpriteMaskLayer[SpriteMaskLayer["Layer2"]=4]="Layer2";SpriteMaskLayer[SpriteMaskLayer["Layer3"]=8]="Layer3";SpriteMaskLayer[SpriteMaskLayer["Layer4"]=16]="Layer4";SpriteMaskLayer[SpriteMaskLayer["Layer5"]=32]="Layer5";SpriteMaskLayer[SpriteMaskLayer["Layer6"]=64]="Layer6";SpriteMaskLayer[SpriteMaskLayer["Layer7"]=128]="Layer7";SpriteMaskLayer[SpriteMaskLayer["Layer8"]=256]="Layer8";SpriteMaskLayer[SpriteMaskLayer["Layer9"]=512]="Layer9";SpriteMaskLayer[SpriteMaskLayer["Layer10"]=1024]="Layer10";SpriteMaskLayer[SpriteMaskLayer["Layer11"]=2048]="Layer11";SpriteMaskLayer[SpriteMaskLayer["Layer12"]=4096]="Layer12";SpriteMaskLayer[SpriteMaskLayer["Layer13"]=8192]="Layer13";SpriteMaskLayer[SpriteMaskLayer["Layer14"]=16384]="Layer14";SpriteMaskLayer[SpriteMaskLayer["Layer15"]=32768]="Layer15";SpriteMaskLayer[SpriteMaskLayer["Layer16"]=65536]="Layer16";SpriteMaskLayer[SpriteMaskLayer["Layer17"]=131072]="Layer17";SpriteMaskLayer[SpriteMaskLayer["Layer18"]=262144]="Layer18";SpriteMaskLayer[SpriteMaskLayer["Layer19"]=524288]="Layer19";SpriteMaskLayer[SpriteMaskLayer["Layer20"]=1048576]="Layer20";SpriteMaskLayer[SpriteMaskLayer["Layer21"]=2097152]="Layer21";SpriteMaskLayer[SpriteMaskLayer["Layer22"]=4194304]="Layer22";SpriteMaskLayer[SpriteMaskLayer["Layer23"]=8388608]="Layer23";SpriteMaskLayer[SpriteMaskLayer["Layer24"]=16777216]="Layer24";SpriteMaskLayer[SpriteMaskLayer["Layer25"]=33554432]="Layer25";SpriteMaskLayer[SpriteMaskLayer["Layer26"]=67108864]="Layer26";SpriteMaskLayer[SpriteMaskLayer["Layer27"]=134217728]="Layer27";SpriteMaskLayer[SpriteMaskLayer["Layer28"]=268435456]="Layer28";SpriteMaskLayer[SpriteMaskLayer["Layer29"]=536870912]="Layer29";SpriteMaskLayer[SpriteMaskLayer["Layer30"]=1073741824]="Layer30";SpriteMaskLayer[SpriteMaskLayer["Layer31"]=2147483648]="Layer31";SpriteMaskLayer[SpriteMaskLayer["Everything"]=4294967295]="Everything";})(exports.SpriteMaskLayer||(exports.SpriteMaskLayer={}));var _class$6$1,_descriptor$6,_descriptor2$6,_descriptor3$5,_descriptor4$5,_descriptor5$5,_descriptor6$5,_class2$5,_temp$5;/**
   * A component for masking Sprites.
   */var SpriteMask=(_class$6$1=(_temp$5=_class2$5=/*#__PURE__*/function(_Renderer){_inheritsLoose$2(SpriteMask,_Renderer);/**
     * @internal
     */function SpriteMask(entity){var _this;_this=_Renderer.call(this,entity)||this;_this._maskElement=void 0;_initializerDefineProperty(_this,"_positions",_descriptor$6,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_isSpriteDirty",_descriptor2$6,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_worldMatrixDirtyFlag",_descriptor3$5,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_sprite",_descriptor4$5,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_alphaCutoff",_descriptor5$5,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"influenceLayers",_descriptor6$5,_assertThisInitialized$1(_this));_this._worldMatrixDirtyFlag=entity.transform.registerWorldChangeFlag();_this.setMaterial(_this._engine._spriteMaskDefaultMaterial);_this.shaderData.setFloat(SpriteMask._alphaCutoffProperty,_this._alphaCutoff);return _this;}/**
     * @override
     * @inheritdoc
     */var _proto=SpriteMask.prototype;_proto._onDestroy=function _onDestroy(){this._worldMatrixDirtyFlag.destroy();_Renderer.prototype._onDestroy.call(this);}/**
     * @override
     * @inheritdoc
     */;_proto._render=function _render(camera){var sprite=this.sprite;if(!sprite){return null;}var texture=sprite.texture;if(!texture){return null;}var positions=this._positions;var transform=this.entity.transform;// Update sprite data.
  var localDirty=sprite._updateMeshData();if(this._worldMatrixDirtyFlag.flag||localDirty||this._isSpriteDirty){var localPositions=sprite._positions;var localVertexPos=SpriteMask._tempVec3;var worldMatrix=transform.worldMatrix;for(var i=0,n=positions.length;i<n;i++){var curVertexPos=localPositions[i];localVertexPos.setValue(curVertexPos.x,curVertexPos.y,0);Vector3.transformToVec3(localVertexPos,worldMatrix,positions[i]);}this._isSpriteDirty=false;this._worldMatrixDirtyFlag.flag=false;}this.shaderData.setTexture(SpriteMask._textureProperty,texture);var spriteMaskElementPool=this._engine._spriteMaskElementPool;var maskElement=spriteMaskElementPool.getFromPool();maskElement.setValue(this,positions,sprite._uv,sprite._triangles,this.getMaterial());maskElement.camera=camera;camera._renderPipeline._allSpriteMasks.add(this);this._maskElement=maskElement;};_createClass$3(SpriteMask,[{key:"sprite",get:/** @internal */ /** @internal */ /** @internal */ /** The mask layers the sprite mask influence to. */ /**
       * The Sprite used to define the mask.
       */function get(){return this._sprite;},set:function set(value){if(this._sprite!==value){this._sprite=value;this._isSpriteDirty=true;}}/**
       * The minimum alpha value used by the mask to select the area of influence defined over the mask's sprite. Value between 0 and 1.
       */},{key:"alphaCutoff",get:function get(){return this._alphaCutoff;},set:function set(value){if(this._alphaCutoff!==value){this._alphaCutoff=value;this.shaderData.setFloat(SpriteMask._alphaCutoffProperty,value);}}}]);return SpriteMask;}(Renderer),_class2$5._textureProperty=Shader.getPropertyByName("u_maskTexture"),_class2$5._alphaCutoffProperty=Shader.getPropertyByName("u_maskAlphaCutoff"),_class2$5._tempVec3=new Vector3(),_temp$5),(_descriptor$6=_applyDecoratedDescriptor$1(_class$6$1.prototype,"_positions",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return [new Vector3(),new Vector3(),new Vector3(),new Vector3()];}}),_descriptor2$6=_applyDecoratedDescriptor$1(_class$6$1.prototype,"_isSpriteDirty",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return true;}}),_descriptor3$5=_applyDecoratedDescriptor$1(_class$6$1.prototype,"_worldMatrixDirtyFlag",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor4$5=_applyDecoratedDescriptor$1(_class$6$1.prototype,"_sprite",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return null;}}),_descriptor5$5=_applyDecoratedDescriptor$1(_class$6$1.prototype,"_alphaCutoff",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return 0.5;}}),_descriptor6$5=_applyDecoratedDescriptor$1(_class$6$1.prototype,"influenceLayers",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return exports.SpriteMaskLayer.Everything;}})),_class$6$1);/**
   * Vertex element format.
   */exports.VertexElementFormat = void 0;(function(VertexElementFormat){VertexElementFormat[VertexElementFormat["Float"]=0]="Float";VertexElementFormat[VertexElementFormat["Vector2"]=1]="Vector2";VertexElementFormat[VertexElementFormat["Vector3"]=2]="Vector3";VertexElementFormat[VertexElementFormat["Vector4"]=3]="Vector4";VertexElementFormat[VertexElementFormat["Byte4"]=4]="Byte4";VertexElementFormat[VertexElementFormat["UByte4"]=5]="UByte4";VertexElementFormat[VertexElementFormat["NormalizedByte4"]=6]="NormalizedByte4";VertexElementFormat[VertexElementFormat["NormalizedUByte4"]=7]="NormalizedUByte4";VertexElementFormat[VertexElementFormat["Short2"]=8]="Short2";VertexElementFormat[VertexElementFormat["UShort2"]=9]="UShort2";VertexElementFormat[VertexElementFormat["NormalizedShort2"]=10]="NormalizedShort2";VertexElementFormat[VertexElementFormat["NormalizedUShort2"]=11]="NormalizedUShort2";VertexElementFormat[VertexElementFormat["Short4"]=12]="Short4";VertexElementFormat[VertexElementFormat["UShort4"]=13]="UShort4";VertexElementFormat[VertexElementFormat["NormalizedShort4"]=14]="NormalizedShort4";VertexElementFormat[VertexElementFormat["NormalizedUShort4"]=15]="NormalizedUShort4";})(exports.VertexElementFormat||(exports.VertexElementFormat={}));/**
   * Buffer usage.
   */exports.BufferUsage = void 0;(function(BufferUsage){BufferUsage[BufferUsage["Static"]=0]="Static";BufferUsage[BufferUsage["Dynamic"]=1]="Dynamic";BufferUsage[BufferUsage["Stream"]=2]="Stream";})(exports.BufferUsage||(exports.BufferUsage={}));/**
   * Index format.
   */exports.IndexFormat = void 0;(function(IndexFormat){IndexFormat[IndexFormat["UInt8"]=0]="UInt8";IndexFormat[IndexFormat["UInt16"]=1]="UInt16";IndexFormat[IndexFormat["UInt32"]=2]="UInt32";})(exports.IndexFormat||(exports.IndexFormat={}));var BufferUtil=/*#__PURE__*/function(){function BufferUtil(){}/**
     * @internal
     */BufferUtil._getGLBufferUsage=function _getGLBufferUsage(gl,bufferUsage){switch(bufferUsage){case exports.BufferUsage.Static:return gl.STATIC_DRAW;case exports.BufferUsage.Dynamic:return gl.DYNAMIC_DRAW;case exports.BufferUsage.Stream:return gl.STREAM_DRAW;}};BufferUtil._getGLIndexType=function _getGLIndexType(indexFormat){switch(indexFormat){case exports.IndexFormat.UInt8:return exports.DataType.UNSIGNED_BYTE;case exports.IndexFormat.UInt16:return exports.DataType.UNSIGNED_SHORT;case exports.IndexFormat.UInt32:return exports.DataType.UNSIGNED_INT;}};BufferUtil._getGLIndexByteCount=function _getGLIndexByteCount(indexFormat){switch(indexFormat){case exports.IndexFormat.UInt8:return 1;case exports.IndexFormat.UInt16:return 2;case exports.IndexFormat.UInt32:return 4;}}/**
     * @internal
     */;BufferUtil._getElementInfo=function _getElementInfo(format){var size;var type;var normalized=false;switch(format){case exports.VertexElementFormat.Float:size=1;type=exports.DataType.FLOAT;break;case exports.VertexElementFormat.Vector2:size=2;type=exports.DataType.FLOAT;break;case exports.VertexElementFormat.Vector3:size=3;type=exports.DataType.FLOAT;break;case exports.VertexElementFormat.Vector4:size=4;type=exports.DataType.FLOAT;break;case exports.VertexElementFormat.Byte4:size=4;type=exports.DataType.BYTE;break;case exports.VertexElementFormat.UByte4:size=4;type=exports.DataType.UNSIGNED_BYTE;break;case exports.VertexElementFormat.NormalizedByte4:size=4;type=exports.DataType.BYTE;normalized=true;break;case exports.VertexElementFormat.NormalizedUByte4:size=4;type=exports.DataType.UNSIGNED_BYTE;normalized=true;break;case exports.VertexElementFormat.Short2:size=2;type=exports.DataType.SHORT;break;case exports.VertexElementFormat.UShort2:size=2;type=exports.DataType.UNSIGNED_SHORT;break;case exports.VertexElementFormat.NormalizedShort2:size=2;type=exports.DataType.SHORT;normalized=true;break;case exports.VertexElementFormat.NormalizedUShort2:size=2;type=exports.DataType.UNSIGNED_SHORT;normalized=true;break;case exports.VertexElementFormat.Short4:size=4;type=exports.DataType.SHORT;break;case exports.VertexElementFormat.UShort4:size=4;type=exports.DataType.UNSIGNED_SHORT;break;case exports.VertexElementFormat.NormalizedShort4:size=4;type=exports.DataType.SHORT;normalized=true;break;case exports.VertexElementFormat.NormalizedUShort4:size=4;type=exports.DataType.UNSIGNED_SHORT;normalized=true;break;}return {size:size,type:type,normalized:normalized};};return BufferUtil;}();/**
   * Vertex element.
   */var VertexElement=/*#__PURE__*/function(){/**
     * Create vertex element.
     * @param semantic - Input vertex semantic
     * @param offset - Vertex data byte offset
     * @param format - Vertex data format
     * @param bindingIndex - Vertex buffer binding index
     * @param instanceStepRate - Instance cadence, the number of instances drawn for each vertex in the buffer, non-instance elements must be 0.
     */function VertexElement(semantic,offset,format,bindingIndex,instanceStepRate){if(instanceStepRate===void 0){instanceStepRate=0;}this._glElementInfo=void 0;this._semantic=void 0;this._offset=void 0;this._format=void 0;this._bindingIndex=void 0;this._instanceStepRate=void 0;this._semantic=semantic;this._offset=offset;this._format=format;this._bindingIndex=bindingIndex;this._glElementInfo=BufferUtil._getElementInfo(this.format);this._instanceStepRate=Math.floor(instanceStepRate);}_createClass$3(VertexElement,[{key:"semantic",get:/**
       * Vertex semantic.
       */function get(){return this._semantic;}/**
       * Vertex data byte offset.
       */},{key:"offset",get:function get(){return this._offset;}/**
       * Vertex data format.
       */},{key:"format",get:function get(){return this._format;}/**
       * Vertex buffer binding index.
       */},{key:"bindingIndex",get:function get(){return this._bindingIndex;}/**
       * Instance cadence, the number of instances drawn for each vertex in the buffer, non-instance elements must be 0.
       */},{key:"instanceStepRate",get:function get(){return this._instanceStepRate;}}]);return VertexElement;}();/**
   * Buffer binding flag.
   */exports.BufferBindFlag = void 0;(function(BufferBindFlag){BufferBindFlag[BufferBindFlag["VertexBuffer"]=0]="VertexBuffer";BufferBindFlag[BufferBindFlag["IndexBuffer"]=1]="IndexBuffer";})(exports.BufferBindFlag||(exports.BufferBindFlag={}));/**
   * Define update strategy when call bufferData/bufferSubData func.
   */exports.SetDataOptions = void 0;(function(SetDataOptions){SetDataOptions[SetDataOptions["None"]=0]="None";SetDataOptions[SetDataOptions["Discard"]=1]="Discard";})(exports.SetDataOptions||(exports.SetDataOptions={}));/**
   * Buffer.
   */var Buffer=/*#__PURE__*/function(_RefObject){_inheritsLoose$2(Buffer,_RefObject);function Buffer(engine,type,byteLengthOrData,bufferUsage){var _this;if(bufferUsage===void 0){bufferUsage=exports.BufferUsage.Static;}_this=_RefObject.call(this,engine)||this;_this._glBindTarget=void 0;_this._glBufferUsage=void 0;_this._nativeBuffer=void 0;_this._hardwareRenderer=void 0;_this._type=void 0;_this._byteLength=void 0;_this._bufferUsage=void 0;_this._engine=engine;_this._type=type;_this._bufferUsage=bufferUsage;var hardwareRenderer=engine._hardwareRenderer;var gl=hardwareRenderer.gl;var glBufferUsage=BufferUtil._getGLBufferUsage(gl,bufferUsage);var glBindTarget=type===exports.BufferBindFlag.VertexBuffer?gl.ARRAY_BUFFER:gl.ELEMENT_ARRAY_BUFFER;_this._nativeBuffer=gl.createBuffer();_this._hardwareRenderer=hardwareRenderer;_this._glBufferUsage=glBufferUsage;_this._glBindTarget=glBindTarget;_this.bind();if(typeof byteLengthOrData==="number"){_this._byteLength=byteLengthOrData;gl.bufferData(glBindTarget,byteLengthOrData,glBufferUsage);}else {_this._byteLength=byteLengthOrData.byteLength;gl.bufferData(glBindTarget,byteLengthOrData,glBufferUsage);}gl.bindBuffer(glBindTarget,null);return _this;}/**
     * Bind buffer.
     */var _proto=Buffer.prototype;_proto.bind=function bind(){var gl=this._hardwareRenderer.gl;gl.bindBuffer(this._glBindTarget,this._nativeBuffer);}/**
     * Set buffer data.
     * @param data - Input buffer data
     */;_proto.setData=function setData(data,bufferByteOffset,dataOffset,dataLength,options){if(bufferByteOffset===void 0){bufferByteOffset=0;}if(dataOffset===void 0){dataOffset=0;}if(options===void 0){options=exports.SetDataOptions.None;}var gl=this._hardwareRenderer.gl;var isWebGL2=this._hardwareRenderer.isWebGL2;var glBindTarget=this._glBindTarget;this.bind();if(options===exports.SetDataOptions.Discard){gl.bufferData(glBindTarget,this._byteLength,this._glBufferUsage);}// TypeArray is BYTES_PER_ELEMENT, unTypeArray is 1
  var byteSize=data.BYTES_PER_ELEMENT||1;var dataByteLength=dataLength?byteSize*dataLength:data.byteLength;if(dataOffset!==0||dataByteLength<data.byteLength){var isArrayBufferView=data.byteOffset!==undefined;if(isWebGL2&&isArrayBufferView){gl.bufferSubData(glBindTarget,bufferByteOffset,data,dataOffset,dataByteLength/byteSize);}else {var subData=new Uint8Array(isArrayBufferView?data.buffer:data,dataOffset*byteSize,dataByteLength);gl.bufferSubData(glBindTarget,bufferByteOffset,subData);}}else {gl.bufferSubData(glBindTarget,bufferByteOffset,data);}gl.bindBuffer(glBindTarget,null);}/**
     * Get buffer data.
     * @param data - Output buffer data
     */;_proto.getData=function getData(data,bufferByteOffset,dataOffset,dataLength){if(bufferByteOffset===void 0){bufferByteOffset=0;}if(dataOffset===void 0){dataOffset=0;}var isWebGL2=this._hardwareRenderer.isWebGL2;if(isWebGL2){var gl=this._hardwareRenderer.gl;this.bind();gl.getBufferSubData(this._glBindTarget,bufferByteOffset,data,dataOffset,dataLength);}else {throw "Buffer is write-only on WebGL1.0 platforms.";}}/**
     * @override
     * Destroy.
     */;_proto._onDestroy=function _onDestroy(){var gl=this._hardwareRenderer.gl;gl.deleteBuffer(this._nativeBuffer);this._nativeBuffer=null;this._hardwareRenderer=null;}/**
     * @deprecated
     */;_proto.resize=function resize(dataLength){this.bind();var gl=this._hardwareRenderer.gl;gl.bufferData(this._glBindTarget,dataLength,this._glBufferUsage);this._byteLength=dataLength;};_createClass$3(Buffer,[{key:"type",get:/**
       * Buffer binding flag.
       */function get(){return this._type;}/**
       * Byte length.
       */},{key:"byteLength",get:function get(){return this._byteLength;}/**
       * Buffer usage.
       */},{key:"bufferUsage",get:function get(){return this._bufferUsage;}/**
       * Create Buffer.
       * @param engine - Engine
       * @param type - Buffer binding flag
       * @param byteLength - Byte length
       * @param bufferUsage - Buffer usage
       */}]);return Buffer;}(RefObject);/**
   * Mesh topology.
   */exports.MeshTopology = void 0;(function(MeshTopology){MeshTopology[MeshTopology["Points"]=0]="Points";MeshTopology[MeshTopology["Lines"]=1]="Lines";MeshTopology[MeshTopology["LineLoop"]=2]="LineLoop";MeshTopology[MeshTopology["LineStrip"]=3]="LineStrip";MeshTopology[MeshTopology["Triangles"]=4]="Triangles";MeshTopology[MeshTopology["TriangleStrip"]=5]="TriangleStrip";MeshTopology[MeshTopology["TriangleFan"]=6]="TriangleFan";})(exports.MeshTopology||(exports.MeshTopology={}));/**
   * Index buffer binding.
   */var IndexBufferBinding=/*#__PURE__*/function(){/**
     * Create index buffer binding.
     * @param buffer - Index buffer
     * @param format - Index buffer format
     */function IndexBufferBinding(buffer,format){this._buffer=void 0;this._format=void 0;this._buffer=buffer;this._format=format;}_createClass$3(IndexBufferBinding,[{key:"buffer",get:/** @internal */ /** @internal */ /**
       * Index buffer.
       */function get(){return this._buffer;}/**
       * Index buffer format.
       */},{key:"format",get:function get(){return this._format;}}]);return IndexBufferBinding;}();/**
   * Sub-mesh, mainly contains drawing information.
   */var SubMesh=/** Start drawing offset. */ /** Drawing count. */ /** Drawing topology. */ /**
   * Create a sub-mesh.
   * @param start - Start drawing offset
   * @param count - Drawing count
   * @param topology - Drawing topology
   */function SubMesh(start,count,topology){if(start===void 0){start=0;}if(count===void 0){count=0;}if(topology===void 0){topology=exports.MeshTopology.Triangles;}this.start=void 0;this.count=void 0;this.topology=void 0;this.start=start;this.count=count;this.topology=topology;};/**
   * Mesh.
   */var Mesh=/*#__PURE__*/function(_RefObject){_inheritsLoose$2(Mesh,_RefObject);/**
     * Create mesh.
     * @param engine - Engine
     * @param name - Mesh name
     */function Mesh(engine,name){var _this;_this=_RefObject.call(this,engine)||this;_this.name=void 0;_this.bounds=new BoundingBox();_this._vertexElementMap={};_this._glIndexType=void 0;_this._glIndexByteCount=void 0;_this._platformPrimitive=void 0;_this._instanceCount=0;_this._vertexBufferBindings=[];_this._indexBufferBinding=null;_this._vertexElements=[];_this._subMeshes=[];_this._updateFlagManager=new UpdateFlagManager();_this.name=name;_this._platformPrimitive=_this._engine._hardwareRenderer.createPlatformPrimitive(_assertThisInitialized$1(_this));return _this;}/**
     * Add sub-mesh, each sub-mesh can correspond to an independent material.
     * @param subMesh - Start drawing offset, if the index buffer is set, it means the offset in the index buffer, if not set, it means the offset in the vertex buffer
     * @returns Sub-mesh
     */var _proto=Mesh.prototype;_proto.addSubMesh=function addSubMesh(startOrSubMesh,count,topology){if(topology===void 0){topology=exports.MeshTopology.Triangles;}if(typeof startOrSubMesh==="number"){startOrSubMesh=new SubMesh(startOrSubMesh,count,topology);}this._subMeshes.push(startOrSubMesh);return startOrSubMesh;}/**
     * Remove sub-mesh.
     * @param subMesh - Sub-mesh needs to be removed
     */;_proto.removeSubMesh=function removeSubMesh(subMesh){var subMeshes=this._subMeshes;var index=subMeshes.indexOf(subMesh);if(index!==-1){subMeshes.splice(index,1);}}/**
     * Clear all sub-mesh.
     */;_proto.clearSubMesh=function clearSubMesh(){this._subMeshes.length=0;}/**
     * Register update flag, update flag will be true if the vertex element changes.
     * @returns Update flag
     */;_proto.registerUpdateFlag=function registerUpdateFlag(){return this._updateFlagManager.register();}/**
     * @internal
     */;_proto._draw=function _draw(shaderProgram,subMesh){this._platformPrimitive.draw(shaderProgram,subMesh);}/**
     * @override
     */;_proto._addRefCount=function _addRefCount(value){_RefObject.prototype._addRefCount.call(this,value);var vertexBufferBindings=this._vertexBufferBindings;for(var i=0,n=vertexBufferBindings.length;i<n;i++){vertexBufferBindings[i]._buffer._addRefCount(value);}}/**
     * @override
     * Destroy.
     */;_proto._onDestroy=function _onDestroy(){this._vertexBufferBindings=null;this._indexBufferBinding=null;this._vertexElements=null;this._vertexElementMap=null;this._platformPrimitive.destroy();};_proto._setVertexElements=function _setVertexElements(elements){this._clearVertexElements();for(var i=0,n=elements.length;i<n;i++){this._addVertexElement(elements[i]);}};_proto._setVertexBufferBinding=function _setVertexBufferBinding(index,binding){if(this._getRefCount()>0){var lastBinding=this._vertexBufferBindings[index];lastBinding&&lastBinding._buffer._addRefCount(-1);binding._buffer._addRefCount(1);}this._vertexBufferBindings[index]=binding;};_proto._setIndexBufferBinding=function _setIndexBufferBinding(binding){if(binding){this._indexBufferBinding=binding;this._glIndexType=BufferUtil._getGLIndexType(binding.format);this._glIndexByteCount=BufferUtil._getGLIndexByteCount(binding.format);}else {this._indexBufferBinding=null;this._glIndexType=undefined;}};_proto._clearVertexElements=function _clearVertexElements(){this._vertexElements.length=0;var vertexElementMap=this._vertexElementMap;for(var k in vertexElementMap){delete vertexElementMap[k];}};_proto._addVertexElement=function _addVertexElement(element){var semantic=element.semantic;this._vertexElementMap[semantic]=element;this._vertexElements.push(element);this._updateFlagManager.distribute();};_createClass$3(Mesh,[{key:"subMesh",get:/** Name. */ /** The bounding volume of the mesh. */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /**
       * First sub-mesh. Rendered using the first material.
       */function get(){return this._subMeshes[0]||null;}/**
       * A collection of sub-mesh, each sub-mesh can be rendered with an independent material.
       */},{key:"subMeshes",get:function get(){return this._subMeshes;}}]);return Mesh;}(RefObject);/**
   * Vertex buffer binding.
   */var VertexBufferBinding=/*#__PURE__*/function(){/**
     * Create vertex buffer.
     * @param buffer - Vertex buffer
     * @param stride - Vertex buffer stride
     */function VertexBufferBinding(buffer,stride){this._buffer=void 0;this._stride=void 0;this._buffer=buffer;this._stride=stride;}_createClass$3(VertexBufferBinding,[{key:"buffer",get:/** @internal */ /** @internal */ /**
       * Vertex buffer.
       */function get(){return this._buffer;}/**
       * Vertex buffer stride.
       */},{key:"stride",get:function get(){return this._stride;}}]);return VertexBufferBinding;}();/**
   * The filter mode of the texture.
   */exports.TextureFilterMode = void 0;(function(TextureFilterMode){TextureFilterMode[TextureFilterMode["Point"]=0]="Point";TextureFilterMode[TextureFilterMode["Bilinear"]=1]="Bilinear";TextureFilterMode[TextureFilterMode["Trilinear"]=2]="Trilinear";})(exports.TextureFilterMode||(exports.TextureFilterMode={}));/**
   * Texture format enumeration.
   */exports.TextureFormat = void 0;(function(TextureFormat){TextureFormat[TextureFormat["R8G8B8"]=0]="R8G8B8";TextureFormat[TextureFormat["R8G8B8A8"]=1]="R8G8B8A8";TextureFormat[TextureFormat["R4G4B4A4"]=2]="R4G4B4A4";TextureFormat[TextureFormat["R5G5B5A1"]=3]="R5G5B5A1";TextureFormat[TextureFormat["R5G6B5"]=4]="R5G6B5";TextureFormat[TextureFormat["Alpha8"]=5]="Alpha8";TextureFormat[TextureFormat["LuminanceAlpha"]=6]="LuminanceAlpha";TextureFormat[TextureFormat["R32G32B32A32"]=7]="R32G32B32A32";TextureFormat[TextureFormat["DXT1"]=8]="DXT1";TextureFormat[TextureFormat["DXT5"]=9]="DXT5";TextureFormat[TextureFormat["ETC1_RGB"]=10]="ETC1_RGB";TextureFormat[TextureFormat["ETC2_RGB"]=11]="ETC2_RGB";TextureFormat[TextureFormat["ETC2_RGBA5"]=12]="ETC2_RGBA5";TextureFormat[TextureFormat["ETC2_RGBA8"]=13]="ETC2_RGBA8";TextureFormat[TextureFormat["PVRTC_RGB2"]=14]="PVRTC_RGB2";TextureFormat[TextureFormat["PVRTC_RGBA2"]=15]="PVRTC_RGBA2";TextureFormat[TextureFormat["PVRTC_RGB4"]=16]="PVRTC_RGB4";TextureFormat[TextureFormat["PVRTC_RGBA4"]=17]="PVRTC_RGBA4";TextureFormat[TextureFormat["ASTC_4x4"]=18]="ASTC_4x4";TextureFormat[TextureFormat["ASTC_5x5"]=19]="ASTC_5x5";TextureFormat[TextureFormat["ASTC_6x6"]=20]="ASTC_6x6";TextureFormat[TextureFormat["ASTC_8x8"]=21]="ASTC_8x8";TextureFormat[TextureFormat["ASTC_10x10"]=22]="ASTC_10x10";TextureFormat[TextureFormat["ASTC_12x12"]=23]="ASTC_12x12";})(exports.TextureFormat||(exports.TextureFormat={}));/**
   * Wrapping mode of the texture.
   */exports.TextureWrapMode = void 0;(function(TextureWrapMode){TextureWrapMode[TextureWrapMode["Clamp"]=0]="Clamp";TextureWrapMode[TextureWrapMode["Repeat"]=1]="Repeat";TextureWrapMode[TextureWrapMode["Mirror"]=2]="Mirror";})(exports.TextureWrapMode||(exports.TextureWrapMode={}));/**
   * Two-dimensional texture.
   */var Texture2D=/*#__PURE__*/function(_Texture){_inheritsLoose$2(Texture2D,_Texture);/**
     * Create Texture2D.
     * @param engine - Define the engine to use to render this texture
     * @param width - Texture width
     * @param height - Texture height
     * @param format - Texture format. default  `TextureFormat.R8G8B8A8`
     * @param mipmap - Whether to use multi-level texture
     */function Texture2D(engine,width,height,format,mipmap){var _this;if(format===void 0){format=exports.TextureFormat.R8G8B8A8;}if(mipmap===void 0){mipmap=true;}_this=_Texture.call(this,engine)||this;_this._format=void 0;_this._mipmap=mipmap;_this._width=width;_this._height=height;_this._format=format;_this._mipmapCount=_this._getMipmapCount();_this._platformTexture=engine._hardwareRenderer.createPlatformTexture2D(_assertThisInitialized$1(_this));_this.filterMode=exports.TextureFilterMode.Bilinear;_this.wrapModeU=_this.wrapModeV=exports.TextureWrapMode.Repeat;return _this;}/**
     * Setting pixels data through color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
     * @remarks If it is the WebGL1.0 platform and the texture format is compressed, the first upload must be filled with textures.
     * @param colorBuffer - Color buffer data
     * @param mipLevel - Texture mipmapping level
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     * @param width - Data width. if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
     * @param height - Data height. if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
     */var _proto=Texture2D.prototype;_proto.setPixelBuffer=function setPixelBuffer(colorBuffer,mipLevel,x,y,width,height){if(mipLevel===void 0){mipLevel=0;}this._platformTexture.setPixelBuffer(colorBuffer,mipLevel,x,y,width,height);}/**
     * Setting pixels data through TexImageSource, designated area and texture mipmapping level.
     * @param imageSource - The source of texture
     * @param mipLevel - Texture mipmapping level
     * @param flipY - Whether to flip the Y axis
     * @param premultiplyAlpha - Whether to premultiply the transparent channel
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     */;_proto.setImageSource=function setImageSource(imageSource,mipLevel,flipY,premultiplyAlpha,x,y){if(mipLevel===void 0){mipLevel=0;}if(flipY===void 0){flipY=false;}if(premultiplyAlpha===void 0){premultiplyAlpha=false;}this._platformTexture.setImageSource(imageSource,mipLevel,flipY,premultiplyAlpha,x,y);}/**
     * Get the pixel color buffer according to the specified area.
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     * @param width - Area width
     * @param height - Area height
     * @param out - Color buffer
     */;_proto.getPixelBuffer=function getPixelBuffer(x,y,width,height,out){this._platformTexture.getPixelBuffer(x,y,width,height,out);};_createClass$3(Texture2D,[{key:"format",get:/**
       * Texture format.
       */function get(){return this._format;}}]);return Texture2D;}(Texture);/**
   * The rendering buffer color format enumeration.
   */exports.RenderBufferColorFormat = void 0;(function(RenderBufferColorFormat){RenderBufferColorFormat[RenderBufferColorFormat["R8G8B8"]=0]="R8G8B8";RenderBufferColorFormat[RenderBufferColorFormat["R8G8B8A8"]=1]="R8G8B8A8";RenderBufferColorFormat[RenderBufferColorFormat["R4G4B4A4"]=2]="R4G4B4A4";RenderBufferColorFormat[RenderBufferColorFormat["R5G5B5A1"]=3]="R5G5B5A1";RenderBufferColorFormat[RenderBufferColorFormat["R5G6B5"]=4]="R5G6B5";RenderBufferColorFormat[RenderBufferColorFormat["Alpha8"]=5]="Alpha8";RenderBufferColorFormat[RenderBufferColorFormat["R16G16B16A16"]=6]="R16G16B16A16";RenderBufferColorFormat[RenderBufferColorFormat["R32G32B32A32"]=7]="R32G32B32A32";})(exports.RenderBufferColorFormat||(exports.RenderBufferColorFormat={}));/**
   * Render buffer depth format enumeration.
   */exports.RenderBufferDepthFormat = void 0;(function(RenderBufferDepthFormat){RenderBufferDepthFormat[RenderBufferDepthFormat["Depth"]=0]="Depth";RenderBufferDepthFormat[RenderBufferDepthFormat["DepthStencil"]=1]="DepthStencil";RenderBufferDepthFormat[RenderBufferDepthFormat["Stencil"]=2]="Stencil";RenderBufferDepthFormat[RenderBufferDepthFormat["Depth16"]=3]="Depth16";RenderBufferDepthFormat[RenderBufferDepthFormat["Depth24"]=4]="Depth24";RenderBufferDepthFormat[RenderBufferDepthFormat["Depth32"]=5]="Depth32";RenderBufferDepthFormat[RenderBufferDepthFormat["Depth24Stencil8"]=6]="Depth24Stencil8";RenderBufferDepthFormat[RenderBufferDepthFormat["Depth32Stencil8"]=7]="Depth32Stencil8";})(exports.RenderBufferDepthFormat||(exports.RenderBufferDepthFormat={}));/**
   * Define the face of the cube texture.
   */exports.TextureCubeFace = void 0;(function(TextureCubeFace){TextureCubeFace[TextureCubeFace["PositiveX"]=0]="PositiveX";TextureCubeFace[TextureCubeFace["NegativeX"]=1]="NegativeX";TextureCubeFace[TextureCubeFace["PositiveY"]=2]="PositiveY";TextureCubeFace[TextureCubeFace["NegativeY"]=3]="NegativeY";TextureCubeFace[TextureCubeFace["PositiveZ"]=4]="PositiveZ";TextureCubeFace[TextureCubeFace["NegativeZ"]=5]="NegativeZ";})(exports.TextureCubeFace||(exports.TextureCubeFace={}));/**
   * Cube texture.
   */var TextureCubeMap=/*#__PURE__*/function(_Texture){_inheritsLoose$2(TextureCubeMap,_Texture);/**
     * Create TextureCube.
     * @param engine - Define the engine to use to render this texture
     * @param size - Texture size. texture width must be equal to height in cube texture
     * @param format - Texture format,default TextureFormat.R8G8B8A8
     * @param mipmap - Whether to use multi-level texture
     */function TextureCubeMap(engine,size,format,mipmap){var _this;if(format===void 0){format=exports.TextureFormat.R8G8B8A8;}if(mipmap===void 0){mipmap=true;}_this=_Texture.call(this,engine)||this;_this._format=void 0;_this._mipmap=mipmap;_this._width=size;_this._height=size;_this._format=format;_this._mipmapCount=_this._getMipmapCount();_this._platformTexture=engine._hardwareRenderer.createPlatformTextureCubeMap(_assertThisInitialized$1(_this));_this.filterMode=exports.TextureFilterMode.Bilinear;_this.wrapModeU=_this.wrapModeV=exports.TextureWrapMode.Clamp;return _this;}/**
     * Setting pixels data through cube face,color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
     * @remarks When compressed texture is in WebGL1, the texture must be filled first before writing the sub-region
     * @param face - Cube face
     * @param colorBuffer - Color buffer data
     * @param mipLevel - Texture mipmapping level
     * @param x - X coordinate of area start
     * @param y -  Y coordinate of area start
     * @param width - Data width.if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
     * @param height - Data height.if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
     */var _proto=TextureCubeMap.prototype;_proto.setPixelBuffer=function setPixelBuffer(face,colorBuffer,mipLevel,x,y,width,height){if(mipLevel===void 0){mipLevel=0;}this._platformTexture.setPixelBuffer(face,colorBuffer,mipLevel,x,y,width,height);}/**
     * Setting pixels data through cube face, TexImageSource, designated area and texture mipmapping level.
     * @param face - Cube face
     * @param imageSource - The source of texture
     * @param mipLevel - Texture mipmapping level
     * @param flipY - Whether to flip the Y axis
     * @param premultiplyAlpha - Whether to premultiply the transparent channel
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     */;_proto.setImageSource=function setImageSource(face,imageSource,mipLevel,flipY,premultiplyAlpha,x,y){if(mipLevel===void 0){mipLevel=0;}if(flipY===void 0){flipY=false;}if(premultiplyAlpha===void 0){premultiplyAlpha=false;}this._platformTexture.setImageSource(face,imageSource,mipLevel,flipY,premultiplyAlpha,x,y);}/**
     * Get the pixel color buffer according to the specified cube face and area.
     * @param face - You can choose which cube face to read
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     * @param width - Area width
     * @param height - Area height
     * @param out - Color buffer
     */;_proto.getPixelBuffer=function getPixelBuffer(face,x,y,width,height,out){this._platformTexture.getPixelBuffer(face,x,y,width,height,out);};_createClass$3(TextureCubeMap,[{key:"format",get:/**
       * Texture format.
       */function get(){return this._format;}}]);return TextureCubeMap;}(Texture);/**
   * The texture is used for the output of depth information in off-screen rendering.
   */var RenderDepthTexture=/*#__PURE__*/function(_Texture){_inheritsLoose$2(RenderDepthTexture,_Texture);/**
     * Create RenderDepthTexture.
     * @param engine - Define the engine to use to render this depth texture
     * @param width - Texture width
     * @param height - Texture height
     * @param format - Texture format. default RenderBufferDepthFormat.Depth, engine will automatically select the supported precision
     * @param mipmap - Whether to use multi-level texture
     * @param isCube - Whether it's cube texture
     */function RenderDepthTexture(engine,width,height,format,mipmap,isCube){var _this;if(format===void 0){format=exports.RenderBufferDepthFormat.Depth;}if(mipmap===void 0){mipmap=false;}if(isCube===void 0){isCube=false;}_this=_Texture.call(this,engine)||this;_this._autoMipmap=false;_this._format=void 0;_this._isCube=false;_this._isCube=isCube;_this._mipmap=mipmap;_this._width=width;_this._height=height;_this._format=format;_this._mipmapCount=_this._getMipmapCount();_this._platformTexture=engine._hardwareRenderer.createPlatformRenderDepthTexture(_assertThisInitialized$1(_this));_this.filterMode=exports.TextureFilterMode.Bilinear;_this.wrapModeU=_this.wrapModeV=exports.TextureWrapMode.Clamp;return _this;}_createClass$3(RenderDepthTexture,[{key:"format",get:/**
       * Texture format.
       */function get(){return this._format;}/**
       * Whether to render to a cube texture.
       */},{key:"isCube",get:function get(){return this._isCube;}/**
       * Whether to automatically generate multi-level textures.
       */},{key:"autoGenerateMipmaps",get:function get(){return this._autoMipmap;},set:function set(value){this._autoMipmap=value;}}]);return RenderDepthTexture;}(Texture);/**
   * The render target used for off-screen rendering.
   */var RenderTarget=/*#__PURE__*/function(_EngineObject){_inheritsLoose$2(RenderTarget,_EngineObject);/**
     * @internal
     */function RenderTarget(engine,width,height,renderTexture,depth,antiAliasing){var _this;if(depth===void 0){depth=exports.RenderBufferDepthFormat.Depth;}if(antiAliasing===void 0){antiAliasing=1;}_this=_EngineObject.call(this,engine)||this;_this._platformRenderTarget=void 0;_this._colorTextures=void 0;_this._depth=void 0;_this._antiAliasing=void 0;_this._width=void 0;_this._height=void 0;_this._depthTexture=void 0;_this._width=width;_this._height=height;_this._antiAliasing=antiAliasing;_this._depth=depth;if(renderTexture){_this._colorTextures=renderTexture instanceof Array?renderTexture.slice():[renderTexture];}else {_this._colorTextures=[];}if(depth instanceof RenderDepthTexture){_this._depthTexture=depth;}_this._platformRenderTarget=engine._hardwareRenderer.createPlatformRenderTarget(_assertThisInitialized$1(_this));return _this;}/**
     *
     * Get the render color texture by index.
     * @param index
     */var _proto=RenderTarget.prototype;_proto.getColorTexture=function getColorTexture(index){if(index===void 0){index=0;}return this._colorTextures[index];}/**
     * Generate the mipmap of each attachment texture of the renderTarget according to the configuration.
     */;_proto.generateMipmaps=function generateMipmaps(){var _this$_depthTexture;var colorTextureCount=this.colorTextureCount;if((_this$_depthTexture=this._depthTexture)!==null&&_this$_depthTexture!==void 0&&_this$_depthTexture.autoGenerateMipmaps){this._depthTexture.generateMipmaps();}for(var i=0;i<colorTextureCount;i++){var _colorTexture=this._colorTextures[i];if(_colorTexture.autoGenerateMipmaps){_colorTexture.generateMipmaps();}}}/**
     * Destroy render target.
     */;_proto.destroy=function destroy(){this._platformRenderTarget.destroy();this._colorTextures.length=0;this._depthTexture=null;this._depth=null;}/**
     * @internal
     */;_proto._setRenderTargetFace=function _setRenderTargetFace(faceIndex){this._platformRenderTarget.setRenderTargetFace(faceIndex);}/**
     * @internal
     */;_proto._blitRenderTarget=function _blitRenderTarget(){this._platformRenderTarget.blitRenderTarget();};_createClass$3(RenderTarget,[{key:"width",get:/** @internal */ /** @internal */ /** @internal */ /** @internal */ /**
       * Render target width.
       */function get(){return this._width;}/**
       * Render target height.
       */},{key:"height",get:function get(){return this._height;}/**
       * Render color texture count.
       */},{key:"colorTextureCount",get:function get(){return this._colorTextures.length;}/**
       * Depth texture.
       */},{key:"depthTexture",get:function get(){return this._depthTexture;}/**
       * Anti-aliasing level.
       * @remarks If the anti-aliasing level set is greater than the maximum level supported by the hardware, the maximum level of the hardware will be used.
       */},{key:"antiAliasing",get:function get(){return this._antiAliasing;}/**
       * Create a render target through color texture and depth format.
       * @param engine - Define the engine to use for this off-screen rendering
       * @param width - Render target width
       * @param height - Render target height
       * @param colorTexture - Render color texture
       * @param depthFormat - Depth format. default RenderBufferDepthFormat.Depth, engine will automatically select the supported precision
       * @param antiAliasing - Anti-aliasing level, default is 1
       */}]);return RenderTarget;}(EngineObject);/**
   * The texture is used for the output of color information in off-screen rendering.
   */var RenderColorTexture=/*#__PURE__*/function(_Texture){_inheritsLoose$2(RenderColorTexture,_Texture);/**
     * Create RenderColorTexture.
     * @param engine - Define the engine to use to render this color texture
     * @param width - Texture width
     * @param height - Texture height
     * @param format - Texture format. default RenderBufferColorFormat.R8G8B8A8
     * @param mipmap - Whether to use multi-level texture
     * @param isCube - Whether it's cube texture
     */function RenderColorTexture(engine,width,height,format,mipmap,isCube){var _this;if(format===void 0){format=exports.RenderBufferColorFormat.R8G8B8A8;}if(mipmap===void 0){mipmap=false;}if(isCube===void 0){isCube=false;}_this=_Texture.call(this,engine)||this;_this._autoMipmap=false;_this._format=void 0;_this._isCube=false;_this._isCube=isCube;_this._mipmap=mipmap;_this._width=width;_this._height=height;_this._format=format;_this._mipmapCount=_this._getMipmapCount();_this._platformTexture=engine._hardwareRenderer.createPlatformRenderColorTexture(_assertThisInitialized$1(_this));_this.filterMode=exports.TextureFilterMode.Bilinear;_this.wrapModeU=_this.wrapModeV=exports.TextureWrapMode.Clamp;return _this;}/**
     * Get the pixel color buffer according to the specified cube face and area.
     * @param face - You can choose which cube face to read if it's cube texture
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     * @param width - Area width
     * @param height - Area height
     * @param out - Color buffer
     */var _proto=RenderColorTexture.prototype;_proto.getPixelBuffer=function getPixelBuffer(face,x,y,width,height,out){this._platformTexture.getPixelBuffer(face,x,y,width,height,out);};_createClass$3(RenderColorTexture,[{key:"format",get:/**
       * Texture format.
       */function get(){return this._format;}/**
       * Whether to render to a cube texture.
       */},{key:"isCube",get:function get(){return this._isCube;}/**
       * Whether to automatically generate multi-level textures.
       */},{key:"autoGenerateMipmaps",get:function get(){return this._autoMipmap;},set:function set(value){this._autoMipmap=value;}}]);return RenderColorTexture;}(Texture);/**
   * Mesh containing common vertex elements of the model.
   */var ModelMesh=/*#__PURE__*/function(_Mesh){_inheritsLoose$2(ModelMesh,_Mesh);/**
     * Create a model mesh.
     * @param engine - Engine to which the mesh belongs
     * @param name - Mesh name
     */function ModelMesh(engine,name){var _this;_this=_Mesh.call(this,engine)||this;_this._hasBlendShape=false;_this._useBlendShapeNormal=false;_this._useBlendShapeTangent=false;_this._blendShapeTexture=void 0;_this._vertexCount=0;_this._accessible=true;_this._verticesFloat32=null;_this._verticesUint8=null;_this._indices=null;_this._indicesFormat=null;_this._vertexSlotChanged=true;_this._vertexChangeFlag=0;_this._indicesChangeFlag=false;_this._elementCount=0;_this._vertexElementsCache=[];_this._positions=[];_this._normals=null;_this._colors=null;_this._tangents=null;_this._uv=null;_this._uv1=null;_this._uv2=null;_this._uv3=null;_this._uv4=null;_this._uv5=null;_this._uv6=null;_this._uv7=null;_this._boneWeights=null;_this._boneIndices=null;_this._blendShapes=[];_this._blendShapeUpdateFlags=[];_this.name=name;return _this;}/**
     * Set positions for the mesh.
     * @param positions - The positions for the mesh.
     */var _proto=ModelMesh.prototype;_proto.setPositions=function setPositions(positions){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}var count=positions.length;this._positions=positions;this._vertexChangeFlag|=ValueChanged.Position;if(this._vertexCount!==count){this._vertexCount=count;}}/**
     * Get positions for the mesh.
     * @remarks Please call the setPositions() method after modification to ensure that the modification takes effect.
     */;_proto.getPositions=function getPositions(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}return this._positions;}/**
     * Set per-vertex normals for the mesh.
     * @param normals - The normals for the mesh.
     */;_proto.setNormals=function setNormals(normals){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}if(normals.length!==this._vertexCount){throw "The array provided needs to be the same size as vertex count.";}this._vertexSlotChanged=!!this._normals!==!!normals;this._vertexChangeFlag|=ValueChanged.Normal;this._normals=normals;}/**
     * Get normals for the mesh.
     * @remarks Please call the setNormals() method after modification to ensure that the modification takes effect.
     */;_proto.getNormals=function getNormals(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}return this._normals;}/**
     * Set per-vertex colors for the mesh.
     * @param colors - The colors for the mesh.
     */;_proto.setColors=function setColors(colors){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}if(colors.length!==this._vertexCount){throw "The array provided needs to be the same size as vertex count.";}this._vertexSlotChanged=!!this._colors!==!!colors;this._vertexChangeFlag|=ValueChanged.Color;this._colors=colors;}/**
     * Get colors for the mesh.
     * @remarks Please call the setColors() method after modification to ensure that the modification takes effect.
     */;_proto.getColors=function getColors(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}return this._colors;}/**
     * Set per-vertex bone weights for the mesh.
     * @param boneWeights - The bone weights for the mesh.
     */;_proto.setBoneWeights=function setBoneWeights(boneWeights){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}if(boneWeights.length!==this._vertexCount){throw "The array provided needs to be the same size as vertex count.";}this._vertexSlotChanged=boneWeights!=null;this._vertexChangeFlag|=ValueChanged.BoneWeight;this._boneWeights=boneWeights;}/**
     * Get weights for the mesh.
     * @remarks Please call the setWeights() method after modification to ensure that the modification takes effect.
     */;_proto.getBoneWeights=function getBoneWeights(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}return this._boneWeights;}/**
     * Set per-vertex bone indices for the mesh.
     * @param boneIndices - The bone indices for the mesh.
     */;_proto.setBoneIndices=function setBoneIndices(boneIndices){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}if(boneIndices.length!==this._vertexCount){throw "The array provided needs to be the same size as vertex count.";}this._vertexSlotChanged=!!this._boneIndices!==!!boneIndices;this._vertexChangeFlag|=ValueChanged.BoneIndex;this._boneIndices=boneIndices;}/**
     * Get joints for the mesh.
     * @remarks Please call the setBoneIndices() method after modification to ensure that the modification takes effect.
     */;_proto.getBoneIndices=function getBoneIndices(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}return this._boneIndices;}/**
     * Set per-vertex tangents for the mesh.
     * @param tangents - The tangents for the mesh.
     */;_proto.setTangents=function setTangents(tangents){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}if(tangents.length!==this._vertexCount){throw "The array provided needs to be the same size as vertex count.";}this._vertexSlotChanged=!!this._tangents!==!!tangents;this._vertexChangeFlag|=ValueChanged.Tangent;this._tangents=tangents;}/**
     * Get tangents for the mesh.
     * @remarks Please call the setTangents() method after modification to ensure that the modification takes effect.
     */;_proto.getTangents=function getTangents(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}return this._tangents;}/**
     * Set per-vertex uv for the mesh.
     * @param uv - The uv for the mesh.
     */;_proto.setUVs=function setUVs(uv,channelIndex){var _channelIndex;if(!this._accessible){throw "Not allowed to access data while accessible is false.";}if(uv.length!==this._vertexCount){throw "The array provided needs to be the same size as vertex count.";}channelIndex=(_channelIndex=channelIndex)!=null?_channelIndex:0;switch(channelIndex){case 0:this._vertexSlotChanged=!!this._uv!==!!uv;this._vertexChangeFlag|=ValueChanged.UV;this._uv=uv;break;case 1:this._vertexSlotChanged=!!this._uv1!==!!uv;this._vertexChangeFlag|=ValueChanged.UV1;this._uv1=uv;break;case 2:this._vertexSlotChanged=!!this._uv2!==!!uv;this._vertexChangeFlag|=ValueChanged.UV2;this._uv2=uv;break;case 3:this._vertexSlotChanged=!!this._uv3!==!!uv;this._vertexChangeFlag|=ValueChanged.UV3;this._uv3=uv;break;case 4:this._vertexSlotChanged=!!this._uv4!==!!uv;this._vertexChangeFlag|=ValueChanged.UV4;this._uv4=uv;break;case 5:this._vertexSlotChanged=!!this._uv5!==!!uv;this._vertexChangeFlag|=ValueChanged.UV5;this._uv5=uv;break;case 6:this._vertexSlotChanged=!!this._uv6!==!!uv;this._vertexChangeFlag|=ValueChanged.UV6;this._uv6=uv;break;case 7:this._vertexSlotChanged=!!this._uv7!==!!uv;this._vertexChangeFlag|=ValueChanged.UV7;this._uv7=uv;break;default:throw "The index of channel needs to be in range [0 - 7].";}}/**
     * Get uv for the mesh.
     * @remarks Please call the setUV() method after modification to ensure that the modification takes effect.
     */;_proto.getUVs=function getUVs(channelIndex){var _channelIndex2;if(!this._accessible){throw "Not allowed to access data while accessible is false.";}channelIndex=(_channelIndex2=channelIndex)!=null?_channelIndex2:0;switch(channelIndex){case 0:return this._uv;case 1:return this._uv1;case 2:return this._uv2;case 3:return this._uv3;case 4:return this._uv4;case 5:return this._uv5;case 6:return this._uv6;case 7:return this._uv7;}throw "The index of channel needs to be in range [0 - 7].";}/**
     * Set indices for the mesh.
     * @param indices - The indices for the mesh.
     */;_proto.setIndices=function setIndices(indices){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}if(this._indices!==indices){this._indices=indices;if(indices instanceof Uint8Array){this._indicesFormat=exports.IndexFormat.UInt8;}else if(indices instanceof Uint16Array){this._indicesFormat=exports.IndexFormat.UInt16;}else if(indices instanceof Uint32Array){this._indicesFormat=exports.IndexFormat.UInt32;}}this._indicesChangeFlag=true;}/**
     * Get indices for the mesh.
     */;_proto.getIndices=function getIndices(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}return this._indices;}/**
     * Add a BlendShape for this ModelMesh.
     * @param blendShape - The BlendShape
     */;_proto.addBlendShape=function addBlendShape(blendShape){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}this._vertexChangeFlag|=ValueChanged.BlendShape;this._useBlendShapeNormal=this._useBlendShapeNormal||blendShape._useBlendShapeNormal;this._useBlendShapeTangent=this._useBlendShapeTangent||blendShape._useBlendShapeTangent;this._blendShapes.push(blendShape);this._blendShapeUpdateFlags.push(blendShape._registerChangeFlag());this._hasBlendShape=true;}/**
     * Clear all BlendShapes.
     */;_proto.clearBlendShapes=function clearBlendShapes(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}this._vertexChangeFlag|=ValueChanged.BlendShape;this._useBlendShapeNormal=false;this._useBlendShapeTangent=false;this._blendShapes.length=0;var blendShapeUpdateFlags=this._blendShapeUpdateFlags;for(var i=0,n=blendShapeUpdateFlags.length;i<n;i++){blendShapeUpdateFlags[i].destroy();}blendShapeUpdateFlags.length=0;this._hasBlendShape=false;}/**
     * Upload Mesh Data to the graphics API.
     * @param noLongerAccessible - Whether to access data later. If true, you'll never access data anymore (free memory cache)
     */;_proto.uploadData=function uploadData(noLongerAccessible){var _vertexBufferBindings,_this$_indexBufferBin;if(!this._accessible){throw "Not allowed to access data while accessible is false.";}var _indices=this._indices;// Vertex element change.
  if(this._vertexSlotChanged){var vertexElements=this._updateVertexElements();this._setVertexElements(vertexElements);this._vertexChangeFlag=ValueChanged.All;this._vertexSlotChanged=false;}// Vertex value change.
  var vertexBufferBindings=this._vertexBufferBindings;var elementCount=this._elementCount;var vertexBuffer=(_vertexBufferBindings=vertexBufferBindings[0])===null||_vertexBufferBindings===void 0?void 0:_vertexBufferBindings._buffer;var vertexFloatCount=elementCount*this._vertexCount;if(!vertexBuffer||this._verticesFloat32.length!==vertexFloatCount){vertexBuffer===null||vertexBuffer===void 0?void 0:vertexBuffer.destroy();var vertices=new Float32Array(vertexFloatCount);this._verticesFloat32=vertices;this._verticesUint8=new Uint8Array(vertices.buffer);this._vertexChangeFlag=ValueChanged.All;this._updateVertices(vertices);var newVertexBuffer=new Buffer(this._engine,exports.BufferBindFlag.VertexBuffer,vertices,noLongerAccessible?exports.BufferUsage.Static:exports.BufferUsage.Dynamic);this._setVertexBufferBinding(0,new VertexBufferBinding(newVertexBuffer,elementCount*4));}else if(this._vertexChangeFlag&ValueChanged.All){var _vertices=this._verticesFloat32;this._updateVertices(_vertices);vertexBuffer.setData(_vertices);}var indexBuffer=(_this$_indexBufferBin=this._indexBufferBinding)===null||_this$_indexBufferBin===void 0?void 0:_this$_indexBufferBin._buffer;if(_indices){if(!indexBuffer||_indices.byteLength!=indexBuffer.byteLength){indexBuffer===null||indexBuffer===void 0?void 0:indexBuffer.destroy();var newIndexBuffer=new Buffer(this._engine,exports.BufferBindFlag.IndexBuffer,_indices);this._setIndexBufferBinding(new IndexBufferBinding(newIndexBuffer,this._indicesFormat));}else if(this._indicesChangeFlag){this._indicesChangeFlag=false;indexBuffer.setData(_indices);if(this._indexBufferBinding._format!==this._indicesFormat){this._setIndexBufferBinding(new IndexBufferBinding(indexBuffer,this._indicesFormat));}}}else if(indexBuffer){indexBuffer.destroy();this._setIndexBufferBinding(null);}if(noLongerAccessible){this._accessible=false;this._releaseCache();}}/**
     * @override
     * @internal
     */;_proto._onDestroy=function _onDestroy(){_Mesh.prototype._onDestroy.call(this);this._accessible&&this._releaseCache();};_proto._updateVertexElements=function _updateVertexElements(){var vertexElements=this._vertexElementsCache;vertexElements.length=1;vertexElements[0]=POSITION_VERTEX_ELEMENT;var offset=12;var elementCount=3;if(this._normals){vertexElements.push(new VertexElement("NORMAL",offset,exports.VertexElementFormat.Vector3,0));offset+=12;elementCount+=3;}if(this._colors){vertexElements.push(new VertexElement("COLOR_0",offset,exports.VertexElementFormat.Vector4,0));offset+=16;elementCount+=4;}if(this._boneWeights){vertexElements.push(new VertexElement("WEIGHTS_0",offset,exports.VertexElementFormat.Vector4,0));offset+=16;elementCount+=4;}if(this._boneIndices){vertexElements.push(new VertexElement("JOINTS_0",offset,exports.VertexElementFormat.UByte4,0));offset+=4;elementCount+=1;}if(this._tangents){vertexElements.push(new VertexElement("TANGENT",offset,exports.VertexElementFormat.Vector4,0));offset+=16;elementCount+=4;}if(this._uv){vertexElements.push(new VertexElement("TEXCOORD_0",offset,exports.VertexElementFormat.Vector2,0));offset+=8;elementCount+=2;}if(this._uv1){vertexElements.push(new VertexElement("TEXCOORD_1",offset,exports.VertexElementFormat.Vector2,0));offset+=8;elementCount+=2;}if(this._uv2){vertexElements.push(new VertexElement("TEXCOORD_2",offset,exports.VertexElementFormat.Vector2,0));offset+=8;elementCount+=2;}if(this._uv3){vertexElements.push(new VertexElement("TEXCOORD_3",offset,exports.VertexElementFormat.Vector2,0));offset+=8;elementCount+=2;}if(this._uv4){vertexElements.push(new VertexElement("TEXCOORD_4",offset,exports.VertexElementFormat.Vector2,0));offset+=8;elementCount+=2;}if(this._uv5){vertexElements.push(new VertexElement("TEXCOORD_5",offset,exports.VertexElementFormat.Vector2,0));offset+=8;elementCount+=2;}if(this._uv6){vertexElements.push(new VertexElement("TEXCOORD_6",offset,exports.VertexElementFormat.Vector2,0));offset+=8;elementCount+=2;}if(this._uv7){vertexElements.push(new VertexElement("TEXCOORD_7",offset,exports.VertexElementFormat.Vector2,0));offset+=8;elementCount+=2;}var blendShapeCount=Math.min(this._blendShapes.length,4);for(var i=0,n=blendShapeCount;i<n;i++){vertexElements.push(new VertexElement("POSITION_BS"+i,offset,exports.VertexElementFormat.Vector3,0));offset+=12;elementCount+=3;if(this._useBlendShapeNormal){vertexElements.push(new VertexElement("NORMAL_BS"+i,offset,exports.VertexElementFormat.Vector3,0));offset+=12;elementCount+=3;}if(this._useBlendShapeTangent){vertexElements.push(new VertexElement("TANGENT_BS"+i,offset,exports.VertexElementFormat.Vector3,0));offset+=12;elementCount+=3;}}this._elementCount=elementCount;return vertexElements;};_proto._updateVertices=function _updateVertices(vertices){// prettier-ignore
  var _elementCount=this._elementCount,_vertexCount=this._vertexCount,_positions=this._positions,_normals=this._normals,_colors=this._colors,_vertexChangeFlag=this._vertexChangeFlag,_boneWeights=this._boneWeights,_boneIndices=this._boneIndices,_tangents=this._tangents,_uv=this._uv,_uv1=this._uv1,_uv2=this._uv2,_uv3=this._uv3,_uv4=this._uv4,_uv5=this._uv5,_uv6=this._uv6,_uv7=this._uv7;if(_vertexChangeFlag&ValueChanged.Position){for(var i=0;i<_vertexCount;i++){var start=_elementCount*i;var position=_positions[i];vertices[start]=position.x;vertices[start+1]=position.y;vertices[start+2]=position.z;}}var offset=3;if(_normals){if(_vertexChangeFlag&ValueChanged.Normal){for(var _i=0;_i<_vertexCount;_i++){var _start=_elementCount*_i+offset;var normal=_normals[_i];if(normal){vertices[_start]=normal.x;vertices[_start+1]=normal.y;vertices[_start+2]=normal.z;}}}offset+=3;}if(_colors){if(_vertexChangeFlag&ValueChanged.Color){for(var _i2=0;_i2<_vertexCount;_i2++){var _start2=_elementCount*_i2+offset;var color=_colors[_i2];if(color){vertices[_start2]=color.r;vertices[_start2+1]=color.g;vertices[_start2+2]=color.b;vertices[_start2+3]=color.a;}}}offset+=4;}if(_boneWeights){if(_vertexChangeFlag&ValueChanged.BoneWeight){for(var _i3=0;_i3<_vertexCount;_i3++){var _start3=_elementCount*_i3+offset;var weight=_boneWeights[_i3];if(weight){vertices[_start3]=weight.x;vertices[_start3+1]=weight.y;vertices[_start3+2]=weight.z;vertices[_start3+3]=weight.w;}}}offset+=4;}if(_boneIndices){if(_vertexChangeFlag&ValueChanged.BoneIndex){var _verticesUint8=this._verticesUint8;for(var _i4=0;_i4<_vertexCount;_i4++){var _start4=_elementCount*_i4+offset;var joint=_boneIndices[_i4];if(joint){var internalStart=_start4*4;_verticesUint8[internalStart]=joint.x;_verticesUint8[internalStart+1]=joint.y;_verticesUint8[internalStart+2]=joint.z;_verticesUint8[internalStart+3]=joint.w;}}}offset+=1;}if(_tangents){if(_vertexChangeFlag&ValueChanged.Tangent){for(var _i5=0;_i5<_vertexCount;_i5++){var _start5=_elementCount*_i5+offset;var tangent=_tangents[_i5];if(tangent){vertices[_start5]=tangent.x;vertices[_start5+1]=tangent.y;vertices[_start5+2]=tangent.z;}}}offset+=4;}if(_uv){if(_vertexChangeFlag&ValueChanged.UV){for(var _i6=0;_i6<_vertexCount;_i6++){var _start6=_elementCount*_i6+offset;var _uv8=_uv[_i6];if(_uv8){vertices[_start6]=_uv8.x;vertices[_start6+1]=_uv8.y;}}}offset+=2;}if(_uv1){if(_vertexChangeFlag&ValueChanged.UV1){for(var _i7=0;_i7<_vertexCount;_i7++){var _start7=_elementCount*_i7+offset;var _uv9=_uv1[_i7];if(_uv9){vertices[_start7]=_uv9.x;vertices[_start7+1]=_uv9.y;}}}offset+=2;}if(_uv2){if(_vertexChangeFlag&ValueChanged.UV2){for(var _i8=0;_i8<_vertexCount;_i8++){var _start8=_elementCount*_i8+offset;var _uv10=_uv2[_i8];if(_uv10){vertices[_start8]=_uv10.x;vertices[_start8+1]=_uv10.y;}}}offset+=2;}if(_uv3){if(_vertexChangeFlag&ValueChanged.UV3){for(var _i9=0;_i9<_vertexCount;_i9++){var _start9=_elementCount*_i9+offset;var _uv11=_uv3[_i9];if(_uv11){vertices[_start9]=_uv11.x;vertices[_start9+1]=_uv11.y;}}}offset+=2;}if(_uv4){if(_vertexChangeFlag&ValueChanged.UV4){for(var _i10=0;_i10<_vertexCount;_i10++){var _start10=_elementCount*_i10+offset;var _uv12=_uv4[_i10];if(_uv12){vertices[_start10]=_uv12.x;vertices[_start10+1]=_uv12.y;}}}offset+=2;}if(_uv5){if(_vertexChangeFlag&ValueChanged.UV5){for(var _i11=0;_i11<_vertexCount;_i11++){var _start11=_elementCount*_i11+offset;var _uv13=_uv5[_i11];if(_uv13){vertices[_start11]=_uv13.x;vertices[_start11+1]=_uv13.y;}}}offset+=2;}if(_uv6){if(_vertexChangeFlag&ValueChanged.UV6){for(var _i12=0;_i12<_vertexCount;_i12++){var _start12=_elementCount*_i12+offset;var _uv14=_uv6[_i12];if(_uv14){vertices[_start12]=_uv14.x;vertices[_start12+1]=_uv14.y;}}}offset+=2;}if(_uv7){if(_vertexChangeFlag&ValueChanged.UV7){for(var _i13=0;_i13<_vertexCount;_i13++){var _start13=_elementCount*_i13+offset;var _uv15=_uv7[_i13];if(_uv15){vertices[_start13]=_uv15.x;vertices[_start13+1]=_uv15.y;}}}offset+=2;}// BlendShape.
  if(_vertexChangeFlag&ValueChanged.BlendShape){var blendShapes=this._blendShapes;var blendShapeUpdateFlags=this._blendShapeUpdateFlags;var blendShapeCount=Math.min(blendShapes.length,4);this.engine._hardwareRenderer;{for(var _i14=0;_i14<blendShapeCount;_i14++){var blendShapeUpdateFlag=blendShapeUpdateFlags[_i14];if(blendShapeUpdateFlag.flag){var blendShape=blendShapes[_i14];var frames=blendShape.frames;var frameCount=frames.length;var endFrame=frames[frameCount-1];if(frameCount>0&&endFrame.deltaPositions.length!==this._vertexCount){throw "BlendShape frame deltaPositions length must same with mesh vertexCount.";}var deltaPositions=endFrame.deltaPositions;for(var j=0;j<_vertexCount;j++){var _start14=_elementCount*j+offset;var deltaPosition=deltaPositions[j];if(deltaPosition){vertices[_start14]=deltaPosition.x;vertices[_start14+1]=deltaPosition.y;vertices[_start14+2]=deltaPosition.z;}}offset+=3;if(this._useBlendShapeNormal){var deltaNormals=endFrame.deltaNormals;if(deltaNormals){for(var _j=0;_j<_vertexCount;_j++){var _start15=_elementCount*_j+offset;var deltaNormal=deltaNormals[_j];if(deltaNormal){vertices[_start15]=deltaNormal.x;vertices[_start15+1]=deltaNormal.y;vertices[_start15+2]=deltaNormal.z;}}}offset+=3;}if(this._useBlendShapeTangent){var deltaTangents=endFrame.deltaTangents;if(deltaTangents){for(var _j2=0;_j2<_vertexCount;_j2++){var _start16=_elementCount*_j2+offset;var deltaTangent=deltaTangents[_j2];if(deltaTangent){vertices[_start16]=deltaTangent.x;vertices[_start16+1]=deltaTangent.y;vertices[_start16+2]=deltaTangent.z;}}}offset+=3;}blendShapeUpdateFlag.flag=false;}}}}this._vertexChangeFlag=0;};_proto._releaseCache=function _releaseCache(){var blendShapeUpdateFlags=this._blendShapeUpdateFlags;for(var i=0,n=blendShapeUpdateFlags.length;i<n;i++){blendShapeUpdateFlags[i].destroy();}this._verticesUint8=null;this._indices=null;this._verticesFloat32=null;this._positions.length=0;this._tangents=null;this._normals=null;this._colors=null;this._uv=null;this._uv1=null;this._uv2=null;this._uv3=null;this._uv4=null;this._uv5=null;this._uv6=null;this._uv7=null;this._blendShapes=null;this._blendShapeUpdateFlags=null;};_createClass$3(ModelMesh,[{key:"accessible",get:/** @internal */ /** @internal */ /** @internal */ /** @internal */ /**
       * Whether to access data of the mesh.
       */function get(){return this._accessible;}/**
       * Vertex count of current mesh.
       */},{key:"vertexCount",get:function get(){return this._vertexCount;}/**
       * BlendShape count of this ModelMesh.
       */},{key:"blendShapes",get:function get(){if(!this._accessible){throw "Not allowed to access data while accessible is false.";}return this._blendShapes;}}]);return ModelMesh;}(Mesh);var POSITION_VERTEX_ELEMENT=new VertexElement("POSITION",0,exports.VertexElementFormat.Vector3,0);var ValueChanged;(function(ValueChanged){ValueChanged[ValueChanged["Position"]=1]="Position";ValueChanged[ValueChanged["Normal"]=2]="Normal";ValueChanged[ValueChanged["Color"]=4]="Color";ValueChanged[ValueChanged["Tangent"]=8]="Tangent";ValueChanged[ValueChanged["BoneWeight"]=16]="BoneWeight";ValueChanged[ValueChanged["BoneIndex"]=32]="BoneIndex";ValueChanged[ValueChanged["UV"]=64]="UV";ValueChanged[ValueChanged["UV1"]=128]="UV1";ValueChanged[ValueChanged["UV2"]=256]="UV2";ValueChanged[ValueChanged["UV3"]=512]="UV3";ValueChanged[ValueChanged["UV4"]=1024]="UV4";ValueChanged[ValueChanged["UV5"]=2048]="UV5";ValueChanged[ValueChanged["UV6"]=4096]="UV6";ValueChanged[ValueChanged["UV7"]=8192]="UV7";ValueChanged[ValueChanged["BlendShape"]=16384]="BlendShape";ValueChanged[ValueChanged["All"]=65535]="All";})(ValueChanged||(ValueChanged={}));/**
   * Mesh skin data, equal glTF skins define
   */var Skin=/*#__PURE__*/function(_EngineObject){_inheritsLoose$2(Skin,_EngineObject);/**
     * Constructor of skin
     * @param name - name
     */function Skin(name){var _this;_this=_EngineObject.call(this,null)||this;_this.name=name;_this.inverseBindMatrices=void 0;_this.joints=void 0;_this.skeleton=void 0;_this.inverseBindMatrices=[];// inverse bind matrix array
  _this.joints=[];// joints name array, element type: string
  _this.skeleton="none";// root bone name
  return _this;}return Skin;}(EngineObject);var _class$5$1,_descriptor$5,_descriptor2$5,_class2$4,_temp$4;/**
   * MeshRenderer Component.
   */var MeshRenderer=(_class$5$1=(_temp$4=_class2$4=/*#__PURE__*/function(_Renderer){_inheritsLoose$2(MeshRenderer,_Renderer);/**
     * @internal
     */function MeshRenderer(entity){var _this;_this=_Renderer.call(this,entity)||this;_initializerDefineProperty(_this,"_mesh",_descriptor$5,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_meshUpdateFlag",_descriptor2$5,_assertThisInitialized$1(_this));return _this;}/**
     * Mesh assigned to the renderer.
     */var _proto=MeshRenderer.prototype;/**
     * @internal
     */_proto._render=function _render(camera){var mesh=this._mesh;if(mesh){if(this._meshUpdateFlag.flag){var shaderData=this.shaderData;var vertexElements=mesh._vertexElements;shaderData.disableMacro(MeshRenderer._uvMacro);shaderData.disableMacro(MeshRenderer._normalMacro);shaderData.disableMacro(MeshRenderer._tangentMacro);shaderData.disableMacro(MeshRenderer._vertexColorMacro);for(var i=0,n=vertexElements.length;i<n;i++){var semantic=vertexElements[i].semantic;switch(semantic){case"TEXCOORD_0":shaderData.enableMacro(MeshRenderer._uvMacro);break;case"NORMAL":shaderData.enableMacro(MeshRenderer._normalMacro);break;case"TANGENT":shaderData.enableMacro(MeshRenderer._tangentMacro);break;case"COLOR_0":shaderData.enableMacro(MeshRenderer._vertexColorMacro);break;}}this._meshUpdateFlag.flag=false;}var subMeshes=mesh.subMeshes;var renderPipeline=camera._renderPipeline;var renderElementPool=this._engine._renderElementPool;for(var _i=0,_n=subMeshes.length;_i<_n;_i++){var material=this._materials[_i];if(material){var element=renderElementPool.getFromPool();element.setValue(this,mesh,subMeshes[_i],material);renderPipeline.pushPrimitive(element);}}}else {Logger.error("mesh is null.");}}/**
     * @internal
     * @override
     */;_proto._onDestroy=function _onDestroy(){_Renderer.prototype._onDestroy.call(this);var mesh=this._mesh;if(mesh&&!mesh.destroyed){mesh._addRefCount(-1);this._mesh=null;}}/**
     * @internal
     */;_proto._cloneTo=function _cloneTo(target){target.mesh=this._mesh;}/**
     * @override
     */;_proto._updateBounds=function _updateBounds(worldBounds){var mesh=this._mesh;if(mesh){var localBounds=mesh.bounds;var worldMatrix=this._entity.transform.worldMatrix;BoundingBox.transform(localBounds,worldMatrix,worldBounds);}else {worldBounds.min.setValue(0,0,0);worldBounds.max.setValue(0,0,0);}};_createClass$3(MeshRenderer,[{key:"mesh",get:function get(){return this._mesh;},set:function set(mesh){var lastMesh=this._mesh;if(lastMesh!==mesh){if(lastMesh){lastMesh._addRefCount(-1);this._meshUpdateFlag.destroy();}if(mesh){mesh._addRefCount(1);this._meshUpdateFlag=mesh.registerUpdateFlag();}this._mesh=mesh;}}}]);return MeshRenderer;}(Renderer),_class2$4._uvMacro=Shader.getMacroByName("O3_HAS_UV"),_class2$4._normalMacro=Shader.getMacroByName("O3_HAS_NORMAL"),_class2$4._tangentMacro=Shader.getMacroByName("O3_HAS_TANGENT"),_class2$4._vertexColorMacro=Shader.getMacroByName("O3_HAS_VERTEXCOLOR"),_temp$4),(_descriptor$5=_applyDecoratedDescriptor$1(_class$5$1.prototype,"_mesh",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor2$5=_applyDecoratedDescriptor$1(_class$5$1.prototype,"_meshUpdateFlag",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null})),_class$5$1);var _class$4$1,_descriptor$4,_descriptor2$4,_descriptor3$4,_descriptor4$4,_descriptor5$4,_descriptor6$4,_class2$3,_temp$3;/**
   * SkinnedMeshRenderer.
   */var SkinnedMeshRenderer=(_class$4$1=(_temp$3=_class2$3=/*#__PURE__*/function(_MeshRenderer){_inheritsLoose$2(SkinnedMeshRenderer,_MeshRenderer);/**
     * Constructor of SkinnedMeshRenderer
     * @param entity - Entity
     */function SkinnedMeshRenderer(entity){var _this;_this=_MeshRenderer.call(this,entity)||this;_initializerDefineProperty(_this,"matrixPalette",_descriptor$4,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"jointNodes",_descriptor2$4,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"jointTexture",_descriptor3$4,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_hasInitJoints",_descriptor4$4,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_mat",_descriptor5$4,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_useJointTexture",_descriptor6$4,_assertThisInitialized$1(_this));_this._skin=void 0;_this._blendShapeWeights=void 0;_this._mat=new Matrix();_this._skin=null;return _this;}/**
     * @internal
     */var _proto=SkinnedMeshRenderer.prototype;_proto._updateShaderData=function _updateShaderData(context){_MeshRenderer.prototype._updateShaderData.call(this,context);var shaderData=this.shaderData;if(!this._useJointTexture&&this.matrixPalette){shaderData.setFloatArray(SkinnedMeshRenderer._jointMatrixProperty,this.matrixPalette);}var mesh=this.mesh;if(mesh._hasBlendShape){shaderData.setFloatArray(SkinnedMeshRenderer._blendShapeWeightsProperty,this._blendShapeWeights);shaderData.enableMacro(SkinnedMeshRenderer._blendShapeMacro);if(mesh._useBlendShapeNormal){shaderData.enableMacro(SkinnedMeshRenderer._blendShapeNormalMacro);}else {shaderData.disableMacro(SkinnedMeshRenderer._blendShapeNormalMacro);}if(mesh._useBlendShapeTangent){shaderData.enableMacro(SkinnedMeshRenderer._blendShapeTangentMacro);}else {shaderData.disableMacro(SkinnedMeshRenderer._blendShapeTangentMacro);}}else {shaderData.disableMacro(SkinnedMeshRenderer._blendShapeMacro);}}/**
     * Skin Object.
     */;_proto._initJoints=function _initJoints(){var _this$jointNodes;if(!this._skin)return;var skin=this._skin;var joints=skin.joints;var jointNodes=[];for(var i=joints.length-1;i>=0;i--){jointNodes[i]=this.findByNodeName(this.entity,joints[i]);}// end of for
  this.matrixPalette=new Float32Array(jointNodes.length*16);this.jointNodes=jointNodes;/** Whether to use a skeleton texture */var rhi=this.entity.engine._hardwareRenderer;if(!rhi)return;var maxAttribUniformVec4=rhi.renderStates.getParameter(rhi.gl.MAX_VERTEX_UNIFORM_VECTORS);var maxJoints=Math.floor((maxAttribUniformVec4-20)/4);var shaderData=this.shaderData;var jointCount=(_this$jointNodes=this.jointNodes)===null||_this$jointNodes===void 0?void 0:_this$jointNodes.length;if(jointCount){shaderData.enableMacro("O3_HAS_SKIN");shaderData.setInt(SkinnedMeshRenderer._jointCountProperty,jointCount);if(joints.length>maxJoints){if(rhi.canIUseMoreJoints){this._useJointTexture=true;}else {Logger.error("component's joints count("+joints+") greater than device's MAX_VERTEX_UNIFORM_VECTORS number "+maxAttribUniformVec4+", and don't support jointTexture in this device. suggest joint count less than "+maxJoints+".",this);}}else {var _maxJoints=Math.max(SkinnedMeshRenderer._maxJoints,joints.length);SkinnedMeshRenderer._maxJoints=_maxJoints;shaderData.disableMacro("O3_USE_JOINT_TEXTURE");shaderData.enableMacro("O3_JOINTS_NUM",_maxJoints.toString());}}else {shaderData.disableMacro("O3_HAS_SKIN");}};_proto.findByNodeName=function findByNodeName(entity,nodeName){if(!entity)return null;var n=entity.findByName(nodeName);if(n)return n;return this.findByNodeName(entity.parent,nodeName);}/**
     * @internal
     */;_proto.update=function update(){if(!this._hasInitJoints){this._initJoints();this._hasInitJoints=true;}if(this._skin){var joints=this.jointNodes;var ibms=this._skin.inverseBindMatrices;var matrixPalette=this.matrixPalette;var worldToLocal=this.entity.getInvModelMatrix();var mat=this._mat;for(var i=joints.length-1;i>=0;i--){mat.identity();if(joints[i]){Matrix.multiply(joints[i].transform.worldMatrix,ibms[i],mat);}else {ibms[i].cloneTo(mat);}Matrix.multiply(worldToLocal,mat,mat);matrixPalette.set(mat.elements,i*16);}if(this._useJointTexture){this.createJointTexture();}}}/**
     * Generate joint texture.
     * Format: (4 * RGBA) * jointCont
     */;_proto.createJointTexture=function createJointTexture(){if(!this.jointTexture){var engine=this.engine;var rhi=engine._hardwareRenderer;if(!rhi)return;this.jointTexture=new Texture2D(engine,4,this.jointNodes.length,exports.TextureFormat.R32G32B32A32,false);this.jointTexture.filterMode=exports.TextureFilterMode.Point;this.shaderData.enableMacro("O3_USE_JOINT_TEXTURE");this.shaderData.setTexture(SkinnedMeshRenderer._jointSamplerProperty,this.jointTexture);}this.jointTexture.setPixelBuffer(this.matrixPalette);};_createClass$3(SkinnedMeshRenderer,[{key:"blendShapeWeights",get:/**
       * The weights of the BlendShapes.
       * @remarks Array index is BlendShape index.
       */function get(){return this._blendShapeWeights;},set:function set(value){this._blendShapeWeights=value;}},{key:"skin",get:function get(){return this._skin;},set:function set(skin){this._skin=skin;}}]);return SkinnedMeshRenderer;}(MeshRenderer),_class2$3._blendShapeMacro=Shader.getMacroByName("OASIS_BLENDSHAPE"),_class2$3._blendShapeNormalMacro=Shader.getMacroByName("OASIS_BLENDSHAPE_NORMAL"),_class2$3._blendShapeTangentMacro=Shader.getMacroByName("OASIS_BLENDSHAPE_TANGENT"),_class2$3._jointCountProperty=Shader.getPropertyByName("u_jointCount"),_class2$3._jointSamplerProperty=Shader.getPropertyByName("u_jointSampler"),_class2$3._jointMatrixProperty=Shader.getPropertyByName("u_jointMatrix"),_class2$3._blendShapeWeightsProperty=Shader.getPropertyByName("u_blendShapeWeights"),_class2$3._maxJoints=0,_temp$3),(_descriptor$4=_applyDecoratedDescriptor$1(_class$4$1.prototype,"matrixPalette",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor2$4=_applyDecoratedDescriptor$1(_class$4$1.prototype,"jointNodes",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor3$4=_applyDecoratedDescriptor$1(_class$4$1.prototype,"jointTexture",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor4$4=_applyDecoratedDescriptor$1(_class$4$1.prototype,"_hasInitJoints",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor5$4=_applyDecoratedDescriptor$1(_class$4$1.prototype,"_mat",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor6$4=_applyDecoratedDescriptor$1(_class$4$1.prototype,"_useJointTexture",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}})),_class$4$1);/**
   * Used to generate common primitive meshes.
   */var PrimitiveMesh=/*#__PURE__*/function(){function PrimitiveMesh(){}/**
     * Create a sphere mesh.
     * @param engine - Engine
     * @param radius - Sphere radius
     * @param segments - Number of segments
     * @param noLongerAccessible - No longer access the vertices of the mesh after creation
     * @returns Sphere model mesh
     */PrimitiveMesh.createSphere=function createSphere(engine,radius,segments,noLongerAccessible){if(radius===void 0){radius=0.5;}if(segments===void 0){segments=18;}if(noLongerAccessible===void 0){noLongerAccessible=true;}var mesh=new ModelMesh(engine);segments=Math.max(2,Math.floor(segments));var count=segments+1;var vertexCount=count*count;var rectangleCount=segments*segments;var indices=PrimitiveMesh._generateIndices(engine,vertexCount,rectangleCount*6);var thetaRange=Math.PI;var alphaRange=thetaRange*2;var countReciprocal=1.0/count;var segmentsReciprocal=1.0/segments;var positions=new Array(vertexCount);var normals=new Array(vertexCount);var uvs=new Array(vertexCount);for(var i=0;i<vertexCount;++i){var x=i%count;var y=i*countReciprocal|0;var u=x*segmentsReciprocal;var v=y*segmentsReciprocal;var alphaDelta=u*alphaRange;var thetaDelta=v*thetaRange;var sinTheta=Math.sin(thetaDelta);var posX=-radius*Math.cos(alphaDelta)*sinTheta;var posY=radius*Math.cos(thetaDelta);var posZ=radius*Math.sin(alphaDelta)*sinTheta;// Position
  positions[i]=new Vector3(posX,posY,posZ);// Normal
  normals[i]=new Vector3(posX,posY,posZ);// Texcoord
  uvs[i]=new Vector2(u,v);}var offset=0;for(var _i=0;_i<rectangleCount;++_i){var _x=_i%segments;var _y=_i*segmentsReciprocal|0;var a=_y*count+_x;var b=a+1;var c=a+count;var d=c+1;indices[offset++]=b;indices[offset++]=a;indices[offset++]=d;indices[offset++]=a;indices[offset++]=c;indices[offset++]=d;}var bounds=mesh.bounds;bounds.min.setValue(-radius,-radius,-radius);bounds.max.setValue(radius,radius,radius);PrimitiveMesh._initialize(mesh,positions,normals,uvs,indices,noLongerAccessible);return mesh;}/**
     * Create a cuboid mesh.
     * @param engine - Engine
     * @param width - Cuboid width
     * @param height - Cuboid height
     * @param depth - Cuboid depth
     * @param noLongerAccessible - No longer access the vertices of the mesh after creation
     * @returns Cuboid model mesh
     */;PrimitiveMesh.createCuboid=function createCuboid(engine,width,height,depth,noLongerAccessible){if(width===void 0){width=1;}if(height===void 0){height=1;}if(depth===void 0){depth=1;}if(noLongerAccessible===void 0){noLongerAccessible=true;}var mesh=new ModelMesh(engine);var halfWidth=width/2;var halfHeight=height/2;var halfDepth=depth/2;var positions=new Array(24);var normals=new Array(24);var uvs=new Array(24);// Up
  positions[0]=new Vector3(-halfWidth,halfHeight,-halfDepth);positions[1]=new Vector3(halfWidth,halfHeight,-halfDepth);positions[2]=new Vector3(halfWidth,halfHeight,halfDepth);positions[3]=new Vector3(-halfWidth,halfHeight,halfDepth);normals[0]=new Vector3(0,1,0);normals[1]=new Vector3(0,1,0);normals[2]=new Vector3(0,1,0);normals[3]=new Vector3(0,1,0);uvs[0]=new Vector2(0,0);uvs[1]=new Vector2(1,0);uvs[2]=new Vector2(1,1);uvs[3]=new Vector2(0,1);// Down
  positions[4]=new Vector3(-halfWidth,-halfHeight,-halfDepth);positions[5]=new Vector3(halfWidth,-halfHeight,-halfDepth);positions[6]=new Vector3(halfWidth,-halfHeight,halfDepth);positions[7]=new Vector3(-halfWidth,-halfHeight,halfDepth);normals[4]=new Vector3(0,-1,0);normals[5]=new Vector3(0,-1,0);normals[6]=new Vector3(0,-1,0);normals[7]=new Vector3(0,-1,0);uvs[4]=new Vector2(0,1);uvs[5]=new Vector2(1,1);uvs[6]=new Vector2(1,0);uvs[7]=new Vector2(0,0);// Left
  positions[8]=new Vector3(-halfWidth,halfHeight,-halfDepth);positions[9]=new Vector3(-halfWidth,halfHeight,halfDepth);positions[10]=new Vector3(-halfWidth,-halfHeight,halfDepth);positions[11]=new Vector3(-halfWidth,-halfHeight,-halfDepth);normals[8]=new Vector3(-1,0,0);normals[9]=new Vector3(-1,0,0);normals[10]=new Vector3(-1,0,0);normals[11]=new Vector3(-1,0,0);uvs[8]=new Vector2(0,0);uvs[9]=new Vector2(1,0);uvs[10]=new Vector2(1,1);uvs[11]=new Vector2(0,1);// Right
  positions[12]=new Vector3(halfWidth,halfHeight,-halfDepth);positions[13]=new Vector3(halfWidth,halfHeight,halfDepth);positions[14]=new Vector3(halfWidth,-halfHeight,halfDepth);positions[15]=new Vector3(halfWidth,-halfHeight,-halfDepth);normals[12]=new Vector3(1,0,0);normals[13]=new Vector3(1,0,0);normals[14]=new Vector3(1,0,0);normals[15]=new Vector3(1,0,0);uvs[12]=new Vector2(1,0);uvs[13]=new Vector2(0,0);uvs[14]=new Vector2(0,1);uvs[15]=new Vector2(1,1);// Front
  positions[16]=new Vector3(-halfWidth,halfHeight,halfDepth);positions[17]=new Vector3(halfWidth,halfHeight,halfDepth);positions[18]=new Vector3(halfWidth,-halfHeight,halfDepth);positions[19]=new Vector3(-halfWidth,-halfHeight,halfDepth);normals[16]=new Vector3(0,0,1);normals[17]=new Vector3(0,0,1);normals[18]=new Vector3(0,0,1);normals[19]=new Vector3(0,0,1);uvs[16]=new Vector2(0,0);uvs[17]=new Vector2(1,0);uvs[18]=new Vector2(1,1);uvs[19]=new Vector2(0,1);// Back
  positions[20]=new Vector3(-halfWidth,halfHeight,-halfDepth);positions[21]=new Vector3(halfWidth,halfHeight,-halfDepth);positions[22]=new Vector3(halfWidth,-halfHeight,-halfDepth);positions[23]=new Vector3(-halfWidth,-halfHeight,-halfDepth);normals[20]=new Vector3(0,0,-1);normals[21]=new Vector3(0,0,-1);normals[22]=new Vector3(0,0,-1);normals[23]=new Vector3(0,0,-1);uvs[20]=new Vector2(1,0);uvs[21]=new Vector2(0,0);uvs[22]=new Vector2(0,1);uvs[23]=new Vector2(1,1);var indices=new Uint16Array(36);// prettier-ignore
  // Up
  indices[0]=0,indices[1]=2,indices[2]=1,indices[3]=2,indices[4]=0,indices[5]=3,// Down
  indices[6]=4,indices[7]=6,indices[8]=7,indices[9]=6,indices[10]=4,indices[11]=5,// Left
  indices[12]=8,indices[13]=10,indices[14]=9,indices[15]=10,indices[16]=8,indices[17]=11,// Right
  indices[18]=12,indices[19]=14,indices[20]=15,indices[21]=14,indices[22]=12,indices[23]=13,// Front
  indices[24]=16,indices[25]=18,indices[26]=17,indices[27]=18,indices[28]=16,indices[29]=19,// Back
  indices[30]=20,indices[31]=22,indices[32]=23,indices[33]=22,indices[34]=20,indices[35]=21;var bounds=mesh.bounds;bounds.min.setValue(-halfWidth,-halfHeight,-halfDepth);bounds.max.setValue(halfWidth,halfHeight,halfDepth);PrimitiveMesh._initialize(mesh,positions,normals,uvs,indices,noLongerAccessible);return mesh;}/**
     * Create a plane mesh.
     * @param engine - Engine
     * @param width - Plane width
     * @param height - Plane height
     * @param horizontalSegments - Plane horizontal segments
     * @param verticalSegments - Plane vertical segments
     * @param noLongerAccessible - No longer access the vertices of the mesh after creation
     * @returns Plane model mesh
     */;PrimitiveMesh.createPlane=function createPlane(engine,width,height,horizontalSegments,verticalSegments,noLongerAccessible){if(width===void 0){width=1;}if(height===void 0){height=1;}if(horizontalSegments===void 0){horizontalSegments=1;}if(verticalSegments===void 0){verticalSegments=1;}if(noLongerAccessible===void 0){noLongerAccessible=true;}var mesh=new ModelMesh(engine);horizontalSegments=Math.max(1,Math.floor(horizontalSegments));verticalSegments=Math.max(1,Math.floor(verticalSegments));var horizontalCount=horizontalSegments+1;var verticalCount=verticalSegments+1;var halfWidth=width/2;var halfHeight=height/2;var gridWidth=width/horizontalSegments;var gridHeight=height/verticalSegments;var vertexCount=horizontalCount*verticalCount;var rectangleCount=verticalSegments*horizontalSegments;var indices=PrimitiveMesh._generateIndices(engine,vertexCount,rectangleCount*6);var horizontalCountReciprocal=1.0/horizontalCount;var horizontalSegmentsReciprocal=1.0/horizontalSegments;var verticalSegmentsReciprocal=1.0/verticalSegments;var positions=new Array(vertexCount);var normals=new Array(vertexCount);var uvs=new Array(vertexCount);for(var i=0;i<vertexCount;++i){var x=i%horizontalCount;var y=i*horizontalCountReciprocal|0;// Position
  positions[i]=new Vector3(x*gridWidth-halfWidth,y*gridHeight-halfHeight,0);// Normal
  normals[i]=new Vector3(0,0,1);// Texcoord
  uvs[i]=new Vector2(x*horizontalSegmentsReciprocal,1-y*verticalSegmentsReciprocal);}var offset=0;for(var _i2=0;_i2<rectangleCount;++_i2){var _x2=_i2%horizontalSegments;var _y2=_i2*horizontalSegmentsReciprocal|0;var a=_y2*horizontalCount+_x2;var b=a+1;var c=a+horizontalCount;var d=c+1;indices[offset++]=b;indices[offset++]=c;indices[offset++]=a;indices[offset++]=b;indices[offset++]=d;indices[offset++]=c;}var bounds=mesh.bounds;bounds.min.setValue(-halfWidth,-halfHeight,0);bounds.max.setValue(halfWidth,halfHeight,0);PrimitiveMesh._initialize(mesh,positions,normals,uvs,indices,noLongerAccessible);return mesh;}/**
     * Create a cylinder mesh.
     * @param engine - Engine
     * @param radiusTop - The radius of top cap
     * @param radiusBottom - The radius of bottom cap
     * @param height - The height of torso
     * @param radialSegments - Cylinder radial segments
     * @param heightSegments - Cylinder height segments
     * @param noLongerAccessible - No longer access the vertices of the mesh after creation
     * @returns Cylinder model mesh
     */;PrimitiveMesh.createCylinder=function createCylinder(engine,radiusTop,radiusBottom,height,radialSegments,heightSegments,noLongerAccessible){if(radiusTop===void 0){radiusTop=0.5;}if(radiusBottom===void 0){radiusBottom=0.5;}if(height===void 0){height=2;}if(radialSegments===void 0){radialSegments=20;}if(heightSegments===void 0){heightSegments=1;}if(noLongerAccessible===void 0){noLongerAccessible=true;}var mesh=new ModelMesh(engine);radialSegments=Math.floor(radialSegments);heightSegments=Math.floor(heightSegments);var radialCount=radialSegments+1;var verticalCount=heightSegments+1;var halfHeight=height*0.5;var unitHeight=height/heightSegments;var torsoVertexCount=radialCount*verticalCount;var torsoRectangleCount=radialSegments*heightSegments;var capTriangleCount=radialSegments*2;var totalVertexCount=torsoVertexCount+2+capTriangleCount;var indices=PrimitiveMesh._generateIndices(engine,totalVertexCount,torsoRectangleCount*6+capTriangleCount*3);var radialCountReciprocal=1.0/radialCount;var radialSegmentsReciprocal=1.0/radialSegments;var heightSegmentsReciprocal=1.0/heightSegments;var positions=new Array(totalVertexCount);var normals=new Array(totalVertexCount);var uvs=new Array(totalVertexCount);var indicesOffset=0;// Create torso
  var thetaStart=Math.PI;var thetaRange=Math.PI*2;var radiusDiff=radiusBottom-radiusTop;var slope=radiusDiff/height;var radiusSlope=radiusDiff/heightSegments;for(var i=0;i<torsoVertexCount;++i){var x=i%radialCount;var y=i*radialCountReciprocal|0;var u=x*radialSegmentsReciprocal;var v=y*heightSegmentsReciprocal;var theta=thetaStart+u*thetaRange;var sinTheta=Math.sin(theta);var cosTheta=Math.cos(theta);var radius=radiusBottom-y*radiusSlope;var posX=radius*sinTheta;var posY=y*unitHeight-halfHeight;var posZ=radius*cosTheta;// Position
  positions[i]=new Vector3(posX,posY,posZ);// Normal
  normals[i]=new Vector3(sinTheta,slope,cosTheta);// Texcoord
  uvs[i]=new Vector2(u,1-v);}for(var _i3=0;_i3<torsoRectangleCount;++_i3){var _x3=_i3%radialSegments;var _y3=_i3*radialSegmentsReciprocal|0;var a=_y3*radialCount+_x3;var b=a+1;var c=a+radialCount;var d=c+1;indices[indicesOffset++]=b;indices[indicesOffset++]=c;indices[indicesOffset++]=a;indices[indicesOffset++]=b;indices[indicesOffset++]=d;indices[indicesOffset++]=c;}// Bottom position
  positions[torsoVertexCount]=new Vector3(0,-halfHeight,0);// Bottom normal
  normals[torsoVertexCount]=new Vector3(0,-1,0);// Bottom texcoord
  uvs[torsoVertexCount]=new Vector2(0.5,0.5);// Top position
  positions[torsoVertexCount+1]=new Vector3(0,halfHeight,0);// Top normal
  normals[torsoVertexCount+1]=new Vector3(0,1,0);// Top texcoord
  uvs[torsoVertexCount+1]=new Vector2(0.5,0.5);// Add cap vertices
  var offset=torsoVertexCount+2;var diameterTopReciprocal=1.0/(radiusTop*2);var diameterBottomReciprocal=1.0/(radiusBottom*2);var positionStride=radialCount*heightSegments;for(var _i4=0;_i4<radialSegments;++_i4){var curPosBottom=positions[_i4];var curPosX=curPosBottom.x;var curPosZ=curPosBottom.z;// Bottom position
  positions[offset]=new Vector3(curPosX,-halfHeight,curPosZ);// Bottom normal
  normals[offset]=new Vector3(0,-1,0);// Bottom texcoord
  uvs[offset++]=new Vector2(curPosX*diameterBottomReciprocal+0.5,0.5-curPosZ*diameterBottomReciprocal);var curPosTop=positions[_i4+positionStride];curPosX=curPosTop.x;curPosZ=curPosTop.z;// Top position
  positions[offset]=new Vector3(curPosX,halfHeight,curPosZ);// Top normal
  normals[offset]=new Vector3(0,1,0);// Top texcoord
  uvs[offset++]=new Vector2(curPosX*diameterTopReciprocal+0.5,curPosZ*diameterTopReciprocal+0.5);}// Add cap indices
  var topCapIndex=torsoVertexCount+1;var bottomIndiceIndex=torsoVertexCount+2;var topIndiceIndex=bottomIndiceIndex+1;for(var _i5=0;_i5<radialSegments;++_i5){var firstStride=_i5*2;var secondStride=_i5===radialSegments-1?0:firstStride+2;// Bottom
  indices[indicesOffset++]=torsoVertexCount;indices[indicesOffset++]=bottomIndiceIndex+secondStride;indices[indicesOffset++]=bottomIndiceIndex+firstStride;// Top
  indices[indicesOffset++]=topCapIndex;indices[indicesOffset++]=topIndiceIndex+firstStride;indices[indicesOffset++]=topIndiceIndex+secondStride;}var bounds=mesh.bounds;var radiusMax=Math.max(radiusTop,radiusBottom);bounds.min.setValue(-radiusMax,-halfHeight,-radiusMax);bounds.max.setValue(radiusMax,halfHeight,radiusMax);PrimitiveMesh._initialize(mesh,positions,normals,uvs,indices,noLongerAccessible);return mesh;}/**
     * Create a torus mesh.
     * @param engine - Engine
     * @param radius - Torus radius
     * @param tubeRadius - Torus tube
     * @param radialSegments - Torus radial segments
     * @param tubularSegments - Torus tubular segments
     * @param arc - Central angle
     * @param noLongerAccessible - No longer access the vertices of the mesh after creation
     * @returns Torus model mesh
     */;PrimitiveMesh.createTorus=function createTorus(engine,radius,tubeRadius,radialSegments,tubularSegments,arc,noLongerAccessible){if(radius===void 0){radius=0.5;}if(tubeRadius===void 0){tubeRadius=0.1;}if(radialSegments===void 0){radialSegments=30;}if(tubularSegments===void 0){tubularSegments=30;}if(arc===void 0){arc=360;}if(noLongerAccessible===void 0){noLongerAccessible=true;}var mesh=new ModelMesh(engine);radialSegments=Math.floor(radialSegments);tubularSegments=Math.floor(tubularSegments);var vertexCount=(radialSegments+1)*(tubularSegments+1);var rectangleCount=radialSegments*tubularSegments;var indices=PrimitiveMesh._generateIndices(engine,vertexCount,rectangleCount*6);var positions=new Array(vertexCount);var normals=new Array(vertexCount);var uvs=new Array(vertexCount);arc=arc/180*Math.PI;var offset=0;for(var i=0;i<=radialSegments;i++){for(var j=0;j<=tubularSegments;j++){var u=j/tubularSegments*arc;var v=i/radialSegments*Math.PI*2;var cosV=Math.cos(v);var sinV=Math.sin(v);var cosU=Math.cos(u);var sinU=Math.sin(u);var position=new Vector3((radius+tubeRadius*cosV)*cosU,(radius+tubeRadius*cosV)*sinU,tubeRadius*sinV);positions[offset]=position;var centerX=radius*cosU;var centerY=radius*sinU;normals[offset]=new Vector3(position.x-centerX,position.y-centerY,position.z).normalize();uvs[offset++]=new Vector2(j/tubularSegments,i/radialSegments);}}offset=0;for(var _i6=1;_i6<=radialSegments;_i6++){for(var _j=1;_j<=tubularSegments;_j++){var a=(tubularSegments+1)*_i6+_j-1;var b=(tubularSegments+1)*(_i6-1)+_j-1;var c=(tubularSegments+1)*(_i6-1)+_j;var d=(tubularSegments+1)*_i6+_j;indices[offset++]=a;indices[offset++]=b;indices[offset++]=d;indices[offset++]=b;indices[offset++]=c;indices[offset++]=d;}}var bounds=mesh.bounds;var outerRadius=radius+tubeRadius;bounds.min.setValue(-outerRadius,-outerRadius,-tubeRadius);bounds.max.setValue(outerRadius,outerRadius,tubeRadius);PrimitiveMesh._initialize(mesh,positions,normals,uvs,indices,noLongerAccessible);return mesh;}/**
     * Create a cone mesh.
     * @param engine - Engine
     * @param radius - The radius of cap
     * @param height - The height of torso
     * @param radialSegments - Cylinder radial segments
     * @param heightSegments - Cylinder height segments
     * @param noLongerAccessible - No longer access the vertices of the mesh after creation
     * @returns Cone model mesh
     */;PrimitiveMesh.createCone=function createCone(engine,radius,height,radialSegments,heightSegments,noLongerAccessible){if(radius===void 0){radius=0.5;}if(height===void 0){height=2;}if(radialSegments===void 0){radialSegments=20;}if(heightSegments===void 0){heightSegments=1;}if(noLongerAccessible===void 0){noLongerAccessible=true;}var mesh=new ModelMesh(engine);radialSegments=Math.floor(radialSegments);heightSegments=Math.floor(heightSegments);var radialCount=radialSegments+1;var verticalCount=heightSegments+1;var halfHeight=height*0.5;var unitHeight=height/heightSegments;var torsoVertexCount=radialCount*verticalCount;var torsoRectangleCount=radialSegments*heightSegments;var totalVertexCount=torsoVertexCount+1+radialSegments;var indices=PrimitiveMesh._generateIndices(engine,totalVertexCount,torsoRectangleCount*6+radialSegments*3);var radialCountReciprocal=1.0/radialCount;var radialSegmentsReciprocal=1.0/radialSegments;var heightSegmentsReciprocal=1.0/heightSegments;var positions=new Array(totalVertexCount);var normals=new Array(totalVertexCount);var uvs=new Array(totalVertexCount);var indicesOffset=0;// Create torso
  var thetaStart=Math.PI;var thetaRange=Math.PI*2;var slope=radius/height;for(var i=0;i<torsoVertexCount;++i){var x=i%radialCount;var y=i*radialCountReciprocal|0;var u=x*radialSegmentsReciprocal;var v=y*heightSegmentsReciprocal;var theta=thetaStart+u*thetaRange;var sinTheta=Math.sin(theta);var cosTheta=Math.cos(theta);var curRadius=radius-y*radius;var posX=curRadius*sinTheta;var posY=y*unitHeight-halfHeight;var posZ=curRadius*cosTheta;// Position
  positions[i]=new Vector3(posX,posY,posZ);// Normal
  normals[i]=new Vector3(sinTheta,slope,cosTheta);// Texcoord
  uvs[i]=new Vector2(u,1-v);}for(var _i7=0;_i7<torsoRectangleCount;++_i7){var _x4=_i7%radialSegments;var _y4=_i7*radialSegmentsReciprocal|0;var a=_y4*radialCount+_x4;var b=a+1;var c=a+radialCount;var d=c+1;indices[indicesOffset++]=b;indices[indicesOffset++]=c;indices[indicesOffset++]=a;indices[indicesOffset++]=b;indices[indicesOffset++]=d;indices[indicesOffset++]=c;}// Bottom position
  positions[torsoVertexCount]=new Vector3(0,-halfHeight,0);// Bottom normal
  normals[torsoVertexCount]=new Vector3(0,-1,0);// Bottom texcoord
  uvs[torsoVertexCount]=new Vector2(0.5,0.5);// Add bottom cap vertices
  var offset=torsoVertexCount+1;var diameterBottomReciprocal=1.0/(radius*2);for(var _i8=0;_i8<radialSegments;++_i8){var curPos=positions[_i8];var curPosX=curPos.x;var curPosZ=curPos.z;// Bottom position
  positions[offset]=new Vector3(curPosX,-halfHeight,curPosZ);// Bottom normal
  normals[offset]=new Vector3(0,-1,0);// Bottom texcoord
  uvs[offset++]=new Vector2(curPosX*diameterBottomReciprocal+0.5,0.5-curPosZ*diameterBottomReciprocal);}var bottomIndiceIndex=torsoVertexCount+1;for(var _i9=0;_i9<radialSegments;++_i9){var firstStride=_i9;var secondStride=_i9===radialSegments-1?0:firstStride+1;// Bottom
  indices[indicesOffset++]=torsoVertexCount;indices[indicesOffset++]=bottomIndiceIndex+secondStride;indices[indicesOffset++]=bottomIndiceIndex+firstStride;}var bounds=mesh.bounds;bounds.min.setValue(-radius,-halfHeight,-radius);bounds.max.setValue(radius,halfHeight,radius);PrimitiveMesh._initialize(mesh,positions,normals,uvs,indices,noLongerAccessible);return mesh;};PrimitiveMesh._initialize=function _initialize(mesh,positions,normals,uvs,indices,noLongerAccessible){mesh.setPositions(positions);mesh.setNormals(normals);mesh.setUVs(uvs);mesh.setIndices(indices);mesh.uploadData(noLongerAccessible);mesh.addSubMesh(0,indices.length);};PrimitiveMesh._generateIndices=function _generateIndices(engine,vertexCount,indexCount){var indices=null;if(vertexCount>65535){if(engine._hardwareRenderer.canIUse(exports.GLCapabilityType.elementIndexUint)){indices=new Uint32Array(indexCount);}else {throw Error("The vertex count is over limit.");}}else {indices=new Uint16Array(indexCount);}return indices;};return PrimitiveMesh;}();/**
   * BufferMesh.
   */var BufferMesh=/*#__PURE__*/function(_Mesh){_inheritsLoose$2(BufferMesh,_Mesh);function BufferMesh(){return _Mesh.apply(this,arguments)||this;}var _proto=BufferMesh.prototype;/**
     * Set vertex elements.
     * @param elements - Vertex element collection
     */_proto.setVertexElements=function setVertexElements(elements){this._setVertexElements(elements);}/**
     * Set vertex buffer binding.
     * @param vertexBufferBindings - Vertex buffer binding
     * @param index - Vertex buffer index, the default value is 0
     */;_proto.setVertexBufferBinding=function setVertexBufferBinding(bufferOrBinding,strideOrFirstIndex,index){if(strideOrFirstIndex===void 0){strideOrFirstIndex=0;}if(index===void 0){index=0;}var binding=bufferOrBinding;var isBinding=binding.buffer!==undefined;isBinding||(binding=new VertexBufferBinding(bufferOrBinding,strideOrFirstIndex));var bindings=this._vertexBufferBindings;bindings.length<=index&&(bindings.length=index+1);this._setVertexBufferBinding(isBinding?strideOrFirstIndex:index,binding);}/**
     * Set vertex buffer binding.
     * @param vertexBufferBindings - Vertex buffer binding
     * @param firstIndex - First vertex buffer index, the default value is 0
     */;_proto.setVertexBufferBindings=function setVertexBufferBindings(vertexBufferBindings,firstIndex){if(firstIndex===void 0){firstIndex=0;}var bindings=this._vertexBufferBindings;var count=vertexBufferBindings.length;var needLength=firstIndex+count;bindings.length<needLength&&(bindings.length=needLength);for(var i=0;i<count;i++){this._setVertexBufferBinding(firstIndex+i,vertexBufferBindings[i]);}}/**
     * Set index buffer binding.
     * @param buffer - Index buffer
     * @param format - Index buffer format
     */;_proto.setIndexBufferBinding=function setIndexBufferBinding(bufferOrBinding,format){var binding=bufferOrBinding;if(binding){var isBinding=binding.buffer!==undefined;isBinding||(binding=new IndexBufferBinding(bufferOrBinding,format));}this._setIndexBufferBinding(binding);};_createClass$3(BufferMesh,[{key:"instanceCount",get:/**
       * Instanced count, disable instanced drawing when set zero.
       */function get(){return this._instanceCount;},set:function set(value){this._instanceCount=value;}/**
       * Vertex buffer binding collection.
       */},{key:"vertexBufferBindings",get:function get(){return this._vertexBufferBindings;}/**
       * Index buffer binding.
       */},{key:"indexBufferBinding",get:function get(){return this._indexBufferBinding;}/**
       * Vertex element collection.
       */},{key:"vertexElements",get:function get(){return this._vertexElements;}}]);return BufferMesh;}(Mesh);/**
   * BlendShapeFrame.
   */var BlendShapeFrame=/** Weight of BlendShapeFrame. */ /** Delta positions for the frame being added. */ /** Delta normals for the frame being added. */ /** Delta tangents for the frame being added. */ /**
   * Create a BlendShapeFrame.
   * @param weight - Weight of BlendShapeFrame
   * @param deltaPositions - Delta positions for the frame being added
   * @param deltaNormals - Delta normals for the frame being added
   * @param deltaTangents - Delta tangents for the frame being added
   */function BlendShapeFrame(weight,deltaPositions,deltaNormals,deltaTangents){if(deltaNormals===void 0){deltaNormals=null;}if(deltaTangents===void 0){deltaTangents=null;}this.weight=void 0;this.deltaPositions=void 0;this.deltaNormals=void 0;this.deltaTangents=void 0;if(deltaNormals&&deltaNormals.length!==deltaPositions.length){throw "deltaNormals length must same with deltaPositions length.";}if(deltaTangents&&deltaTangents.length!==deltaPositions.length){throw "deltaTangents length must same with deltaPositions length.";}this.weight=weight;this.deltaPositions=deltaPositions;this.deltaNormals=deltaNormals;this.deltaTangents=deltaTangents;};/**
   * BlendShape.
   */var BlendShape=/*#__PURE__*/function(){/**
     * Create a BlendShape.
     * @param name - BlendShape name.
     */function BlendShape(name){this.name=void 0;this._useBlendShapeNormal=false;this._useBlendShapeTangent=false;this._frames=[];this._updateFlagManager=new UpdateFlagManager();this.name=name;}/**
     * Add a BlendShapeFrame by weight, deltaPositions, deltaNormals and deltaTangents.
     * @param weight - Weight of BlendShapeFrame
     * @param deltaPositions - Delta positions for the frame being added
     * @param deltaNormals - Delta normals for the frame being added
     * @param deltaTangents - Delta tangents for the frame being added
     */var _proto=BlendShape.prototype;_proto.addFrame=function addFrame(frameOrWeight,deltaPositions,deltaNormals,deltaTangents){if(typeof frameOrWeight==="number"){var _frame=new BlendShapeFrame(frameOrWeight,deltaPositions,deltaNormals,deltaTangents);this._addFrame(_frame);return _frame;}else {this._addFrame(frameOrWeight);}this._updateFlagManager.distribute();}/**
     * Clear all frames.
     */;_proto.clearFrames=function clearFrames(){this._frames.length=0;this._updateFlagManager.distribute();this._useBlendShapeNormal=false;this._useBlendShapeTangent=false;}/**
     * @internal
     */;_proto._registerChangeFlag=function _registerChangeFlag(){return this._updateFlagManager.register();};_proto._addFrame=function _addFrame(frame){var frames=this._frames;var frameCount=frames.length;if(frameCount>0&&frame.deltaPositions.length!==frames[frameCount-1].deltaPositions.length){throw "Frame's deltaPositions length must same with before frame deltaPositions length.";}this._useBlendShapeNormal=this._useBlendShapeNormal||frame.deltaNormals!==null;this._useBlendShapeTangent=this._useBlendShapeTangent||frame.deltaTangents!==null;this._frames.push(frame);};_createClass$3(BlendShape,[{key:"frames",get:/** Name of BlendShape. */ /** @internal */ /** @internal */ /**
       * Frames of BlendShape.
       */function get(){return this._frames;}}]);return BlendShape;}();var Basic2DBatcher=/*#__PURE__*/function(){/** The maximum number of vertex. */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */function Basic2DBatcher(engine){this._subMeshPool=new ClassPool(SubMesh);this._batchedQueue=[];this._meshes=[];this._meshCount=1;this._vertexBuffers=[];this._indiceBuffers=[];this._vertices=void 0;this._indices=void 0;this._flushId=0;this._vertexCount=0;this._elementCount=0;var MAX_VERTEX_COUNT=Basic2DBatcher.MAX_VERTEX_COUNT;this._vertices=new Float32Array(MAX_VERTEX_COUNT*9);this._indices=new Uint16Array(MAX_VERTEX_COUNT*3);var _meshes=this._meshes,_meshCount=this._meshCount;for(var i=0;i<_meshCount;i++){_meshes[i]=this._createMesh(engine,i);}}var _proto=Basic2DBatcher.prototype;_proto.drawElement=function drawElement(element){var len=element.positions.length;if(this._vertexCount+len>Basic2DBatcher.MAX_VERTEX_COUNT){this.flush(element.camera.engine);}this._vertexCount+=len;this._batchedQueue[this._elementCount++]=element;};_proto.flush=function flush(engine){var batchedQueue=this._batchedQueue;if(batchedQueue.length===0){return;}this._updateData(engine);this.drawBatches(engine);if(!Basic2DBatcher._canUploadSameBuffer){this._flushId++;}batchedQueue.length=0;this._subMeshPool.resetPool();this._vertexCount=0;this._elementCount=0;};_proto.clear=function clear(){this._flushId=0;this._vertexCount=0;this._elementCount=0;this._batchedQueue.length=0;};_proto.destroy=function destroy(){this._batchedQueue=null;var meshes=this._meshes,vertexBuffers=this._vertexBuffers,indiceBuffers=this._indiceBuffers;for(var i=0,n=meshes.length;i<n;++i){meshes[i].destroy();}this._meshes=null;for(var _i=0,_n=vertexBuffers.length;_i<_n;++_i){vertexBuffers[_i].destroy();}this._vertexBuffers=null;for(var _i2=0,_n2=indiceBuffers.length;_i2<_n2;++_i2){indiceBuffers[_i2].destroy();}this._indiceBuffers=null;};_proto._createMesh=function _createMesh(engine,index){var MAX_VERTEX_COUNT=Basic2DBatcher.MAX_VERTEX_COUNT;var mesh=new BufferMesh(engine,"BufferMesh"+index);var vertexElements=[];var vertexStride=this.createVertexElements(vertexElements);// vertices
  this._vertexBuffers[index]=new Buffer(engine,exports.BufferBindFlag.VertexBuffer,MAX_VERTEX_COUNT*4*vertexStride,exports.BufferUsage.Dynamic);// indices
  this._indiceBuffers[index]=new Buffer(engine,exports.BufferBindFlag.IndexBuffer,MAX_VERTEX_COUNT*3,exports.BufferUsage.Dynamic);mesh.setVertexBufferBinding(this._vertexBuffers[index],vertexStride);mesh.setIndexBufferBinding(this._indiceBuffers[index],exports.IndexFormat.UInt16);mesh.setVertexElements(vertexElements);return mesh;};_proto._updateData=function _updateData(engine){var _meshes=this._meshes,_flushId=this._flushId;if(!Basic2DBatcher._canUploadSameBuffer&&this._meshCount<=_flushId){this._meshCount++;_meshes[_flushId]=this._createMesh(engine,_flushId);}var batchedQueue=this._batchedQueue,vertices=this._vertices,indices=this._indices;var mesh=_meshes[_flushId];mesh.clearSubMesh();var vertexIndex=0;var indiceIndex=0;var vertexStartIndex=0;var vertexCount=0;var curIndiceStartIndex=0;var curMeshIndex=0;var preElement=null;for(var i=0,len=batchedQueue.length;i<len;i++){var _curElement=batchedQueue[i];// Batch vertex
  vertexIndex=this.updateVertices(_curElement,vertices,vertexIndex);// Batch indice
  var triangles=_curElement.triangles;var triangleNum=triangles.length;for(var j=0;j<triangleNum;j++){indices[indiceIndex++]=triangles[j]+curIndiceStartIndex;}curIndiceStartIndex+=_curElement.positions.length;if(preElement===null){vertexCount+=triangleNum;}else {if(this.canBatch(preElement,_curElement)){vertexCount+=triangleNum;}else {mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex,vertexCount));vertexStartIndex+=vertexCount;vertexCount=triangleNum;batchedQueue[curMeshIndex++]=preElement;}}preElement=_curElement;}mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex,vertexCount));batchedQueue[curMeshIndex]=preElement;this._vertexBuffers[_flushId].setData(vertices,0,0,vertexIndex);this._indiceBuffers[_flushId].setData(indices,0,0,indiceIndex);};_proto._getSubMeshFromPool=function _getSubMeshFromPool(start,count){var subMesh=this._subMeshPool.getFromPool();subMesh.start=start;subMesh.count=count;subMesh.topology=exports.MeshTopology.Triangles;return subMesh;}/**
     * @internal
     */;return Basic2DBatcher;}();Basic2DBatcher.MAX_VERTEX_COUNT=4096;Basic2DBatcher._canUploadSameBuffer=true;var SpriteMaskBatcher=/*#__PURE__*/function(_Basic2DBatcher){_inheritsLoose$2(SpriteMaskBatcher,_Basic2DBatcher);function SpriteMaskBatcher(){return _Basic2DBatcher.apply(this,arguments)||this;}var _proto=SpriteMaskBatcher.prototype;_proto.createVertexElements=function createVertexElements(vertexElements){vertexElements[0]=new VertexElement("POSITION",0,exports.VertexElementFormat.Vector3,0);vertexElements[1]=new VertexElement("TEXCOORD_0",12,exports.VertexElementFormat.Vector2,0);return 20;};_proto.canBatch=function canBatch(preElement,curElement){if(preElement.isAdd!==curElement.isAdd){return false;}// Compare renderer property
  var preShaderData=preElement.component.shaderData;var curShaderData=curElement.component.shaderData;var textureProperty=SpriteMask._textureProperty;var alphaCutoffProperty=SpriteMask._alphaCutoffProperty;return preShaderData.getTexture(textureProperty)===curShaderData.getTexture(textureProperty)&&preShaderData.getTexture(alphaCutoffProperty)===curShaderData.getTexture(alphaCutoffProperty);};_proto.updateVertices=function updateVertices(element,vertices,vertexIndex){var positions=element.positions,uv=element.uv;var verticesNum=positions.length;for(var i=0;i<verticesNum;i++){var curPos=positions[i];var curUV=uv[i];vertices[vertexIndex++]=curPos.x;vertices[vertexIndex++]=curPos.y;vertices[vertexIndex++]=curPos.z;vertices[vertexIndex++]=curUV.x;vertices[vertexIndex++]=curUV.y;}return vertexIndex;};_proto.drawBatches=function drawBatches(engine){var mesh=this._meshes[this._flushId];var subMeshes=mesh.subMeshes;var batchedQueue=this._batchedQueue;for(var i=0,len=subMeshes.length;i<len;i++){var subMesh=subMeshes[i];var spriteMaskElement=batchedQueue[i];if(!subMesh||!spriteMaskElement){return;}var renderer=spriteMaskElement.component;var material=spriteMaskElement.material;var compileMacros=Shader._compileMacros;// union render global macro and material self macro.
  ShaderMacroCollection.unionCollection(renderer._globalShaderMacro,material.shaderData._macroCollection,compileMacros);// Update stencil state
  var stencilState=material.renderState.stencilState;var op=spriteMaskElement.isAdd?exports.StencilOperation.IncrementSaturate:exports.StencilOperation.DecrementSaturate;stencilState.passOperationFront=op;stencilState.passOperationBack=op;var program=material.shader._getShaderProgram(engine,compileMacros);if(!program.isValid){return;}var camera=spriteMaskElement.camera;program.bind();program.groupingOtherUniformBlock();program.uploadAll(program.sceneUniformBlock,camera.scene.shaderData);program.uploadAll(program.cameraUniformBlock,camera.shaderData);program.uploadAll(program.rendererUniformBlock,renderer.shaderData);program.uploadAll(program.materialUniformBlock,material.shaderData);material.renderState._apply(engine);engine._hardwareRenderer.drawPrimitive(mesh,subMesh,program);}};return SpriteMaskBatcher;}(Basic2DBatcher);/**
   * @internal
   */var SpriteMaskManager=/*#__PURE__*/function(){function SpriteMaskManager(engine){this._batcher=void 0;this._preMaskLayer=0;this._batcher=new SpriteMaskBatcher(engine);}var _proto=SpriteMaskManager.prototype;_proto.clear=function clear(){this._preMaskLayer=0;this._batcher.clear();};_proto.preRender=function preRender(camera,renderer){if(renderer.maskInteraction===exports.SpriteMaskInteraction.None){return;}this._batcher.clear();this._processMasksDiff(camera,renderer);this._batcher.flush(camera.engine);};_proto.postRender=function postRender(renderer){if(renderer.maskInteraction===exports.SpriteMaskInteraction.None){return;}this._preMaskLayer=renderer.maskLayer;};_proto.destroy=function destroy(){this._batcher.destroy();this._batcher=null;};_proto._processMasksDiff=function _processMasksDiff(camera,renderer){var preMaskLayer=this._preMaskLayer;var curMaskLayer=renderer.maskLayer;if(preMaskLayer!==curMaskLayer){var allMasks=camera._renderPipeline._allSpriteMasks;var commonLayer=preMaskLayer&curMaskLayer;var addLayer=curMaskLayer&~preMaskLayer;var reduceLayer=preMaskLayer&~curMaskLayer;var allMaskElements=allMasks._elements;for(var i=0,n=allMasks.length;i<n;i++){var mask=allMaskElements[i];var influenceLayers=mask.influenceLayers;if(influenceLayers&commonLayer){continue;}if(influenceLayers&addLayer){var maskRenderElement=mask._maskElement;maskRenderElement.isAdd=true;this._batcher.drawElement(maskRenderElement);continue;}if(influenceLayers&reduceLayer){var _maskRenderElement=mask._maskElement;_maskRenderElement.isAdd=false;this._batcher.drawElement(_maskRenderElement);}}}};return SpriteMaskManager;}();/**
   * The Background mode enumeration.
   */exports.BackgroundMode = void 0;(function(BackgroundMode){BackgroundMode[BackgroundMode["SolidColor"]=0]="SolidColor";BackgroundMode[BackgroundMode["Sky"]=1]="Sky";BackgroundMode[BackgroundMode["Texture"]=2]="Texture";})(exports.BackgroundMode||(exports.BackgroundMode={}));/**
   * Filling mode of background texture.
   */var BackgroundTextureFillMode;(function(BackgroundTextureFillMode){BackgroundTextureFillMode[BackgroundTextureFillMode["AspectFitWidth"]=0]="AspectFitWidth";BackgroundTextureFillMode[BackgroundTextureFillMode["AspectFitHeight"]=1]="AspectFitHeight";BackgroundTextureFillMode[BackgroundTextureFillMode["Fill"]=2]="Fill";})(BackgroundTextureFillMode||(BackgroundTextureFillMode={}));/**
   * Sky.
   */var Sky=function Sky(){this.material=void 0;this.mesh=void 0;this._matrix=new Matrix();};/**
   * Background of scene.
   */var Background=/*#__PURE__*/function(){/**
     * Constructor of Background.
     * @param _engine Engine Which the background belongs to.
     */function Background(_engine){this._engine=_engine;this.mode=exports.BackgroundMode.SolidColor;this.solidColor=new Color(0.25,0.25,0.25,1.0);this.sky=new Sky();this._textureFillMode=BackgroundTextureFillMode.AspectFitHeight;this._texture=null;}/**
     * @internal
     */var _proto=Background.prototype;_proto._resizeBackgroundTexture=function _resizeBackgroundTexture(){if(!this._texture){return;}var canvas=this._engine.canvas;var width=canvas.width,height=canvas.height;var _backgroundTextureMesh=this._engine._backgroundTextureMesh;var positions=_backgroundTextureMesh.getPositions();switch(this._textureFillMode){case BackgroundTextureFillMode.Fill:positions[0].setValue(-1,-1,1);positions[1].setValue(1,-1,1);positions[2].setValue(-1,1,1);positions[3].setValue(1,1,1);break;case BackgroundTextureFillMode.AspectFitWidth:var fitWidthScale=this._texture.height*width/this.texture.width/height;positions[0].setValue(-1,-fitWidthScale,1);positions[1].setValue(1,-fitWidthScale,1);positions[2].setValue(-1,fitWidthScale,1);positions[3].setValue(1,fitWidthScale,1);break;case BackgroundTextureFillMode.AspectFitHeight:var fitHeightScale=this._texture.width*height/this.texture.height/width;positions[0].setValue(-fitHeightScale,-1,1);positions[1].setValue(fitHeightScale,-1,1);positions[2].setValue(-fitHeightScale,1,1);positions[3].setValue(fitHeightScale,1,1);break;}_backgroundTextureMesh.setPositions(positions);_backgroundTextureMesh.uploadData(false);};_createClass$3(Background,[{key:"texture",get:/**
       * Background mode.
       * @defaultValue `BackgroundMode.SolidColor`
       * @remarks If using `BackgroundMode.Sky` mode and material or mesh of the `sky` is not defined, it will downgrade to `BackgroundMode.SolidColor`.
       */ /**
       * Background solid color.
       * @defaultValue `new Color(0.25, 0.25, 0.25, 1.0)`
       * @remarks When `mode` is `BackgroundMode.SolidColor`, the property will take effects.
       */ /**
       * Background sky.
       * @remarks When `mode` is `BackgroundMode.Sky`, the property will take effects.
       */ /** @internal */ /**
       * Background texture.
       * @remarks When `mode` is `BackgroundMode.Texture`, the property will take effects.
       */function get(){return this._texture;},set:function set(value){if(this._texture!==value){this._texture=value;this._engine._backgroundTextureMaterial.shaderData.setTexture("u_baseTexture",value);}}/**
       * @internal
       * Background texture fill mode.
       * @remarks When `mode` is `BackgroundMode.Texture`, the property will take effects.
       * @defaultValue `BackgroundTextureFillMode.FitHeight`
       */},{key:"textureFillMode",get:function get(){return this._textureFillMode;},set:function set(value){if(value!==this._textureFillMode){this._textureFillMode=value;this._resizeBackgroundTexture();}}}]);return Background;}();/**
   * Diffuse mode.
   */exports.DiffuseMode = void 0;(function(DiffuseMode){DiffuseMode[DiffuseMode["SolidColor"]=0]="SolidColor";DiffuseMode[DiffuseMode["SphericalHarmonics"]=1]="SphericalHarmonics";})(exports.DiffuseMode||(exports.DiffuseMode={}));/**
   * Ambient light.
   */var AmbientLight=/*#__PURE__*/function(){function AmbientLight(scene){this._scene=void 0;this._diffuseSphericalHarmonics=void 0;this._diffuseSolidColor=new Color(0.212,0.227,0.259);this._diffuseIntensity=1.0;this._specularReflection=void 0;this._specularIntensity=1.0;this._diffuseMode=exports.DiffuseMode.SolidColor;this._shArray=new Float32Array(27);this._scene=scene;var shaderData=this._scene.shaderData;shaderData.setColor(AmbientLight._diffuseColorProperty,this._diffuseSolidColor);shaderData.setFloat(AmbientLight._diffuseIntensityProperty,this._diffuseIntensity);shaderData.setFloat(AmbientLight._specularIntensityProperty,this._specularIntensity);}var _proto=AmbientLight.prototype;_proto._preComputeSH=function _preComputeSH(sh,out){/**
       * Basis constants
       *
       * 0: 1/2 * Math.sqrt(1 / Math.PI)
       *
       * 1: -1/2 * Math.sqrt(3 / Math.PI)
       * 2: 1/2 * Math.sqrt(3 / Math.PI)
       * 3: -1/2 * Math.sqrt(3 / Math.PI)
       *
       * 4: 1/2 * Math.sqrt(15 / Math.PI)
       * 5: -1/2 * Math.sqrt(15 / Math.PI)
       * 6: 1/4 * Math.sqrt(5 / Math.PI)
       * 7: -1/2 * Math.sqrt(15 / Math.PI)
       * 8: 1/4 * Math.sqrt(15 / Math.PI)
       */ /**
       * Convolution kernel
       *
       * 0: Math.PI
       * 1: (2 * Math.PI) / 3
       * 2: Math.PI / 4
       */var src=sh.coefficients;// l0
  out[0]=src[0]*0.886227;// kernel0 * basis0 = 0.886227
  out[1]=src[1]*0.886227;out[2]=src[2]*0.886227;// l1
  out[3]=src[3]*-1.023327;// kernel1 * basis1 = -1.023327;
  out[4]=src[4]*-1.023327;out[5]=src[5]*-1.023327;out[6]=src[6]*1.023327;// kernel1 * basis2 = 1.023327
  out[7]=src[7]*1.023327;out[8]=src[8]*1.023327;out[9]=src[9]*-1.023327;// kernel1 * basis3 = -1.023327
  out[10]=src[10]*-1.023327;out[11]=src[11]*-1.023327;// l2
  out[12]=src[12]*0.858086;// kernel2 * basis4 = 0.858086
  out[13]=src[13]*0.858086;out[14]=src[14]*0.858086;out[15]=src[15]*-0.858086;// kernel2 * basis5 = -0.858086
  out[16]=src[16]*-0.858086;out[17]=src[17]*-0.858086;out[18]=src[18]*0.247708;// kernel2 * basis6 = 0.247708
  out[19]=src[19]*0.247708;out[20]=src[20]*0.247708;out[21]=src[21]*-0.858086;// kernel2 * basis7 = -0.858086
  out[22]=src[22]*-0.858086;out[23]=src[23]*-0.858086;out[24]=src[24]*0.429042;// kernel2 * basis8 = 0.429042
  out[25]=src[25]*0.429042;out[26]=src[26]*0.429042;return out;};_createClass$3(AmbientLight,[{key:"diffuseMode",get:/**
       * Diffuse mode of ambient light.
       */function get(){return this._diffuseMode;},set:function set(value){this._diffuseMode=value;if(value===exports.DiffuseMode.SphericalHarmonics){this._scene.shaderData.enableMacro(AmbientLight._shMacro);}else {this._scene.shaderData.disableMacro(AmbientLight._shMacro);}}/**
       * Diffuse reflection solid color.
       * @remarks Effective when diffuse reflection mode is `DiffuseMode.SolidColor`.
       */},{key:"diffuseSolidColor",get:function get(){return this._diffuseSolidColor;},set:function set(value){if(value!==this._diffuseSolidColor){value.cloneTo(this._diffuseSolidColor);}}/**
       * Diffuse reflection spherical harmonics 3.
       * @remarks Effective when diffuse reflection mode is `DiffuseMode.SphericalHarmonics`.
       */},{key:"diffuseSphericalHarmonics",get:function get(){return this._diffuseSphericalHarmonics;},set:function set(value){this._diffuseSphericalHarmonics=value;var shaderData=this._scene.shaderData;if(value){shaderData.setFloatArray(AmbientLight._diffuseSHProperty,this._preComputeSH(value,this._shArray));}}/**
       * Diffuse reflection intensity.
       */},{key:"diffuseIntensity",get:function get(){return this._diffuseIntensity;},set:function set(value){this._diffuseIntensity=value;this._scene.shaderData.setFloat(AmbientLight._diffuseIntensityProperty,value);}/**
       * Specular reflection texture.
       */},{key:"specularTexture",get:function get(){return this._specularReflection;},set:function set(value){this._specularReflection=value;var shaderData=this._scene.shaderData;if(value){shaderData.setTexture(AmbientLight._specularTextureProperty,value);shaderData.setFloat(AmbientLight._mipLevelProperty,this._specularReflection.mipmapCount);shaderData.enableMacro(AmbientLight._specularMacro);}else {shaderData.disableMacro(AmbientLight._specularMacro);}}/**
       * Specular reflection intensity.
       */},{key:"specularIntensity",get:function get(){return this._specularIntensity;},set:function set(value){this._specularIntensity=value;this._scene.shaderData.setFloat(AmbientLight._specularIntensityProperty,value);}}]);return AmbientLight;}();AmbientLight._shMacro=Shader.getMacroByName("O3_USE_SH");AmbientLight._specularMacro=Shader.getMacroByName("O3_USE_SPECULAR_ENV");AmbientLight._diffuseColorProperty=Shader.getPropertyByName("u_envMapLight.diffuse");AmbientLight._diffuseSHProperty=Shader.getPropertyByName("u_env_sh");AmbientLight._diffuseIntensityProperty=Shader.getPropertyByName("u_envMapLight.diffuseIntensity");AmbientLight._specularTextureProperty=Shader.getPropertyByName("u_env_specularSampler");AmbientLight._specularIntensityProperty=Shader.getPropertyByName("u_envMapLight.specularIntensity");AmbientLight._mipLevelProperty=Shader.getPropertyByName("u_envMapLight.mipMapLevel");/**
   * Scene feature plug-in.
   * @deprecated
   */var SceneFeature=/*#__PURE__*/function(){function SceneFeature(){}var _proto=SceneFeature.prototype;/**
     * Callback before every scene update.
     * @param scene - Scene
     */_proto.preUpdate=function preUpdate(scene){}/**
     * Callback after every scene update.
     * @param scene - Scene
     */;_proto.postUpdate=function postUpdate(scene){}/**
     * Callback before scene rendering.
     * @param scene - Scene
     * @param camera - Camera
     */;_proto.preRender=function preRender(scene,camera){}/**
     * Callback after scene rendering.
     * @param scene - Scene
     * @param camera - Camera
     */;_proto.postRender=function postRender(scene,camera){}/**
     * Callback after the scene is destroyed.
     * @param scene - Scene
     */;_proto.destroy=function destroy(scene){};return SceneFeature;}();/**
   * Light base class.
   */var Light=/*#__PURE__*/function(_Component){_inheritsLoose$2(Light,_Component);function Light(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Component.call.apply(_Component,[this].concat(args))||this;_this._viewMat=void 0;_this._inverseViewMat=void 0;return _this;}var _proto=Light.prototype;/**
     * Mount to the current Scene.
     * @internal
     * @override
     */_proto._onEnable=function _onEnable(){this.scene.findFeature(LightFeature).attachRenderLight(this);}/**
     * Unmount from the current Scene.
     * @internal
     * @override
     */;_proto._onDisable=function _onDisable(){this.scene.findFeature(LightFeature).detachRenderLight(this);}/**
     * View matrix.
     */;_createClass$3(Light,[{key:"viewMatrix",get:function get(){if(!this._viewMat)this._viewMat=new Matrix();Matrix.invert(this.entity.transform.worldMatrix,this._viewMat);return this._viewMat;}/**
       * Inverse view matrix.
       */},{key:"inverseViewMatrix",get:function get(){if(!this._inverseViewMat)this._inverseViewMat=new Matrix();Matrix.invert(this.viewMatrix,this._inverseViewMat);return this._inverseViewMat;}}]);return Light;}(Component);Light._maxLight=10;/**
   * Directional light.
   */var DirectLight=/*#__PURE__*/function(_Light){_inheritsLoose$2(DirectLight,_Light);function DirectLight(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Light.call.apply(_Light,[this].concat(args))||this;_this.color=new Color(1,1,1,1);_this.intensity=1;_this._forward=new Vector3();_this._lightColor=new Color(1,1,1,1);_this._reverseDirection=new Vector3();return _this;}/**
     * @internal
     */DirectLight._updateShaderData=function _updateShaderData(shaderData){var data=DirectLight._combinedData;shaderData.setFloatArray(DirectLight._colorProperty,data.color);shaderData.setFloatArray(DirectLight._directionProperty,data.direction);};var _proto=DirectLight.prototype;/**
     * @internal
     */_proto._appendData=function _appendData(lightIndex){var colorStart=lightIndex*3;var directionStart=lightIndex*3;var lightColor=this.lightColor;var direction=this.direction;var data=DirectLight._combinedData;data.color[colorStart]=lightColor.r;data.color[colorStart+1]=lightColor.g;data.color[colorStart+2]=lightColor.b;data.direction[directionStart]=direction.x;data.direction[directionStart+1]=direction.y;data.direction[directionStart+2]=direction.z;};_createClass$3(DirectLight,[{key:"direction",get:/**
       * Get direction.
       */function get(){this.entity.transform.getWorldForward(this._forward);return this._forward;}/**
       * Get the final light color.
       */},{key:"lightColor",get:function get(){this._lightColor.r=this.color.r*this.intensity;this._lightColor.g=this.color.g*this.intensity;this._lightColor.b=this.color.b*this.intensity;this._lightColor.a=this.color.a*this.intensity;return this._lightColor;}/**
       * Get the opposite direction of the directional light direction.
       */},{key:"reverseDirection",get:function get(){Vector3.scale(this.direction,-1,this._reverseDirection);return this._reverseDirection;}}]);return DirectLight;}(Light);DirectLight._colorProperty=Shader.getPropertyByName("u_directLightColor");DirectLight._directionProperty=Shader.getPropertyByName("u_directLightDirection");DirectLight._combinedData={color:new Float32Array(3*Light._maxLight),direction:new Float32Array(3*Light._maxLight)};/**
   * Point light.
   */var PointLight=/*#__PURE__*/function(_Light){_inheritsLoose$2(PointLight,_Light);function PointLight(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Light.call.apply(_Light,[this].concat(args))||this;_this.color=new Color(1,1,1,1);_this.intensity=1.0;_this.distance=100;_this._lightColor=new Color(1,1,1,1);return _this;}/**
     * @internal
     */PointLight._updateShaderData=function _updateShaderData(shaderData){var data=PointLight._combinedData;shaderData.setFloatArray(PointLight._colorProperty,data.color);shaderData.setFloatArray(PointLight._positionProperty,data.position);shaderData.setFloatArray(PointLight._distanceProperty,data.distance);}/** Light color. */;var _proto=PointLight.prototype;/**
     * @internal
     */_proto._appendData=function _appendData(lightIndex){var colorStart=lightIndex*3;var positionStart=lightIndex*3;var distanceStart=lightIndex;var lightColor=this.lightColor;var lightPosition=this.position;var data=PointLight._combinedData;data.color[colorStart]=lightColor.r;data.color[colorStart+1]=lightColor.g;data.color[colorStart+2]=lightColor.b;data.position[positionStart]=lightPosition.x;data.position[positionStart+1]=lightPosition.y;data.position[positionStart+2]=lightPosition.z;data.distance[distanceStart]=this.distance;};_createClass$3(PointLight,[{key:"position",get:/**
       * Get light position.
       */function get(){return this.entity.transform.worldPosition;}/**
       * Get the final light color.
       */},{key:"lightColor",get:function get(){this._lightColor.r=this.color.r*this.intensity;this._lightColor.g=this.color.g*this.intensity;this._lightColor.b=this.color.b*this.intensity;this._lightColor.a=this.color.a*this.intensity;return this._lightColor;}}]);return PointLight;}(Light);PointLight._colorProperty=Shader.getPropertyByName("u_pointLightColor");PointLight._positionProperty=Shader.getPropertyByName("u_pointLightPosition");PointLight._distanceProperty=Shader.getPropertyByName("u_pointLightDistance");PointLight._combinedData={color:new Float32Array(3*Light._maxLight),position:new Float32Array(3*Light._maxLight),distance:new Float32Array(Light._maxLight)};/**
   * Spot light.
   */var SpotLight=/*#__PURE__*/function(_Light){_inheritsLoose$2(SpotLight,_Light);function SpotLight(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Light.call.apply(_Light,[this].concat(args))||this;_this.color=new Color(1,1,1,1);_this.intensity=1.0;_this.distance=100;_this.angle=Math.PI/6;_this.penumbra=Math.PI/12;_this._forward=new Vector3();_this._lightColor=new Color(1,1,1,1);_this._inverseDirection=new Vector3();return _this;}/**
     * @internal
     */SpotLight._updateShaderData=function _updateShaderData(shaderData){var data=SpotLight._combinedData;shaderData.setFloatArray(SpotLight._colorProperty,data.color);shaderData.setFloatArray(SpotLight._positionProperty,data.position);shaderData.setFloatArray(SpotLight._directionProperty,data.direction);shaderData.setFloatArray(SpotLight._distanceProperty,data.distance);shaderData.setFloatArray(SpotLight._angleCosProperty,data.angleCos);shaderData.setFloatArray(SpotLight._penumbraCosProperty,data.penumbraCos);}/** Light color. */;var _proto=SpotLight.prototype;/**
     * @internal
     */_proto._appendData=function _appendData(lightIndex){var colorStart=lightIndex*3;var positionStart=lightIndex*3;var directionStart=lightIndex*3;var distanceStart=lightIndex;var penumbraCosStart=lightIndex;var angleCosStart=lightIndex;var color=this.lightColor;var position=this.position;var direction=this.direction;var data=SpotLight._combinedData;data.color[colorStart]=color.r;data.color[colorStart+1]=color.g;data.color[colorStart+2]=color.b;data.position[positionStart]=position.x;data.position[positionStart+1]=position.y;data.position[positionStart+2]=position.z;data.direction[directionStart]=direction.x;data.direction[directionStart+1]=direction.y;data.direction[directionStart+2]=direction.z;data.distance[distanceStart]=this.distance;data.angleCos[angleCosStart]=Math.cos(this.angle);data.penumbraCos[penumbraCosStart]=Math.cos(this.angle+this.penumbra);};_createClass$3(SpotLight,[{key:"position",get:/**
       * Get light position.
       */function get(){return this.entity.transform.worldPosition;}/**
       * Get light direction.
       */},{key:"direction",get:function get(){this.entity.transform.getWorldForward(this._forward);return this._forward;}/**
       * Get the opposite direction of the spotlight.
       */},{key:"reverseDirection",get:function get(){Vector3.scale(this.direction,-1,this._inverseDirection);return this._inverseDirection;}/**
       * Get the final light color.
       */},{key:"lightColor",get:function get(){this._lightColor.r=this.color.r*this.intensity;this._lightColor.g=this.color.g*this.intensity;this._lightColor.b=this.color.b*this.intensity;this._lightColor.a=this.color.a*this.intensity;return this._lightColor;}}]);return SpotLight;}(Light);SpotLight._colorProperty=Shader.getPropertyByName("u_spotLightColor");SpotLight._positionProperty=Shader.getPropertyByName("u_spotLightPosition");SpotLight._directionProperty=Shader.getPropertyByName("u_spotLightDirection");SpotLight._distanceProperty=Shader.getPropertyByName("u_spotLightDistance");SpotLight._angleCosProperty=Shader.getPropertyByName("u_spotLightAngleCos");SpotLight._penumbraCosProperty=Shader.getPropertyByName("u_spotLightPenumbraCos");SpotLight._combinedData={color:new Float32Array(3*Light._maxLight),position:new Float32Array(3*Light._maxLight),direction:new Float32Array(3*Light._maxLight),distance:new Float32Array(Light._maxLight),angleCos:new Float32Array(Light._maxLight),penumbraCos:new Float32Array(Light._maxLight)};/**
   * Determine whether there are lights in the scene.
   * @returns Has light
   */function hasLight(){return this.findFeature(LightFeature).visibleLights.length>0;}/**
   * Light plug-in.
   */var LightFeature=/*#__PURE__*/function(_SceneFeature){_inheritsLoose$2(LightFeature,_SceneFeature);function LightFeature(){var _this;_this=_SceneFeature.call(this)||this;_this.visibleLights=void 0;_this.visibleLights=[];return _this;}/**
     * Register a light object to the current scene.
     * @param light
     */var _proto=LightFeature.prototype;_proto.attachRenderLight=function attachRenderLight(light){var index=this.visibleLights.indexOf(light);if(index==-1){this.visibleLights.push(light);}else {Logger.warn("Light already attached.");}}/**
     * Remove a light object from the current scene.
     * @param light
     */;_proto.detachRenderLight=function detachRenderLight(light){var index=this.visibleLights.indexOf(light);if(index!=-1){this.visibleLights.splice(index,1);}}/**
     * @internal
     */;_proto._updateShaderData=function _updateShaderData(shaderData){/**
       * ambientLight and envMapLight only use the last one in the scene
       * */var directLightCount=0;var pointLightCount=0;var spotLightCount=0;var lights=this.visibleLights;for(var i=0,len=lights.length;i<len;i++){var light=lights[i];if(light instanceof DirectLight){light._appendData(directLightCount++);}else if(light instanceof PointLight){light._appendData(pointLightCount++);}else if(light instanceof SpotLight){light._appendData(spotLightCount++);}}if(directLightCount){DirectLight._updateShaderData(shaderData);shaderData.enableMacro("O3_DIRECT_LIGHT_COUNT",directLightCount.toString());}else {shaderData.disableMacro("O3_DIRECT_LIGHT_COUNT");}if(pointLightCount){PointLight._updateShaderData(shaderData);shaderData.enableMacro("O3_POINT_LIGHT_COUNT",pointLightCount.toString());}else {shaderData.disableMacro("O3_POINT_LIGHT_COUNT");}if(spotLightCount){SpotLight._updateShaderData(shaderData);shaderData.enableMacro("O3_SPOT_LIGHT_COUNT",spotLightCount.toString());}else {shaderData.disableMacro("O3_SPOT_LIGHT_COUNT");}};return LightFeature;}(SceneFeature);/**
   * Scene.
   */var Scene=/*#__PURE__*/function(_EngineObject){_inheritsLoose$2(Scene,_EngineObject);/**
     * Create scene.
     * @param engine - Engine
     * @param name - Name
     */function Scene(engine,name){var _this;_this=_EngineObject.call(this,engine)||this;_this.name=void 0;_this.background=new Background(_this._engine);_this.ambientLight=void 0;_this.shaderData=new ShaderData(ShaderDataGroup.Scene);_this._activeCameras=[];_this._isActiveInEngine=false;_this._destroyed=false;_this._rootEntities=[];_this.features=[];_this.name=name||"";var shaderData=_this.shaderData;Scene.sceneFeatureManager.addObject(_assertThisInitialized$1(_this));shaderData._addRefCount(1);_this.ambientLight=new AmbientLight(_assertThisInitialized$1(_this));return _this;}/**
     * Create root entity.
     * @param name - Entity name
     * @returns Entity
     */var _proto=Scene.prototype;_proto.createRootEntity=function createRootEntity(name){var entity=new Entity(this._engine,name);this.addRootEntity(entity);return entity;}/**
     * Append an entity.
     * @param entity - The root entity to add
     */;_proto.addRootEntity=function addRootEntity(entity){var isRoot=entity._isRoot;// let entity become root
  if(!isRoot){entity._isRoot=true;entity._removeFromParent();}// add or remove from scene's rootEntities
  var oldScene=entity._scene;if(oldScene!==this){if(oldScene&&isRoot){oldScene._removeEntity(entity);}this._rootEntities.push(entity);Entity._traverseSetOwnerScene(entity,this);}else if(!isRoot){this._rootEntities.push(entity);}// process entity active/inActive
  if(this._isActiveInEngine){!entity._isActiveInHierarchy&&entity._isActive&&entity._processActive();}else {entity._isActiveInHierarchy&&entity._processInActive();}}/**
     * Remove an entity.
     * @param entity - The root entity to remove
     */;_proto.removeRootEntity=function removeRootEntity(entity){if(entity._isRoot&&entity._scene==this){this._removeEntity(entity);this._isActiveInEngine&&entity._processInActive();Entity._traverseSetOwnerScene(entity,null);}}/**
     * Get root entity from index.
     * @param index - Index
     * @returns Entity
     */;_proto.getRootEntity=function getRootEntity(index){if(index===void 0){index=0;}return this._rootEntities[index];}/**
     * Find entity globally by name.
     * @param name - Entity name
     * @returns Entity
     */;_proto.findEntityByName=function findEntityByName(name){var children=this._rootEntities;for(var i=children.length-1;i>=0;i--){var child=children[i];if(child.name===name){return child;}}for(var _i=children.length-1;_i>=0;_i--){var _child=children[_i];var entity=_child.findByName(name);if(entity){return entity;}}return null;}/**
     * Find entity globally by name,use ‘/’ symbol as a path separator.
     * @param path - Entity's path
     * @returns Entity
     */;_proto.findEntityByPath=function findEntityByPath(path){var splits=path.split("/").filter(Boolean);for(var i=0,n=this.rootEntitiesCount;i<n;i++){var findEntity=this.getRootEntity(i);if(findEntity.name!=splits[0])continue;for(var j=1,m=splits.length;j<m;++j){findEntity=Entity._findChildByName(findEntity,splits[j]);if(!findEntity)break;}return findEntity;}return null;}/**
     * Destroy this scene.
     */;_proto.destroy=function destroy(){if(this._destroyed){return;}this._isActiveInEngine&&(this._engine.sceneManager.activeScene=null);Scene.sceneFeatureManager.callFeatureMethod(this,"destroy",[this]);for(var i=0,n=this.rootEntitiesCount;i<n;i++){this._rootEntities[i].destroy();}this._rootEntities.length=0;this._activeCameras.length=0;Scene.sceneFeatureManager._objects=[];this.shaderData._addRefCount(-1);this._destroyed=true;}/**
     * @internal
     */;_proto._attachRenderCamera=function _attachRenderCamera(camera){var index=this._activeCameras.indexOf(camera);if(index===-1){this._activeCameras.push(camera);}else {Logger.warn("Camera already attached.");}}/**
     * @internal
     */;_proto._detachRenderCamera=function _detachRenderCamera(camera){var index=this._activeCameras.indexOf(camera);if(index!==-1){this._activeCameras.splice(index,1);}}/**
     * @internal
     */;_proto._processActive=function _processActive(active){this._isActiveInEngine=active;var rootEntities=this._rootEntities;for(var i=rootEntities.length-1;i>=0;i--){var entity=rootEntities[i];if(entity._isActive){active?entity._processActive():entity._processInActive();}}}/**
     * @internal
     */;_proto._updateShaderData=function _updateShaderData(){var lightMgr=this.findFeature(LightFeature);lightMgr._updateShaderData(this.shaderData);};_proto._removeEntity=function _removeEntity(entity){var oldRootEntities=this._rootEntities;oldRootEntities.splice(oldRootEntities.indexOf(entity),1);}//-----------------------------------------@deprecated-----------------------------------
  ;Scene.registerFeature=function registerFeature(Feature){Scene.sceneFeatureManager.registerFeature(Feature);};_proto.findFeature=function findFeature(Feature){return Scene.sceneFeatureManager.findFeature(this,Feature);};_createClass$3(Scene,[{key:"rootEntitiesCount",get:/** Scene name. */ /** The background of the scene. */ /** Ambient light. */ /** Scene-related shader data. */ /** @internal */ /** @internal */ /**
       * Count of root entities.
       */function get(){return this._rootEntities.length;}/**
       * Root entity collection.
       */},{key:"rootEntities",get:function get(){return this._rootEntities;}/**
       * Whether it's destroyed.
       */},{key:"destroyed",get:function get(){return this._destroyed;}}]);return Scene;}(EngineObject);Scene.sceneFeatureManager=new FeatureManager();/**
   * Scene manager.
   */var SceneManager$1=/*#__PURE__*/function(){/**
     * @internal
     */function SceneManager(engine){this.engine=engine;this._activeScene=void 0;}/**
     * Load and activate scene.
     * @param url - the path of the scene
     * @param destroyOldScene - whether to destroy old scene information
     * @returns scene promise
     */var _proto=SceneManager.prototype;_proto.loadScene=function loadScene(url,destroyOldScene){var _this=this;if(destroyOldScene===void 0){destroyOldScene=true;}var scenePromise=this.engine.resourceManager.load(url);scenePromise.then(function(scene){var oldScene=_this._activeScene;_this.activeScene=scene;if(oldScene&&destroyOldScene){oldScene.destroy();}});return scenePromise;}/**
     * Merge the source scene into the target scene.
     * @remarks the global information of destScene will be used after the merge, and the lightingMap information will be merged.
     * @param sourceScene - source scene
     * @param destScene - target scene
     */;_proto.mergeScenes=function mergeScenes(sourceScene,destScene){var oldRootEntities=sourceScene.rootEntities;for(var i=0,n=oldRootEntities.length;i<n;i++){destScene.addRootEntity(oldRootEntities[i]);}};_createClass$3(SceneManager,[{key:"activeScene",get:/**
       * Get the activated scene.
       */function get(){return this._activeScene;},set:function set(scene){var oldScene=this._activeScene;if(oldScene!==scene){oldScene&&oldScene._processActive(false);scene&&scene._processActive(true);this._activeScene=scene;}}}]);return SceneManager;}();var blinnPhongFs="#define GLSLIFY 1\n#include <common>\n#include <common_frag>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <pbr_envmap_light_frag_define>\n#include <direct_light_frag>\n#include <point_light_frag>\n#include <spot_light_frag>\n#include <mobile_material_frag>\n#include <fog_share>\n#include <normal_get>\nvoid main(){\n#include <begin_mobile_frag>\n#include <begin_viewdir_frag>\n#include <mobile_blinnphong_frag>\ngl_FragColor=emission+ambient+diffuse+specular;gl_FragColor.a=diffuse.a;\n#include <fog_frag>\n}";// eslint-disable-line
  var blinnPhongVs="#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <shadow_vert>\n#include <position_vert>\n#include <fog_vert>\n}";// eslint-disable-line
  var particleFs="#define GLSLIFY 1\nvarying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;uniform sampler2D u_texture;void main(){if(v_lifeLeft==1.0){discard;}float alphaFactor=1.0;\n#ifdef fadeIn\nfloat fadeInFactor=step(0.5,v_lifeLeft);alphaFactor=2.0*fadeInFactor*(1.0-v_lifeLeft)+(1.0-fadeInFactor);\n#endif\n#ifdef fadeOut\nfloat fadeOutFactor=step(0.5,v_lifeLeft);alphaFactor=alphaFactor*2.0*(1.0-fadeOutFactor)*v_lifeLeft+alphaFactor*fadeOutFactor;\n#endif\n#ifdef particleTexture\nvec4 tex=texture2D(u_texture,v_uv);\n#ifdef useOriginColor\ngl_FragColor=vec4(tex.rgb,alphaFactor*tex.a*v_color.w);\n#else\ngl_FragColor=vec4(v_color.xyz*tex.rgb,alphaFactor*tex.a*v_color.w);\n#endif\n#else\ngl_FragColor=vec4(v_color.xyz,alphaFactor*v_color.w);\n#endif\n}";// eslint-disable-line
  var particleVs="#define GLSLIFY 1\nattribute vec3 a_position;attribute vec3 a_velocity;attribute vec3 a_acceleration;attribute vec4 a_color;attribute vec4 a_lifeAndSize;attribute vec2 a_rotation;attribute vec3 a_uv;attribute vec2 a_normalizedUv;uniform float u_time;uniform bool u_once;uniform mat4 u_MVPMat;varying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;\n#ifdef is2d\nuniform mat4 u_viewInvMat;uniform mat4 u_projMat;uniform mat4 u_viewMat;uniform mat4 u_modelMat;\n#endif\nmat2 rotation2d(float angle){float s=sin(angle);float c=cos(angle);return mat2(c,-s,s,c);}void main(){v_color=a_color;v_uv=a_uv.xy;float life=a_lifeAndSize.y;float startTime=a_lifeAndSize.x;float deltaTime=max(mod(u_time-startTime,life),0.0);if((u_once&&u_time>life+startTime)){deltaTime=0.0;}v_lifeLeft=1.0-deltaTime/life;float scale=a_lifeAndSize.z;vec3 position=a_position+(a_velocity+a_acceleration*deltaTime*0.5)*deltaTime;\n#ifdef isScaleByLifetime\nscale*=v_lifeLeft;\n#else\nscale*=pow(a_lifeAndSize.w,deltaTime);\n#endif\n#ifdef rotateToVelocity\nvec3 v=a_velocity+a_acceleration*deltaTime;float angle=atan(v.z,v.x)*2.0;\n#else\nfloat deltaAngle=deltaTime*a_rotation.y;float angle=a_rotation.x+deltaAngle;\n#endif\n#ifdef is2d\nvec2 rotatedPoint=rotation2d(angle)*vec2(a_normalizedUv.x,a_normalizedUv.y*a_uv.z);vec3 basisX=u_viewInvMat[0].xyz;vec3 basisZ=u_viewInvMat[1].xyz;vec3 localPosition=vec3(basisX*rotatedPoint.x+basisZ*rotatedPoint.y)*scale+position;gl_Position=u_projMat*u_viewMat*vec4(localPosition+u_modelMat[3].xyz,1.);\n#else\n#ifdef rotateToVelocity\nfloat s=sin(angle);float c=cos(angle);\n#else\nfloat s=sin(angle);float c=cos(angle);\n#endif\nvec4 rotatedPoint=vec4((a_normalizedUv.x*c+a_normalizedUv.y*a_uv.z*s)*scale,0.,(a_normalizedUv.x*s-a_normalizedUv.y*a_uv.z*c)*scale,1.);vec4 orientation=vec4(0,0,0,1);vec4 q2=orientation+orientation;vec4 qx=orientation.xxxw*q2.xyzx;vec4 qy=orientation.xyyw*q2.xyzy;vec4 qz=orientation.xxzw*q2.xxzz;mat4 localMatrix=mat4((1.0-qy.y)-qz.z,qx.y+qz.w,qx.z-qy.w,0,qx.y-qz.w,(1.0-qx.x)-qz.z,qy.z+qx.w,0,qx.z+qy.w,qy.z-qx.w,(1.0-qx.x)-qy.y,0,position.x,position.y,position.z,1);rotatedPoint=localMatrix*rotatedPoint;gl_Position=u_MVPMat*rotatedPoint;\n#endif\n}";// eslint-disable-line
  var pbrFs="#define GLSLIFY 1\n#include <common>\n#include <common_frag>\n#include <pbr_common_frag_define>\n#include <pbr_util_frag_define>\n#include <fog_share>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <direct_light_frag>\n#include <point_light_frag>\n#include <spot_light_frag>\n#include <pbr_envmap_light_frag_define>\n#include <pbr_base_frag_define>\n#include <pbr_texture_frag_define>\n#include <pbr_runtime_frag_define>\n#include <normal_get>\n#include <pbr_brdf_cook_torrance_frag_define>\n#include <pbr_direct_irradiance_frag_define>\n#include <pbr_ibl_diffuse_frag_define>\n#include <pbr_ibl_specular_frag_define>\nvoid main(){\n#include <pbr_begin_frag>\n#include <pbr_direct_irradiance_frag>\n#include <pbr_ibl_diffuse_frag>\n#include <pbr_ibl_specular_frag>\n#include <pbr_end_frag>\n#include <gamma_frag>\n#include <fog_frag>\n}";// eslint-disable-line
  var pbrVs="#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <shadow_vert>\n#include <position_vert>\n#include <fog_vert>\n}";// eslint-disable-line
  var shadowMapFs="#define GLSLIFY 1\nvec4 pack(float depth){const vec4 bitShift=vec4(1.0,256.0,256.0*256.0,256.0*256.0*256.0);const vec4 bitMask=vec4(1.0/256.0,1.0/256.0,1.0/256.0,0.0);vec4 rgbaDepth=fract(depth*bitShift);rgbaDepth-=rgbaDepth.gbaa*bitMask;return rgbaDepth;}void main(){gl_FragColor=pack(gl_FragCoord.z);}";// eslint-disable-line
  var shadowMapVs="#define GLSLIFY 1\n#include <common_vert>\n#include <blendShape_input>\n#include <normal_share>\n#include <shadow_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <shadow_vert>\n#include <position_vert>\n}";// eslint-disable-line
  var shadowFs="#define GLSLIFY 1\n#ifdef O3_SHADOW_MAP_COUNT\nuniform float u_shadowBias[O3_SHADOW_MAP_COUNT];uniform float u_shadowIntensity[O3_SHADOW_MAP_COUNT];uniform float u_shadowRadius[O3_SHADOW_MAP_COUNT];uniform vec2 u_shadowMapSize[O3_SHADOW_MAP_COUNT];uniform sampler2D u_shadowMaps[O3_SHADOW_MAP_COUNT];varying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];const vec4 bitShift=vec4(1.0,1.0/256.0,1.0/(256.0*256.0),1.0/(256.0*256.0*256.0));float unpack(const in vec4 rgbaDepth){return dot(rgbaDepth,bitShift);}float getVisibility(vec4 positionFromLight,const in sampler2D shadowMap,vec2 mapSize,float intensity,float bias,float radius){vec3 shadowCoord=(positionFromLight.xyz/positionFromLight.w)/2.0+0.5;float filterX=step(0.0,shadowCoord.x)*(1.0-step(1.0,shadowCoord.x));float filterY=step(0.0,shadowCoord.y)*(1.0-step(1.0,shadowCoord.y));shadowCoord.z-=bias;vec2 texelSize=vec2(1.0)/mapSize;float visibility=0.0;for(float y=-1.0;y<=1.0;y+=1.0){for(float x=-1.0;x<=1.0;x+=1.0){vec2 uv=shadowCoord.xy+texelSize*vec2(x,y)*radius;vec4 rgbaDepth=texture2D(shadowMap,uv);float depth=unpack(rgbaDepth);visibility+=step(depth,shadowCoord.z)*intensity;}}visibility*=(1.0/9.0);return visibility*filterX*filterY;}\n#endif\nvoid main(){vec4 shadowColor=vec4(1.0,1.0,1.0,1.0);\n#ifdef O3_SHADOW_MAP_COUNT\nfloat visibility=1.0;\n#if (O3_SHADOW_MAP_COUNT == 1)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);\n#elif (O3_SHADOW_MAP_COUNT == 2)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);visibility-=getVisibility(v_PositionFromLight[1],u_shadowMaps[1],u_shadowMapSize[1],u_shadowIntensity[1],u_shadowBias[1],u_shadowRadius[1]);\n#elif (O3_SHADOW_MAP_COUNT == 3)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);visibility-=getVisibility(v_PositionFromLight[1],u_shadowMaps[1],u_shadowMapSize[1],u_shadowIntensity[1],u_shadowBias[1],u_shadowRadius[1]);visibility-=getVisibility(v_PositionFromLight[2],u_shadowMaps[2],u_shadowMapSize[2],u_shadowIntensity[2],u_shadowBias[2],u_shadowRadius[2]);\n#endif\nvisibility=clamp(visibility,0.0,1.0);shadowColor=vec4(visibility,visibility,visibility,1.0);\n#endif\ngl_FragColor=shadowColor;}";// eslint-disable-line
  var skyboxFs="#define GLSLIFY 1\nuniform samplerCube u_cube;varying vec3 v_cubeUV;void main(){gl_FragColor=textureCube(u_cube,v_cubeUV);}";// eslint-disable-line
  var skyboxVs="#define GLSLIFY 1\n#include <common_vert>\nuniform mat4 u_mvpNoscale;varying vec3 v_cubeUV;void main(){v_cubeUV=POSITION.xyz;gl_Position=u_mvpNoscale*vec4(POSITION,1.0);gl_Position.z=gl_Position.w;}";// eslint-disable-line
  var spriteMaskFs="#define GLSLIFY 1\nuniform sampler2D u_maskTexture;uniform float u_maskAlphaCutoff;varying vec2 v_uv;void main(){vec4 color=texture2D(u_maskTexture,v_uv);if(color.a<u_maskAlphaCutoff){discard;}gl_FragColor=color;}";// eslint-disable-line
  var spriteMaskVs="#define GLSLIFY 1\nuniform mat4 u_VPMat;attribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=u_VPMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}";// eslint-disable-line
  var spriteFs="#define GLSLIFY 1\n#ifdef USE_CUSTOM_TEXTURE\nuniform sampler2D u_cusTomTexture;\n#else\nuniform sampler2D u_spriteTexture;\n#endif\nvarying vec2 v_uv;varying vec4 v_color;void main(){\n#ifdef USE_CUSTOM_TEXTURE\nvec4 baseColor=texture2D(u_cusTomTexture,v_uv);\n#else\nvec4 baseColor=texture2D(u_spriteTexture,v_uv);\n#endif\ngl_FragColor=baseColor*v_color;}";// eslint-disable-line
  var spriteVs="#define GLSLIFY 1\n#ifdef USE_MODEL_MATRIX\nuniform mat4 u_MVPMat;\n#else\nuniform mat4 u_VPMat;\n#endif\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;attribute vec4 COLOR_0;varying vec2 v_uv;varying vec4 v_color;void main(){\n#ifdef USE_MODEL_MATRIX\ngl_Position=u_MVPMat*vec4(POSITION,1.0);\n#else\ngl_Position=u_VPMat*vec4(POSITION,1.0);\n#endif\nv_uv=TEXCOORD_0;v_color=COLOR_0;}";// eslint-disable-line
  var unlitFs="#define GLSLIFY 1\n#include <uv_share>\n#include <fog_share>\nuniform vec4 u_baseColor;uniform float u_alphaCutoff;\n#ifdef O3_BASE_TEXTURE\nuniform sampler2D u_baseTexture;\n#endif\nvoid main(){vec4 baseColor=u_baseColor;\n#ifdef O3_BASE_TEXTURE\nbaseColor*=texture2D(u_baseTexture,v_uv);\n#endif\n#ifdef ALPHA_CUTOFF\nif(baseColor.a<u_alphaCutoff){discard;}\n#endif\ngl_FragColor=baseColor;\n#include <fog_frag>\n}";// eslint-disable-line
  var unlitVs="#define GLSLIFY 1\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <position_vert>\n#include <fog_vert>\n}";// eslint-disable-line
  var backgroundTextureVs="#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=vec4(POSITION,1.0);v_uv=TEXCOORD_0;}";// eslint-disable-line
  var backgroundTextureFs="#define GLSLIFY 1\nuniform sampler2D u_baseTexture;varying vec2 v_uv;void main(){gl_FragColor=texture2D(u_baseTexture,v_uv);}";// eslint-disable-line
  /**
   * Internal shader pool.
   * @internal
   */var ShaderPool=/*#__PURE__*/function(){function ShaderPool(){}ShaderPool.init=function init(){Shader.create("blinn-phong",blinnPhongVs,blinnPhongFs);Shader.create("pbr",pbrVs,pbrFs);Shader.create("unlit",unlitVs,unlitFs);Shader.create("shadow-map",shadowMapVs,shadowMapFs);Shader.create("shadow",shadowMapVs,shadowFs);Shader.create("skybox",skyboxVs,skyboxFs);Shader.create("particle-shader",particleVs,particleFs);Shader.create("SpriteMask",spriteMaskVs,spriteMaskFs);Shader.create("Sprite",spriteVs,spriteFs);Shader.create("background-texture",backgroundTextureVs,backgroundTextureFs);};return ShaderPool;}();/**
   * Shader program pool.
   * @internal
   */var ShaderProgramPool=/*#__PURE__*/function(){function ShaderProgramPool(){this._cacheHierarchy=1;this._cacheMap=Object.create(null);this._lastQueryMap=void 0;this._lastQueryKey=void 0;}var _proto=ShaderProgramPool.prototype;/**
     * Get shader program by macro collection.
     * @param macros - macro collection
     * @returns shader program
     */_proto.get=function get(macros){var cacheMap=this._cacheMap;var maskLength=macros._length;if(maskLength>this._cacheHierarchy){this._resizeCacheMapHierarchy(cacheMap,0,maskLength);}var mask=macros._mask;var endIndex=macros._length-1;var maxEndIndex=this._cacheHierarchy-1;for(var i=0;i<maxEndIndex;i++){var subMask=endIndex<i?0:mask[i];var subCacheShaders=cacheMap[subMask];subCacheShaders||(cacheMap[subMask]=subCacheShaders=Object.create(null));cacheMap=subCacheShaders;}var cacheKey=endIndex<maxEndIndex?0:mask[maxEndIndex];var shader=cacheMap[cacheKey];if(!shader){this._lastQueryKey=cacheKey;this._lastQueryMap=cacheMap;}return shader;}/**
     * Cache the shader program.
     *
     * @remarks
     * The method must return an empty value after calling get() to run normally.
     *
     * @param shaderProgram - shader program
     */;_proto.cache=function cache(shaderProgram){this._lastQueryMap[this._lastQueryKey]=shaderProgram;};_proto._resizeCacheMapHierarchy=function _resizeCacheMapHierarchy(cacheMap,hierarchy,resizeLength){// only expand but not shrink.
  var end=this._cacheHierarchy-1;if(hierarchy==end){for(var k in cacheMap){var shader=cacheMap[k];for(var i=0,n=resizeLength-end;i<n;i++){if(i==n-1){cacheMap[0]=shader;}else {cacheMap=cacheMap[i==0?k:0]=Object.create(null);}}}this._cacheHierarchy=resizeLength;}else {for(var _k in cacheMap){this._resizeCacheMapHierarchy(cacheMap[_k],++hierarchy,resizeLength);}}};return ShaderProgramPool;}();var ColliderFeature=/*#__PURE__*/function(_SceneFeature){_inheritsLoose$2(ColliderFeature,_SceneFeature);function ColliderFeature(){var _this;_this=_SceneFeature.call(this)||this;_this.colliders=void 0;_this.colliders=[];return _this;}/**
     * Add a collider component.
     * @param collider - The collider component to add
     */var _proto=ColliderFeature.prototype;_proto.attachCollider=function attachCollider(collider){this.colliders.push(collider);}/**
     * Remove a collider component.
     * @param collider - The collider component to remove
     */;_proto.detachCollider=function detachCollider(collider){var index=this.colliders.indexOf(collider);if(index!=-1){this.colliders.splice(index,1);}};return ColliderFeature;}(SceneFeature);/**
   * Define collider data.
   */var Collider=/*#__PURE__*/function(_Component){_inheritsLoose$2(Collider,_Component);/**
     * @param {Entity} entity
     */function Collider(entity){return _Component.call(this,entity)||this;}var _proto=Collider.prototype;_proto._onEnable=function _onEnable(){this.scene.findFeature(ColliderFeature).attachCollider(this);};_proto._onDisable=function _onDisable(){this.scene.findFeature(ColliderFeature).detachCollider(this);};_proto._updateHitResult=function _updateHitResult(ray,distance,outHit,origin,isWorldRay){if(isWorldRay===void 0){isWorldRay=false;}ray.getPoint(distance,outHit.point);if(!isWorldRay){Vector3.transformCoordinate(outHit.point,this.entity.transform.worldMatrix,outHit.point);}outHit.distance=Vector3.distance(origin,outHit.point);outHit.collider=this;};_proto._getLocalRay=function _getLocalRay(ray){var worldToLocal=this.entity.getInvModelMatrix();var outRay=Collider._ray;Vector3.transformCoordinate(ray.origin,worldToLocal,outRay.origin);Vector3.transformNormal(ray.direction,worldToLocal,outRay.direction);outRay.direction.normalize();return outRay;}/**
     * @internal
     */;_proto._raycast=function _raycast(ray,hit){throw "Error: use concrete type instead!";};return Collider;}(Component);Collider._ray=new Ray();/**
   * Axis Aligned Bound Box (AABB).
   * @extends Collider
   */var ABoxCollider=/*#__PURE__*/function(_Collider){_inheritsLoose$2(ABoxCollider,_Collider);/**
     * Constructor of ABoxCollider.
     * @param entity - Entity which the box belongs to
     */function ABoxCollider(entity){var _this;_this=_Collider.call(this,entity)||this;_this.boxMin=void 0;_this.boxMax=void 0;_this._corners=[];_this._cornerFlag=false;_this.boxMin=new Vector3(-0.5,-0.5,-0.5);_this.boxMax=new Vector3(0.5,0.5,0.5);return _this;}/**
     * Set box from the minimum point of the box and the maximum point of the box.
     * @param min - The minimum point of the box
     * @param max - The maximum point of the box
     */var _proto=ABoxCollider.prototype;_proto.setBoxMinMax=function setBoxMinMax(min,max){this.boxMin=min;this.boxMax=max;this._cornerFlag=true;}/**
     * Set box from the center point and the size of the bounding box.
     * @param center - The center point
     * @param size - The size of the bounding box
     */;_proto.setBoxCenterSize=function setBoxCenterSize(center,size){var halfSize=ABoxCollider._tempVec3;Vector3.scale(size,0.5,halfSize);Vector3.add(center,halfSize,this.boxMax);Vector3.subtract(center,halfSize,this.boxMin);this._cornerFlag=true;}/**
     * Get the eight corners of this bounding box.
     */;_proto.getCorners=function getCorners(){if(this._cornerFlag){var minX=this.boxMin.x;var minY=this.boxMin.y;var minZ=this.boxMin.z;var w=this.boxMax.x-minX;var h=this.boxMax.y-minY;var d=this.boxMax.z-minZ;if(this._corners.length===0){for(var i=0;i<8;++i){this._corners.push(new Vector3());}}this._corners[0].setValue(minX+w,minY+h,minZ+d);this._corners[1].setValue(minX,minY+h,minZ+d);this._corners[2].setValue(minX,minY,minZ+d);this._corners[3].setValue(minX+w,minY,minZ+d);this._corners[4].setValue(minX+w,minY+h,minZ);this._corners[5].setValue(minX,minY+h,minZ);this._corners[6].setValue(minX,minY,minZ);this._corners[7].setValue(minX+w,minY,minZ);this._cornerFlag=false;}return this._corners;// if (this._corners.length === 0) {
  //   const minX = this.boxMin.x;
  //   const minY = this.boxMin.y;
  //   const minZ = this.boxMin.z;
  //   const w = this.boxMax.x - minX;
  //   const h = this.boxMax.y - minY;
  //   const d = this.boxMax.z - minZ;
  //   this._corners = [
  //     new Vector3(minX + w, minY + h, minZ + d),
  //     new Vector3(minX, minY + h, minZ + d),
  //     new Vector3(minX, minY, minZ + d),
  //     new Vector3(minX + w, minY, minZ + d),
  //     new Vector3(minX + w, minY + h, minZ),
  //     new Vector3(minX, minY + h, minZ),
  //     new Vector3(minX, minY, minZ),
  //     new Vector3(minX + w, minY, minZ)
  //   ];
  // }
  // return this._corners;
  }/**
     * @internal
     */;_proto._raycast=function _raycast(ray,hit){var localRay=this._getLocalRay(ray);var boundingBox=ABoxCollider._tempBox;this.boxMin.cloneTo(boundingBox.min);this.boxMax.cloneTo(boundingBox.max);var intersect=localRay.intersectBox(boundingBox);if(intersect!==-1){this._updateHitResult(localRay,intersect,hit,ray.origin);return true;}else {return false;}// end of else
  };return ABoxCollider;}(Collider);ABoxCollider._tempVec3=new Vector3();ABoxCollider._tempBox=new BoundingBox();/**
   * Represents a plane in three dimensional space.
   */var PlaneCollider=/*#__PURE__*/function(_Collider){_inheritsLoose$2(PlaneCollider,_Collider);/**
     * Constructor of PlaneCollider.
     * @param entity - Entity which the plane belongs to
     */function PlaneCollider(entity){var _this;_this=_Collider.call(this,entity)||this;/** The point through the plane. */_this.planePoint=void 0;_this.normal=void 0;_this.planePoint=new Vector3();/** The normal direction of the plane. */_this.normal=new Vector3(0,1,0);return _this;}/**
     * Set a plane from point and normal.
     * @param  point - The point through the plane
     * @param  normal - The normal direction of the plane
     */var _proto=PlaneCollider.prototype;_proto.setPlane=function setPlane(point,normal){this.planePoint=point;this.normal=normal;}/**
     * @internal
     */;_proto._raycast=function _raycast(ray,hit){var localRay=this._getLocalRay(ray);var boundingPlane=PlaneCollider._tempPlane;this.normal.cloneTo(boundingPlane.normal);boundingPlane.distance=-Vector3.dot(this.planePoint,boundingPlane.normal);var intersect=localRay.intersectPlane(boundingPlane);if(intersect!==-1){this._updateHitResult(localRay,intersect,hit,ray.origin);return true;}else {return false;}// end of else
  };return PlaneCollider;}(Collider);PlaneCollider._tempPlane=new Plane();/**
   * A bounding sphere.
   */var ASphereCollider=/*#__PURE__*/function(_Collider){_inheritsLoose$2(ASphereCollider,_Collider);/**
     * Constructor of ASphereCollider.
     * @param  entity - Entity which the sphere belongs to
     */function ASphereCollider(entity){var _this;_this=_Collider.call(this,entity)||this;/** The center point of the sphere. */_this.center=void 0;_this.radius=void 0;_this.center=new Vector3();/** The radius of the sphere. */_this.radius=1;return _this;}/**
     * Set the center and radius of the sphere.
     * @param center - The center point of the sphere
     * @param radius - The radius of the sphere
     */var _proto=ASphereCollider.prototype;_proto.setSphere=function setSphere(center,radius){this.center=center;this.radius=radius;}/**
     * @internal
     */;_proto._raycast=function _raycast(ray,hit){var transform=this.entity.transform;var boundingSphere=ASphereCollider._tempSphere;Vector3.transformCoordinate(this.center,transform.worldMatrix,boundingSphere.center);var lossyScale=transform.lossyWorldScale;boundingSphere.radius=this.radius*Math.max(lossyScale.x,lossyScale.y,lossyScale.z);var intersect=ray.intersectSphere(boundingSphere);if(intersect!==-1){this._updateHitResult(ray,intersect,hit,ray.origin,true);return true;}else {return false;}};return ASphereCollider;}(Collider);ASphereCollider._tempSphere=new BoundingSphere();var BoxCollider=/*#__PURE__*/function(_ABoxCollider){_inheritsLoose$2(BoxCollider,_ABoxCollider);function BoxCollider(entity){var _this;_this=_ABoxCollider.call(this,entity)||this;_this._center=new Vector3();_this._size=new Vector3();_this.isShowCollider=true;_this.center=_this.center;_this.size=_this.size;_this.isShowCollider=_this.isShowCollider;return _this;}_createClass$3(BoxCollider,[{key:"center",get:function get(){return this._center;},set:function set(value){this._center=value;this.setBoxCenterSize(this._center,this._size);}},{key:"size",get:function get(){return this._size;},set:function set(value){this._size=value;this.setBoxCenterSize(this._center,this._size);}}]);return BoxCollider;}(ABoxCollider);var SphereCollider=/*#__PURE__*/function(_ASphereCollider){_inheritsLoose$2(SphereCollider,_ASphereCollider);function SphereCollider(entity){var _this;_this=_ASphereCollider.call(this,entity)||this;_this.__center=new Vector3();_this.__radius=1.0;_this.isShowCollider=true;_this._center=_this._center;_this._radius=_this._radius;_this.isShowCollider=_this.isShowCollider;return _this;}_createClass$3(SphereCollider,[{key:"_center",get:function get(){return this.__center;},set:function set(value){this.__center=value;this.setSphere(this.__center,this.__radius);}},{key:"_radius",get:function get(){return this.__radius;},set:function set(value){this.__radius=value;this.setSphere(this.__center,this.__radius);}}]);return SphereCollider;}(ASphereCollider);Scene.registerFeature(ColliderFeature);//-- colliders
  /**
   * Structure used to get information back from a raycast or a sweep.
   */var HitResult=function HitResult(){this.collider=null;this.distance=0;this.point=new Vector3();this.normal=new Vector3();};/*
   * Manager for physical scenes.
   */var PhysicsManager=/*#__PURE__*/function(){/**
     * @internal
     */function PhysicsManager(engine){this._engine=void 0;this._engine=engine;}/**
     * Casts a ray through the Scene and returns the first hit.
     * @param ray - The ray
     * @returns Returns true if the ray intersects with a Collider, otherwise false.
     */var _proto=PhysicsManager.prototype;_proto.raycast=function raycast(ray,distanceOrResult,layerMaskOrResult,outHitResult){var cf=this._engine.sceneManager.activeScene.findFeature(ColliderFeature);var colliders=cf.colliders;var hitResult;var distance=Number.MAX_VALUE;if(typeof distanceOrResult==="number"){distance=distanceOrResult;}else if(distanceOrResult!=undefined){hitResult=distanceOrResult;}var layerMask=exports.Layer.Everything;if(typeof layerMaskOrResult==="number"){layerMask=layerMaskOrResult;}else if(layerMaskOrResult!=undefined){hitResult=layerMaskOrResult;}if(outHitResult){hitResult=outHitResult;}var isHit=false;var curHit=PhysicsManager._currentHit;for(var i=0,len=colliders.length;i<len;i++){var collider=colliders[i];if(!(collider.entity.layer&layerMask)){continue;}if(collider._raycast(ray,curHit)){isHit=true;if(curHit.distance<distance){if(hitResult){curHit.normal.cloneTo(hitResult.normal);curHit.point.cloneTo(hitResult.point);hitResult.distance=curHit.distance;hitResult.collider=curHit.collider;}else {return true;}distance=curHit.distance;}}}if(!isHit&&hitResult){hitResult.collider=null;hitResult.distance=0;hitResult.point.setValue(0,0,0);hitResult.normal.setValue(0,0,0);}return isHit;};return PhysicsManager;}();PhysicsManager._currentHit=new HitResult();/** TODO: delete */var engineFeatureManager=new FeatureManager();ShaderPool.init();/**
   * Engine.
   */var Engine=/*#__PURE__*/function(_EventDispatcher){_inheritsLoose$2(Engine,_EventDispatcher);/**
     * Create engine.
     * @param canvas - The canvas to use for rendering
     * @param hardwareRenderer - Graphics API renderer
     */function Engine(canvas,hardwareRenderer){var _this;_this=_EventDispatcher.call(this,null)||this;_this.physicsManager=new PhysicsManager(_assertThisInitialized$1(_this));_this._componentsManager=new ComponentsManager();_this._hardwareRenderer=void 0;_this._lastRenderState=new RenderState();_this._renderElementPool=new ClassPool(RenderElement);_this._spriteElementPool=new ClassPool(SpriteElement);_this._spriteMaskElementPool=new ClassPool(SpriteMaskElement);_this._spriteDefaultMaterial=void 0;_this._spriteMaskDefaultMaterial=void 0;_this._renderContext=new RenderContext();_this._whiteTexture2D=void 0;_this._whiteTextureCube=void 0;_this._backgroundTextureMaterial=void 0;_this._backgroundTextureMesh=void 0;_this._renderCount=0;_this._shaderProgramPools=[];_this._spriteMaskManager=void 0;_this._canvas=void 0;_this._resourceManager=new ResourceManager(_assertThisInitialized$1(_this));_this._sceneManager=new SceneManager$1(_assertThisInitialized$1(_this));_this._vSyncCount=1;_this._targetFrameRate=60;_this._time=new Time();_this._isPaused=true;_this._requestId=void 0;_this._timeoutId=void 0;_this._vSyncCounter=1;_this._targetFrameInterval=1000/60;_this._animate=function(){if(_this._vSyncCount){_this._requestId=requestAnimationFrame(_this._animate);if(_this._vSyncCounter++%_this._vSyncCount===0){_this.update();_this._vSyncCounter=1;}}else {_this._timeoutId=window.setTimeout(_this._animate,_this._targetFrameInterval);_this.update();}};_this.features=[];_this._hardwareRenderer=hardwareRenderer;_this._hardwareRenderer.init(canvas);_this._canvas=canvas;// @todo delete
  engineFeatureManager.addObject(_assertThisInitialized$1(_this));_this._sceneManager.activeScene=new Scene(_assertThisInitialized$1(_this),"DefaultScene");_this._spriteMaskManager=new SpriteMaskManager(_assertThisInitialized$1(_this));_this._spriteDefaultMaterial=_this._createSpriteMaterial();_this._spriteMaskDefaultMaterial=_this._createSpriteMaskMaterial();var whitePixel=new Uint8Array([255,255,255,255]);var whiteTexture2D=new Texture2D(_assertThisInitialized$1(_this),1,1,exports.TextureFormat.R8G8B8A8,false);whiteTexture2D.setPixelBuffer(whitePixel);whiteTexture2D.isGCIgnored=true;var whiteTextureCube=new TextureCubeMap(_assertThisInitialized$1(_this),1,exports.TextureFormat.R8G8B8A8,false);whiteTextureCube.setPixelBuffer(exports.TextureCubeFace.PositiveX,whitePixel);whiteTextureCube.setPixelBuffer(exports.TextureCubeFace.NegativeX,whitePixel);whiteTextureCube.setPixelBuffer(exports.TextureCubeFace.PositiveY,whitePixel);whiteTextureCube.setPixelBuffer(exports.TextureCubeFace.NegativeY,whitePixel);whiteTextureCube.setPixelBuffer(exports.TextureCubeFace.PositiveZ,whitePixel);whiteTextureCube.setPixelBuffer(exports.TextureCubeFace.NegativeZ,whitePixel);whiteTextureCube.isGCIgnored=true;_this._whiteTexture2D=whiteTexture2D;_this._whiteTextureCube=whiteTextureCube;_this._backgroundTextureMaterial=new Material(_assertThisInitialized$1(_this),Shader.find("background-texture"));_this._backgroundTextureMaterial.isGCIgnored=true;_this._backgroundTextureMaterial.renderState.depthState.compareFunction=exports.CompareFunction.LessEqual;_this._backgroundTextureMesh=PrimitiveMesh.createPlane(_assertThisInitialized$1(_this),2,2,1,1,false);_this._backgroundTextureMesh.isGCIgnored=true;return _this;}/**
     * Create an entity.
     * @param name - The name of the entity
     * @returns Entity
     */var _proto=Engine.prototype;_proto.createEntity=function createEntity(name){return new Entity(this,name);}/**
     * Pause the engine.
     */;_proto.pause=function pause(){this._isPaused=true;cancelAnimationFrame(this._requestId);clearTimeout(this._timeoutId);}/**
     * Resume the engine.
     */;_proto.resume=function resume(){if(!this._isPaused)return;this._isPaused=false;this.time.reset();requestAnimationFrame(this._animate);}/**
     * Update the engine loop manually. If you call engine.run(), you generally don't need to call this function.
     */;_proto.update=function update(){var time=this._time;var deltaTime=time.deltaTime;time.tick();this._renderElementPool.resetPool();this._spriteElementPool.resetPool();this._spriteMaskElementPool.resetPool();engineFeatureManager.callFeatureMethod(this,"preTick",[this,this._sceneManager._activeScene]);var scene=this._sceneManager._activeScene;var componentsManager=this._componentsManager;if(scene){componentsManager.callScriptOnStart();componentsManager.callScriptOnUpdate(deltaTime);componentsManager.callAnimationUpdate(deltaTime);componentsManager.callScriptOnLateUpdate(deltaTime);this._render(scene);}this._componentsManager.callComponentDestroy();engineFeatureManager.callFeatureMethod(this,"postTick",[this,this._sceneManager._activeScene]);}/**
     * Execution engine loop.
     */;_proto.run=function run(){// @todo: delete
  engineFeatureManager.callFeatureMethod(this,"preLoad",[this]);this.resume();this.trigger(new Event("run",this));}/**
     * Destroy engine.
     */;_proto.destroy=function destroy(){if(this._sceneManager){this._whiteTexture2D.destroy(true);this._whiteTextureCube.destroy(true);this.trigger(new Event("shutdown",this));engineFeatureManager.callFeatureMethod(this,"shutdown",[this]);// -- cancel animation
  this.pause();this._animate=null;this._sceneManager._activeScene.destroy();this._resourceManager.gc();// If engine destroy, callComponentDestroy() maybe will not call anymore.
  this._componentsManager.callComponentDestroy();this._sceneManager=null;this._resourceManager=null;this._canvas=null;this.features=[];this._time=null;// delete mask manager
  this._spriteMaskManager.destroy();// todo: delete
  engineFeatureManager._objects=[];this.removeAllEventListeners();}}/**
     * @internal
     */;_proto._getShaderProgramPool=function _getShaderProgramPool(shader){var index=shader._shaderId;var shaderProgramPools=this._shaderProgramPools;var pool=shaderProgramPools[index];if(!pool){var length=index+1;if(length<shaderProgramPools.length){shaderProgramPools.length=length;}shaderProgramPools[index]=pool=new ShaderProgramPool();}return pool;};_proto._render=function _render(scene){var cameras=scene._activeCameras;var componentsManager=this._componentsManager;var deltaTime=this.time.deltaTime;componentsManager.callRendererOnUpdate(deltaTime);scene._updateShaderData();if(cameras.length>0){// Sort on priority
  //@ts-ignore
  cameras.sort(function(camera1,camera2){return camera1.priority-camera2.priority;});for(var i=0,l=cameras.length;i<l;i++){var camera=cameras[i];var cameraEntity=camera.entity;if(camera.enabled&&cameraEntity.isActiveInHierarchy){componentsManager.callCameraOnBeginRender(camera);Scene.sceneFeatureManager.callFeatureMethod(scene,"preRender",[scene,camera]);//TODO: will be removed
  camera.render();Scene.sceneFeatureManager.callFeatureMethod(scene,"postRender",[scene,camera]);//TODO: will be removed
  componentsManager.callCameraOnEndRender(camera);}}}else {Logger.debug("NO active camera.");}};_proto._createSpriteMaterial=function _createSpriteMaterial(){var material=new Material(this,Shader.find("Sprite"));var renderState=material.renderState;var target=renderState.blendState.targetBlendState;target.enabled=true;target.sourceColorBlendFactor=exports.BlendFactor.SourceAlpha;target.destinationColorBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;target.sourceAlphaBlendFactor=exports.BlendFactor.One;target.destinationAlphaBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;target.colorBlendOperation=target.alphaBlendOperation=exports.BlendOperation.Add;renderState.depthState.writeEnabled=false;renderState.rasterState.cullMode=exports.CullMode.Off;material.renderQueueType=exports.RenderQueueType.Transparent;material.isGCIgnored=true;return material;};_proto._createSpriteMaskMaterial=function _createSpriteMaskMaterial(){var material=new Material(this,Shader.find("SpriteMask"));var renderState=material.renderState;renderState.blendState.targetBlendState.colorWriteMask=exports.ColorWriteMask.None;renderState.rasterState.cullMode=exports.CullMode.Off;renderState.stencilState.enabled=true;renderState.depthState.enabled=false;material.isGCIgnored=true;return material;}//-----------------------------------------@deprecated-----------------------------------
  ;_proto.findFeature=function findFeature(Feature){return engineFeatureManager.findFeature(this,Feature);};Engine.registerFeature=function registerFeature(Feature){engineFeatureManager.registerFeature(Feature);};_createClass$3(Engine,[{key:"canvas",get:/** Physics manager of Engine. */ /* @internal */ /* @internal */ /* @internal */ /* @internal */ /* @internal */ /* @internal */ /** @internal */ /**
       * The canvas to use for rendering.
       */function get(){return this._canvas;}/**
       * Get the resource manager.
       */},{key:"resourceManager",get:function get(){return this._resourceManager;}/**
       * Get the scene manager.
       */},{key:"sceneManager",get:function get(){return this._sceneManager;}/**
       * Get the Time class.
       */},{key:"time",get:function get(){return this._time;}/**
       * Whether the engine is paused.
       */},{key:"isPaused",get:function get(){return this._isPaused;}/**
       * The number of vertical synchronization means the number of vertical blanking for one frame.
       * @remarks 0 means that the vertical synchronization is turned off.
       */},{key:"vSyncCount",get:function get(){return this._vSyncCount;},set:function set(value){this._vSyncCount=Math.max(0,Math.floor(value));}/**
       * Set the target frame rate you want to achieve.
       * @remarks
       * It only takes effect when vSyncCount = 0 (ie, vertical synchronization is turned off).
       * The larger the value, the higher the target frame rate, Number.POSITIVE_INFINITY represents the infinite target frame rate.
       */},{key:"targetFrameRate",get:function get(){return this._targetFrameRate;},set:function set(value){value=Math.max(0.000001,value);this._targetFrameRate=value;this._targetFrameInterval=1000/value;}}]);return Engine;}(EventDispatcher);/**
   * System info.
   */var SystemInfo=/*#__PURE__*/function(){function SystemInfo(){}/**
     * @internal
     */SystemInfo._isIos=function _isIos(){if(!window){return false;}var ua=window.navigator.userAgent.toLocaleLowerCase();return /iphone|ipad|ipod/.test(ua);};_createClass$3(SystemInfo,null,[{key:"devicePixelRatio",get:/**
       * The pixel ratio of the device.
       */function get(){return window.devicePixelRatio;}}]);return SystemInfo;}();/**
   * Engine feature plug-in.
   * @deprecated
   */var EngineFeature=/*#__PURE__*/function(){function EngineFeature(){}var _proto=EngineFeature.prototype;/**
     * Callback before the engine main loop runs,used to load resource.
     * @param engine - Engine
     */_proto.preLoad=function preLoad(engine){}/**
     * Callback before every engine tick.
     * @param engine - Engine
     * @param currentScene - Scene
     */;_proto.preTick=function preTick(engine,currentScene){}/**
     * Callback after every engine tick.
     * @param  engine - Engine
     */;_proto.postTick=function postTick(engine,currentScene){}/**
     * Callback after the engine is destroyed.
     * @param engine - Engine
     */;_proto.shutdown=function shutdown(engine){};return EngineFeature;}();var _class$3$1,_descriptor$3,_descriptor2$3,_descriptor3$3,_descriptor4$3,_descriptor5$3,_descriptor6$3,_descriptor7$3;/**
   * Script class, used for logic writing.
   */var Script=(_class$3$1=/*#__PURE__*/function(_Component){_inheritsLoose$2(Script,_Component);function Script(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Component.call.apply(_Component,[this].concat(args))||this;_initializerDefineProperty(_this,"_started",_descriptor$3,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_onStartIndex",_descriptor2$3,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_onUpdateIndex",_descriptor3$3,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_onLateUpdateIndex",_descriptor4$3,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_onPreRenderIndex",_descriptor5$3,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_onPostRenderIndex",_descriptor6$3,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_entityCacheIndex",_descriptor7$3,_assertThisInitialized$1(_this));return _this;}var _proto=Script.prototype;/**
     * Called when be enabled first time, only once.
     */_proto.onAwake=function onAwake(){}/**
     * Called when be enabled.
     */;_proto.onEnable=function onEnable(){}/**
     * Called before the frame-level loop start for the first time, only once.
     */;_proto.onStart=function onStart(){}/**
     * The main loop, called frame by frame.
     * @param deltaTime - The deltaTime when the script update.
     */;_proto.onUpdate=function onUpdate(deltaTime){}/**
     * Called after the onUpdate finished, called frame by frame.
     * @param deltaTime - The deltaTime when the script update.
     */;_proto.onLateUpdate=function onLateUpdate(deltaTime){}/**
     * Called before camera rendering, called per camera.
     * @param camera - Current camera.
     */;_proto.onBeginRender=function onBeginRender(camera){}/**
     * Called after camera rendering, called per camera.
     * @param camera - Current camera.
     */;_proto.onEndRender=function onEndRender(camera){}/**
     * Called when the collision enter.
     * @param other Collider
     */;_proto.onTriggerEnter=function onTriggerEnter(other){}/**
     * Called when the collision stay.
     * @remarks onTriggerStay is called every frame while the collision stay.
     * @param other Collider
     */;_proto.onTriggerStay=function onTriggerStay(other){}/**
     * Called when the collision exit.
     * @param other Collider
     */;_proto.onTriggerExit=function onTriggerExit(other){}/**
     * Called when the pointer is down while over the Collider.
     */;_proto.onPointerDown=function onPointerDown(){}/**
     * Called when the pointer is up while over the Collider.
     */;_proto.onPointerUp=function onPointerUp(){}/**
     * Called when the pointer is down and up with the same collider.
     */;_proto.onPointerClick=function onPointerClick(){}/**
     * Called when the pointer is enters the Collider.
     */;_proto.onPointerEnter=function onPointerEnter(){}/**
     * Called when the pointer is no longer over the Collider.
     */;_proto.onPointerExit=function onPointerExit(){}/**
     * Called when the pointer is down while over the Collider and is still holding down.
     * @remarks onPointerDrag is called every frame while the pointer is down.
     */;_proto.onPointerDrag=function onPointerDrag(){}/**
     * Called when be disabled.
     */;_proto.onDisable=function onDisable(){}/**
     * Called at the end of the destroyed frame.
     */;_proto.onDestroy=function onDestroy(){}/**
     * @internal
     * @inheritDoc
     * @override
     */;_proto._onAwake=function _onAwake(){this.onAwake();}/**
     * @internal
     * @inheritDoc
     * @override
     */;_proto._onEnable=function _onEnable(){var componentsManager=this.engine._componentsManager;var prototype=Script.prototype;if(!this._started){componentsManager.addOnStartScript(this);}if(this.onUpdate!==prototype.onUpdate){componentsManager.addOnUpdateScript(this);}if(this.onLateUpdate!==prototype.onLateUpdate){componentsManager.addOnLateUpdateScript(this);}this._entity._addScript(this);this.onEnable();}/**
     * @internal
     * @inheritDoc
     * @override
     */;_proto._onDisable=function _onDisable(){var componentsManager=this.engine._componentsManager;// Use "xxIndex" is more safe.
  // When call onDisable it maybe it still not in script queue,for example write "entity.isActive = false" in onWake().
  if(this._onStartIndex!==-1){componentsManager.removeOnStartScript(this);}if(this._onUpdateIndex!==-1){componentsManager.removeOnUpdateScript(this);}if(this._onLateUpdateIndex!==-1){componentsManager.removeOnLateUpdateScript(this);}if(this._entityCacheIndex!==-1){this._entity._removeScript(this);}this.onDisable();}/**
     * @internal
     * @inheritDoc
     * @override
     */;_proto._onDestroy=function _onDestroy(){this.engine._componentsManager.addDestroyComponent(this);};return Script;}(Component),(_descriptor$3=_applyDecoratedDescriptor$1(_class$3$1.prototype,"_started",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor2$3=_applyDecoratedDescriptor$1(_class$3$1.prototype,"_onStartIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_descriptor3$3=_applyDecoratedDescriptor$1(_class$3$1.prototype,"_onUpdateIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_descriptor4$3=_applyDecoratedDescriptor$1(_class$3$1.prototype,"_onLateUpdateIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_descriptor5$3=_applyDecoratedDescriptor$1(_class$3$1.prototype,"_onPreRenderIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_descriptor6$3=_applyDecoratedDescriptor$1(_class$3$1.prototype,"_onPostRenderIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}}),_descriptor7$3=_applyDecoratedDescriptor$1(_class$3$1.prototype,"_entityCacheIndex",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return -1;}})),_class$3$1);/**
   * Camera clear flags enumeration.
   */exports.CameraClearFlags = void 0;(function(CameraClearFlags){CameraClearFlags[CameraClearFlags["DepthColor"]=0]="DepthColor";CameraClearFlags[CameraClearFlags["Depth"]=1]="Depth";CameraClearFlags[CameraClearFlags["None"]=2]="None";})(exports.CameraClearFlags||(exports.CameraClearFlags={}));var passNum=0;/**
   * RenderPass.
   */var RenderPass=/*#__PURE__*/function(){/**
     * Create a RenderPass.
     * @param name - Pass name
     * @param priority - Priority, less than 0 before the default pass, greater than 0 after the default pass
     * @param renderTarget - The specified Render Target
     * @param replaceMaterial -  Replaced material
     * @param mask - Perform bit and operations with Entity.Layer to filter the objects that this Pass needs to render
     */function RenderPass(name,priority,renderTarget,replaceMaterial,mask){if(name===void 0){name="RENDER_PASS"+passNum++;}if(priority===void 0){priority=0;}if(renderTarget===void 0){renderTarget=null;}if(replaceMaterial===void 0){replaceMaterial=null;}if(mask===void 0){mask=null;}this.name=void 0;this.enabled=void 0;this.priority=void 0;this.renderTarget=void 0;this.replaceMaterial=void 0;this.mask=void 0;this.renderOverride=void 0;this.clearFlags=void 0;this.clearColor=void 0;this.name=name;this.enabled=true;this.priority=priority;this.renderTarget=renderTarget;this.replaceMaterial=replaceMaterial;this.mask=mask||exports.Layer.Everything;this.renderOverride=false;// If renderOverride is set to true, you need to implement the render method
  }/**
     * Rendering callback, will be executed if renderOverride is set to true.
     * @param camera - Camera
     * @param opaqueQueue - Opaque queue
     * @param alphaTestQueue - Alpha test queue
     * @param transparentQueue - Transparent queue
     */var _proto=RenderPass.prototype;_proto.render=function render(camera,opaqueQueue,alphaTestQueue,transparentQueue){}/**
     * Post rendering callback.
     * @param camera - Camera
     * @param opaqueQueue - Opaque queue
     * @param alphaTestQueue - Alpha test queue
     * @param transparentQueue - Transparent queue
     */;_proto.preRender=function preRender(camera,opaqueQueue,alphaTestQueue,transparentQueue){}/**
     * Post rendering callback.
     * @param camera - Camera
     * @param opaqueQueue - Opaque queue
     * @param alphaTestQueue - Alpha test queue
     * @param transparentQueue - Transparent queue
     */;_proto.postRender=function postRender(camera,opaqueQueue,alphaTestQueue,transparentQueue){};return RenderPass;}();/**
   * @internal
   */var SpriteBatcher=/*#__PURE__*/function(_Basic2DBatcher){_inheritsLoose$2(SpriteBatcher,_Basic2DBatcher);function SpriteBatcher(){return _Basic2DBatcher.apply(this,arguments)||this;}var _proto=SpriteBatcher.prototype;_proto.createVertexElements=function createVertexElements(vertexElements){vertexElements[0]=new VertexElement("POSITION",0,exports.VertexElementFormat.Vector3,0);vertexElements[1]=new VertexElement("TEXCOORD_0",12,exports.VertexElementFormat.Vector2,0);vertexElements[2]=new VertexElement("COLOR_0",20,exports.VertexElementFormat.Vector4,0);return 36;};_proto.canBatch=function canBatch(preElement,curElement){var preRenderer=preElement.component;var curRenderer=curElement.component;// Compare mask
  if(!this.checkBatchWithMask(preRenderer,curRenderer)){return false;}// Compare renderer property
  var textureProperty=SpriteBatcher._textureProperty;if(preRenderer.shaderData.getTexture(textureProperty)!==curRenderer.shaderData.getTexture(textureProperty)){return false;}// Compare material
  return preElement.material===curElement.material;};_proto.checkBatchWithMask=function checkBatchWithMask(left,right){var leftMaskInteraction=left.maskInteraction;if(leftMaskInteraction!==right.maskInteraction){return false;}if(leftMaskInteraction===exports.SpriteMaskInteraction.None){return true;}return left.maskLayer===right.maskLayer;};_proto.updateVertices=function updateVertices(element,vertices,vertexIndex){var positions=element.positions,uv=element.uv,color=element.color;var verticesNum=positions.length;for(var i=0;i<verticesNum;i++){var curPos=positions[i];var curUV=uv[i];vertices[vertexIndex++]=curPos.x;vertices[vertexIndex++]=curPos.y;vertices[vertexIndex++]=curPos.z;vertices[vertexIndex++]=curUV.x;vertices[vertexIndex++]=curUV.y;vertices[vertexIndex++]=color.r;vertices[vertexIndex++]=color.g;vertices[vertexIndex++]=color.b;vertices[vertexIndex++]=color.a;}return vertexIndex;};_proto.drawBatches=function drawBatches(engine){var mesh=this._meshes[this._flushId];var subMeshes=mesh.subMeshes;var batchedQueue=this._batchedQueue;var maskManager=engine._spriteMaskManager;for(var i=0,len=subMeshes.length;i<len;i++){var subMesh=subMeshes[i];var spriteElement=batchedQueue[i];if(!subMesh||!spriteElement){return;}var renderer=spriteElement.component;var camera=spriteElement.camera;var material=spriteElement.material;maskManager.preRender(camera,renderer);var compileMacros=Shader._compileMacros;// union render global macro and material self macro.
  ShaderMacroCollection.unionCollection(renderer._globalShaderMacro,material.shaderData._macroCollection,compileMacros);var program=material.shader._getShaderProgram(engine,compileMacros);if(!program.isValid){return;}program.bind();program.groupingOtherUniformBlock();program.uploadAll(program.sceneUniformBlock,camera.scene.shaderData);program.uploadAll(program.cameraUniformBlock,camera.shaderData);program.uploadAll(program.rendererUniformBlock,renderer.shaderData);program.uploadAll(program.materialUniformBlock,material.shaderData);material.renderState._apply(engine);engine._hardwareRenderer.drawPrimitive(mesh,subMesh,program);maskManager.postRender(renderer);}};_proto.destroy=function destroy(){this._batchedQueue=null;var meshes=this._meshes,vertexBuffers=this._vertexBuffers,indiceBuffers=this._indiceBuffers;for(var i=0,n=meshes.length;i<n;++i){meshes[i].destroy();}this._meshes=null;for(var _i=0,_n=vertexBuffers.length;_i<_n;++_i){vertexBuffers[_i].destroy();}this._vertexBuffers=null;for(var _i2=0,_n2=indiceBuffers.length;_i2<_n2;++_i2){indiceBuffers[_i2].destroy();}this._indiceBuffers=null;};return SpriteBatcher;}(Basic2DBatcher);SpriteBatcher._textureProperty=Shader.getPropertyByName("u_spriteTexture");/**
   * Render queue.
   */var RenderQueue=/*#__PURE__*/function(){/**
     * @internal
     */RenderQueue._compareFromNearToFar=function _compareFromNearToFar(a,b){return a.material.renderQueueType-b.material.renderQueueType||a.component._distanceForSort-b.component._distanceForSort||b.component._renderSortId-a.component._renderSortId;}/**
     * @internal
     */;RenderQueue._compareFromFarToNear=function _compareFromFarToNear(a,b){return a.material.renderQueueType-b.material.renderQueueType||b.component._distanceForSort-a.component._distanceForSort||b.component._renderSortId-a.component._renderSortId;};function RenderQueue(engine){this.items=[];this._spriteBatcher=void 0;this._spriteBatcher=new SpriteBatcher(engine);}/**
     * Push a render element.
     */var _proto=RenderQueue.prototype;_proto.pushPrimitive=function pushPrimitive(element){this.items.push(element);};_proto.render=function render(camera,replaceMaterial,mask){var items=this.items;if(items.length===0){return;}var engine=camera.engine,scene=camera.scene;var renderCount=engine._renderCount;var rhi=engine._hardwareRenderer;var sceneData=scene.shaderData;var cameraData=camera.shaderData;for(var i=0,n=items.length;i<n;i++){var item=items[i];var renderPassFlag=item.component.entity.layer;if(!(renderPassFlag&mask)){continue;}if(!!item.mesh){this._spriteBatcher.flush(engine);var compileMacros=Shader._compileMacros;var element=item;var renderer=element.component;var material=replaceMaterial?replaceMaterial:element.material;var rendererData=renderer.shaderData;var materialData=material.shaderData;// @todo: temporary solution
  material._preRender(element);// union render global macro and material self macro.
  ShaderMacroCollection.unionCollection(renderer._globalShaderMacro,materialData._macroCollection,compileMacros);var program=material.shader._getShaderProgram(engine,compileMacros);if(!program.isValid){continue;}var switchProgram=program.bind();var switchRenderCount=renderCount!==program._uploadRenderCount;if(switchRenderCount){program.groupingOtherUniformBlock();program.uploadAll(program.sceneUniformBlock,sceneData);program.uploadAll(program.cameraUniformBlock,cameraData);program.uploadAll(program.rendererUniformBlock,rendererData);program.uploadAll(program.materialUniformBlock,materialData);// Ungroup textures should upload default value, texture uint maybe change by logic of texture bind.
  program.uploadUngroupTextures();program._uploadCamera=camera;program._uploadRenderer=renderer;program._uploadMaterial=material;program._uploadRenderCount=renderCount;}else {if(program._uploadCamera!==camera){program.uploadAll(program.cameraUniformBlock,cameraData);program._uploadCamera=camera;}else if(switchProgram){program.uploadTextures(program.cameraUniformBlock,cameraData);}if(program._uploadRenderer!==renderer){program.uploadAll(program.rendererUniformBlock,rendererData);program._uploadRenderer=renderer;}else if(switchProgram){program.uploadTextures(program.rendererUniformBlock,rendererData);}if(program._uploadMaterial!==material){program.uploadAll(program.materialUniformBlock,materialData);program._uploadMaterial=material;}else if(switchProgram){program.uploadTextures(program.materialUniformBlock,materialData);}// We only consider switchProgram case, because ungroup texture's value is always default.
  if(switchProgram){program.uploadUngroupTextures();}}material.renderState._apply(camera.engine);rhi.drawPrimitive(element.mesh,element.subMesh,program);}else {var spriteElement=item;this._spriteBatcher.drawElement(spriteElement);}}this._spriteBatcher.flush(engine);}/**
     * Clear collection.
     */;_proto.clear=function clear(){this.items.length=0;this._spriteBatcher.clear();}/**
     * Destroy internal resources.
     */;_proto.destroy=function destroy(){this._spriteBatcher.destroy();this._spriteBatcher=null;}/**
     * Sort the elements.
     */;_proto.sort=function sort(compareFunc){this._quickSort(this.items,0,this.items.length,compareFunc);}/**
     * @remarks
     * Modified based on v8.
     * https://github.com/v8/v8/blob/7.2-lkgr/src/js/array.js
     */;_proto._quickSort=function _quickSort(a,from,to,compareFunc){while(true){// Insertion sort is faster for short arrays.
  if(to-from<=10){this._insertionSort(a,from,to,compareFunc);return;}var third_index=from+to>>1;// Find a pivot as the median of first, last and middle element.
  var v0=a[from];var v1=a[to-1];var v2=a[third_index];var c01=compareFunc(v0,v1);if(c01>0){// v1 < v0, so swap them.
  var tmp=v0;v0=v1;v1=tmp;}// v0 <= v1.
  var c02=compareFunc(v0,v2);if(c02>=0){// v2 <= v0 <= v1.
  var _tmp=v0;v0=v2;v2=v1;v1=_tmp;}else {// v0 <= v1 && v0 < v2
  var c12=compareFunc(v1,v2);if(c12>0){// v0 <= v2 < v1
  var _tmp2=v1;v1=v2;v2=_tmp2;}}// v0 <= v1 <= v2
  a[from]=v0;a[to-1]=v2;var pivot=v1;var low_end=from+1;// Upper bound of elements lower than pivot.
  var high_start=to-1;// Lower bound of elements greater than pivot.
  a[third_index]=a[low_end];a[low_end]=pivot;// From low_end to i are elements equal to pivot.
  // From i to high_start are elements that haven't been compared yet.
  partition:for(var i=low_end+1;i<high_start;i++){var element=a[i];var order=compareFunc(element,pivot);if(order<0){a[i]=a[low_end];a[low_end]=element;low_end++;}else if(order>0){do{high_start--;if(high_start==i)break partition;var top_elem=a[high_start];order=compareFunc(top_elem,pivot);}while(order>0);a[i]=a[high_start];a[high_start]=element;if(order<0){element=a[i];a[i]=a[low_end];a[low_end]=element;low_end++;}}}if(to-high_start<low_end-from){this._quickSort(a,high_start,to,compareFunc);to=low_end;}else {this._quickSort(a,from,low_end,compareFunc);from=high_start;}}};_proto._insertionSort=function _insertionSort(a,from,to,compareFunc){for(var i=from+1;i<to;i++){var j=void 0;var element=a[i];for(j=i-1;j>=from;j--){var tmp=a[j];var order=compareFunc(tmp,element);if(order>0){a[j+1]=tmp;}else {break;}}a[j+1]=element;}};return RenderQueue;}();/**
   * Basic render pipeline.
   */var BasicRenderPipeline=/*#__PURE__*/function(){/** @internal */ /** @internal */ /** @internal */ /** @internal */ /**
     * Create a basic render pipeline.
     * @param camera - Camera
     */function BasicRenderPipeline(camera){this._opaqueQueue=void 0;this._transparentQueue=void 0;this._alphaTestQueue=void 0;this._allSpriteMasks=new DisorderedArray();this._camera=void 0;this._defaultPass=void 0;this._renderPassArray=void 0;this._lastCanvasSize=new Vector2();this._camera=camera;var engine=camera.engine;this._opaqueQueue=new RenderQueue(engine);this._alphaTestQueue=new RenderQueue(engine);this._transparentQueue=new RenderQueue(engine);this._renderPassArray=[];this._defaultPass=new RenderPass("default",0,null,null,0);this.addRenderPass(this._defaultPass);}/**
     * Default render pass.
     */var _proto=BasicRenderPipeline.prototype;/**
     * Add render pass.
     * @param nameOrPass - The name of this Pass or RenderPass object. When it is a name, the following parameters need to be provided
     * @param priority - Priority, less than 0 before the default pass, greater than 0 after the default pass
     * @param renderTarget - The specified Render Target
     * @param replaceMaterial -  Replaced material
     * @param mask - Perform bit and operations with Entity.Layer to filter the objects that this Pass needs to render
     */_proto.addRenderPass=function addRenderPass(nameOrPass,priority,renderTarget,replaceMaterial,mask){if(priority===void 0){priority=null;}if(renderTarget===void 0){renderTarget=null;}if(replaceMaterial===void 0){replaceMaterial=null;}if(mask===void 0){mask=null;}if(typeof nameOrPass==="string"){var renderPass=new RenderPass(nameOrPass,priority,renderTarget,replaceMaterial,mask);this._renderPassArray.push(renderPass);}else if(nameOrPass instanceof RenderPass){this._renderPassArray.push(nameOrPass);}this._renderPassArray.sort(function(p1,p2){return p1.priority-p2.priority;});}/**
     * Remove render pass by name or render pass object.
     * @param nameOrPass - Render pass name or render pass object
     */;_proto.removeRenderPass=function removeRenderPass(nameOrPass){var pass;if(typeof nameOrPass==="string")pass=this.getRenderPass(nameOrPass);else if(nameOrPass instanceof RenderPass)pass=nameOrPass;if(pass){var idx=this._renderPassArray.indexOf(pass);this._renderPassArray.splice(idx,1);}}/**
     * Get render pass by name.
     * @param  name - Render pass name
     */;_proto.getRenderPass=function getRenderPass(name){for(var i=0,len=this._renderPassArray.length;i<len;i++){var pass=this._renderPassArray[i];if(pass.name===name)return pass;}return null;}/**
     * Destroy internal resources.
     */;_proto.destroy=function destroy(){this._opaqueQueue.destroy();this._alphaTestQueue.destroy();this._transparentQueue.destroy();this._allSpriteMasks=null;this._renderPassArray=null;this._defaultPass=null;this._camera=null;}/**
     * Perform scene rendering.
     * @param context - Render context
     * @param cubeFace - Render surface of cube texture
     */;_proto.render=function render(context,cubeFace){var camera=this._camera;var opaqueQueue=this._opaqueQueue;var alphaTestQueue=this._alphaTestQueue;var transparentQueue=this._transparentQueue;camera.engine._spriteMaskManager.clear();opaqueQueue.clear();alphaTestQueue.clear();transparentQueue.clear();this._allSpriteMasks.length=0;camera.engine._componentsManager.callRender(context);opaqueQueue.sort(RenderQueue._compareFromNearToFar);alphaTestQueue.sort(RenderQueue._compareFromNearToFar);transparentQueue.sort(RenderQueue._compareFromFarToNear);for(var i=0,len=this._renderPassArray.length;i<len;i++){this._drawRenderPass(this._renderPassArray[i],camera,cubeFace);}};_proto._drawRenderPass=function _drawRenderPass(pass,camera,cubeFace){pass.preRender(camera,this._opaqueQueue,this._alphaTestQueue,this._transparentQueue);if(pass.enabled){var _pass$clearFlags,_pass$clearColor;var engine=camera.engine,scene=camera.scene;var background=scene.background;var rhi=engine._hardwareRenderer;var renderTarget=camera.renderTarget||pass.renderTarget;rhi.activeRenderTarget(renderTarget,camera);renderTarget===null||renderTarget===void 0?void 0:renderTarget._setRenderTargetFace(cubeFace);var clearFlags=(_pass$clearFlags=pass.clearFlags)!=null?_pass$clearFlags:camera.clearFlags;var color=(_pass$clearColor=pass.clearColor)!=null?_pass$clearColor:background.solidColor;if(clearFlags!==exports.CameraClearFlags.None){rhi.clearRenderTarget(camera.engine,clearFlags,color);}if(pass.renderOverride){pass.render(camera,this._opaqueQueue,this._alphaTestQueue,this._transparentQueue);}else {this._opaqueQueue.render(camera,pass.replaceMaterial,pass.mask);this._alphaTestQueue.render(camera,pass.replaceMaterial,pass.mask);if(background.mode===exports.BackgroundMode.Sky){this._drawSky(engine,camera,background.sky);}else if(background.mode===exports.BackgroundMode.Texture&&background.texture){this._drawBackgroundTexture(engine,background);}this._transparentQueue.render(camera,pass.replaceMaterial,pass.mask);}renderTarget===null||renderTarget===void 0?void 0:renderTarget._blitRenderTarget();renderTarget===null||renderTarget===void 0?void 0:renderTarget.generateMipmaps();}pass.postRender(camera,this._opaqueQueue,this._alphaTestQueue,this._transparentQueue);}/**
     * Push a render element to the render queue.
     * @param element - Render element
     */;_proto.pushPrimitive=function pushPrimitive(element){var renderQueueType=element.material.renderQueueType;if(renderQueueType>exports.RenderQueueType.Transparent+exports.RenderQueueType.AlphaTest>>1){this._transparentQueue.pushPrimitive(element);}else if(renderQueueType>exports.RenderQueueType.AlphaTest+exports.RenderQueueType.Opaque>>1){this._alphaTestQueue.pushPrimitive(element);}else {this._opaqueQueue.pushPrimitive(element);}};_proto._drawBackgroundTexture=function _drawBackgroundTexture(engine,background){var rhi=engine._hardwareRenderer;var _backgroundTextureMaterial=engine._backgroundTextureMaterial,_backgroundTextureMesh=engine._backgroundTextureMesh,canvas=engine.canvas;if((this._lastCanvasSize.x!==canvas.width||this._lastCanvasSize.y!==canvas.height)&&background._textureFillMode!==BackgroundTextureFillMode.Fill){this._lastCanvasSize.setValue(canvas.width,canvas.height);background._resizeBackgroundTexture();}var program=_backgroundTextureMaterial.shader._getShaderProgram(engine,Shader._compileMacros);program.bind();program.uploadAll(program.materialUniformBlock,_backgroundTextureMaterial.shaderData);program.uploadUngroupTextures();_backgroundTextureMaterial.renderState._apply(engine);rhi.drawPrimitive(_backgroundTextureMesh,_backgroundTextureMesh.subMesh,program);};_proto._drawSky=function _drawSky(engine,camera,sky){var material=sky.material,mesh=sky.mesh,_matrix=sky._matrix;if(!material){Logger.warn("The material of sky is not defined.");return;}if(!mesh){Logger.warn("The mesh of sky is not defined.");return;}var rhi=engine._hardwareRenderer;var shaderData=material.shaderData,shader=material.shader,renderState=material.renderState;var compileMacros=Shader._compileMacros;ShaderMacroCollection.unionCollection(camera._globalShaderMacro,shaderData._macroCollection,compileMacros);var viewMatrix=camera.viewMatrix,projectionMatrix=camera.projectionMatrix;viewMatrix.cloneTo(_matrix);var e=_matrix.elements;e[12]=e[13]=e[14]=0;Matrix.multiply(projectionMatrix,_matrix,_matrix);shaderData.setMatrix("u_mvpNoscale",_matrix);var program=shader._getShaderProgram(engine,compileMacros);program.bind();program.groupingOtherUniformBlock();program.uploadAll(program.materialUniformBlock,shaderData);program.uploadUngroupTextures();renderState._apply(engine);rhi.drawPrimitive(mesh,mesh.subMesh,program);};_createClass$3(BasicRenderPipeline,[{key:"defaultRenderPass",get:function get(){return this._defaultPass;}}]);return BasicRenderPipeline;}();var _dec$k,_class$2$1,_class2$2,_descriptor$2,_descriptor2$2,_descriptor3$2,_descriptor4$2,_descriptor5$2,_descriptor6$2,_descriptor7$2,_descriptor8$1,_descriptor9$1,_descriptor10$1,_descriptor11$1,_descriptor12$1,_class3,_temp$2;var MathTemp=function MathTemp(){};/**
   * Camera component, as the entrance to the three-dimensional world.
   */MathTemp.tempMat4=new Matrix();MathTemp.tempVec4=new Vector4();MathTemp.tempVec3=new Vector3();MathTemp.tempVec2=new Vector2();var Camera=(_dec$k=dependencies(Transform),_dec$k(_class$2$1=(_class2$2=(_temp$2=_class3=/*#__PURE__*/function(_Component){_inheritsLoose$2(Camera,_Component);/**
     * Create the Camera component.
     * @param entity - Entity
     */function Camera(entity){var _this;_this=_Component.call(this,entity)||this;_this.shaderData=new ShaderData(ShaderDataGroup.Camera);_this.priority=0;_this.enableFrustumCulling=true;_this.clearFlags=exports.CameraClearFlags.DepthColor;_this.cullingMask=exports.Layer.Everything;_this._globalShaderMacro=new ShaderMacroCollection();_initializerDefineProperty(_this,"_frustum",_descriptor$2,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_renderPipeline",_descriptor2$2,_assertThisInitialized$1(_this));_this._isOrthographic=false;_this._isProjMatSetting=false;_this._nearClipPlane=0.1;_this._farClipPlane=100;_this._fieldOfView=45;_this._orthographicSize=10;_this._isProjectionDirty=true;_this._isInvProjMatDirty=true;_this._isFrustumProjectDirty=true;_this._customAspectRatio=undefined;_this._renderTarget=null;_initializerDefineProperty(_this,"_frustumViewChangeFlag",_descriptor3$2,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_transform",_descriptor4$2,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_isViewMatrixDirty",_descriptor5$2,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_isInvViewProjDirty",_descriptor6$2,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_projectionMatrix",_descriptor7$2,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_viewMatrix",_descriptor8$1,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_viewport",_descriptor9$1,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_inverseProjectionMatrix",_descriptor10$1,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_lastAspectSize",_descriptor11$1,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_invViewProjMat",_descriptor12$1,_assertThisInitialized$1(_this));var transform=_this.entity.transform;_this._transform=transform;_this._isViewMatrixDirty=transform.registerWorldChangeFlag();_this._isInvViewProjDirty=transform.registerWorldChangeFlag();_this._frustumViewChangeFlag=transform.registerWorldChangeFlag();_this._renderPipeline=new BasicRenderPipeline(_assertThisInitialized$1(_this));_this.shaderData._addRefCount(1);return _this;}/**
     * Restore the automatic calculation of projection matrix through fieldOfView, nearClipPlane and farClipPlane.
     */var _proto=Camera.prototype;_proto.resetProjectionMatrix=function resetProjectionMatrix(){this._isProjMatSetting=false;this._projMatChange();}/**
     * Restore the automatic calculation of the aspect ratio through the viewport aspect ratio.
     */;_proto.resetAspectRatio=function resetAspectRatio(){this._customAspectRatio=undefined;this._projMatChange();}/**
     * Transform a point from world space to viewport space.
     * @param point - Point in world space
     * @param out - A point in the viewport space, X and Y are the viewport space coordinates, Z is the viewport depth, the near clipping plane is 0, the far clipping plane is 1, and W is the world unit distance from the camera
     * @returns Point in viewport space
     */;_proto.worldToViewportPoint=function worldToViewportPoint(point,out){Matrix.multiply(this.projectionMatrix,this.viewMatrix,MathTemp.tempMat4);MathTemp.tempVec4.setValue(point.x,point.y,point.z,1.0);Vector4.transform(MathTemp.tempVec4,MathTemp.tempMat4,MathTemp.tempVec4);var w=MathTemp.tempVec4.w;var nx=MathTemp.tempVec4.x/w;var ny=MathTemp.tempVec4.y/w;var nz=MathTemp.tempVec4.z/w;// Transform of coordinate axis.
  out.x=(nx+1.0)*0.5;out.y=(1.0-ny)*0.5;out.z=nz;out.w=w;return out;}/**
     * Transform a point from viewport space to world space.
     * @param point - Point in viewport space, X and Y are the viewport space coordinates, Z is the viewport depth. The near clipping plane is 0, and the far clipping plane is 1
     * @param out - Point in world space
     * @returns Point in world space
     */;_proto.viewportToWorldPoint=function viewportToWorldPoint(point,out){var invViewProjMat=this.invViewProjMat;return this._innerViewportToWorldPoint(point,invViewProjMat,out);}/**
     * Generate a ray by a point in viewport.
     * @param point - Point in viewport space, which is represented by normalization
     * @param out - Ray
     * @returns Ray
     */;_proto.viewportPointToRay=function viewportPointToRay(point,out){var clipPoint=MathTemp.tempVec3;// Use the intersection of the near clipping plane as the origin point.
  clipPoint.setValue(point.x,point.y,0);var origin=this.viewportToWorldPoint(clipPoint,out.origin);// Use the intersection of the far clipping plane as the origin point.
  clipPoint.z=1.0;var farPoint=this._innerViewportToWorldPoint(clipPoint,this._invViewProjMat,clipPoint);Vector3.subtract(farPoint,origin,out.direction);out.direction.normalize();return out;}/**
     * Transform the X and Y coordinates of a point from screen space to viewport space
     * @param point - Point in screen space
     * @param out - Point in viewport space
     * @returns Point in viewport space
     */;_proto.screenToViewportPoint=function screenToViewportPoint(point,out){var canvas=this.engine.canvas;var viewport=this.viewport;out.x=(point.x/canvas.width-viewport.x)/viewport.z;out.y=(point.y/canvas.height-viewport.y)/viewport.w;return out;}/**
     * Transform the X and Y coordinates of a point from viewport space to screen space.
     * @param point - Point in viewport space
     * @param out - Point in screen space
     * @returns Point in screen space
     */;_proto.viewportToScreenPoint=function viewportToScreenPoint(point,out){var canvas=this.engine.canvas;var viewport=this.viewport;out.x=(viewport.x+point.x*viewport.z)*canvas.width;out.y=(viewport.y+point.y*viewport.w)*canvas.height;return out;}/**
     * Transform a point from world space to screen space.
     * @param point - Point in world space
     * @param out - Point of screen space
     * @returns Point of screen space
     */;_proto.worldToScreenPoint=function worldToScreenPoint(point,out){this.worldToViewportPoint(point,out);return this.viewportToScreenPoint(out,out);}/**
     * Transform a point from screen space to world space.
     * @param point - Screen space point
     * @param out - Point in world space
     * @returns Point in world space
     */;_proto.screenToWorldPoint=function screenToWorldPoint(point,out){this.screenToViewportPoint(point,out);return this.viewportToWorldPoint(out,out);}/**
     * Generate a ray by a point in screen.
     * @param point - Point in screen space, the unit is pixel
     * @param out - Ray
     * @returns Ray
     */;_proto.screenPointToRay=function screenPointToRay(point,out){var viewportPoint=MathTemp.tempVec2;this.screenToViewportPoint(point,viewportPoint);return this.viewportPointToRay(viewportPoint,out);}/**
     * Manually call the rendering of the camera.
     * @param cubeFace - Cube rendering surface collection
     */;_proto.render=function render(cubeFace){// compute cull frustum.
  var context=this.engine._renderContext;context._setContext(this);if(this.enableFrustumCulling&&(this._frustumViewChangeFlag.flag||this._isFrustumProjectDirty)){this._frustum.calculateFromMatrix(context._viewProjectMatrix);this._frustumViewChangeFlag.flag=false;this._isFrustumProjectDirty=false;}this._updateShaderData(context);// union scene and camera macro.
  ShaderMacroCollection.unionCollection(this.scene.shaderData._macroCollection,this.shaderData._macroCollection,this._globalShaderMacro);this._renderPipeline.render(context,cubeFace);this._engine._renderCount++;}/**
     * @override
     * @inheritdoc
     */;_proto._onActive=function _onActive(){this.entity.scene._attachRenderCamera(this);}/**
     * @override
     * @inheritdoc
     */;_proto._onInActive=function _onInActive(){this.entity.scene._detachRenderCamera(this);}/**
     * @override
     * @inheritdoc
     */;_proto._onDestroy=function _onDestroy(){var _this$_renderPipeline;(_this$_renderPipeline=this._renderPipeline)===null||_this$_renderPipeline===void 0?void 0:_this$_renderPipeline.destroy();this._isInvViewProjDirty.destroy();this._isViewMatrixDirty.destroy();this.shaderData._addRefCount(-1);};_proto._projMatChange=function _projMatChange(){this._isFrustumProjectDirty=true;this._isProjectionDirty=true;this._isInvProjMatDirty=true;this._isInvViewProjDirty.flag=true;};_proto._innerViewportToWorldPoint=function _innerViewportToWorldPoint(point,invViewProjMat,out){// Depth is a normalized value, 0 is nearPlane, 1 is farClipPlane.
  var depth=point.z*2-1;// Transform to clipping space matrix
  var clipPoint=MathTemp.tempVec4;clipPoint.setValue(point.x*2-1,1-point.y*2,depth,1);Vector4.transform(clipPoint,invViewProjMat,clipPoint);var invW=1.0/clipPoint.w;out.x=clipPoint.x*invW;out.y=clipPoint.y*invW;out.z=clipPoint.z*invW;return out;};_proto._updateShaderData=function _updateShaderData(context){var shaderData=this.shaderData;shaderData.setMatrix(Camera._viewMatrixProperty,this.viewMatrix);shaderData.setMatrix(Camera._projectionMatrixProperty,this.projectionMatrix);shaderData.setMatrix(Camera._vpMatrixProperty,context._viewProjectMatrix);shaderData.setMatrix(Camera._inverseViewMatrixProperty,this._transform.worldMatrix);shaderData.setMatrix(Camera._inverseProjectionMatrixProperty,this.inverseProjectionMatrix);shaderData.setVector3(Camera._cameraPositionProperty,this._transform.worldPosition);}/**
     * @private
     * The inverse matrix of view projection matrix.
     */;_createClass$3(Camera,[{key:"nearClipPlane",get:/** Shader data. */ /** Rendering priority - A Camera with higher priority will be rendered on top of a camera with lower priority. */ /** Whether to enable frustum culling, it is enabled by default. */ /**
       * Determining what to clear when rendering by a Camera.
       * @defaultValue `CameraClearFlags.DepthColor`
       */ /**
       * Culling mask - which layers the camera renders.
       * @remarks Support bit manipulation, corresponding to Entity's layer.
       */ /** @internal */ /** @internal */ /** @internal */ /**
       * Near clip plane - the closest point to the camera when rendering occurs.
       */function get(){return this._nearClipPlane;},set:function set(value){this._nearClipPlane=value;this._projMatChange();}/**
       * Far clip plane - the furthest point to the camera when rendering occurs.
       */},{key:"farClipPlane",get:function get(){return this._farClipPlane;},set:function set(value){this._farClipPlane=value;this._projMatChange();}/**
       * The camera's view angle. activating when camera use perspective projection.
       */},{key:"fieldOfView",get:function get(){return this._fieldOfView;},set:function set(value){this._fieldOfView=value;this._projMatChange();}/**
       * Aspect ratio. The default is automatically calculated by the viewport's aspect ratio. If it is manually set,
       * the manual value will be kept. Call resetAspectRatio() to restore it.
       */},{key:"aspectRatio",get:function get(){var _this$_customAspectRa;var canvas=this._entity.engine.canvas;return (_this$_customAspectRa=this._customAspectRatio)!=null?_this$_customAspectRa:canvas.width*this._viewport.z/(canvas.height*this._viewport.w);},set:function set(value){this._customAspectRatio=value;this._projMatChange();}/**
       * Viewport, normalized expression, the upper left corner is (0, 0), and the lower right corner is (1, 1).
       * @remarks Re-assignment is required after modification to ensure that the modification takes effect.
       */},{key:"viewport",get:function get(){return this._viewport;},set:function set(value){if(value!==this._viewport){value.cloneTo(this._viewport);}this._projMatChange();}/**
       * Whether it is orthogonal, the default is false. True will use orthographic projection, false will use perspective projection.
       */},{key:"isOrthographic",get:function get(){return this._isOrthographic;},set:function set(value){this._isOrthographic=value;this._projMatChange();}/**
       * Half the size of the camera in orthographic mode.
       */},{key:"orthographicSize",get:function get(){return this._orthographicSize;},set:function set(value){this._orthographicSize=value;this._projMatChange();}/**
       * View matrix.
       */},{key:"viewMatrix",get:function get(){// Remove scale
  if(this._isViewMatrixDirty.flag){this._isViewMatrixDirty.flag=false;Matrix.invert(this._transform.worldMatrix,this._viewMatrix);}return this._viewMatrix;}/**
       * The projection matrix is ​​calculated by the relevant parameters of the camera by default.
       * If it is manually set, the manual value will be maintained. Call resetProjectionMatrix() to restore it.
       */},{key:"projectionMatrix",get:function get(){var canvas=this._entity.engine.canvas;if((!this._isProjectionDirty||this._isProjMatSetting)&&this._lastAspectSize.x===canvas.width&&this._lastAspectSize.y===canvas.height){return this._projectionMatrix;}this._isProjectionDirty=false;this._lastAspectSize.x=canvas.width;this._lastAspectSize.y=canvas.height;var aspectRatio=this.aspectRatio;if(!this._isOrthographic){Matrix.perspective(MathUtil.degreeToRadian(this._fieldOfView),aspectRatio,this._nearClipPlane,this._farClipPlane,this._projectionMatrix);}else {var width=this._orthographicSize*aspectRatio;var height=this._orthographicSize;Matrix.ortho(-width,width,-height,height,this._nearClipPlane,this._farClipPlane,this._projectionMatrix);}return this._projectionMatrix;}/**
       * Whether to enable HDR.
       * @todo When render pipeline modification
       */,set:function set(value){this._projectionMatrix=value;this._isProjMatSetting=true;this._projMatChange();}},{key:"enableHDR",get:function get(){console.log("not implementation");return false;},set:function set(value){console.log("not implementation");}/**
       * RenderTarget. After setting, it will be rendered to the renderTarget. If it is empty, it will be rendered to the main canvas.
       */},{key:"renderTarget",get:function get(){return this._renderTarget;},set:function set(value){this._renderTarget=value;}},{key:"invViewProjMat",get:function get(){if(this._isInvViewProjDirty.flag){this._isInvViewProjDirty.flag=false;Matrix.multiply(this._transform.worldMatrix,this.inverseProjectionMatrix,this._invViewProjMat);}return this._invViewProjMat;}/**
       * @private
       * The inverse of the projection matrix.
       */},{key:"inverseProjectionMatrix",get:function get(){if(this._isInvProjMatDirty){this._isInvProjMatDirty=false;Matrix.invert(this.projectionMatrix,this._inverseProjectionMatrix);}return this._inverseProjectionMatrix;}}]);return Camera;}(Component),_class3._viewMatrixProperty=Shader.getPropertyByName("u_viewMat"),_class3._projectionMatrixProperty=Shader.getPropertyByName("u_projMat"),_class3._vpMatrixProperty=Shader.getPropertyByName("u_VPMat"),_class3._inverseViewMatrixProperty=Shader.getPropertyByName("u_viewInvMat"),_class3._inverseProjectionMatrixProperty=Shader.getPropertyByName("u_projInvMat"),_class3._cameraPositionProperty=Shader.getPropertyByName("u_cameraPos"),_temp$2),(_descriptor$2=_applyDecoratedDescriptor$1(_class2$2.prototype,"_frustum",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new BoundingFrustum();}}),_descriptor2$2=_applyDecoratedDescriptor$1(_class2$2.prototype,"_renderPipeline",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor3$2=_applyDecoratedDescriptor$1(_class2$2.prototype,"_frustumViewChangeFlag",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor4$2=_applyDecoratedDescriptor$1(_class2$2.prototype,"_transform",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor5$2=_applyDecoratedDescriptor$1(_class2$2.prototype,"_isViewMatrixDirty",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor6$2=_applyDecoratedDescriptor$1(_class2$2.prototype,"_isInvViewProjDirty",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor7$2=_applyDecoratedDescriptor$1(_class2$2.prototype,"_projectionMatrix",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor8$1=_applyDecoratedDescriptor$1(_class2$2.prototype,"_viewMatrix",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor9$1=_applyDecoratedDescriptor$1(_class2$2.prototype,"_viewport",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Vector4(0,0,1,1);}}),_descriptor10$1=_applyDecoratedDescriptor$1(_class2$2.prototype,"_inverseProjectionMatrix",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}}),_descriptor11$1=_applyDecoratedDescriptor$1(_class2$2.prototype,"_lastAspectSize",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Vector2(0,0);}}),_descriptor12$1=_applyDecoratedDescriptor$1(_class2$2.prototype,"_invViewProjMat",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Matrix();}})),_class2$2))||_class$2$1);var mimeType={json:"json",gltf:"json",mtl:"json",prefab:"json",txt:"text",bin:"arraybuffer",png:"image",webp:"image",jpg:"image"};var defaultRetryCount=4;var defaultTimeout=15000;var defaultInterval=500;/**
   * Web request.
   * @param url - The link
   * @param config - Load configuration
   */function request(url,config){if(config===void 0){config={};}return new AssetPromise(function(resolve,reject,setProgress){var _config$retryCount,_config$retryInterval,_config$timeout,_config$type;var retryCount=(_config$retryCount=config.retryCount)!=null?_config$retryCount:defaultRetryCount;var retryInterval=(_config$retryInterval=config.retryInterval)!=null?_config$retryInterval:defaultInterval;config.timeout=(_config$timeout=config.timeout)!=null?_config$timeout:defaultTimeout;config.type=(_config$type=config.type)!=null?_config$type:getMimeTypeFromUrl(url);var realRequest=config.type==="image"?requestImage:requestRes;var lastError;var executor=new MultiExecutor(function(){return realRequest(url,config).onProgress(setProgress).then(function(res){resolve(res);executor.stop();}).catch(function(err){return lastError=err;});},retryCount,retryInterval);executor.start(function(){reject(lastError);});});}function requestImage(url,config){return new AssetPromise(function(resolve,reject){var timeout=config.timeout;var img=new Image();var onerror=function onerror(){reject(new Error("request "+url+" fail"));};img.onerror=onerror;img.onabort=onerror;var timeoutId=setTimeout(function(){reject(new Error("request "+url+" timeout"));},timeout);img.onload=function(timeoutId){return function(){// Call requestAnimationFrame to avoid iOS's bug.
  requestAnimationFrame(function(){//@ts-ignore
  resolve(img);img.onload=null;img.onerror=null;img.onabort=null;});clearTimeout(timeoutId);};}(timeoutId);img.crossOrigin="anonymous";img.src=url;});}function requestRes(url,config){return new AssetPromise(function(resolve,reject,setProgress){var _config$method;var xhr=new XMLHttpRequest();xhr.timeout=config.timeout;config.method=(_config$method=config.method)!=null?_config$method:"get";xhr.onload=function(){var _xhr$response;if(xhr.status<200||xhr.status>=300){reject(new Error("request failed from: "+url));return;}var result=(_xhr$response=xhr.response)!=null?_xhr$response:xhr.responseText;resolve(result);};xhr.onerror=function(){reject(new Error("request failed from: "+url));};xhr.ontimeout=function(){reject(new Error("request timeout from: "+url));};xhr.onprogress=function(e){setProgress(e.loaded/e.total);};xhr.open(config.method,url,true);xhr.withCredentials=config.credentials==="include";//@ts-ignore
  xhr.responseType=config.type;var headers=config.headers;if(headers){Object.keys(headers).forEach(function(name){xhr.setRequestHeader(name,headers[name]);});}xhr.send(config.body);});}function getMimeTypeFromUrl(url){var extname=url.substring(url.lastIndexOf(".")+1);return mimeType[extname];}var MultiExecutor=/*#__PURE__*/function(){function MultiExecutor(execFunc,totalCount,interval){this.execFunc=execFunc;this.totalCount=totalCount;this.interval=interval;this._timeoutId=-100;this._currentCount=0;this.done=void 0;this.exec=this.exec.bind(this);}var _proto=MultiExecutor.prototype;_proto.start=function start(done){this.done=done;this.exec();};_proto.stop=function stop(){clearTimeout(this._timeoutId);};_proto.exec=function exec(){var _this=this;if(this._currentCount>=this.totalCount){this.done&&this.done();return;}this._currentCount++;this.execFunc(this._currentCount).then(function(){//@ts-ignore
  _this._timeoutId=setTimeout(_this.exec,_this.interval);});};return MultiExecutor;}();/**
   * Loader abstract class.
   */var Loader=function Loader(useCache){this.useCache=useCache;this.request=request;};/**
   * Asset Type.
   */exports.AssetType = void 0;(function(AssetType){AssetType["Text"]="text";AssetType["JSON"]="json";AssetType["Buffer"]="buffer";AssetType["Texture2D"]="texture2d";AssetType["TextureCube"]="texture-cube";AssetType["Material"]="material";AssetType["Mesh"]="mesh";AssetType["AnimationClip"]="animation-clip";AssetType["Prefab"]="prefab";AssetType["KTX"]="ktx";AssetType["KTXCube"]="ktx-cube";AssetType["SpriteAtlas"]="sprite-atlas";})(exports.AssetType||(exports.AssetType={}));/**
   * Set which face for render.
   */exports.RenderFace = void 0;(function(RenderFace){RenderFace[RenderFace["Front"]=0]="Front";RenderFace[RenderFace["Back"]=1]="Back";RenderFace[RenderFace["Double"]=2]="Double";})(exports.RenderFace||(exports.RenderFace={}));/**
   * Alpha blend mode.
   */exports.BlendMode = void 0;(function(BlendMode){BlendMode[BlendMode["Normal"]=0]="Normal";BlendMode[BlendMode["Additive"]=1]="Additive";})(exports.BlendMode||(exports.BlendMode={}));var BaseMaterial=/*#__PURE__*/function(_Material){_inheritsLoose$2(BaseMaterial,_Material);/**
     * Create a BaseMaterial instance.
     * @param engine - Engine to which the material belongs
     * @param shader - Shader used by the material
     */function BaseMaterial(engine,shader){var _this;_this=_Material.call(this,engine,shader)||this;_this._renderFace=exports.RenderFace.Front;_this._isTransparent=false;_this._blendMode=void 0;_this.blendMode=exports.BlendMode.Normal;_this.shaderData.setFloat(BaseMaterial._alphaCutoffProp,0);return _this;}/**
     * @override
     * Clone and return the instance.
     */var _proto=BaseMaterial.prototype;_proto.clone=function clone(){var dest=new BaseMaterial(this._engine,this.shader);this.cloneTo(dest);return dest;}/**
     * @override
     * Clone to the target material.
     * @param target - target material
     */;_proto.cloneTo=function cloneTo(target){_Material.prototype.cloneTo.call(this,target);target._renderFace=this._renderFace;target._isTransparent=this._isTransparent;target._blendMode=this._blendMode;};_createClass$3(BaseMaterial,[{key:"isTransparent",get:/**
       * Is this material transparent.
       * @remarks
       * If material is transparent, transparent blend mode will be affected by `blendMode`, default is `BlendMode.Normal`.
       */function get(){return this._isTransparent;},set:function set(value){if(value===this._isTransparent)return;this._isTransparent=value;var _this$renderState=this.renderState,depthState=_this$renderState.depthState,targetBlendState=_this$renderState.blendState.targetBlendState;if(value){targetBlendState.enabled=true;depthState.writeEnabled=false;this.renderQueueType=exports.RenderQueueType.Transparent;}else {targetBlendState.enabled=false;depthState.writeEnabled=true;this.renderQueueType=this.shaderData.getFloat(BaseMaterial._alphaCutoffProp)?exports.RenderQueueType.AlphaTest:exports.RenderQueueType.Opaque;}}/**
       * Alpha cutoff value.
       * @remarks
       * Fragments with alpha channel lower than cutoff value will be discarded.
       * `0` means no fragment will be discarded.
       */},{key:"alphaCutoff",get:function get(){return this.shaderData.getFloat(BaseMaterial._alphaCutoffProp);},set:function set(value){this.shaderData.setFloat(BaseMaterial._alphaCutoffProp,value);if(value>0){this.shaderData.enableMacro(BaseMaterial._alphaCutoffMacro);this.renderQueueType=this._isTransparent?exports.RenderQueueType.Transparent:exports.RenderQueueType.AlphaTest;}else {this.shaderData.disableMacro(BaseMaterial._alphaCutoffMacro);this.renderQueueType=this._isTransparent?exports.RenderQueueType.Transparent:exports.RenderQueueType.Opaque;}}/**
       * Set which face for render.
       */},{key:"renderFace",get:function get(){return this._renderFace;},set:function set(value){if(value===this._renderFace)return;this._renderFace=value;switch(value){case exports.RenderFace.Front:this.renderState.rasterState.cullMode=exports.CullMode.Back;break;case exports.RenderFace.Back:this.renderState.rasterState.cullMode=exports.CullMode.Front;break;case exports.RenderFace.Double:this.renderState.rasterState.cullMode=exports.CullMode.Off;break;}}/**
       * Alpha blend mode.
       * @remarks
       * Only take effect when `isTransparent` is `true`.
       */},{key:"blendMode",get:function get(){return this._blendMode;},set:function set(value){if(value===this._blendMode)return;this._blendMode=value;var target=this.renderState.blendState.targetBlendState;switch(value){case exports.BlendMode.Normal:target.sourceColorBlendFactor=exports.BlendFactor.SourceAlpha;target.destinationColorBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;target.sourceAlphaBlendFactor=exports.BlendFactor.One;target.destinationAlphaBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;target.colorBlendOperation=target.alphaBlendOperation=exports.BlendOperation.Add;break;case exports.BlendMode.Additive:target.sourceColorBlendFactor=exports.BlendFactor.SourceAlpha;target.destinationColorBlendFactor=exports.BlendFactor.One;target.sourceAlphaBlendFactor=exports.BlendFactor.One;target.destinationAlphaBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;target.colorBlendOperation=target.alphaBlendOperation=exports.BlendOperation.Add;break;}}}]);return BaseMaterial;}(Material);BaseMaterial._alphaCutoffMacro=Shader.getMacroByName("ALPHA_CUTOFF");BaseMaterial._alphaCutoffProp=Shader.getPropertyByName("u_alphaCutoff");/**
   * Blinn-phong Material.
   */var BlinnPhongMaterial=/*#__PURE__*/function(_BaseMaterial){_inheritsLoose$2(BlinnPhongMaterial,_BaseMaterial);function BlinnPhongMaterial(engine){var _this;_this=_BaseMaterial.call(this,engine,Shader.find("blinn-phong"))||this;var shaderData=_this.shaderData;shaderData.enableMacro("O3_NEED_WORLDPOS");shaderData.enableMacro("O3_NEED_TILINGOFFSET");shaderData.setColor(BlinnPhongMaterial._diffuseColorProp,new Color(1,1,1,1));shaderData.setColor(BlinnPhongMaterial._specularColorProp,new Color(1,1,1,1));shaderData.setColor(BlinnPhongMaterial._emissiveColorProp,new Color(0,0,0,1));shaderData.setVector4(BlinnPhongMaterial._tilingOffsetProp,new Vector4(1,1,0,0));shaderData.setFloat(BlinnPhongMaterial._shininessProp,16);shaderData.setFloat(BlinnPhongMaterial._normalIntensityProp,1);return _this;}/**
     * @override
     */var _proto=BlinnPhongMaterial.prototype;_proto.clone=function clone(){var dest=new BlinnPhongMaterial(this._engine);this.cloneTo(dest);return dest;};_createClass$3(BlinnPhongMaterial,[{key:"baseColor",get:/**
       * Base color.
       */function get(){return this.shaderData.getColor(BlinnPhongMaterial._diffuseColorProp);},set:function set(value){var baseColor=this.shaderData.getColor(BlinnPhongMaterial._diffuseColorProp);if(value!==baseColor){value.cloneTo(baseColor);}}/**
       * Base texture.
       */},{key:"baseTexture",get:function get(){return this.shaderData.getTexture(BlinnPhongMaterial._baseTextureProp);},set:function set(value){this.shaderData.setTexture(BlinnPhongMaterial._baseTextureProp,value);if(value){this.shaderData.enableMacro("O3_DIFFUSE_TEXTURE");}else {this.shaderData.disableMacro("O3_DIFFUSE_TEXTURE");}}/**
       * Specular color.
       */},{key:"specularColor",get:function get(){return this.shaderData.getColor(BlinnPhongMaterial._specularColorProp);},set:function set(value){var specularColor=this.shaderData.getColor(BlinnPhongMaterial._specularColorProp);if(value!==specularColor){value.cloneTo(specularColor);}}/**
       * Specular texture.
       */},{key:"specularTexture",get:function get(){return this.shaderData.getTexture(BlinnPhongMaterial._specularTextureProp);},set:function set(value){this.shaderData.setTexture(BlinnPhongMaterial._specularTextureProp,value);if(value){this.shaderData.enableMacro("O3_SPECULAR_TEXTURE");}else {this.shaderData.disableMacro("O3_SPECULAR_TEXTURE");}}/**
       * Emissive color.
       */},{key:"emissiveColor",get:function get(){return this.shaderData.getColor(BlinnPhongMaterial._emissiveColorProp);},set:function set(value){var emissiveColor=this.shaderData.getColor(BlinnPhongMaterial._emissiveColorProp);if(value!==emissiveColor){value.cloneTo(emissiveColor);}}/**
       * Emissive texture.
       */},{key:"emissiveTexture",get:function get(){return this.shaderData.getTexture(BlinnPhongMaterial._emissiveTextureProp);},set:function set(value){this.shaderData.setTexture(BlinnPhongMaterial._emissiveTextureProp,value);if(value){this.shaderData.enableMacro("O3_EMISSIVE_TEXTURE");}else {this.shaderData.disableMacro("O3_EMISSIVE_TEXTURE");}}/**
       * Normal texture.
       */},{key:"normalTexture",get:function get(){return this.shaderData.getTexture(BlinnPhongMaterial._normalTextureProp);},set:function set(value){this.shaderData.setTexture(BlinnPhongMaterial._normalTextureProp,value);if(value){this.shaderData.enableMacro("O3_NORMAL_TEXTURE");}else {this.shaderData.disableMacro("O3_NORMAL_TEXTURE");}}/**
       * Normal texture intensity.
       */},{key:"normalIntensity",get:function get(){return this.shaderData.getFloat(BlinnPhongMaterial._normalIntensityProp);},set:function set(value){this.shaderData.setFloat(BlinnPhongMaterial._normalIntensityProp,value);}/**
       * Set the specular reflection coefficient, the larger the value, the more convergent the specular reflection effect.
       */},{key:"shininess",get:function get(){return this.shaderData.getFloat(BlinnPhongMaterial._shininessProp);},set:function set(value){this.shaderData.setFloat(BlinnPhongMaterial._shininessProp,value);}/**
       * Tiling and offset of main textures.
       */},{key:"tilingOffset",get:function get(){return this.shaderData.getVector4(BlinnPhongMaterial._tilingOffsetProp);},set:function set(value){var tilingOffset=this.shaderData.getVector4(BlinnPhongMaterial._tilingOffsetProp);if(value!==tilingOffset){value.cloneTo(tilingOffset);}}}]);return BlinnPhongMaterial;}(BaseMaterial);BlinnPhongMaterial._diffuseColorProp=Shader.getPropertyByName("u_diffuseColor");BlinnPhongMaterial._specularColorProp=Shader.getPropertyByName("u_specularColor");BlinnPhongMaterial._emissiveColorProp=Shader.getPropertyByName("u_emissiveColor");BlinnPhongMaterial._tilingOffsetProp=Shader.getPropertyByName("u_tilingOffset");BlinnPhongMaterial._shininessProp=Shader.getPropertyByName("u_shininess");BlinnPhongMaterial._normalIntensityProp=Shader.getPropertyByName("u_normalIntensity");BlinnPhongMaterial._baseTextureProp=Shader.getPropertyByName("u_diffuseTexture");BlinnPhongMaterial._specularTextureProp=Shader.getPropertyByName("u_specularTexture");BlinnPhongMaterial._emissiveTextureProp=Shader.getPropertyByName("u_emissiveTexture");BlinnPhongMaterial._normalTextureProp=Shader.getPropertyByName("u_normalTexture");/**
   * PBR (Physically-Based Rendering) Material.
   */var PBRBaseMaterial=/*#__PURE__*/function(_BaseMaterial){_inheritsLoose$2(PBRBaseMaterial,_BaseMaterial);/**
     * Create a pbr base material instance.
     * @param engine - Engine to which the material belongs
     */function PBRBaseMaterial(engine){var _this;_this=_BaseMaterial.call(this,engine,Shader.find("pbr"))||this;var shaderData=_this.shaderData;shaderData.enableMacro("O3_NEED_WORLDPOS");shaderData.enableMacro("O3_NEED_TILINGOFFSET");shaderData.setColor(PBRBaseMaterial._baseColorProp,new Color(1,1,1,1));shaderData.setColor(PBRBaseMaterial._emissiveColorProp,new Color(0,0,0,1));shaderData.setVector4(PBRBaseMaterial._tilingOffsetProp,new Vector4(1,1,0,0));shaderData.setFloat(PBRBaseMaterial._normalTextureIntensityProp,1);shaderData.setFloat(PBRBaseMaterial._occlusionTextureIntensityProp,1);return _this;}_createClass$3(PBRBaseMaterial,[{key:"baseColor",get:/**
       * Base color.
       */function get(){return this.shaderData.getColor(PBRBaseMaterial._baseColorProp);},set:function set(value){var baseColor=this.shaderData.getColor(PBRBaseMaterial._baseColorProp);if(value!==baseColor){value.cloneTo(baseColor);}}/**
       * Base texture.
       */},{key:"baseTexture",get:function get(){return this.shaderData.getTexture(PBRBaseMaterial._baseTextureProp);},set:function set(value){this.shaderData.setTexture(PBRBaseMaterial._baseTextureProp,value);if(value){this.shaderData.enableMacro("HAS_BASECOLORMAP");}else {this.shaderData.disableMacro("HAS_BASECOLORMAP");}}/**
       * Normal texture.
       */},{key:"normalTexture",get:function get(){return this.shaderData.getTexture(PBRBaseMaterial._normalTextureProp);},set:function set(value){this.shaderData.setTexture(PBRBaseMaterial._normalTextureProp,value);if(value){this.shaderData.enableMacro("O3_NORMAL_TEXTURE");}else {this.shaderData.disableMacro("O3_NORMAL_TEXTURE");}}/**
       * Normal texture intensity.
       */},{key:"normalTextureIntensity",get:function get(){return this.shaderData.getFloat(PBRBaseMaterial._normalTextureIntensityProp);},set:function set(value){this.shaderData.setFloat(PBRBaseMaterial._normalTextureIntensityProp,value);this.shaderData.setFloat("u_normalIntensity",value);}/**
       * Emissive color.
       */},{key:"emissiveColor",get:function get(){return this.shaderData.getColor(PBRBaseMaterial._emissiveColorProp);},set:function set(value){var emissiveColor=this.shaderData.getColor(PBRBaseMaterial._emissiveColorProp);if(value!==emissiveColor){value.cloneTo(emissiveColor);}}/**
       * Emissive texture.
       */},{key:"emissiveTexture",get:function get(){return this.shaderData.getTexture(PBRBaseMaterial._emissiveTextureProp);},set:function set(value){this.shaderData.setTexture(PBRBaseMaterial._emissiveTextureProp,value);if(value){this.shaderData.enableMacro("HAS_EMISSIVEMAP");}else {this.shaderData.disableMacro("HAS_EMISSIVEMAP");}}/**
       * Occlusion texture.
       */},{key:"occlusionTexture",get:function get(){return this.shaderData.getTexture(PBRBaseMaterial._occlusionTextureProp);},set:function set(value){this.shaderData.setTexture(PBRBaseMaterial._occlusionTextureProp,value);if(value){this.shaderData.enableMacro("HAS_OCCLUSIONMAP");}else {this.shaderData.disableMacro("HAS_OCCLUSIONMAP");}}/**
       * Occlusion texture intensity.
       */},{key:"occlusionTextureIntensity",get:function get(){return this.shaderData.getFloat(PBRBaseMaterial._occlusionTextureIntensityProp);},set:function set(value){this.shaderData.setFloat(PBRBaseMaterial._occlusionTextureIntensityProp,value);}/**
       * Tiling and offset of main textures.
       */},{key:"tilingOffset",get:function get(){return this.shaderData.getVector4(PBRBaseMaterial._tilingOffsetProp);},set:function set(value){var tilingOffset=this.shaderData.getVector4(PBRBaseMaterial._tilingOffsetProp);if(value!==tilingOffset){value.cloneTo(tilingOffset);}}}]);return PBRBaseMaterial;}(BaseMaterial);PBRBaseMaterial._baseColorProp=Shader.getPropertyByName("u_baseColor");PBRBaseMaterial._emissiveColorProp=Shader.getPropertyByName("u_emissiveColor");PBRBaseMaterial._tilingOffsetProp=Shader.getPropertyByName("u_tilingOffset");PBRBaseMaterial._baseTextureProp=Shader.getPropertyByName("u_baseColorSampler");PBRBaseMaterial._normalTextureProp=Shader.getPropertyByName("u_normalTexture");PBRBaseMaterial._normalTextureIntensityProp=Shader.getPropertyByName("u_normalIntensity");PBRBaseMaterial._occlusionTextureIntensityProp=Shader.getPropertyByName("u_occlusionStrength");PBRBaseMaterial._emissiveTextureProp=Shader.getPropertyByName("u_emissiveSampler");PBRBaseMaterial._occlusionTextureProp=Shader.getPropertyByName("u_occlusionSampler");/**
   * PBR (Metallic-Roughness Workflow) Material.
   */var PBRMaterial=/*#__PURE__*/function(_PBRBaseMaterial){_inheritsLoose$2(PBRMaterial,_PBRBaseMaterial);/**
     * Create a pbr metallic-roughness workflow material instance.
     * @param engine - Engine to which the material belongs
     */function PBRMaterial(engine){var _this;_this=_PBRBaseMaterial.call(this,engine)||this;_this.shaderData.enableMacro("IS_METALLIC_WORKFLOW");_this.shaderData.setFloat(PBRMaterial._metallicProp,1.0);_this.shaderData.setFloat(PBRMaterial._roughnessProp,1.0);return _this;}/**
     * @override
     */var _proto=PBRMaterial.prototype;_proto.clone=function clone(){var dest=new PBRMaterial(this._engine);this.cloneTo(dest);return dest;};_createClass$3(PBRMaterial,[{key:"metallic",get:/**
       * Metallic.
       */function get(){return this.shaderData.getFloat(PBRMaterial._metallicProp);},set:function set(value){this.shaderData.setFloat(PBRMaterial._metallicProp,value);}/**
       * Roughness.
       */},{key:"roughness",get:function get(){return this.shaderData.getFloat(PBRMaterial._roughnessProp);},set:function set(value){this.shaderData.setFloat(PBRMaterial._roughnessProp,value);}/**
       * Roughness metallic texture.
       * @remarks G channel is roughness, B channel is metallic
       */},{key:"roughnessMetallicTexture",get:function get(){return this.shaderData.getTexture(PBRMaterial._metallicRoughnessTextureProp);},set:function set(value){this.shaderData.setTexture(PBRMaterial._metallicRoughnessTextureProp,value);if(value){this.shaderData.enableMacro("HAS_METALROUGHNESSMAP");}else {this.shaderData.disableMacro("HAS_METALROUGHNESSMAP");}}}]);return PBRMaterial;}(PBRBaseMaterial);PBRMaterial._metallicProp=Shader.getPropertyByName("u_metal");PBRMaterial._roughnessProp=Shader.getPropertyByName("u_roughness");PBRMaterial._metallicRoughnessTextureProp=Shader.getPropertyByName("u_metallicRoughnessSampler");/**
   * PBR (Specular-Glossiness Workflow) Material.
   */var PBRSpecularMaterial=/*#__PURE__*/function(_PBRBaseMaterial){_inheritsLoose$2(PBRSpecularMaterial,_PBRBaseMaterial);/**
     * Create a pbr specular-glossiness workflow material instance.
     * @param engine - Engine to which the material belongs
     */function PBRSpecularMaterial(engine){var _this;_this=_PBRBaseMaterial.call(this,engine)||this;_this.shaderData.setColor(PBRSpecularMaterial._specularColorProp,new Color(1,1,1,1));_this.shaderData.setFloat(PBRSpecularMaterial._glossinessProp,1.0);return _this;}/**
     * @override
     */var _proto=PBRSpecularMaterial.prototype;_proto.clone=function clone(){var dest=new PBRSpecularMaterial(this._engine);this.cloneTo(dest);return dest;};_createClass$3(PBRSpecularMaterial,[{key:"specularColor",get:/**
       * Specular color.
       */function get(){return this.shaderData.getColor(PBRSpecularMaterial._specularColorProp);},set:function set(value){var specularColor=this.shaderData.getColor(PBRSpecularMaterial._specularColorProp);if(value!==specularColor){value.cloneTo(specularColor);}}/**
       * Glossiness.
       */},{key:"glossiness",get:function get(){return this.shaderData.getFloat(PBRSpecularMaterial._glossinessProp);},set:function set(value){this.shaderData.setFloat(PBRSpecularMaterial._glossinessProp,value);}/**
       * Specular glossiness texture.
       * @remarks RGB is specular, A is glossiness
       */},{key:"specularGlossinessTexture",get:function get(){return this.shaderData.getTexture(PBRSpecularMaterial._specularGlossinessTextureProp);},set:function set(value){this.shaderData.setTexture(PBRSpecularMaterial._specularGlossinessTextureProp,value);if(value){this.shaderData.enableMacro("HAS_SPECULARGLOSSINESSMAP");}else {this.shaderData.disableMacro("HAS_SPECULARGLOSSINESSMAP");}}}]);return PBRSpecularMaterial;}(PBRBaseMaterial);PBRSpecularMaterial._specularColorProp=Shader.getPropertyByName("u_specularColor");PBRSpecularMaterial._glossinessProp=Shader.getPropertyByName("u_glossinessFactor");PBRSpecularMaterial._specularGlossinessTextureProp=Shader.getPropertyByName("u_specularGlossinessSampler");/**
   * Unlit Material.
   */var UnlitMaterial=/*#__PURE__*/function(_BaseMaterial){_inheritsLoose$2(UnlitMaterial,_BaseMaterial);/**
     * Create a unlit material instance.
     * @param engine - Engine to which the material belongs
     */function UnlitMaterial(engine){var _this;_this=_BaseMaterial.call(this,engine,Shader.find("unlit"))||this;var shaderData=_this.shaderData;shaderData.enableMacro("OMIT_NORMAL");shaderData.enableMacro("O3_NEED_TILINGOFFSET");shaderData.setColor(UnlitMaterial._baseColorProp,new Color(1,1,1,1));shaderData.setVector4(UnlitMaterial._tilingOffsetProp,new Vector4(1,1,0,0));return _this;}/**
     * @override
     */var _proto=UnlitMaterial.prototype;_proto.clone=function clone(){var dest=new UnlitMaterial(this._engine);this.cloneTo(dest);return dest;};_createClass$3(UnlitMaterial,[{key:"baseColor",get:/**
       * Base color.
       */function get(){return this.shaderData.getColor(UnlitMaterial._baseColorProp);},set:function set(value){var baseColor=this.shaderData.getColor(UnlitMaterial._baseColorProp);if(value!==baseColor){value.cloneTo(baseColor);}}/**
       * Base texture.
       */},{key:"baseTexture",get:function get(){return this.shaderData.getTexture(UnlitMaterial._baseTextureProp);},set:function set(value){this.shaderData.setTexture(UnlitMaterial._baseTextureProp,value);if(value){this.shaderData.enableMacro("O3_BASE_TEXTURE");}else {this.shaderData.disableMacro("O3_BASE_TEXTURE");}}/**
       * Tiling and offset of main textures.
       */},{key:"tilingOffset",get:function get(){return this.shaderData.getVector4(UnlitMaterial._tilingOffsetProp);},set:function set(value){var tilingOffset=this.shaderData.getVector4(UnlitMaterial._tilingOffsetProp);if(value!==tilingOffset){value.cloneTo(tilingOffset);}}}]);return UnlitMaterial;}(BaseMaterial);UnlitMaterial._baseColorProp=Shader.getPropertyByName("u_baseColor");UnlitMaterial._baseTextureProp=Shader.getPropertyByName("u_baseTexture");UnlitMaterial._tilingOffsetProp=Shader.getPropertyByName("u_tilingOffset");/**
   * Sprite Atlas.
   */var SpriteAtlas=/*#__PURE__*/function(_RefObject){_inheritsLoose$2(SpriteAtlas,_RefObject);var _proto=SpriteAtlas.prototype;/**
     * Get the last sprite named 'name' from the atlas.
     * @param name - The name of the sprite you want to find
     * @returns The sprite you want to find
     */_proto.getSprite=function getSprite(name){var sprite=this._sprites[this._spriteNamesToIndex[name]];if(!sprite){console.warn("There is no sprite named "+name+" in the atlas.");}return sprite;}/**
     * Get all the sprite named 'name' from the atlas.
     * @param name - The name of the sprites you want to find
     * @param outSprites - This array holds the sprites found
     * @returns The sprites you want to find
     */;_proto.getSprites=function getSprites(name,outSprites){outSprites.length=0;var i=this._spriteNamesToIndex[name];if(i!==undefined){var _sprites=this._sprites;for(;i>=0;i--){var sprite=_sprites[i];sprite.name===name&&outSprites.push(sprite);}}else {console.warn("The name of the sprite you want to find is not exit in SpriteAtlas.");}return outSprites;}/**
     * Constructor a SpriteAtlas.
     * @param engine - Engine to which the SpriteAtlas belongs
     */;function SpriteAtlas(engine){var _this;_this=_RefObject.call(this,engine)||this;_this._sprites=new Array();_this._spriteNamesToIndex={};return _this;}/**
     * @internal
     */_proto._addSprite=function _addSprite(sprite){this._spriteNamesToIndex[sprite.name]=this._sprites.push(sprite)-1;}/**
     * @override
     */;_proto._onDestroy=function _onDestroy(){this._sprites=null;this._spriteNamesToIndex=null;};_createClass$3(SpriteAtlas,[{key:"sprites",get:/**
       * All the sprites in the atlas.
       */function get(){return this._sprites;}}]);return SpriteAtlas;}(RefObject);/**
   * 2D sprite.
   */var Sprite=/*#__PURE__*/function(_RefObject){_inheritsLoose$2(Sprite,_RefObject);/**
     * Constructor a Sprite.
     * @param engine - Engine to which the sprite belongs
     * @param texture - Texture from which to obtain the Sprite
     * @param region - Rectangle region of the texture to use for the Sprite, specified in normalized
     * @param pivot - Sprite's pivot point relative to its graphic rectangle, specified in normalized
     * @param pixelsPerUnit - The number of pixels in the Sprite that correspond to one unit in world space
     * @param name - The name of Sprite
     */function Sprite(engine,texture,region,pivot,pixelsPerUnit,name){var _this;if(texture===void 0){texture=null;}if(region===void 0){region=null;}if(pivot===void 0){pivot=null;}if(pixelsPerUnit===void 0){pixelsPerUnit=128;}if(name===void 0){name=null;}_this=_RefObject.call(this,engine)||this;_this.name=void 0;_this._uv=[new Vector2(),new Vector2(),new Vector2(),new Vector2()];_this._positions=[new Vector2(),new Vector2(),new Vector2(),new Vector2()];_this._bounds=new BoundingBox();_this._triangles=void 0;_this._assetID=void 0;_this._pixelsPerUnit=void 0;_this._texture=null;_this._atlasRotated=false;_this._region=new Rect(0,0,1,1);_this._pivot=new Vector2(0.5,0.5);_this._atlasRegion=new Rect(0,0,1,1);_this._atlasRegionOffset=new Vector4(0,0,0,0);_this._dirtyFlag=DirtyFlag$1.all;_this.name=name;_this._texture=texture;_this._pixelsPerUnit=pixelsPerUnit;region&&region.cloneTo(_this._region);pivot&&pivot.cloneTo(_this._pivot);_this._triangles=Sprite._rectangleTriangles;return _this;}/**
     * @override
     */var _proto=Sprite.prototype;_proto._onDestroy=function _onDestroy(){if(this._texture){this._texture=null;}}/**
     * Update positions and bounds.
     */;_proto._updatePositionsAndBounds=function _updatePositionsAndBounds(){var texture=this._texture,bounds=this._bounds;if(texture){var atlasRegion=this._atlasRegion,pivot=this._pivot,atlasRegionOffset=this._atlasRegionOffset;var _this$_region=this._region,regionX=_this$_region.x,regionY=_this$_region.y,regionW=_this$_region.width,regionH=_this$_region.height;var pPUReciprocal=1.0/this._pixelsPerUnit;// Coordinates of the four boundaries.
  var lx,ty,rx,by;// TextureSize
  var textureW,textureH;if(this._atlasRotated){textureW=texture.height*atlasRegion.height*pPUReciprocal;textureH=texture.width*atlasRegion.width*pPUReciprocal;}else {textureW=texture.width*atlasRegion.width*pPUReciprocal;textureH=texture.height*atlasRegion.height*pPUReciprocal;}// Determine whether it has been trimmed.
  if(atlasRegionOffset.x==0&&atlasRegionOffset.y==0&&atlasRegionOffset.z==0&&atlasRegionOffset.w==0){// Real rendering size.
  var realRenderW=textureW*regionW;var realRenderH=textureH*regionH;lx=-pivot.x*realRenderW;by=-pivot.y*realRenderH;rx=realRenderW+lx;ty=realRenderH+by;}else {var blankLeft=atlasRegionOffset.x,blankTop=atlasRegionOffset.y,blankRight=atlasRegionOffset.z,blankBottom=atlasRegionOffset.w;var oriWidth=textureW/(1-blankRight-blankLeft);var oriHeight=textureH/(1-blankBottom-blankTop);// The size of the real rendering.
  lx=(-pivot.x*regionW+Math.max(blankLeft,regionX)-regionX)*oriWidth;ty=(pivot.y*regionH-Math.max(blankTop,regionY)+regionY)*oriHeight;rx=(-pivot.x*regionW+Math.min(1-blankRight,regionX+regionW)-regionX)*oriWidth;by=(pivot.y*regionH-Math.min(1-blankBottom,regionY+regionH)+regionY)*oriHeight;}// Assign values ​​to _positions
  var positions=this._positions;// Top-left.
  positions[0].setValue(lx,ty);// Top-right.
  positions[1].setValue(rx,ty);// Bottom-right.
  positions[2].setValue(rx,by);// Bottom-left.
  positions[3].setValue(lx,by);// Update bounds.
  bounds.min.setValue(lx,by,0);bounds.max.setValue(rx,ty,0);}else {// Update bounds.
  bounds.min.setValue(0,0,0);bounds.max.setValue(0,0,0);}}/**
     * Update mesh.
     */;_proto._updateMesh=function _updateMesh(){if(this._isContainDirtyFlag(DirtyFlag$1.positions)){this._updatePositionsAndBounds();}if(this._isContainDirtyFlag(DirtyFlag$1.uv)){var _atlasRegion=this._atlasRegion,uv=this._uv,region=this._region,_atlasRotated=this._atlasRotated,atlasRegionOffset=this._atlasRegionOffset;var left,top,right,bottom;// Determine whether it has been trimmed.
  if(atlasRegionOffset.x==0&&atlasRegionOffset.y==0&&atlasRegionOffset.z==0&&atlasRegionOffset.w==0){var atlasRegionW=_atlasRegion.width,atlasRegionH=_atlasRegion.height;if(_atlasRotated){left=atlasRegionW*(1-region.y-region.height)+_atlasRegion.x;top=atlasRegionH*region.x+_atlasRegion.y;right=atlasRegionW*region.height+left;bottom=atlasRegionH*region.width+top;}else {left=atlasRegionW*region.x+_atlasRegion.x;top=atlasRegionH*region.y+_atlasRegion.y;right=atlasRegionW*region.width+left;bottom=atlasRegionH*region.height+top;}}else {var regionX=region.x,regionY=region.y;var atlasRegionX=_atlasRegion.x,atlasRegionY=_atlasRegion.y;var blankLeft=atlasRegionOffset.x,blankTop=atlasRegionOffset.y,blankRight=atlasRegionOffset.z,blankBottom=atlasRegionOffset.w;// Proportion of the original sprite size in the atlas.
  if(_atlasRotated){var textureW=_atlasRegion.width/(1-blankBottom-blankTop);var textureH=_atlasRegion.height/(1-blankRight-blankLeft);left=(Math.max(blankBottom,1-regionY-region.height)-blankBottom)*textureW+atlasRegionX;top=(Math.max(blankLeft,regionX)-blankLeft)*textureH+atlasRegionY;right=(Math.min(1-blankTop,1-regionY)-blankBottom)*textureW+atlasRegionX;bottom=(Math.min(1-blankRight,regionX+region.width)-blankLeft)*textureH+atlasRegionY;}else {var _textureW=_atlasRegion.width/(1-blankRight-blankLeft);var _textureH=_atlasRegion.height/(1-blankBottom-blankTop);left=(Math.max(blankLeft,regionX)-blankLeft)*_textureW+atlasRegionX;top=(Math.max(blankTop,regionY)-blankTop)*_textureH+atlasRegionY;right=(Math.min(1-blankRight,regionX+region.width)-blankLeft)*_textureW+atlasRegionX;bottom=(Math.min(1-blankBottom,regionY+region.height)-blankTop)*_textureH+atlasRegionY;}}if(_atlasRotated){// If it is rotated, we need to rotate the UV 90 degrees counterclockwise to correct it.
  // Top-right.
  uv[0].setValue(right,top);// Bottom-right.
  uv[1].setValue(right,bottom);// Bottom-left.
  uv[2].setValue(left,bottom);// Top-left.
  uv[3].setValue(left,top);}else {// Top-left.
  uv[0].setValue(left,top);// Top-right.
  uv[1].setValue(right,top);// Bottom-right.
  uv[2].setValue(right,bottom);// Bottom-left.
  uv[3].setValue(left,bottom);}}}/**
     * @internal
     * Update mesh data of the sprite.
     * @returns True if the data is refreshed, false otherwise.
     */;_proto._updateMeshData=function _updateMeshData(){if(this._isContainDirtyFlag(DirtyFlag$1.all)){this._updateMesh();this._setDirtyFlagFalse(DirtyFlag$1.all);return true;}return false;};_proto._isContainDirtyFlag=function _isContainDirtyFlag(type){return (this._dirtyFlag&type)!=0;};_proto._setDirtyFlagTrue=function _setDirtyFlagTrue(type){this._dirtyFlag|=type;};_proto._setDirtyFlagFalse=function _setDirtyFlagFalse(type){this._dirtyFlag&=~type;};_createClass$3(Sprite,[{key:"texture",get:/** The name of sprite. */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal temp solution. */ /**
       * The reference to the used texture.
       */function get(){return this._texture;},set:function set(value){if(this._texture!==value){this._texture=value;this._setDirtyFlagTrue(DirtyFlag$1.positions);}}/**
       *  Bounding volume of the sprite.
       *  @remarks The returned bounds should be considered deep-read-only.
       */},{key:"bounds",get:function get(){if(this._isContainDirtyFlag(DirtyFlag$1.positions)&&this._texture){this._updatePositionsAndBounds();this._setDirtyFlagFalse(DirtyFlag$1.positions);}return this._bounds;}/**
       * Is it rotated 90 degrees clockwise when packing.
       */},{key:"atlasRotated",get:function get(){return this._atlasRotated;},set:function set(value){if(this._atlasRotated!=value){this._atlasRotated=value;this._setDirtyFlagTrue(DirtyFlag$1.positions|DirtyFlag$1.uv);}}/**
       * The rectangle region of the original texture on its atlas texture, specified in normalized.
       */},{key:"atlasRegion",get:function get(){return this._atlasRegion;},set:function set(value){var x=MathUtil.clamp(value.x,0,1);var y=MathUtil.clamp(value.y,0,1);this._atlasRegion.setValue(x,y,MathUtil.clamp(value.width,0,1-x),MathUtil.clamp(value.height,0,1-y));this._setDirtyFlagTrue(DirtyFlag$1.positions|DirtyFlag$1.uv);}/**
       * The rectangle region offset of the original texture on its atlas texture, specified in normalized.
       */},{key:"atlasRegionOffset",get:function get(){return this._atlasRegionOffset;},set:function set(value){var x=MathUtil.clamp(value.x,0,1);var y=MathUtil.clamp(value.y,0,1);this._atlasRegionOffset.setValue(x,y,MathUtil.clamp(value.z,0,1-x),MathUtil.clamp(value.w,0,1-y));this._setDirtyFlagTrue(DirtyFlag$1.positions|DirtyFlag$1.uv);}/**
       * Location of the sprite's center point in the rectangle region, specified in normalized.
       */},{key:"pivot",get:function get(){return this._pivot;},set:function set(value){this._pivot.setValue(MathUtil.clamp(value.x,0,1),MathUtil.clamp(value.y,0,1));this._setDirtyFlagTrue(DirtyFlag$1.positions);}/**
       * The rectangle region of the sprite, specified in normalized.
       */},{key:"region",get:function get(){return this._region;},set:function set(value){var region=this._region;var x=MathUtil.clamp(value.x,0,1);var y=MathUtil.clamp(value.y,0,1);region.setValue(x,y,MathUtil.clamp(value.width,0,1-x),MathUtil.clamp(value.height,0,1-y));this._setDirtyFlagTrue(DirtyFlag$1.positions|DirtyFlag$1.uv);}/**
       * The number of pixels in the sprite that correspond to one unit in world space.
       */},{key:"pixelsPerUnit",get:function get(){return this._pixelsPerUnit;},set:function set(value){if(this._pixelsPerUnit!==value){this._pixelsPerUnit=value;this._setDirtyFlagTrue(DirtyFlag$1.positions);}}}]);return Sprite;}(RefObject);Sprite._rectangleTriangles=[0,2,1,2,0,3];var DirtyFlag$1;(function(DirtyFlag){DirtyFlag[DirtyFlag["positions"]=1]="positions";DirtyFlag[DirtyFlag["uv"]=2]="uv";DirtyFlag[DirtyFlag["all"]=3]="all";})(DirtyFlag$1||(DirtyFlag$1={}));var _class$1$1,_descriptor$1,_descriptor2$1,_descriptor3$1,_descriptor4$1,_descriptor5$1,_descriptor6$1,_descriptor7$1,_descriptor8,_descriptor9,_descriptor10,_descriptor11,_descriptor12,_descriptor13,_class2$1,_temp$1;/**
   * Renders a Sprite for 2D graphics.
   */var SpriteRenderer=(_class$1$1=(_temp$1=_class2$1=/*#__PURE__*/function(_Renderer){_inheritsLoose$2(SpriteRenderer,_Renderer);/**
     * @internal
     */function SpriteRenderer(entity){var _this;_this=_Renderer.call(this,entity)||this;_initializerDefineProperty(_this,"_customLocalBounds",_descriptor$1,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_customRootEntity",_descriptor2$1,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_positions",_descriptor3$1,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_sprite",_descriptor4$1,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_color",_descriptor5$1,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_flipX",_descriptor6$1,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_flipY",_descriptor7$1,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_cacheFlipX",_descriptor8,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_cacheFlipY",_descriptor9,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_dirtyFlag",_descriptor10,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_isWorldMatrixDirty",_descriptor11,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_maskInteraction",_descriptor12,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_maskLayer",_descriptor13,_assertThisInitialized$1(_this));_this._isWorldMatrixDirty=entity.transform.registerWorldChangeFlag();_this.setMaterial(_this._engine._spriteDefaultMaterial);return _this;}/**
     * @internal
     */var _proto=SpriteRenderer.prototype;_proto._render=function _render(camera){var sprite=this.sprite;if(!sprite){return;}var texture=sprite.texture;if(!texture){return;}var _positions=this._positions;var transform=this.entity.transform;// Update sprite data.
  var localDirty=sprite._updateMeshData();if(this._isWorldMatrixDirty.flag||localDirty||this._isContainDirtyFlag(DirtyFlag.Sprite)){var localPositions=sprite._positions;var localVertexPos=SpriteRenderer._tempVec3;var worldMatrix=transform.worldMatrix;var flipX=this.flipX,flipY=this.flipY;for(var i=0,n=_positions.length;i<n;i++){var curVertexPos=localPositions[i];localVertexPos.setValue(flipX?-curVertexPos.x:curVertexPos.x,flipY?-curVertexPos.y:curVertexPos.y,0);Vector3.transformToVec3(localVertexPos,worldMatrix,_positions[i]);}this._setDirtyFlagFalse(DirtyFlag.Flip);this._setDirtyFlagFalse(DirtyFlag.Sprite);this._isWorldMatrixDirty.flag=false;this._cacheFlipX=flipX;this._cacheFlipY=flipY;}else if(this._isContainDirtyFlag(DirtyFlag.Flip)){var _flipX=this.flipX,_flipY=this.flipY;var flipXChange=this._cacheFlipX!==_flipX;var flipYChange=this._cacheFlipY!==_flipY;if(flipXChange||flipYChange){var _transform$worldPosit=transform.worldPosition,x=_transform$worldPosit.x,y=_transform$worldPosit.y;for(var _i=0,_n=_positions.length;_i<_n;_i++){var curPos=_positions[_i];if(flipXChange){curPos.x=x*2-curPos.x;}if(flipYChange){curPos.y=y*2-curPos.y;}}}this._setDirtyFlagFalse(DirtyFlag.Flip);this._cacheFlipX=_flipX;this._cacheFlipY=_flipY;}if(this._isContainDirtyFlag(DirtyFlag.MaskInteraction)){this._updateStencilState();this._setDirtyFlagFalse(DirtyFlag.MaskInteraction);}this.shaderData.setTexture(SpriteRenderer._textureProperty,texture);var material=this.getMaterial();var spriteElementPool=this._engine._spriteElementPool;var spriteElement=spriteElementPool.getFromPool();spriteElement.setValue(this,_positions,sprite._uv,sprite._triangles,this.color,material,camera);camera._renderPipeline.pushPrimitive(spriteElement);}/**
     * @internal
     */;_proto._onDestroy=function _onDestroy(){this._isWorldMatrixDirty.destroy();_Renderer.prototype._onDestroy.call(this);};_proto._isContainDirtyFlag=function _isContainDirtyFlag(type){return (this._dirtyFlag&type)!=0;};_proto._setDirtyFlagTrue=function _setDirtyFlagTrue(type){this._dirtyFlag|=type;};_proto._setDirtyFlagFalse=function _setDirtyFlagFalse(type){this._dirtyFlag&=~type;}/**
     * @override
     */;_proto._updateBounds=function _updateBounds(worldBounds){var sprite=this._sprite;if(sprite){if(this._customLocalBounds&&this._customRootEntity){var worldMatrix=this._customRootEntity.transform.worldMatrix;BoundingBox.transform(this._customLocalBounds,worldMatrix,worldBounds);}else {var localBounds=sprite.bounds;var _worldMatrix=this._entity.transform.worldMatrix;BoundingBox.transform(localBounds,_worldMatrix,worldBounds);}}else {worldBounds.min.setValue(0,0,0);worldBounds.max.setValue(0,0,0);}};_proto._updateStencilState=function _updateStencilState(){// Update stencil.
  var material=this.getInstanceMaterial();var stencilState=material.renderState.stencilState;var maskInteraction=this._maskInteraction;if(maskInteraction===exports.SpriteMaskInteraction.None){stencilState.enabled=false;stencilState.writeMask=0xff;stencilState.referenceValue=0;stencilState.compareFunctionFront=stencilState.compareFunctionBack=exports.CompareFunction.Always;}else {stencilState.enabled=true;stencilState.writeMask=0x00;stencilState.referenceValue=1;var compare=maskInteraction===exports.SpriteMaskInteraction.VisibleInsideMask?exports.CompareFunction.LessEqual:exports.CompareFunction.Greater;stencilState.compareFunctionFront=compare;stencilState.compareFunctionBack=compare;}};_createClass$3(SpriteRenderer,[{key:"sprite",get:/** @internal temp solution. */ /** @internal temp solution. */ /**
       * The Sprite to render.
       */function get(){return this._sprite;},set:function set(value){if(this._sprite!==value){this._sprite=value;this._setDirtyFlagTrue(DirtyFlag.Sprite);}}/**
       * Rendering color for the Sprite graphic.
       */},{key:"color",get:function get(){return this._color;},set:function set(value){if(this._color!==value){value.cloneTo(this._color);}}/**
       * Flips the sprite on the X axis.
       */},{key:"flipX",get:function get(){return this._flipX;},set:function set(value){if(this._flipX!==value){this._flipX=value;this._setDirtyFlagTrue(DirtyFlag.Flip);}}/**
       * Flips the sprite on the Y axis.
       */},{key:"flipY",get:function get(){return this._flipY;},set:function set(value){if(this._flipY!==value){this._flipY=value;this._setDirtyFlagTrue(DirtyFlag.Flip);}}/**
       * Interacts with the masks.
       */},{key:"maskInteraction",get:function get(){return this._maskInteraction;},set:function set(value){if(this._maskInteraction!==value){this._maskInteraction=value;this._setDirtyFlagTrue(DirtyFlag.MaskInteraction);}}/**
       * The mask layer the sprite renderer belongs to.
       */},{key:"maskLayer",get:function get(){return this._maskLayer;},set:function set(value){this._maskLayer=value;}}]);return SpriteRenderer;}(Renderer),_class2$1._textureProperty=Shader.getPropertyByName("u_spriteTexture"),_class2$1._tempVec3=new Vector3(),_temp$1),(_descriptor$1=_applyDecoratedDescriptor$1(_class$1$1.prototype,"_customLocalBounds",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return null;}}),_descriptor2$1=_applyDecoratedDescriptor$1(_class$1$1.prototype,"_customRootEntity",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return null;}}),_descriptor3$1=_applyDecoratedDescriptor$1(_class$1$1.prototype,"_positions",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return [new Vector3(),new Vector3(),new Vector3(),new Vector3()];}}),_descriptor4$1=_applyDecoratedDescriptor$1(_class$1$1.prototype,"_sprite",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return null;}}),_descriptor5$1=_applyDecoratedDescriptor$1(_class$1$1.prototype,"_color",[deepClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new Color(1,1,1,1);}}),_descriptor6$1=_applyDecoratedDescriptor$1(_class$1$1.prototype,"_flipX",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor7$1=_applyDecoratedDescriptor$1(_class$1$1.prototype,"_flipY",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor8=_applyDecoratedDescriptor$1(_class$1$1.prototype,"_cacheFlipX",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor9=_applyDecoratedDescriptor$1(_class$1$1.prototype,"_cacheFlipY",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return false;}}),_descriptor10=_applyDecoratedDescriptor$1(_class$1$1.prototype,"_dirtyFlag",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return DirtyFlag.All;}}),_descriptor11=_applyDecoratedDescriptor$1(_class$1$1.prototype,"_isWorldMatrixDirty",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor12=_applyDecoratedDescriptor$1(_class$1$1.prototype,"_maskInteraction",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return exports.SpriteMaskInteraction.None;}}),_descriptor13=_applyDecoratedDescriptor$1(_class$1$1.prototype,"_maskLayer",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return exports.SpriteMaskLayer.Layer0;}})),_class$1$1);var DirtyFlag;(function(DirtyFlag){DirtyFlag[DirtyFlag["Flip"]=1]="Flip";DirtyFlag[DirtyFlag["Sprite"]=2]="Sprite";DirtyFlag[DirtyFlag["All"]=3]="All";DirtyFlag[DirtyFlag["MaskInteraction"]=4]="MaskInteraction";})(DirtyFlag||(DirtyFlag={}));/**
   * Associate AnimationCurve and the Entity
   */var AnimationClipCurveBinding=function AnimationClipCurveBinding(){this.relativePath=void 0;this.type=void 0;this.property=void 0;this.curve=void 0;};exports.AnimationProperty = void 0;(function(AnimationProperty){AnimationProperty[AnimationProperty["Position"]=0]="Position";AnimationProperty[AnimationProperty["Rotation"]=1]="Rotation";AnimationProperty[AnimationProperty["Scale"]=2]="Scale";AnimationProperty[AnimationProperty["BlendShapeWeights"]=3]="BlendShapeWeights";})(exports.AnimationProperty||(exports.AnimationProperty={}));/**
   * Base class for AnimationClips and BlendTrees.
   */var Motion=function Motion(){};/**
   * Stores keyframe based animations.
   */var AnimationClip=/*#__PURE__*/function(_Motion){_inheritsLoose$2(AnimationClip,_Motion);/**
     * @param name - The AnimationClip's name
     */function AnimationClip(name){var _this;_this=_Motion.call(this)||this;_this.name=name;_this._curveBindings=[];_this._length=0;_this._events=[];return _this;}/**
     * Adds an animation event to the clip.
     * @param event - The animation event
     */var _proto=AnimationClip.prototype;_proto.addEvent=function addEvent(event){this._events.push(event);this._events.sort(function(a,b){return a.time-b.time;});}/**
     * Clears all events from the clip.
     */;_proto.clearEvents=function clearEvents(){this._events.length=0;}/**
     * Add curve binding for the clip.
     * @param relativePath - Path to the game object this curve applies to. The relativePath is formatted similar to a pathname, e.g. "/root/spine/leftArm"
     * @param type- The class type of the component that is animated
     * @param propertyName - The name to the property being animated
     * @param curve - The animation curve
     */;_proto.addCurveBinding=function addCurveBinding(relativePath,type,propertyName,curve){var property;switch(propertyName){case"position":property=exports.AnimationProperty.Position;break;case"rotation":property=exports.AnimationProperty.Rotation;break;case"scale":property=exports.AnimationProperty.Scale;break;case"blendShapeWeights":property=exports.AnimationProperty.BlendShapeWeights;break;}var curveBinding=new AnimationClipCurveBinding();curveBinding.relativePath=relativePath;curveBinding.type=type;curveBinding.property=property;curveBinding.curve=curve;if(curve.length>this._length){this._length=curve.length;}this._curveBindings.push(curveBinding);}/**
     * Clears all curve bindings from the clip.
     */;_proto.clearCurveBindings=function clearCurveBindings(){this._curveBindings.length=0;this._length=0;}/**
     * @internal
     * Samples an animation at a given time.
     * @param entity - The animated entity
     * @param time - The time to sample an animation
     */;_proto._sampleAnimation=function _sampleAnimation(entity,time){var length=this._curveBindings.length;for(var i=length-1;i>=0;i--){var curveData=this._curveBindings[i];var curve=curveData.curve,property=curveData.property,relativePath=curveData.relativePath,type=curveData.type;var val=curve.evaluate(time);var target=entity.findByName(relativePath);var transform=target.transform;if(type===Transform){switch(property){case exports.AnimationProperty.Position:transform.position=val;break;case exports.AnimationProperty.Rotation:transform.rotationQuaternion=val;break;case exports.AnimationProperty.Scale:transform.scale=val;break;}}}};_createClass$3(AnimationClip,[{key:"events",get:/** @internal */ /**
       * Animation events for this animation clip.
       */function get(){return this._events;}/**
       * Animation curve bindings for this animation clip.
       */},{key:"curveBindings",get:function get(){return this._curveBindings;}/**
       * Animation length in seconds.
       */},{key:"length",get:function get(){return this._length;}}]);return AnimationClip;}(Motion);/**
   * @internal
   */var AnimatorUtils=/*#__PURE__*/function(){function AnimatorUtils(){}AnimatorUtils.scaleWeight=function scaleWeight(s,w,out){var sX=s.x;var sY=s.y;var sZ=s.z;out.x=sX>0?Math.pow(Math.abs(sX),w):-Math.pow(Math.abs(sX),w);out.y=sY>0?Math.pow(Math.abs(sY),w):-Math.pow(Math.abs(sY),w);out.z=sZ>0?Math.pow(Math.abs(sZ),w):-Math.pow(Math.abs(sZ),w);};AnimatorUtils.scaleBlend=function scaleBlend(sa,sb,w,out){var saw=AnimatorUtils._tempVector30;var sbw=AnimatorUtils._tempVector31;AnimatorUtils.scaleWeight(sa,1.0-w,saw);AnimatorUtils.scaleWeight(sb,w,sbw);var sng=w>0.5?sb:sa;out.x=sng.x>0?Math.abs(saw.x*sbw.x):-Math.abs(saw.x*sbw.x);out.y=sng.y>0?Math.abs(saw.y*sbw.y):-Math.abs(saw.y*sbw.y);out.z=sng.z>0?Math.abs(saw.z*sbw.z):-Math.abs(saw.z*sbw.z);};AnimatorUtils.quaternionWeight=function quaternionWeight(s,w,out){out.x=s.x*w;out.y=s.y*w;out.z=s.z*w;out.w=s.w;};return AnimatorUtils;}();AnimatorUtils._tempVector30=new Vector3();AnimatorUtils._tempVector31=new Vector3();exports.AnimatorLayerBlendingMode = void 0;(function(AnimatorLayerBlendingMode){AnimatorLayerBlendingMode[AnimatorLayerBlendingMode["Override"]=0]="Override";AnimatorLayerBlendingMode[AnimatorLayerBlendingMode["Additive"]=1]="Additive";})(exports.AnimatorLayerBlendingMode||(exports.AnimatorLayerBlendingMode={}));/**
   * Layer state.
   */var LayerState;(function(LayerState){LayerState[LayerState["Standby"]=0]="Standby";LayerState[LayerState["Playing"]=1]="Playing";LayerState[LayerState["CrossFading"]=2]="CrossFading";LayerState[LayerState["FixedCrossFading"]=3]="FixedCrossFading";})(LayerState||(LayerState={}));/**
   * @internal
   */var AnimationCurveOwner=/*#__PURE__*/function(){function AnimationCurveOwner(target,type,property){this.crossCurveMark=0;this.crossCurveIndex=void 0;this.target=void 0;this.type=void 0;this.property=void 0;this.component=void 0;this.defaultValue=void 0;this.fixedPoseValue=void 0;this.target=target;this.type=type;this.property=property;switch(property){case exports.AnimationProperty.Position:this.defaultValue=new Vector3();this.fixedPoseValue=new Vector3();this.component=target.transform;break;case exports.AnimationProperty.Rotation:this.defaultValue=new Quaternion();this.fixedPoseValue=new Quaternion();this.component=target.transform;break;case exports.AnimationProperty.Scale:this.defaultValue=new Vector3();this.fixedPoseValue=new Vector3();this.component=target.transform;break;case exports.AnimationProperty.BlendShapeWeights:this.defaultValue=new Float32Array(4);this.fixedPoseValue=new Float32Array(4);this.component=target.getComponent(SkinnedMeshRenderer);break;}}var _proto=AnimationCurveOwner.prototype;_proto.saveDefaultValue=function saveDefaultValue(){switch(this.property){case exports.AnimationProperty.Position:this.target.transform.position.cloneTo(this.defaultValue);break;case exports.AnimationProperty.Rotation:this.target.transform.rotationQuaternion.cloneTo(this.defaultValue);break;case exports.AnimationProperty.Scale:this.target.transform.scale.cloneTo(this.defaultValue);break;}};_proto.saveFixedPoseValue=function saveFixedPoseValue(){switch(this.property){case exports.AnimationProperty.Position:this.target.transform.position.cloneTo(this.fixedPoseValue);break;case exports.AnimationProperty.Rotation:this.target.transform.rotationQuaternion.cloneTo(this.fixedPoseValue);break;case exports.AnimationProperty.Scale:this.target.transform.scale.cloneTo(this.fixedPoseValue);break;}};return AnimationCurveOwner;}();/**
   * @internal
   */var AnimationEventHandler=function AnimationEventHandler(){this.event=void 0;this.handlers=[];};/**
   * Transitions define when and how the state machine switch from on state to another. AnimatorTransition always originate from a StateMachine or a StateMachine entry.
   */var AnimatorStateTransition=function AnimatorStateTransition(){this.duration=0;this.offset=0;this.exitTime=1;this.destinationState=void 0;};/**
   * Animation wrap mode.
   */exports.WrapMode = void 0;(function(WrapMode){WrapMode[WrapMode["Once"]=0]="Once";WrapMode[WrapMode["Loop"]=1]="Loop";})(exports.WrapMode||(exports.WrapMode={}));/**
   * @internal
   */var AnimatorStatePlayData=/*#__PURE__*/function(){function AnimatorStatePlayData(){this.state=void 0;this.stateData=void 0;this.frameTime=void 0;this.finished=void 0;this.clipTime=void 0;this.currentEventIndex=void 0;}var _proto=AnimatorStatePlayData.prototype;_proto.reset=function reset(state,stateData,offsetFrameTime){this.state=state;this.frameTime=offsetFrameTime;this.stateData=stateData;this.finished=false;this.clipTime=this.state.clipStartTime;this.currentEventIndex=0;};_proto.update=function update(){var state=this.state;var time=this.frameTime;var duration=state.clipEndTime-state.clipStartTime;if(time>duration){if(state.wrapMode===exports.WrapMode.Loop){time=time%duration;}else {time=duration;this.finished=true;}}this.clipTime=time+this.state.clipStartTime;};return AnimatorStatePlayData;}();/**
   * @internal
   */var AnimatorLayerData=/*#__PURE__*/function(){function AnimatorLayerData(){this.animatorStateDataMap={};this.srcPlayData=new AnimatorStatePlayData();this.destPlayData=new AnimatorStatePlayData();this.layerState=LayerState.Standby;this.crossCurveMark=0;this.manuallyTransition=new AnimatorStateTransition();this.crossFadeTransition=void 0;}var _proto=AnimatorLayerData.prototype;_proto.switchPlayData=function switchPlayData(){var srcPlayData=this.destPlayData;var switchTemp=this.srcPlayData;this.srcPlayData=srcPlayData;this.destPlayData=switchTemp;};return AnimatorLayerData;}();/**
   * @internal
   */var AnimatorStateData=function AnimatorStateData(){this.curveOwners=[];this.eventHandlers=[];};/**
   * @internal
   */var AnimatorStateInfo=function AnimatorStateInfo(){this.layerIndex=void 0;this.state=void 0;};/**
   * @internal
   */var CrossCurveData=function CrossCurveData(){this.curveOwner=void 0;this.srcCurveIndex=void 0;this.destCurveIndex=void 0;};var _class$k,_descriptor,_descriptor2,_descriptor3,_descriptor4,_descriptor5,_descriptor6,_descriptor7,_class2$9,_temp$9;/**
   * The controller of the animation system.
   */var Animator=(_class$k=(_temp$9=_class2$9=/*#__PURE__*/function(_Component){_inheritsLoose$2(Animator,_Component);/**
     * @internal
     */function Animator(entity){var _this;_this=_Component.call(this,entity)||this;_this._animatorController=void 0;_initializerDefineProperty(_this,"_speed",_descriptor,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_controllerUpdateFlag",_descriptor2,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_animatorLayersData",_descriptor3,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_crossCurveDataCollection",_descriptor4,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_animationCurveOwners",_descriptor5,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_crossCurveDataPool",_descriptor6,_assertThisInitialized$1(_this));_initializerDefineProperty(_this,"_animationEventHandlerPool",_descriptor7,_assertThisInitialized$1(_this));return _this;}/**
     * Play a state by name.
     * @param stateName - The state name
     * @param layerIndex - The layer index(default -1). If layer is -1, play the first state with the given state name
     * @param normalizedTimeOffset - The time offset between 0 and 1(default 0)
     */var _proto=Animator.prototype;_proto.play=function play(stateName,layerIndex,normalizedTimeOffset){var _this$_controllerUpda;if(layerIndex===void 0){layerIndex=-1;}if(normalizedTimeOffset===void 0){normalizedTimeOffset=0;}if((_this$_controllerUpda=this._controllerUpdateFlag)!==null&&_this$_controllerUpda!==void 0&&_this$_controllerUpda.flag){this._clearPlayData();}var animatorInfo=this._getAnimatorStateInfo(stateName,layerIndex,Animator._animatorInfo);var state=animatorInfo.state;if(!state){return;}if(!state.clip){console.warn("The state named "+stateName+" has no AnimationClip data.");return;}var animatorLayerData=this._getAnimatorLayerData(animatorInfo.layerIndex);var srcPlayData=animatorLayerData.srcPlayData;var curState=srcPlayData.state;if(curState&&curState!==state){this._revertDefaultValue(srcPlayData);}//CM: Not consider same stateName, but different animation
  var animatorStateData=this._getAnimatorStateData(stateName,state,animatorLayerData);animatorLayerData.layerState=LayerState.Playing;srcPlayData.reset(state,animatorStateData,state._getDuration()*normalizedTimeOffset);this._saveDefaultValues(animatorStateData);}/**
     * Create a cross fade from the current state to another state.
     * @param stateName - The state name
     * @param normalizedTransitionDuration - The duration of the transition (normalized)
     * @param layerIndex - The layer index(default -1). If layer is -1, play the first state with the given state name
     * @param normalizedTimeOffset - The time offset between 0 and 1(default 0)
     */;_proto.crossFade=function crossFade(stateName,normalizedTransitionDuration,layerIndex,normalizedTimeOffset){var _this$_controllerUpda2;if(layerIndex===void 0){layerIndex=-1;}if(normalizedTimeOffset===void 0){normalizedTimeOffset=0;}if((_this$_controllerUpda2=this._controllerUpdateFlag)!==null&&_this$_controllerUpda2!==void 0&&_this$_controllerUpda2.flag){this._clearPlayData();}var _this$_getAnimatorSta=this._getAnimatorStateInfo(stateName,layerIndex,Animator._animatorInfo),state=_this$_getAnimatorSta.state;var _this$_getAnimatorLay=this._getAnimatorLayerData(layerIndex),manuallyTransition=_this$_getAnimatorLay.manuallyTransition;manuallyTransition.duration=normalizedTransitionDuration;manuallyTransition.offset=normalizedTimeOffset;manuallyTransition.destinationState=state;this._crossFadeByTransition(manuallyTransition,layerIndex);}/**
     * Evaluates the animator component based on deltaTime.
     * @param deltaTime - The deltaTime when the animation update
     */;_proto.update=function update(deltaTime){var _this$_controllerUpda3;if(this.speed===0){return;}var animatorController=this._animatorController;if(!animatorController){return;}if((_this$_controllerUpda3=this._controllerUpdateFlag)!==null&&_this$_controllerUpda3!==void 0&&_this$_controllerUpda3.flag){return;}deltaTime*=this.speed;for(var i=0,n=animatorController.layers.length;i<n;i++){var animatorLayerData=this._getAnimatorLayerData(i);if(animatorLayerData.layerState===LayerState.Standby){continue;}this._updateLayer(i,i===0,deltaTime/1000);}}/**
     * @override
     * @internal
     */;_proto._onEnable=function _onEnable(){this.engine._componentsManager.addOnUpdateAnimations(this);}/**
     * @override
     * @internal
     */;_proto._onDisable=function _onDisable(){this.engine._componentsManager.removeOnUpdateAnimations(this);};_proto._getAnimatorStateInfo=function _getAnimatorStateInfo(stateName,layerIndex,out){var state=null;var animatorController=this._animatorController;if(animatorController){var layers=animatorController.layers;if(layerIndex===-1){for(var i=0,n=layers.length;i<n;i++){state=layers[i].stateMachine.findStateByName(stateName);if(state){layerIndex=i;break;}}}else {state=layers[layerIndex].stateMachine.findStateByName(stateName);}}out.layerIndex=layerIndex;out.state=state;return out;};_proto._saveDefaultValues=function _saveDefaultValues(stateData){var curveOwners=stateData.curveOwners;for(var i=curveOwners.length-1;i>=0;i--){curveOwners[i].saveDefaultValue();}};_proto._getAnimatorStateData=function _getAnimatorStateData(stateName,animatorState,animatorLayerData){var animatorStateDataCollection=animatorLayerData.animatorStateDataMap;var animatorStateData=animatorStateDataCollection[stateName];if(!animatorStateData){animatorStateData=new AnimatorStateData();animatorStateDataCollection[stateName]=animatorStateData;this._saveAnimatorStateData(animatorState,animatorStateData);this._saveAnimatorEventHandlers(animatorState,animatorStateData);}return animatorStateData;};_proto._saveAnimatorStateData=function _saveAnimatorStateData(animatorState,animatorStateData){var entity=this.entity,animationCureOwners=this._animationCurveOwners;var curveOwners=animatorStateData.curveOwners;var curves=animatorState.clip._curveBindings;for(var i=curves.length-1;i>=0;i--){var curve=curves[i];var targetEntity=curve.relativePath===""?entity:entity.findByPath(curve.relativePath);var property=curve.property;var instanceId=targetEntity.instanceId;var propertyOwners=animationCureOwners[instanceId]||(animationCureOwners[instanceId]=[]);curveOwners[i]=propertyOwners[property]||(propertyOwners[property]=new AnimationCurveOwner(targetEntity,curve.type,property));}};_proto._saveAnimatorEventHandlers=function _saveAnimatorEventHandlers(state,animatorStateData){var eventHandlerPool=this._animationEventHandlerPool;var scripts=this._entity._scripts;var scriptCount=scripts.length;var eventHandlers=animatorStateData.eventHandlers;var events=state.clip.events;eventHandlerPool.resetPool();eventHandlers.length=0;for(var i=0,n=events.length;i<n;i++){var event=events[i];var eventHandler=eventHandlerPool.getFromPool();var funcName=event.functionName;var handlers=eventHandler.handlers;eventHandler.event=event;handlers.length=0;for(var j=scriptCount-1;j>=0;j--){var handler=scripts.get(j)[funcName];handler&&handlers.push(handler);}eventHandlers.push(eventHandler);}};_proto._clearCrossData=function _clearCrossData(animatorLayerData){animatorLayerData.crossCurveMark++;this._crossCurveDataCollection.length=0;this._crossCurveDataPool.resetPool();};_proto._addCrossCurveData=function _addCrossCurveData(crossCurveData,owner,curCurveIndex,nextCurveIndex){var dataItem=this._crossCurveDataPool.getFromPool();dataItem.curveOwner=owner;dataItem.srcCurveIndex=curCurveIndex;dataItem.destCurveIndex=nextCurveIndex;crossCurveData.push(dataItem);};_proto._prepareCrossFading=function _prepareCrossFading(animatorLayerData){var crossCurveData=this._crossCurveDataCollection;var crossCurveMark=animatorLayerData.crossCurveMark;// Add src cross curve data.
  this._prepareSrcCrossData(crossCurveData,animatorLayerData.srcPlayData,crossCurveMark,false);// Add dest cross curve data.
  this._prepareDestCrossData(crossCurveData,animatorLayerData.destPlayData,crossCurveMark,false);};_proto._prepareStandbyCrossFading=function _prepareStandbyCrossFading(animatorLayerData){var crossCurveData=this._crossCurveDataCollection;var srcPlayData=animatorLayerData.srcPlayData,crossCurveMark=animatorLayerData.crossCurveMark;// Standby have two sub state, one is never play, one is finished, never play srcPlayData is null.
  srcPlayData&&this._prepareSrcCrossData(crossCurveData,srcPlayData,crossCurveMark,true);// Add dest cross curve data.
  this._prepareDestCrossData(crossCurveData,animatorLayerData.destPlayData,crossCurveMark,true);};_proto._prepareFixedPoseCrossFading=function _prepareFixedPoseCrossFading(animatorLayerData){var crossCurveData=this._crossCurveDataCollection;// Save current cross curve data owner fixed pose.
  for(var i=crossCurveData.length-1;i>=0;i--){var item=crossCurveData[i];item.curveOwner.saveFixedPoseValue();// Reset destCurveIndex When fixed pose crossFading again.
  item.destCurveIndex=-1;}// prepare dest AnimatorState cross data.
  this._prepareDestCrossData(crossCurveData,animatorLayerData.destPlayData,animatorLayerData.crossCurveMark,true);};_proto._prepareSrcCrossData=function _prepareSrcCrossData(crossCurveData,srcPlayData,crossCurveMark,saveFixed){var curveOwners=srcPlayData.stateData.curveOwners;for(var i=curveOwners.length-1;i>=0;i--){var owner=curveOwners[i];owner.crossCurveMark=crossCurveMark;owner.crossCurveIndex=crossCurveData.length;saveFixed&&owner.saveFixedPoseValue();this._addCrossCurveData(crossCurveData,owner,i,-1);}};_proto._prepareDestCrossData=function _prepareDestCrossData(crossCurveData,destPlayData,crossCurveMark,saveFixed){var curveOwners=destPlayData.stateData.curveOwners;for(var i=curveOwners.length-1;i>=0;i--){var owner=curveOwners[i];// Not include in previous AnimatorState.
  if(owner.crossCurveMark===crossCurveMark){crossCurveData[owner.crossCurveIndex].destCurveIndex=i;}else {saveFixed&&owner.saveFixedPoseValue();owner.crossCurveMark=crossCurveMark;owner.crossCurveIndex=crossCurveData.length;this._addCrossCurveData(crossCurveData,owner,-1,i);}}};_proto._evaluateCurve=function _evaluateCurve(property,curve,time,additive){var value=curve.evaluate(time);if(additive){var baseValue=curve.keys[0].value;switch(property){case exports.AnimationProperty.Position:var pos=Animator._tempVector3;Vector3.subtract(value,baseValue,pos);return pos;case exports.AnimationProperty.Rotation:var rot=Animator._tempQuaternion;Quaternion.conjugate(baseValue,rot);Quaternion.multiply(rot,value,rot);return rot;case exports.AnimationProperty.Scale:var scale=Animator._tempVector3;Vector3.divide(value,baseValue,scale);return scale;}}return value;};_proto._getAnimatorLayerData=function _getAnimatorLayerData(layerIndex){var animatorLayerData=this._animatorLayersData[layerIndex];animatorLayerData||(this._animatorLayersData[layerIndex]=animatorLayerData=new AnimatorLayerData());return animatorLayerData;};_proto._updateLayer=function _updateLayer(layerIndex,firstLayer,deltaTime){var _this$_animatorContro=this._animatorController.layers[layerIndex],blendingMode=_this$_animatorContro.blendingMode,weight=_this$_animatorContro.weight;var animLayerData=this._animatorLayersData[layerIndex];var srcPlayData=animLayerData.srcPlayData,destPlayData=animLayerData.destPlayData,crossFadeTransitionInfo=animLayerData.crossFadeTransition;var layerAdditive=blendingMode===exports.AnimatorLayerBlendingMode.Additive;var layerWeight=firstLayer?1.0:weight;this._checkTransition(srcPlayData,crossFadeTransitionInfo,layerIndex);switch(animLayerData.layerState){case LayerState.Playing:this._updatePlayingState(srcPlayData,animLayerData,layerWeight,deltaTime,layerAdditive);break;case LayerState.FixedCrossFading:this._updateCrossFadeFromPose(destPlayData,animLayerData,layerWeight,deltaTime,layerAdditive);break;case LayerState.CrossFading:this._updateCrossFade(srcPlayData,destPlayData,animLayerData,layerWeight,deltaTime,layerAdditive);break;}};_proto._updatePlayingState=function _updatePlayingState(playData,layerData,weight,delta,additive){var _playData$stateData=playData.stateData,curveOwners=_playData$stateData.curveOwners,eventHandlers=_playData$stateData.eventHandlers;var state=playData.state;var curves=state.clip._curveBindings;var lastClipTime=playData.clipTime;playData.update();var clipTime=playData.clipTime;eventHandlers.length&&this._fireAnimationEvents(playData,eventHandlers,lastClipTime,clipTime);for(var i=curves.length-1;i>=0;i--){var owner=curveOwners[i];var value=this._evaluateCurve(owner.property,curves[i].curve,clipTime,additive);if(additive){this._applyClipValueAdditive(owner,value,weight);}else {this._applyClipValue(owner,value,weight);}}playData.frameTime+=state.speed*delta;if(playData.finished){layerData.layerState=LayerState.Standby;}};_proto._updateCrossFade=function _updateCrossFade(srcPlayData,destPlayData,layerData,weight,delta,additive){var crossCurveDataCollection=this._crossCurveDataCollection;var srcCurves=srcPlayData.state.clip._curveBindings;var destState=destPlayData.state;var destCurves=destState.clip._curveBindings;var crossWeight=destPlayData.frameTime/(destState._getDuration()*layerData.crossFadeTransition.duration);crossWeight>=1.0&&(crossWeight=1.0);srcPlayData.update();destPlayData.update();var srcClipTime=srcPlayData.clipTime;var destClipTime=destPlayData.clipTime;for(var i=crossCurveDataCollection.length-1;i>=0;i--){var _crossCurveDataCollec=crossCurveDataCollection[i],curveOwner=_crossCurveDataCollec.curveOwner,srcCurveIndex=_crossCurveDataCollec.srcCurveIndex,destCurveIndex=_crossCurveDataCollec.destCurveIndex;var property=curveOwner.property,defaultValue=curveOwner.defaultValue;var srcValue=srcCurveIndex>=0?this._evaluateCurve(property,srcCurves[srcCurveIndex].curve,srcClipTime,additive):defaultValue;var destValue=destCurveIndex>=0?this._evaluateCurve(property,destCurves[destCurveIndex].curve,destClipTime,additive):defaultValue;this._applyCrossClipValue(curveOwner,srcValue,destValue,crossWeight,weight,additive);}this._updateCrossFadeData(layerData,crossWeight,delta,false);};_proto._updateCrossFadeFromPose=function _updateCrossFadeFromPose(destPlayData,layerData,weight,delta,additive){var crossCurveDataCollection=this._crossCurveDataCollection;var destState=destPlayData.state;var curves=destState.clip._curveBindings;var crossWeight=destPlayData.frameTime/(destState._getDuration()*layerData.crossFadeTransition.duration);crossWeight>=1.0&&(crossWeight=1.0);destPlayData.update();var destClipTime=destPlayData.clipTime;for(var i=crossCurveDataCollection.length-1;i>=0;i--){var _crossCurveDataCollec2=crossCurveDataCollection[i],curveOwner=_crossCurveDataCollec2.curveOwner,destCurveIndex=_crossCurveDataCollec2.destCurveIndex;var destValue=destCurveIndex>=0?this._evaluateCurve(curveOwner.property,curves[destCurveIndex].curve,destClipTime,additive):curveOwner.defaultValue;this._applyCrossClipValue(curveOwner,curveOwner.fixedPoseValue,destValue,crossWeight,weight,additive);}this._updateCrossFadeData(layerData,crossWeight,delta,true);};_proto._updateCrossFadeData=function _updateCrossFadeData(layerData,crossWeight,delta,fixed){var destPlayData=layerData.destPlayData;destPlayData.frameTime+=destPlayData.state.speed*delta;if(crossWeight===1.0){if(destPlayData.finished){layerData.layerState=LayerState.Standby;}else {layerData.layerState=LayerState.Playing;}layerData.switchPlayData();}else {fixed||(layerData.srcPlayData.frameTime+=layerData.srcPlayData.state.speed*delta);}};_proto._applyCrossClipValue=function _applyCrossClipValue(owner,srcValue,destValue,crossWeight,layerWeight,additive){var value;if(owner.type===Transform){var transform=owner.target.transform;switch(owner.property){case exports.AnimationProperty.Position:Vector3.lerp(srcValue,destValue,crossWeight,Animator._tempVector3);value=Animator._tempVector3;break;case exports.AnimationProperty.Rotation:Quaternion.slerp(srcValue,destValue,crossWeight,Animator._tempQuaternion);value=Animator._tempQuaternion;break;case exports.AnimationProperty.Scale:{var scale=transform.scale;Vector3.lerp(srcValue,destValue,crossWeight,Animator._tempVector3);transform.scale=scale;value=Animator._tempVector3;break;}}}if(additive){this._applyClipValueAdditive(owner,value,layerWeight);}else {this._applyClipValue(owner,value,layerWeight);}};_proto._applyClipValue=function _applyClipValue(owner,value,weight){if(owner.type===Transform){var transform=owner.target.transform;switch(owner.property){case exports.AnimationProperty.Position:if(weight===1.0){transform.position=value;}else {var position=transform.position;Vector3.lerp(position,value,weight,position);transform.position=position;}break;case exports.AnimationProperty.Rotation:if(weight===1.0){transform.rotationQuaternion=value;}else {var rotationQuaternion=transform.rotationQuaternion;Quaternion.slerp(rotationQuaternion,value,weight,rotationQuaternion);transform.rotationQuaternion=rotationQuaternion;}break;case exports.AnimationProperty.Scale:if(weight===1.0){transform.scale=value;}else {var scale=transform.scale;Vector3.lerp(scale,value,weight,scale);transform.scale=scale;}break;}}else if(owner.type===SkinnedMeshRenderer){switch(owner.property){case exports.AnimationProperty.BlendShapeWeights:owner.component.blendShapeWeights=value;break;}}};_proto._applyClipValueAdditive=function _applyClipValueAdditive(owner,additiveValue,weight){if(owner.type===Transform){var transform=owner.target.transform;switch(owner.property){case exports.AnimationProperty.Position:var position=transform.position;position.x+=additiveValue.x*weight;position.y+=additiveValue.y*weight;position.z+=additiveValue.z*weight;transform.position=position;break;case exports.AnimationProperty.Rotation:var rotationQuaternion=transform.rotationQuaternion;AnimatorUtils.quaternionWeight(additiveValue,weight,additiveValue);additiveValue.normalize();rotationQuaternion.multiply(additiveValue);transform.rotationQuaternion=rotationQuaternion;break;case exports.AnimationProperty.Scale:var scale=transform.scale;AnimatorUtils.scaleWeight(scale,weight,scale);Vector3.multiply(scale,additiveValue,scale);transform.scale=scale;break;}}};_proto._revertDefaultValue=function _revertDefaultValue(playData){var clip=playData.state.clip;if(clip){var curves=clip._curveBindings;var curveOwners=playData.stateData.curveOwners;for(var i=curves.length-1;i>=0;i--){var owner=curveOwners[i];var transform=owner.target.transform;switch(owner.property){case exports.AnimationProperty.Position:transform.position=owner.defaultValue;break;case exports.AnimationProperty.Rotation:transform.rotationQuaternion=owner.defaultValue;break;case exports.AnimationProperty.Scale:transform.scale=owner.defaultValue;break;}}}};_proto._checkTransition=function _checkTransition(stateData,crossFadeTransition,layerIndex){var state=stateData.state,clipTime=stateData.clipTime;var duration=state._getDuration();var transitions=state.transitions;for(var i=0,n=transitions.length;i<n;++i){var transition=transitions[i];if(duration*transition.exitTime<=clipTime){crossFadeTransition!==transition&&this._crossFadeByTransition(transition,layerIndex);}}};_proto._crossFadeByTransition=function _crossFadeByTransition(transition,layerIndex){var name=transition.destinationState.name;var animatorStateInfo=this._getAnimatorStateInfo(name,layerIndex,Animator._animatorInfo);var crossState=animatorStateInfo.state;if(!crossState){return;}if(!crossState.clip){console.warn("The state named "+name+" has no AnimationClip data.");return;}var animatorLayerData=this._getAnimatorLayerData(animatorStateInfo.layerIndex);var layerState=animatorLayerData.layerState;var destPlayData=animatorLayerData.destPlayData;var animatorStateData=this._getAnimatorStateData(name,crossState,animatorLayerData);var duration=crossState._getDuration();var offset=duration*transition.offset;destPlayData.reset(crossState,animatorStateData,offset);this._saveDefaultValues(animatorStateData);switch(layerState){// Maybe not play, maybe end.
  case LayerState.Standby:animatorLayerData.layerState=LayerState.FixedCrossFading;this._clearCrossData(animatorLayerData);this._prepareStandbyCrossFading(animatorLayerData);break;case LayerState.Playing:animatorLayerData.layerState=LayerState.CrossFading;this._clearCrossData(animatorLayerData);this._prepareCrossFading(animatorLayerData);break;case LayerState.CrossFading:animatorLayerData.layerState=LayerState.FixedCrossFading;this._prepareFixedPoseCrossFading(animatorLayerData);break;case LayerState.FixedCrossFading:this._prepareFixedPoseCrossFading(animatorLayerData);break;}animatorLayerData.crossFadeTransition=transition;};_proto._fireAnimationEvents=function _fireAnimationEvents(playState,eventHandlers,lastClipTime,clipTime){// TODO: If play backward, not work.
  if(clipTime<lastClipTime){this._fireSubAnimationEvents(playState,eventHandlers,lastClipTime,playState.state.clipEndTime);playState.currentEventIndex=0;this._fireSubAnimationEvents(playState,eventHandlers,playState.state.clipStartTime,clipTime);}else {this._fireSubAnimationEvents(playState,eventHandlers,lastClipTime,clipTime);}};_proto._fireSubAnimationEvents=function _fireSubAnimationEvents(playState,eventHandlers,lastClipTime,curClipTime){for(var i=playState.currentEventIndex,n=eventHandlers.length;i<n;i++){var eventHandler=eventHandlers[i];var _eventHandler$event=eventHandler.event,time=_eventHandler$event.time,parameter=_eventHandler$event.parameter;if(time>curClipTime){break;}var handlers=eventHandler.handlers;if(time>=lastClipTime){for(var j=handlers.length-1;j>=0;j--){handlers[j](parameter);}playState.currentEventIndex=i+1;}}};_proto._clearPlayData=function _clearPlayData(){this._animatorLayersData.length=0;this._crossCurveDataCollection.length=0;this._animationCurveOwners.length=0;this._controllerUpdateFlag.flag=false;};_createClass$3(Animator,[{key:"speed",get:/**
       * The playback speed of the Animator, 1.0 is normal playback speed.
       */function get(){return this._speed;},set:function set(value){this._speed=value;}/**
       * All layers from the AnimatorController which belongs this Animator.
       */},{key:"animatorController",get:function get(){return this._animatorController;},set:function set(animatorController){if(animatorController!==this._animatorController){this._controllerUpdateFlag&&this._controllerUpdateFlag.destroy();this._controllerUpdateFlag=animatorController&&animatorController._registerChangeFlag();this._animatorController=animatorController;}}}]);return Animator;}(Component),_class2$9._tempVector3=new Vector3(),_class2$9._tempQuaternion=new Quaternion(),_class2$9._animatorInfo=new AnimatorStateInfo(),_temp$9),(_descriptor=_applyDecoratedDescriptor$1(_class$k.prototype,"_speed",[assignmentClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return 1.0;}}),_descriptor2=_applyDecoratedDescriptor$1(_class$k.prototype,"_controllerUpdateFlag",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor3=_applyDecoratedDescriptor$1(_class$k.prototype,"_animatorLayersData",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return [];}}),_descriptor4=_applyDecoratedDescriptor$1(_class$k.prototype,"_crossCurveDataCollection",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return [];}}),_descriptor5=_applyDecoratedDescriptor$1(_class$k.prototype,"_animationCurveOwners",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return [];}}),_descriptor6=_applyDecoratedDescriptor$1(_class$k.prototype,"_crossCurveDataPool",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new ClassPool(CrossCurveData);}}),_descriptor7=_applyDecoratedDescriptor$1(_class$k.prototype,"_animationEventHandlerPool",[ignoreClone],{configurable:true,enumerable:true,writable:true,initializer:function initializer(){return new ClassPool(AnimationEventHandler);}})),_class$k);/**
   * Store the data for Animator playback.
   */var AnimatorController=/*#__PURE__*/function(){function AnimatorController(){this._updateFlagManager=new UpdateFlagManager();this._layers=[];this._layersMap={};}var _proto=AnimatorController.prototype;/**
     * Get the layer by name.
     * @param name - The layer's name.
     */_proto.findLayerByName=function findLayerByName(name){return this._layersMap[name];}/**
     * Add a layer to the controller.
     * @param layer - The layer to add
     */;_proto.addLayer=function addLayer(layer){this._layers.push(layer);this._layersMap[layer.name]=layer;this._distributeUpdateFlag();}/**
     * Remove a layer from the controller.
     * @param layerIndex - The index of the AnimatorLayer
     */;_proto.removeLayer=function removeLayer(layerIndex){var theLayer=this.layers[layerIndex];this._layers.splice(layerIndex,1);delete this._layersMap[theLayer.name];this._distributeUpdateFlag();}/**
     * Clear layers.
     */;_proto.clearLayers=function clearLayers(){this._layers.length=0;for(var name in this._layersMap){delete this._layersMap[name];}this._distributeUpdateFlag();}/**
     * @internal
     */;_proto._registerChangeFlag=function _registerChangeFlag(){return this._updateFlagManager.register();};_proto._distributeUpdateFlag=function _distributeUpdateFlag(){this._updateFlagManager.distribute();};_createClass$3(AnimatorController,[{key:"layers",get:/**
       * The layers in the controller.
       */function get(){return this._layers;}}]);return AnimatorController;}();/**
   * The Animation Layer contains a state machine that controls animations of a model or part of it.
   */var AnimatorControllerLayer=/** The blending weight that the layers has. It is not taken into account for the first layer. */ /** The blending mode used by the layer. It is not taken into account for the first layer. */ /** The state machine for the layer. */ /**
   * @param name - The layer's name
   */function AnimatorControllerLayer(name){this.name=name;this.weight=1.0;this.blendingMode=exports.AnimatorLayerBlendingMode.Override;this.stateMachine=void 0;};/**
   * States are the basic building blocks of a state machine. Each state contains a AnimationClip which will play while the character is in that state.
   */var AnimatorState=/*#__PURE__*/function(){/**
     * @param name - The state's name
     */function AnimatorState(name){this.name=name;this.speed=1.0;this.wrapMode=exports.WrapMode.Loop;this._clipStartTime=0;this._clipEndTime=Infinity;this._clip=void 0;this._transitions=[];}/**
     * Add an outgoing transition to the destination state.
     * @param transition - The transition
     */var _proto=AnimatorState.prototype;_proto.addTransition=function addTransition(transition){this._transitions.push(transition);}/**
     * Remove a transition from the state.
     * @param transition - The transition
     */;_proto.removeTransition=function removeTransition(transition){var index=this._transitions.indexOf(transition);index!==-1&&this._transitions.splice(index,1);}/**
     * Clears all transitions from the state.
     */;_proto.clearTransitions=function clearTransitions(){this._transitions.length=0;}/**
     * @internal
     */;_proto._getDuration=function _getDuration(){return this._clipEndTime-this._clipStartTime;};_createClass$3(AnimatorState,[{key:"transitions",get:/** The speed of the clip. 1 is normal speed, default 1. */ /** The wrap mode used in the state. */ /**
       * The transitions that are going out of the state.
       */function get(){return this._transitions;}/**
       * ƒThe clip that is being played by this animator state.
       */},{key:"clip",get:function get(){return this._clip;},set:function set(clip){this._clip=clip;this._clipEndTime=Math.min(this._clipEndTime,clip.length);}/**
       * The clip start time the user set , default is 0.
       */},{key:"clipStartTime",get:function get(){return this._clipStartTime;},set:function set(time){this._clipStartTime=time<0?0:time;}/**
       * The clip end time the user set , default is the clip duration.
       */},{key:"clipEndTime",get:function get(){return this._clipEndTime;},set:function set(time){var clip=this._clip;if(clip){this._clipEndTime=Math.min(time,clip.length);}}}]);return AnimatorState;}();/**
   * A graph controlling the interaction of states. Each state references a motion.
   */var AnimatorStateMachine=/*#__PURE__*/function(){function AnimatorStateMachine(){this.states=[];this._statesMap={};}var _proto=AnimatorStateMachine.prototype;/**
     * Add a state to the state machine.
     * @param name - The name of the new state
     */_proto.addState=function addState(name){var state=this.findStateByName(name);if(!state){state=new AnimatorState(name);this.states.push(state);this._statesMap[name]=state;}else {console.warn("The state named "+name+" has existed.");}return state;}/**
     * Remove a state from the state machine.
     * @param state - The state
     */;_proto.removeState=function removeState(state){var name=state.name;var index=this.states.indexOf(state);if(index>-1){this.states.splice(index,1);}delete this._statesMap[name];}/**
     * Get the state by name.
     * @param name - The layer's name
     */;_proto.findStateByName=function findStateByName(name){return this._statesMap[name];}/**
     * Makes a unique state name in the state machine.
     * @param name - Desired name for the state.
     * @returns Unique name.
     */;_proto.makeUniqueStateName=function makeUniqueStateName(name){var _statesMap=this._statesMap;var originName=name;var index=0;while(_statesMap[name]){name=originName+" "+index;index++;}return name;};return AnimatorStateMachine;}();exports.InterpolableValueType = void 0;(function(InterpolableValueType){InterpolableValueType[InterpolableValueType["Float"]=0]="Float";InterpolableValueType[InterpolableValueType["FloatArray"]=1]="FloatArray";InterpolableValueType[InterpolableValueType["Vector2"]=2]="Vector2";InterpolableValueType[InterpolableValueType["Vector3"]=3]="Vector3";InterpolableValueType[InterpolableValueType["Vector4"]=4]="Vector4";InterpolableValueType[InterpolableValueType["Quaternion"]=5]="Quaternion";})(exports.InterpolableValueType||(exports.InterpolableValueType={}));/**
   * Animation interpolation method.
   */exports.InterpolationType = void 0;(function(InterpolationType){InterpolationType[InterpolationType["Linear"]=0]="Linear";InterpolationType[InterpolationType["CubicSpine"]=1]="CubicSpine";InterpolationType[InterpolationType["Step"]=2]="Step";InterpolationType[InterpolationType["Hermite"]=3]="Hermite";})(exports.InterpolationType||(exports.InterpolationType={}));/**
   * Store a collection of Keyframes that can be evaluated over time.
   */var AnimationCurve=/*#__PURE__*/function(){function AnimationCurve(){this.keys=[];this.interpolation=void 0;this._valueSize=void 0;this._valueType=void 0;this._currentValue=void 0;this._length=0;this._currentIndex=0;}var _proto=AnimationCurve.prototype;/**
     * Add a new key to the curve.
     * @param key - The keyframe
     */_proto.addKey=function addKey(key){var time=key.time;this.keys.push(key);if(time>this._length){this._length=time;}if(!this._valueSize){//CM: It's not reasonable to write here.
  if(typeof key.value=="number"){this._valueSize=1;this._valueType=exports.InterpolableValueType.Float;this._currentValue=0;}if(key.value instanceof Vector2){this._valueSize=2;this._valueType=exports.InterpolableValueType.Vector2;this._currentValue=new Vector2();}if(key.value instanceof Vector3){this._valueSize=3;this._valueType=exports.InterpolableValueType.Vector3;this._currentValue=new Vector3();}if(key.value instanceof Vector4){this._valueSize=4;this._valueType=exports.InterpolableValueType.Vector4;this._currentValue=new Vector4();}if(key.value instanceof Quaternion){this._valueSize=4;this._valueType=exports.InterpolableValueType.Quaternion;this._currentValue=new Quaternion();}if(key.value instanceof Float32Array){var size=key.value.length;this._valueSize=size;this._valueType=exports.InterpolableValueType.FloatArray;this._currentValue=new Float32Array(size);}}this.keys.sort(function(a,b){return a.time-b.time;});}/**
     * Evaluate the curve at time.
     * @param time - The time within the curve you want to evaluate
     */;_proto.evaluate=function evaluate(time){var keys=this.keys,interpolation=this.interpolation;var length=this.keys.length;// Compute curIndex and nextIndex.
  var curIndex=this._currentIndex;// Reset loop.
  if(curIndex!==-1&&time<keys[curIndex].time){curIndex=-1;}var nextIndex=curIndex+1;while(nextIndex<length){if(time<keys[nextIndex].time){break;}curIndex++;nextIndex++;}this._currentIndex=curIndex;// Evaluate value.
  var value;if(curIndex===-1){value=keys[0].value;}else if(nextIndex===length){value=keys[curIndex].value;}else {// Time between first frame and end frame.
  var curFrameTime=keys[curIndex].time;var duration=keys[nextIndex].time-curFrameTime;var t=(time-curFrameTime)/duration;var dur=duration;switch(interpolation){case exports.InterpolationType.Linear:value=this._evaluateLinear(curIndex,nextIndex,t);break;case exports.InterpolationType.Step:value=this._evaluateStep(nextIndex);break;case exports.InterpolationType.CubicSpine:case exports.InterpolationType.Hermite:value=this._evaluateHermite(curIndex,nextIndex,t,dur);}}return value;}/**
     * Removes the keyframe at index and inserts key.
     * @param index - The index of the key to move
     * @param key - The key to insert
     */;_proto.moveKey=function moveKey(index,key){this.keys[index]=key;}/**
     * Removes a key.
     * @param index - The index of the key to remove
     */;_proto.removeKey=function removeKey(index){this.keys.splice(index,1);var keys=this.keys;var count=this.keys.length;var newLength=0;for(var i=count-1;i>=0;i--){if(keys[i].time>length){newLength=keys[i].time;}}this._length=newLength;};_proto._evaluateLinear=function _evaluateLinear(frameIndex,nextFrameIndex,t){var _valueType=this._valueType,keys=this.keys;switch(_valueType){case exports.InterpolableValueType.Float:return keys[frameIndex].value*(1-t)+keys[nextFrameIndex].value*t;case exports.InterpolableValueType.FloatArray:var curValue=this._currentValue;var value=keys[frameIndex].value;var nextValue=keys[nextFrameIndex].value;for(var i=0,n=value.length;i<n;i++){curValue[i]=value[i]*(1-t)+nextValue[i]*t;}return curValue;case exports.InterpolableValueType.Vector2:Vector2.lerp(keys[frameIndex].value,keys[nextFrameIndex].value,t,this._currentValue);return this._currentValue;case exports.InterpolableValueType.Vector3:Vector3.lerp(keys[frameIndex].value,keys[nextFrameIndex].value,t,this._currentValue);return this._currentValue;case exports.InterpolableValueType.Quaternion:Quaternion.slerp(keys[frameIndex].value,keys[nextFrameIndex].value,t,this._currentValue);return this._currentValue;}};_proto._evaluateStep=function _evaluateStep(nextFrameIndex){var _valueSize=this._valueSize,keys=this.keys;if(_valueSize===1){return keys[nextFrameIndex].value;}else {return keys[nextFrameIndex].value;}};_proto._evaluateHermite=function _evaluateHermite(frameIndex,nextFrameIndex,t,dur){var _valueSize=this._valueSize,keys=this.keys;var curKey=keys[frameIndex];var nextKey=keys[nextFrameIndex];switch(_valueSize){case 1:{var t0=curKey.outTangent,t1=nextKey.inTangent,p0=curKey.value,p1=nextKey.value;if(Number.isFinite(t0)&&Number.isFinite(t1)){var t2=t*t;var t3=t2*t;var a=2.0*t3-3.0*t2+1.0;var b=t3-2.0*t2+t;var c=t3-t2;var d=-2.0*t3+3.0*t2;return a*p0+b*t0*dur+c*t1*dur+d*p1;}else {return curKey.value;}}case 2:{var _p=curKey.value;var tan0=curKey.outTangent;var _p2=nextKey.value;var tan1=nextKey.inTangent;var _t=t*t;var _t2=_t*t;var _a=2.0*_t2-3.0*_t+1.0;var _b=_t2-2.0*_t+t;var _c=_t2-_t;var _d=-2.0*_t2+3.0*_t;var _t3=tan0.x,_t4=tan1.x;if(Number.isFinite(_t3)&&Number.isFinite(_t4)){this._currentValue.x=_a*_p.x+_b*_t3*dur+_c*_t4*dur+_d*_p2.x;}else {this._currentValue.x=_p.x;}_t3=tan0.y,_t4=tan1.y;if(Number.isFinite(_t3)&&Number.isFinite(_t4))this._currentValue.y=_a*_p.y+_b*_t3*dur+_c*_t4*dur+_d*_p2.y;else {this._currentValue.y=_p.y;}return this._currentValue;}case 3:{var _p3=curKey.value;var _tan=curKey.outTangent;var _p4=nextKey.value;var _tan2=nextKey.inTangent;var _t5=t*t;var _t6=_t5*t;var _a2=2.0*_t6-3.0*_t5+1.0;var _b2=_t6-2.0*_t5+t;var _c2=_t6-_t5;var _d2=-2.0*_t6+3.0*_t5;var _t7=_tan.x,_t8=_tan2.x;if(Number.isFinite(_t7)&&Number.isFinite(_t8)){this._currentValue.x=_a2*_p3.x+_b2*_t7*dur+_c2*_t8*dur+_d2*_p4.x;}else {this._currentValue.x=_p3.x;}_t7=_tan.y,_t8=_tan2.y;if(Number.isFinite(_t7)&&Number.isFinite(_t8)){this._currentValue.y=_a2*_p3.y+_b2*_t7*dur+_c2*_t8*dur+_d2*_p4.y;}else {this._currentValue.y=_p3.y;}_t7=_tan.z,_t8=_tan2.z;if(Number.isFinite(_t7)&&Number.isFinite(_t8)){this._currentValue.z=_a2*_p3.z+_b2*_t7*dur+_c2*_t8*dur+_d2*_p4.z;}else {this._currentValue.z=_p3.z;}return this._currentValue;}case 4:{var _p5=curKey.value;var _tan3=curKey.outTangent;var _p6=nextKey.value;var _tan4=nextKey.inTangent;var _t9=t*t;var _t10=_t9*t;var _a3=2.0*_t10-3.0*_t9+1.0;var _b3=_t10-2.0*_t9+t;var _c3=_t10-_t9;var _d3=-2.0*_t10+3.0*_t9;var _t11=_tan3.x,_t12=_tan4.x;if(Number.isFinite(_t11)&&Number.isFinite(_t12)){this._currentValue.x=_a3*_p5.x+_b3*_t11*dur+_c3*_t12*dur+_d3*_p6.x;}else {this._currentValue.x=_p5.x;}_t11=_tan3.y,_t12=_tan4.y;if(Number.isFinite(_t11)&&Number.isFinite(_t12)){this._currentValue.y=_a3*_p5.y+_b3*_t11*dur+_c3*_t12*dur+_d3*_p6.y;}else {this._currentValue.y=_p5.y;}_t11=_tan3.z,_t12=_tan4.z;if(Number.isFinite(_t11)&&Number.isFinite(_t12)){this._currentValue.z=_a3*_p5.z+_b3*_t11*dur+_c3*_t12*dur+_d3*_p6.z;}else {this._currentValue.z=_p5.z;}_t11=_tan3.w,_t12=_tan4.w;if(Number.isFinite(_t11)&&Number.isFinite(_t12)){this._currentValue.w=_a3*_p5.w+_b3*_t11*dur+_c3*_t12*dur+_d3*_p6.w;}else {this._currentValue.w=_p5.w;}return this._currentValue;}}};_createClass$3(AnimationCurve,[{key:"length",get:/**
       * Animation curve length in seconds.
       */function get(){return this._length;}}]);return AnimationCurve;}();/**
   * Keyframe.
   * @typeParam V - Type of Keyframe value
   */var Keyframe=function Keyframe(){this.time=void 0;this.value=void 0;};/**
   * InterpolableKeyframe.
   * @typeParam T - Type of Tangent value
   * @typeParam V - Type of Keyframe value
   */var InterpolableKeyframe=/*#__PURE__*/function(_Keyframe){_inheritsLoose$2(InterpolableKeyframe,_Keyframe);function InterpolableKeyframe(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Keyframe.call.apply(_Keyframe,[this].concat(args))||this;_this.inTangent=void 0;_this.outTangent=void 0;return _this;}return InterpolableKeyframe;}(Keyframe);/**
   * AnimationEvent lets you call a script function similar to SendMessage as part of playing back an animation.
   */var AnimationEvent=function AnimationEvent(){this.time=void 0;this.functionName=void 0;this.parameter=void 0;};exports.AnimatorConditionMode = void 0;(function(AnimatorConditionMode){AnimatorConditionMode[AnimatorConditionMode["If"]=0]="If";AnimatorConditionMode[AnimatorConditionMode["IfNot"]=1]="IfNot";AnimatorConditionMode[AnimatorConditionMode["Greater"]=2]="Greater";AnimatorConditionMode[AnimatorConditionMode["Less"]=3]="Less";AnimatorConditionMode[AnimatorConditionMode["Equals"]=4]="Equals";AnimatorConditionMode[AnimatorConditionMode["NotEquals"]=5]="NotEquals";})(exports.AnimatorConditionMode||(exports.AnimatorConditionMode={}));/**
   * SkyboxMaterial
   */var SkyBoxMaterial=/*#__PURE__*/function(_Material){_inheritsLoose$2(SkyBoxMaterial,_Material);function SkyBoxMaterial(engine){var _this;_this=_Material.call(this,engine,Shader.find("skybox"))||this;_this.renderState.rasterState.cullMode=exports.CullMode.Off;_this.renderState.depthState.compareFunction=exports.CompareFunction.LessEqual;return _this;}/** Texture cube map of the sky box material. */_createClass$3(SkyBoxMaterial,[{key:"textureCubeMap",get:function get(){return this.shaderData.getTexture("u_cube");},set:function set(v){this.shaderData.setTexture("u_cube",v);}}]);return SkyBoxMaterial;}(Material);var DirtyFlagType;/**
   * Blend mode enums of the particle renderer's material.
   */(function(DirtyFlagType){DirtyFlagType[DirtyFlagType["Position"]=1]="Position";DirtyFlagType[DirtyFlagType["Velocity"]=2]="Velocity";DirtyFlagType[DirtyFlagType["Acceleration"]=4]="Acceleration";DirtyFlagType[DirtyFlagType["Color"]=8]="Color";DirtyFlagType[DirtyFlagType["Alpha"]=16]="Alpha";DirtyFlagType[DirtyFlagType["Size"]=32]="Size";DirtyFlagType[DirtyFlagType["StartAngle"]=64]="StartAngle";DirtyFlagType[DirtyFlagType["StartTime"]=128]="StartTime";DirtyFlagType[DirtyFlagType["LifeTime"]=256]="LifeTime";DirtyFlagType[DirtyFlagType["RotateVelocity"]=512]="RotateVelocity";DirtyFlagType[DirtyFlagType["Scale"]=1024]="Scale";DirtyFlagType[DirtyFlagType["Everything"]=4294967295]="Everything";})(DirtyFlagType||(DirtyFlagType={}));exports.ParticleRendererBlendMode = void 0;/**
   * Particle Renderer Component.
   */(function(ParticleRendererBlendMode){ParticleRendererBlendMode[ParticleRendererBlendMode["Transparent"]=0]="Transparent";ParticleRendererBlendMode[ParticleRendererBlendMode["Additive"]=1]="Additive";})(exports.ParticleRendererBlendMode||(exports.ParticleRendererBlendMode={}));var ParticleRenderer=/*#__PURE__*/function(_MeshRenderer){_inheritsLoose$2(ParticleRenderer,_MeshRenderer);/** The max number of indices that Uint16Array can support. */ParticleRenderer._getRandom=function _getRandom(){return Math.random()-0.5;};function ParticleRenderer(props){var _this;_this=_MeshRenderer.call(this,props)||this;_this._vertexStride=void 0;_this._vertices=void 0;_this._vertexBuffer=void 0;_this._maxCount=1000;_this._position=new Vector3();_this._positionRandomness=new Vector3();_this._positionArray=void 0;_this._velocity=new Vector3();_this._velocityRandomness=new Vector3();_this._acceleration=new Vector3();_this._accelerationRandomness=new Vector3();_this._color=new Color(1,1,1,1);_this._colorRandomness=0;_this._size=1;_this._sizeRandomness=0;_this._alpha=1;_this._alphaRandomness=0;_this._startAngle=0;_this._startAngleRandomness=0;_this._rotateVelocity=0;_this._rotateVelocityRandomness=0;_this._lifetime=5;_this._startTimeRandomness=0;_this._scale=1;_this._isOnce=false;_this._onceTime=0;_this._time=0;_this._isInit=false;_this._isStart=false;_this._updateDirtyFlag=DirtyFlagType.Everything;_this._isRotateToVelocity=false;_this._isUseOriginColor=false;_this._isScaleByLifetime=false;_this._is2d=true;_this._isFadeIn=false;_this._isFadeOut=false;_this._playOnEnable=true;_this._blendMode=exports.ParticleRendererBlendMode.Transparent;_this.spriteSheet=void 0;_this.setMaterial(_this._createMaterial());return _this;}/**
     * @override
     * @internal
     */var _proto=ParticleRenderer.prototype;_proto.update=function update(deltaTime){if(!this._isInit||!this._isStart){return;}// Stop after play once
  if(this._isOnce&&this._time>this._onceTime){return this.stop();}if(this._updateDirtyFlag){this._updateBuffer();this._updateDirtyFlag=0;}this._time+=deltaTime/1000;this.shaderData.setFloat("u_time",this._time);}/**
     * @override
     * @internal
     */;_proto._onEnable=function _onEnable(){_MeshRenderer.prototype._onEnable.call(this);if(this._playOnEnable){this.start();}}/**
     * Start emitting.
     */;_proto.start=function start(){this._isStart=true;this._time=0;}/**
     * Stop emitting.
     */;_proto.stop=function stop(){this._isStart=false;};_proto._createMaterial=function _createMaterial(){var material=new Material(this.engine,Shader.find("particle-shader"));var renderState=material.renderState;var target=renderState.blendState.targetBlendState;target.enabled=true;target.sourceColorBlendFactor=exports.BlendFactor.SourceAlpha;target.destinationColorBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;target.sourceAlphaBlendFactor=exports.BlendFactor.One;target.destinationAlphaBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;renderState.depthState.writeEnabled=false;material.renderQueueType=exports.RenderQueueType.Transparent;this.isUseOriginColor=true;this.is2d=true;this.isFadeOut=true;return material;};_proto._createMesh=function _createMesh(){var mesh=new BufferMesh(this._entity.engine,"particleMesh");var vertexStride=96;var vertexCount=this._maxCount*4;var vertexFloatCount=vertexCount*vertexStride;var vertices=new Float32Array(vertexFloatCount);var indices=null;var useUint32=false;if(vertexCount>ParticleRenderer._uint16VertexLimit){if(this.engine._hardwareRenderer.canIUse(exports.GLCapabilityType.elementIndexUint)){useUint32=true;indices=new Uint32Array(6*this._maxCount);}else {throw Error("The vertex count is over limit.");}}else {indices=new Uint16Array(6*this._maxCount);}for(var i=0,idx=0;i<this._maxCount;++i){var startIndex=i*4;indices[idx++]=startIndex;indices[idx++]=startIndex+1;indices[idx++]=startIndex+2;indices[idx++]=startIndex;indices[idx++]=startIndex+2;indices[idx++]=startIndex+3;}var vertexElements=[new VertexElement("a_position",0,exports.VertexElementFormat.Vector3,0),new VertexElement("a_velocity",12,exports.VertexElementFormat.Vector3,0),new VertexElement("a_acceleration",24,exports.VertexElementFormat.Vector3,0),new VertexElement("a_color",36,exports.VertexElementFormat.Vector4,0),new VertexElement("a_lifeAndSize",52,exports.VertexElementFormat.Vector4,0),new VertexElement("a_rotation",68,exports.VertexElementFormat.Vector2,0),new VertexElement("a_uv",76,exports.VertexElementFormat.Vector3,0),new VertexElement("a_normalizedUv",88,exports.VertexElementFormat.Vector2,0)];var vertexBuffer=new Buffer(this.engine,exports.BufferBindFlag.VertexBuffer,vertexFloatCount*4,exports.BufferUsage.Dynamic);var indexBuffer=new Buffer(this.engine,exports.BufferBindFlag.IndexBuffer,indices,exports.BufferUsage.Dynamic);mesh.setVertexBufferBinding(vertexBuffer,vertexStride);mesh.setIndexBufferBinding(indexBuffer,useUint32?exports.IndexFormat.UInt32:exports.IndexFormat.UInt16);mesh.setVertexElements(vertexElements);mesh.addSubMesh(0,indices.length);this._vertexBuffer=vertexBuffer;this._vertexStride=vertexStride/4;this._vertices=vertices;return mesh;};_proto._updateBuffer=function _updateBuffer(){for(var x=0;x<this._maxCount;x++){this._updateSingleBuffer(x);}this._vertexBuffer.setData(this._vertices);};_proto._updateSingleBuffer=function _updateSingleBuffer(i){var _updateDirtyFlag=this._updateDirtyFlag,vertices=this._vertices,vertexStride=this._vertexStride;var getRandom=ParticleRenderer._getRandom;var offset=i*4;var k0=offset*vertexStride;var k1=(offset+1)*vertexStride;var k2=(offset+2)*vertexStride;var k3=(offset+3)*vertexStride;if(_updateDirtyFlag&DirtyFlagType.Position){var _this$_position=this._position,x=_this$_position.x,y=_this$_position.y,z=_this$_position.z;var _positionArray=this._positionArray,_positionRandomness=this._positionRandomness;if(_positionArray){if(_positionArray.length!==this._maxCount){throw Error("The length of positionArray must be equal to maxCount.");}var pos=_positionArray[i];x+=pos.x;y+=pos.y;z+=pos.z;}else {x+=getRandom()*_positionRandomness.x;y+=getRandom()*_positionRandomness.y;z+=getRandom()*_positionRandomness.z;}vertices[k0]=vertices[k1]=vertices[k2]=vertices[k3]=x;vertices[k0+1]=vertices[k1+1]=vertices[k2+1]=vertices[k3+1]=y;vertices[k0+2]=vertices[k1+2]=vertices[k2+2]=vertices[k3+2]=z;}if(_updateDirtyFlag&DirtyFlagType.Velocity){var _velocity=this._velocity,_velocityRandomness=this._velocityRandomness;vertices[k0+3]=vertices[k1+3]=vertices[k2+3]=vertices[k3+3]=_velocity.x+getRandom()*_velocityRandomness.x;vertices[k0+4]=vertices[k1+4]=vertices[k2+4]=vertices[k3+4]=_velocity.y+getRandom()*_velocityRandomness.y;vertices[k0+5]=vertices[k1+5]=vertices[k2+5]=vertices[k3+5]=_velocity.z+getRandom()*_velocityRandomness.z;}if(_updateDirtyFlag&DirtyFlagType.Acceleration){var _acceleration=this._acceleration,_accelerationRandomness=this._accelerationRandomness;vertices[k0+6]=vertices[k1+6]=vertices[k2+6]=vertices[k3+6]=_acceleration.x+getRandom()*_accelerationRandomness.x;vertices[k0+7]=vertices[k1+7]=vertices[k2+7]=vertices[k3+7]=_acceleration.y+getRandom()*_accelerationRandomness.y;vertices[k0+8]=vertices[k1+8]=vertices[k2+8]=vertices[k3+8]=_acceleration.z+getRandom()*_accelerationRandomness.z;}if(_updateDirtyFlag&DirtyFlagType.Color){var _color=this._color,_colorRandomness=this._colorRandomness;vertices[k0+9]=vertices[k1+9]=vertices[k2+9]=vertices[k3+9]=MathUtil.clamp(_color.r+getRandom()*_colorRandomness,0,1);vertices[k0+10]=vertices[k1+10]=vertices[k2+10]=vertices[k3+10]=MathUtil.clamp(_color.g+getRandom()*_colorRandomness,0,1);vertices[k0+11]=vertices[k1+11]=vertices[k2+11]=vertices[k3+11]=MathUtil.clamp(_color.b+getRandom()*_colorRandomness,0,1);}if(_updateDirtyFlag&DirtyFlagType.Alpha){vertices[k0+12]=vertices[k1+12]=vertices[k2+12]=vertices[k3+12]=MathUtil.clamp(this._alpha+getRandom()*this._alphaRandomness,0,1);}if(_updateDirtyFlag&DirtyFlagType.StartTime){vertices[k0+13]=vertices[k1+13]=vertices[k2+13]=vertices[k3+13]=Math.random()*this._startTimeRandomness;}if(_updateDirtyFlag&DirtyFlagType.LifeTime){var _lifetime=this._lifetime;vertices[k0+14]=vertices[k1+14]=vertices[k2+14]=vertices[k3+14]=_lifetime+getRandom()*_lifetime;}// Update the duration of play once when startTime or lifetime changes.
  if(_updateDirtyFlag&DirtyFlagType.StartTime||_updateDirtyFlag&DirtyFlagType.LifeTime){this._onceTime=Math.max(this._onceTime,vertices[k0+13]+vertices[k0+14]);}if(_updateDirtyFlag&DirtyFlagType.Size){var _size=this._size;vertices[k0+15]=vertices[k1+15]=vertices[k2+15]=vertices[k3+15]=Math.max(_size+getRandom()*this._sizeRandomness*_size*2,0);}if(_updateDirtyFlag&DirtyFlagType.Scale){vertices[k0+16]=vertices[k1+16]=vertices[k2+16]=vertices[k3+16]=this._scale;}if(_updateDirtyFlag&DirtyFlagType.StartAngle){vertices[k0+17]=vertices[k1+17]=vertices[k2+17]=vertices[k3+17]=this._startAngle+getRandom()*Math.PI*this._startAngleRandomness*2;}if(_updateDirtyFlag&DirtyFlagType.RotateVelocity){vertices[k0+18]=vertices[k1+18]=vertices[k2+18]=vertices[k3+18]=this._rotateVelocity+getRandom()*this._rotateVelocityRandomness;}this._updateSingleUv(i,k0,k1,k2,k3);};_proto._updateSingleUv=function _updateSingleUv(i,k0,k1,k2,k3){var spriteSheet=this.spriteSheet;var texture=this.getMaterial().shaderData.getTexture("u_texture");var vertices=this._vertices;if(texture){var width=texture.width;var height=texture.height;if(spriteSheet){var _spriteSheet=spriteSheet[i%spriteSheet.length],x=_spriteSheet.x,y=_spriteSheet.y,w=_spriteSheet.w,h=_spriteSheet.h;var u=x/width;var v=y/height;var p=u+w/width;var q=v+h/height;var ratio=h/w;// left bottom
  vertices[k0+19]=u;vertices[k0+20]=q;vertices[k0+21]=ratio;// right bottom
  vertices[k1+19]=p;vertices[k1+20]=q;vertices[k1+21]=ratio;// right top
  vertices[k2+19]=p;vertices[k2+20]=v;vertices[k2+21]=ratio;// left top
  vertices[k3+19]=u;vertices[k3+20]=v;vertices[k3+21]=ratio;}else {var _ratio=height/width;// left bottom
  vertices[k0+19]=0;vertices[k0+20]=1;vertices[k0+21]=_ratio;// right bottom
  vertices[k1+19]=1;vertices[k1+20]=1;vertices[k1+21]=_ratio;// right top
  vertices[k2+19]=1;vertices[k2+20]=0;vertices[k2+21]=_ratio;// left top
  vertices[k3+19]=0;vertices[k3+20]=0;vertices[k3+21]=_ratio;}}else {// left bottom
  vertices[k0+19]=0;vertices[k0+20]=0;vertices[k0+21]=1;// right bottom
  vertices[k1+19]=1;vertices[k1+20]=0;vertices[k1+21]=1;// right top
  vertices[k2+19]=1;vertices[k2+20]=1;vertices[k2+21]=1;// left top
  vertices[k3+19]=0;vertices[k3+20]=1;vertices[k3+21]=1;}vertices[k0+22]=-0.5;vertices[k0+23]=-0.5;vertices[k1+22]=0.5;vertices[k1+23]=-0.5;vertices[k2+22]=0.5;vertices[k2+23]=0.5;vertices[k3+22]=-0.5;vertices[k3+23]=0.5;};_createClass$3(ParticleRenderer,[{key:"texture",get:/**
       * Texture of particle.
       */function get(){return this.getMaterial().shaderData.getTexture("u_texture");},set:function set(texture){if(texture){this.shaderData.enableMacro("particleTexture");this.getMaterial().shaderData.setTexture("u_texture",texture);}else {this.shaderData.disableMacro("particleTexture");}}/**
       * Position of particles.
       */},{key:"position",get:function get(){return this._position;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Position;this._position=value;}/**
       * Random range of positions.
       */},{key:"positionRandomness",get:function get(){return this._positionRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Position;this._positionRandomness=value;}/**
       * Array of fixed positions.
       */},{key:"positionArray",get:function get(){return this._positionArray;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Position;this._positionArray=value;}/**
       * Velocity of particles.
       */},{key:"velocity",get:function get(){return this._velocity;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Velocity;this._velocity=value;}/**
       * Random range of velocity.
       */},{key:"velocityRandomness",get:function get(){return this._velocityRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Velocity;this._velocityRandomness=value;}/**
       * Acceleration of particles.
       */},{key:"acceleration",get:function get(){return this._acceleration;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Acceleration;this._acceleration=value;}/**
       * Random range of acceleration.
       */},{key:"accelerationRandomness",get:function get(){return this._accelerationRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Acceleration;this._accelerationRandomness=value;}/**
       * Color of particles.
       */},{key:"color",get:function get(){return this._color;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Color;this._color=value;}/**
       * Random range of color.
       */},{key:"colorRandomness",get:function get(){return this._colorRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Color;this._colorRandomness=value;}/**
       * Size of particles.
       */},{key:"size",get:function get(){return this._size;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Size;this._size=value;}/**
       * Random range of size.
       */},{key:"sizeRandomness",get:function get(){return this._sizeRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Size;this._sizeRandomness=value;}/**
       * Alpha of particles.
       */},{key:"alpha",get:function get(){return this._alpha;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Alpha;this._alpha=value;}/**
       * Random range of alpha.
       */},{key:"alphaRandomness",get:function get(){return this._alphaRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Alpha;this._alphaRandomness=value;}/**
       * Angle of particles.
       */},{key:"angle",get:function get(){return this._startAngle;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.StartAngle;this._startAngle=value;}/**
       * Random range of angle.
       */},{key:"angleRandomness",get:function get(){return this._startAngleRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.StartAngle;this._startAngleRandomness=value;}/**
       * Rotate velocity of particles.
       */},{key:"rotateVelocity",get:function get(){return this._rotateVelocity;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.RotateVelocity;this._rotateVelocity=value;}/**
       * Random range of rotate velocity.
       */},{key:"rotateVelocityRandomness",get:function get(){return this._rotateVelocityRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.RotateVelocity;this._rotateVelocityRandomness=value;}/**
       * Lifetime of particles.
       */},{key:"lifetime",get:function get(){return this._lifetime;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.LifeTime;this._lifetime=value;this._onceTime=0;}/**
       * Random range of start time.
       */},{key:"startTimeRandomness",get:function get(){return this._startTimeRandomness;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.StartTime;this._startTimeRandomness=value;this._onceTime=0;}/**
       * Scale factor of particles.
       */},{key:"scale",get:function get(){return this._scale;},set:function set(value){this._updateDirtyFlag|=DirtyFlagType.Scale;this._scale=value;}/**
       * Max count of particles.
       */},{key:"maxCount",get:function get(){return this._maxCount;},set:function set(value){this._isStart=false;this._isInit=false;this._maxCount=value;this._updateDirtyFlag=DirtyFlagType.Everything;this.mesh=this._createMesh();this._updateBuffer();this._isInit=true;this.shaderData.setFloat("u_time",0);}/**
       * Whether play once.
       */},{key:"isOnce",get:function get(){return this._isOnce;},set:function set(value){this._time=0;this.shaderData.setInt("u_once",value?1:0);this._isOnce=value;}/**
       * Whether follow the direction of velocity.
       */},{key:"isRotateToVelocity",get:function get(){return this._isRotateToVelocity;},set:function set(value){if(value){this.shaderData.enableMacro("rotateToVelocity");}else {this.shaderData.disableMacro("rotateToVelocity");}this._isRotateToVelocity=value;}/**
       * Whether use origin color.
       */},{key:"isUseOriginColor",get:function get(){return this._isUseOriginColor;},set:function set(value){if(value){this.shaderData.enableMacro("useOriginColor");}else {this.shaderData.disableMacro("useOriginColor");}this._isUseOriginColor=value;}/**
       * Whether scale by lifetime.
       */},{key:"isScaleByLifetime",get:function get(){return this._isScaleByLifetime;},set:function set(value){if(value){this.shaderData.enableMacro("isScaleByLifetime");}else {this.shaderData.disableMacro("isScaleByLifetime");}this._isScaleByLifetime=value;}/**
       * Whether 2D rendering.
       */},{key:"is2d",get:function get(){return this._is2d;},set:function set(value){if(value){this.shaderData.enableMacro("is2d");}else {this.shaderData.disableMacro("is2d");this.getMaterial().renderState.rasterState.cullMode=exports.CullMode.Off;}this._is2d=value;}/**
       * Whether fade in.
       */},{key:"isFadeIn",get:function get(){return this._isFadeIn;},set:function set(value){if(value){this.shaderData.enableMacro("fadeIn");}else {this.shaderData.disableMacro("fadeIn");}this._isFadeIn=value;}/**
       * Whether fade out.
       */},{key:"isFadeOut",get:function get(){return this._isFadeOut;},set:function set(value){if(value){this.shaderData.enableMacro("fadeOut");}else {this.shaderData.disableMacro("fadeOut");}this._isFadeOut=value;}/**
       * Whether play on enable.
       */},{key:"playOnEnable",get:function get(){return this._playOnEnable;},set:function set(value){this._playOnEnable=value;if(value){this.start();}else {this.stop();}}/**
       * Blend mode of the particle renderer's material.
       */},{key:"blendMode",get:function get(){return this._blendMode;},set:function set(value){var blendState=this.getMaterial().renderState.blendState;var target=blendState.targetBlendState;if(value===exports.ParticleRendererBlendMode.Transparent){target.enabled=true;target.sourceColorBlendFactor=exports.BlendFactor.SourceAlpha;target.destinationColorBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;target.sourceAlphaBlendFactor=exports.BlendFactor.One;target.destinationAlphaBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;}else if(value===exports.ParticleRendererBlendMode.Additive){target.enabled=true;target.sourceColorBlendFactor=exports.BlendFactor.SourceAlpha;target.destinationColorBlendFactor=exports.BlendFactor.One;target.sourceAlphaBlendFactor=exports.BlendFactor.One;target.destinationAlphaBlendFactor=exports.BlendFactor.OneMinusSourceAlpha;}this._blendMode=value;}}]);return ParticleRenderer;}(MeshRenderer);ParticleRenderer._uint16VertexLimit=65535;var FRAG_SHADER="#define GLSLIFY 1\nvarying vec2 v_uv;uniform sampler2D u_texture;void main(void){gl_FragColor=texture2D(u_texture,v_uv);}";// eslint-disable-line
  var VERT_SHADER="#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;uniform mat4 u_projMat;uniform mat4 u_viewMat;void main(){gl_Position=u_projMat*u_viewMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}";// eslint-disable-line
  Shader.create("trail",VERT_SHADER,FRAG_SHADER);var TrailMaterial=/*#__PURE__*/function(_Material){_inheritsLoose$2(TrailMaterial,_Material);function TrailMaterial(engine){var _this;_this=_Material.call(this,engine,Shader.find("trail"))||this;var target=_this.renderState.blendState.targetBlendState;target.enabled=true;target.sourceColorBlendFactor=target.sourceAlphaBlendFactor=exports.BlendFactor.SourceAlpha;target.destinationColorBlendFactor=target.destinationAlphaBlendFactor=exports.BlendFactor.One;_this.renderState.depthState.writeEnabled=false;return _this;}return TrailMaterial;}(Material);var _tempVector3=new Vector3();/**
   * @deprecated
   */var TrailRenderer=/*#__PURE__*/function(_MeshRenderer){_inheritsLoose$2(TrailRenderer,_MeshRenderer);/**
     * @deprecated
     */function TrailRenderer(entity,props){var _this;_this=_MeshRenderer.call(this,entity)||this;_this._vertexStride=void 0;_this._vertices=void 0;_this._vertexBuffer=void 0;_this._stroke=void 0;_this._minSeg=void 0;_this._lifetime=void 0;_this._maxPointNum=void 0;_this._points=void 0;_this._pointStates=void 0;_this._strapPoints=void 0;_this._curPointNum=void 0;_this._prePointsNum=void 0;_this._stroke=props.stroke||0.2;_this._minSeg=props.minSeg||0.02;_this._lifetime=props.lifetime||1000;_this._maxPointNum=_this._lifetime/1000.0*entity.engine.targetFrameRate;_this._points=[];_this._pointStates=[];_this._strapPoints=[];for(var i=0;i<_this._maxPointNum;i++){_this._points.push(new Vector3());_this._pointStates.push(_this._lifetime);_this._strapPoints.push(new Vector3());_this._strapPoints.push(new Vector3());}_this._curPointNum=0;var mtl=props.material||new TrailMaterial(_this.engine);_this.setMaterial(mtl);_this.setTexture(props.texture);_this._initGeometry();return _this;}/**
     * @internal
     */var _proto=TrailRenderer.prototype;_proto.update=function update(deltaTime){var mov=0,newIdx=0;for(var i=0;i<this._curPointNum;i++){this._pointStates[i]-=deltaTime;if(this._pointStates[i]<0){mov++;}else if(mov>0){newIdx=i-mov;// Move data
  this._pointStates[newIdx]=this._pointStates[i];// Move point
  this._points[i].cloneTo(this._points[newIdx]);}}this._curPointNum-=mov;var appendNewPoint=true;if(this._curPointNum===this._maxPointNum){appendNewPoint=false;}else if(this._curPointNum>0){var lastPoint=this._points[this._points.length-1];if(Vector3.distance(this.entity.worldPosition,lastPoint)<this._minSeg){appendNewPoint=false;}}if(appendNewPoint){this._pointStates[this._curPointNum]=this._lifetime;this.entity.worldPosition.cloneTo(this._points[this._curPointNum]);this._curPointNum++;}}/**
     * @internal
     */;_proto._render=function _render(camera){this._updateStrapVertices(camera,this._points);this._updateStrapCoords();this._vertexBuffer.setData(this._vertices);_MeshRenderer.prototype._render.call(this,camera);}/**
     * @deprecated
     * Set trail texture.
     * @param texture
     */;_proto.setTexture=function setTexture(texture){if(texture){this.getMaterial().shaderData.setTexture("u_texture",texture);}};_proto._initGeometry=function _initGeometry(){var mesh=new BufferMesh(this._entity.engine);var vertexStride=20;var vertexCount=this._maxPointNum*2;var vertexFloatCount=vertexCount*vertexStride;var vertices=new Float32Array(vertexFloatCount);var vertexElements=[new VertexElement("POSITION",0,exports.VertexElementFormat.Vector3,0),new VertexElement("TEXCOORD_0",12,exports.VertexElementFormat.Vector2,0)];var vertexBuffer=new Buffer(this.engine,vertexFloatCount*4,exports.BufferUsage.Dynamic);mesh.setVertexBufferBinding(vertexBuffer,vertexStride);mesh.setVertexElements(vertexElements);mesh.addSubMesh(0,vertexCount,exports.MeshTopology.TriangleStrip);this._vertexBuffer=vertexBuffer;this._vertexStride=vertexStride;this._vertices=vertices;this.mesh=mesh;};_proto._updateStrapVertices=function _updateStrapVertices(camera,points){var m=camera.viewMatrix;var e=m.elements;var vx=new Vector3(e[0],e[4],e[8]);var vy=new Vector3(e[1],e[5],e[9]);var vz=new Vector3(e[2],e[6],e[10]);var s=this._stroke;vy.scale(s);var up=new Vector3();var down=new Vector3();var rotation=new Quaternion();Vector3.transformByQuat(vx,rotation,vx);Vector3.transformByQuat(vy,rotation,vy);var dy=new Vector3();var cross=new Vector3();var perpVector=new Vector3();vx.normalize();var vertices=this._vertices;//-- quad pos
  for(var i=0;i<this._maxPointNum;i++){//-- center pos
  if(i<this._curPointNum){var p=points[i];if(i===this._curPointNum-1&&i!==0){Vector3.subtract(p,points[i-1],perpVector);}else {Vector3.subtract(points[i+1],p,perpVector);}this._projectOnPlane(perpVector,vz,perpVector);perpVector.normalize();// Calculate angle between vectors
  var angle=Math.acos(Vector3.dot(vx,perpVector));Vector3.cross(vx,perpVector,cross);if(Vector3.dot(cross,vz)<=0){angle=Math.PI*2-angle;}Quaternion.rotationAxisAngle(vz,angle,rotation);Vector3.transformByQuat(vy,rotation,dy);Vector3.add(p,dy,up);Vector3.subtract(p,dy,down);}var p0=i*2*this._vertexStride/4;var p1=(i*2+1)*this._vertexStride/4;vertices[p0]=up.x;vertices[p0+1]=up.y;vertices[p0+2]=up.z;vertices[p1]=down.x;vertices[p1+1]=down.y;vertices[p1+2]=down.z;}};_proto._updateStrapCoords=function _updateStrapCoords(){if(this._prePointsNum===this._curPointNum){return;}this._prePointsNum=this._curPointNum;var count=this._curPointNum;var texDelta=1.0/count;var vertices=this._vertices;for(var i=0;i<count;i++){var d=1.0-i*texDelta;var p0=i*2*this._vertexStride/4;var p1=(i*2+1)*this._vertexStride/4;vertices[p0]=0;vertices[p0+1]=d;vertices[p1]=1.0;vertices[p1+1]=d;}};_proto._projectOnVector=function _projectOnVector(a,p,out){var n_p=p.clone();Vector3.normalize(n_p,n_p);var cosine=Vector3.dot(a,n_p);out.x=n_p.x*cosine;out.y=n_p.y*cosine;out.z=n_p.z*cosine;};_proto._projectOnPlane=function _projectOnPlane(a,n,out){this._projectOnVector(a,n,_tempVector3);Vector3.subtract(a,_tempVector3,out);};return TrailRenderer;}(MeshRenderer);/**
   * AABBox = {
   *  min: [-1,-1,-1],
   *  max: [1,1,1]
   * };
   *
   * Sphere = {
   *  center: [0,0,0],
   *  radius: 1
   * };
   */ /**
   * Check whether the boxes intersect.
   * @param boxA - The first box to check
   * @param boxB - The second box to check
   * @returns True if the boxes intersect, false otherwise
   */function intersectBox2Box(boxA,boxB){return boxA.min.x<=boxB.max.x&&boxA.max.x>=boxB.min.x&&boxA.min.y<=boxB.max.y&&boxA.max.y>=boxB.min.y&&boxA.min.z<=boxB.max.z&&boxA.max.z>=boxB.min.z;}/**
   * Check whether the spheres intersect.
   * @param sphereA - The first sphere to check
   * @param sphereB - The second sphere to check
   * @returns True if the spheres intersect, false otherwise
   */function intersectSphere2Sphere(sphereA,sphereB){var distance=Vector3.distance(sphereA.center,sphereB.center);return distance<sphereA.radius+sphereA.radius;}/**
   * Check whether the sphere and the box intersect.
   * @param sphere - The sphere to check
   * @param box - The box to check
   * @returns True if the sphere and the box intersect, false otherwise
   */function intersectSphere2Box(sphere,box){var center=sphere.center;var closestPoint=new Vector3(Math.max(box.min.x,Math.min(center.x,box.max.x)),Math.max(box.min.y,Math.min(center.y,box.max.y)),Math.max(box.min.z,Math.min(center.z,box.max.z)));var distance=Vector3.distance(center,closestPoint);return distance<sphere.radius;}/**
   * Detect collisions between the Collider on the current entity and other Colliders in the scene.
   */var CollisionDetection=/*#__PURE__*/function(_Script){_inheritsLoose$2(CollisionDetection,_Script);/**
     * Constructor of the collision detection.
     * @param entity - Entity to which the collision detection belong
     */function CollisionDetection(entity){var _this;_this=_Script.call(this,entity)||this;_this._colliderManager=void 0;_this._myCollider=void 0;_this._overlappedCollider=void 0;_this._sphere=void 0;_this._box=new BoundingBox();return _this;}/**
     * The collider that intersects with the collider on the current Entity.
     */var _proto=CollisionDetection.prototype;/**
     * When every frame is updated, calculate the collision with other collider.
     */_proto.onUpdate=function onUpdate(deltaTime){_Script.prototype.onUpdate.call(this,deltaTime);var overlappedCollider=null;if(this._colliderManager&&this._myCollider){var colliders=this._colliderManager.colliders;if(this._myCollider instanceof ABoxCollider){this._updateWorldBox(this._myCollider,this._box);for(var i=0,len=colliders.length;i<len;i++){var collider=colliders[i];if(collider!=this._myCollider&&this._boxCollision(collider)){overlappedCollider=collider;var scripts=this.entity._scripts;for(var _i=0,_len=scripts.length;_i<_len;_i++){scripts.get(_i).onTriggerStay(collider);}}}// end of for
  }else if(this._myCollider instanceof ASphereCollider){this._sphere=this._getWorldSphere(this._myCollider);for(var _i2=0,_len2=colliders.length;_i2<_len2;_i2++){var _collider=colliders[_i2];if(_collider!=this._myCollider&&this._sphereCollision(_collider)){overlappedCollider=_collider;var _scripts=this.entity._scripts;for(var _i3=0,_len3=_scripts.length;_i3<_len3;_i3++){_scripts.get(_i3).onTriggerStay(_collider);}}}// end of for
  }}// end of if
  //-- overlap events
  if(overlappedCollider!=null&&this._overlappedCollider!=overlappedCollider){var _scripts2=this.entity._scripts;for(var _i4=0,_len4=_scripts2.length;_i4<_len4;_i4++){_scripts2.get(_i4).onTriggerEnter(overlappedCollider);}}if(this._overlappedCollider!=null&&this._overlappedCollider!=overlappedCollider){var _scripts3=this.entity._scripts;for(var _i5=0,_len5=_scripts3.length;_i5<_len5;_i5++){_scripts3.get(_i5).onTriggerExit(this._overlappedCollider);}}this._overlappedCollider=overlappedCollider;}/**
     * Calculate the boundingbox in world space from boxCollider.
     * @param boxCollider - The boxCollider to calculate
     * @param out - The calculated boundingBox
     */;_proto._updateWorldBox=function _updateWorldBox(boxCollider,out){var mat=boxCollider.entity.transform.worldMatrix;var source=CollisionDetection._tempBox1;boxCollider.boxMax.cloneTo(source.max);boxCollider.boxMin.cloneTo(source.min);BoundingBox.transform(source,mat,out);}/**
     * Get the sphere info of the given sphere collider in world space.
     * @param sphereCollider - The given sphere collider
     */;_proto._getWorldSphere=function _getWorldSphere(sphereCollider){var center=new Vector3();Vector3.transformCoordinate(sphereCollider.center,sphereCollider.entity.transform.worldMatrix,center);return {radius:sphereCollider.radius,center:center};}/**
     * Collider and another collider do collision detection.
     * @param other - The another collider to collision detection
     */;_proto._boxCollision=function _boxCollision(other){if(other instanceof ABoxCollider){var box=CollisionDetection._tempBox2;this._updateWorldBox(other,box);return intersectBox2Box(box,this._box);}else if(other instanceof ASphereCollider){var sphere=this._getWorldSphere(other);return intersectSphere2Box(sphere,this._box);}return false;}/**
     * Collider and another collider do collision detection.
     * @param other - The another collider to collision detection
     */;_proto._sphereCollision=function _sphereCollision(other){if(other instanceof ABoxCollider){var box=CollisionDetection._tempBox2;this._updateWorldBox(other,box);return intersectSphere2Box(this._sphere,box);}else if(other instanceof ASphereCollider){var sphere=this._getWorldSphere(other);return intersectSphere2Sphere(sphere,this._sphere);}return false;};_proto.onAwake=function onAwake(){this._colliderManager=this.scene.findFeature(ColliderFeature);this._myCollider=this.entity.getComponent(Collider);};_createClass$3(CollisionDetection,[{key:"overlappedCollider",get:function get(){return this._overlappedCollider;}}]);return CollisionDetection;}(Script);CollisionDetection._tempBox1=new BoundingBox();CollisionDetection._tempBox2=new BoundingBox();/**
   * Fog.
   */var Fog=/*#__PURE__*/function(_Component){_inheritsLoose$2(Fog,_Component);function Fog(entity){var _this;_this=_Component.call(this,entity)||this;_this._color=new Color(1,0,0,1);_this.color=_this._color;return _this;}/**
     * @internal
     * @override
     */var _proto=Fog.prototype;_proto._onEnable=function _onEnable(){this.scene.shaderData.enableMacro("O3_HAS_FOG");}/**
     * @internal
     * @override
     */;_proto._onDisable=function _onDisable(){this.scene.shaderData.disableMacro("O3_HAS_FOG");};_createClass$3(Fog,[{key:"color",get:/**
       * Fog color.
       */function get(){return this._color;},set:function set(value){this._color=value;this.scene.shaderData.setColor(Fog._colorProperty,value);}}]);return Fog;}(Component);Fog._colorProperty=Shader.getPropertyByName("u_fogColor");/**
   * Exponential fog.
   */var EXP2Fog=/*#__PURE__*/function(_Fog){_inheritsLoose$2(EXP2Fog,_Fog);function EXP2Fog(entity){var _this;_this=_Fog.call(this,entity)||this;_this._density=0.0025;_this.density=_this._density;return _this;}/**
     * @internal
     * @override
     */var _proto=EXP2Fog.prototype;_proto._onEnable=function _onEnable(){this.scene.shaderData.enableMacro("O3_FOG_EXP2");}/**
     * @internal
     * @override
     */;_proto._onDisable=function _onDisable(){this.scene.shaderData.disableMacro("O3_FOG_EXP2");};_createClass$3(EXP2Fog,[{key:"density",get:/**
       * Density of fog.
       */function get(){return this._density;},set:function set(value){this._density=value;this.scene.shaderData.setFloat(EXP2Fog._densityProperty,value);}}]);return EXP2Fog;}(Fog);EXP2Fog._densityProperty=Shader.getPropertyByName("u_fogDensity");/**
   * Linear fog, according to the distance of the camera linear difference fog density.
   */var LinearFog=/*#__PURE__*/function(_Fog){_inheritsLoose$2(LinearFog,_Fog);function LinearFog(entity){var _this;_this=_Fog.call(this,entity)||this;_this._near=1;_this._far=1000;_this.near=_this._near;_this.far=_this._far;return _this;}_createClass$3(LinearFog,[{key:"near",get:/**
       * Start of fog.
       */function get(){return this._near;},set:function set(value){this._near=value;this.scene.shaderData.setFloat(LinearFog._nearProperty,value);}/**
       * End of fog.
       */},{key:"far",get:function get(){return this._far;},set:function set(value){this._far=value;this.scene.shaderData.setFloat(LinearFog._farProperty,value);}}]);return LinearFog;}(Fog);LinearFog._nearProperty=Shader.getPropertyByName("u_fogNear");LinearFog._farProperty=Shader.getPropertyByName("u_fogFar");/**
   * Environmental probes, providing necessary capabilities such as reflection and refraction.
   * @example
   * ```ts
   * const probe = cameraEntity.addComponent( CubeProbe )
   * probe.onTextureChange = cubeTexture => {
   *   envLight.specularTexture = cubeTexture;
   *   skybox.specularTexture = cubeTexture;
   * }
   * ```
   */var Probe=/*#__PURE__*/function(_Script){_inheritsLoose$2(Probe,_Script);function Probe(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Script.call.apply(_Script,[this].concat(args))||this;_this.probeLayer=exports.Layer.Everything;_this.width=1024;_this.height=1024;_this.antiAliasing=1;_this._isCube=false;_this._oriCameraRenderTarget=void 0;_this._renderTarget=void 0;_this._renderTargetSwap=void 0;_this._activeRenderTarget=void 0;_this._camera=void 0;_this._oriCameraCullingMask=void 0;return _this;}var _proto=Probe.prototype;/**
     * Provide hooks for users to exchange Texture.
     * @remarks Prevent issue: Feedback Loops Between Textures and the Framebuffer.
     */_proto.onTextureChange=function onTextureChange(renderColorTexture){}/**
     * @override
     */;_proto.onBeginRender=function onBeginRender(camera){if(!this.enabled)return;this._camera=camera;this._oriCameraCullingMask=camera.cullingMask;camera.cullingMask=this.probeLayer;if(!this._activeRenderTarget||this._activeRenderTarget.width!==this.width||this._activeRenderTarget.height!==this.height||this._activeRenderTarget.antiAliasing!==this.antiAliasing){this._renderTarget=new RenderTarget(this.engine,this.width,this.height,new RenderColorTexture(this.engine,this.width,this.height,undefined,undefined,this._isCube),exports.RenderBufferDepthFormat.Depth,this.antiAliasing);this._renderTargetSwap=new RenderTarget(this.engine,this.width,this.height,new RenderColorTexture(this.engine,this.width,this.height,undefined,undefined,this._isCube),exports.RenderBufferDepthFormat.Depth,this.antiAliasing);this._activeRenderTarget=this._renderTarget;}this._oriCameraRenderTarget=camera.renderTarget;camera.renderTarget=this._activeRenderTarget;}/**
     * @override
     */;_proto.onEndRender=function onEndRender(camera){if(!this.enabled)return;this.onTextureChange&&this.onTextureChange(this._texture);this._activeRenderTarget=this._activeRenderTarget===this._renderTarget?this._renderTargetSwap:this._renderTarget;};_proto._reset=function _reset(){if(!this.enabled)return;this._camera.renderTarget=this._oriCameraRenderTarget;this._camera.cullingMask=this._oriCameraCullingMask;};_createClass$3(Probe,[{key:"_texture",get:function get(){var _this$_activeRenderTa;return (_this$_activeRenderTa=this._activeRenderTarget)===null||_this$_activeRenderTa===void 0?void 0:_this$_activeRenderTa.getColorTexture();}}]);return Probe;}(Script);var cacheTarget=new Vector3();var cacheUp=new Vector3();var cacheDir=new Vector3();/**
   * Cube probe, generate cubeTexture, used for dynamic environment reflection and other effects.
   */var CubeProbe=/*#__PURE__*/function(_Probe){_inheritsLoose$2(CubeProbe,_Probe);function CubeProbe(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_Probe.call.apply(_Probe,[this].concat(args))||this;_this.position=new Vector3(0,0,0);_this._isCube=true;_this.oriViewMatrix=new Matrix();_this._oriFieldOfView=void 0;return _this;}var _proto=CubeProbe.prototype;/**
     * @override
     */_proto.onBeginRender=function onBeginRender(camera){if(!this.enabled)return;_Probe.prototype.onBeginRender.call(this,camera);this._storeCamera(camera);// Render 6 faces
  for(var faceIndex=0;faceIndex<6;faceIndex++){// Change camera parameters
  this._setCamera(faceIndex,camera);camera.render(exports.TextureCubeFace.PositiveX+faceIndex);}this._restoreCamera(camera);_Probe.prototype._reset.call(this);}/**
     * Store original camera parameters.
     */;_proto._storeCamera=function _storeCamera(camera){camera.viewMatrix.cloneTo(this.oriViewMatrix);this._oriFieldOfView=camera.fieldOfView;}/**
     * Restore camera parameters.
     */;_proto._restoreCamera=function _restoreCamera(camera){this.oriViewMatrix.cloneTo(camera.viewMatrix);camera.fieldOfView=this._oriFieldOfView;}/**
     * Set camera parameters according to the rendering surface.
     */;_proto._setCamera=function _setCamera(faceIndex,camera){switch(faceIndex){// positive_x
  case 0:cacheUp.setValue(0,-1,0);cacheDir.setValue(1,0,0);break;// negative_x
  case 1:cacheUp.setValue(0,-1,0);cacheDir.setValue(-1,0,0);break;// positive_y
  case 2:cacheUp.setValue(0,0,1);cacheDir.setValue(0,1,0);break;// negative_y
  case 3:cacheUp.setValue(0,0,-1);cacheDir.setValue(0,-1,0);break;// positive_z
  case 4:cacheUp.setValue(0,-1,0);cacheDir.setValue(0,0,1);break;// negative_z
  case 5:cacheUp.setValue(0,-1,0);cacheDir.setValue(0,0,-1);break;}Vector3.add(this.position,cacheDir,cacheTarget);Matrix.lookAt(this.position,cacheTarget,cacheUp,camera.viewMatrix);camera.fieldOfView=90;};return CubeProbe;}(Probe);/**
   * Shadow manager.
   */var LightShadow=/*#__PURE__*/function(){/**
     * @internal
     */LightShadow._updateShaderData=function _updateShaderData(shaderData){var data=LightShadow._combinedData;shaderData.setFloatArray(LightShadow._viewMatFromLightProperty,data.viewMatrix);shaderData.setFloatArray(LightShadow._projMatFromLightProperty,data.projectionMatrix);shaderData.setFloatArray(LightShadow._shadowBiasProperty,data.bias);shaderData.setFloatArray(LightShadow._shadowIntensityProperty,data.intensity);shaderData.setFloatArray(LightShadow._shadowRadiusProperty,data.radius);shaderData.setFloatArray(LightShadow._shadowMapSizeProperty,data.mapSize);shaderData.setTextureArray(LightShadow._shadowMapsProperty,data.map);}/**
     * Clear all shadow maps.
     */;LightShadow.clearMap=function clearMap(){LightShadow._combinedData.map.length=0;};function LightShadow(light,props){if(props===void 0){props={engine:null,width:512,height:512};}this._mapSize=void 0;this._renderTarget=void 0;this.light=void 0;this.bias=0.005;this.intensity=0.2;this.radius=1;this.projectionMatrix=new Matrix();this.light=light;var _props=props,engine=_props.engine,width=_props.width,height=_props.height;this._mapSize=new Vector2(width,height);this._renderTarget=new RenderTarget(engine,width,height,new RenderColorTexture(engine,width,height));}/**
     * The RenderTarget corresponding to the shadow map.
     */var _proto=LightShadow.prototype;/**
     * Initialize the projection matrix for lighting.
     * @param light - The light to generate shadow
     */_proto.initShadowProjectionMatrix=function initShadowProjectionMatrix(light){/**
       * Directional light projection matrix, the default coverage area is left: -5, right: 5, bottom: -5, up: 5, near: 0.5, far: 50.
       */if(light instanceof DirectLight){Matrix.ortho(-5,5,-5,5,0.1,50,this.projectionMatrix);}/**
       * Point light projection matrix, default configuration: fov: 50, aspect: 1, near: 0.5, far: 50.
       */if(light instanceof PointLight){Matrix.perspective(MathUtil.degreeToRadian(50),1,0.5,50,this.projectionMatrix);}/**
       * Spotlight projection matrix, the default configuration: fov: this.angle * 2 * Math.sqrt(2), aspect: 1, near: 0.1, far: this.distance + 5
       */if(light instanceof SpotLight){var fov=Math.min(Math.PI/2,light.angle*2*Math.sqrt(2));Matrix.perspective(fov,1,0.1,light.distance+5,this.projectionMatrix);}};_proto.appendData=function appendData(lightIndex){var viewStart=lightIndex*16;var projectionStart=lightIndex*16;var biasStart=lightIndex;var intensityStart=lightIndex;var radiusStart=lightIndex;var mapSizeStart=lightIndex*2;var mapStart=lightIndex;var data=LightShadow._combinedData;data.viewMatrix.set(this.light.viewMatrix.elements,viewStart);data.projectionMatrix.set(this.projectionMatrix.elements,projectionStart);data.bias[biasStart]=this.bias;data.intensity[intensityStart]=this.intensity;data.radius[radiusStart]=this.radius;data.mapSize[mapSizeStart]=this.mapSize.x;data.mapSize[mapSizeStart+1]=this.mapSize.y;data.map[mapStart]=this.map;};_createClass$3(LightShadow,[{key:"renderTarget",get:function get(){return this._renderTarget;}/**
       * Shadow map's color render texture.
       */},{key:"map",get:function get(){return this._renderTarget.getColorTexture();}/**
       * Shadow map size.
       */},{key:"mapSize",get:function get(){return this._mapSize;}}]);return LightShadow;}();LightShadow._viewMatFromLightProperty=Shader.getPropertyByName("u_viewMatFromLight");LightShadow._projMatFromLightProperty=Shader.getPropertyByName("u_projMatFromLight");LightShadow._shadowBiasProperty=Shader.getPropertyByName("u_shadowBias");LightShadow._shadowIntensityProperty=Shader.getPropertyByName("u_shadowIntensity");LightShadow._shadowRadiusProperty=Shader.getPropertyByName("u_shadowRadius");LightShadow._shadowMapSizeProperty=Shader.getPropertyByName("u_shadowMapSize");LightShadow._shadowMapsProperty=Shader.getPropertyByName("u_shadowMaps");LightShadow._maxLight=3;LightShadow._combinedData={viewMatrix:new Float32Array(16*LightShadow._maxLight),projectionMatrix:new Float32Array(16*LightShadow._maxLight),bias:new Float32Array(LightShadow._maxLight),intensity:new Float32Array(LightShadow._maxLight),radius:new Float32Array(LightShadow._maxLight),mapSize:new Float32Array(2*LightShadow._maxLight),map:[]};/**
   * Set whether the light to generate shadows.
   */Object.defineProperty(Light.prototype,"enableShadow",{get:function get(){return this._enableShadow;},set:function set(enabled){this._enableShadow=enabled;if(this._enableShadow){if(this instanceof AmbientLight){this._enableShadow=false;Logger.warn("Has no shadow!");return;}this.shadow=this.shadow||new LightShadow(this,{engine:this.engine,width:512,height:512});this.shadow.initShadowProjectionMatrix(this);}}});/**
   * Set whether the renderer to receive shadows.
   */Object.defineProperty(Component.prototype,"receiveShadow",{get:function get(){return this._recieveShadow;},set:function set(enabled){this._recieveShadow=enabled;}});/**
   * Set whether the renderer to cast shadows.
   */Object.defineProperty(Component.prototype,"castShadow",{get:function get(){return this._castShadow;},set:function set(enabled){this._castShadow=enabled;}});/**
   * Shadow Map material.
   */var ShadowMapMaterial=/*#__PURE__*/function(_Material){_inheritsLoose$2(ShadowMapMaterial,_Material);function ShadowMapMaterial(engine){var _this;_this=_Material.call(this,engine,Shader.find("shadow-map"))||this;_this.shaderData.enableMacro("O3_GENERATE_SHADOW_MAP");return _this;}return ShadowMapMaterial;}(Material);/**
   * RenderPass for rendering shadow map.
   */var ShadowMapPass=/*#__PURE__*/function(_RenderPass){_inheritsLoose$2(ShadowMapPass,_RenderPass);/**
     * Constructor.
     * @param light  - The light that the shadow belongs to
     */function ShadowMapPass(name,priority,renderTarget,replaceMaterial,mask,light){var _this;_this=_RenderPass.call(this,name,priority,renderTarget,replaceMaterial,mask)||this;_this.light=void 0;_this.light=light;_this.clearColor=new Color(1,1,1,1);return _this;}/**
     * @override
     */var _proto=ShadowMapPass.prototype;_proto.preRender=function preRender(camera,queue){// The viewProjection matrix from the light.
  var shaderData=this.replaceMaterial.shaderData;shaderData.setMatrix(ShadowMapPass._viewMatFromLightProperty,this.light.viewMatrix);shaderData.setMatrix(ShadowMapPass._projMatFromLightProperty,this.light.shadow.projectionMatrix);};return ShadowMapPass;}(RenderPass);ShadowMapPass._viewMatFromLightProperty=Shader.getPropertyByName("u_viewMatFromLight");ShadowMapPass._projMatFromLightProperty=Shader.getPropertyByName("u_projMatFromLight");/**
   * Shadow material.
   */var ShadowMaterial=/*#__PURE__*/function(_Material){_inheritsLoose$2(ShadowMaterial,_Material);function ShadowMaterial(engine){var _this;_this=_Material.call(this,engine,Shader.find("shadow"))||this;var targetBlendState=_this.renderState.blendState.targetBlendState;targetBlendState.enabled=true;targetBlendState.sourceColorBlendFactor=targetBlendState.sourceAlphaBlendFactor=exports.BlendFactor.DestinationColor;targetBlendState.destinationColorBlendFactor=targetBlendState.destinationAlphaBlendFactor=exports.BlendFactor.Zero;_this.renderState.depthState.compareFunction=exports.CompareFunction.LessEqual;_this.renderQueueType=exports.RenderQueueType.Transparent;return _this;}return ShadowMaterial;}(Material);/**
   * RenderPass for rendering shadow.
   */var ShadowPass=/*#__PURE__*/function(_RenderPass){_inheritsLoose$2(ShadowPass,_RenderPass);function ShadowPass(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_RenderPass.call.apply(_RenderPass,[this].concat(args))||this;_this.clearFlags=exports.CameraClearFlags.None;return _this;}/**
     * @override
     */var _proto=ShadowPass.prototype;_proto.preRender=function preRender(camera,queue){this.enabled=false;var lightMgr=camera.scene.findFeature(LightFeature);var lights=lightMgr.visibleLights;var shaderData=this.replaceMaterial.shaderData;// keep render based on default render pass
  var pass=camera._renderPipeline.defaultRenderPass;this.renderTarget=pass.renderTarget;var shadowMapCount=0;LightShadow.clearMap();for(var i=0,len=lights.length;i<len;i++){var lgt=lights[i];if(lgt.enableShadow){lgt.shadow.appendData(shadowMapCount++);}}if(shadowMapCount){this.enabled=true;LightShadow._updateShaderData(shaderData);shaderData.enableMacro("O3_SHADOW_MAP_COUNT",shadowMapCount.toString());}else {shaderData.disableMacro("O3_SHADOW_MAP_COUNT");}};return ShadowPass;}(RenderPass);/**
   * Shadow plug-in.
   */var ShadowFeature=/*#__PURE__*/function(_SceneFeature){_inheritsLoose$2(ShadowFeature,_SceneFeature);function ShadowFeature(){var _this;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_SceneFeature.call.apply(_SceneFeature,[this].concat(args))||this;_this._shadowPass=void 0;_this._shadowMapMaterial=void 0;return _this;}var _proto=ShadowFeature.prototype;/**
     * @override
     */_proto.preRender=function preRender(scene,camera){var lights=scene.findFeature(LightFeature).visibleLights;if(lights.length>0){// Check RenderPass for rendering shadows.
  if(!this._shadowPass){this.addShadowPass(camera);}// Check RenderPass for rendering shadow map.
  var renderPipeline=camera._renderPipeline;for(var i=0,len=lights.length;i<len;i++){var lgt=lights[i];if(lgt.enableShadow&&!lgt.shadowMapPass){lgt.shadowMapPass=this.addShadowMapPass(camera,lgt);}else if(!lgt.enableShadow&&lgt.shadowMapPass){renderPipeline.removeRenderPass(lgt.shadowMapPass);lgt.shadowMapPass=null;}}this.updatePassRenderFlag(renderPipeline._opaqueQueue);this.updatePassRenderFlag(renderPipeline._alphaTestQueue);this.updatePassRenderFlag(renderPipeline._transparentQueue);}}/**
     * Add RenderPass for rendering shadows.
     * @param camera - The camera for rendering
     */;_proto.addShadowPass=function addShadowPass(camera){var shadowMaterial=new ShadowMaterial(camera.engine);this._shadowPass=new ShadowPass("ShadowPass",1,null,shadowMaterial,exports.Layer.Layer30);// SHADOW
  var renderer=camera._renderPipeline;renderer.addRenderPass(this._shadowPass);}/**
     * Add RenderPass for rendering shadow map.
     * @param camera - The camera for rendering
     * @param light - The light that the shadow belongs to
     */;_proto.addShadowMapPass=function addShadowMapPass(camera,light){// Share shadow map material.
  this._shadowMapMaterial=this._shadowMapMaterial||new ShadowMapMaterial(camera.engine);var shadowMapPass=new ShadowMapPass("ShadowMapPass",-1,light.shadow.renderTarget,this._shadowMapMaterial,exports.Layer.Layer31,// SHADOW_MAP
  light);var renderer=camera._renderPipeline;renderer.addRenderPass(shadowMapPass);return shadowMapPass;}/**
     * Update the renderPassFlag state of renderers in the scene.
     * @param renderQueue - Render queue
     */;_proto.updatePassRenderFlag=function updatePassRenderFlag(renderQueue){var items=renderQueue.items;for(var i=0,len=items.length;i<len;i++){var item=items[i];var ability=item.component;var receiveShadow=ability.recieveShadow;var castShadow=ability.castShadow;if(receiveShadow===true){ability.entity.layer|=exports.Layer.Layer30;//SHADOW;
  }else if(receiveShadow===false){ability.entity.layer&=~exports.Layer.Layer30;//SHADOW;
  }if(castShadow===true){ability.entity.layer|=exports.Layer.Layer31;//SHADOW_MAP;
  }else if(castShadow===false){ability.entity.layer&=~exports.Layer.Layer31;//SHADOW_MAP;
  }}};return ShadowFeature;}(SceneFeature);Scene.registerFeature(ShadowFeature);Scene.registerFeature(LightFeature);Scene.prototype.hasLight=hasLight;

  /**
   * Smoothing plug-in.
   * */

  /**
   * @deprecated
   */

  exports.GLCompressedTextureInternalFormat = void 0;

  (function (GLCompressedTextureInternalFormat) {
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_4X4_KHR"] = 37808] = "RGBA_ASTC_4X4_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_5X4_KHR"] = 37809] = "RGBA_ASTC_5X4_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_5X5_KHR"] = 37810] = "RGBA_ASTC_5X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_6X5_KHR"] = 37811] = "RGBA_ASTC_6X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_6X6_KHR"] = 37812] = "RGBA_ASTC_6X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X5_KHR"] = 37813] = "RGBA_ASTC_8X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X6_KHR"] = 37814] = "RGBA_ASTC_8X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X8_KHR"] = 37815] = "RGBA_ASTC_8X8_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X5_KHR"] = 37816] = "RGBA_ASTC_10X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X6_KHR"] = 37817] = "RGBA_ASTC_10X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X8_KHR"] = 37818] = "RGBA_ASTC_10X8_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X10_KHR"] = 37819] = "RGBA_ASTC_10X10_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_12X10_KHR"] = 37820] = "RGBA_ASTC_12X10_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_12X12_KHR"] = 37821] = "RGBA_ASTC_12X12_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_4X4_KHR"] = 37840] = "SRGB8_ALPHA8_ASTC_4X4_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_5X4_KHR"] = 37841] = "SRGB8_ALPHA8_ASTC_5X4_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_5X5_KHR"] = 37842] = "SRGB8_ALPHA8_ASTC_5X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_6X5_KHR"] = 37843] = "SRGB8_ALPHA8_ASTC_6X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_6X6_KHR"] = 37844] = "SRGB8_ALPHA8_ASTC_6X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X5_KHR"] = 37845] = "SRGB8_ALPHA8_ASTC_8X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X6_KHR"] = 37846] = "SRGB8_ALPHA8_ASTC_8X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X8_KHR"] = 37847] = "SRGB8_ALPHA8_ASTC_8X8_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X5_KHR"] = 37848] = "SRGB8_ALPHA8_ASTC_10X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X6_KHR"] = 37849] = "SRGB8_ALPHA8_ASTC_10X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X8_KHR"] = 37850] = "SRGB8_ALPHA8_ASTC_10X8_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X10_KHR"] = 37851] = "SRGB8_ALPHA8_ASTC_10X10_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_12X10_KHR"] = 37852] = "SRGB8_ALPHA8_ASTC_12X10_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_12X12_KHR"] = 37853] = "SRGB8_ALPHA8_ASTC_12X12_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_ETC1_WEBGL"] = 36196] = "RGB_ETC1_WEBGL";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["R11_EAC"] = 37488] = "R11_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SIGNED_R11_EAC"] = 37489] = "SIGNED_R11_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RG11_EAC"] = 37490] = "RG11_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SIGNED_RG11_EAC"] = 37491] = "SIGNED_RG11_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB8_ETC2"] = 37492] = "RGB8_ETC2";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ETC2"] = 37493] = "SRGB8_ETC2";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA8_ETC2_EAC"] = 37496] = "RGBA8_ETC2_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "SRGB8_ALPHA8_ETC2_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_PVRTC_4BPPV1_IMG"] = 35840] = "RGB_PVRTC_4BPPV1_IMG";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_PVRTC_2BPPV1_IMG"] = 35841] = "RGB_PVRTC_2BPPV1_IMG";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "RGBA_PVRTC_4BPPV1_IMG";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "RGBA_PVRTC_2BPPV1_IMG";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_S3TC_DXT1_EXT"] = 33776] = "RGB_S3TC_DXT1_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT1_EXT"] = 33777] = "RGBA_S3TC_DXT1_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT3_EXT"] = 33778] = "RGBA_S3TC_DXT3_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT5_EXT"] = 33779] = "RGBA_S3TC_DXT5_EXT";
  })(exports.GLCompressedTextureInternalFormat || (exports.GLCompressedTextureInternalFormat = {}));

  function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2$1(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$1(Object(source), true).forEach(function (key) {
          _defineProperty$1(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$1(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperties$2(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$2(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$2(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inheritsLoose$1(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf$1(subClass, superClass);
  }

  function _setPrototypeOf$1(o, p) {
    _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$1(o, p);
  }
  /**
   * The canvas used on the web, which can support HTMLCanvasElement and OffscreenCanvas.
   */


  var WebCanvas = /*#__PURE__*/function () {
    var _proto = WebCanvas.prototype;
    /**
     * Resize the rendering size according to the clientWidth and clientHeight of the canvas.
     * @param pixelRatio - Pixel ratio
     */

    _proto.resizeByClientSize = function resizeByClientSize(pixelRatio) {
      if (pixelRatio === void 0) {
        pixelRatio = window.devicePixelRatio;
      }

      var webCanvas = this._webCanvas;

      if (webCanvas instanceof HTMLCanvasElement) {
        var width = webCanvas.clientWidth;
        var height = webCanvas.clientHeight;
        this.width = width * pixelRatio;
        this.height = height * pixelRatio;
      }
    }
    /**
     * Create a web canvas.
     * @param webCanvas - Web native canvas
     */
    ;

    function WebCanvas(webCanvas) {
      this._webCanvas = void 0;
      this._width = void 0;
      this._height = void 0;
      this._scale = new Vector2();
      var width = webCanvas.width;
      var height = webCanvas.height;
      this._webCanvas = webCanvas;
      this._width = width;
      this._height = height;
    }
    /**
     * Set scale.
     * @param x - Scale along the X axis
     * @param y - Scale along the Y axis
     */


    _proto.setScale = function setScale(x, y) {
      this._scale.setValue(x, y);

      this.scale = this._scale;
    };

    _createClass$2(WebCanvas, [{
      key: "width",
      get:
      /**
       * @inheritdoc
       */
      function get() {
        return this._width;
      },
      set: function set(value) {
        if (this._width !== value) {
          this._webCanvas.width = value;
          this._width = value;
        }
      }
      /**
       * @inheritdoc
       */

    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        if (this._height !== value) {
          this._webCanvas.height = value;
          this._height = value;
        }
      }
      /**
       * The scale of canvas, the value is visible width/height divide the render width/height.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */

    }, {
      key: "scale",
      get: function get() {
        var webCanvas = this._webCanvas;

        if (webCanvas instanceof HTMLCanvasElement) {
          this._scale.setValue(webCanvas.clientWidth * devicePixelRatio / webCanvas.width, webCanvas.clientHeight * devicePixelRatio / webCanvas.height);
        }

        return this._scale;
      },
      set: function set(value) {
        var webCanvas = this._webCanvas;

        if (webCanvas instanceof HTMLCanvasElement) {
          webCanvas.style.transformOrigin = "left top";
          webCanvas.style.transform = "scale(" + value.x + ", " + value.y + ")";
        }
      }
    }]);

    return WebCanvas;
  }();
  /**
   * GL capability.
   */


  var GLCapability = /*#__PURE__*/function () {
    function GLCapability(rhi) {
      this._maxDrawBuffers = void 0;
      this._maxAnisoLevel = void 0;
      this._maxAntiAliasing = void 0;
      this._rhi = void 0;
      this.capabilityList = void 0;
      this._rhi = rhi;
      this.capabilityList = new Map();

      this._init();

      this._compatibleAllInterface();
    }
    /**
     * Check device capabilities.
     */


    var _proto = GLCapability.prototype;

    _proto.canIUse = function canIUse(capabilityType) {
      return this.capabilityList.get(capabilityType);
    }
    /**
     * Check if can use some compressed texture format.
     */
    ;

    _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(internalType) {
      var RGBA_ASTC_4X4_KHR = exports.GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
          RGBA_ASTC_12X12_KHR = exports.GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
          SRGB8_ALPHA8_ASTC_4X4_KHR = exports.GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_4X4_KHR,
          SRGB8_ALPHA8_ASTC_12X12_KHR = exports.GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_12X12_KHR,
          RGB_ETC1_WEBGL = exports.GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
          R11_EAC = exports.GLCompressedTextureInternalFormat.R11_EAC,
          SRGB8_ALPHA8_ETC2_EAC = exports.GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ETC2_EAC,
          RGB_PVRTC_4BPPV1_IMG = exports.GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
          RGBA_PVRTC_2BPPV1_IMG = exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
          RGB_S3TC_DXT1_EXT = exports.GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
          RGBA_S3TC_DXT5_EXT = exports.GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT;

      if (internalType >= RGBA_ASTC_4X4_KHR && RGBA_ASTC_12X12_KHR <= RGBA_ASTC_12X12_KHR || internalType >= SRGB8_ALPHA8_ASTC_4X4_KHR && internalType <= SRGB8_ALPHA8_ASTC_12X12_KHR) {
        return this.canIUse(exports.GLCapabilityType.astc);
      } else if (internalType === RGB_ETC1_WEBGL) {
        return this.canIUse(exports.GLCapabilityType.etc1);
      } else if (internalType >= R11_EAC && internalType <= SRGB8_ALPHA8_ETC2_EAC) {
        return this.canIUse(exports.GLCapabilityType.etc);
      } else if (internalType >= RGB_PVRTC_4BPPV1_IMG && internalType <= RGBA_PVRTC_2BPPV1_IMG) {
        return this.canIUse(exports.GLCapabilityType.pvrtc);
      } else if (internalType >= RGB_S3TC_DXT1_EXT && internalType <= RGBA_S3TC_DXT5_EXT) {
        return this.canIUse(exports.GLCapabilityType.s3tc);
      }

      return false;
    }
    /**
     *  Init capabilities.
     */
    ;

    _proto._init = function _init() {
      var cap = this.capabilityList;
      var isWebGL2 = this.rhi.isWebGL2;
      var requireExtension = this.rhi.requireExtension.bind(this.rhi);
      var shaderVertexID = exports.GLCapabilityType.shaderVertexID,
          standardDerivatives = exports.GLCapabilityType.standardDerivatives,
          shaderTextureLod = exports.GLCapabilityType.shaderTextureLod,
          elementIndexUint = exports.GLCapabilityType.elementIndexUint,
          depthTexture = exports.GLCapabilityType.depthTexture,
          vertexArrayObject = exports.GLCapabilityType.vertexArrayObject,
          instancedArrays = exports.GLCapabilityType.instancedArrays,
          multipleSample = exports.GLCapabilityType.multipleSample,
          drawBuffers = exports.GLCapabilityType.drawBuffers,
          astc = exports.GLCapabilityType.astc,
          astc_webkit = exports.GLCapabilityType.astc_webkit,
          etc = exports.GLCapabilityType.etc,
          etc_webkit = exports.GLCapabilityType.etc_webkit,
          etc1 = exports.GLCapabilityType.etc1,
          etc1_webkit = exports.GLCapabilityType.etc1_webkit,
          pvrtc = exports.GLCapabilityType.pvrtc,
          pvrtc_webkit = exports.GLCapabilityType.pvrtc_webkit,
          s3tc = exports.GLCapabilityType.s3tc,
          s3tc_webkit = exports.GLCapabilityType.s3tc_webkit,
          textureFloat = exports.GLCapabilityType.textureFloat,
          textureHalfFloat = exports.GLCapabilityType.textureHalfFloat,
          textureFloatLinear = exports.GLCapabilityType.textureFloatLinear,
          textureHalfFloatLinear = exports.GLCapabilityType.textureHalfFloatLinear,
          WEBGL_colorBufferFloat = exports.GLCapabilityType.WEBGL_colorBufferFloat,
          colorBufferFloat = exports.GLCapabilityType.colorBufferFloat,
          colorBufferHalfFloat = exports.GLCapabilityType.colorBufferHalfFloat,
          textureFilterAnisotropic = exports.GLCapabilityType.textureFilterAnisotropic;
      cap.set(shaderVertexID, isWebGL2);
      cap.set(standardDerivatives, isWebGL2 || !!requireExtension(standardDerivatives));
      cap.set(shaderTextureLod, isWebGL2 || !!requireExtension(shaderTextureLod));
      cap.set(elementIndexUint, isWebGL2 || !!requireExtension(elementIndexUint));
      cap.set(depthTexture, isWebGL2 || !!requireExtension(depthTexture));
      cap.set(vertexArrayObject, isWebGL2 || !!requireExtension(vertexArrayObject));
      cap.set(instancedArrays, isWebGL2 || !!requireExtension(instancedArrays));
      cap.set(multipleSample, isWebGL2);
      cap.set(drawBuffers, isWebGL2 || !!requireExtension(drawBuffers));
      cap.set(textureFloat, isWebGL2 || !!requireExtension(textureFloat));
      cap.set(textureHalfFloat, isWebGL2 || !!requireExtension(textureHalfFloat));
      cap.set(textureFloatLinear, !!requireExtension(textureFloatLinear));
      cap.set(textureHalfFloatLinear, isWebGL2 || !!requireExtension(textureHalfFloatLinear));
      cap.set(colorBufferFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(WEBGL_colorBufferFloat));
      cap.set(colorBufferHalfFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(colorBufferHalfFloat));
      cap.set(textureFilterAnisotropic, !!requireExtension(textureFilterAnisotropic));
      cap.set(astc, !!(requireExtension(astc) || requireExtension(astc_webkit)));
      cap.set(etc, !!(requireExtension(etc) || requireExtension(etc_webkit)));
      cap.set(etc1, !!(requireExtension(etc1) || requireExtension(etc1_webkit)));
      cap.set(pvrtc, !!(requireExtension(pvrtc) || requireExtension(pvrtc_webkit)));
      cap.set(s3tc, !!(requireExtension(s3tc) || requireExtension(s3tc_webkit)));
    }
    /**
     * If there are extensions that can supplement this ability, smooth out the difference.
     * @example
     * compatible(GLCapabilityType.depthTexture,{
     *    UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
     * })
     * gl.UNSIGNED_INT_24_8 = ext.UNSIGNED_INT_24_8_WEBGL
     */
    ;

    _proto._compatibleInterface = function _compatibleInterface(capabilityType, flatItem) {
      var rhi = this.rhi;
      var gl = rhi.gl;
      var ext = null;

      if (ext = rhi.requireExtension(capabilityType)) {
        for (var _glKey in flatItem) {
          var _extensionKey = flatItem[_glKey];
          var extensionVal = ext[_extensionKey]; // Mini game hack the native function,use “.bind” to smooth out if is “Funcion”.

          if (extensionVal !== null && extensionVal !== void 0 && extensionVal.bind) {
            gl[_glKey] = extensionVal.bind(ext);
          } else {
            gl[_glKey] = extensionVal;
          }
        }
      }
    };

    _proto._compatibleAllInterface = function _compatibleAllInterface() {
      var depthTexture = exports.GLCapabilityType.depthTexture,
          vertexArrayObject = exports.GLCapabilityType.vertexArrayObject,
          instancedArrays = exports.GLCapabilityType.instancedArrays,
          drawBuffers = exports.GLCapabilityType.drawBuffers,
          textureFilterAnisotropic = exports.GLCapabilityType.textureFilterAnisotropic,
          textureHalfFloat = exports.GLCapabilityType.textureHalfFloat,
          colorBufferHalfFloat = exports.GLCapabilityType.colorBufferHalfFloat,
          WEBGL_colorBufferFloat = exports.GLCapabilityType.WEBGL_colorBufferFloat;
      var isWebGL2 = this.rhi.isWebGL2;

      if (!isWebGL2) {
        this._compatibleInterface(depthTexture, {
          UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
        });

        this._compatibleInterface(vertexArrayObject, {
          createVertexArray: "createVertexArrayOES",
          deleteVertexArray: "deleteVertexArrayOES",
          isVertexArray: "isVertexArrayOES",
          bindVertexArray: "bindVertexArrayOES"
        });

        this._compatibleInterface(instancedArrays, {
          drawArraysInstanced: "drawArraysInstancedANGLE",
          drawElementsInstanced: "drawElementsInstancedANGLE",
          vertexAttribDivisor: "vertexAttribDivisorANGLE"
        });

        this._compatibleInterface(drawBuffers, {
          MAX_DRAW_BUFFERS: "MAX_DRAW_BUFFERS_WEBGL"
        });

        var items = {};

        if (this.canIUse(exports.GLCapabilityType.drawBuffers)) {
          var maxDrawBuffers = this.maxDrawBuffers;

          for (var i = 0; i < maxDrawBuffers; i++) {
            i != 0 && (items["COLOR_ATTACHMENT" + i] = "COLOR_ATTACHMENT" + i + "_WEBGL");
            items["DRAW_BUFFER" + i] = "DRAW_BUFFER" + i + "_WEBGL";
          }

          this._compatibleInterface(drawBuffers, _objectSpread2$1({
            drawBuffers: "drawBuffersWEBGL"
          }, items));
        }

        this._compatibleInterface(textureHalfFloat, {
          HAFL_FLOAT: "HALF_FLOAT_OES"
        });

        this._compatibleInterface(colorBufferHalfFloat, {
          RGBA16F: "RBGA16F_EXT"
        });

        this._compatibleInterface(WEBGL_colorBufferFloat, {
          RGBA32F: "RBGA32F_EXT"
        });
      }

      this._compatibleInterface(textureFilterAnisotropic, {
        TEXTURE_MAX_ANISOTROPY_EXT: "TEXTURE_MAX_ANISOTROPY_EXT"
      });
    };

    _createClass$2(GLCapability, [{
      key: "canUseFloatTextureBlendShape",
      get: function get() {
        return this.canIUse(exports.GLCapabilityType.shaderVertexID) && this.canIUse(exports.GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
      }
      /**
       * Whether can use more joints.
       */

    }, {
      key: "canIUseMoreJoints",
      get: function get() {
        return this.canIUse(exports.GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
      }
    }, {
      key: "maxDrawBuffers",
      get: function get() {
        if (!this._maxDrawBuffers) {
          if (this.canIUse(exports.GLCapabilityType.drawBuffers)) {
            this._maxDrawBuffers = this._rhi.gl.getParameter(this._rhi.gl.MAX_DRAW_BUFFERS);
          } else {
            this._maxDrawBuffers = 1;
          }
        }

        return this._maxDrawBuffers;
      }
      /**
       * Max anisoLevel.
       */

    }, {
      key: "maxAnisoLevel",
      get: function get() {
        if (!this._maxAnisoLevel) {
          var ext = this._rhi.requireExtension(exports.GLCapabilityType.textureFilterAnisotropic);

          this._maxAnisoLevel = ext ? this._rhi.gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
        }

        return this._maxAnisoLevel;
      }
      /**
       * Max MSAA count.
       */

    }, {
      key: "maxAntiAliasing",
      get: function get() {
        if (!this._maxAntiAliasing) {
          var gl = this._rhi.gl;
          var canMSAA = this.canIUse(exports.GLCapabilityType.multipleSample);
          this._maxAntiAliasing = canMSAA ? gl.getParameter(gl.MAX_SAMPLES) : 1;
        }

        return this._maxAntiAliasing;
      }
    }, {
      key: "rhi",
      get: function get() {
        return this._rhi;
      }
    }]);

    return GLCapability;
  }();
  /**
   * GLContext extension.
   */


  var GLExtensions = /*#__PURE__*/function () {
    function GLExtensions(rhi) {
      this.rhi = void 0;
      this._requireResult = void 0;
      this.rhi = rhi;
      this._requireResult = {};
    }
    /**
     * Require an extension.
     */


    var _proto = GLExtensions.prototype;

    _proto.requireExtension = function requireExtension(ext) {
      if (this._requireResult[ext] !== undefined) {
        return this._requireResult[ext];
      }

      this._requireResult[ext] = this.rhi.gl.getExtension(ext);
      return this._requireResult[ext];
    };

    return GLExtensions;
  }();
  /**
   * Improvement of VAO:
   * 1) WebGL2.0 must support VAO, almost all devices support vao extensions in webgl1.0, we can use PollyFill,only keep VAO mode.
   * 2) VAO implementation now has bugs, change IndexBuffer、VertexBuffer、VertexElements need to update VAO.
   */

  /**
   * @internal
   * GL platform primitive.
   */


  var GLPrimitive = /*#__PURE__*/function () {
    function GLPrimitive(rhi, primitive) {
      this.attribLocArray = void 0;
      this._primitive = void 0;
      this.canUseInstancedArrays = void 0;
      this.gl = void 0;
      this.vao = new Map();
      this._useVao = void 0;
      this._primitive = primitive;
      this.canUseInstancedArrays = rhi.canIUse(exports.GLCapabilityType.instancedArrays);
      this._useVao = rhi.canIUse(exports.GLCapabilityType.vertexArrayObject);
      this.gl = rhi.gl;
    }
    /**
     * Draw the primitive.
     */


    var _proto = GLPrimitive.prototype;

    _proto.draw = function draw(shaderProgram, subMesh) {
      var gl = this.gl;
      var primitive = this._primitive;

      if (this._useVao) {
        if (!this.vao.has(shaderProgram.id)) {
          this.registerVAO(shaderProgram);
        }

        var vao = this.vao.get(shaderProgram.id);
        gl.bindVertexArray(vao);
      } else {
        this.bindBufferAndAttrib(shaderProgram);
      } // @ts-ignore


      var _indexBufferBinding = primitive._indexBufferBinding,
          _instanceCount = primitive._instanceCount,
          _glIndexType = primitive._glIndexType,
          _glIndexByteCount = primitive._glIndexByteCount;
      var topology = subMesh.topology,
          start = subMesh.start,
          count = subMesh.count;

      if (!_instanceCount) {
        if (_indexBufferBinding) {
          if (this._useVao) {
            gl.drawElements(topology, count, _glIndexType, start * _glIndexByteCount);
          } else {
            var _nativeBuffer = _indexBufferBinding.buffer._nativeBuffer;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer);
            gl.drawElements(topology, count, _glIndexType, start * _glIndexByteCount);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }
        } else {
          gl.drawArrays(topology, start, count);
        }
      } else {
        if (this.canUseInstancedArrays) {
          if (_indexBufferBinding) {
            if (this._useVao) {
              gl.drawElementsInstanced(topology, count, _glIndexType, start * _glIndexByteCount, _instanceCount);
            } else {
              var _nativeBuffer2 = _indexBufferBinding.buffer._nativeBuffer;
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer2);
              gl.drawElementsInstanced(topology, count, _glIndexType, start * _glIndexByteCount, _instanceCount);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            }
          } else {
            gl.drawArraysInstanced(topology, start, count, _instanceCount);
          }
        } else {
          Logger.error("ANGLE_instanced_arrays extension is not supported");
        }
      } // unbind


      if (this._useVao) {
        gl.bindVertexArray(null);
      } else {
        this.disableAttrib();
      }
    };

    _proto.destroy = function destroy() {
      if (this._useVao) {
        var gl = this.gl;
        this.vao.forEach(function (vao) {
          gl.deleteVertexArray(vao);
        });
        this.vao.clear();
      }
    }
    /**
     * Bind buffer and attribute.
     */
    ;

    _proto.bindBufferAndAttrib = function bindBufferAndAttrib(shaderProgram) {
      var gl = this.gl;
      var primitive = this._primitive; // @ts-ignore

      var vertexBufferBindings = primitive._vertexBufferBindings;
      this.attribLocArray = [];
      var attributeLocation = shaderProgram.attributeLocation;
      var attributes = primitive._vertexElementMap;
      var vbo;
      var lastBoundVbo;

      for (var name in attributeLocation) {
        var loc = attributeLocation[name];
        if (loc === -1) continue;
        var element = attributes[name];

        if (element) {
          var _vertexBufferBindings = vertexBufferBindings[element.bindingIndex],
              buffer = _vertexBufferBindings.buffer,
              stride = _vertexBufferBindings.stride;
          vbo = buffer._nativeBuffer; // prevent binding the vbo which already bound at the last loop, e.g. a buffer with multiple attributes.

          if (lastBoundVbo !== vbo) {
            lastBoundVbo = vbo;
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
          }

          gl.enableVertexAttribArray(loc);
          var _element$_glElementIn = element._glElementInfo,
              size = _element$_glElementIn.size,
              type = _element$_glElementIn.type,
              normalized = _element$_glElementIn.normalized;
          gl.vertexAttribPointer(loc, size, type, normalized, stride, element.offset);

          if (this.canUseInstancedArrays) {
            gl.vertexAttribDivisor(loc, element.instanceStepRate);
          }

          this.attribLocArray.push(loc);
        } else {
          Logger.warn("vertex attribute not found: " + name);
        }
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    };

    _proto.disableAttrib = function disableAttrib() {
      var gl = this.gl;

      for (var i = 0, l = this.attribLocArray.length; i < l; i++) {
        gl.disableVertexAttribArray(this.attribLocArray[i]);
      }
    };

    _proto.registerVAO = function registerVAO(shaderProgram) {
      var gl = this.gl;
      var vao = gl.createVertexArray();
      /** register VAO */

      gl.bindVertexArray(vao); // @ts-ignore

      var _indexBufferBinding = this._primitive._indexBufferBinding;

      if (_indexBufferBinding) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _indexBufferBinding.buffer._nativeBuffer);
      }

      this.bindBufferAndAttrib(shaderProgram);
      /** unbind */

      gl.bindVertexArray(null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      this.disableAttrib();
      this.vao.set(shaderProgram.id, vao);
    };

    return GLPrimitive;
  }();
  /**
   * Texture in WebGL platform.
   */


  var GLTexture = /*#__PURE__*/function () {
    /** @internal */

    /** @internal */
    GLTexture._isPowerOf2 = function _isPowerOf2(v) {
      return (v & v - 1) === 0;
    }
    /**
     * Get more texture info from TextureFormat.
     * @internal
     */
    ;

    GLTexture._getFormatDetail = function _getFormatDetail(format, gl, isWebGL2) {
      switch (format) {
        case exports.TextureFormat.R8G8B8:
          return {
            internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
            baseFormat: gl.RGB,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };

        case exports.TextureFormat.R8G8B8A8:
          return {
            internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
            baseFormat: gl.RGBA,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };

        case exports.TextureFormat.R4G4B4A4:
          return {
            internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
            baseFormat: gl.RGBA,
            dataType: gl.UNSIGNED_SHORT_4_4_4_4,
            isCompressed: false
          };

        case exports.TextureFormat.R5G5B5A1:
          return {
            internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
            baseFormat: gl.RGBA,
            dataType: gl.UNSIGNED_SHORT_5_5_5_1,
            isCompressed: false
          };

        case exports.TextureFormat.R5G6B5:
          return {
            internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
            baseFormat: gl.RGB,
            dataType: gl.UNSIGNED_SHORT_5_6_5,
            isCompressed: false
          };

        case exports.TextureFormat.Alpha8:
          return {
            internalFormat: gl.ALPHA,
            baseFormat: gl.ALPHA,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };

        case exports.TextureFormat.LuminanceAlpha:
          return {
            internalFormat: gl.LUMINANCE_ALPHA,
            baseFormat: gl.LUMINANCE_ALPHA,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };

        case exports.TextureFormat.R32G32B32A32:
          return {
            internalFormat: gl.RGBA32F,
            baseFormat: gl.RGBA,
            dataType: gl.FLOAT,
            isCompressed: false
          };

        case exports.TextureFormat.DXT1:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
            isCompressed: true
          };

        case exports.TextureFormat.DXT5:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT,
            isCompressed: true
          };

        case exports.TextureFormat.ETC1_RGB:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
            isCompressed: true
          };

        case exports.TextureFormat.ETC2_RGB:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB8_ETC2,
            isCompressed: true
          };

        case exports.TextureFormat.ETC2_RGBA5:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
            isCompressed: true
          };

        case exports.TextureFormat.ETC2_RGBA8:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC,
            isCompressed: true
          };

        case exports.TextureFormat.PVRTC_RGB2:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG,
            isCompressed: true
          };

        case exports.TextureFormat.PVRTC_RGBA2:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
            isCompressed: true
          };

        case exports.TextureFormat.PVRTC_RGB4:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
            isCompressed: true
          };

        case exports.TextureFormat.PVRTC_RGBA4:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG,
            isCompressed: true
          };

        case exports.TextureFormat.ASTC_4x4:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
            isCompressed: true
          };

        case exports.TextureFormat.ASTC_5x5:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR,
            isCompressed: true
          };

        case exports.TextureFormat.ASTC_6x6:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR,
            isCompressed: true
          };

        case exports.TextureFormat.ASTC_8x8:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR,
            isCompressed: true
          };

        case exports.TextureFormat.ASTC_10x10:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR,
            isCompressed: true
          };

        case exports.TextureFormat.ASTC_12x12:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
            isCompressed: true
          };

        default:
          throw new Error("this TextureFormat is not supported in Oasis Engine: " + format);
      }
    }
    /**
     * @internal
     */
    ;

    GLTexture._getRenderBufferColorFormatDetail = function _getRenderBufferColorFormatDetail(format, gl, isWebGL2) {
      switch (format) {
        case exports.RenderBufferColorFormat.R8G8B8:
          return {
            internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
            baseFormat: gl.RGB,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };

        case exports.RenderBufferColorFormat.R8G8B8A8:
          return {
            internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
            baseFormat: gl.RGBA,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };

        case exports.RenderBufferColorFormat.R4G4B4A4:
          return {
            internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
            baseFormat: gl.RGBA,
            dataType: gl.UNSIGNED_SHORT_4_4_4_4,
            isCompressed: false
          };

        case exports.RenderBufferColorFormat.R5G5B5A1:
          return {
            internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
            baseFormat: gl.RGBA,
            dataType: gl.UNSIGNED_SHORT_5_5_5_1,
            isCompressed: false
          };

        case exports.RenderBufferColorFormat.R5G6B5:
          return {
            internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
            baseFormat: gl.RGB,
            dataType: gl.UNSIGNED_SHORT_5_6_5,
            isCompressed: false
          };

        case exports.RenderBufferColorFormat.Alpha8:
          return {
            internalFormat: gl.ALPHA,
            baseFormat: gl.ALPHA,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };

        case exports.RenderBufferColorFormat.R16G16B16A16:
          return {
            internalFormat: gl.RGBA16F,
            baseFormat: gl.RGBA,
            dataType: gl.HALF_FLOAT,
            isCompressed: false
          };

        case exports.RenderBufferColorFormat.R32G32B32A32:
          return {
            internalFormat: gl.RGBA32F,
            baseFormat: gl.RGBA,
            dataType: gl.FLOAT,
            isCompressed: false
          };

        default:
          throw new Error("this RenderBufferColorFormat is not supported in Oasis Engine: " + format);
      }
    }
    /**
     * In WebGL 1, internalformat must be the same as baseFormat when call texImage2D.
     * @internal
     */
    ;

    GLTexture._getRenderBufferDepthFormatDetail = function _getRenderBufferDepthFormatDetail(format, gl, isWebGL2) {
      switch (format) {
        case exports.RenderBufferDepthFormat.Depth:
          return {
            internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16,
            baseFormat: gl.DEPTH_COMPONENT,
            dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_INT,
            isCompressed: false,
            attachment: gl.DEPTH_ATTACHMENT
          };

        case exports.RenderBufferDepthFormat.DepthStencil:
          return {
            internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
            baseFormat: gl.DEPTH_STENCIL,
            dataType: gl.UNSIGNED_INT_24_8,
            isCompressed: false,
            attachment: gl.DEPTH_STENCIL_ATTACHMENT
          };

        case exports.RenderBufferDepthFormat.Stencil:
          return {
            internalFormat: gl.STENCIL_INDEX8,
            baseFormat: gl.STENCIL_ATTACHMENT,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false,
            attachment: gl.STENCIL_ATTACHMENT
          };

        case exports.RenderBufferDepthFormat.Depth16:
          return {
            internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT16,
            baseFormat: gl.DEPTH_COMPONENT,
            dataType: gl.UNSIGNED_INT,
            isCompressed: false,
            attachment: gl.DEPTH_ATTACHMENT
          };

        case exports.RenderBufferDepthFormat.Depth24:
          return {
            internalFormat: gl.DEPTH_COMPONENT24,
            baseFormat: gl.DEPTH_COMPONENT,
            dataType: gl.UNSIGNED_INT,
            isCompressed: false,
            attachment: gl.DEPTH_ATTACHMENT
          };

        case exports.RenderBufferDepthFormat.Depth32:
          return {
            internalFormat: gl.DEPTH_COMPONENT32F,
            baseFormat: gl.DEPTH_COMPONENT,
            dataType: gl.FLOAT,
            isCompressed: false,
            attachment: gl.DEPTH_ATTACHMENT
          };

        case exports.RenderBufferDepthFormat.Depth24Stencil8:
          return {
            internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
            baseFormat: gl.DEPTH_STENCIL,
            dataType: gl.UNSIGNED_INT_24_8,
            isCompressed: false,
            attachment: gl.DEPTH_STENCIL_ATTACHMENT
          };

        case exports.RenderBufferDepthFormat.Depth32Stencil8:
          return {
            internalFormat: gl.DEPTH32F_STENCIL8,
            baseFormat: gl.DEPTH_STENCIL,
            dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,
            isCompressed: false,
            attachment: gl.DEPTH_STENCIL_ATTACHMENT
          };

        default:
          throw new Error("this RenderBufferDepthFormat is not supported in Oasis Engine: " + format);
      }
    }
    /**
     * Check whether the corresponding texture format is supported.
     * @internal
     */
    ;

    GLTexture._supportTextureFormat = function _supportTextureFormat(format, rhi) {
      var isSupported = true;

      switch (format) {
        case exports.TextureFormat.R32G32B32A32:
          {
            if (!rhi.canIUse(exports.GLCapabilityType.textureFloat)) {
              isSupported = false;
            }
          }
          break;
      }

      return isSupported;
    }
    /**
     * @internal
     */
    ;

    GLTexture._supportRenderBufferColorFormat = function _supportRenderBufferColorFormat(format, rhi) {
      var isSupported = true;

      switch (format) {
        case exports.RenderBufferColorFormat.R32G32B32A32:
          {
            if (!rhi.canIUse(exports.GLCapabilityType.colorBufferFloat) || !rhi.canIUse(exports.GLCapabilityType.textureFloat)) {
              isSupported = false;
            }
          }
          break;

        case exports.RenderBufferColorFormat.R16G16B16A16:
          {
            if (!rhi.canIUse(exports.GLCapabilityType.colorBufferHalfFloat) || !rhi.canIUse(exports.GLCapabilityType.textureHalfFloat)) {
              isSupported = false;
            }
          }
          break;
      }

      return isSupported;
    }
    /**
     * @internal
     */
    ;

    GLTexture._supportRenderBufferDepthFormat = function _supportRenderBufferDepthFormat(format, rhi, isTexture) {
      var isWebGL2 = rhi.isWebGL2;
      var isSupported = true;

      if (isTexture && !rhi.canIUse(exports.GLCapabilityType.depthTexture)) {
        return false;
      }

      switch (format) {
        case exports.RenderBufferDepthFormat.Stencil:
          {
            isSupported = false;
          }
          break;

        case exports.RenderBufferDepthFormat.Depth24:
        case exports.RenderBufferDepthFormat.Depth32:
        case exports.RenderBufferDepthFormat.Depth32Stencil8:
          {
            if (!isWebGL2) {
              isSupported = false;
            }
          }
          break;
      }

      return isSupported;
    }
    /** @internal */
    ;
    /**
     * Create texture in WebGL platform.
     */


    function GLTexture(rhi, texture, target) {
      this._texture = void 0;
      this._glTexture = void 0;
      this._rhi = void 0;
      this._gl = void 0;
      this._isWebGL2 = void 0;
      this._target = void 0;
      this._formatDetail = void 0;
      this._texture = texture;
      this._rhi = rhi;
      this._gl = rhi.gl;
      this._isWebGL2 = rhi.isWebGL2;
      this._target = target;
      this._glTexture = this._gl.createTexture();
    }
    /**
     * Destroy texture.
     */


    var _proto = GLTexture.prototype;

    _proto.destroy = function destroy() {
      this._gl.deleteTexture(this._glTexture);

      this._texture = null;
      this._glTexture = null;
      this._formatDetail = null;
    }
    /**
     * Generate multi-level textures based on the 0th level data.
     */
    ;

    _proto.generateMipmaps = function generateMipmaps() {
      this._bind();

      this._gl.generateMipmap(this._target);
    };

    _proto._bind = function _bind() {
      this._rhi.bindTexture(this);
    }
    /**
     * Pre-development mipmapping GPU memory.
     */
    ;

    _proto._initMipmap = function _initMipmap(isCube) {
      var gl = this._gl;
      var isWebGL2 = this._isWebGL2;
      var _this$_formatDetail = this._formatDetail,
          internalFormat = _this$_formatDetail.internalFormat,
          baseFormat = _this$_formatDetail.baseFormat,
          dataType = _this$_formatDetail.dataType;
      var _this$_texture = this._texture,
          mipmapCount = _this$_texture.mipmapCount,
          width = _this$_texture.width,
          height = _this$_texture.height;

      this._bind();

      if (isWebGL2 && !(baseFormat === gl.LUMINANCE_ALPHA || baseFormat === gl.ALPHA)) {
        gl.texStorage2D(this._target, mipmapCount, internalFormat, width, height);
      } else {
        // In WebGL 1, internalformat must be the same as baseFormat
        if (baseFormat !== internalFormat) {
          internalFormat = baseFormat;
        }

        if (!isCube) {
          for (var i = 0; i < mipmapCount; i++) {
            var mipWidth = Math.max(1, width >> i);
            var mipHeight = Math.max(1, height >> i);
            gl.texImage2D(this._target, i, internalFormat, mipWidth, mipHeight, 0, baseFormat, dataType, null);
          }
        } else {
          for (var _i = 0; _i < mipmapCount; _i++) {
            var size = Math.max(1, width >> _i);

            for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
              gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, _i, internalFormat, size, size, 0, baseFormat, dataType, null);
            }
          }
        }
      }
    }
    /**
     * Get the pixel color buffer according to the specified cube face and area.
     * @param face - You can choose which cube face to read
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     * @param width - Area width
     * @param height - Area height
     * @param out - Color buffer
     */
    ;

    _proto._getPixelBuffer = function _getPixelBuffer(face, x, y, width, height, out) {
      var gl = this._gl;
      var _this$_formatDetail2 = this._formatDetail,
          baseFormat = _this$_formatDetail2.baseFormat,
          dataType = _this$_formatDetail2.dataType;

      if (!GLTexture._readFrameBuffer) {
        GLTexture._readFrameBuffer = gl.createFramebuffer();
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, GLTexture._readFrameBuffer);

      if (face != null) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, this._glTexture, 0);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._glTexture, 0);
      }

      gl.readPixels(x, y, width, height, baseFormat, dataType, out);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    };

    _proto._setWrapMode = function _setWrapMode(value, pname) {
      var gl = this._gl;
      var isWebGL2 = this._isWebGL2;
      var target = this._target;
      var _this$_texture2 = this._texture,
          width = _this$_texture2.width,
          height = _this$_texture2.height;

      if (!isWebGL2 && value !== exports.TextureWrapMode.Clamp && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
        Logger.warn("non-power-2 texture is not supported for REPEAT or MIRRORED_REPEAT in WebGL1,and has automatically downgraded to CLAMP_TO_EDGE");
        value = exports.TextureWrapMode.Clamp;
      }

      switch (value) {
        case exports.TextureWrapMode.Clamp:
          gl.texParameteri(target, pname, gl.CLAMP_TO_EDGE);
          break;

        case exports.TextureWrapMode.Repeat:
          gl.texParameteri(target, pname, gl.REPEAT);
          break;

        case exports.TextureWrapMode.Mirror:
          gl.texParameteri(target, pname, gl.MIRRORED_REPEAT);
          break;
      }
    };

    _createClass$2(GLTexture, [{
      key: "wrapModeU",
      set:
      /**
       * Wrapping mode for texture coordinate S.
       */
      function set(value) {
        this._bind();

        this._setWrapMode(value, this._gl.TEXTURE_WRAP_S);
      }
      /**
       * Wrapping mode for texture coordinate T.
       */

    }, {
      key: "wrapModeV",
      set: function set(value) {
        this._bind();

        this._setWrapMode(value, this._gl.TEXTURE_WRAP_T);
      }
      /**
       * Filter mode for texture.
       */

    }, {
      key: "filterMode",
      set: function set(value) {
        var gl = this._gl;
        var target = this._target;
        /** @ts-ignore */

        var _mipmap = this._texture._mipmap;

        this._bind();

        switch (value) {
          case exports.TextureFilterMode.Point:
            gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST);
            break;

          case exports.TextureFilterMode.Bilinear:
            gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR);
            break;

          case exports.TextureFilterMode.Trilinear:
            gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
            break;
        }
      }
      /**
       * Anisotropic level for texture.
       */

    }, {
      key: "anisoLevel",
      set: function set(value) {
        var gl = this._gl;

        this._bind();

        gl.texParameterf(this._target, gl.TEXTURE_MAX_ANISOTROPY_EXT, value);
      }
    }]);

    return GLTexture;
  }();

  GLTexture._readFrameBuffer = null;
  /**
   * The texture in WebGL platform is used for the output of color information in off-screen rendering.
   */

  var GLRenderColorTexture = /*#__PURE__*/function (_GLTexture) {
    _inheritsLoose$1(GLRenderColorTexture, _GLTexture);
    /**
     * Create render color texture in WebGL platform.
     */


    function GLRenderColorTexture(rhi, texture) {
      var _this;

      _this = _GLTexture.call(this, rhi, texture, texture.isCube ? rhi.gl.TEXTURE_CUBE_MAP : rhi.gl.TEXTURE_2D) || this;
      /** @ts-ignore */

      var format = texture.format,
          _mipmap = texture._mipmap,
          width = texture.width,
          height = texture.height,
          isCube = texture.isCube;
      var isWebGL2 = _this._isWebGL2;

      if (!GLTexture._supportRenderBufferColorFormat(format, rhi)) {
        throw new Error("RenderBufferColorFormat is not supported:" + exports.RenderBufferColorFormat[format]);
      }

      if (isCube && width !== height) {
        throw new Error("The cube texture must have the same width and height");
      }

      if (_mipmap && !isWebGL2 && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
        Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
        /** @ts-ignore */

        texture._mipmap = false;
        /** @ts-ignore */

        texture._mipmapCount = texture._getMipmapCount();
      }

      _this._formatDetail = GLTexture._getRenderBufferColorFormatDetail(format, _this._gl, isWebGL2);

      _this._initMipmap(isCube);

      return _this;
    }
    /**
     * Get the pixel color buffer according to the specified cube face and area.
     * @param face - You can choose which cube face to read if it's cube texture
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     * @param width - Area width
     * @param height - Area height
     * @param out - Color buffer
     */


    var _proto = GLRenderColorTexture.prototype;

    _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, out) {
      _GLTexture.prototype._getPixelBuffer.call(this, face, x, y, width, height, out);
    };

    return GLRenderColorTexture;
  }(GLTexture);
  /**
   * The texture in WebGL platform is used for the output of depth information in off-screen rendering.
   */


  var GLRenderDepthTexture = /*#__PURE__*/function (_GLTexture) {
    _inheritsLoose$1(GLRenderDepthTexture, _GLTexture);
    /**
     * Create render depth texture in WebGL platform.
     */


    function GLRenderDepthTexture(rhi, texture) {
      var _this;

      _this = _GLTexture.call(this, rhi, texture, texture.isCube ? rhi.gl.TEXTURE_CUBE_MAP : rhi.gl.TEXTURE_2D) || this;
      /** @ts-ignore */

      var format = texture.format,
          _mipmap = texture._mipmap,
          width = texture.width,
          height = texture.height,
          isCube = texture.isCube;
      var isWebGL2 = _this._isWebGL2;

      if (!GLTexture._supportRenderBufferDepthFormat(format, rhi, true)) {
        throw new Error("RenderBufferDepthFormat is not supported:" + exports.RenderBufferDepthFormat[format]);
      }

      if (isCube && width !== height) {
        throw new Error("The cube texture must have the same width and height");
      }

      if (_mipmap && !isWebGL2 && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
        Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
        /** @ts-ignore */

        texture._mipmap = false;
        /** @ts-ignore */

        texture._mipmapCount = texture._getMipmapCount();
      }

      _this._formatDetail = GLTexture._getRenderBufferDepthFormatDetail(format, _this._gl, isWebGL2);

      _this._initMipmap(isCube);

      return _this;
    }

    return GLRenderDepthTexture;
  }(GLTexture);
  /**
   * @private
   */


  var GLRenderStates = /*#__PURE__*/function () {
    /**
     * @param {WebGLRenderingContext} gl
     */
    function GLRenderStates(gl) {
      this._gl = void 0;
      this._parameters = {};
      this._gl = gl;
      this._parameters = {}; // current gl state parameters

      /** cache */

      this._parameters[gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
      this._parameters[gl.MAX_VERTEX_UNIFORM_VECTORS] = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
      this._parameters[gl.MAX_VERTEX_ATTRIBS] = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
      this._parameters[gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
      this._parameters[gl.MAX_TEXTURE_SIZE] = gl.getParameter(gl.MAX_TEXTURE_SIZE); // init blend state same as BlendState default value.

      gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
      gl.colorMask(true, true, true, true);
      gl.blendColor(0, 0, 0, 0);
      gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE); // init depth state same as DepthState default value.

      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LESS);
      gl.depthMask(true); // init stencil state same as StencilState default value.

      gl.disable(gl.STENCIL_TEST);
      gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 0, 0xff);
      gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 0, 0xff);
      gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
      gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
      gl.stencilMask(0xff); // init raster state same as RasterState default value.

      gl.enable(gl.CULL_FACE);
      gl.cullFace(gl.BACK);
      gl.disable(gl.POLYGON_OFFSET_FILL);
      gl.polygonOffset(0, 0);
    }
    /**
     * Get a parameter.
     */


    var _proto = GLRenderStates.prototype;

    _proto.getParameter = function getParameter(pname) {
      return this._parameters[pname];
    };

    return GLRenderStates;
  }();
  /**
   * The render target in WebGL platform is used for off-screen rendering.
   */


  var GLRenderTarget = /*#__PURE__*/function () {
    /**
     * Create render target in WebGL platform.
     */
    function GLRenderTarget(rhi, target) {
      this._gl = void 0;
      this._isWebGL2 = void 0;
      this._target = void 0;
      this._frameBuffer = void 0;
      this._MSAAFrameBuffer = void 0;
      this._depthRenderBuffer = void 0;
      this._MSAAColorRenderBuffers = [];
      this._MSAADepthRenderBuffer = void 0;
      this._oriDrawBuffers = void 0;
      this._blitDrawBuffers = void 0;
      this._gl = rhi.gl;
      this._isWebGL2 = rhi.isWebGL2;
      this._target = target;
      /** @ts-ignore */

      var _colorTextures = target._colorTextures,
          _depth = target._depth,
          width = target.width,
          height = target.height;
      /** todo
       * MRT + Cube + [,MSAA]
       * MRT + MSAA
       */

      if (!(_depth instanceof RenderDepthTexture) && !GLTexture._supportRenderBufferDepthFormat(_depth, rhi, false)) {
        throw new Error("RenderBufferDepthFormat is not supported:" + exports.RenderBufferDepthFormat[_depth]);
      }

      if (_colorTextures.length > 1 && !rhi.canIUse(exports.GLCapabilityType.drawBuffers)) {
        throw new Error("MRT is not supported");
      }

      if (_colorTextures.some(function (v) {
        return v.width !== width || v.height !== height;
      })) {
        throw new Error("RenderColorTexture's size must as same as RenderTarget");
      }

      if (_depth instanceof RenderDepthTexture && (_depth.width !== width || _depth.height !== height)) {
        throw new Error("RenderDepthTexture's size must as same as RenderTarget");
      } // todo: necessary to support MRT + Cube + [,MSAA] ?


      if (_colorTextures.length > 1 && _colorTextures.some(function (v) {
        return v.isCube;
      })) {
        throw new Error("MRT+Cube+[,MSAA] is not supported");
      }

      var maxAntiAliasing = rhi.capability.maxAntiAliasing;

      if (target.antiAliasing > maxAntiAliasing) {
        Logger.warn("MSAA antiAliasing exceeds the limit and is automatically downgraded to:" + maxAntiAliasing);
        /** @ts-ignore */

        target._antiAliasing = maxAntiAliasing;
      }

      this._frameBuffer = this._gl.createFramebuffer(); // bind main FBO

      this._bindMainFBO(); // bind MSAA FBO


      if (target.antiAliasing > 1) {
        this._MSAAFrameBuffer = this._gl.createFramebuffer();

        this._bindMSAAFBO();
      }
    }
    /**
     * Set which face of the cube texture to render to.
     * @param faceIndex - Cube texture face
     */


    var _proto = GLRenderTarget.prototype;

    _proto.setRenderTargetFace = function setRenderTargetFace(faceIndex) {
      var gl = this._gl;

      var colorTexture = this._target.getColorTexture(0);

      var depthTexture = this._target.depthTexture;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer); // bind render color texture

      if (colorTexture !== null && colorTexture !== void 0 && colorTexture.isCube) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,
        /** @ts-ignore */
        colorTexture._platformTexture._glTexture, 0);
      } // bind depth texture


      if (depthTexture !== null && depthTexture !== void 0 && depthTexture.isCube) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER,
        /** @ts-ignore */
        depthTexture._platformTexture._formatDetail.attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,
        /** @ts-ignore */
        depthTexture._platformTexture._glTexture, 0);
      } // revert current activated render target


      this._activeRenderTarget();
    }
    /**
     * Blit FBO.
     */
    ;

    _proto.blitRenderTarget = function blitRenderTarget() {
      if (!this._MSAAFrameBuffer) return;
      var gl = this._gl;
      var mask = gl.COLOR_BUFFER_BIT | (this._target.depthTexture ? gl.DEPTH_BUFFER_BIT : 0);
      var _this$_target = this._target,
          colorTextureCount = _this$_target.colorTextureCount,
          width = _this$_target.width,
          height = _this$_target.height;
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._MSAAFrameBuffer);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);

      for (var textureIndex = 0; textureIndex < colorTextureCount; textureIndex++) {
        var attachment = gl.COLOR_ATTACHMENT0 + textureIndex;
        this._blitDrawBuffers[textureIndex] = attachment;
        gl.readBuffer(attachment);
        gl.drawBuffers(this._blitDrawBuffers);
        gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);
        this._blitDrawBuffers[textureIndex] = gl.NONE;
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    /**
     * Destroy render target.
     */
    ;

    _proto.destroy = function destroy() {
      var gl = this._gl;
      this._frameBuffer && gl.deleteFramebuffer(this._frameBuffer);
      this._depthRenderBuffer && gl.deleteRenderbuffer(this._depthRenderBuffer);
      this._MSAAFrameBuffer && gl.deleteFramebuffer(this._MSAAFrameBuffer);
      this._MSAADepthRenderBuffer && gl.deleteRenderbuffer(this._MSAADepthRenderBuffer);

      for (var i = 0; i < this._MSAAColorRenderBuffers.length; i++) {
        gl.deleteRenderbuffer(this._MSAAColorRenderBuffers[i]);
      }

      this._frameBuffer = null;
      this._depthRenderBuffer = null;
      this._MSAAFrameBuffer = null;
      this._MSAAColorRenderBuffers.length = 0;
      this._MSAADepthRenderBuffer = null;
    }
    /**
     * Activate this RenderTarget.
     * @internal
     * @remarks
     * If MSAA is turned on, MSAA FBO is activated, and then this._blitRenderTarget() is performed to exchange FBO.
     * If MSAA is not turned on, activate the main FBO.
     */
    ;

    _proto._activeRenderTarget = function _activeRenderTarget() {
      var gl = this._gl;

      if (this._MSAAFrameBuffer) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
      } else {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
      }
    };

    _proto._bindMainFBO = function _bindMainFBO() {
      var gl = this._gl;
      var isWebGL2 = this._isWebGL2;
      /** @ts-ignore */

      var _this$_target2 = this._target,
          _depth = _this$_target2._depth,
          colorTextureCount = _this$_target2.colorTextureCount,
          width = _this$_target2.width,
          height = _this$_target2.height;
      var drawBuffers = new Array(colorTextureCount);
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
      /** color render buffer */

      for (var i = 0; i < colorTextureCount; i++) {
        var colorTexture = this._target.getColorTexture(i);

        var attachment = gl.COLOR_ATTACHMENT0 + i;
        drawBuffers[i] = attachment; // Cube texture please call _setRenderTargetFace()

        if (!colorTexture.isCube) {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D,
          /** @ts-ignore */
          colorTexture._platformTexture._glTexture, 0);
        }
      }

      if (colorTextureCount > 1) {
        gl.drawBuffers(drawBuffers);
      }

      this._oriDrawBuffers = drawBuffers;
      /** depth render buffer */

      if (_depth !== null) {
        if (_depth instanceof RenderDepthTexture) {
          // Cube texture please call _setRenderTargetFace()
          if (!_depth.isCube) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER,
            /** @ts-ignore */
            _depth._platformTexture._formatDetail.attachment, gl.TEXTURE_2D,
            /** @ts-ignore */
            _depth._platformTexture._glTexture, 0);
          }
        } else if (this._target.antiAliasing <= 1) {
          var _GLTexture$_getRender = GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2),
              internalFormat = _GLTexture$_getRender.internalFormat,
              _attachment = _GLTexture$_getRender.attachment;

          var depthRenderBuffer = gl.createRenderbuffer();
          this._depthRenderBuffer = depthRenderBuffer;
          gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
          gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, _attachment, gl.RENDERBUFFER, depthRenderBuffer);
        }
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    };

    _proto._bindMSAAFBO = function _bindMSAAFBO() {
      var gl = this._gl;
      var isWebGL2 = this._isWebGL2;
      var MSAADepthRenderBuffer = gl.createRenderbuffer();
      /** @ts-ignore */

      var _this$_target3 = this._target,
          _depth = _this$_target3._depth,
          colorTextureCount = _this$_target3.colorTextureCount,
          antiAliasing = _this$_target3.antiAliasing,
          width = _this$_target3.width,
          height = _this$_target3.height;
      this._blitDrawBuffers = new Array(colorTextureCount);
      this._MSAADepthRenderBuffer = MSAADepthRenderBuffer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer); // prepare MRT+MSAA color RBOs

      for (var i = 0; i < colorTextureCount; i++) {
        var MSAAColorRenderBuffer = gl.createRenderbuffer();
        this._MSAAColorRenderBuffers[i] = MSAAColorRenderBuffer;
        this._blitDrawBuffers[i] = gl.NONE;
        gl.bindRenderbuffer(gl.RENDERBUFFER, MSAAColorRenderBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, antiAliasing,
        /** @ts-ignore */
        this._target.getColorTexture(i)._platformTexture._formatDetail.internalFormat, width, height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, MSAAColorRenderBuffer);
      }

      gl.drawBuffers(this._oriDrawBuffers); // prepare MSAA depth RBO

      if (_depth !== null) {
        var _ref = _depth instanceof RenderDepthTexture ?
        /** @ts-ignore */
        _depth._platformTexture._formatDetail : GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2),
            internalFormat = _ref.internalFormat,
            attachment = _ref.attachment;

        gl.bindRenderbuffer(gl.RENDERBUFFER, MSAADepthRenderBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, antiAliasing, internalFormat, width, height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, MSAADepthRenderBuffer);
      }

      this._checkFrameBuffer();

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    };

    _proto._checkFrameBuffer = function _checkFrameBuffer() {
      var gl = this._gl;
      var isWebGL2 = this._isWebGL2;
      var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

      switch (e) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete");

        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          throw new Error("There is no attachment");

        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          throw new Error(" Height and width of the attachment are not the same.");

        case gl.FRAMEBUFFER_UNSUPPORTED:
          throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer");
      }

      if (isWebGL2 && e === gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {
        throw new Error("The values of gl.RENDERBUFFER_SAMPLES are different among attached renderbuffers, or are non-zero if the attached images are a mix of renderbuffers and textures.");
      }
    };

    return GLRenderTarget;
  }();
  /**
   * Texture 2d in WebGL platform.
   */


  var GLTexture2D = /*#__PURE__*/function (_GLTexture) {
    _inheritsLoose$1(GLTexture2D, _GLTexture);
    /**
     * Backward compatible with WebGL1.0.
     */

    /**
     * Create texture2D in WebGL platform.
     */


    function GLTexture2D(rhi, texture2D) {
      var _this;

      _this = _GLTexture.call(this, rhi, texture2D, rhi.gl.TEXTURE_2D) || this;
      /** @ts-ignore */

      _this._compressedMipFilled = 0;
      var format = texture2D.format,
          _mipmap = texture2D._mipmap,
          width = texture2D.width,
          height = texture2D.height;
      var isWebGL2 = _this._isWebGL2;

      if (!GLTexture._supportTextureFormat(format, rhi)) {
        throw new Error("Texture format is not supported:" + exports.TextureFormat[format]);
      }

      if (_mipmap && !isWebGL2 && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
        Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
        /** @ts-ignore */

        texture2D._mipmap = false;
        /** @ts-ignore */

        texture2D._mipmapCount = texture2D._getMipmapCount();
      }

      _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, isWebGL2);
      _this._formatDetail.isCompressed && !isWebGL2 || _this._initMipmap(false);
      return _this;
    }
    /**
     * Setting pixels data through color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
     * @remarks If it is the WebGL1.0 platform and the texture format is compressed, the first upload must be filled with textures.
     * @param colorBuffer - Color buffer data
     * @param mipLevel - Texture mipmapping level
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     * @param width - Data width. if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
     * @param height - Data height. if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
     */


    var _proto = GLTexture2D.prototype;

    _proto.setPixelBuffer = function setPixelBuffer(colorBuffer, mipLevel, x, y, width, height) {
      if (mipLevel === void 0) {
        mipLevel = 0;
      }

      var gl = this._gl;
      var isWebGL2 = this._isWebGL2;
      var _this$_formatDetail = this._formatDetail,
          internalFormat = _this$_formatDetail.internalFormat,
          baseFormat = _this$_formatDetail.baseFormat,
          dataType = _this$_formatDetail.dataType,
          isCompressed = _this$_formatDetail.isCompressed;
      var mipWidth = Math.max(1, this._texture.width >> mipLevel);
      var mipHeight = Math.max(1, this._texture.height >> mipLevel);
      x = x || 0;
      y = y || 0;
      width = width || mipWidth - x;
      height = height || mipHeight - y;

      this._bind();

      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);

      if (isCompressed) {
        var mipBit = 1 << mipLevel;

        if (isWebGL2 || this._compressedMipFilled & mipBit) {
          gl.compressedTexSubImage2D(this._target, mipLevel, x, y, width, height, internalFormat, colorBuffer);
        } else {
          gl.compressedTexImage2D(this._target, mipLevel, internalFormat, width, height, 0, colorBuffer);
          this._compressedMipFilled |= mipBit;
        }
      } else {
        gl.texSubImage2D(this._target, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
      }
    }
    /**
     * Setting pixels data through TexImageSource, designated area and texture mipmapping level.
     * @param imageSource - The source of texture
     * @param mipLevel - Texture mipmapping level
     * @param flipY - Whether to flip the Y axis
     * @param premultiplyAlpha - Whether to premultiply the transparent channel
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     */
    ;

    _proto.setImageSource = function setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
      if (mipLevel === void 0) {
        mipLevel = 0;
      }

      if (flipY === void 0) {
        flipY = false;
      }

      if (premultiplyAlpha === void 0) {
        premultiplyAlpha = false;
      }

      var gl = this._gl;
      var _this$_formatDetail2 = this._formatDetail,
          baseFormat = _this$_formatDetail2.baseFormat,
          dataType = _this$_formatDetail2.dataType;

      this._bind();

      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
      gl.texSubImage2D(this._target, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
    }
    /**
     * Get the pixel color buffer according to the specified area.
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     * @param width - Area width
     * @param height - Area height
     * @param out - Color buffer
     */
    ;

    _proto.getPixelBuffer = function getPixelBuffer(x, y, width, height, out) {
      if (this._formatDetail.isCompressed) {
        throw new Error("Unable to read compressed texture");
      }

      _GLTexture.prototype._getPixelBuffer.call(this, null, x, y, width, height, out);
    };

    return GLTexture2D;
  }(GLTexture);
  /**
   * Cube texture in WebGL platform.
   */


  var GLTextureCubeMap = /*#__PURE__*/function (_GLTexture) {
    _inheritsLoose$1(GLTextureCubeMap, _GLTexture);
    /**
     * Backward compatible with WebGL1.0.。
     */

    /**
     * Create cube texture in WebGL platform.
     */


    function GLTextureCubeMap(rhi, textureCube) {
      var _this;

      _this = _GLTexture.call(this, rhi, textureCube, rhi.gl.TEXTURE_CUBE_MAP) || this;
      /** @ts-ignore */

      _this._compressedFaceFilled = [0, 0, 0, 0, 0, 0];
      var format = textureCube.format,
          _mipmap = textureCube._mipmap,
          size = textureCube.width;
      var isWebGL2 = _this._isWebGL2;

      if (!GLTexture._supportTextureFormat(format, rhi)) {
        throw new Error("Texture format is not supported:" + exports.TextureFormat[format]);
      }

      if (_mipmap && !isWebGL2 && !GLTexture._isPowerOf2(size)) {
        Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
        /** @ts-ignore */

        textureCube._mipmap = false;
        /** @ts-ignore */

        textureCube._mipmapCount = textureCube._getMipmapCount();
      }

      _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, isWebGL2);
      _this._formatDetail.isCompressed && !isWebGL2 || _this._initMipmap(true);
      return _this;
    }
    /**
     * Setting pixels data through cube face,color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
     * @remarks When compressed texture is in WebGL1, the texture must be filled first before writing the sub-region
     * @param face - Cube face
     * @param colorBuffer - Color buffer data
     * @param mipLevel - Texture mipmapping level
     * @param x - X coordinate of area start
     * @param y -  Y coordinate of area start
     * @param width - Data width.if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
     * @param height - Data height.if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
     */


    var _proto = GLTextureCubeMap.prototype;

    _proto.setPixelBuffer = function setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height) {
      if (mipLevel === void 0) {
        mipLevel = 0;
      }

      var gl = this._gl;
      var isWebGL2 = this._isWebGL2;
      var _this$_formatDetail = this._formatDetail,
          internalFormat = _this$_formatDetail.internalFormat,
          baseFormat = _this$_formatDetail.baseFormat,
          dataType = _this$_formatDetail.dataType,
          isCompressed = _this$_formatDetail.isCompressed;
      var mipSize = Math.max(1, this._texture.width >> mipLevel);
      x = x || 0;
      y = y || 0;
      width = width || mipSize - x;
      height = height || mipSize - y;

      this._bind();

      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);

      if (isCompressed) {
        var mipBit = 1 << mipLevel;

        if (isWebGL2 || this._compressedFaceFilled[face] & mipBit) {
          gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, internalFormat, colorBuffer);
        } else {
          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, internalFormat, width, height, 0, colorBuffer);
          this._compressedFaceFilled[face] |= mipBit;
        }
      } else {
        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
      }
    }
    /**
     * Setting pixels data through cube face, TexImageSource, designated area and texture mipmapping level.
     * @param face - Cube face
     * @param imageSource - The source of texture
     * @param mipLevel - Texture mipmapping level
     * @param flipY - Whether to flip the Y axis
     * @param premultiplyAlpha - Whether to premultiply the transparent channel
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     */
    ;

    _proto.setImageSource = function setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
      if (mipLevel === void 0) {
        mipLevel = 0;
      }

      if (flipY === void 0) {
        flipY = false;
      }

      if (premultiplyAlpha === void 0) {
        premultiplyAlpha = false;
      }

      var gl = this._gl;
      var _this$_formatDetail2 = this._formatDetail,
          baseFormat = _this$_formatDetail2.baseFormat,
          dataType = _this$_formatDetail2.dataType;

      this._bind();

      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
      gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
    }
    /**
     * Get the pixel color buffer according to the specified cube face and area.
     * @param face - You can choose which cube face to read
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     * @param width - Area width
     * @param height - Area height
     * @param out - Color buffer
     */
    ;

    _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, out) {
      if (this._formatDetail.isCompressed) {
        throw new Error("Unable to read compressed texture");
      }

      _GLTexture.prototype._getPixelBuffer.call(this, face, x, y, width, height, out);
    };

    return GLTextureCubeMap;
  }(GLTexture);
  /**
   * WebGL mode.
   */


  exports.WebGLMode = void 0;
  /**
   * WebGL renderer options.
   */

  (function (WebGLMode) {
    WebGLMode[WebGLMode["Auto"] = 0] = "Auto";
    WebGLMode[WebGLMode["WebGL2"] = 1] = "WebGL2";
    WebGLMode[WebGLMode["WebGL1"] = 2] = "WebGL1";
  })(exports.WebGLMode || (exports.WebGLMode = {}));
  /**
   * WebGL renderer, including WebGL1.0 and WebGL2.0.
   */


  var WebGLRenderer = /*#__PURE__*/function () {
    function WebGLRenderer(options) {
      if (options === void 0) {
        options = {};
      }

      this._currentBind = void 0;
      this._options = void 0;
      this._gl = void 0;
      this._renderStates = void 0;
      this._extensions = void 0;
      this._capability = void 0;
      this._isWebGL2 = void 0;
      this._activeTextureID = void 0;
      this._activeTextures = new Array(32);
      this._lastViewport = new Vector4(null, null, null, null);
      this._lastClearColor = new Color(null, null, null, null);
      this._options = options;
    }

    var _proto = WebGLRenderer.prototype;

    _proto.init = function init(canvas) {
      var option = this._options;
      option.alpha === undefined && (option.alpha = false);
      option.stencil === undefined && (option.stencil = true);
      var webCanvas = canvas._webCanvas;
      var webGLMode = option.webGLMode || exports.WebGLMode.Auto;
      var gl;

      if (webGLMode == exports.WebGLMode.Auto || webGLMode == exports.WebGLMode.WebGL2) {
        gl = webCanvas.getContext("webgl2", option);

        if (!gl && webCanvas instanceof HTMLCanvasElement) {
          gl = webCanvas.getContext("experimental-webgl2", option);
        }

        this._isWebGL2 = true; // Prevent weird browsers to lie (such as safari!)

        if (gl && !gl.deleteQuery) {
          this._isWebGL2 = false;
        }
      }

      if (!gl) {
        if (webGLMode == exports.WebGLMode.Auto || webGLMode == exports.WebGLMode.WebGL1) {
          gl = webCanvas.getContext("webgl", option);

          if (!gl && webCanvas instanceof HTMLCanvasElement) {
            gl = webCanvas.getContext("experimental-webgl", option);
          }

          this._isWebGL2 = false;
        }
      }

      if (!gl) {
        throw new Error("Get GL Context FAILED.");
      }

      this._gl = gl;
      this._activeTextureID = gl.TEXTURE0;
      this._renderStates = new GLRenderStates(gl);
      this._extensions = new GLExtensions(this);
      this._capability = new GLCapability(this); // Make sure the active texture in gl context is on default, because gl context may be used in other webgl renderer.

      gl.activeTexture(gl.TEXTURE0);
      this._options = null;
    };

    _proto.createPlatformPrimitive = function createPlatformPrimitive(primitive) {
      return new GLPrimitive(this, primitive);
    };

    _proto.createPlatformTexture2D = function createPlatformTexture2D(texture2D) {
      return new GLTexture2D(this, texture2D);
    };

    _proto.createPlatformTextureCubeMap = function createPlatformTextureCubeMap(textureCube) {
      return new GLTextureCubeMap(this, textureCube);
    };

    _proto.createPlatformRenderColorTexture = function createPlatformRenderColorTexture(texture) {
      return new GLRenderColorTexture(this, texture);
    };

    _proto.createPlatformRenderDepthTexture = function createPlatformRenderDepthTexture(texture) {
      return new GLRenderDepthTexture(this, texture);
    };

    _proto.createPlatformRenderTarget = function createPlatformRenderTarget(target) {
      return new GLRenderTarget(this, target);
    };

    _proto.requireExtension = function requireExtension(ext) {
      return this._extensions.requireExtension(ext);
    };

    _proto.canIUse = function canIUse(capabilityType) {
      return this.capability.canIUse(capabilityType);
    };

    _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(type) {
      return this.capability.canIUseCompressedTextureInternalFormat(type);
    };

    _proto.viewport = function viewport(x, y, width, height) {
      // gl.enable(gl.SCISSOR_TEST);
      // gl.scissor(x, transformY, width, height);
      var gl = this._gl;
      var lv = this._lastViewport;

      if (x !== lv.x || y !== lv.y || width !== lv.z || height !== lv.w) {
        gl.viewport(x, y, width, height);
        lv.setValue(x, y, width, height);
      }
    };

    _proto.colorMask = function colorMask(r, g, b, a) {
      this._gl.colorMask(r, g, b, a);
    };

    _proto.clearRenderTarget = function clearRenderTarget(engine, clearFlags, clearColor) {
      var gl = this._gl;
      var _engine$_lastRenderSt = engine._lastRenderState,
          targetBlendState = _engine$_lastRenderSt.blendState.targetBlendState,
          depthState = _engine$_lastRenderSt.depthState,
          stencilState = _engine$_lastRenderSt.stencilState;
      var clearFlag = gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT;

      if (clearFlags === exports.CameraClearFlags.DepthColor) {
        clearFlag |= gl.COLOR_BUFFER_BIT;
        var lc = this._lastClearColor;
        var r = clearColor.r,
            g = clearColor.g,
            b = clearColor.b,
            a = clearColor.a;

        if (clearColor && (r !== lc.r || g !== lc.g || b !== lc.b || a !== lc.a)) {
          gl.clearColor(r, g, b, a);
          lc.setValue(r, g, b, a);
        }

        if (targetBlendState.colorWriteMask !== exports.ColorWriteMask.All) {
          gl.colorMask(true, true, true, true);
          targetBlendState.colorWriteMask = exports.ColorWriteMask.All;
        }
      }

      if (depthState.writeEnabled !== true) {
        gl.depthMask(true);
        depthState.writeEnabled = true;
      }

      if (stencilState.writeMask !== 0xff) {
        gl.stencilMask(0xff);
        stencilState.writeMask = 0xff;
      }

      gl.clear(clearFlag);
    };

    _proto.drawPrimitive = function drawPrimitive(primitive, subPrimitive, shaderProgram) {
      // todo: VAO not support morph animation
      if (primitive) {
        //@ts-ignore
        primitive._draw(shaderProgram, subPrimitive);
      } else {
        Logger.error("draw primitive failed.");
      }
    };

    _proto.activeRenderTarget = function activeRenderTarget(renderTarget, camera) {
      var gl = this._gl;

      if (renderTarget) {
        var _renderTarget$_platfo;
        /** @ts-ignore */


        (_renderTarget$_platfo = renderTarget._platformRenderTarget) === null || _renderTarget$_platfo === void 0 ? void 0 : _renderTarget$_platfo._activeRenderTarget();
        var width = renderTarget.width,
            height = renderTarget.height;
        this.viewport(0, 0, width, height);
      } else {
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        var viewport = camera.viewport;
        var drawingBufferWidth = gl.drawingBufferWidth,
            drawingBufferHeight = gl.drawingBufferHeight;

        var _width = drawingBufferWidth * viewport.z;

        var _height = drawingBufferHeight * viewport.w;

        var x = viewport.x * drawingBufferWidth;
        var y = drawingBufferHeight - viewport.y * drawingBufferHeight - _height;
        this.viewport(x, y, _width, _height);
      }
    };

    _proto.destroy = function destroy() {};

    _proto.activeTexture = function activeTexture(textureID) {
      if (this._activeTextureID !== textureID) {
        this._gl.activeTexture(textureID);

        this._activeTextureID = textureID;
      }
    };

    _proto.bindTexture = function bindTexture(texture) {
      var index = this._activeTextureID - this._gl.TEXTURE0;

      if (this._activeTextures[index] !== texture) {
        this._gl.bindTexture(texture._target, texture._glTexture);

        this._activeTextures[index] = texture;
      }
    };

    _createClass$2(WebGLRenderer, [{
      key: "isWebGL2",
      get: // cache value
      function get() {
        return this._isWebGL2;
      }
      /**
       * GL Context
       * @member {WebGLRenderingContext}
       */

    }, {
      key: "gl",
      get: function get() {
        return this._gl;
      }
    }, {
      key: "renderStates",
      get: function get() {
        return this._renderStates;
      }
    }, {
      key: "capability",
      get: function get() {
        return this._capability;
      }
    }, {
      key: "canIUseMoreJoints",
      get: function get() {
        return this.capability.canIUseMoreJoints;
      }
    }]);

    return WebGLRenderer;
  }();
  /**
   * WebGL platform engine,support includes WebGL1.0 and WebGL2.0.
   */


  var WebGLEngine = /*#__PURE__*/function (_Engine) {
    _inheritsLoose$1(WebGLEngine, _Engine);
    /**
     * Create an engine suitable for the WebGL platform.
     * @param canvas - Native web canvas
     * @param webGLRendererOptions - WebGL renderer options
     */


    function WebGLEngine(canvas, webGLRendererOptions) {
      var webCanvas = new WebCanvas(typeof canvas === "string" ? document.getElementById(canvas) : canvas);
      var hardwareRenderer = new WebGLRenderer(webGLRendererOptions);
      return _Engine.call(this, webCanvas, hardwareRenderer) || this;
    }
    /**
     * Web canvas.
     */


    _createClass$2(WebGLEngine, [{
      key: "canvas",
      get: function get() {
        return this._canvas;
      }
    }]);

    return WebGLEngine;
  }(Engine);

  function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);
    return Constructor;
  }

  var DRACOWorker = /*#__PURE__*/function () {
    function DRACOWorker(workerSourceURL, decoderWASMBinary) {
      var _this = this;

      this._worker = void 0;
      this._costs = {};
      this._currentLoad = 0;
      this._callbacks = {};
      this._worker = new Worker(workerSourceURL);

      this._worker.onmessage = function (e) {
        var message = e.data;

        switch (message.type) {
          case "decode":
            _this._callbacks[message.id].resolve(message.geometry);

            break;

          case "error":
            _this._callbacks[message.id].reject(message);

            break;

          default:
            Logger.error('DRACOWorker: Unexpected message, "' + message.type + '"');
        }
      };

      if (decoderWASMBinary) {
        this._worker.postMessage({
          type: "init",
          decoderConfig: {
            wasmBinary: decoderWASMBinary
          }
        });
      } else {
        this._worker.postMessage({
          type: "init",
          decoderConfig: {}
        });
      }
    }

    var _proto = DRACOWorker.prototype;

    _proto.setCosts = function setCosts(taskId, cost) {
      this._costs[taskId] = cost;
    };

    _proto.addCurrentLoad = function addCurrentLoad(cost) {
      this._currentLoad += cost;
    };

    _proto.setCallback = function setCallback(taskId, resolve, reject) {
      this._callbacks[taskId] = {
        resolve: resolve,
        reject: reject
      };
    };

    _proto.decode = function decode(taskId, taskConfig, buffer) {
      this._worker.postMessage({
        type: "decode",
        id: taskId,
        taskConfig: taskConfig,
        buffer: buffer
      }, [buffer]);
    };

    _proto.releaseTask = function releaseTask(taskId) {
      this._currentLoad -= this._costs[taskId];
      delete this._callbacks[taskId];
      delete this._costs[taskId];
    };

    _createClass$1(DRACOWorker, [{
      key: "currentLoad",
      get: // Worker instance.
      // Record byteLength of each task.
      // The sum of bytelength that the worker is currently dealing with, in order to sort the workers.
      function get() {
        return this._currentLoad;
      }
    }]);

    return DRACOWorker;
  }();

  var workerString = "let decoderPending;\nlet decoderConfig;\n\nonmessage = function(e) {\n  const message = e.data;\n\n  switch (message.type) {\n    case \"init\":\n      decoderConfig = message.decoderConfig;\n      decoderPending = new Promise(function(resolve /*, reject*/) {\n        decoderConfig.onModuleLoaded = function(draco) {\n          // Module is Promise-like. Wrap before resolving to avoid loop.\n          resolve({ draco: draco });\n        };\n        DracoDecoderModule(decoderConfig);\n      });\n      break;\n\n    case \"decode\":\n      const buffer = message.buffer;\n      const taskConfig = message.taskConfig;\n      decoderPending.then(module => {\n        const draco = module.draco;\n        const decoder = new draco.Decoder();\n        const decoderBuffer = new draco.DecoderBuffer();\n        decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n        try {\n          const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n          const buffers = geometry.attributes.map(attr => attr.array.buffer);\n          if (geometry.index) buffers.push(geometry.index.array.buffer);\n          self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n        } catch (error) {\n          console.error(error);\n          self.postMessage({ type: \"error\", id: message.id, error: error.message });\n        } finally {\n          draco.destroy(decoderBuffer);\n          draco.destroy(decoder);\n        }\n      });\n      break;\n  }\n};\n\nfunction decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n  const attributeIDs = taskConfig.attributeIDs;\n  const attributeTypes = taskConfig.attributeTypes;\n\n  let dracoGeometry;\n  let decodingStatus;\n\n  const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    dracoGeometry = new draco.Mesh();\n    decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n  } else {\n    throw new Error(\"DRACODecoder worker: Unexpected geometry type.\");\n  }\n\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new Error(\"DRACODecoder worker: Decoding failed: \" + decodingStatus.error_msg());\n  }\n\n  const geometry = { index: null, attributes: [] };\n\n  // Gather all vertex attributes.\n  for (let attributeName in attributeIDs) {\n    const attributeType = self[attributeTypes[attributeName]];\n\n    let attribute;\n    let attributeID;\n\n    // A Draco file may be created with default vertex attributes, whose attribute IDs\n    // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n    // a Draco file may contain a custom set of attributes, identified by known unique\n    // IDs. glTF files always do the latter, and .drc files typically do the former.\n    if (taskConfig.useUniqueIDs) {\n      attributeID = attributeIDs[attributeName];\n      attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n    } else {\n      attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n      if (attributeID === -1) continue;\n      attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n    }\n    geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n  }\n  // Add index.\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    // Generate mesh faces.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    let dataSize;\n    let ptr;\n    let index;\n    const indexType = self[taskConfig.indexType];\n\n    switch (indexType) {\n      case Uint16Array:\n        dataSize = numIndices * 2;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt16Array(dracoGeometry, dataSize, ptr);\n        index = new Uint16Array(draco.HEAPU16.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      case Uint32Array:\n        dataSize = numIndices * 4;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, dataSize, ptr);\n        index = new Uint32Array(draco.HEAPU32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      default:\n        throw new Error(\"DRACODecoder: Unexpected index type.\");\n    }\n    geometry.index = { array: index, itemSize: 1 };\n  }\n  draco.destroy(dracoGeometry);\n  return geometry;\n}\n\nfunction decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n  const numComponents = attribute.num_components();\n  const numPoints = dracoGeometry.num_points();\n  const numValues = numPoints * numComponents;\n  let ptr;\n  let array;\n  let dataSize;\n  switch (attributeType) {\n    case Float32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr);\n      array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT8, numValues, ptr);\n      array = new Int8Array(draco.HEAP8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr);\n      array = new Int16Array(draco.HEAP16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr);\n      array = new Int32Array(draco.HEAP32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr);\n      array = new Uint8Array(draco.HEAPU8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr);\n      array = new Uint16Array(draco.HEAPU16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr);\n      array = new Uint32Array(draco.HEAPU32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    default:\n      throw new Error(\"DRACODecoder: Unexpected attribute type.\");\n  }\n\n  return {\n    name: attributeName,\n    array: array,\n    itemSize: numComponents\n  };\n}\n";
  var LIB_PATH = "https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/";
  var JS_FILE = "draco_decoder_gltf.js";
  var WASM_FILE = "draco_decoder_gltf.r3bin";
  var WASM_WRAPPER_FILE = "draco_wasm_wrapper_gltf.js";

  var DRACODecoder = /*#__PURE__*/function () {
    function DRACODecoder(config) {
      if (config === void 0) {
        config = {
          type: "wasm",
          workerLimit: 4
        };
      }

      this.pool = [];
      this.workerLimit = Math.min(navigator.hardwareConcurrency || 4, 4);
      this.useJS = void 0;
      this.currentTaskId = 1;
      this.taskCache = new WeakMap();
      this.loadLibPromise = void 0;

      if (config.workerLimit > this.workerLimit) {
        Logger.warn("DRACOWorkerPool: Can not initialize worker pool with limit:" + config.workerLimit);
      } else {
        var _config$workerLimit;

        this.workerLimit = (_config$workerLimit = config.workerLimit) != null ? _config$workerLimit : 4;
      }

      this.useJS = typeof WebAssembly !== "object" || config.type === "js";
      this.loadLibPromise = this.preloadLib();
    }

    var _proto = DRACODecoder.prototype;

    _proto.preloadLib = function preloadLib() {
      var _this = this;

      if (this.loadLibPromise) {
        return this.loadLibPromise;
      }

      return new Promise(function (resolve, reject) {
        if (_this.useJS) {
          request("" + LIB_PATH + JS_FILE, {
            type: "text"
          }).then(function (jsSource) {
            var body = [jsSource, workerString].join("\n");
            var workerSourceURL = URL.createObjectURL(new Blob([body]));
            resolve({
              workerSourceURL: workerSourceURL,
              decoderWASMBinary: null
            });
          }).catch(function (reason) {
            reject(reason);
          });
        } else {
          Promise.all([request("" + LIB_PATH + WASM_WRAPPER_FILE, {
            type: "text"
          }), request("" + LIB_PATH + WASM_FILE, {
            type: "arraybuffer"
          })]).then(function (resources) {
            var wrapperSource = resources[0],
                decoderWASMBinary = resources[1];
            var body = [wrapperSource, workerString].join("\n");
            var workerSourceURL = URL.createObjectURL(new Blob([body]));
            resolve({
              workerSourceURL: workerSourceURL,
              decoderWASMBinary: decoderWASMBinary
            });
          }).catch(function (reason) {
            reject(reason);
          });
        }
      });
    };

    _proto.getWorker = function getWorker() {
      var _this2 = this;

      return this.preloadLib().then(function (worderResources) {
        if (_this2.pool.length < _this2.workerLimit) {
          var dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);

          _this2.pool.push(dracoWorker);
        } else {
          _this2.pool.sort(function (a, b) {
            return a.currentLoad > b.currentLoad ? -1 : 1;
          });
        }

        return _this2.pool[_this2.pool.length - 1];
      });
    };

    _proto.decode = function decode(buffer, taskConfig) {
      var _this3 = this;

      var taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred.
      // again from this thread.

      if (this.taskCache.has(buffer)) {
        var cachedTask = this.taskCache.get(buffer);

        if (cachedTask.key === taskKey) {
          return cachedTask.promise;
        } else if (buffer.byteLength === 0) {
          // After using transferable to transfer data, the data in the original environment will be cleared, so it is judged that byteLength is 0, which means it has been transferred.
          // Technically, it would be possible to wait for the previous task to complete,
          // transfer the buffer back, and decode again with the second configuration. That
          // is complex, and I don't know of any reason to decode a Draco buffer twice in
          // different ways, so this is left unimplemented.
          throw new Error("DRACODecoder: Unable to re-decode a buffer with different " + "settings. Buffer has already been transferred.");
        }
      }

      var taskId = this.currentTaskId++;
      var cost = buffer.byteLength;
      var taskWorker;
      var task = new Promise(function (resolve, reject) {
        _this3.getWorker().then(function (worker) {
          taskWorker = worker;
          worker.setCosts(taskId, cost);
          worker.addCurrentLoad(cost);
          worker.setCallback(taskId, resolve, reject);
          worker.decode(taskId, taskConfig, buffer);
        }).catch(function (e) {
          reject(e);
        });
      });
      task.finally(function () {
        if (taskWorker && taskId) {
          taskWorker.releaseTask(taskId);
        }
      });
      this.taskCache.set(buffer, {
        key: taskKey,
        promise: task
      });
      return task;
    };

    return DRACODecoder;
  }();

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);

    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }

    return desc;
  }

  var _dec$j, _class$j;

  function isBase64(url) {
    return /^data:(.+?);base64,/.test(url);
  }

  _dec$j = resourceLoader(exports.AssetType.Buffer, ["bin", "r3bin"], false), _dec$j(_class$j = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(BufferLoader, _Loader);

    function BufferLoader() {
      return _Loader.apply(this, arguments) || this;
    }

    var _proto = BufferLoader.prototype;

    _proto.load = function load(item) {
      var url = item.url;

      if (isBase64(url)) {
        return new AssetPromise(function (resolve) {
          var base64Str = url.slice(13 + RegExp.$1.length);
          var result = Uint8Array.from(atob(base64Str), function (c) {
            return c.charCodeAt(0);
          });
          resolve(result.buffer);
        });
      }

      return this.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
        type: "arraybuffer"
      }));
    };

    return BufferLoader;
  }(Loader)) || _class$j;
  /**
   * Module for glTF 2.0 Interface
   */

  /**
   * The datatype of the components in the attribute
   */

  var AccessorComponentType;
  /**
   * Specifies if the attirbute is a scalar, vector, or matrix
   */

  (function (AccessorComponentType) {
    AccessorComponentType[AccessorComponentType["BYTE"] = 5120] = "BYTE";
    AccessorComponentType[AccessorComponentType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    AccessorComponentType[AccessorComponentType["SHORT"] = 5122] = "SHORT";
    AccessorComponentType[AccessorComponentType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    AccessorComponentType[AccessorComponentType["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    AccessorComponentType[AccessorComponentType["FLOAT"] = 5126] = "FLOAT";
  })(AccessorComponentType || (AccessorComponentType = {}));

  var AccessorType;
  /**
   * The name of the node's TRS property to modify, or the weights of the Morph Targets it instantiates
   */

  (function (AccessorType) {
    AccessorType["SCALAR"] = "SCALAR";
    AccessorType["VEC2"] = "VEC2";
    AccessorType["VEC3"] = "VEC3";
    AccessorType["VEC4"] = "VEC4";
    AccessorType["MAT2"] = "MAT2";
    AccessorType["MAT3"] = "MAT3";
    AccessorType["MAT4"] = "MAT4";
  })(AccessorType || (AccessorType = {}));

  var AnimationChannelTargetPath;
  /**
   * Interpolation algorithm
   */

  (function (AnimationChannelTargetPath) {
    AnimationChannelTargetPath["TRANSLATION"] = "translation";
    AnimationChannelTargetPath["ROTATION"] = "rotation";
    AnimationChannelTargetPath["SCALE"] = "scale";
    AnimationChannelTargetPath["WEIGHTS"] = "weights";
  })(AnimationChannelTargetPath || (AnimationChannelTargetPath = {}));

  var AnimationSamplerInterpolation;
  /**
   * A camera's projection.  A node can reference a camera to apply a transform to place the camera in the scene
   */

  (function (AnimationSamplerInterpolation) {
    AnimationSamplerInterpolation["Linear"] = "LINEAR";
    AnimationSamplerInterpolation["Step"] = "STEP";
    AnimationSamplerInterpolation["CubicSpine"] = "CUBICSPLINE";
  })(AnimationSamplerInterpolation || (AnimationSamplerInterpolation = {}));

  var CameraType;
  /**
   * The mime-type of the image
   */

  (function (CameraType) {
    CameraType["PERSPECTIVE"] = "perspective";
    CameraType["ORTHOGRAPHIC"] = "orthographic";
  })(CameraType || (CameraType = {}));

  var ImageMimeType;
  /**
   * The alpha rendering mode of the material
   */

  (function (ImageMimeType) {
    ImageMimeType["JPEG"] = "image/jpeg";
    ImageMimeType["PNG"] = "image/png";
  })(ImageMimeType || (ImageMimeType = {}));

  var MaterialAlphaMode;
  /**
   * Magnification filter.  Valid values correspond to WebGL enums: 9728 (NEAREST) and 9729 (LINEAR)
   */

  (function (MaterialAlphaMode) {
    MaterialAlphaMode["OPAQUE"] = "OPAQUE";
    MaterialAlphaMode["MASK"] = "MASK";
    MaterialAlphaMode["BLEND"] = "BLEND";
  })(MaterialAlphaMode || (MaterialAlphaMode = {}));

  var TextureMagFilter;
  /**
   * Minification filter.  All valid values correspond to WebGL enums
   */

  (function (TextureMagFilter) {
    TextureMagFilter[TextureMagFilter["NEAREST"] = 9728] = "NEAREST";
    TextureMagFilter[TextureMagFilter["LINEAR"] = 9729] = "LINEAR";
  })(TextureMagFilter || (TextureMagFilter = {}));

  var TextureMinFilter;
  /**
   * S (U) wrapping mode.  All valid values correspond to WebGL enums
   */

  (function (TextureMinFilter) {
    TextureMinFilter[TextureMinFilter["NEAREST"] = 9728] = "NEAREST";
    TextureMinFilter[TextureMinFilter["LINEAR"] = 9729] = "LINEAR";
    TextureMinFilter[TextureMinFilter["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    TextureMinFilter[TextureMinFilter["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    TextureMinFilter[TextureMinFilter["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    TextureMinFilter[TextureMinFilter["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
  })(TextureMinFilter || (TextureMinFilter = {}));

  var TextureWrapMode;
  /**
   * glTF Property
   */

  (function (TextureWrapMode) {
    TextureWrapMode[TextureWrapMode["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    TextureWrapMode[TextureWrapMode["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    TextureWrapMode[TextureWrapMode["REPEAT"] = 10497] = "REPEAT";
  })(TextureWrapMode || (TextureWrapMode = {}));
  /**
   * @internal
   */


  var GLTFUtil = /*#__PURE__*/function () {
    function GLTFUtil() {}

    GLTFUtil.floatBufferToVector2Array = function floatBufferToVector2Array(buffer) {
      var bufferLen = buffer.length;
      var array = new Array(bufferLen / 2);

      for (var i = 0; i < bufferLen; i += 2) {
        array[i / 2] = new Vector2(buffer[i], buffer[i + 1]);
      }

      return array;
    };

    GLTFUtil.floatBufferToVector3Array = function floatBufferToVector3Array(buffer) {
      var bufferLen = buffer.length;
      var array = new Array(bufferLen / 3);

      for (var i = 0; i < bufferLen; i += 3) {
        array[i / 3] = new Vector3(buffer[i], buffer[i + 1], buffer[i + 2]);
      }

      return array;
    };

    GLTFUtil.floatBufferToVector4Array = function floatBufferToVector4Array(buffer) {
      var bufferLen = buffer.length;
      var array = new Array(bufferLen / 4);

      for (var i = 0; i < bufferLen; i += 4) {
        array[i / 4] = new Vector4(buffer[i], buffer[i + 1], buffer[i + 2], buffer[i + 3]);
      }

      return array;
    }
    /**
     * Parse binary text for glb loader.
     */
    ;

    GLTFUtil.decodeText = function decodeText(array) {
      if (typeof TextDecoder !== "undefined") {
        return new TextDecoder().decode(array);
      } // TextDecoder polyfill


      var s = "";

      for (var i = 0, il = array.length; i < il; i++) {
        s += String.fromCharCode(array[i]);
      }

      return decodeURIComponent(encodeURIComponent(s));
    }
    /**
     * Get the number of bytes occupied by accessor type.
     */
    ;

    GLTFUtil.getAccessorTypeSize = function getAccessorTypeSize(accessorType) {
      switch (accessorType) {
        case AccessorType.SCALAR:
          return 1;

        case AccessorType.VEC2:
          return 2;

        case AccessorType.VEC3:
          return 3;

        case AccessorType.VEC4:
          return 4;

        case AccessorType.MAT2:
          return 4;

        case AccessorType.MAT3:
          return 9;

        case AccessorType.MAT4:
          return 16;
      }
    }
    /**
     * Get the TypedArray corresponding to the component type.
     */
    ;

    GLTFUtil.getComponentType = function getComponentType(componentType) {
      switch (componentType) {
        case AccessorComponentType.BYTE:
          return Int8Array;

        case AccessorComponentType.UNSIGNED_BYTE:
          return Uint8Array;

        case AccessorComponentType.SHORT:
          return Int16Array;

        case AccessorComponentType.UNSIGNED_SHORT:
          return Uint16Array;

        case AccessorComponentType.UNSIGNED_INT:
          return Uint32Array;

        case AccessorComponentType.FLOAT:
          return Float32Array;
      }
    }
    /**
     * Get accessor data.
     */
    ;

    GLTFUtil.getAccessorData = function getAccessorData(gltf, accessor, buffers) {
      var _bufferView$byteStrid;

      var bufferViews = gltf.bufferViews;
      var bufferView = bufferViews[accessor.bufferView];
      var arrayBuffer = buffers[bufferView.buffer];
      var accessorByteOffset = accessor.hasOwnProperty("byteOffset") ? accessor.byteOffset : 0;
      var bufferViewByteOffset = bufferView.hasOwnProperty("byteOffset") ? bufferView.byteOffset : 0;
      var byteOffset = accessorByteOffset + bufferViewByteOffset;
      var accessorTypeSize = GLTFUtil.getAccessorTypeSize(accessor.type);
      var length = accessorTypeSize * accessor.count;
      var byteStride = (_bufferView$byteStrid = bufferView.byteStride) != null ? _bufferView$byteStrid : 0;
      var arrayType = GLTFUtil.getComponentType(accessor.componentType);
      var uint8Array;

      if (byteStride) {
        var accessorByteSize = accessorTypeSize * arrayType.BYTES_PER_ELEMENT;
        uint8Array = new Uint8Array(accessor.count * accessorByteSize);
        var originalBufferView = new Uint8Array(arrayBuffer, bufferViewByteOffset, bufferView.byteLength);

        for (var i = 0; i < accessor.count; i++) {
          for (var j = 0; j < accessorByteSize; j++) {
            uint8Array[i * accessorByteSize + j] = originalBufferView[i * byteStride + accessorByteOffset + j];
          }
        }
      } else {
        uint8Array = new Uint8Array(arrayBuffer.slice(byteOffset, byteOffset + length * arrayType.BYTES_PER_ELEMENT));
      }

      var typedArray = new arrayType(uint8Array.buffer);

      if (accessor.sparse) {
        var _indices$byteOffset, _indicesBufferView$by, _values$byteOffset, _valuesBufferView$byt;

        var _accessor$sparse = accessor.sparse,
            count = _accessor$sparse.count,
            indices = _accessor$sparse.indices,
            values = _accessor$sparse.values;
        var indicesBufferView = bufferViews[indices.bufferView];
        var valuesBufferView = bufferViews[values.bufferView];
        var indicesArrayBuffer = buffers[indicesBufferView.buffer];
        var valuesArrayBuffer = buffers[valuesBufferView.buffer];
        var indicesByteOffset = ((_indices$byteOffset = indices.byteOffset) != null ? _indices$byteOffset : 0) + ((_indicesBufferView$by = indicesBufferView.byteOffset) != null ? _indicesBufferView$by : 0);
        var indicesByteLength = indicesBufferView.byteLength;
        var valuesByteOffset = ((_values$byteOffset = values.byteOffset) != null ? _values$byteOffset : 0) + ((_valuesBufferView$byt = valuesBufferView.byteOffset) != null ? _valuesBufferView$byt : 0);
        var valuesByteLength = valuesBufferView.byteLength;
        var indicesType = GLTFUtil.getComponentType(indices.componentType);
        var indicesArray = new indicesType(indicesArrayBuffer, indicesByteOffset, indicesByteLength / indicesType.BYTES_PER_ELEMENT);
        var valuesArray = new arrayType(valuesArrayBuffer, valuesByteOffset, valuesByteLength / arrayType.BYTES_PER_ELEMENT);

        for (var _i = 0; _i < count; _i++) {
          var replaceIndex = indicesArray[_i];

          for (var _j = 0; _j < accessorTypeSize; _j++) {
            typedArray[replaceIndex * accessorTypeSize + _j] = valuesArray[_i * accessorTypeSize + _j];
          }
        }
      }

      return typedArray;
    };

    GLTFUtil.getBufferViewData = function getBufferViewData(bufferView, buffers) {
      var buffer = bufferView.buffer,
          _bufferView$byteOffse = bufferView.byteOffset,
          byteOffset = _bufferView$byteOffse === void 0 ? 0 : _bufferView$byteOffse,
          byteLength = bufferView.byteLength;
      var arrayBuffer = buffers[buffer];
      return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
    };

    GLTFUtil.getVertexStride = function getVertexStride(gltf, accessor) {
      var _accessor$bufferView;

      var stride = gltf.bufferViews[(_accessor$bufferView = accessor.bufferView) != null ? _accessor$bufferView : 0].byteStride;

      if (stride) {
        return stride;
      }

      var size = GLTFUtil.getAccessorTypeSize(accessor.type);
      var componentType = GLTFUtil.getComponentType(accessor.componentType);
      return size * componentType.BYTES_PER_ELEMENT;
    };

    GLTFUtil.createVertexElement = function createVertexElement(semantic, accessor, index) {
      var size = GLTFUtil.getAccessorTypeSize(accessor.type);
      return new VertexElement(semantic, 0, GLTFUtil.getElementFormat(accessor.componentType, size, accessor.normalized), index);
    };

    GLTFUtil.getIndexFormat = function getIndexFormat(type) {
      switch (type) {
        case AccessorComponentType.UNSIGNED_BYTE:
          return exports.IndexFormat.UInt8;

        case AccessorComponentType.UNSIGNED_SHORT:
          return exports.IndexFormat.UInt16;

        case AccessorComponentType.UNSIGNED_INT:
          return exports.IndexFormat.UInt32;
      }
    };

    GLTFUtil.getElementFormat = function getElementFormat(type, size, normalized) {
      if (normalized === void 0) {
        normalized = false;
      }

      if (type == AccessorComponentType.FLOAT) {
        switch (size) {
          case 1:
            return exports.VertexElementFormat.Float;

          case 2:
            return exports.VertexElementFormat.Vector2;

          case 3:
            return exports.VertexElementFormat.Vector3;

          case 4:
            return exports.VertexElementFormat.Vector4;
        }
      }

      if (type == AccessorComponentType.SHORT) {
        switch (size) {
          case 2:
            return normalized ? exports.VertexElementFormat.NormalizedShort2 : exports.VertexElementFormat.Short2;

          case 3:
          case 4:
            return normalized ? exports.VertexElementFormat.NormalizedShort4 : exports.VertexElementFormat.Short4;
        }
      }

      if (type == AccessorComponentType.UNSIGNED_SHORT) {
        switch (size) {
          case 2:
            return normalized ? exports.VertexElementFormat.NormalizedUShort2 : exports.VertexElementFormat.UShort2;

          case 3:
          case 4:
            return normalized ? exports.VertexElementFormat.NormalizedUShort4 : exports.VertexElementFormat.UShort4;
        }
      }

      if (type == AccessorComponentType.BYTE) {
        switch (size) {
          case 2:
          case 3:
          case 4:
            return normalized ? exports.VertexElementFormat.NormalizedByte4 : exports.VertexElementFormat.Byte4;
        }
      }

      if (type == AccessorComponentType.UNSIGNED_BYTE) {
        switch (size) {
          case 2:
          case 3:
          case 4:
            return normalized ? exports.VertexElementFormat.NormalizedUByte4 : exports.VertexElementFormat.UByte4;
        }
      }
    }
    /**
     * Load image buffer
     */
    ;

    GLTFUtil.loadImageBuffer = function loadImageBuffer(imageBuffer, type) {
      return new Promise(function (resolve, reject) {
        var blob = new window.Blob([imageBuffer], {
          type: type
        });
        var img = new Image();
        img.src = URL.createObjectURL(blob);
        img.crossOrigin = "anonymous";

        img.onerror = function () {
          reject(new Error("Failed to load image buffer"));
        };

        img.onload = function () {
          // Call requestAnimationFrame to avoid iOS's bug.
          requestAnimationFrame(function () {
            resolve(img);
            img.onload = null;
            img.onerror = null;
            img.onabort = null;
          });
        };
      });
    };

    GLTFUtil.isAbsoluteUrl = function isAbsoluteUrl(url) {
      return /^(?:http|blob|data:|\/)/.test(url);
    };

    GLTFUtil.parseRelativeUrl = function parseRelativeUrl(baseUrl, relativeUrl) {
      if (GLTFUtil.isAbsoluteUrl(relativeUrl)) {
        return relativeUrl;
      }

      var char0 = relativeUrl.charAt(0);

      if (char0 === ".") {
        return GLTFUtil._formatRelativePath(relativeUrl + relativeUrl);
      }

      return baseUrl.substring(0, baseUrl.lastIndexOf("/") + 1) + relativeUrl;
    }
    /**
     * Parse the glb format.
     */
    ;

    GLTFUtil.parseGLB = function parseGLB(glb) {
      var UINT32_LENGTH = 4;
      var GLB_HEADER_MAGIC = 0x46546c67; // 'glTF'

      var GLB_HEADER_LENGTH = 12;
      var GLB_CHUNK_TYPES = {
        JSON: 0x4e4f534a,
        BIN: 0x004e4942
      };
      var dataView = new DataView(glb); // read header

      var header = {
        magic: dataView.getUint32(0, true),
        version: dataView.getUint32(UINT32_LENGTH, true),
        length: dataView.getUint32(2 * UINT32_LENGTH, true)
      };

      if (header.magic !== GLB_HEADER_MAGIC) {
        console.error("Invalid glb magic number. Expected 0x46546C67, found 0x" + header.magic.toString(16));
        return null;
      } // read main data


      var chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);
      var chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true); // read glTF json

      if (chunkType !== GLB_CHUNK_TYPES.JSON) {
        console.error("Invalid glb chunk type. Expected 0x4E4F534A, found 0x" + chunkType.toString(16));
        return null;
      }

      var glTFData = new Uint8Array(glb, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);
      var gltf = JSON.parse(GLTFUtil.decodeText(glTFData)); // read all buffers

      var buffers = [];
      var byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;

      while (byteOffset < header.length) {
        chunkLength = dataView.getUint32(byteOffset, true);
        chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);

        if (chunkType !== GLB_CHUNK_TYPES.BIN) {
          console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
          return null;
        }

        var currentOffset = byteOffset + 2 * UINT32_LENGTH;
        var buffer = glb.slice(currentOffset, currentOffset + chunkLength);
        buffers.push(buffer);
        byteOffset += chunkLength + 2 * UINT32_LENGTH;
      }

      return {
        gltf: gltf,
        buffers: buffers
      };
    };

    GLTFUtil._formatRelativePath = function _formatRelativePath(value) {
      var parts = value.split("/");

      for (var i = 0, n = parts.length; i < n; i++) {
        if (parts[i] == "..") {
          parts.splice(i - 1, 2);
          i -= 2;
        }
      }

      return parts.join("/");
    };

    return GLTFUtil;
  }();

  var Parser$1 = /*#__PURE__*/function () {
    function Parser() {}

    Parser.parseEngineResource = function parseEngineResource(extensionName, extensionSchema, parseResource, context) {
      var parsers = Parser._extensionParsers[extensionName];

      if (parsers !== null && parsers !== void 0 && parsers.length) {
        for (var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
          extra[_key - 4] = arguments[_key];
        }

        for (var i = 0; i < parsers.length; i++) {
          var _parsers$i;

          (_parsers$i = parsers[i]).parseEngineResource.apply(_parsers$i, [extensionSchema, parseResource, context].concat(extra));
        }
      }
    };

    Parser.createEngineResource = function createEngineResource(extensionName, extensionSchema, context) {
      var parsers = Parser._extensionParsers[extensionName];

      if (parsers !== null && parsers !== void 0 && parsers.length) {
        var _parsers$;

        for (var _len2 = arguments.length, extra = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
          extra[_key2 - 3] = arguments[_key2];
        }

        return (_parsers$ = parsers[0]).createEngineResource.apply(_parsers$, [extensionSchema, context].concat(extra));
      }
    };

    Parser.hasExtensionParser = function hasExtensionParser(extensionName) {
      var parsers = Parser._extensionParsers[extensionName];
      return !!(parsers !== null && parsers !== void 0 && parsers.length);
    };

    Parser.initialize = function initialize(extensionName) {
      var parsers = Parser._extensionParsers[extensionName];

      if (parsers !== null && parsers !== void 0 && parsers.length) {
        for (var i = 0; i < parsers.length; i++) {
          parsers[i].initialize();
        }
      }
    }
    /**
     * @internal
     */
    ;

    Parser._addExtensionParser = function _addExtensionParser(extensionName, extensionParser) {
      if (!Parser._extensionParsers[extensionName]) {
        Parser._extensionParsers[extensionName] = [];
      }

      Parser._extensionParsers[extensionName].push(extensionParser);
    };

    return Parser;
  }();
  /**
   * Declare ExtensionParser's decorator.
   * @param extensionName - Extension name
   */


  Parser$1._extensionParsers = {};

  function registerExtension(extensionName) {
    return function (parser) {
      var extensionParser = new parser();

      Parser$1._addExtensionParser(extensionName, extensionParser);
    };
  }

  var AnimationParser = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(AnimationParser, _Parser);

    function AnimationParser() {
      return _Parser.apply(this, arguments) || this;
    }

    var _proto = AnimationParser.prototype;

    _proto.parse = function parse(context) {
      var gltf = context.gltf,
          buffers = context.buffers,
          entities = context.entities;
      var animations = gltf.animations,
          accessors = gltf.accessors;

      if (!animations) {
        return;
      }

      var animationClipCount = animations.length;
      var animationClips = new Array(animationClipCount);
      var animationsIndices = new Array(animationClipCount);

      for (var i = 0; i < animationClipCount; i++) {
        var gltfAnimation = animations[i];
        var channels = gltfAnimation.channels,
            samplers = gltfAnimation.samplers,
            _gltfAnimation$name = gltfAnimation.name,
            name = _gltfAnimation$name === void 0 ? "AnimationClip" + i : _gltfAnimation$name;
        var animationClip = new AnimationClip(name);
        var sampleDataCollection = new Array();

        for (var _i = 0; _i < samplers.length; _i++) {
          var _gltfSampler$interpol;

          var gltfSampler = samplers[_i];
          var inputAccessor = accessors[gltfSampler.input];
          var outputAccessor = accessors[gltfSampler.output];
          var input = GLTFUtil.getAccessorData(gltf, inputAccessor, buffers);
          var output = GLTFUtil.getAccessorData(gltf, outputAccessor, buffers);
          var outputAccessorSize = output.length / input.length;
          var interpolation = (_gltfSampler$interpol = gltfSampler.interpolation) != null ? _gltfSampler$interpol : AnimationSamplerInterpolation.Linear;
          var samplerInterpolation = void 0;

          switch (interpolation) {
            case AnimationSamplerInterpolation.CubicSpine:
              samplerInterpolation = exports.InterpolationType.CubicSpine;
              break;

            case AnimationSamplerInterpolation.Step:
              samplerInterpolation = exports.InterpolationType.Step;
              break;

            case AnimationSamplerInterpolation.Linear:
              samplerInterpolation = exports.InterpolationType.Linear;
              break;
          }

          input[input.length - 1];
          sampleDataCollection.push({
            type: outputAccessor.type,
            interpolation: samplerInterpolation,
            input: input,
            output: output,
            outputSize: outputAccessorSize
          });
        }

        for (var _i2 = 0; _i2 < channels.length; _i2++) {
          var gltfChannel = channels[_i2];
          var target = gltfChannel.target;
          var channelTargetEntity = entities[target.node];
          var relativePath = "";
          var entity = channelTargetEntity;

          while (entity.parent) {
            relativePath = relativePath === "" ? "" + entity.name : entity.name + "/" + relativePath;
            entity = entity.parent;
          }

          var compType = void 0;
          var propertyName = void 0;

          switch (target.path) {
            case AnimationChannelTargetPath.TRANSLATION:
              compType = Transform;
              propertyName = "position";
              break;

            case AnimationChannelTargetPath.ROTATION:
              compType = Transform;
              propertyName = "rotation";
              break;

            case AnimationChannelTargetPath.SCALE:
              compType = Transform;
              propertyName = "scale";
              break;

            case AnimationChannelTargetPath.WEIGHTS:
              compType = SkinnedMeshRenderer;
              propertyName = "blendShapeWeights";
              break;
          }

          var curve = this._addCurve(gltfChannel, sampleDataCollection);

          animationClip.addCurveBinding(relativePath, compType, propertyName, curve);
        }

        animationClips[i] = animationClip;
        animationsIndices[i] = {
          name: name,
          index: i
        };
      }

      context.animations = animationClips; // @ts-ignore for editor

      context._animationsIndices = animationsIndices;
    };

    _proto._addCurve = function _addCurve(gltfChannel, sampleDataCollection) {
      var curve = new AnimationCurve();
      var sampleData = sampleDataCollection[gltfChannel.sampler];
      var type = sampleData.type,
          input = sampleData.input,
          output = sampleData.output,
          outputSize = sampleData.outputSize;
      curve.interpolation = sampleData.interpolation;

      for (var j = 0, n = input.length; j < n; j++) {
        var offset = j * outputSize;

        if (type === AccessorType.SCALAR) {
          var keyframe = outputSize > 1 ? new InterpolableKeyframe() : new InterpolableKeyframe();
          keyframe.time = input[j];
          keyframe.inTangent = 0;
          keyframe.outTangent = 0;
          keyframe.value = outputSize > 1 ? output.subarray(offset, offset + outputSize) : output[offset];
          curve.addKey(keyframe);
        }

        if (type === AccessorType.VEC2) {
          var _keyframe = new InterpolableKeyframe();

          _keyframe.time = input[j];
          _keyframe.value = new Vector2(output[offset], output[offset + 1]);
          _keyframe.inTangent = new Vector2();
          _keyframe.outTangent = new Vector2();
          curve.addKey(_keyframe);
        }

        if (type === AccessorType.VEC3) {
          var _keyframe2 = new InterpolableKeyframe();

          _keyframe2.time = input[j];
          _keyframe2.value = new Vector3(output[offset], output[offset + 1], output[offset + 2]);
          _keyframe2.inTangent = new Vector3();
          _keyframe2.outTangent = new Vector3();
          curve.addKey(_keyframe2);
        }

        if (type === AccessorType.VEC4) {
          var _keyframe3 = new InterpolableKeyframe();

          _keyframe3.time = input[j];
          _keyframe3.value = new Quaternion(output[offset], output[offset + 1], output[offset + 2], output[offset + 3]);
          _keyframe3.inTangent = new Vector4();
          _keyframe3.outTangent = new Vector4();
          curve.addKey(_keyframe3);
        }
      }

      return curve;
    };

    return AnimationParser;
  }(Parser$1);

  var BufferParser = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(BufferParser, _Parser);

    function BufferParser() {
      return _Parser.apply(this, arguments) || this;
    }

    var _proto = BufferParser.prototype;

    _proto.parse = function parse(context) {
      var url = context.url,
          engine = context.engine;

      if (this._isGLB(url)) {
        return engine.resourceManager.load({
          url: url,
          type: exports.AssetType.Buffer
        }).then(GLTFUtil.parseGLB).then(function (_ref) {
          var gltf = _ref.gltf,
              buffers = _ref.buffers;
          context.gltf = gltf;
          context.buffers = buffers;
        });
      } else {
        return engine.resourceManager.load({
          url: url,
          type: exports.AssetType.JSON
        }).then(function (gltf) {
          context.gltf = gltf;
          return Promise.all(gltf.buffers.map(function (buffer) {
            return engine.resourceManager.load({
              type: exports.AssetType.Buffer,
              url: GLTFUtil.parseRelativeUrl(url, buffer.uri)
            });
          })).then(function (buffers) {
            context.buffers = buffers;
          });
        });
      }
    };

    _proto._isGLB = function _isGLB(url) {
      return url.substring(url.lastIndexOf(".") + 1) === "glb";
    };

    return BufferParser;
  }(Parser$1);

  var EntityParser = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(EntityParser, _Parser);

    function EntityParser() {
      return _Parser.apply(this, arguments) || this;
    }

    var _proto = EntityParser.prototype;
    /** @internal */

    _proto.parse = function parse(context) {
      var engine = context.engine,
          nodes = context.gltf.nodes;
      if (!nodes) return;
      var entities = [];

      for (var i = 0; i < nodes.length; i++) {
        var gltfNode = nodes[i];
        var matrix = gltfNode.matrix,
            translation = gltfNode.translation,
            rotation = gltfNode.rotation,
            scale = gltfNode.scale;
        var entity = new Entity(engine, gltfNode.name || "" + EntityParser._defaultName + i);
        var transform = entity.transform;

        if (matrix) {
          var localMatrix = transform.localMatrix;
          localMatrix.setValueByArray(matrix);
          transform.localMatrix = localMatrix;
        } else {
          if (translation) {
            transform.setPosition(translation[0], translation[1], translation[2]);
          }

          if (rotation) {
            transform.setRotationQuaternion(rotation[0], rotation[1], rotation[2], rotation[3]);
          }

          if (scale) {
            transform.setScale(scale[0], scale[1], scale[2]);
          }
        }

        entities[i] = entity;
      }

      context.entities = entities;

      this._buildEntityTree(context);

      this._createSceneRoots(context);
    };

    _proto._buildEntityTree = function _buildEntityTree(context) {
      var nodes = context.gltf.nodes,
          entities = context.entities;

      for (var i = 0; i < nodes.length; i++) {
        var children = nodes[i].children;
        var entity = entities[i];

        if (children) {
          for (var j = 0; j < children.length; j++) {
            var childEntity = entities[children[j]];
            entity.addChild(childEntity);
          }
        }
      }
    };

    _proto._createSceneRoots = function _createSceneRoots(context) {
      var engine = context.engine,
          _context$gltf = context.gltf,
          _context$gltf$scene = _context$gltf.scene,
          sceneID = _context$gltf$scene === void 0 ? 0 : _context$gltf$scene,
          scenes = _context$gltf.scenes,
          entities = context.entities;
      if (!scenes) return;
      var sceneRoots = [];

      for (var i = 0; i < scenes.length; i++) {
        var nodes = scenes[i].nodes;
        if (!nodes) continue;

        if (nodes.length === 1) {
          sceneRoots[i] = entities[nodes[0]];
        } else {
          var rootEntity = new Entity(engine, "GLTF_ROOT");

          for (var j = 0; j < nodes.length; j++) {
            rootEntity.addChild(entities[nodes[j]]);
          }

          sceneRoots[i] = rootEntity;
        }
      }

      context.sceneRoots = sceneRoots;
      context.defaultSceneRoot = sceneRoots[sceneID];
    };

    return EntityParser;
  }(Parser$1);

  EntityParser._defaultName = "_GLTF_ENTITY_";

  var MaterialParser = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(MaterialParser, _Parser);

    function MaterialParser() {
      return _Parser.apply(this, arguments) || this;
    }
    /** @internal */


    MaterialParser._parseTextureTransform = function _parseTextureTransform(material, extensions, context) {
      if (extensions === void 0) {
        extensions = {};
      }

      var schema = extensions.KHR_texture_transform;

      if (schema) {
        Parser$1.parseEngineResource("KHR_texture_transform", schema, material, context);
      }
    };

    var _proto = MaterialParser.prototype;

    _proto.parse = function parse(context) {
      var gltf = context.gltf,
          engine = context.engine,
          textures = context.textures;
      if (!gltf.materials) return;
      var materials = [];

      for (var i = 0; i < gltf.materials.length; i++) {
        var _gltf$materials$i = gltf.materials[i],
            _gltf$materials$i$ext = _gltf$materials$i.extensions,
            extensions = _gltf$materials$i$ext === void 0 ? {} : _gltf$materials$i$ext,
            pbrMetallicRoughness = _gltf$materials$i.pbrMetallicRoughness,
            normalTexture = _gltf$materials$i.normalTexture,
            occlusionTexture = _gltf$materials$i.occlusionTexture,
            emissiveTexture = _gltf$materials$i.emissiveTexture,
            emissiveFactor = _gltf$materials$i.emissiveFactor,
            alphaMode = _gltf$materials$i.alphaMode,
            alphaCutoff = _gltf$materials$i.alphaCutoff,
            doubleSided = _gltf$materials$i.doubleSided,
            _gltf$materials$i$nam = _gltf$materials$i.name,
            name = _gltf$materials$i$nam === void 0 ? "" : _gltf$materials$i$nam;
        var KHR_materials_unlit = extensions.KHR_materials_unlit,
            KHR_materials_pbrSpecularGlossiness = extensions.KHR_materials_pbrSpecularGlossiness;
        var material = null;

        if (KHR_materials_unlit) {
          material = Parser$1.createEngineResource("KHR_materials_unlit", KHR_materials_unlit, context);
        } else if (KHR_materials_pbrSpecularGlossiness) {
          material = Parser$1.createEngineResource("KHR_materials_pbrSpecularGlossiness", KHR_materials_pbrSpecularGlossiness, context);
        } else {
          material = new PBRMaterial(engine);
        }

        material.name = name;

        if (pbrMetallicRoughness) {
          var baseColorFactor = pbrMetallicRoughness.baseColorFactor,
              baseColorTexture = pbrMetallicRoughness.baseColorTexture,
              metallicFactor = pbrMetallicRoughness.metallicFactor,
              roughnessFactor = pbrMetallicRoughness.roughnessFactor,
              metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;

          if (baseColorFactor) {
            material.baseColor = _construct(Color, baseColorFactor);
          }

          if (baseColorTexture) {
            material.baseTexture = textures[baseColorTexture.index];

            MaterialParser._parseTextureTransform(material, baseColorTexture.extensions, context);
          }

          if (!KHR_materials_unlit && !KHR_materials_pbrSpecularGlossiness) {
            var m = material;
            m.metallic = metallicFactor != null ? metallicFactor : 1;
            m.roughness = roughnessFactor != null ? roughnessFactor : 1;

            if (metallicRoughnessTexture) {
              m.roughnessMetallicTexture = textures[metallicRoughnessTexture.index];

              MaterialParser._parseTextureTransform(material, metallicRoughnessTexture.extensions, context);
            }
          }
        }

        if (!KHR_materials_unlit) {
          var _m = material;

          if (emissiveTexture) {
            _m.emissiveTexture = textures[emissiveTexture.index];

            MaterialParser._parseTextureTransform(material, emissiveTexture.extensions, context);
          }

          if (emissiveFactor) {
            _m.emissiveColor = _construct(Color, emissiveFactor);
          }

          if (normalTexture) {
            var index = normalTexture.index,
                scale = normalTexture.scale;
            _m.normalTexture = textures[index];

            MaterialParser._parseTextureTransform(material, normalTexture.extensions, context);

            if (scale !== undefined) {
              _m.normalTextureIntensity = scale;
            }
          }

          if (occlusionTexture) {
            var _index = occlusionTexture.index,
                strength = occlusionTexture.strength;
            _m.occlusionTexture = textures[_index];

            MaterialParser._parseTextureTransform(material, occlusionTexture.extensions, context);

            if (strength !== undefined) {
              _m.occlusionTextureIntensity = strength;
            }
          }
        }

        if (doubleSided) {
          material.renderFace = exports.RenderFace.Double;
        } else {
          material.renderFace = exports.RenderFace.Front;
        }

        switch (alphaMode) {
          case MaterialAlphaMode.OPAQUE:
            material.isTransparent = false;
            break;

          case MaterialAlphaMode.BLEND:
            material.isTransparent = true;
            break;

          case MaterialAlphaMode.MASK:
            material.alphaCutoff = alphaCutoff != null ? alphaCutoff : 0.5;
            break;
        }

        materials[i] = material;
      }

      context.materials = materials;
    };

    return MaterialParser;
  }(Parser$1);

  var MeshParser = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(MeshParser, _Parser);

    function MeshParser() {
      return _Parser.apply(this, arguments) || this;
    }

    var _proto = MeshParser.prototype;

    _proto.parse = function parse(context) {
      var _this = this;

      var engine = context.engine,
          gltf = context.gltf,
          buffers = context.buffers;
      if (!gltf.meshes) return;
      var meshPromises = [];

      var _loop = function _loop(i) {
        var gltfMesh = gltf.meshes[i];
        var primitivePromises = [];

        var _loop2 = function _loop2(j) {
          var gltfPrimitive = gltfMesh.primitives[j];
          var _gltfPrimitive$extens = gltfPrimitive.extensions,
              extensions = _gltfPrimitive$extens === void 0 ? {} : _gltfPrimitive$extens;
          var KHR_draco_mesh_compression = extensions.KHR_draco_mesh_compression;
          primitivePromises.push(new Promise(function (resolve) {
            var mesh = new ModelMesh(engine, gltfMesh.name || j + "");

            if (KHR_draco_mesh_compression) {
              Parser$1.createEngineResource("KHR_draco_mesh_compression", KHR_draco_mesh_compression, context, gltfPrimitive).then(function (decodedGeometry) {
                return _this._parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, function (attributeSemantic) {
                  for (var _j = 0; _j < decodedGeometry.attributes.length; _j++) {
                    if (decodedGeometry.attributes[_j].name === attributeSemantic) {
                      return decodedGeometry.attributes[_j].array;
                    }
                  }

                  return null;
                }, function (attributeSemantic, shapeIndex) {
                  throw "BlendShape animation is not supported when using draco.";
                }, function () {
                  return decodedGeometry.index.array;
                }, engine);
              }).then(resolve);
            } else {
              _this._parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, function (attributeSemantic) {
                var accessorIdx = gltfPrimitive.attributes[attributeSemantic];
                var accessor = gltf.accessors[accessorIdx];
                return GLTFUtil.getAccessorData(gltf, accessor, buffers);
              }, function (attributeName, shapeIndex) {
                var shapeAccessorIdx = gltfPrimitive.targets[shapeIndex];
                var attributeAccessorIdx = shapeAccessorIdx[attributeName];

                if (attributeAccessorIdx) {
                  var accessor = gltf.accessors[attributeAccessorIdx];
                  return GLTFUtil.getAccessorData(gltf, accessor, buffers);
                } else {
                  return null;
                }
              }, function () {
                var indexAccessor = gltf.accessors[gltfPrimitive.indices];
                return GLTFUtil.getAccessorData(gltf, indexAccessor, buffers);
              }, engine).then(resolve);
            }
          }));
        };

        for (var j = 0; j < gltfMesh.primitives.length; j++) {
          _loop2(j);
        }

        meshPromises.push(Promise.all(primitivePromises));
      };

      for (var i = 0; i < gltf.meshes.length; i++) {
        _loop(i);
      }

      return Promise.all(meshPromises).then(function (meshes) {
        context.meshes = meshes;
      });
    };

    _proto._parseMeshFromGLTFPrimitive = function _parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, getVertexBufferData, getBlendShapeData, getIndexBufferData, engine) {
      var attributes = gltfPrimitive.attributes,
          targets = gltfPrimitive.targets,
          indices = gltfPrimitive.indices,
          mode = gltfPrimitive.mode;
      var vertexCount;
      var accessor = gltf.accessors[attributes["POSITION"]];
      var positionBuffer = getVertexBufferData("POSITION");
      var positions = GLTFUtil.floatBufferToVector3Array(positionBuffer);
      mesh.setPositions(positions);
      var bounds = mesh.bounds;
      vertexCount = accessor.count;

      if (accessor.min && accessor.max) {
        bounds.min.setValueByArray(accessor.min);
        bounds.max.setValueByArray(accessor.max);
      } else {
        var position = MeshParser._tempVector3;
        var min = bounds.min,
            max = bounds.max;
        min.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        max.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        var stride = positionBuffer.length / vertexCount;

        for (var j = 0; j < vertexCount; j++) {
          var offset = j * stride;
          position.setValueByArray(positionBuffer, offset);
          Vector3.min(min, position, min);
          Vector3.max(max, position, max);
        }
      }

      for (var attributeSemantic in attributes) {
        if (attributeSemantic === "POSITION") {
          continue;
        }

        var bufferData = getVertexBufferData(attributeSemantic);

        switch (attributeSemantic) {
          case "NORMAL":
            var normals = GLTFUtil.floatBufferToVector3Array(bufferData);
            mesh.setNormals(normals);
            break;

          case "TANGENT":
            var tangents = GLTFUtil.floatBufferToVector4Array(bufferData);
            mesh.setTangents(tangents);
            break;

          case "TEXCOORD_0":
            var texturecoords = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords, 0);
            break;

          case "JOINTS_0":
            var joints = GLTFUtil.floatBufferToVector4Array(bufferData);
            mesh.setBoneIndices(joints);
            break;

          case "WEIGHTS_0":
            var weights = GLTFUtil.floatBufferToVector4Array(bufferData);
            mesh.setBoneWeights(weights);
            break;
        }
      } // Indices


      if (indices !== undefined) {
        var indexAccessor = gltf.accessors[indices];
        var indexData = getIndexBufferData();
        mesh.setIndices(indexData);
        mesh.addSubMesh(0, indexAccessor.count, mode);
      } else {
        mesh.addSubMesh(0, vertexCount, mode);
      } // BlendShapes


      targets && this._createBlendShape(mesh, gltfMesh, targets, getBlendShapeData);
      mesh.uploadData(true);
      return Promise.resolve(mesh);
    };

    _proto._createBlendShape = function _createBlendShape(mesh, glTFMesh, glTFTargets, getBlendShapeData) {
      var blendShapeNames = glTFMesh.extras ? glTFMesh.extras.targetNames : null;

      for (var i = 0, n = glTFTargets.length; i < n; i++) {
        var _name = blendShapeNames ? blendShapeNames[i] : "blendShape" + i;

        var deltaPosBuffer = getBlendShapeData("POSITION", i);
        var deltaNorBuffer = getBlendShapeData("NORMAL", i);
        var deltaTanBuffer = getBlendShapeData("TANGENT", i);
        var deltaPositions = deltaPosBuffer ? GLTFUtil.floatBufferToVector3Array(deltaPosBuffer) : null;
        var deltaNormals = deltaNorBuffer ? GLTFUtil.floatBufferToVector3Array(deltaNorBuffer) : null;
        var deltaTangents = deltaTanBuffer ? GLTFUtil.floatBufferToVector3Array(deltaTanBuffer) : null;
        var blendShape = new BlendShape(_name);
        blendShape.addFrame(1.0, deltaPositions, deltaNormals, deltaTangents);
        mesh.addBlendShape(blendShape);
      }
    };

    return MeshParser;
  }(Parser$1);

  MeshParser._tempVector3 = new Vector3();

  var SceneParser = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(SceneParser, _Parser);

    function SceneParser() {
      return _Parser.apply(this, arguments) || this;
    }

    SceneParser._getDefaultMaterial = function _getDefaultMaterial(engine) {
      if (!SceneParser._defaultMaterial) {
        SceneParser._defaultMaterial = new BlinnPhongMaterial(engine);
      }

      return SceneParser._defaultMaterial;
    };

    var _proto = SceneParser.prototype;

    _proto.parse = function parse(context) {
      var _context$gltf = context.gltf,
          nodes = _context$gltf.nodes,
          gltfCameras = _context$gltf.cameras,
          entities = context.entities;
      if (!nodes) return;

      for (var i = 0; i < nodes.length; i++) {
        var gltfNode = nodes[i];
        var cameraID = gltfNode.camera,
            meshID = gltfNode.mesh,
            _gltfNode$extensions = gltfNode.extensions,
            extensions = _gltfNode$extensions === void 0 ? {} : _gltfNode$extensions;
        var KHR_lights_punctual = extensions.KHR_lights_punctual;
        var entity = entities[i];

        if (cameraID !== undefined) {
          this._createCamera(context, gltfCameras[cameraID], entity);
        }

        if (meshID !== undefined) {
          this._createRenderer(context, gltfNode, entity);
        }

        if (KHR_lights_punctual) {
          var lightIndex = KHR_lights_punctual.light;
          var lights = context.gltf.extensions.KHR_lights_punctual.lights;
          Parser$1.parseEngineResource("KHR_lights_punctual", lights[lightIndex], entity, context);
        }
      }

      if (context.defaultSceneRoot) {
        this._createAnimator(context);
      }
    };

    _proto._createCamera = function _createCamera(context, cameraSchema, entity) {
      var orthographic = cameraSchema.orthographic,
          perspective = cameraSchema.perspective,
          type = cameraSchema.type;
      var camera = entity.addComponent(Camera);

      if (type === CameraType.ORTHOGRAPHIC) {
        var xmag = orthographic.xmag,
            ymag = orthographic.ymag,
            zfar = orthographic.zfar,
            znear = orthographic.znear;
        camera.isOrthographic = true;

        if (znear !== undefined) {
          camera.nearClipPlane = znear;
        }

        if (zfar !== undefined) {
          camera.farClipPlane = zfar;
        }

        camera.orthographicSize = Math.max(ymag != null ? ymag : 0, xmag != null ? xmag : 0) / 2;
      } else if (type === CameraType.PERSPECTIVE) {
        var aspectRatio = perspective.aspectRatio,
            yfov = perspective.yfov,
            _zfar = perspective.zfar,
            _znear = perspective.znear;

        if (aspectRatio !== undefined) {
          camera.aspectRatio = aspectRatio;
        }

        if (yfov !== undefined) {
          camera.fieldOfView = yfov * 180 / Math.PI;
        }

        if (_zfar !== undefined) {
          camera.farClipPlane = _zfar;
        }

        if (_znear !== undefined) {
          camera.nearClipPlane = _znear;
        }
      }

      if (!context.cameras) context.cameras = [];
      context.cameras.push(camera); // @todo: use engine camera by default

      camera.enabled = false;
    };

    _proto._createRenderer = function _createRenderer(context, gltfNode, entity) {
      var engine = context.engine,
          gltfMeshes = context.gltf.meshes,
          meshes = context.meshes,
          materials = context.materials,
          skins = context.skins;
      var meshID = gltfNode.mesh,
          skinID = gltfNode.skin;
      var glTFMesh = gltfMeshes[meshID];
      var gltfMeshPrimitives = glTFMesh.primitives;
      var blendShapeWeights = gltfNode.weights || glTFMesh.weights;

      for (var i = 0; i < gltfMeshPrimitives.length; i++) {
        var mesh = meshes[meshID][i];
        var renderer = void 0;

        if (skinID !== undefined || blendShapeWeights) {
          var skinRenderer = entity.addComponent(SkinnedMeshRenderer);
          skinRenderer.mesh = mesh;

          if (skinID !== undefined) {
            skinRenderer.skin = skins[skinID];
          }

          if (blendShapeWeights) {
            skinRenderer.blendShapeWeights = new Float32Array(blendShapeWeights);
          }

          renderer = skinRenderer;
        } else {
          renderer = entity.addComponent(MeshRenderer);
          renderer.mesh = mesh;
        }

        var materialIndex = gltfMeshPrimitives[i].material;

        var material = (materials === null || materials === void 0 ? void 0 : materials[materialIndex]) || SceneParser._getDefaultMaterial(engine);

        renderer.setMaterial(material);
        var _gltfMeshPrimitives$i = gltfMeshPrimitives[i].extensions,
            extensions = _gltfMeshPrimitives$i === void 0 ? {} : _gltfMeshPrimitives$i;
        var KHR_materials_variants = extensions.KHR_materials_variants;

        if (KHR_materials_variants) {
          Parser$1.parseEngineResource("KHR_materials_variants", KHR_materials_variants, renderer, context);
        }
      }
    };

    _proto._createAnimator = function _createAnimator(context) {
      var defaultSceneRoot = context.defaultSceneRoot,
          animations = context.animations;
      if (!animations) return;
      var animator = defaultSceneRoot.addComponent(Animator);
      var animatorController = new AnimatorController();
      var layer = new AnimatorControllerLayer("layer");
      var animatorStateMachine = new AnimatorStateMachine();
      animatorController.addLayer(layer);
      animator.animatorController = animatorController;
      layer.stateMachine = animatorStateMachine;

      if (animations) {
        for (var i = 0; i < animations.length; i++) {
          var animationClip = animations[i];
          var name = animationClip.name;
          var uniqueName = animatorStateMachine.makeUniqueStateName(name);

          if (uniqueName !== name) {
            console.warn("AnimatorState name is existed, name: " + name + " reset to " + uniqueName);
          }

          var animatorState = animatorStateMachine.addState(uniqueName);
          animatorState.clip = animationClip;
        }
      }
    };

    return SceneParser;
  }(Parser$1);

  SceneParser._defaultMaterial = void 0;

  var SkinParser = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(SkinParser, _Parser);

    function SkinParser() {
      return _Parser.apply(this, arguments) || this;
    }

    var _proto = SkinParser.prototype;

    _proto.parse = function parse(context) {
      var gltf = context.gltf,
          buffers = context.buffers,
          entities = context.entities,
          defaultSceneRoot = context.defaultSceneRoot;
      var gltfSkins = gltf.skins;
      if (!gltfSkins) return;
      var skins = [];

      for (var i = 0; i < gltfSkins.length; i++) {
        var _gltfSkins$i = gltfSkins[i],
            inverseBindMatrices = _gltfSkins$i.inverseBindMatrices,
            skeleton = _gltfSkins$i.skeleton,
            joints = _gltfSkins$i.joints,
            _gltfSkins$i$name = _gltfSkins$i.name,
            name = _gltfSkins$i$name === void 0 ? "SKIN_" + i : _gltfSkins$i$name;
        var jointCount = joints.length;
        var skin = new Skin(name);
        skin.inverseBindMatrices.length = jointCount; // parse IBM

        var accessor = gltf.accessors[inverseBindMatrices];
        var buffer = GLTFUtil.getAccessorData(gltf, accessor, buffers);

        for (var _i = 0; _i < jointCount; _i++) {
          var inverseBindMatrix = new Matrix();
          inverseBindMatrix.setValueByArray(buffer, _i * 16);
          skin.inverseBindMatrices[_i] = inverseBindMatrix;
        } // get joints


        for (var _i2 = 0; _i2 < jointCount; _i2++) {
          skin.joints[_i2] = entities[joints[_i2]].name;
        } // get skeleton


        if (skeleton !== undefined) {
          skin.skeleton = entities[skeleton].name;
        } else {
          skin.skeleton = defaultSceneRoot.name;
        }

        skins[i] = skin;
      }

      context.skins = skins;
    };

    return SkinParser;
  }(Parser$1);

  var TextureParser = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(TextureParser, _Parser);

    function TextureParser() {
      return _Parser.apply(this, arguments) || this;
    }

    var _proto = TextureParser.prototype;

    _proto.parse = function parse(context) {
      var _this = this;

      var gltf = context.gltf,
          buffers = context.buffers,
          engine = context.engine,
          url = context.url;

      if (gltf.textures) {
        return Promise.all(gltf.textures.map(function (_ref, index) {
          var sampler = _ref.sampler,
              _ref$source = _ref.source,
              source = _ref$source === void 0 ? 0 : _ref$source,
              textureName = _ref.name;
          var _gltf$images$source = gltf.images[source],
              uri = _gltf$images$source.uri,
              bufferViewIndex = _gltf$images$source.bufferView,
              mimeType = _gltf$images$source.mimeType,
              imageName = _gltf$images$source.name;

          if (uri) {
            return engine.resourceManager.load({
              url: GLTFUtil.parseRelativeUrl(url, uri),
              type: exports.AssetType.Texture2D
            }).then(function (texture) {
              if (!texture.name) {
                texture.name = textureName || imageName || "texture_" + index;
              }

              if (sampler !== undefined) {
                _this._parseSampler(texture, gltf.samplers[sampler]);
              }

              return texture;
            });
          } else {
            var bufferView = gltf.bufferViews[bufferViewIndex];
            var bufferViewData = GLTFUtil.getBufferViewData(bufferView, buffers);
            return GLTFUtil.loadImageBuffer(bufferViewData, mimeType).then(function (image) {
              var texture = new Texture2D(engine, image.width, image.height);
              texture.setImageSource(image);
              texture.generateMipmaps();
              texture.name = textureName || imageName || "texture_" + index;

              if (sampler !== undefined) {
                _this._parseSampler(texture, gltf.samplers[sampler]);
              }

              return texture;
            });
          }
        })).then(function (textures) {
          context.textures = textures;
        });
      }
    };

    _proto._parseSampler = function _parseSampler(texture, sampler) {
      var magFilter = sampler.magFilter,
          minFilter = sampler.minFilter,
          wrapS = sampler.wrapS,
          wrapT = sampler.wrapT;

      if (magFilter || minFilter) {
        Logger.warn("texture use filterMode in engine");
      }

      if (wrapS) {
        texture.wrapModeU = TextureParser._wrapMap[wrapS];
      }

      if (wrapT) {
        texture.wrapModeV = TextureParser._wrapMap[wrapT];
      }
    };

    return TextureParser;
  }(Parser$1);

  TextureParser._wrapMap = {
    33071: exports.TextureWrapMode.Clamp,
    33648: exports.TextureWrapMode.Mirror,
    10497: exports.TextureWrapMode.Repeat
  };

  var Validator = /*#__PURE__*/function (_Parser) {
    _inheritsLoose(Validator, _Parser);

    function Validator() {
      return _Parser.apply(this, arguments) || this;
    }

    var _proto = Validator.prototype;

    _proto.parse = function parse(context) {
      var _context$gltf = context.gltf,
          version = _context$gltf.asset.version,
          extensionsUsed = _context$gltf.extensionsUsed,
          extensionsRequired = _context$gltf.extensionsRequired;
      var gltfVersion = Number(version);

      if (!(gltfVersion >= 2 && gltfVersion < 3)) {
        throw "Only support gltf 2.x.";
      }

      if (extensionsUsed) {
        Logger.info("extensionsUsed: ", extensionsUsed);

        for (var i = 0; i < extensionsUsed.length; i++) {
          if (!Parser$1.hasExtensionParser(extensionsUsed[i])) {
            Logger.warn("Extension " + extensionsUsed[i] + " is not implemented, you can customize this extension in gltf.");
          }
        }
      }

      if (extensionsRequired) {
        Logger.info("extensionsRequired: " + extensionsRequired);

        for (var _i = 0; _i < extensionsRequired.length; _i++) {
          var extensionRequired = extensionsRequired[_i];

          if (!Parser$1.hasExtensionParser(extensionRequired)) {
            Logger.error("GLTF parser has not supported required extension " + extensionRequired + ".");
          } else {
            Parser$1.initialize(extensionRequired);
          }
        }
      }
    };

    return Validator;
  }(Parser$1);

  var GLTFParser = /*#__PURE__*/function () {
    function GLTFParser(pipes) {
      var _this = this;

      this._pipes = [];
      pipes.forEach(function (pipe, index) {
        _this._pipes[index] = new pipe();
      });
    }

    var _proto = GLTFParser.prototype;

    _proto.parse = function parse(context) {
      var _this2 = this;

      var lastPipe;
      return new Promise(function (resolve, reject) {
        _this2._pipes.forEach(function (parser) {
          if (lastPipe) {
            lastPipe = lastPipe.then(function () {
              return parser.parse(context);
            });
          } else {
            lastPipe = parser.parse(context);
          }
        });

        if (lastPipe) {
          lastPipe.then(function () {
            resolve(context);
          }).catch(reject);
        } else {
          resolve(context);
        }
      });
    };

    return GLTFParser;
  }();

  GLTFParser.instance = new GLTFParser([BufferParser, Validator, TextureParser, MaterialParser, MeshParser, EntityParser, SkinParser, AnimationParser, SceneParser]);
  /**
   * Product after GLTF parser, usually, `defaultSceneRoot` is only needed to use.
   */

  var GLTFResource$1 = /*#__PURE__*/function (_EngineObject) {
    _inheritsLoose(GLTFResource, _EngineObject);

    function GLTFResource() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _EngineObject.call.apply(_EngineObject, [this].concat(args)) || this;
      _this.url = void 0;
      _this.gltf = void 0;
      _this.buffers = void 0;
      _this.textures = void 0;
      _this.materials = void 0;
      _this.meshes = void 0;
      _this.skins = void 0;
      _this.animations = void 0;
      _this.entities = void 0;
      _this.cameras = void 0;
      _this.lights = void 0;
      _this.sceneRoots = void 0;
      _this.defaultSceneRoot = void 0;
      _this.variants = void 0;
      return _this;
    }

    return GLTFResource;
  }(EngineObject);

  var _dec$i, _class$i;

  _dec$i = resourceLoader(exports.AssetType.Prefab, ["gltf", "glb"]), _dec$i(_class$i = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(GLTFLoader, _Loader);

    function GLTFLoader() {
      return _Loader.apply(this, arguments) || this;
    }

    var _proto = GLTFLoader.prototype;

    _proto.load = function load(item, resourceManager) {
      var url = item.url;
      return new AssetPromise(function (resolve, reject) {
        var resource = new GLTFResource$1(resourceManager.engine);
        resource.url = url;
        GLTFParser.instance.parse(resource).then(resolve).catch(function (e) {
          console.error(e);
          reject("Error loading glTF model from " + url + " .");
        });
      });
    };

    return GLTFLoader;
  }(Loader)) || _class$i;

  var _dec$h, _class$h;

  _dec$h = resourceLoader(exports.AssetType.JSON, ["json"], false), _dec$h(_class$h = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(JSONLoader, _Loader);

    function JSONLoader() {
      return _Loader.apply(this, arguments) || this;
    }

    var _proto = JSONLoader.prototype;

    _proto.load = function load(item) {
      return this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
        type: "json"
      }));
    };

    return JSONLoader;
  }(Loader)) || _class$h;
  /**
   *
   * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts
   */

  var HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)
  // load types

  var COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()

  function getMipmaps(ktxContainer, loadMipmaps) {
    var mipmaps = []; // initialize width & height for level 1

    var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;
    var width = ktxContainer.pixelWidth;
    var height = ktxContainer.pixelHeight;
    var mipmapCount = loadMipmaps ? ktxContainer.numberOfMipmapLevels : 1;

    for (var level = 0; level < mipmapCount; level++) {
      var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps

      dataOffset += 4; // size of the image + 4 for the imageSize field

      for (var face = 0; face < ktxContainer.numberOfFaces; face++) {
        var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);
        mipmaps.push({
          data: byteArray,
          width: width,
          height: height
        });
        dataOffset += imageSize;
        dataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image
      }

      width = Math.max(1.0, width * 0.5);
      height = Math.max(1.0, height * 0.5);
    }

    return mipmaps;
  }
  /**
   * Checks if the given data starts with a KTX file identifier.
   * @param data the data to check
   * @returns true if the data is a KTX file or false otherwise
   */


  function isValid(data) {
    if (data.byteLength >= 12) {
      // '«', 'K', 'T', 'X', ' ', '1', '1', '»', '\r', '\n', '\x1A', '\n'
      var identifier = new Uint8Array(data, 0, 12);

      if (identifier[0] === 0xab && identifier[1] === 0x4b && identifier[2] === 0x54 && identifier[3] === 0x58 && identifier[4] === 0x20 && identifier[5] === 0x31 && identifier[6] === 0x31 && identifier[7] === 0xbb && identifier[8] === 0x0d && identifier[9] === 0x0a && identifier[10] === 0x1a && identifier[11] === 0x0a) {
        return true;
      }
    }

    return false;
  }

  function getEngineFormat(internalFormat) {
    switch (internalFormat) {
      // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT3_EXT:
      // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
      // break;
      case exports.GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:
        return exports.TextureFormat.DXT1;

      case exports.GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
        return exports.TextureFormat.DXT5;

      case exports.GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:
        return exports.TextureFormat.ETC1_RGB;

      case exports.GLCompressedTextureInternalFormat.RGB8_ETC2:
        return exports.TextureFormat.ETC2_RGB;

      case exports.GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
        return exports.TextureFormat.ETC2_RGBA5;

      case exports.GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:
        return exports.TextureFormat.ETC2_RGBA8;

      case exports.GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:
        return exports.TextureFormat.PVRTC_RGB2;

      case exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:
        return exports.TextureFormat.PVRTC_RGBA2;

      case exports.GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:
        return exports.TextureFormat.PVRTC_RGB4;

      case exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:
        return exports.TextureFormat.PVRTC_RGBA4;

      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:
        return exports.TextureFormat.ASTC_4x4;

      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:
        return exports.TextureFormat.ASTC_5x5;

      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:
        return exports.TextureFormat.ASTC_6x6;

      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:
        return exports.TextureFormat.ASTC_8x8;

      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:
        return exports.TextureFormat.ASTC_10x10;

      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:
        return exports.TextureFormat.ASTC_12x12;

      default:
        var formatName = exports.GLCompressedTextureInternalFormat[internalFormat];
        throw new Error("this format is not supported in Oasis Engine: " + formatName);
    }
  }
  /**
   * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
   * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
   */


  var khronosTextureContainerParser = {
    /**
     *
     * @param buffer contents of the KTX container file
     * @param facesExpected should be either 1 or 6, based whether a cube texture or or
     * @param threeDExpected provision for indicating that data should be a 3D texture, not implemented
     * @param textureArrayExpected provision for indicating that data should be a texture array, not implemented
     * @param mapEngineFormat get Oasis Engine native TextureFormat?
     */
    parse: function parse(buffer, facesExpected, withMipmaps, mapEngineFormat) {
      if (mapEngineFormat === void 0) {
        mapEngineFormat = false;
      }

      if (!isValid(buffer)) {
        throw new Error("khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier");
      } // load the reset of the header in native 32 bit uint


      var dataSize = Uint32Array.BYTES_PER_ELEMENT;
      var headerDataView = new DataView(buffer, 12, 13 * dataSize);
      var endianness = headerDataView.getUint32(0, true);
      var littleEndian = endianness === 0x04030201;
      var parsedResult = {
        buffer: buffer,
        glType: headerDataView.getUint32(1 * dataSize, littleEndian),
        // must be 0 for compressed textures
        glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian),
        // must be 1 for compressed textures
        glFormat: headerDataView.getUint32(3 * dataSize, littleEndian),
        // must be 0 for compressed textures
        glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian),
        // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)
        glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian),
        // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)
        pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian),
        // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)
        pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian),
        // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)
        pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian),
        // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)
        numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian),
        // used for texture arrays
        numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian),
        // used for cubemap textures, should either be 1 or 6
        numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian),
        // number of levels; disregard possibility of 0 for compressed textures
        bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian),
        // the amount of space after the header for meta-data
        // would need to make this more elaborate & adjust checks above to support more than one load type
        loadType: COMPRESSED_2D
      }; // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.

      if (parsedResult.glType !== 0) {
        throw new Error("only compressed formats currently supported");
      } else {
        // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
        parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);
      }

      if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {
        throw new Error("only 2D textures currently supported");
      }

      if (parsedResult.numberOfArrayElements !== 0) {
        throw new Error("texture arrays not currently supported");
      }

      if (parsedResult.numberOfFaces !== facesExpected) {
        throw new Error("number of faces expected" + facesExpected + ", but found " + parsedResult.numberOfFaces);
      }

      if (withMipmaps) {
        parsedResult.mipmaps = getMipmaps(parsedResult, true);
      }

      if (mapEngineFormat) {
        parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);
      }

      return parsedResult;
    }
  };

  function parseSingleKTX(data) {
    var ktx = khronosTextureContainerParser.parse(data, 1, true, true);
    return {
      mipmaps: ktx.mipmaps,
      engineFormat: ktx.engineFormat,
      internalFormat: ktx.glInternalFormat,
      width: ktx.pixelWidth,
      height: ktx.pixelHeight
    };
  }

  function parseCubeKTX(dataArray) {
    var mipmapsFaces = [];
    var internalFormat;
    var engineFormat;
    var width;
    var height;

    for (var i = 0; i < dataArray.length; i++) {
      var ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);
      mipmapsFaces.push(ktx.mipmaps);

      if (i === 0) {
        width = ktx.pixelWidth;
        height = ktx.pixelHeight;
        internalFormat = ktx.glInternalFormat;
        engineFormat = ktx.engineFormat;
      }
    }

    return {
      mipmapsFaces: mipmapsFaces,
      engineFormat: engineFormat,
      internalFormat: internalFormat,
      width: width,
      height: height
    };
  }

  var _dec$g, _class$g;

  _dec$g = resourceLoader(exports.AssetType.KTXCube, []), _dec$g(_class$g = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(KTXCubeLoader, _Loader);

    function KTXCubeLoader() {
      return _Loader.apply(this, arguments) || this;
    }

    var _proto = KTXCubeLoader.prototype;

    _proto.load = function load(item, resourceManager) {
      var _this = this;

      return new AssetPromise(function (resolve, reject) {
        Promise.all(item.urls.map(function (url) {
          return _this.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
            type: "arraybuffer"
          }));
        })).then(function (data) {
          var parsedData = parseCubeKTX(data);
          var width = parsedData.width,
              mipmapsFaces = parsedData.mipmapsFaces,
              engineFormat = parsedData.engineFormat;
          var mipmap = mipmapsFaces[0].length > 1;
          var texture = new TextureCubeMap(resourceManager.engine, width, engineFormat, mipmap);

          for (var face = 0; face < 6; face++) {
            var length = mipmapsFaces[face].length;

            for (var miplevel = 0; miplevel < length; miplevel++) {
              var _mipmapsFaces$face$mi = mipmapsFaces[face][miplevel],
                  _data = _mipmapsFaces$face$mi.data,
                  _width = _mipmapsFaces$face$mi.width,
                  height = _mipmapsFaces$face$mi.height;
              texture.setPixelBuffer(exports.TextureCubeFace.PositiveX + face, _data, miplevel, 0, 0, _width, height);
            }
          }

          resolve(texture);
        }).catch(function (e) {
          reject(e);
        });
      });
    };

    return KTXCubeLoader;
  }(Loader)) || _class$g;

  var _dec$f, _class$f;

  _dec$f = resourceLoader(exports.AssetType.KTX, ["ktx"]), _dec$f(_class$f = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(KTXLoader, _Loader);

    function KTXLoader() {
      return _Loader.apply(this, arguments) || this;
    }

    var _proto = KTXLoader.prototype;

    _proto.load = function load(item, resourceManager) {
      var _this = this;

      return new AssetPromise(function (resolve, reject) {
        _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "arraybuffer"
        })).then(function (bin) {
          var parsedData = parseSingleKTX(bin);
          var width = parsedData.width,
              height = parsedData.height,
              mipmaps = parsedData.mipmaps,
              engineFormat = parsedData.engineFormat;
          var mipmap = mipmaps.length > 1;
          var texture = new Texture2D(resourceManager.engine, width, height, engineFormat, mipmap);

          for (var miplevel = 0; miplevel < mipmaps.length; miplevel++) {
            var _mipmaps$miplevel = mipmaps[miplevel],
                _width = _mipmaps$miplevel.width,
                _height = _mipmaps$miplevel.height,
                data = _mipmaps$miplevel.data;
            texture.setPixelBuffer(data, miplevel, 0, 0, _width, _height);
          }

          resolve(texture);
        }).catch(function (e) {
          reject(e);
        });
      });
    };

    return KTXLoader;
  }(Loader)) || _class$f;

  var _dec$e, _class$e;

  _dec$e = resourceLoader(exports.AssetType.Texture2D, ["png", "jpg", "webp", "jpeg"]), _dec$e(_class$e = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(Texture2DLoader, _Loader);

    function Texture2DLoader() {
      return _Loader.apply(this, arguments) || this;
    }

    var _proto = Texture2DLoader.prototype;

    _proto.load = function load(item, resourceManager) {
      var _this = this;

      return new AssetPromise(function (resolve, reject) {
        _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "image"
        })).then(function (image) {
          var texture = new Texture2D(resourceManager.engine, image.width, image.height);
          /** @ts-ignore */

          if (!texture._platformTexture) return;
          texture.setImageSource(image);
          texture.generateMipmaps();

          if (item.url.indexOf("data:") !== 0) {
            var splitPath = item.url.split("/");
            texture.name = splitPath[splitPath.length - 1];
          }

          resolve(texture);
        }).catch(function (e) {
          reject(e);
        });
      });
    };

    return Texture2DLoader;
  }(Loader)) || _class$e;

  var _dec$d, _class$d;

  _dec$d = resourceLoader(exports.AssetType.TextureCube, [""]), _dec$d(_class$d = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(TextureCubeLoader, _Loader);

    function TextureCubeLoader() {
      return _Loader.apply(this, arguments) || this;
    }

    var _proto = TextureCubeLoader.prototype;

    _proto.load = function load(item, resourceManager) {
      var _this = this;

      return new AssetPromise(function (resolve, reject) {
        Promise.all(item.urls.map(function (url) {
          return _this.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
            type: "image"
          }));
        })).then(function (images) {
          var _images$ = images[0],
              width = _images$.width,
              height = _images$.height;

          if (width !== height) {
            console.error("The cube texture must have the same width and height");
            return;
          }

          var tex = new TextureCubeMap(resourceManager.engine, width);
          /** @ts-ignore */

          if (!tex._platformTexture) return;

          for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
            tex.setImageSource(exports.TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
          }

          tex.generateMipmaps();
          resolve(tex);
        }).catch(function (e) {
          reject(e);
        });
      });
    };

    return TextureCubeLoader;
  }(Loader)) || _class$d;

  var _dec$c, _class$c;

  _dec$c = resourceLoader(exports.AssetType.SpriteAtlas, ["atlas"], false), _dec$c(_class$c = /*#__PURE__*/function (_Loader) {
    _inheritsLoose(SpriteAtlasLoader, _Loader);

    function SpriteAtlasLoader() {
      return _Loader.apply(this, arguments) || this;
    }

    var _proto = SpriteAtlasLoader.prototype;

    _proto.load = function load(item, resourceManager) {
      var _this = this;

      return new AssetPromise(function (resolve, reject) {
        _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "json"
        })).then(function (atlasData) {
          var atlasItems = atlasData.atlasItems,
              format = atlasData.format;
          var atlasItemsLen = atlasItems.length;
          Promise.all(atlasItems.map(function (_ref) {
            var img = _ref.img;
            return _this.request(GLTFUtil.parseRelativeUrl(item.url, img), _objectSpread2(_objectSpread2({}, item), {}, {
              type: "image"
            }));
          })).then(function (imgs) {
            var engine = resourceManager.engine; // Generate a SpriteAtlas object.

            var tempRect = new Rect();
            var tempVect2 = new Vector2();
            var spriteAtlas = new SpriteAtlas(engine);

            for (var i = 0; i < atlasItemsLen; i++) {
              // Generate Texture2D according to configuration.
              var originalImg = imgs[i];
              var width = originalImg.width,
                  height = originalImg.height;
              var texture = new Texture2D(engine, width, height, format);
              texture.setImageSource(originalImg);
              texture.generateMipmaps(); // Generate all the sprites on this texture.

              var atlasItem = atlasItems[i];
              var sprites = atlasItem.sprites;
              var sourceWidthReciprocal = 1.0 / width;
              var sourceHeightReciprocal = 1.0 / height;

              for (var j = sprites.length - 1; j >= 0; j--) {
                var atlasSprite = sprites[j];
                var region = atlasSprite.region,
                    pivot = atlasSprite.pivot,
                    atlasRegionOffset = atlasSprite.atlasRegionOffset,
                    atlasRegion = atlasSprite.atlasRegion,
                    id = atlasSprite.id;
                var sprite = new Sprite(engine, texture, region ? tempRect.setValue(region.x, region.y, region.w, region.h) : undefined, pivot ? tempVect2.setValue(pivot.x, pivot.y) : undefined, atlasSprite.pixelsPerUnit || undefined, atlasSprite.name);
                sprite.atlasRegion.setValue(atlasRegion.x * sourceWidthReciprocal, atlasRegion.y * sourceHeightReciprocal, atlasRegion.w * sourceWidthReciprocal, atlasRegion.h * sourceHeightReciprocal);
                atlasSprite.atlasRotated && (sprite.atlasRotated = true);

                if (atlasRegionOffset) {
                  var offsetLeft = atlasRegionOffset.x,
                      offsetTop = atlasRegionOffset.y,
                      offsetRight = atlasRegionOffset.z,
                      offsetBottom = atlasRegionOffset.w;
                  var originalWReciprocal = void 0,
                      originalHReciprocal = void 0;

                  if (atlasSprite.atlasRotated) {
                    originalWReciprocal = 1 / (offsetLeft + atlasRegion.h + offsetRight);
                    originalHReciprocal = 1 / (offsetTop + atlasRegion.w + offsetBottom);
                  } else {
                    originalWReciprocal = 1 / (offsetLeft + atlasRegion.w + offsetRight);
                    originalHReciprocal = 1 / (offsetTop + atlasRegion.h + offsetBottom);
                  }

                  sprite.atlasRegionOffset.setValue(offsetLeft * originalWReciprocal, offsetTop * originalHReciprocal, offsetRight * originalWReciprocal, offsetBottom * originalHReciprocal);
                }

                if (id !== undefined) {
                  // @ts-ignore
                  sprite._assetID = id;
                } // @ts-ignore


                spriteAtlas._addSprite(sprite);
              }
            }

            resolve(spriteAtlas);
          });
        }).catch(function (e) {
          reject(e);
        });
      });
    };

    return SpriteAtlasLoader;
  }(Loader)) || _class$c;

  var ExtensionParser = /*#__PURE__*/function () {
    function ExtensionParser() {}

    var _proto = ExtensionParser.prototype;

    _proto.initialize = function initialize() {};

    _proto.parseEngineResource = function parseEngineResource(schema, parseResource, context) {};

    _proto.createEngineResource = function createEngineResource(schema, context) {
      return null;
    };

    return ExtensionParser;
  }();

  var _dec$b, _class$b, _class2, _temp;

  _dec$b = registerExtension("KHR_draco_mesh_compression"), _dec$b(_class$b = (_temp = _class2 = /*#__PURE__*/function (_ExtensionParser) {
    _inheritsLoose(KHR_draco_mesh_compression, _ExtensionParser);

    function KHR_draco_mesh_compression() {
      return _ExtensionParser.apply(this, arguments) || this;
    }

    var _proto = KHR_draco_mesh_compression.prototype;

    _proto.initialize = function initialize() {
      if (!KHR_draco_mesh_compression._decoder) {
        KHR_draco_mesh_compression._decoder = new DRACODecoder();
      }
    };

    _proto.createEngineResource = function createEngineResource(schema, context, gltfPrimitive) {
      var gltf = context.gltf,
          buffers = context.buffers;
      var bufferViews = gltf.bufferViews,
          accessors = gltf.accessors;
      var bufferViewIndex = schema.bufferView,
          gltfAttributeMap = schema.attributes;
      var attributeMap = {};
      var attributeTypeMap = {};

      for (var attributeName in gltfAttributeMap) {
        attributeMap[attributeName] = gltfAttributeMap[attributeName];
      }

      for (var _attributeName in gltfPrimitive.attributes) {
        if (gltfAttributeMap[_attributeName] !== undefined) {
          var accessorDef = accessors[gltfPrimitive.attributes[_attributeName]];
          attributeTypeMap[_attributeName] = GLTFUtil.getComponentType(accessorDef.componentType).name;
        }
      }

      var indexAccessor = accessors[gltfPrimitive.indices];
      var indexType = GLTFUtil.getComponentType(indexAccessor.componentType).name;
      var taskConfig = {
        attributeIDs: attributeMap,
        attributeTypes: attributeTypeMap,
        useUniqueIDs: true,
        indexType: indexType
      };
      var buffer = GLTFUtil.getBufferViewData(bufferViews[bufferViewIndex], buffers);
      return KHR_draco_mesh_compression._decoder.decode(buffer, taskConfig).then(function (parsedGeometry) {
        return parsedGeometry;
      });
    };

    return KHR_draco_mesh_compression;
  }(ExtensionParser), _class2._decoder = void 0, _temp)) || _class$b;

  var _dec$a, _class$a;

  _dec$a = registerExtension("KHR_lights_punctual"), _dec$a(_class$a = /*#__PURE__*/function (_ExtensionParser) {
    _inheritsLoose(KHR_lights_punctual, _ExtensionParser);

    function KHR_lights_punctual() {
      return _ExtensionParser.apply(this, arguments) || this;
    }

    var _proto = KHR_lights_punctual.prototype;

    _proto.parseEngineResource = function parseEngineResource(schema, entity, context) {
      var color = schema.color,
          _schema$intensity = schema.intensity,
          intensity = _schema$intensity === void 0 ? 1 : _schema$intensity,
          type = schema.type,
          range = schema.range,
          spot = schema.spot;
      var light;

      if (type === "directional") {
        light = entity.addComponent(DirectLight);
      } else if (type === "point") {
        light = entity.addComponent(PointLight);
      } else if (type === "spot") {
        light = entity.addComponent(SpotLight);
      }

      if (color) {
        light.color.setValue(color[0], color[1], color[2], 1);
      }

      light.intensity = intensity;

      if (range && !(light instanceof DirectLight)) {
        light.distance = range;
      }

      if (spot && light instanceof SpotLight) {
        var _spot$innerConeAngle = spot.innerConeAngle,
            innerConeAngle = _spot$innerConeAngle === void 0 ? 0 : _spot$innerConeAngle,
            _spot$outerConeAngle = spot.outerConeAngle,
            outerConeAngle = _spot$outerConeAngle === void 0 ? Math.PI / 4 : _spot$outerConeAngle;
        light.angle = innerConeAngle;
        light.penumbra = outerConeAngle - innerConeAngle;
      }

      if (!context.lights) context.lights = [];
      context.lights.push(light);
    };

    return KHR_lights_punctual;
  }(ExtensionParser)) || _class$a;

  var _dec$9, _class$9;

  _dec$9 = registerExtension("KHR_materials_pbrSpecularGlossiness"), _dec$9(_class$9 = /*#__PURE__*/function (_ExtensionParser) {
    _inheritsLoose(KHR_materials_pbrSpecularGlossiness, _ExtensionParser);

    function KHR_materials_pbrSpecularGlossiness() {
      return _ExtensionParser.apply(this, arguments) || this;
    }

    var _proto = KHR_materials_pbrSpecularGlossiness.prototype;

    _proto.createEngineResource = function createEngineResource(schema, context) {
      var engine = context.engine,
          textures = context.textures;
      var material = new PBRSpecularMaterial(engine);
      var diffuseFactor = schema.diffuseFactor,
          diffuseTexture = schema.diffuseTexture,
          specularFactor = schema.specularFactor,
          glossinessFactor = schema.glossinessFactor,
          specularGlossinessTexture = schema.specularGlossinessTexture;

      if (diffuseFactor) {
        material.baseColor = _construct(Color, diffuseFactor);
      }

      if (diffuseTexture) {
        material.baseTexture = textures[diffuseTexture.index];

        MaterialParser._parseTextureTransform(material, diffuseTexture.extensions, context);
      }

      if (specularFactor) {
        material.specularColor = _construct(Color, specularFactor);
      }

      if (glossinessFactor !== undefined) {
        material.glossiness = glossinessFactor;
      }

      if (specularGlossinessTexture) {
        material.specularGlossinessTexture = textures[specularGlossinessTexture.index];

        MaterialParser._parseTextureTransform(material, specularGlossinessTexture.extensions, context);
      }

      return material;
    };

    return KHR_materials_pbrSpecularGlossiness;
  }(ExtensionParser)) || _class$9;

  var _dec$8, _class$8;

  _dec$8 = registerExtension("KHR_materials_unlit"), _dec$8(_class$8 = /*#__PURE__*/function (_ExtensionParser) {
    _inheritsLoose(KHR_materials_unlit, _ExtensionParser);

    function KHR_materials_unlit() {
      return _ExtensionParser.apply(this, arguments) || this;
    }

    var _proto = KHR_materials_unlit.prototype;

    _proto.createEngineResource = function createEngineResource(schema, context) {
      var engine = context.engine;
      var material = new UnlitMaterial(engine);
      return material;
    };

    return KHR_materials_unlit;
  }(ExtensionParser)) || _class$8;

  var _dec$7, _class$7;

  _dec$7 = registerExtension("KHR_materials_variants"), _dec$7(_class$7 = /*#__PURE__*/function (_ExtensionParser) {
    _inheritsLoose(KHR_materials_variants, _ExtensionParser);

    function KHR_materials_variants() {
      return _ExtensionParser.apply(this, arguments) || this;
    }

    var _proto = KHR_materials_variants.prototype;

    _proto.parseEngineResource = function parseEngineResource(schema, renderer, context) {
      var variantNames = context.gltf.extensions.KHR_materials_variants.variants,
          materials = context.materials;
      var mappings = schema.mappings;

      for (var i = 0; i < mappings.length; i++) {
        var _mappings$i = mappings[i],
            material = _mappings$i.material,
            variants = _mappings$i.variants;
        if (!context.variants) context.variants = [];
        context.variants.push({
          renderer: renderer,
          material: materials[material],
          variants: variants.map(function (index) {
            return variantNames[index].name;
          })
        });
      }
    };

    return KHR_materials_variants;
  }(ExtensionParser)) || _class$7;

  var _dec$6, _class$6;

  _dec$6 = registerExtension("KHR_mesh_quantization"), _dec$6(_class$6 = /*#__PURE__*/function (_ExtensionParser) {
    _inheritsLoose(KHR_mesh_quantization, _ExtensionParser);

    function KHR_mesh_quantization() {
      return _ExtensionParser.apply(this, arguments) || this;
    }

    return KHR_mesh_quantization;
  }(ExtensionParser)) || _class$6;

  var _dec$5, _class$5;

  _dec$5 = registerExtension("KHR_texture_transform"), _dec$5(_class$5 = /*#__PURE__*/function (_ExtensionParser) {
    _inheritsLoose(KHR_texture_transform, _ExtensionParser);

    function KHR_texture_transform() {
      return _ExtensionParser.apply(this, arguments) || this;
    }

    var _proto = KHR_texture_transform.prototype;

    _proto.parseEngineResource = function parseEngineResource(schema, material, context) {
      var offset = schema.offset,
          rotation = schema.rotation,
          scale = schema.scale,
          texCoord = schema.texCoord;

      if (offset) {
        material.tilingOffset.z = offset[0];
        material.tilingOffset.w = offset[1];
      }

      if (scale) {
        material.tilingOffset.x = scale[0];
        material.tilingOffset.y = scale[1];
      }

      if (rotation) {
        Logger.warn("rotation in KHR_texture_transform is not supported now");
      }

      if (texCoord) {
        Logger.warn("texCoord in KHR_texture_transform is not supported now");
      }
    };

    return KHR_texture_transform;
  }(ExtensionParser)) || _class$5;
  /**
   * @deprecated
   * Temporarily only for editor use.
   * Remove when editor finish change from gltf to prefab.
   */

  var GLTFModel = /*#__PURE__*/function (_Component) {
    _inheritsLoose(GLTFModel, _Component);

    function GLTFModel(entity) {
      var _this;

      _this = _Component.call(this, entity) || this;
      _this._animatorController = void 0;
      _this._speed = 1.0;
      _this._animator = void 0;
      _this._asset = void 0;
      _this._glTFEntity = void 0;
      _this._clipPreview = void 0;
      _this._hasBuiltNode = false;
      _this._controllerUpdateFlag = void 0;
      return _this;
    }
    /**
     * Init.
     * @param props - Init props
     */


    var _proto = GLTFModel.prototype;

    _proto.init = function init(props) {
      var _props$asset = props.asset,
          asset = _props$asset === void 0 ? null : _props$asset,
          speed = props.speed,
          animatorController = props.animatorController,
          clipPreview = props.clipPreview,
          isClone = props.isClone;

      if (isClone) {
        var rootName = props.gltfRootName;

        if (rootName) {
          this._glTFEntity = this.entity.findByName(rootName);
        }
      }

      if (!this._glTFEntity) {
        var _rootName = "GLTF-" + Date.now();

        props.gltfRootName = _rootName;
        this._glTFEntity = this.entity.createChild(_rootName);
        this._hasBuiltNode = false;
      } else {
        this._hasBuiltNode = true;
      }

      this.asset = asset;
      this.animatorController = animatorController;
      this.speed = speed;
      this.clipPreview = clipPreview;
    };

    _proto.update = function update() {
      if (this._animator) {
        var _this$_controllerUpda;

        if ((_this$_controllerUpda = this._controllerUpdateFlag) !== null && _this$_controllerUpda !== void 0 && _this$_controllerUpda.flag) {
          this._playState();
        }
      }
    }
    /**
     * @override
     */
    ;

    _proto._onEnable = function _onEnable() {
      this._glTFEntity && (this._glTFEntity.isActive = true);

      this.engine._componentsManager.addOnUpdateAnimations(this);
    }
    /**
     * @override
     */
    ;

    _proto._onDisable = function _onDisable() {
      this._glTFEntity && (this._glTFEntity.isActive = false);

      this.engine._componentsManager.removeOnUpdateAnimations(this);
    };

    _proto._playState = function _playState() {
      var playStateName = this._clipPreview;

      if (playStateName) {
        var _this$_controllerUpda2;

        this._animator.play(playStateName, 0);

        if ((_this$_controllerUpda2 = this._controllerUpdateFlag) !== null && _this$_controllerUpda2 !== void 0 && _this$_controllerUpda2.flag) {
          this._controllerUpdateFlag.flag = false;
        }
      } else {
        this._playDefaultState();
      }
    };

    _proto._playDefaultState = function _playDefaultState() {
      var animatorController = this._animatorController,
          animator = this._animator;
      if (!animator) return;

      if (animatorController) {
        var layers = animatorController.layers;

        for (var i = 0, length = layers.length; i < length; ++i) {
          var _layers$i$stateMachin, _layers$i, _layers$i$stateMachin2, _layers$i2, _layers$i2$stateMachi; //@ts-ignore


          var defaultState = (_layers$i$stateMachin = (_layers$i = layers[i]) === null || _layers$i === void 0 ? void 0 : (_layers$i$stateMachin2 = _layers$i.stateMachine) === null || _layers$i$stateMachin2 === void 0 ? void 0 : _layers$i$stateMachin2._defaultState) != null ? _layers$i$stateMachin : (_layers$i2 = layers[i]) === null || _layers$i2 === void 0 ? void 0 : (_layers$i2$stateMachi = _layers$i2.stateMachine) === null || _layers$i2$stateMachi === void 0 ? void 0 : _layers$i2$stateMachi.states[0];
          var defaultStateName = defaultState === null || defaultState === void 0 ? void 0 : defaultState.name;

          if (defaultStateName) {
            var _this$_controllerUpda3;

            animator.play(defaultStateName, i);

            if ((_this$_controllerUpda3 = this._controllerUpdateFlag) !== null && _this$_controllerUpda3 !== void 0 && _this$_controllerUpda3.flag) {
              this._controllerUpdateFlag.flag = false;
            }
          }
        }
      }
    };

    _createClass(GLTFModel, [{
      key: "asset",
      get: function get() {
        return this._asset;
      },
      set: function set(value) {
        var animatorController = this._animatorController,
            speed = this._speed;
        var entity = this._glTFEntity;

        if (value && value.defaultSceneRoot === this._glTFEntity) {
          return;
        }

        if (!this._hasBuiltNode) {
          entity.clearChildren();

          if (value !== null) {
            entity === null || entity === void 0 ? void 0 : entity.destroy();
            var gltfEntity = value.defaultSceneRoot.clone();
            this._animator = gltfEntity.getComponent(Animator);
            this.entity.addChild(gltfEntity);
            gltfEntity.isActive = this.enabled;
            this._glTFEntity = gltfEntity;
          }
        }

        if (animatorController) {
          this._animator.animatorController = animatorController;
          this._animator.speed = speed;

          this._playState();
        }

        this._asset = value;
      }
    }, {
      key: "animatorController",
      get: function get() {
        return this._animatorController;
      },
      set: function set(animatorController) {
        var animator = this._animator;

        if (animatorController !== this._animatorController) {
          this._controllerUpdateFlag && this._controllerUpdateFlag.destroy(); // @ts-ignore

          this._controllerUpdateFlag = animatorController && animatorController._registerChangeFlag();
          this._animatorController = animatorController;

          if (animator) {
            animator.animatorController = animatorController;

            this._playState();
          }
        }
      }
    }, {
      key: "speed",
      get: function get() {
        return this._speed;
      },
      set: function set(speed) {
        var animator = this._animator;
        this._speed = speed;

        if (animator) {
          animator.speed = speed;

          this._playState();
        }
      }
    }, {
      key: "animator",
      get: function get() {
        return this._animator;
      }
    }, {
      key: "clipPreview",
      get: function get() {
        return this._clipPreview;
      },
      set: function set(value) {
        if (this._animator) {
          if (value) {
            this._animator.play(value, 0);
          } else {
            this._playDefaultState();
          }
        }

        this._clipPreview = value;
      }
    }]);

    return GLTFModel;
  }(Component);

  var Model = /*#__PURE__*/function (_MeshRenderer) {
    _inheritsLoose(Model, _MeshRenderer);

    function Model(entity) {
      var _this;

      _this = _MeshRenderer.call(this, entity) || this;
      _this._props = null;

      _this.setMaterial(new BlinnPhongMaterial(_this.engine));

      return _this;
    }

    var _proto = Model.prototype;

    _proto.setProps = function setProps(props) {
      if (props === void 0) {
        props = {};
      }

      if (this._props !== props) {
        this._props = props;
      }

      switch (props.geometryType) {
        case "Sphere":
          this.mesh = PrimitiveMesh.createSphere(this._engine, props.sphereRadius, props.sphereSegments);
          break;

        case "Cylinder":
          this.mesh = PrimitiveMesh.createCylinder(this._engine, props.cylinderRadiusTop, props.cylinderRadiusBottom, props.cylinderHeight, props.cylinderRadialSegments, props.cylinderHeightSegments);
          break;

        case "Plane":
          this.mesh = PrimitiveMesh.createPlane(this._engine, props.planeWidth, props.planeHeight, props.planeHorizontalSegments, props.planeVerticalSegments);
          break;

        case "Box":
          this.mesh = PrimitiveMesh.createCuboid(this._engine, props.boxWidth, props.boxHeight, props.boxDepth);
          break;
      }
    };

    _proto.updateProp = function updateProp(key, value) {
      var props = this._props;
      props[key] = value;
      this.setProps(props);
    };

    _createClass(Model, [{
      key: "material",
      get: function get() {
        return this.getMaterial();
      },
      set: function set(mtl) {
        this.setMaterial(mtl);
      }
    }]);

    return Model;
  }(MeshRenderer);

  var PluginManager = /*#__PURE__*/function () {
    function PluginManager() {
      this.registeredPlugins = new Set();
      this.plugins = [];
    }

    var _proto = PluginManager.prototype;

    _proto.register = function register(plugin) {
      this.registeredPlugins.add(plugin);
    };

    _proto.boot = function boot(oasis) {
      for (var _iterator = _createForOfIteratorHelperLoose(this.registeredPlugins.values()), _step; !(_step = _iterator()).done;) {
        var plugin = _step.value;

        if (typeof plugin === "function") {
          plugin = plugin(oasis);
        }

        this.plugins.push(plugin);
      }
    };

    _proto.reset = function reset() {
      this.registeredPlugins.clear();
      this.plugins = [];
    };

    _proto.nodeAdded = function nodeAdded(entity) {
      this.delegateMethod("nodeAdded", entity);
    };

    _proto.delegateMethod = function delegateMethod(name) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this.plugins.forEach(function (plugin) {
        return plugin[name] && plugin[name].apply(plugin, args);
      });
    };

    return PluginManager;
  }();

  function pluginHook(options) {
    return function (target, propertyName, descriptor) {
      var method = descriptor.value;

      descriptor.value = function () {
        var _this$oasis$pluginMan,
            _this = this;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        options.before && (_this$oasis$pluginMan = this.oasis.pluginManager).delegateMethod.apply(_this$oasis$pluginMan, [options.before].concat(args));
        return Promise.resolve(method.apply(this, arguments)).then(function (returnObj) {
          options.after && _this.oasis.pluginManager.delegateMethod(options.after, returnObj);
          return returnObj;
        });
      };
    };
  }
  /**
   * temp compa
   * @param config
   */


  function compatibleToV2(config) {
    var _config$abilities = config.abilities,
        abilities = _config$abilities === void 0 ? {} : _config$abilities,
        _config$assets = config.assets,
        assets = _config$assets === void 0 ? {} : _config$assets,
        _config$scene = config.scene,
        scene = _config$scene === void 0 ? {} : _config$scene;
    var ids = Object.keys(abilities);
    var assetKeys = Object.keys(assets);
    var sceneKeys = Object.keys(scene || {});

    for (var i = 0, l = ids.length; i < l; ++i) {
      handleComponents(abilities[ids[i]].props);
    }

    for (var _i = 0, _l = assetKeys.length; _i < _l; ++_i) {
      handleAssets(assets[assetKeys[_i]].props);
    }

    for (var _i2 = 0, _l2 = sceneKeys.length; _i2 < _l2; ++_i2) {
      handleSceneProps(scene[sceneKeys[_i2]].props);
    }

    return config;
  } // TODO temp


  function handleComponents(props) {
    var keys = Object.keys(props);

    for (var i = 0, l = keys.length; i < l; ++i) {
      var k = keys[i];
      var v = props[k];

      if (Array.isArray(v) && typeof v[0] !== "object") {
        if (["color", "diffuseColor", "specularColor"].indexOf(k) !== -1) {
          props[k] = new Color(v[0], v[1], v[2], v[3]);
        } else if (v.length === 4) {
          props[k] = new Vector4(v[0], v[1], v[2], v[3]);
        } else if (v.length === 3) {
          props[k] = new Vector3(v[0], v[1], v[2]);
        } else if (v.length === 2) {
          props[k] = new Vector2(v[0], v[1]);
        }
      }
    }
  }

  var sh = new SphericalHarmonics3();

  function handleSceneProps(props) {
    var keys = Object.keys(props);

    for (var i = 0, l = keys.length; i < l; ++i) {
      var k = keys[i];
      var v = props[k];

      if (Array.isArray(v) && typeof v[0] !== "object") {
        if (/color/i.test(k)) {
          props[k] = new Color(v[0], v[1], v[2], v[3]);
        } else if (v.length === 4) {
          props[k] = new Vector4(v[0], v[1], v[2], v[3]);
        } else if (v.length === 3) {
          props[k] = new Vector3(v[0], v[1], v[2]);
        } else if (v.length === 2) {
          props[k] = new Vector2(v[0], v[1]);
        }
      } else if (v && k === "diffuseSphericalHarmonics") {
        sh.setValueByArray(JSON.parse(v));
        props[k] = sh;
      }
    }
  }

  function handleAssets(props) {
    if (props === void 0) {
      props = {};
    }

    if (!props) {
      return;
    }

    var keys = Object.keys(props);

    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      var value = props[key];

      if (key === "newMaterial" || key === "scripts") {
        continue;
      }

      if (Array.isArray(value) && typeof value[0] !== "object") {
        if (["emissiveColor", "diffuseColor", "specularColor", "baseColor"].indexOf(key) !== -1) {
          props[key] = new Color(value[0], value[1], value[2], value[3]);
        } else if (value.length === 4) {
          props[key] = new Vector4(value[0], value[1], value[2], value[3]);
        } else if (value.length === 3) {
          props[key] = new Vector3(value[0], value[1], value[2]);
        } else if (value.length === 2) {
          props[key] = new Vector2(value[0], value[1]);
        }
      }
    }
  }

  var CURRENT_SCHEMA_VERSION = 3;

  var Parser = /*#__PURE__*/function () {
    var _proto = Parser.prototype;
    /**
     * Parse a scene config.
     * @param options - Options of scene
     */

    _proto.parse = function parse(options) {
      var _options$config;

      if ((options === null || options === void 0 ? void 0 : (_options$config = options.config) === null || _options$config === void 0 ? void 0 : _options$config.version) !== CURRENT_SCHEMA_VERSION) {
        var _options$config2;

        console.warn("schema-parser: schema version \"" + (options === null || options === void 0 ? void 0 : (_options$config2 = options.config) === null || _options$config2 === void 0 ? void 0 : _options$config2.version) + "\" is out of date, please re-pull the latest version (version " + CURRENT_SCHEMA_VERSION + ") of the schema");
      }

      compatibleToV2(options.config);
      return Oasis.create(options, this.pluginManager);
    };

    _proto.register = function register(plugin) {
      this.pluginManager.register(plugin);
    };

    _proto.resetPlugins = function resetPlugins() {
      this.pluginManager.reset();
    };

    function Parser() {
      this.pluginManager = new PluginManager();
    }

    Parser.create = function create() {
      var parser = new Parser();
      return parser;
    }
    /** @internal */
    ;
    /**
     * Register parsing component
     * @param namespace - Namespace
     * @param components - Components
     */


    Parser.registerComponents = function registerComponents(namespace, components) {
      if (!this._components[namespace]) {
        this._components[namespace] = {};
      }

      _extends(this._components[namespace], components);
    };

    return Parser;
  }();

  Parser._components = {};
  var parser = Parser.create();

  function switchElementsIndex(elements, currentIndex, targetIndex) {
    if (currentIndex === targetIndex || targetIndex === null || targetIndex === undefined) {
      return;
    }

    var _ref = [elements[targetIndex], elements[currentIndex]];
    elements[currentIndex] = _ref[0];
    elements[targetIndex] = _ref[1];
  }

  function isAsset(config) {
    return config && config.type === "asset";
  }

  function getAllGetters(obj) {
    var result = [];
    var prototype = Object.getPrototypeOf(obj);
    var prototype_property_descriptors = Object.getOwnPropertyDescriptors(prototype);

    for (var _i = 0, _Object$entries = Object.entries(prototype_property_descriptors); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _Object$entries[_i],
          property = _Object$entries$_i[0],
          descriptor = _Object$entries$_i[1];

      if (typeof descriptor.get === "function") {
        result.push(property);
      }
    }

    return result;
  }

  var SchemaResource = /*#__PURE__*/function () {
    var _proto = SchemaResource.prototype;

    _proto.setMeta = function setMeta() {};

    function SchemaResource(resourceManager, _resource) {
      this.resourceManager = resourceManager;
      this._resource = _resource;
      this._meta = {};
      this._attachedResources = [];
      this.setMeta();
    }

    _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceLoader, assetConfig, oasis) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        _this.load(resourceLoader, assetConfig, oasis).then(function () {
          resolve({
            resources: [_this],
            structure: {
              index: 0,
              props: {}
            }
          });
        }).catch(function (e) {
          reject(e);
        });
      });
    };

    _proto.getProps = function getProps() {
      return {};
    };

    _proto.bind = function bind() {};

    _proto.attach = function attach() {};

    _proto.update = function update(key, value) {
      if (isAsset(value)) {
        var resource = this.resourceManager.get(value.id);

        if (resource) {
          this._resource[key] = resource.resource;
        } else {
          Logger.warn("SchemaResource: " + this.meta.name + " can't find asset, which id is: " + value.id);
        }
      } else {
        this._resource[key] = value;
      }
    };

    _proto.updateMeta = function updateMeta(key, value) {
      this._meta[key] = value;
    };

    _proto.onDestroy = function onDestroy() {};

    _createClass(SchemaResource, [{
      key: "resource",
      get:
      /**
       * Resource
       */
      function get() {
        return this._resource;
      }
    }, {
      key: "meta",
      get: function get() {
        return this._meta;
      }
    }, {
      key: "attachedResources",
      get: function get() {
        return this._attachedResources;
      }
    }]);

    return SchemaResource;
  }();

  var AnimationClipResource = /*#__PURE__*/function (_SchemaResource) {
    _inheritsLoose(AnimationClipResource, _SchemaResource);

    function AnimationClipResource() {
      return _SchemaResource.apply(this, arguments) || this;
    }

    var _proto = AnimationClipResource.prototype;

    _proto.load = function load(resourceManager, assetConfig) {
      var _this = this;

      return new Promise(function (resolve) {
        _this._resource = assetConfig.props || {};

        _this.setMeta();

        resolve(_this);
      });
    };

    _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var loadPromise;

        if (assetConfig.props) {
          loadPromise = _this2.load(resourceManager, assetConfig);
        } else {
          reject("Load AnimationClip Error");
        }

        if (loadPromise) {
          loadPromise.then(function () {
            var result = {
              resources: [_this2],
              structure: {
                index: 0,
                props: {}
              }
            };
            resolve(result);
          });
        }
      });
    };

    _proto.setMeta = function setMeta() {
      if (this.resource) {
        this.meta.name = this.resource.name;
      }
    };

    _proto.getProps = function getProps() {
      return this._resource;
    };

    return AnimationClipResource;
  }(SchemaResource);

  var AnimatorControllerResource = /*#__PURE__*/function (_SchemaResource) {
    _inheritsLoose(AnimatorControllerResource, _SchemaResource);

    function AnimatorControllerResource() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
      _this.gltf = void 0;
      _this.animatorControllerData = void 0;
      _this.animationClipAssets = void 0;
      _this.animationsIndices = void 0;
      return _this;
    }

    var _proto = AnimatorControllerResource.prototype;

    _proto.load = function load(resourceManager, assetConfig) {
      var _this2 = this;

      return new Promise(function (resolve) {
        var _ref = assetConfig.props || {},
            animatorController = _ref.animatorController,
            animationClipAssets = _ref.animationClips,
            animationsIndices = _ref.animationsIndices,
            gltf = _ref.gltf;

        _this2._resource = new AnimatorController();
        _this2.animatorControllerData = animatorController;
        _this2.animationsIndices = animationsIndices || [];
        _this2.animationClipAssets = animationClipAssets || [];
        _this2.gltf = gltf;
        !animatorController && _this2._setDefaultDataByAnimationClip();

        _this2.setMetaData("name", assetConfig.name);

        resolve(_this2);
      });
    };

    _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var clipLoadPromises = [];

        _this3.load(resourceManager, assetConfig).then(function () {
          var result = {
            resources: [_this3],
            structure: {
              index: 0,
              props: {
                animationClips: []
              }
            }
          };
          var animations = _this3.animationsIndices;

          for (var i = 0, length = animations.length; i < length; ++i) {
            var clip = animations[i];
            var clipResourse = new AnimationClipResource(_this3.resourceManager);

            _this3.attachedResources.push(clipResourse);

            clipLoadPromises.push(clipResourse.loadWithAttachedResources(resourceManager, {
              type: "animationClip",
              name: clip.name,
              props: clip
            }));
          }

          Promise.all(clipLoadPromises).then(function (res) {
            var animationClips = result.structure.props.animationClips;
            res.forEach(function (clip) {
              var clipStructure = clip.structure;
              var clipResource = clip.resources[clipStructure.index];
              result.resources.push(clipResource);
              clipStructure.index = result.resources.length - 1;
              animationClips.push(clipStructure);
            });
            resolve(result);
          });
        });
      });
    };

    _proto.setMetaData = function setMetaData(key, value) {
      this._meta[key] = value;
    };

    _proto.update = function update(key, value) {
      this._initAnimatorController(value);
    };

    _proto.bind = function bind() {
      var animatorControllerData = this.animatorControllerData,
          animationClipAssets = this.animationClipAssets;

      this._bindClips(animationClipAssets);

      if (animatorControllerData) {
        this._initAnimatorController(animatorControllerData);
      } else {
        this._setDefaultDataByAnimationClipAsset();
      }
    };

    _proto._initAnimatorController = function _initAnimatorController(animatorControllerData) {
      var _ref2 = this.gltf || {},
          animations = _ref2.animations;

      var layers = animatorControllerData.layers;
      if (!animations || !layers) return;

      this._resource.clearLayers();

      for (var i = 0, length = layers.length; i < length; ++i) {
        var _layers$i = layers[i],
            name = _layers$i.name,
            blending = _layers$i.blending,
            weight = _layers$i.weight,
            stateMachineData = _layers$i.stateMachine;
        if (!stateMachineData) continue;
        var layer = new AnimatorControllerLayer(name);
        layer.blendingMode = blending;
        layer.weight = weight;
        var states = stateMachineData.states;
        var stateMachine = new AnimatorStateMachine();
        var stateMachineTransitions = [];

        for (var j = 0, _length = states.length; j < _length; ++j) {
          var stateData = states[j];
          var _name = stateData.name,
              transitions = stateData.transitions,
              clip = stateData.clip,
              speed = stateData.speed,
              wrapMode = stateData.wrapMode,
              clipStartNormalizedTime = stateData.clipStartNormalizedTime,
              clipEndNormalizedTime = stateData.clipEndNormalizedTime,
              isDefaultState = stateData.isDefaultState;

          var _ref3 = clip || {},
              clipAssetId = _ref3.id;

          if (!clipAssetId) continue;
          var uniqueName = stateMachine.makeUniqueStateName(_name);

          if (uniqueName !== _name) {
            console.warn("AnimatorState name is existed, name: " + _name + " reset to " + uniqueName);
          }

          var state = stateMachine.addState(uniqueName);
          state.speed = speed;
          state.wrapMode = wrapMode;
          var animationIndex = this.resourceManager.get(clipAssetId).resource;
          var animationClip = animations[animationIndex.index];
          if (!animationClip) continue;
          state.clip = animationClip;
          state.clipStartTime = animationClip.length * clipStartNormalizedTime;
          state.clipEndTime = animationClip.length * clipEndNormalizedTime;

          for (var _j = 0, _length2 = transitions.length; _j < _length2; ++_j) {
            var transition = transitions[_j];
            transitions[_j].srcState = state;
            stateMachineTransitions.push(transition);
          }

          if (isDefaultState) {
            //@ts-ignore
            stateMachine._defaultState = state;
          }
        }

        for (var _j2 = 0, _length3 = stateMachineTransitions.length; _j2 < _length3; ++_j2) {
          var transitionData = stateMachineTransitions[_j2];

          var _transition = new AnimatorStateTransition();

          _transition.duration = transitionData.duration;
          _transition.offset = transitionData.offset;
          _transition.exitTime = transitionData.exitTime;
          _transition.destinationState = stateMachine.findStateByName(transitionData.targetStateName);
          transitionData.srcState.addTransition(_transition);
          delete transitionData.srcState;
        }

        layer.stateMachine = stateMachine;

        this._resource.addLayer(layer);
      }
    };

    _proto._bindClips = function _bindClips(animationClips) {
      for (var i = 0, length = animationClips.length; i < length; i++) {
        var clipAsset = animationClips[i];
        var clipResource = this.resourceManager.get(clipAsset.id);

        if (clipResource) {
          this._attachedResources.push(clipResource);
        } else {
          "AnimatorResource: " + this.meta.name + " can't find asset \"animationClip\", which id is: " + clipAsset.id;
        }
      }
    };

    _proto._setDefaultDataByAnimationClipAsset = function _setDefaultDataByAnimationClipAsset() {
      var animationClipAssets = this.animationClipAssets;

      if (!animationClipAssets.length) {
        return;
      }

      var clips = [];

      for (var i = 0, length = animationClipAssets.length; i < length; i++) {
        var clipAsset = this.resourceManager.get(animationClipAssets[i].id);
        clips.push(clipAsset.resource);
      }

      this.animationsIndices = clips;

      this._setDefaultDataByAnimationClip();
    };

    _proto._setDefaultDataByAnimationClip = function _setDefaultDataByAnimationClip() {
      var animationsIndices = this.animationsIndices,
          animatorController = this._resource,
          gltf = this.gltf;

      if (!animationsIndices.length || !gltf) {
        return;
      }

      var animations = gltf.animations;
      var layer = new AnimatorControllerLayer("layer");
      var animatorStateMachine = new AnimatorStateMachine();
      animatorController.addLayer(layer);
      layer.stateMachine = animatorStateMachine;

      for (var i = 0, length = animationsIndices.length; i < length; i++) {
        var animationIndex = animationsIndices[i];
        var name = animationIndex.name,
            index = animationIndex.index;
        var uniqueName = animatorStateMachine.makeUniqueStateName(name);

        if (uniqueName !== name) {
          console.warn("AnimatorState name is existed, name: " + name + " reset to " + uniqueName);
        }

        var animatorState = animatorStateMachine.addState(uniqueName);
        animatorState.clip = animations[index];
      }
    };

    return AnimatorControllerResource;
  }(SchemaResource);

  var TextureResource = /*#__PURE__*/function (_SchemaResource) {
    _inheritsLoose(TextureResource, _SchemaResource);

    function TextureResource() {
      return _SchemaResource.apply(this, arguments) || this;
    }

    var _proto = TextureResource.prototype;

    _proto.load = function load(resourceManager, assetConfig, oasis) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        var _assetConfig$props, _assetConfig$props$co, _url;

        var url;
        var assetType = exports.AssetType.Texture2D;

        if (_this.resourceManager.useCompressedTexture && assetConfig !== null && assetConfig !== void 0 && (_assetConfig$props = assetConfig.props) !== null && _assetConfig$props !== void 0 && (_assetConfig$props$co = _assetConfig$props.compression) !== null && _assetConfig$props$co !== void 0 && _assetConfig$props$co.compressions.length) {
          var rhi = oasis.engine._hardwareRenderer;
          var compressions = assetConfig.props.compression.compressions;

          for (var i = 0; i < compressions.length; i++) {
            var compression = compressions[i];

            if (compression.container === "ktx" && rhi.canIUse(exports.GLCapabilityType[compression.type])) {
              url = compression.url;
              assetType = exports.AssetType.KTX;
              break;
            }
          }
        }

        url = (_url = url) != null ? _url : assetConfig.url;
        resourceManager.load({
          url: url,
          type: assetType
        }).then(function (res) {
          _this._resource = res;
          resolve(_this);
        }).catch(function (e) {
          reject(e);
        });
      });
    };

    _proto.setMeta = function setMeta() {
      if (this.resource) {
        this._meta.name = this.resource.name;
      }
    };

    return TextureResource;
  }(SchemaResource);

  var BlinnPhongMaterialResource = /*#__PURE__*/function (_SchemaResource) {
    _inheritsLoose(BlinnPhongMaterialResource, _SchemaResource);

    function BlinnPhongMaterialResource() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
      _this.configProps = void 0;
      return _this;
    }

    var _proto = BlinnPhongMaterialResource.prototype;

    _proto.load = function load(resourceManager, assetConfig) {
      var _this2 = this;

      return new Promise(function (resolve) {
        var assetObj = new BlinnPhongMaterial(resourceManager.engine);
        _this2.configProps = assetConfig.props;
        _this2._resource = assetObj;

        for (var k in _this2.configProps) {
          if (!isAsset(_this2.configProps[k])) {
            assetObj[k] = _this2.configProps[k];
          }
        }

        _this2.setMeta();

        resolve(_this2);
      });
    };

    _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var loadPromise;

        if (assetConfig.resource instanceof BlinnPhongMaterial) {
          loadPromise = new Promise(function (resolve) {
            _this3._resource = assetConfig.resource;

            _this3.setMeta();

            resolve(_this3);
          });
        } else if (assetConfig.props) {
          loadPromise = _this3.load(resourceManager, assetConfig);
        } else {
          reject("Load BlinnPhongMaterial Error");
        }

        if (loadPromise) {
          loadPromise.then(function () {
            var result = {
              resources: [_this3],
              structure: {
                index: 0,
                props: {}
              }
            };
            var material = _this3._resource;
            getAllGetters(_this3._resource).forEach(function (attr) {
              if (!(material[attr] instanceof Texture)) return;
              var textureResource = new TextureResource(_this3.resourceManager, material[attr]);

              _this3.attachedResources.push(textureResource);

              result.resources.push(textureResource);
              result.structure.props[attr] = {
                index: result.resources.length - 1
              };
            });
            resolve(result);
          });
        }
      });
    };

    _proto.setMeta = function setMeta() {
      if (this.resource) {
        this.meta.name = this.resource.name;
      }
    };

    _proto.bind = function bind() {
      var _this4 = this;

      var resource = this._resource;
      Object.keys(this.configProps).forEach(function (attr) {
        var value = _this4.configProps[attr];

        if (isAsset(value)) {
          var textureResource = _this4.resourceManager.get(value.id);

          if (textureResource && textureResource instanceof TextureResource) {
            resource[attr] = textureResource.resource;

            _this4._attachedResources.push(textureResource);
          } else {
            resource[attr] = null;
            Logger.warn("BlinnPhongMaterialResource: " + _this4.meta.name + " can't find asset \"" + attr + "\", which id is: " + value.id);
          }
        } else {
          resource[attr] = value;
        }
      });
    };

    return BlinnPhongMaterialResource;
  }(SchemaResource);

  var attrs$1 = ["metallic", "roughness", "roughnessMetallicTexture", // pbr base
  "tilingOffset", "baseColor", "normalTextureIntensity", "emissiveColor", "occlusionTextureIntensity", "baseTexture", "normalTexture", "emissiveTexture", "occlusionTexture", // base material
  "isTransparent", "alphaCutoff", "renderFace", "blendMode"];

  var PBRMaterialResource = /*#__PURE__*/function (_SchemaResource) {
    _inheritsLoose(PBRMaterialResource, _SchemaResource);

    function PBRMaterialResource() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
      _this.configProps = void 0;
      return _this;
    }

    var _proto = PBRMaterialResource.prototype;

    _proto.load = function load(resourceManager, assetConfig) {
      var _this2 = this;

      return new Promise(function (resolve) {
        var assetObj = new PBRMaterial(resourceManager.engine);
        _this2.configProps = assetConfig.props;

        for (var k in _this2.configProps) {
          if (!isAsset(_this2.configProps[k])) {
            assetObj[k] = _this2.configProps[k];
          }
        }

        _this2._resource = assetObj;

        _this2.setMeta();

        resolve(_this2);
      });
    };

    _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var loadPromise;

        if (assetConfig.resource instanceof PBRMaterial) {
          loadPromise = new Promise(function (resolve) {
            _this3._resource = assetConfig.resource;

            _this3.setMeta();

            resolve(_this3);
          });
        } else if (assetConfig.props) {
          loadPromise = _this3.load(resourceManager, assetConfig);
        } else {
          reject("Load PBRMaterial Error");
        }

        if (loadPromise) {
          loadPromise.then(function () {
            var result = {
              resources: [_this3],
              structure: {
                index: 0,
                props: {}
              }
            };
            var material = _this3._resource;
            attrs$1.forEach(function (attr) {
              if (!(material[attr] instanceof Texture)) return;
              var textureResource = new TextureResource(_this3.resourceManager, material[attr]);

              _this3.attachedResources.push(textureResource);

              result.resources.push(textureResource);
              result.structure.props[attr] = {
                index: result.resources.length - 1
              };
            });
            resolve(result);
          });
        }
      });
    };

    _proto.setMeta = function setMeta() {
      if (this.resource) {
        this.meta.name = this.resource.name;
      }
    };

    _proto.getProps = function getProps() {
      var _this4 = this;

      var result = {};
      attrs$1.forEach(function (prop) {
        return result[prop] = _this4.resource[prop];
      });
      return result;
    };

    _proto.bind = function bind() {
      var _this5 = this;

      var resource = this._resource;
      Object.keys(this.configProps).forEach(function (attr) {
        var value = _this5.configProps[attr];

        if (isAsset(value)) {
          var textureResource = _this5.resourceManager.get(value.id);

          if (textureResource && textureResource instanceof TextureResource) {
            resource[attr] = textureResource.resource;

            _this5._attachedResources.push(textureResource);
          } else {
            resource[attr] = null;
            Logger.warn("PBRMaterialResource: " + _this5.meta.name + " can't find asset \"" + attr + "\", which id is: " + value.id);
          }
        } else {
          resource[attr] = value;
        }
      });
    };

    return PBRMaterialResource;
  }(SchemaResource);

  var attrs = ["specularColor", "glossiness", "specularGlossinessTexture", // pbr base
  "tilingOffset", "baseColor", "normalTextureIntensity", "emissiveColor", "occlusionTextureIntensity", "baseTexture", "normalTexture", "emissiveTexture", "occlusionTexture", // base material
  "isTransparent", "alphaCutoff", "renderFace", "blendMode"];

  var PBRSpecularMaterialResource = /*#__PURE__*/function (_SchemaResource) {
    _inheritsLoose(PBRSpecularMaterialResource, _SchemaResource);

    function PBRSpecularMaterialResource() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
      _this.configProps = void 0;
      return _this;
    }

    var _proto = PBRSpecularMaterialResource.prototype;

    _proto.load = function load(resourceManager, assetConfig) {
      var _this2 = this;

      return new Promise(function (resolve) {
        var assetObj = new PBRSpecularMaterial(resourceManager.engine);
        _this2.configProps = assetConfig.props;
        _this2._resource = assetObj;

        for (var k in _this2.configProps) {
          if (!isAsset(_this2.configProps[k])) {
            assetObj[k] = _this2.configProps[k];
          }
        }

        _this2.setMeta();

        resolve(_this2);
      });
    };

    _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var loadPromise;

        if (assetConfig.resource instanceof PBRSpecularMaterial) {
          loadPromise = new Promise(function (resolve) {
            _this3._resource = assetConfig.resource;

            _this3.setMeta();

            resolve(_this3);
          });
        } else if (assetConfig.props) {
          loadPromise = _this3.load(resourceManager, assetConfig);
        } else {
          reject("Load PBRSpecularMaterial Error");
        }

        if (loadPromise) {
          loadPromise.then(function () {
            var result = {
              resources: [_this3],
              structure: {
                index: 0,
                props: {}
              }
            };
            var material = _this3._resource;
            Object.keys(_this3._resource).forEach(function (attr) {
              if (!(material[attr] instanceof Texture)) return;
              var textureResource = new TextureResource(_this3.resourceManager, material[attr]);

              _this3.attachedResources.push(textureResource);

              result.resources.push(textureResource);
              result.structure.props[attr] = {
                index: result.resources.length - 1
              };
            });
            resolve(result);
          });
        }
      });
    };

    _proto.setMeta = function setMeta() {
      if (this.resource) {
        this.meta.name = this.resource.name;
      }
    };

    _proto.getProps = function getProps() {
      var _this4 = this;

      var result = {};
      attrs.forEach(function (prop) {
        return result[prop] = _this4.resource[prop];
      });
      return result;
    };

    _proto.bind = function bind() {
      var _this5 = this;

      var resource = this._resource;
      Object.keys(this.configProps).forEach(function (attr) {
        var value = _this5.configProps[attr];

        if (isAsset(value)) {
          var textureResource = _this5.resourceManager.get(value.id);

          if (textureResource && textureResource instanceof TextureResource) {
            resource[attr] = textureResource.resource;

            _this5._attachedResources.push(textureResource);
          } else {
            resource[attr] = null;
            Logger.warn("PBRSpecularMaterialResource: " + _this5.meta.name + " can't find asset \"" + attr + "\", which id is: " + value.id);
          }
        } else {
          resource[attr] = value;
        }
      });
    };

    return PBRSpecularMaterialResource;
  }(SchemaResource);

  var UnlitMaterialResource = /*#__PURE__*/function (_SchemaResource) {
    _inheritsLoose(UnlitMaterialResource, _SchemaResource);

    function UnlitMaterialResource() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
      _this.configProps = void 0;
      return _this;
    }

    var _proto = UnlitMaterialResource.prototype;

    _proto.load = function load(resourceManager, assetConfig) {
      var _this2 = this;

      return new Promise(function (resolve) {
        var assetObj = new UnlitMaterial(resourceManager.engine);
        _this2.configProps = assetConfig.props;

        for (var k in _this2.configProps) {
          if (!isAsset(_this2.configProps[k])) {
            assetObj[k] = _this2.configProps[k];
          }
        }

        _this2._resource = assetObj;

        _this2.setMeta();

        resolve(_this2);
      });
    };

    _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var loadPromise;

        if (assetConfig.resource instanceof UnlitMaterial) {
          loadPromise = new Promise(function (resolve) {
            _this3._resource = assetConfig.resource;

            _this3.setMeta();

            resolve(_this3);
          });
        } else if (assetConfig.props) {
          loadPromise = _this3.load(resourceManager, assetConfig);
        } else {
          reject("Load PBRMaterial Error");
        }

        if (loadPromise) {
          loadPromise.then(function () {
            var result = {
              resources: [_this3],
              structure: {
                index: 0,
                props: {}
              }
            };
            var material = _this3._resource;
            getAllGetters(_this3._resource).forEach(function (attr) {
              if (!(material[attr] instanceof Texture)) return;
              var textureResource = new TextureResource(_this3.resourceManager, material[attr]);

              _this3.attachedResources.push(textureResource);

              result.resources.push(textureResource);
              result.structure.props[attr] = {
                index: result.resources.length - 1
              };
            });
            resolve(result);
          });
        }
      });
    };

    _proto.setMeta = function setMeta() {
      if (this.resource) {
        this.meta.name = this.resource.name;
      }
    };

    _proto.getProps = function getProps() {
      var _this4 = this;

      var result = {};
      var props = getAllGetters(this.resource);
      props.forEach(function (prop) {
        return result[prop] = _this4.resource[prop];
      });
      return result;
    };

    _proto.bind = function bind() {
      var _this5 = this;

      var resource = this._resource;
      Object.keys(this.configProps).forEach(function (attr) {
        var value = _this5.configProps[attr];

        if (isAsset(value)) {
          var textureResource = _this5.resourceManager.get(value.id);

          if (textureResource && textureResource instanceof TextureResource) {
            resource[attr] = textureResource.resource;

            _this5._attachedResources.push(textureResource);
          } else {
            resource[attr] = null;
            Logger.warn("PBRMaterialResource: " + _this5.meta.name + " can't find asset \"" + attr + "\", which id is: " + value.id);
          }
        } else {
          resource[attr] = value;
        }
      });
    };

    return UnlitMaterialResource;
  }(SchemaResource);

  var GLTFResource = /*#__PURE__*/function (_SchemaResource) {
    _inheritsLoose(GLTFResource, _SchemaResource);

    function GLTFResource() {
      return _SchemaResource.apply(this, arguments) || this;
    }

    var _proto = GLTFResource.prototype;

    _proto.load = function load(resourceManager, assetConfig, oasis) {
      var _this = this;

      return resourceManager.load({
        url: assetConfig.url,
        type: exports.AssetType.Prefab
      }).then(function (res) {
        var gltf = res;

        if (assetConfig.props) {
          gltf.newMaterial = assetConfig.props.newMaterial;
          gltf.animatorControllers = assetConfig.props.animatorControllers;
        }

        _this._resource = gltf;
      });
    };

    _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig, oasis) {
      var _this2 = this;

      return new Promise(function (resolve) {
        _this2.load(resourceManager, assetConfig, oasis).then(function () {
          var gltf = _this2.resource;

          var _gltf$materials = gltf.materials,
              materials = _gltf$materials === void 0 ? [] : _gltf$materials,
              _gltf$_animationsIndi = gltf._animationsIndices,
              _animationsIndices = _gltf$_animationsIndi === void 0 ? [] : _gltf$_animationsIndi;

          var materialLoadPromises = [];
          var animatorControllerLoadPromise;
          var result = {
            resources: [_this2],
            structure: {
              index: 0,
              props: {
                newMaterial: [],
                animatorControllers: []
              }
            }
          };

          if (materials !== null && materials !== void 0 && materials.length) {
            for (var i = 0; i < materials.length; i++) {
              var material = materials[i];
              var materialResource = null;
              var type = "";

              if (material instanceof PBRMaterial) {
                materialResource = new PBRMaterialResource(_this2.resourceManager);
                type = "PBRMaterial";
              } else if (material instanceof UnlitMaterial) {
                materialResource = new UnlitMaterialResource(_this2.resourceManager);
                type = "UnlitMaterial";
              } else if (material instanceof PBRSpecularMaterial) {
                materialResource = new PBRSpecularMaterialResource(_this2.resourceManager);
                type = "PBRSpecularMaterial";
              } else {
                materialResource = new BlinnPhongMaterialResource(_this2.resourceManager);
                type = "BlinnPhongMaterial";
              }

              _this2._attachedResources.push(materialResource);

              materialLoadPromises.push(materialResource.loadWithAttachedResources(resourceManager, {
                type: type,
                name: material.name,
                resource: material
              }));
            }
          }

          if (_animationsIndices.length) {
            var animatorControllerResource = new AnimatorControllerResource(_this2.resourceManager);

            _this2._attachedResources.push(animatorControllerResource);

            animatorControllerLoadPromise = animatorControllerResource.loadWithAttachedResources(resourceManager, {
              type: "animatorController",
              name: "AnimatorController",
              props: {
                animationsIndices: _animationsIndices,
                gltf: _this2._resource
              }
            });
          }

          var loadAttachedMaterial = Promise.all(materialLoadPromises).then(function (res) {
            var newMaterial = result.structure.props.newMaterial;
            res.forEach(function (mat) {
              var matStructure = mat.structure;
              var matResource = mat.resources[matStructure.index];
              result.resources.push(matResource);
              matStructure.index = result.resources.length - 1;

              for (var key in matStructure.props) {
                if (matStructure.props.hasOwnProperty(key)) {
                  var textureStructure = matStructure.props[key];
                  var textureResource = mat.resources[textureStructure.index];
                  result.resources.push(textureResource);
                  textureStructure.index = result.resources.length - 1;
                }
              }

              newMaterial.push(matStructure);
            });
          });
          var loadAttachedController = animatorControllerLoadPromise ? animatorControllerLoadPromise.then(function (res) {
            var animatorControllers = result.structure.props.animatorControllers;
            var controllerStructure = res.structure;
            var controllerResource = res.resources[controllerStructure.index];
            result.resources.push(controllerResource);
            controllerStructure.index = result.resources.length - 1;
            var animationClips = controllerStructure.props.animationClips;

            if (animationClips) {
              for (var _i = 0, length = animationClips.length; _i < length; ++_i) {
                var clipStructure = animationClips[_i];
                var clipResource = res.resources[clipStructure.index];
                result.resources.push(clipResource);
                clipStructure.index = result.resources.length - 1;
              }
            }

            animatorControllers.push(controllerStructure);
          }) : Promise.resolve();
          Promise.all([loadAttachedMaterial, loadAttachedController]).then(function () {
            resolve(result);
          });
        });
      });
    };

    _proto.setMeta = function setMeta(assetConfig) {
      if (assetConfig) {
        this.meta.name = assetConfig.name;
      }
    };

    _proto.bind = function bind() {
      var resource = this._resource;
      this.bindMaterials(resource.newMaterial);
      this.bindAnimatorControllers(resource.animatorControllers);
    };

    _proto.update = function update(key, value) {
      if (key === "newMaterial") {
        this.bindMaterials(value);
      } else {
        this._resource[key] = value;
      }
    };

    _proto.bindMaterials = function bindMaterials(newMaterialsConfig) {
      var newMaterialCount = newMaterialsConfig.length;

      if (!newMaterialsConfig || !newMaterialsConfig.length) {
        return;
      }

      var gltf = this._resource;
      var newMaterials = new Array(newMaterialCount);
      gltf.newMaterial = newMaterials;

      for (var i = 0; i < newMaterialsConfig.length; i++) {
        var mtlResource = this.resourceManager.get(newMaterialsConfig[i].id);

        if (mtlResource) {
          this._attachedResources.push(mtlResource);

          newMaterials[i] = mtlResource.resource;
        } else {
          Logger.warn("GLTFResource: " + this.meta.name + " can't find asset \"material\", which id is: " + newMaterialsConfig[i].id);
        }
      }

      var gltfRoot = gltf.defaultSceneRoot;
      var originMaterials = gltf.materials;
      var meshRenderers = gltfRoot.getComponentsIncludeChildren(MeshRenderer, []);

      for (var _i2 = 0; _i2 < newMaterialCount; _i2++) {
        var newMaterial = newMaterials[_i2];
        var originMaterial = originMaterials[_i2];

        for (var j = 0; j < meshRenderers.length; j++) {
          var meshRenderer = meshRenderers[j];
          var meshMaterials = meshRenderer.getMaterials();

          for (var k = 0; k < meshMaterials.length; k++) {
            if (originMaterial === meshMaterials[k]) {
              meshRenderer.setMaterial(k, newMaterial);
            }
          }
        }
      }
    };

    _proto.bindAnimatorControllers = function bindAnimatorControllers(animatorControllers) {
      for (var i = 0, length = animatorControllers.length; i < length; i++) {
        var animatorControllerAsset = animatorControllers[i];
        var controllerResource = this.resourceManager.get(animatorControllerAsset.id);
        controllerResource.gltf = this._resource;

        if (controllerResource) {
          this._attachedResources.push(controllerResource);
        } else {
          "GLTFResource: " + this.meta.name + " can't find asset \"animatorController\", which id is: " + animatorControllerAsset.id;
        }
      }
    };

    return GLTFResource;
  }(SchemaResource);

  var scriptAbility = {};

  function script(name) {
    return function (target) {
      scriptAbility[name] = target;
    };
  }

  var ScriptResource = /*#__PURE__*/function (_SchemaResource) {
    _inheritsLoose(ScriptResource, _SchemaResource);

    function ScriptResource() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
      _this.isInit = false;
      return _this;
    }

    var _proto = ScriptResource.prototype;

    _proto.initScriptContext = function initScriptContext() {
      if (this.isInit) {
        return;
      }

      this.isInit = true;
      window.__o3_script_context__ = {
        o3: Parser._components["o3"],
        script: function script(name) {
          return function (target) {
            scriptAbility[name] = target;
          };
        }
      };
    };

    _proto.load = function load(resourceLoader, assetConfig, oasis) {
      var _this2 = this;

      this.initScriptContext();
      return new Promise(function (resolve) {
        var config = assetConfig;
        var scripts = config.props.scripts;

        if (!_this2.resourceManager.isLocal) {
          var scriptDom = document.createElement("script");
          scriptDom.crossOrigin = "anonymous";

          _this2.setMeta(assetConfig);

          scriptDom.onload = function () {
            var o3Scripts = window.o3Scripts;

            for (var i = 0; i < scripts.length; i++) {
              var name = scripts[i].name;
              _this2._resource = o3Scripts && o3Scripts[name];
              scriptAbility[name] = _this2._resource;
            }

            resolve(_this2);
          };

          scriptDom.src = assetConfig.url;
          document.body.appendChild(scriptDom);
        } else {
          for (var i = 0; i < scripts.length; i++) {
            var _oasis$options;

            var name = scripts[i].name;
            scriptAbility[name] = (_oasis$options = oasis.options) === null || _oasis$options === void 0 ? void 0 : _oasis$options.scripts[name];
          }

          resolve(_this2);
        }
      });
    };

    _proto.setMeta = function setMeta(assetConfig) {
      if (assetConfig) {
        this._meta.name = assetConfig.name;
        this._meta.url = assetConfig.url;
        this._meta.source = assetConfig.source;
      }
    };

    return ScriptResource;
  }(SchemaResource);

  var SpriteResource = /*#__PURE__*/function (_SchemaResource) {
    _inheritsLoose(SpriteResource, _SchemaResource);

    function SpriteResource() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
      _this.configProps = void 0;
      return _this;
    }

    var _proto = SpriteResource.prototype;

    _proto.load = function load(resourceManager, assetConfig) {
      var _this2 = this;

      return new Promise(function (resolve) {
        var assetObj = new Sprite(resourceManager.engine);
        _this2.configProps = assetConfig.props;
        var configProps = _this2.configProps;
        var pivotType = configProps.pivotType,
            pivot = configProps.pivot;

        if (typeof pivot !== "undefined" && typeof pivotType !== "undefined" && pivotType !== exports.SpritePivotType.Custom) {
          switch (pivotType) {
            case exports.SpritePivotType.Center:
              pivot.x = 0.5;
              pivot.y = 0.5;
              break;

            case exports.SpritePivotType.TopLeft:
              pivot.x = 0;
              pivot.y = 1;
              break;

            case exports.SpritePivotType.Top:
              pivot.x = 0.5;
              pivot.y = 1;
              break;

            case exports.SpritePivotType.TopRight:
              pivot.x = 1;
              pivot.y = 1;
              break;

            case exports.SpritePivotType.Left:
              pivot.x = 0;
              pivot.y = 0.5;
              break;

            case exports.SpritePivotType.Right:
              pivot.x = 1;
              pivot.y = 0.5;
              break;

            case exports.SpritePivotType.BottomLeft:
              pivot.x = 0;
              pivot.y = 0;
              break;

            case exports.SpritePivotType.Bottom:
              pivot.x = 0.5;
              pivot.y = 0;
              break;

            case exports.SpritePivotType.BottomRight:
              pivot.x = 1;
              pivot.y = 0;
              break;
          }
        }

        for (var k in configProps) {
          if (!isAsset(configProps[k]) && typeof configProps[k] !== "undefined") {
            assetObj[k] = configProps[k];
          }
        }

        _this2._resource = assetObj;

        _this2.setMeta();

        resolve(_this2);
      });
    };

    _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var loadPromise;

        if (assetConfig.resource instanceof SpriteResource) {
          loadPromise = new Promise(function (resolve) {
            _this3._resource = assetConfig.resource;

            _this3.setMeta();

            resolve(_this3);
          });
        } else if (assetConfig.props) {
          loadPromise = _this3.load(resourceManager, assetConfig);
        } else {
          reject("Load Sprite Error");
        }

        if (loadPromise) {
          loadPromise.then(function () {
            var result = {
              resources: [_this3],
              structure: {
                index: 0,
                props: {}
              }
            };
            var sprite = _this3._resource;
            getAllGetters(_this3._resource).forEach(function (attr) {
              if (!(sprite[attr] instanceof Texture)) return;
              var textureResource = new TextureResource(_this3.resourceManager, sprite[attr]);

              _this3.attachedResources.push(textureResource);

              result.resources.push(textureResource);
              result.structure.props[attr] = {
                index: result.resources.length - 1
              };
            });
            resolve(result);
          });
        }
      });
    };

    _proto.setMeta = function setMeta() {
      if (this.resource) {
        this.meta.name = this.resource.name;
      }
    };

    _proto.getProps = function getProps() {
      var _this4 = this;

      var result = {};
      var props = getAllGetters(this.resource);
      props.forEach(function (prop) {
        return result[prop] = _this4.resource[prop];
      });
      return result;
    };

    _proto.bind = function bind() {
      var _this5 = this;

      var resource = this._resource;
      this.configProps && Object.keys(this.configProps).forEach(function (attr) {
        var value = _this5.configProps[attr];

        if (isAsset(value)) {
          var textureResource = _this5.resourceManager.get(value.id);

          if (textureResource && textureResource instanceof TextureResource) {
            resource[attr] = textureResource.resource;

            _this5._attachedResources.push(textureResource);
          } else {
            resource[attr] = null;
            Logger.warn("SpriteResource: " + _this5.meta.name + " can't find asset \"" + attr + "\", which id is: " + value.id);
          }
        } else {
          resource[attr] = value;
        }
      });
    };

    return SpriteResource;
  }(SchemaResource);

  exports.SpritePivotType = void 0;

  (function (SpritePivotType) {
    SpritePivotType[SpritePivotType["Center"] = 0] = "Center";
    SpritePivotType[SpritePivotType["TopLeft"] = 1] = "TopLeft";
    SpritePivotType[SpritePivotType["Top"] = 2] = "Top";
    SpritePivotType[SpritePivotType["TopRight"] = 3] = "TopRight";
    SpritePivotType[SpritePivotType["Left"] = 4] = "Left";
    SpritePivotType[SpritePivotType["Right"] = 5] = "Right";
    SpritePivotType[SpritePivotType["BottomLeft"] = 6] = "BottomLeft";
    SpritePivotType[SpritePivotType["Bottom"] = 7] = "Bottom";
    SpritePivotType[SpritePivotType["BottomRight"] = 8] = "BottomRight";
    SpritePivotType[SpritePivotType["Custom"] = 9] = "Custom";
  })(exports.SpritePivotType || (exports.SpritePivotType = {}));

  var imageOrderMap = {
    px: 0,
    nx: 1,
    py: 2,
    ny: 3,
    pz: 4,
    nz: 5
  };

  var TextureCubeMapResource = /*#__PURE__*/function (_SchemaResource) {
    _inheritsLoose(TextureCubeMapResource, _SchemaResource);

    function TextureCubeMapResource() {
      return _SchemaResource.apply(this, arguments) || this;
    }

    var _proto = TextureCubeMapResource.prototype;

    _proto.load = function load(resourceManager, assetConfig, oasis) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        var _assetConfig$props, _assetConfig$props$co;

        var imageUrls = [];
        var type = exports.AssetType.TextureCube;

        if (_this.resourceManager.useCompressedTexture && assetConfig !== null && assetConfig !== void 0 && (_assetConfig$props = assetConfig.props) !== null && _assetConfig$props !== void 0 && (_assetConfig$props$co = _assetConfig$props.compression) !== null && _assetConfig$props$co !== void 0 && _assetConfig$props$co.compressions.length) {
          var rhi = oasis.engine._hardwareRenderer;
          var compressions = assetConfig.props.compression.compressions;

          for (var i = 0; i < compressions.length; i++) {
            var compression = compressions[i];

            if (compression.container === "ktx" && rhi.canIUse(exports.GLCapabilityType[compression.type])) {
              for (var key in compression.files) {
                if (compression.files.hasOwnProperty(key)) {
                  var image = compression.files[key];
                  imageUrls[imageOrderMap[key]] = image.url;
                }
              }

              console.warn(compression.type);
              type = exports.AssetType.KTXCube;
              break;
            }
          }
        }

        if (type === exports.AssetType.TextureCube) {
          for (var _key in assetConfig.props.images) {
            if (assetConfig.props.images.hasOwnProperty(_key)) {
              var _image = assetConfig.props.images[_key];
              imageUrls[imageOrderMap[_key]] = _image.url;
            }
          }
        }

        resourceManager.load({
          urls: imageUrls,
          type: type
        }).then(function (res) {
          _this._resource = res;
          resolve(_this);
        }).catch(function (e) {
          reject(e);
        });
      });
    };

    _proto.setMeta = function setMeta() {
      if (this.resource) {
        this.meta.name = this.resource.name;
      }
    };

    return TextureCubeMapResource;
  }(SchemaResource);

  var BaseResource = /*#__PURE__*/function (_SchemaResource) {
    _inheritsLoose(BaseResource, _SchemaResource);

    function BaseResource() {
      return _SchemaResource.apply(this, arguments) || this;
    }

    var _proto = BaseResource.prototype;

    _proto.load = function load(resourceLoader, assetConfig) {
      var _this = this;

      return new Promise(function (resolve) {
        _this._resource = assetConfig;

        _this.setMetaData("name", _this.resource.name);

        _this.setMetaData("url", _this.resource.url);

        resolve(_this);
      });
    };

    _proto.setMetaData = function setMetaData(key, value) {
      this._meta[key] = value;
    };

    return BaseResource;
  }(SchemaResource);

  var _dec$4, _dec2$2, _dec3$1, _class$4;

  var AbilityManager = (_dec$4 = pluginHook({
    after: "abilityAdded",
    before: "beforeAbilityAdded"
  }), _dec2$2 = pluginHook({
    before: "beforeAbilityUpdated",
    after: "abilityUpdated"
  }), _dec3$1 = pluginHook({
    after: "abilityDeleted",
    before: "beforeAbilityDeleted"
  }), (_class$4 = /*#__PURE__*/function () {
    function AbilityManager(oasis) {
      this.oasis = oasis;
      this.abilityMap = {};
    }

    var _proto = AbilityManager.prototype;

    _proto.add = function add(abilityConfig) {
      var type = abilityConfig.type,
          nodeId = abilityConfig.node,
          props = abilityConfig.props,
          id = abilityConfig.id,
          index = abilityConfig.index;
      var node = this.oasis.nodeManager.get(nodeId);
      var AbilityConstructor = this.getCompConstructor(type);

      if (!AbilityConstructor) {
        Logger.error(type + " abiltiy is not defined");
        return;
      }

      var abilityProps = this.mixPropsToExplicitProps(props);
      var ability = node.addComponent(AbilityConstructor);
      var enabled = abilityProps.enabled;

      if (enabled !== undefined) {
        ability.enabled = enabled;
      }

      if (type === "GLTFModel") {
        // TODO
        ability.init(abilityProps);
      } else if (type === "Model") {
        // TODO
        ability.setProps(abilityProps);

        if (abilityProps.material) {
          ability.material = abilityProps.material;
        }
      } else {
        for (var k in abilityProps) {
          if (abilityProps[k] !== null) {
            ability[k] = abilityProps[k];
          }
        }
      } //@ts-ignore


      var abilityArray = node._components;
      var currentIndex = abilityArray.length - 1;
      switchElementsIndex(abilityArray, currentIndex, index);
      ability.id = id;
      this.abilityMap[id] = ability;
      return ability;
    };

    _proto.update = function update(id, key, value) {
      if (value && this.checkIsAsset(value)) {
        this.get(id)[key] = this.oasis.resourceManager.get(value.id).resource;
      } else {
        if (this.get(id).constructor === Model) {
          this.get(id).updateProp(key, value);
        } else {
          this.get(id)[key] = value;
        }
      }

      return {
        id: id,
        key: key,
        value: value
      };
    };

    _proto.addRuntimeComponent = function addRuntimeComponent(componentId, component) {
      component.id = componentId;
      this.abilityMap[componentId] = component;
      return component;
    };

    _proto.get = function get(id) {
      return this.abilityMap[id];
    };

    _proto.delete = function _delete(id) {
      var ability = this.abilityMap[id];
      ability.destroy();
      delete this.abilityMap[id];
      return id;
    };

    _proto.getCompConstructor = function getCompConstructor(type) {
      var splits = type.split("."); // script

      if (splits[0] === "script") {
        return scriptAbility[splits[1]];
      }

      var constructor = Parser._components["o3"][type];

      if (!constructor) {
        console.warn(type + " is not defined");
      }

      return constructor;
    };

    _proto.mixPropsToExplicitProps = function mixPropsToExplicitProps(props) {
      var explicitProps = _objectSpread2({}, props);

      for (var k in props) {
        var prop = props[k];

        if (prop && this.checkIsAsset(prop)) {
          var res = this.oasis.resourceManager.get(prop.id);

          if (res) {
            explicitProps[k] = res.resource;
          } else {
            explicitProps[k] = null;
            Logger.warn("AbilityManager: can't get asset \"" + k + "\", which id is " + prop.id);
          }
        }
      }

      return explicitProps;
    };

    _proto.checkIsAsset = function checkIsAsset(prop) {
      return prop.type === "asset";
    };

    return AbilityManager;
  }(), (_applyDecoratedDescriptor(_class$4.prototype, "add", [_dec$4], Object.getOwnPropertyDescriptor(_class$4.prototype, "add"), _class$4.prototype), _applyDecoratedDescriptor(_class$4.prototype, "update", [_dec2$2], Object.getOwnPropertyDescriptor(_class$4.prototype, "update"), _class$4.prototype), _applyDecoratedDescriptor(_class$4.prototype, "delete", [_dec3$1], Object.getOwnPropertyDescriptor(_class$4.prototype, "delete"), _class$4.prototype)), _class$4));

  var _dec$3, _dec2$1, _dec3, _class$3;

  var NodeManager = (_dec$3 = pluginHook({
    after: "nodeAdded"
  }), _dec2$1 = pluginHook({
    before: "beforeNodeUpdated",
    after: "nodeUpdated"
  }), _dec3 = pluginHook({
    before: "beforeNodeDeleted"
  }), (_class$3 = /*#__PURE__*/function () {
    function NodeManager(oasis) {
      this.oasis = oasis;
      this.nodeMap = {};
      this.root = void 0;
      this.root = new Entity(this.oasis.engine, "root");
    }

    var _proto = NodeManager.prototype;

    _proto.addRootEntity = function addRootEntity() {
      this.oasis.engine.sceneManager.activeScene.addRootEntity(this.root);
    };

    _proto.add = function add(nodeConfig) {
      this.create(nodeConfig);
      this.append(nodeConfig.id, nodeConfig.parent, nodeConfig.index);
      return this.get(nodeConfig.id);
    };

    _proto.update = function update(id, key, value) {
      this.get(id)[key] = value;
      return {
        id: id,
        key: key,
        value: value
      };
    };

    _proto.get = function get(id) {
      return this.nodeMap[id];
    };

    _proto.reset = function reset() {
      this.nodeMap = {};
    };

    _proto.delete = function _delete(id) {
      this.nodeMap[id].destroy();
      delete this.nodeMap[id];
    };

    _proto.create = function create(nodeConfig) {
      var isActive = nodeConfig.isActive,
          position = nodeConfig.position,
          rotation = nodeConfig.rotation,
          scale = nodeConfig.scale,
          id = nodeConfig.id,
          name = nodeConfig.name;
      var entity = new Entity(this.oasis.engine, name);
      entity.isActive = isActive;
      entity.transform.position = new Vector3(position[0], position[1], position[2]);
      entity.transform.rotation = new Vector3(rotation[0], rotation[1], rotation[2]);
      entity.transform.scale = new Vector3(scale[0], scale[1], scale[2]);
      entity.id = id;
      this.nodeMap[id] = entity;
      return entity;
    };

    _proto.append = function append(childId, parentId, index) {
      var child = this.nodeMap[childId];
      var parent = this.nodeMap[parentId] || this.root;
      parent.addChild(child); //@ts-ignore

      var children = parent._children;
      var currentIndex = children.length - 1;
      switchElementsIndex(children, currentIndex, index);
    };

    return NodeManager;
  }(), (_applyDecoratedDescriptor(_class$3.prototype, "add", [_dec$3], Object.getOwnPropertyDescriptor(_class$3.prototype, "add"), _class$3.prototype), _applyDecoratedDescriptor(_class$3.prototype, "update", [_dec2$1], Object.getOwnPropertyDescriptor(_class$3.prototype, "update"), _class$3.prototype), _applyDecoratedDescriptor(_class$3.prototype, "delete", [_dec3], Object.getOwnPropertyDescriptor(_class$3.prototype, "delete"), _class$3.prototype)), _class$3));

  var _dec$2, _class$2;

  var SceneManager = (_dec$2 = pluginHook({
    before: "beforeSceneUpdated",
    after: "sceneUpdated"
  }), (_class$2 = /*#__PURE__*/function () {
    function SceneManager(oasis) {
      this.oasis = oasis;
    }

    var _proto = SceneManager.prototype;

    _proto.init = function init() {
      var _this = this;

      var scene = this.oasis.options.config.scene;

      if (scene) {
        Object.keys(scene).forEach(function (field) {
          var fieldConfig = scene[field];
          Object.keys(fieldConfig.props).forEach(function (key) {
            var prop = fieldConfig.props[key];

            _this.setProp(field, key, prop);
          });
        });
      }
    };

    _proto.update = function update(field, key, value) {
      this.setProp(field, key, value);
      return {
        field: field,
        key: key,
        value: value
      };
    };

    _proto.setProp = function setProp(field, key, prop) {
      var scene = this.oasis.engine.sceneManager.activeScene;

      if (field === "background" && key === "skyboxTexture") {
        var sky = scene.background.sky;

        if (prop) {
          sky.mesh = PrimitiveMesh.createCuboid(scene.engine, 2, 2, 2);
          var skyMaterial = new SkyBoxMaterial(scene.engine);
          skyMaterial.textureCubeMap = this.oasis.resourceManager.get(prop.id).resource;
          sky.material = skyMaterial;
        } else {
          sky.mesh = null;
          sky.material = null;
        }
      } else if (scene[field]) {
        if (prop && prop.type === "asset") {
          scene[field][key] = this.oasis.resourceManager.get(prop.id).resource;
        } else {
          scene[field][key] = prop;
        }
      }
    };

    return SceneManager;
  }(), _applyDecoratedDescriptor(_class$2.prototype, "update", [_dec$2], Object.getOwnPropertyDescriptor(_class$2.prototype, "update"), _class$2.prototype), _class$2));

  var SpriteAtlasResource = /*#__PURE__*/function (_SchemaResource) {
    _inheritsLoose(SpriteAtlasResource, _SchemaResource);

    function SpriteAtlasResource() {
      return _SchemaResource.apply(this, arguments) || this;
    }

    var _proto = SpriteAtlasResource.prototype;

    _proto.load = function load(resourceManager, assetConfig) {
      var _this = this;

      return new Promise(function (resolve) {
        _this.setMeta();

        if (assetConfig.source) {
          resourceManager.load({
            url: assetConfig.source,
            type: exports.AssetType.SpriteAtlas
          }).then(function (spriteAtlas) {
            _this._resource = spriteAtlas;
            var sprites = spriteAtlas.sprites;
            var schemaResourceManager = _this.resourceManager;

            for (var index = sprites.length - 1; index >= 0; index--) {
              var sprite = sprites[index];
              var spriteResource = new SpriteResource(schemaResourceManager, sprite); // @ts-ignore

              var assetID = sprite._assetID; // @ts-ignore

              schemaResourceManager.maxId = Math.max(assetID, schemaResourceManager.maxId); // @ts-ignore

              schemaResourceManager.resourceMap[assetID] = spriteResource; // @ts-ignore

              schemaResourceManager.resourceIdMap.set(spriteResource, "" + assetID);
            }

            resolve(_this);
          });
        } else {
          if (!SpriteAtlasResource.defaultAtlas) {
            SpriteAtlasResource.defaultAtlas = new SpriteAtlas(resourceManager.engine);
          }

          _this._resource = SpriteAtlasResource.defaultAtlas;
          resolve(_this);
        }
      });
    };

    _proto.setMeta = function setMeta() {
      if (this.resource) {
        this.meta.name = this.resource.name;
      }
    };

    _proto.getProps = function getProps() {
      var _this2 = this;

      var result = {};
      var props = getAllGetters(this.resource);
      props.forEach(function (prop) {
        return result[prop] = _this2.resource[prop];
      });
      return result;
    };

    _proto.update = function update() {};

    return SpriteAtlasResource;
  }(SchemaResource);

  SpriteAtlasResource.defaultAtlas = void 0;

  var _dec$1, _dec2, _class$1;

  var RESOURCE_CLASS = {
    script: ScriptResource,
    gltf: GLTFResource,
    texture: TextureResource,
    // 'image': TextureResource,
    cubeTexture: TextureCubeMapResource,
    PBRMaterial: PBRMaterialResource,
    PBRSpecularMaterial: PBRSpecularMaterialResource,
    UnlitMaterial: UnlitMaterialResource,
    BlinnPhongMaterial: BlinnPhongMaterialResource,
    base: BaseResource,
    sprite: SpriteResource,
    SpriteAtlas: SpriteAtlasResource,
    animatorController: AnimatorControllerResource,
    animationClip: AnimationClipResource
  };
  var RESOURCE_TYPE = new Map();

  for (var key in RESOURCE_CLASS) {
    if (RESOURCE_CLASS.hasOwnProperty(key)) {
      var element = RESOURCE_CLASS[key];
      RESOURCE_TYPE.set(element, key);
    }
  }

  var resourceFactory = {
    createResource: function createResource(resourceManager, type) {
      return new RESOURCE_CLASS[type](resourceManager);
    }
  };

  function registerResource(type, resource) {
    if (!RESOURCE_CLASS.hasOwnProperty(type)) {
      RESOURCE_CLASS[type] = resource;
      RESOURCE_TYPE.set(resource, type);
    }
  }

  var SchemaResourceManager = (_dec$1 = pluginHook({
    before: "beforeResourceRemove"
  }), _dec2 = pluginHook({
    after: "resourceUpdated",
    before: "beforeResourceUpdate"
  }), (_class$1 = /*#__PURE__*/function () {
    function SchemaResourceManager(oasis) {
      this.oasis = oasis;
      this.resourceMap = {};
      this.resourceIdMap = new WeakMap();
      this.maxId = 0;
      this.engineResourceManager = void 0;
      this.engineResourceManager = this.oasis.engine.resourceManager;
    }

    var _proto = SchemaResourceManager.prototype;

    _proto.load = function load(asset) {
      var _this = this;

      var resource = resourceFactory.createResource(this, asset.type);
      var loadPromise = resource.load(this.oasis.engine.resourceManager, asset, this.oasis);
      this.maxId = Math.max(+asset.id, this.maxId);
      loadPromise.then(function () {
        _this.resourceMap[asset.id] = resource;

        _this.resourceIdMap.set(resource, asset.id);
      });
      return loadPromise;
    };

    _proto.add = function add(asset) {
      var _this2 = this;

      var resource = resourceFactory.createResource(this, asset.type);
      return new Promise(function (resolve) {
        resource.loadWithAttachedResources(_this2.oasis.engine.resourceManager, asset, _this2.oasis).then(function (result) {
          resolve(_this2.getAddResourceResult(result.resources, result.structure));
        });
      });
    };

    _proto.remove = function remove(id) {
      var _this3 = this;

      return new Promise(function (resolve) {
        var resource = _this3.resourceMap[id];
        var result = [id];
        var hasAttachedResource = false;
        delete _this3.resourceMap[id];

        if (resource) {
          var attached = resource.attachedResources;

          for (var index = 0; index < attached.length; index++) {
            var attachedResource = attached[index];

            var attachedResourceId = _this3.resourceIdMap.get(attachedResource);

            if (attachedResourceId) {
              hasAttachedResource = true;

              _this3.remove(attachedResourceId).then(function (attachedResourceRemoveResult) {
                result.push.apply(result, attachedResourceRemoveResult);
                resolve(result);
              });
            }
          }
        }

        if (!hasAttachedResource) {
          resolve(result);
        }
      });
    };

    _proto.update = function update(id, key, value) {
      var resource = this.get(id);

      if (resource) {
        resource.update(key, value);
      }

      return {
        resource: resource,
        id: id,
        key: key,
        value: value
      };
    };

    _proto.updateMeta = function updateMeta(id, key, value) {
      var resource = this.get(id);

      if (resource) {
        resource.updateMeta(key, value);
      }
    };

    _proto.get = function get(id) {
      return this.resourceMap[id];
    };

    _proto.getAll = function getAll() {
      return ObjectValues(this.resourceMap);
    };

    _proto.getAddResourceResult = function getAddResourceResult(resources, structure) {
      var _this4 = this;

      var addResourceResult = {};
      var resource = resources[structure.index];
      var id = "" + ++this.maxId;
      this.resourceMap[id] = resource;
      this.resourceIdMap.set(resource, id);
      addResourceResult.id = this.maxId;
      addResourceResult.type = RESOURCE_TYPE.get(resource.constructor);
      addResourceResult.meta = resource.meta;
      addResourceResult.props = {};

      for (var _key in structure.props) {
        if (structure.props.hasOwnProperty(_key)) {
          var _element = structure.props[_key];

          if (_element) {
            if (Array.isArray(_element)) {
              addResourceResult.props[_key] = _element.map(function (child) {
                return _this4.getAddResourceResult(resources, child);
              });
            } else {
              addResourceResult.props[_key] = this.getAddResourceResult(resources, _element);
            }
          }
        }
      }

      return addResourceResult;
    };

    _createClass(SchemaResourceManager, [{
      key: "isLocal",
      get: function get() {
        return this.oasis.options.local;
      }
    }, {
      key: "useCompressedTexture",
      get: function get() {
        var _this$oasis$options$u;

        return (_this$oasis$options$u = this.oasis.options.useCompressedTexture) != null ? _this$oasis$options$u : true;
      }
    }]);

    return SchemaResourceManager;
  }(), (_applyDecoratedDescriptor(_class$1.prototype, "remove", [_dec$1], Object.getOwnPropertyDescriptor(_class$1.prototype, "remove"), _class$1.prototype), _applyDecoratedDescriptor(_class$1.prototype, "update", [_dec2], Object.getOwnPropertyDescriptor(_class$1.prototype, "update"), _class$1.prototype)), _class$1));

  var _dec, _class;

  var Oasis = (_dec = pluginHook({
    after: "schemaParsed"
  }), (_class = /*#__PURE__*/function (_EventDispatcher) {
    _inheritsLoose(Oasis, _EventDispatcher);

    function Oasis(_options, pluginManager) {
      var _options$scripts;

      var _this;

      _this = _EventDispatcher.call(this, _options.engine) || this;
      _this._options = _options;
      _this.pluginManager = pluginManager;
      _this.nodeManager = void 0;
      _this.abilityManager = void 0;
      _this.sceneManager = void 0;
      _this.resourceManager = void 0;
      _this._canvas = void 0;
      _this.schema = void 0;
      _this.timeout = void 0;
      _this.oasis = _assertThisInitialized(_this);
      _this.schema = _options.config;
      _this.timeout = _options.timeout;
      _options.scripts = (_options$scripts = _options.scripts) != null ? _options$scripts : {};
      _this.nodeManager = new NodeManager(_assertThisInitialized(_this));
      _this.abilityManager = new AbilityManager(_assertThisInitialized(_this));
      _this.nodeManager.add = _this.nodeManager.add.bind(_this.nodeManager);
      _this.abilityManager.add = _this.abilityManager.add.bind(_this.abilityManager);
      _this.resourceManager = new SchemaResourceManager(_assertThisInitialized(_this));
      _this.sceneManager = new SceneManager(_assertThisInitialized(_this));

      if (_options.fps) {
        _this.engine.targetFrameRate = _options.fps;
        _this.engine.vSyncCount = 0;
      }

      return _this;
    }

    var _proto = Oasis.prototype;

    _proto.updateConfig = function updateConfig(config) {
      this.schema = config;
      this.init();
    };

    _proto.init = function init() {
      var _this2 = this;

      return this.loadResources().then(function () {
        _this2.bindResources();

        _this2.parseEntities();

        _this2.attach();

        _this2.nodeManager.addRootEntity();

        _this2.sceneManager.init();

        _this2.parseNodeAbilities();

        _this2.pluginManager.boot(_this2);
      });
    };

    _proto.loadResources = function loadResources() {
      var _this3 = this;

      var _this$schema$assets = this.schema.assets,
          assets = _this$schema$assets === void 0 ? {} : _this$schema$assets;
      var loadingPromises = ObjectValues(assets).filter(function (asset) {
        if (RESOURCE_CLASS[asset.type]) {
          return true;
        }

        console.warn(asset.type + " loader is not defined. the " + asset.type + " type will be ignored.");
        return false;
      }).map(function (asset) {
        return _this3.resourceManager.load(asset);
      });
      return Promise.all(loadingPromises);
    };

    _proto.bindResources = function bindResources() {
      this.resourceManager.getAll().forEach(function (resource) {
        resource.bind();
      });
    };

    _proto.parseEntities = function parseEntities() {
      var nodes = this.schema.nodes;
      var indices = this.bfsNodes();
      indices.map(function (index) {
        return nodes[index];
      }).forEach(this.nodeManager.add);
    };

    _proto.parseNodeAbilities = function parseNodeAbilities() {
      var abilities = this.schema.abilities;
      Object.keys(abilities).map(function (id) {
        return _objectSpread2({
          id: id
        }, abilities[id]);
      }).forEach(this.abilityManager.add);
    };

    _proto.bfsNodes = function bfsNodes() {
      var nodes = this.schema.nodes;
      var roots = ObjectValues(nodes).filter(function (node) {
        return !nodes[node.parent];
      }).map(function (node) {
        return node.id;
      });
      var result = [];

      var traverseChildren = function traverseChildren(roots) {
        result = result.concat(roots);
        roots.forEach(function (id) {
          var children = nodes[id].children;
          children && traverseChildren(children);
        });
      };

      traverseChildren(roots);
      return result;
    };

    _proto.attach = function attach() {
      this.resourceManager.getAll().forEach(function (resource) {
        resource.attach();
      });
    };

    Oasis.create = function create(options, pluginManager) {
      var oasis = new Oasis(options, pluginManager);
      return oasis.init().then(function () {
        options.autoPlay && oasis.engine.run();
        return oasis;
      });
    };

    _createClass(Oasis, [{
      key: "canvas",
      get: function get() {
        return this._options.canvas;
      }
    }, {
      key: "options",
      get: function get() {
        return this._options;
      }
    }]);

    return Oasis;
  }(EventDispatcher), _applyDecoratedDescriptor(_class.prototype, "init", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "init"), _class.prototype), _class));

  Parser.registerComponents("o3", {
    GLTFModel: GLTFModel,
    SpriteRenderer: SpriteRenderer,
    SpriteMask: SpriteMask,
    PointLight: PointLight,
    AmbientLight: AmbientLight,
    DirectLight: DirectLight,
    ParticleRenderer: ParticleRenderer,
    BoxCollider: BoxCollider,
    Camera: Camera,
    Model: Model,
    Component: Component,
    SphereCollider: SphereCollider,
    Animator: Animator
  }); //@ts-ignore

  var version = "0.5.7";
  console.log("oasis engine version: " + version);

  exports.ABoxCollider = ABoxCollider;
  exports.ACollider = Collider;
  exports.ASphereCollider = ASphereCollider;
  exports.AmbientLight = AmbientLight;
  exports.AnimationClip = AnimationClip;
  exports.AnimationClipCurveBinding = AnimationClipCurveBinding;
  exports.AnimationCurve = AnimationCurve;
  exports.AnimationEvent = AnimationEvent;
  exports.Animator = Animator;
  exports.AnimatorController = AnimatorController;
  exports.AnimatorControllerLayer = AnimatorControllerLayer;
  exports.AnimatorState = AnimatorState;
  exports.AnimatorStateMachine = AnimatorStateMachine;
  exports.AnimatorStateTransition = AnimatorStateTransition;
  exports.AssetPromise = AssetPromise;
  exports.Background = Background;
  exports.BaseMaterial = BaseMaterial;
  exports.BasicRenderPipeline = BasicRenderPipeline;
  exports.BlendShape = BlendShape;
  exports.BlendShapeFrame = BlendShapeFrame;
  exports.BlinnPhongMaterial = BlinnPhongMaterial;
  exports.BoundingBox = BoundingBox;
  exports.BoundingFrustum = BoundingFrustum;
  exports.BoundingSphere = BoundingSphere;
  exports.BoxCollider = BoxCollider;
  exports.Buffer = Buffer;
  exports.BufferMesh = BufferMesh;
  exports.BufferUtil = BufferUtil;
  exports.Camera = Camera;
  exports.CloneManager = CloneManager;
  exports.ColliderFeature = ColliderFeature;
  exports.CollisionDetection = CollisionDetection;
  exports.CollisionUtil = CollisionUtil;
  exports.Color = Color;
  exports.Component = Component;
  exports.CubeProbe = CubeProbe;
  exports.DirectLight = DirectLight;
  exports.EXP2Fog = EXP2Fog;
  exports.Engine = Engine;
  exports.EngineFeature = EngineFeature;
  exports.EngineObject = EngineObject;
  exports.Entity = Entity;
  exports.Event = Event;
  exports.EventDispatcher = EventDispatcher;
  exports.Fog = Fog;
  exports.GLTFModel = GLTFModel;
  exports.GLTFResource = GLTFResource$1;
  exports.HitResult = HitResult;
  exports.IndexBufferBinding = IndexBufferBinding;
  exports.InterpolableKeyframe = InterpolableKeyframe;
  exports.Keyframe = Keyframe;
  exports.Light = Light;
  exports.LinearFog = LinearFog;
  exports.Loader = Loader;
  exports.Logger = Logger;
  exports.Material = Material;
  exports.MathUtil = MathUtil;
  exports.Matrix = Matrix;
  exports.Matrix3x3 = Matrix3x3;
  exports.Mesh = Mesh;
  exports.MeshRenderer = MeshRenderer;
  exports.Model = Model;
  exports.ModelMesh = ModelMesh;
  exports.Oasis = Oasis;
  exports.ObjectValues = ObjectValues;
  exports.PBRBaseMaterial = PBRBaseMaterial;
  exports.PBRMaterial = PBRMaterial;
  exports.PBRSpecularMaterial = PBRSpecularMaterial;
  exports.Parser = Parser;
  exports.ParticleRenderer = ParticleRenderer;
  exports.PhysicsManager = PhysicsManager;
  exports.Plane = Plane;
  exports.PlaneCollider = PlaneCollider;
  exports.PointLight = PointLight;
  exports.PrimitiveMesh = PrimitiveMesh;
  exports.Probe = Probe;
  exports.Quaternion = Quaternion;
  exports.Ray = Ray;
  exports.Rect = Rect;
  exports.RefObject = RefObject;
  exports.RenderColorTexture = RenderColorTexture;
  exports.RenderDepthTexture = RenderDepthTexture;
  exports.RenderElement = RenderElement;
  exports.RenderPass = RenderPass;
  exports.RenderQueue = RenderQueue;
  exports.RenderTarget = RenderTarget;
  exports.Renderer = Renderer;
  exports.ResourceManager = ResourceManager;
  exports.Scene = Scene;
  exports.SceneFeature = SceneFeature;
  exports.SceneManager = SceneManager$1;
  exports.SchemaResource = SchemaResource;
  exports.Script = Script;
  exports.Shader = Shader;
  exports.ShaderData = ShaderData;
  exports.ShaderFactory = ShaderFactory;
  exports.Skin = Skin;
  exports.SkinnedMeshRenderer = SkinnedMeshRenderer;
  exports.Sky = Sky;
  exports.SkyBoxMaterial = SkyBoxMaterial;
  exports.SphereCollider = SphereCollider;
  exports.SphericalHarmonics3 = SphericalHarmonics3;
  exports.SpotLight = SpotLight;
  exports.Sprite = Sprite;
  exports.SpriteAtlas = SpriteAtlas;
  exports.SpriteElement = SpriteElement;
  exports.SpriteMask = SpriteMask;
  exports.SpriteRenderer = SpriteRenderer;
  exports.SubMesh = SubMesh;
  exports.SystemInfo = SystemInfo;
  exports.Texture = Texture;
  exports.Texture2D = Texture2D;
  exports.TextureCubeMap = TextureCubeMap;
  exports.Time = Time;
  exports.TrailMaterial = TrailMaterial;
  exports.TrailRenderer = TrailRenderer;
  exports.Transform = Transform;
  exports.UnlitMaterial = UnlitMaterial;
  exports.UpdateFlag = UpdateFlag;
  exports.Util = Util;
  exports.Vector2 = Vector2;
  exports.Vector3 = Vector3;
  exports.Vector4 = Vector4;
  exports.VertexBufferBinding = VertexBufferBinding;
  exports.VertexElement = VertexElement;
  exports.WebCanvas = WebCanvas;
  exports.WebGLEngine = WebGLEngine;
  exports.WebGLRenderer = WebGLRenderer;
  exports.assignmentClone = assignmentClone;
  exports.deepClone = deepClone;
  exports.dependencies = dependencies;
  exports.ignoreClone = ignoreClone;
  exports.parseSingleKTX = parseSingleKTX;
  exports.parser = parser;
  exports.registerResource = registerResource;
  exports.request = request;
  exports.resourceLoader = resourceLoader;
  exports.script = script;
  exports.shallowClone = shallowClone;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
