'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var miniprogramAdapter = require('@oasis-engine/miniprogram-adapter');
var miniprogram = require('@oasis-engine/core/dist/miniprogram');
var miniprogram$1 = require('@oasis-engine/math/dist/miniprogram');
var miniprogram$2 = require('@oasis-engine/rhi-webgl/dist/miniprogram');
var miniprogram$3 = require('@oasis-engine/draco/dist/miniprogram');

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }

  return desc;
}

var _dec$j, _class$j;

function isBase64(url) {
  return /^data:(.+?);base64,/.test(url);
}

(_dec$j = miniprogram.resourceLoader(miniprogram.AssetType.Buffer, ["bin", "r3bin"], false), _dec$j(_class$j = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(BufferLoader, _Loader);

  function BufferLoader() {
    return _Loader.apply(this, arguments) || this;
  }

  var _proto = BufferLoader.prototype;

  _proto.load = function load(item) {
    var url = item.url;

    if (isBase64(url)) {
      return new miniprogram.AssetPromise(function (resolve) {
        var base64Str = url.slice(13 + RegExp.$1.length);
        var result = Uint8Array.from(miniprogramAdapter.atob(base64Str), function (c) {
          return c.charCodeAt(0);
        });
        resolve(result.buffer);
      });
    }

    return this.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
      type: "arraybuffer"
    }));
  };

  return BufferLoader;
}(miniprogram.Loader)) || _class$j);

/**
 * Module for glTF 2.0 Interface
 */

/**
 * The datatype of the components in the attribute
 */
var AccessorComponentType;
/**
 * Specifies if the attirbute is a scalar, vector, or matrix
 */

(function (AccessorComponentType) {
  AccessorComponentType[AccessorComponentType["BYTE"] = 5120] = "BYTE";
  AccessorComponentType[AccessorComponentType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  AccessorComponentType[AccessorComponentType["SHORT"] = 5122] = "SHORT";
  AccessorComponentType[AccessorComponentType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  AccessorComponentType[AccessorComponentType["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  AccessorComponentType[AccessorComponentType["FLOAT"] = 5126] = "FLOAT";
})(AccessorComponentType || (AccessorComponentType = {}));

var AccessorType;
/**
 * The name of the node's TRS property to modify, or the weights of the Morph Targets it instantiates
 */

(function (AccessorType) {
  AccessorType["SCALAR"] = "SCALAR";
  AccessorType["VEC2"] = "VEC2";
  AccessorType["VEC3"] = "VEC3";
  AccessorType["VEC4"] = "VEC4";
  AccessorType["MAT2"] = "MAT2";
  AccessorType["MAT3"] = "MAT3";
  AccessorType["MAT4"] = "MAT4";
})(AccessorType || (AccessorType = {}));

var AnimationChannelTargetPath;
/**
 * Interpolation algorithm
 */

(function (AnimationChannelTargetPath) {
  AnimationChannelTargetPath["TRANSLATION"] = "translation";
  AnimationChannelTargetPath["ROTATION"] = "rotation";
  AnimationChannelTargetPath["SCALE"] = "scale";
  AnimationChannelTargetPath["WEIGHTS"] = "weights";
})(AnimationChannelTargetPath || (AnimationChannelTargetPath = {}));

var AnimationSamplerInterpolation;
/**
 * A camera's projection.  A node can reference a camera to apply a transform to place the camera in the scene
 */

(function (AnimationSamplerInterpolation) {
  AnimationSamplerInterpolation["Linear"] = "LINEAR";
  AnimationSamplerInterpolation["Step"] = "STEP";
  AnimationSamplerInterpolation["CubicSpine"] = "CUBICSPLINE";
})(AnimationSamplerInterpolation || (AnimationSamplerInterpolation = {}));

var CameraType;
/**
 * The mime-type of the image
 */

(function (CameraType) {
  CameraType["PERSPECTIVE"] = "perspective";
  CameraType["ORTHOGRAPHIC"] = "orthographic";
})(CameraType || (CameraType = {}));

var ImageMimeType;
/**
 * The alpha rendering mode of the material
 */

(function (ImageMimeType) {
  ImageMimeType["JPEG"] = "image/jpeg";
  ImageMimeType["PNG"] = "image/png";
})(ImageMimeType || (ImageMimeType = {}));

var MaterialAlphaMode;
/**
 * Magnification filter.  Valid values correspond to WebGL enums: 9728 (NEAREST) and 9729 (LINEAR)
 */

(function (MaterialAlphaMode) {
  MaterialAlphaMode["OPAQUE"] = "OPAQUE";
  MaterialAlphaMode["MASK"] = "MASK";
  MaterialAlphaMode["BLEND"] = "BLEND";
})(MaterialAlphaMode || (MaterialAlphaMode = {}));

var TextureMagFilter;
/**
 * Minification filter.  All valid values correspond to WebGL enums
 */

(function (TextureMagFilter) {
  TextureMagFilter[TextureMagFilter["NEAREST"] = 9728] = "NEAREST";
  TextureMagFilter[TextureMagFilter["LINEAR"] = 9729] = "LINEAR";
})(TextureMagFilter || (TextureMagFilter = {}));

var TextureMinFilter;
/**
 * S (U) wrapping mode.  All valid values correspond to WebGL enums
 */

(function (TextureMinFilter) {
  TextureMinFilter[TextureMinFilter["NEAREST"] = 9728] = "NEAREST";
  TextureMinFilter[TextureMinFilter["LINEAR"] = 9729] = "LINEAR";
  TextureMinFilter[TextureMinFilter["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
  TextureMinFilter[TextureMinFilter["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  TextureMinFilter[TextureMinFilter["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
  TextureMinFilter[TextureMinFilter["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(TextureMinFilter || (TextureMinFilter = {}));

var TextureWrapMode;
/**
 * glTF Property
 */

(function (TextureWrapMode) {
  TextureWrapMode[TextureWrapMode["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
  TextureWrapMode[TextureWrapMode["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  TextureWrapMode[TextureWrapMode["REPEAT"] = 10497] = "REPEAT";
})(TextureWrapMode || (TextureWrapMode = {}));

/**
 * @internal
 */

var GLTFUtil = /*#__PURE__*/function () {
  function GLTFUtil() {}

  GLTFUtil.floatBufferToVector2Array = function floatBufferToVector2Array(buffer) {
    var bufferLen = buffer.length;
    var array = new Array(bufferLen / 2);

    for (var i = 0; i < bufferLen; i += 2) {
      array[i / 2] = new miniprogram$1.Vector2(buffer[i], buffer[i + 1]);
    }

    return array;
  };

  GLTFUtil.floatBufferToVector3Array = function floatBufferToVector3Array(buffer) {
    var bufferLen = buffer.length;
    var array = new Array(bufferLen / 3);

    for (var i = 0; i < bufferLen; i += 3) {
      array[i / 3] = new miniprogram$1.Vector3(buffer[i], buffer[i + 1], buffer[i + 2]);
    }

    return array;
  };

  GLTFUtil.floatBufferToVector4Array = function floatBufferToVector4Array(buffer) {
    var bufferLen = buffer.length;
    var array = new Array(bufferLen / 4);

    for (var i = 0; i < bufferLen; i += 4) {
      array[i / 4] = new miniprogram$1.Vector4(buffer[i], buffer[i + 1], buffer[i + 2], buffer[i + 3]);
    }

    return array;
  }
  /**
   * Parse binary text for glb loader.
   */
  ;

  GLTFUtil.decodeText = function decodeText(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    } // TextDecoder polyfill


    var s = "";

    for (var i = 0, il = array.length; i < il; i++) {
      s += String.fromCharCode(array[i]);
    }

    return decodeURIComponent(encodeURIComponent(s));
  }
  /**
   * Get the number of bytes occupied by accessor type.
   */
  ;

  GLTFUtil.getAccessorTypeSize = function getAccessorTypeSize(accessorType) {
    switch (accessorType) {
      case AccessorType.SCALAR:
        return 1;

      case AccessorType.VEC2:
        return 2;

      case AccessorType.VEC3:
        return 3;

      case AccessorType.VEC4:
        return 4;

      case AccessorType.MAT2:
        return 4;

      case AccessorType.MAT3:
        return 9;

      case AccessorType.MAT4:
        return 16;
    }
  }
  /**
   * Get the TypedArray corresponding to the component type.
   */
  ;

  GLTFUtil.getComponentType = function getComponentType(componentType) {
    switch (componentType) {
      case AccessorComponentType.BYTE:
        return Int8Array;

      case AccessorComponentType.UNSIGNED_BYTE:
        return Uint8Array;

      case AccessorComponentType.SHORT:
        return Int16Array;

      case AccessorComponentType.UNSIGNED_SHORT:
        return Uint16Array;

      case AccessorComponentType.UNSIGNED_INT:
        return Uint32Array;

      case AccessorComponentType.FLOAT:
        return Float32Array;
    }
  }
  /**
   * Get accessor data.
   */
  ;

  GLTFUtil.getAccessorData = function getAccessorData(gltf, accessor, buffers) {
    var _bufferView$byteStrid;

    var bufferViews = gltf.bufferViews;
    var bufferView = bufferViews[accessor.bufferView];
    var arrayBuffer = buffers[bufferView.buffer];
    var accessorByteOffset = accessor.hasOwnProperty("byteOffset") ? accessor.byteOffset : 0;
    var bufferViewByteOffset = bufferView.hasOwnProperty("byteOffset") ? bufferView.byteOffset : 0;
    var byteOffset = accessorByteOffset + bufferViewByteOffset;
    var accessorTypeSize = GLTFUtil.getAccessorTypeSize(accessor.type);
    var length = accessorTypeSize * accessor.count;
    var byteStride = (_bufferView$byteStrid = bufferView.byteStride) != null ? _bufferView$byteStrid : 0;
    var arrayType = GLTFUtil.getComponentType(accessor.componentType);
    var uint8Array;

    if (byteStride) {
      var accessorByteSize = accessorTypeSize * arrayType.BYTES_PER_ELEMENT;
      uint8Array = new Uint8Array(accessor.count * accessorByteSize);
      var originalBufferView = new Uint8Array(arrayBuffer, bufferViewByteOffset, bufferView.byteLength);

      for (var i = 0; i < accessor.count; i++) {
        for (var j = 0; j < accessorByteSize; j++) {
          uint8Array[i * accessorByteSize + j] = originalBufferView[i * byteStride + accessorByteOffset + j];
        }
      }
    } else {
      uint8Array = new Uint8Array(arrayBuffer.slice(byteOffset, byteOffset + length * arrayType.BYTES_PER_ELEMENT));
    }

    var typedArray = new arrayType(uint8Array.buffer);

    if (accessor.sparse) {
      var _indices$byteOffset, _indicesBufferView$by, _values$byteOffset, _valuesBufferView$byt;

      var _accessor$sparse = accessor.sparse,
          count = _accessor$sparse.count,
          indices = _accessor$sparse.indices,
          values = _accessor$sparse.values;
      var indicesBufferView = bufferViews[indices.bufferView];
      var valuesBufferView = bufferViews[values.bufferView];
      var indicesArrayBuffer = buffers[indicesBufferView.buffer];
      var valuesArrayBuffer = buffers[valuesBufferView.buffer];
      var indicesByteOffset = ((_indices$byteOffset = indices.byteOffset) != null ? _indices$byteOffset : 0) + ((_indicesBufferView$by = indicesBufferView.byteOffset) != null ? _indicesBufferView$by : 0);
      var indicesByteLength = indicesBufferView.byteLength;
      var valuesByteOffset = ((_values$byteOffset = values.byteOffset) != null ? _values$byteOffset : 0) + ((_valuesBufferView$byt = valuesBufferView.byteOffset) != null ? _valuesBufferView$byt : 0);
      var valuesByteLength = valuesBufferView.byteLength;
      var indicesType = GLTFUtil.getComponentType(indices.componentType);
      var indicesArray = new indicesType(indicesArrayBuffer, indicesByteOffset, indicesByteLength / indicesType.BYTES_PER_ELEMENT);
      var valuesArray = new arrayType(valuesArrayBuffer, valuesByteOffset, valuesByteLength / arrayType.BYTES_PER_ELEMENT);

      for (var _i = 0; _i < count; _i++) {
        var replaceIndex = indicesArray[_i];

        for (var _j = 0; _j < accessorTypeSize; _j++) {
          typedArray[replaceIndex * accessorTypeSize + _j] = valuesArray[_i * accessorTypeSize + _j];
        }
      }
    }

    return typedArray;
  };

  GLTFUtil.getBufferViewData = function getBufferViewData(bufferView, buffers) {
    var buffer = bufferView.buffer,
        _bufferView$byteOffse = bufferView.byteOffset,
        byteOffset = _bufferView$byteOffse === void 0 ? 0 : _bufferView$byteOffse,
        byteLength = bufferView.byteLength;
    var arrayBuffer = buffers[buffer];
    return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
  };

  GLTFUtil.getVertexStride = function getVertexStride(gltf, accessor) {
    var _accessor$bufferView;

    var stride = gltf.bufferViews[(_accessor$bufferView = accessor.bufferView) != null ? _accessor$bufferView : 0].byteStride;

    if (stride) {
      return stride;
    }

    var size = GLTFUtil.getAccessorTypeSize(accessor.type);
    var componentType = GLTFUtil.getComponentType(accessor.componentType);
    return size * componentType.BYTES_PER_ELEMENT;
  };

  GLTFUtil.createVertexElement = function createVertexElement(semantic, accessor, index) {
    var size = GLTFUtil.getAccessorTypeSize(accessor.type);
    return new miniprogram.VertexElement(semantic, 0, GLTFUtil.getElementFormat(accessor.componentType, size, accessor.normalized), index);
  };

  GLTFUtil.getIndexFormat = function getIndexFormat(type) {
    switch (type) {
      case AccessorComponentType.UNSIGNED_BYTE:
        return miniprogram.IndexFormat.UInt8;

      case AccessorComponentType.UNSIGNED_SHORT:
        return miniprogram.IndexFormat.UInt16;

      case AccessorComponentType.UNSIGNED_INT:
        return miniprogram.IndexFormat.UInt32;
    }
  };

  GLTFUtil.getElementFormat = function getElementFormat(type, size, normalized) {
    if (normalized === void 0) {
      normalized = false;
    }

    if (type == AccessorComponentType.FLOAT) {
      switch (size) {
        case 1:
          return miniprogram.VertexElementFormat.Float;

        case 2:
          return miniprogram.VertexElementFormat.Vector2;

        case 3:
          return miniprogram.VertexElementFormat.Vector3;

        case 4:
          return miniprogram.VertexElementFormat.Vector4;
      }
    }

    if (type == AccessorComponentType.SHORT) {
      switch (size) {
        case 2:
          return normalized ? miniprogram.VertexElementFormat.NormalizedShort2 : miniprogram.VertexElementFormat.Short2;

        case 3:
        case 4:
          return normalized ? miniprogram.VertexElementFormat.NormalizedShort4 : miniprogram.VertexElementFormat.Short4;
      }
    }

    if (type == AccessorComponentType.UNSIGNED_SHORT) {
      switch (size) {
        case 2:
          return normalized ? miniprogram.VertexElementFormat.NormalizedUShort2 : miniprogram.VertexElementFormat.UShort2;

        case 3:
        case 4:
          return normalized ? miniprogram.VertexElementFormat.NormalizedUShort4 : miniprogram.VertexElementFormat.UShort4;
      }
    }

    if (type == AccessorComponentType.BYTE) {
      switch (size) {
        case 2:
        case 3:
        case 4:
          return normalized ? miniprogram.VertexElementFormat.NormalizedByte4 : miniprogram.VertexElementFormat.Byte4;
      }
    }

    if (type == AccessorComponentType.UNSIGNED_BYTE) {
      switch (size) {
        case 2:
        case 3:
        case 4:
          return normalized ? miniprogram.VertexElementFormat.NormalizedUByte4 : miniprogram.VertexElementFormat.UByte4;
      }
    }
  }
  /**
   * Load image buffer
   */
  ;

  GLTFUtil.loadImageBuffer = function loadImageBuffer(imageBuffer, type) {
    return new Promise(function (resolve, reject) {
      var blob = new miniprogramAdapter.window.Blob([imageBuffer], {
        type: type
      });
      var img = new miniprogramAdapter.Image();
      img.src = URL.createObjectURL(blob);
      img.crossOrigin = "anonymous";

      img.onerror = function () {
        reject(new Error("Failed to load image buffer"));
      };

      img.onload = function () {
        // Call requestAnimationFrame to avoid iOS's bug.
        miniprogramAdapter.requestAnimationFrame(function () {
          resolve(img);
          img.onload = null;
          img.onerror = null;
          img.onabort = null;
        });
      };
    });
  };

  GLTFUtil.isAbsoluteUrl = function isAbsoluteUrl(url) {
    return /^(?:http|blob|data:|\/)/.test(url);
  };

  GLTFUtil.parseRelativeUrl = function parseRelativeUrl(baseUrl, relativeUrl) {
    if (GLTFUtil.isAbsoluteUrl(relativeUrl)) {
      return relativeUrl;
    }

    var char0 = relativeUrl.charAt(0);

    if (char0 === ".") {
      return GLTFUtil._formatRelativePath(relativeUrl + relativeUrl);
    }

    return baseUrl.substring(0, baseUrl.lastIndexOf("/") + 1) + relativeUrl;
  }
  /**
   * Parse the glb format.
   */
  ;

  GLTFUtil.parseGLB = function parseGLB(glb) {
    var UINT32_LENGTH = 4;
    var GLB_HEADER_MAGIC = 0x46546c67; // 'glTF'

    var GLB_HEADER_LENGTH = 12;
    var GLB_CHUNK_TYPES = {
      JSON: 0x4e4f534a,
      BIN: 0x004e4942
    };
    var dataView = new DataView(glb); // read header

    var header = {
      magic: dataView.getUint32(0, true),
      version: dataView.getUint32(UINT32_LENGTH, true),
      length: dataView.getUint32(2 * UINT32_LENGTH, true)
    };

    if (header.magic !== GLB_HEADER_MAGIC) {
      console.error("Invalid glb magic number. Expected 0x46546C67, found 0x" + header.magic.toString(16));
      return null;
    } // read main data


    var chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);
    var chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true); // read glTF json

    if (chunkType !== GLB_CHUNK_TYPES.JSON) {
      console.error("Invalid glb chunk type. Expected 0x4E4F534A, found 0x" + chunkType.toString(16));
      return null;
    }

    var glTFData = new Uint8Array(glb, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);
    var gltf = JSON.parse(GLTFUtil.decodeText(glTFData)); // read all buffers

    var buffers = [];
    var byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;

    while (byteOffset < header.length) {
      chunkLength = dataView.getUint32(byteOffset, true);
      chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);

      if (chunkType !== GLB_CHUNK_TYPES.BIN) {
        console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
        return null;
      }

      var currentOffset = byteOffset + 2 * UINT32_LENGTH;
      var buffer = glb.slice(currentOffset, currentOffset + chunkLength);
      buffers.push(buffer);
      byteOffset += chunkLength + 2 * UINT32_LENGTH;
    }

    return {
      gltf: gltf,
      buffers: buffers
    };
  };

  GLTFUtil._formatRelativePath = function _formatRelativePath(value) {
    var parts = value.split("/");

    for (var i = 0, n = parts.length; i < n; i++) {
      if (parts[i] == "..") {
        parts.splice(i - 1, 2);
        i -= 2;
      }
    }

    return parts.join("/");
  };

  return GLTFUtil;
}();

var Parser$1 = /*#__PURE__*/function () {
  function Parser() {}

  Parser.parseEngineResource = function parseEngineResource(extensionName, extensionSchema, parseResource, context) {
    var parsers = Parser._extensionParsers[extensionName];

    if (parsers !== null && parsers !== void 0 && parsers.length) {
      for (var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
        extra[_key - 4] = arguments[_key];
      }

      for (var i = 0; i < parsers.length; i++) {
        var _parsers$i;

        (_parsers$i = parsers[i]).parseEngineResource.apply(_parsers$i, [extensionSchema, parseResource, context].concat(extra));
      }
    }
  };

  Parser.createEngineResource = function createEngineResource(extensionName, extensionSchema, context) {
    var parsers = Parser._extensionParsers[extensionName];

    if (parsers !== null && parsers !== void 0 && parsers.length) {
      var _parsers$;

      for (var _len2 = arguments.length, extra = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
        extra[_key2 - 3] = arguments[_key2];
      }

      return (_parsers$ = parsers[0]).createEngineResource.apply(_parsers$, [extensionSchema, context].concat(extra));
    }
  };

  Parser.hasExtensionParser = function hasExtensionParser(extensionName) {
    var parsers = Parser._extensionParsers[extensionName];
    return !!(parsers !== null && parsers !== void 0 && parsers.length);
  };

  Parser.initialize = function initialize(extensionName) {
    var parsers = Parser._extensionParsers[extensionName];

    if (parsers !== null && parsers !== void 0 && parsers.length) {
      for (var i = 0; i < parsers.length; i++) {
        parsers[i].initialize();
      }
    }
  }
  /**
   * @internal
   */
  ;

  Parser._addExtensionParser = function _addExtensionParser(extensionName, extensionParser) {
    if (!Parser._extensionParsers[extensionName]) {
      Parser._extensionParsers[extensionName] = [];
    }

    Parser._extensionParsers[extensionName].push(extensionParser);
  };

  return Parser;
}();
/**
 * Declare ExtensionParser's decorator.
 * @param extensionName - Extension name
 */

Parser$1._extensionParsers = {};
function registerExtension(extensionName) {
  return function (parser) {
    var extensionParser = new parser();

    Parser$1._addExtensionParser(extensionName, extensionParser);
  };
}

var AnimationParser = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(AnimationParser, _Parser);

  function AnimationParser() {
    return _Parser.apply(this, arguments) || this;
  }

  var _proto = AnimationParser.prototype;

  _proto.parse = function parse(context) {
    var gltf = context.gltf,
        buffers = context.buffers,
        entities = context.entities;
    var animations = gltf.animations,
        accessors = gltf.accessors;

    if (!animations) {
      return;
    }

    var animationClipCount = animations.length;
    var animationClips = new Array(animationClipCount);
    var animationsIndices = new Array(animationClipCount);

    for (var i = 0; i < animationClipCount; i++) {
      var gltfAnimation = animations[i];
      var channels = gltfAnimation.channels,
          samplers = gltfAnimation.samplers,
          _gltfAnimation$name = gltfAnimation.name,
          name = _gltfAnimation$name === void 0 ? "AnimationClip" + i : _gltfAnimation$name;
      var animationClip = new miniprogram.AnimationClip(name);
      var sampleDataCollection = new Array();

      for (var _i = 0; _i < samplers.length; _i++) {
        var _gltfSampler$interpol;

        var gltfSampler = samplers[_i];
        var inputAccessor = accessors[gltfSampler.input];
        var outputAccessor = accessors[gltfSampler.output];
        var input = GLTFUtil.getAccessorData(gltf, inputAccessor, buffers);
        var output = GLTFUtil.getAccessorData(gltf, outputAccessor, buffers);
        var outputAccessorSize = output.length / input.length;
        var interpolation = (_gltfSampler$interpol = gltfSampler.interpolation) != null ? _gltfSampler$interpol : AnimationSamplerInterpolation.Linear;
        var samplerInterpolation = void 0;

        switch (interpolation) {
          case AnimationSamplerInterpolation.CubicSpine:
            samplerInterpolation = miniprogram.InterpolationType.CubicSpine;
            break;

          case AnimationSamplerInterpolation.Step:
            samplerInterpolation = miniprogram.InterpolationType.Step;
            break;

          case AnimationSamplerInterpolation.Linear:
            samplerInterpolation = miniprogram.InterpolationType.Linear;
            break;
        }

        input[input.length - 1];

        sampleDataCollection.push({
          type: outputAccessor.type,
          interpolation: samplerInterpolation,
          input: input,
          output: output,
          outputSize: outputAccessorSize
        });
      }

      for (var _i2 = 0; _i2 < channels.length; _i2++) {
        var gltfChannel = channels[_i2];
        var target = gltfChannel.target;
        var channelTargetEntity = entities[target.node];
        var relativePath = "";
        var entity = channelTargetEntity;

        while (entity.parent) {
          relativePath = relativePath === "" ? "" + entity.name : entity.name + "/" + relativePath;
          entity = entity.parent;
        }

        var compType = void 0;
        var propertyName = void 0;

        switch (target.path) {
          case AnimationChannelTargetPath.TRANSLATION:
            compType = miniprogram.Transform;
            propertyName = "position";
            break;

          case AnimationChannelTargetPath.ROTATION:
            compType = miniprogram.Transform;
            propertyName = "rotation";
            break;

          case AnimationChannelTargetPath.SCALE:
            compType = miniprogram.Transform;
            propertyName = "scale";
            break;

          case AnimationChannelTargetPath.WEIGHTS:
            compType = miniprogram.SkinnedMeshRenderer;
            propertyName = "blendShapeWeights";
            break;
        }

        var curve = this._addCurve(gltfChannel, sampleDataCollection);

        animationClip.addCurveBinding(relativePath, compType, propertyName, curve);
      }

      animationClips[i] = animationClip;
      animationsIndices[i] = {
        name: name,
        index: i
      };
    }

    context.animations = animationClips; // @ts-ignore for editor

    context._animationsIndices = animationsIndices;
  };

  _proto._addCurve = function _addCurve(gltfChannel, sampleDataCollection) {
    var curve = new miniprogram.AnimationCurve();
    var sampleData = sampleDataCollection[gltfChannel.sampler];
    var type = sampleData.type,
        input = sampleData.input,
        output = sampleData.output,
        outputSize = sampleData.outputSize;
    curve.interpolation = sampleData.interpolation;

    for (var j = 0, n = input.length; j < n; j++) {
      var offset = j * outputSize;

      if (type === AccessorType.SCALAR) {
        var keyframe = outputSize > 1 ? new miniprogram.InterpolableKeyframe() : new miniprogram.InterpolableKeyframe();
        keyframe.time = input[j];
        keyframe.inTangent = 0;
        keyframe.outTangent = 0;
        keyframe.value = outputSize > 1 ? output.subarray(offset, offset + outputSize) : output[offset];
        curve.addKey(keyframe);
      }

      if (type === AccessorType.VEC2) {
        var _keyframe = new miniprogram.InterpolableKeyframe();

        _keyframe.time = input[j];
        _keyframe.value = new miniprogram$1.Vector2(output[offset], output[offset + 1]);
        _keyframe.inTangent = new miniprogram$1.Vector2();
        _keyframe.outTangent = new miniprogram$1.Vector2();
        curve.addKey(_keyframe);
      }

      if (type === AccessorType.VEC3) {
        var _keyframe2 = new miniprogram.InterpolableKeyframe();

        _keyframe2.time = input[j];
        _keyframe2.value = new miniprogram$1.Vector3(output[offset], output[offset + 1], output[offset + 2]);
        _keyframe2.inTangent = new miniprogram$1.Vector3();
        _keyframe2.outTangent = new miniprogram$1.Vector3();
        curve.addKey(_keyframe2);
      }

      if (type === AccessorType.VEC4) {
        var _keyframe3 = new miniprogram.InterpolableKeyframe();

        _keyframe3.time = input[j];
        _keyframe3.value = new miniprogram$1.Quaternion(output[offset], output[offset + 1], output[offset + 2], output[offset + 3]);
        _keyframe3.inTangent = new miniprogram$1.Vector4();
        _keyframe3.outTangent = new miniprogram$1.Vector4();
        curve.addKey(_keyframe3);
      }
    }

    return curve;
  };

  return AnimationParser;
}(Parser$1);

var BufferParser = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(BufferParser, _Parser);

  function BufferParser() {
    return _Parser.apply(this, arguments) || this;
  }

  var _proto = BufferParser.prototype;

  _proto.parse = function parse(context) {
    var url = context.url,
        engine = context.engine;

    if (this._isGLB(url)) {
      return engine.resourceManager.load({
        url: url,
        type: miniprogram.AssetType.Buffer
      }).then(GLTFUtil.parseGLB).then(function (_ref) {
        var gltf = _ref.gltf,
            buffers = _ref.buffers;
        context.gltf = gltf;
        context.buffers = buffers;
      });
    } else {
      return engine.resourceManager.load({
        url: url,
        type: miniprogram.AssetType.JSON
      }).then(function (gltf) {
        context.gltf = gltf;
        return Promise.all(gltf.buffers.map(function (buffer) {
          return engine.resourceManager.load({
            type: miniprogram.AssetType.Buffer,
            url: GLTFUtil.parseRelativeUrl(url, buffer.uri)
          });
        })).then(function (buffers) {
          context.buffers = buffers;
        });
      });
    }
  };

  _proto._isGLB = function _isGLB(url) {
    return url.substring(url.lastIndexOf(".") + 1) === "glb";
  };

  return BufferParser;
}(Parser$1);

var EntityParser = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(EntityParser, _Parser);

  function EntityParser() {
    return _Parser.apply(this, arguments) || this;
  }

  var _proto = EntityParser.prototype;

  /** @internal */
  _proto.parse = function parse(context) {
    var engine = context.engine,
        nodes = context.gltf.nodes;
    if (!nodes) return;
    var entities = [];

    for (var i = 0; i < nodes.length; i++) {
      var gltfNode = nodes[i];
      var matrix = gltfNode.matrix,
          translation = gltfNode.translation,
          rotation = gltfNode.rotation,
          scale = gltfNode.scale;
      var entity = new miniprogram.Entity(engine, gltfNode.name || "" + EntityParser._defaultName + i);
      var transform = entity.transform;

      if (matrix) {
        var localMatrix = transform.localMatrix;
        localMatrix.setValueByArray(matrix);
        transform.localMatrix = localMatrix;
      } else {
        if (translation) {
          transform.setPosition(translation[0], translation[1], translation[2]);
        }

        if (rotation) {
          transform.setRotationQuaternion(rotation[0], rotation[1], rotation[2], rotation[3]);
        }

        if (scale) {
          transform.setScale(scale[0], scale[1], scale[2]);
        }
      }

      entities[i] = entity;
    }

    context.entities = entities;

    this._buildEntityTree(context);

    this._createSceneRoots(context);
  };

  _proto._buildEntityTree = function _buildEntityTree(context) {
    var nodes = context.gltf.nodes,
        entities = context.entities;

    for (var i = 0; i < nodes.length; i++) {
      var children = nodes[i].children;
      var entity = entities[i];

      if (children) {
        for (var j = 0; j < children.length; j++) {
          var childEntity = entities[children[j]];
          entity.addChild(childEntity);
        }
      }
    }
  };

  _proto._createSceneRoots = function _createSceneRoots(context) {
    var engine = context.engine,
        _context$gltf = context.gltf,
        _context$gltf$scene = _context$gltf.scene,
        sceneID = _context$gltf$scene === void 0 ? 0 : _context$gltf$scene,
        scenes = _context$gltf.scenes,
        entities = context.entities;
    if (!scenes) return;
    var sceneRoots = [];

    for (var i = 0; i < scenes.length; i++) {
      var nodes = scenes[i].nodes;
      if (!nodes) continue;

      if (nodes.length === 1) {
        sceneRoots[i] = entities[nodes[0]];
      } else {
        var rootEntity = new miniprogram.Entity(engine, "GLTF_ROOT");

        for (var j = 0; j < nodes.length; j++) {
          rootEntity.addChild(entities[nodes[j]]);
        }

        sceneRoots[i] = rootEntity;
      }
    }

    context.sceneRoots = sceneRoots;
    context.defaultSceneRoot = sceneRoots[sceneID];
  };

  return EntityParser;
}(Parser$1);
EntityParser._defaultName = "_GLTF_ENTITY_";

var MaterialParser = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(MaterialParser, _Parser);

  function MaterialParser() {
    return _Parser.apply(this, arguments) || this;
  }

  /** @internal */
  MaterialParser._parseTextureTransform = function _parseTextureTransform(material, extensions, context) {
    if (extensions === void 0) {
      extensions = {};
    }

    var schema = extensions.KHR_texture_transform;

    if (schema) {
      Parser$1.parseEngineResource("KHR_texture_transform", schema, material, context);
    }
  };

  var _proto = MaterialParser.prototype;

  _proto.parse = function parse(context) {
    var gltf = context.gltf,
        engine = context.engine,
        textures = context.textures;
    if (!gltf.materials) return;
    var materials = [];

    for (var i = 0; i < gltf.materials.length; i++) {
      var _gltf$materials$i = gltf.materials[i],
          _gltf$materials$i$ext = _gltf$materials$i.extensions,
          extensions = _gltf$materials$i$ext === void 0 ? {} : _gltf$materials$i$ext,
          pbrMetallicRoughness = _gltf$materials$i.pbrMetallicRoughness,
          normalTexture = _gltf$materials$i.normalTexture,
          occlusionTexture = _gltf$materials$i.occlusionTexture,
          emissiveTexture = _gltf$materials$i.emissiveTexture,
          emissiveFactor = _gltf$materials$i.emissiveFactor,
          alphaMode = _gltf$materials$i.alphaMode,
          alphaCutoff = _gltf$materials$i.alphaCutoff,
          doubleSided = _gltf$materials$i.doubleSided,
          _gltf$materials$i$nam = _gltf$materials$i.name,
          name = _gltf$materials$i$nam === void 0 ? "" : _gltf$materials$i$nam;
      var KHR_materials_unlit = extensions.KHR_materials_unlit,
          KHR_materials_pbrSpecularGlossiness = extensions.KHR_materials_pbrSpecularGlossiness;
      var material = null;

      if (KHR_materials_unlit) {
        material = Parser$1.createEngineResource("KHR_materials_unlit", KHR_materials_unlit, context);
      } else if (KHR_materials_pbrSpecularGlossiness) {
        material = Parser$1.createEngineResource("KHR_materials_pbrSpecularGlossiness", KHR_materials_pbrSpecularGlossiness, context);
      } else {
        material = new miniprogram.PBRMaterial(engine);
      }

      material.name = name;

      if (pbrMetallicRoughness) {
        var baseColorFactor = pbrMetallicRoughness.baseColorFactor,
            baseColorTexture = pbrMetallicRoughness.baseColorTexture,
            metallicFactor = pbrMetallicRoughness.metallicFactor,
            roughnessFactor = pbrMetallicRoughness.roughnessFactor,
            metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;

        if (baseColorFactor) {
          material.baseColor = _construct(miniprogram$1.Color, baseColorFactor);
        }

        if (baseColorTexture) {
          material.baseTexture = textures[baseColorTexture.index];

          MaterialParser._parseTextureTransform(material, baseColorTexture.extensions, context);
        }

        if (!KHR_materials_unlit && !KHR_materials_pbrSpecularGlossiness) {
          var m = material;
          m.metallic = metallicFactor != null ? metallicFactor : 1;
          m.roughness = roughnessFactor != null ? roughnessFactor : 1;

          if (metallicRoughnessTexture) {
            m.roughnessMetallicTexture = textures[metallicRoughnessTexture.index];

            MaterialParser._parseTextureTransform(material, metallicRoughnessTexture.extensions, context);
          }
        }
      }

      if (!KHR_materials_unlit) {
        var _m = material;

        if (emissiveTexture) {
          _m.emissiveTexture = textures[emissiveTexture.index];

          MaterialParser._parseTextureTransform(material, emissiveTexture.extensions, context);
        }

        if (emissiveFactor) {
          _m.emissiveColor = _construct(miniprogram$1.Color, emissiveFactor);
        }

        if (normalTexture) {
          var index = normalTexture.index,
              scale = normalTexture.scale;
          _m.normalTexture = textures[index];

          MaterialParser._parseTextureTransform(material, normalTexture.extensions, context);

          if (scale !== undefined) {
            _m.normalTextureIntensity = scale;
          }
        }

        if (occlusionTexture) {
          var _index = occlusionTexture.index,
              strength = occlusionTexture.strength;
          _m.occlusionTexture = textures[_index];

          MaterialParser._parseTextureTransform(material, occlusionTexture.extensions, context);

          if (strength !== undefined) {
            _m.occlusionTextureIntensity = strength;
          }
        }
      }

      if (doubleSided) {
        material.renderFace = miniprogram.RenderFace.Double;
      } else {
        material.renderFace = miniprogram.RenderFace.Front;
      }

      switch (alphaMode) {
        case MaterialAlphaMode.OPAQUE:
          material.isTransparent = false;
          break;

        case MaterialAlphaMode.BLEND:
          material.isTransparent = true;
          break;

        case MaterialAlphaMode.MASK:
          material.alphaCutoff = alphaCutoff != null ? alphaCutoff : 0.5;
          break;
      }

      materials[i] = material;
    }

    context.materials = materials;
  };

  return MaterialParser;
}(Parser$1);

var MeshParser = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(MeshParser, _Parser);

  function MeshParser() {
    return _Parser.apply(this, arguments) || this;
  }

  var _proto = MeshParser.prototype;

  _proto.parse = function parse(context) {
    var _this = this;

    var engine = context.engine,
        gltf = context.gltf,
        buffers = context.buffers;
    if (!gltf.meshes) return;
    var meshPromises = [];

    var _loop = function _loop(i) {
      var gltfMesh = gltf.meshes[i];
      var primitivePromises = [];

      var _loop2 = function _loop2(j) {
        var gltfPrimitive = gltfMesh.primitives[j];
        var _gltfPrimitive$extens = gltfPrimitive.extensions,
            extensions = _gltfPrimitive$extens === void 0 ? {} : _gltfPrimitive$extens;
        var KHR_draco_mesh_compression = extensions.KHR_draco_mesh_compression;
        primitivePromises.push(new Promise(function (resolve) {
          var mesh = new miniprogram.ModelMesh(engine, gltfMesh.name || j + "");

          if (KHR_draco_mesh_compression) {
            Parser$1.createEngineResource("KHR_draco_mesh_compression", KHR_draco_mesh_compression, context, gltfPrimitive).then(function (decodedGeometry) {
              return _this._parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, function (attributeSemantic) {
                for (var _j = 0; _j < decodedGeometry.attributes.length; _j++) {
                  if (decodedGeometry.attributes[_j].name === attributeSemantic) {
                    return decodedGeometry.attributes[_j].array;
                  }
                }

                return null;
              }, function (attributeSemantic, shapeIndex) {
                throw "BlendShape animation is not supported when using draco.";
              }, function () {
                return decodedGeometry.index.array;
              }, engine);
            }).then(resolve);
          } else {
            _this._parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, function (attributeSemantic) {
              var accessorIdx = gltfPrimitive.attributes[attributeSemantic];
              var accessor = gltf.accessors[accessorIdx];
              return GLTFUtil.getAccessorData(gltf, accessor, buffers);
            }, function (attributeName, shapeIndex) {
              var shapeAccessorIdx = gltfPrimitive.targets[shapeIndex];
              var attributeAccessorIdx = shapeAccessorIdx[attributeName];

              if (attributeAccessorIdx) {
                var accessor = gltf.accessors[attributeAccessorIdx];
                return GLTFUtil.getAccessorData(gltf, accessor, buffers);
              } else {
                return null;
              }
            }, function () {
              var indexAccessor = gltf.accessors[gltfPrimitive.indices];
              return GLTFUtil.getAccessorData(gltf, indexAccessor, buffers);
            }, engine).then(resolve);
          }
        }));
      };

      for (var j = 0; j < gltfMesh.primitives.length; j++) {
        _loop2(j);
      }

      meshPromises.push(Promise.all(primitivePromises));
    };

    for (var i = 0; i < gltf.meshes.length; i++) {
      _loop(i);
    }

    return Promise.all(meshPromises).then(function (meshes) {
      context.meshes = meshes;
    });
  };

  _proto._parseMeshFromGLTFPrimitive = function _parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, getVertexBufferData, getBlendShapeData, getIndexBufferData, engine) {
    var attributes = gltfPrimitive.attributes,
        targets = gltfPrimitive.targets,
        indices = gltfPrimitive.indices,
        mode = gltfPrimitive.mode;
    var vertexCount;
    var accessor = gltf.accessors[attributes["POSITION"]];
    var positionBuffer = getVertexBufferData("POSITION");
    var positions = GLTFUtil.floatBufferToVector3Array(positionBuffer);
    mesh.setPositions(positions);
    var bounds = mesh.bounds;
    vertexCount = accessor.count;

    if (accessor.min && accessor.max) {
      bounds.min.setValueByArray(accessor.min);
      bounds.max.setValueByArray(accessor.max);
    } else {
      var position = MeshParser._tempVector3;
      var min = bounds.min,
          max = bounds.max;
      min.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      max.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
      var stride = positionBuffer.length / vertexCount;

      for (var j = 0; j < vertexCount; j++) {
        var offset = j * stride;
        position.setValueByArray(positionBuffer, offset);
        miniprogram$1.Vector3.min(min, position, min);
        miniprogram$1.Vector3.max(max, position, max);
      }
    }

    for (var attributeSemantic in attributes) {
      if (attributeSemantic === "POSITION") {
        continue;
      }

      var bufferData = getVertexBufferData(attributeSemantic);

      switch (attributeSemantic) {
        case "NORMAL":
          var normals = GLTFUtil.floatBufferToVector3Array(bufferData);
          mesh.setNormals(normals);
          break;

        case "TANGENT":
          var tangents = GLTFUtil.floatBufferToVector4Array(bufferData);
          mesh.setTangents(tangents);
          break;

        case "TEXCOORD_0":
          var texturecoords = GLTFUtil.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords, 0);
          break;

        case "JOINTS_0":
          var joints = GLTFUtil.floatBufferToVector4Array(bufferData);
          mesh.setBoneIndices(joints);
          break;

        case "WEIGHTS_0":
          var weights = GLTFUtil.floatBufferToVector4Array(bufferData);
          mesh.setBoneWeights(weights);
          break;
      }
    } // Indices


    if (indices !== undefined) {
      var indexAccessor = gltf.accessors[indices];
      var indexData = getIndexBufferData();
      mesh.setIndices(indexData);
      mesh.addSubMesh(0, indexAccessor.count, mode);
    } else {
      mesh.addSubMesh(0, vertexCount, mode);
    } // BlendShapes


    targets && this._createBlendShape(mesh, gltfMesh, targets, getBlendShapeData);
    mesh.uploadData(true);
    return Promise.resolve(mesh);
  };

  _proto._createBlendShape = function _createBlendShape(mesh, glTFMesh, glTFTargets, getBlendShapeData) {
    var blendShapeNames = glTFMesh.extras ? glTFMesh.extras.targetNames : null;

    for (var i = 0, n = glTFTargets.length; i < n; i++) {
      var _name = blendShapeNames ? blendShapeNames[i] : "blendShape" + i;

      var deltaPosBuffer = getBlendShapeData("POSITION", i);
      var deltaNorBuffer = getBlendShapeData("NORMAL", i);
      var deltaTanBuffer = getBlendShapeData("TANGENT", i);
      var deltaPositions = deltaPosBuffer ? GLTFUtil.floatBufferToVector3Array(deltaPosBuffer) : null;
      var deltaNormals = deltaNorBuffer ? GLTFUtil.floatBufferToVector3Array(deltaNorBuffer) : null;
      var deltaTangents = deltaTanBuffer ? GLTFUtil.floatBufferToVector3Array(deltaTanBuffer) : null;
      var blendShape = new miniprogram.BlendShape(_name);
      blendShape.addFrame(1.0, deltaPositions, deltaNormals, deltaTangents);
      mesh.addBlendShape(blendShape);
    }
  };

  return MeshParser;
}(Parser$1);
MeshParser._tempVector3 = new miniprogram$1.Vector3();

var SceneParser = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(SceneParser, _Parser);

  function SceneParser() {
    return _Parser.apply(this, arguments) || this;
  }

  SceneParser._getDefaultMaterial = function _getDefaultMaterial(engine) {
    if (!SceneParser._defaultMaterial) {
      SceneParser._defaultMaterial = new miniprogram.BlinnPhongMaterial(engine);
    }

    return SceneParser._defaultMaterial;
  };

  var _proto = SceneParser.prototype;

  _proto.parse = function parse(context) {
    var _context$gltf = context.gltf,
        nodes = _context$gltf.nodes,
        gltfCameras = _context$gltf.cameras,
        entities = context.entities;
    if (!nodes) return;

    for (var i = 0; i < nodes.length; i++) {
      var gltfNode = nodes[i];
      var cameraID = gltfNode.camera,
          meshID = gltfNode.mesh,
          _gltfNode$extensions = gltfNode.extensions,
          extensions = _gltfNode$extensions === void 0 ? {} : _gltfNode$extensions;
      var KHR_lights_punctual = extensions.KHR_lights_punctual;
      var entity = entities[i];

      if (cameraID !== undefined) {
        this._createCamera(context, gltfCameras[cameraID], entity);
      }

      if (meshID !== undefined) {
        this._createRenderer(context, gltfNode, entity);
      }

      if (KHR_lights_punctual) {
        var lightIndex = KHR_lights_punctual.light;
        var lights = context.gltf.extensions.KHR_lights_punctual.lights;
        Parser$1.parseEngineResource("KHR_lights_punctual", lights[lightIndex], entity, context);
      }
    }

    if (context.defaultSceneRoot) {
      this._createAnimator(context);
    }
  };

  _proto._createCamera = function _createCamera(context, cameraSchema, entity) {
    var orthographic = cameraSchema.orthographic,
        perspective = cameraSchema.perspective,
        type = cameraSchema.type;
    var camera = entity.addComponent(miniprogram.Camera);

    if (type === CameraType.ORTHOGRAPHIC) {
      var xmag = orthographic.xmag,
          ymag = orthographic.ymag,
          zfar = orthographic.zfar,
          znear = orthographic.znear;
      camera.isOrthographic = true;

      if (znear !== undefined) {
        camera.nearClipPlane = znear;
      }

      if (zfar !== undefined) {
        camera.farClipPlane = zfar;
      }

      camera.orthographicSize = Math.max(ymag != null ? ymag : 0, xmag != null ? xmag : 0) / 2;
    } else if (type === CameraType.PERSPECTIVE) {
      var aspectRatio = perspective.aspectRatio,
          yfov = perspective.yfov,
          _zfar = perspective.zfar,
          _znear = perspective.znear;

      if (aspectRatio !== undefined) {
        camera.aspectRatio = aspectRatio;
      }

      if (yfov !== undefined) {
        camera.fieldOfView = yfov * 180 / Math.PI;
      }

      if (_zfar !== undefined) {
        camera.farClipPlane = _zfar;
      }

      if (_znear !== undefined) {
        camera.nearClipPlane = _znear;
      }
    }

    if (!context.cameras) context.cameras = [];
    context.cameras.push(camera); // @todo: use engine camera by default

    camera.enabled = false;
  };

  _proto._createRenderer = function _createRenderer(context, gltfNode, entity) {
    var engine = context.engine,
        gltfMeshes = context.gltf.meshes,
        meshes = context.meshes,
        materials = context.materials,
        skins = context.skins;
    var meshID = gltfNode.mesh,
        skinID = gltfNode.skin;
    var glTFMesh = gltfMeshes[meshID];
    var gltfMeshPrimitives = glTFMesh.primitives;
    var blendShapeWeights = gltfNode.weights || glTFMesh.weights;

    for (var i = 0; i < gltfMeshPrimitives.length; i++) {
      var mesh = meshes[meshID][i];
      var renderer = void 0;

      if (skinID !== undefined || blendShapeWeights) {
        var skinRenderer = entity.addComponent(miniprogram.SkinnedMeshRenderer);
        skinRenderer.mesh = mesh;

        if (skinID !== undefined) {
          skinRenderer.skin = skins[skinID];
        }

        if (blendShapeWeights) {
          skinRenderer.blendShapeWeights = new Float32Array(blendShapeWeights);
        }

        renderer = skinRenderer;
      } else {
        renderer = entity.addComponent(miniprogram.MeshRenderer);
        renderer.mesh = mesh;
      }

      var materialIndex = gltfMeshPrimitives[i].material;

      var material = (materials === null || materials === void 0 ? void 0 : materials[materialIndex]) || SceneParser._getDefaultMaterial(engine);

      renderer.setMaterial(material);
      var _gltfMeshPrimitives$i = gltfMeshPrimitives[i].extensions,
          extensions = _gltfMeshPrimitives$i === void 0 ? {} : _gltfMeshPrimitives$i;
      var KHR_materials_variants = extensions.KHR_materials_variants;

      if (KHR_materials_variants) {
        Parser$1.parseEngineResource("KHR_materials_variants", KHR_materials_variants, renderer, context);
      }
    }
  };

  _proto._createAnimator = function _createAnimator(context) {
    var defaultSceneRoot = context.defaultSceneRoot,
        animations = context.animations;
    if (!animations) return;
    var animator = defaultSceneRoot.addComponent(miniprogram.Animator);
    var animatorController = new miniprogram.AnimatorController();
    var layer = new miniprogram.AnimatorControllerLayer("layer");
    var animatorStateMachine = new miniprogram.AnimatorStateMachine();
    animatorController.addLayer(layer);
    animator.animatorController = animatorController;
    layer.stateMachine = animatorStateMachine;

    if (animations) {
      for (var i = 0; i < animations.length; i++) {
        var animationClip = animations[i];
        var name = animationClip.name;
        var uniqueName = animatorStateMachine.makeUniqueStateName(name);

        if (uniqueName !== name) {
          console.warn("AnimatorState name is existed, name: " + name + " reset to " + uniqueName);
        }

        var animatorState = animatorStateMachine.addState(uniqueName);
        animatorState.clip = animationClip;
      }
    }
  };

  return SceneParser;
}(Parser$1);
SceneParser._defaultMaterial = void 0;

var SkinParser = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(SkinParser, _Parser);

  function SkinParser() {
    return _Parser.apply(this, arguments) || this;
  }

  var _proto = SkinParser.prototype;

  _proto.parse = function parse(context) {
    var gltf = context.gltf,
        buffers = context.buffers,
        entities = context.entities,
        defaultSceneRoot = context.defaultSceneRoot;
    var gltfSkins = gltf.skins;
    if (!gltfSkins) return;
    var skins = [];

    for (var i = 0; i < gltfSkins.length; i++) {
      var _gltfSkins$i = gltfSkins[i],
          inverseBindMatrices = _gltfSkins$i.inverseBindMatrices,
          skeleton = _gltfSkins$i.skeleton,
          joints = _gltfSkins$i.joints,
          _gltfSkins$i$name = _gltfSkins$i.name,
          name = _gltfSkins$i$name === void 0 ? "SKIN_" + i : _gltfSkins$i$name;
      var jointCount = joints.length;
      var skin = new miniprogram.Skin(name);
      skin.inverseBindMatrices.length = jointCount; // parse IBM

      var accessor = gltf.accessors[inverseBindMatrices];
      var buffer = GLTFUtil.getAccessorData(gltf, accessor, buffers);

      for (var _i = 0; _i < jointCount; _i++) {
        var inverseBindMatrix = new miniprogram$1.Matrix();
        inverseBindMatrix.setValueByArray(buffer, _i * 16);
        skin.inverseBindMatrices[_i] = inverseBindMatrix;
      } // get joints


      for (var _i2 = 0; _i2 < jointCount; _i2++) {
        skin.joints[_i2] = entities[joints[_i2]].name;
      } // get skeleton


      if (skeleton !== undefined) {
        skin.skeleton = entities[skeleton].name;
      } else {
        skin.skeleton = defaultSceneRoot.name;
      }

      skins[i] = skin;
    }

    context.skins = skins;
  };

  return SkinParser;
}(Parser$1);

var TextureParser = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(TextureParser, _Parser);

  function TextureParser() {
    return _Parser.apply(this, arguments) || this;
  }

  var _proto = TextureParser.prototype;

  _proto.parse = function parse(context) {
    var _this = this;

    var gltf = context.gltf,
        buffers = context.buffers,
        engine = context.engine,
        url = context.url;

    if (gltf.textures) {
      return Promise.all(gltf.textures.map(function (_ref, index) {
        var sampler = _ref.sampler,
            _ref$source = _ref.source,
            source = _ref$source === void 0 ? 0 : _ref$source,
            textureName = _ref.name;
        var _gltf$images$source = gltf.images[source],
            uri = _gltf$images$source.uri,
            bufferViewIndex = _gltf$images$source.bufferView,
            mimeType = _gltf$images$source.mimeType,
            imageName = _gltf$images$source.name;

        if (uri) {
          return engine.resourceManager.load({
            url: GLTFUtil.parseRelativeUrl(url, uri),
            type: miniprogram.AssetType.Texture2D
          }).then(function (texture) {
            if (!texture.name) {
              texture.name = textureName || imageName || "texture_" + index;
            }

            if (sampler !== undefined) {
              _this._parseSampler(texture, gltf.samplers[sampler]);
            }

            return texture;
          });
        } else {
          var bufferView = gltf.bufferViews[bufferViewIndex];
          var bufferViewData = GLTFUtil.getBufferViewData(bufferView, buffers);
          return GLTFUtil.loadImageBuffer(bufferViewData, mimeType).then(function (image) {
            var texture = new miniprogram.Texture2D(engine, image.width, image.height);
            texture.setImageSource(image);
            texture.generateMipmaps();
            texture.name = textureName || imageName || "texture_" + index;

            if (sampler !== undefined) {
              _this._parseSampler(texture, gltf.samplers[sampler]);
            }

            return texture;
          });
        }
      })).then(function (textures) {
        context.textures = textures;
      });
    }
  };

  _proto._parseSampler = function _parseSampler(texture, sampler) {
    var magFilter = sampler.magFilter,
        minFilter = sampler.minFilter,
        wrapS = sampler.wrapS,
        wrapT = sampler.wrapT;

    if (magFilter || minFilter) {
      miniprogram.Logger.warn("texture use filterMode in engine");
    }

    if (wrapS) {
      texture.wrapModeU = TextureParser._wrapMap[wrapS];
    }

    if (wrapT) {
      texture.wrapModeV = TextureParser._wrapMap[wrapT];
    }
  };

  return TextureParser;
}(Parser$1);
TextureParser._wrapMap = {
  33071: miniprogram.TextureWrapMode.Clamp,
  33648: miniprogram.TextureWrapMode.Mirror,
  10497: miniprogram.TextureWrapMode.Repeat
};

var Validator = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(Validator, _Parser);

  function Validator() {
    return _Parser.apply(this, arguments) || this;
  }

  var _proto = Validator.prototype;

  _proto.parse = function parse(context) {
    var _context$gltf = context.gltf,
        version = _context$gltf.asset.version,
        extensionsUsed = _context$gltf.extensionsUsed,
        extensionsRequired = _context$gltf.extensionsRequired;
    var gltfVersion = Number(version);

    if (!(gltfVersion >= 2 && gltfVersion < 3)) {
      throw "Only support gltf 2.x.";
    }

    if (extensionsUsed) {
      miniprogram.Logger.info("extensionsUsed: ", extensionsUsed);

      for (var i = 0; i < extensionsUsed.length; i++) {
        if (!Parser$1.hasExtensionParser(extensionsUsed[i])) {
          miniprogram.Logger.warn("Extension " + extensionsUsed[i] + " is not implemented, you can customize this extension in gltf.");
        }
      }
    }

    if (extensionsRequired) {
      miniprogram.Logger.info("extensionsRequired: " + extensionsRequired);

      for (var _i = 0; _i < extensionsRequired.length; _i++) {
        var extensionRequired = extensionsRequired[_i];

        if (!Parser$1.hasExtensionParser(extensionRequired)) {
          miniprogram.Logger.error("GLTF parser has not supported required extension " + extensionRequired + ".");
        } else {
          Parser$1.initialize(extensionRequired);
        }
      }
    }
  };

  return Validator;
}(Parser$1);

var GLTFParser = /*#__PURE__*/function () {
  function GLTFParser(pipes) {
    var _this = this;

    this._pipes = [];
    pipes.forEach(function (pipe, index) {
      _this._pipes[index] = new pipe();
    });
  }

  var _proto = GLTFParser.prototype;

  _proto.parse = function parse(context) {
    var _this2 = this;

    var lastPipe;
    return new Promise(function (resolve, reject) {
      _this2._pipes.forEach(function (parser) {
        if (lastPipe) {
          lastPipe = lastPipe.then(function () {
            return parser.parse(context);
          });
        } else {
          lastPipe = parser.parse(context);
        }
      });

      if (lastPipe) {
        lastPipe.then(function () {
          resolve(context);
        }).catch(reject);
      } else {
        resolve(context);
      }
    });
  };

  return GLTFParser;
}();
GLTFParser.instance = new GLTFParser([BufferParser, Validator, TextureParser, MaterialParser, MeshParser, EntityParser, SkinParser, AnimationParser, SceneParser]);

/**
 * Product after GLTF parser, usually, `defaultSceneRoot` is only needed to use.
 */
var GLTFResource$1 = /*#__PURE__*/function (_EngineObject) {
  _inheritsLoose(GLTFResource, _EngineObject);

  function GLTFResource() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _EngineObject.call.apply(_EngineObject, [this].concat(args)) || this;
    _this.url = void 0;
    _this.gltf = void 0;
    _this.buffers = void 0;
    _this.textures = void 0;
    _this.materials = void 0;
    _this.meshes = void 0;
    _this.skins = void 0;
    _this.animations = void 0;
    _this.entities = void 0;
    _this.cameras = void 0;
    _this.lights = void 0;
    _this.sceneRoots = void 0;
    _this.defaultSceneRoot = void 0;
    _this.variants = void 0;
    return _this;
  }

  return GLTFResource;
}(miniprogram.EngineObject);

var _dec$i, _class$i;
(_dec$i = miniprogram.resourceLoader(miniprogram.AssetType.Prefab, ["gltf", "glb"]), _dec$i(_class$i = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(GLTFLoader, _Loader);

  function GLTFLoader() {
    return _Loader.apply(this, arguments) || this;
  }

  var _proto = GLTFLoader.prototype;

  _proto.load = function load(item, resourceManager) {
    var url = item.url;
    return new miniprogram.AssetPromise(function (resolve, reject) {
      var resource = new GLTFResource$1(resourceManager.engine);
      resource.url = url;
      GLTFParser.instance.parse(resource).then(resolve).catch(function (e) {
        console.error(e);
        reject("Error loading glTF model from " + url + " .");
      });
    });
  };

  return GLTFLoader;
}(miniprogram.Loader)) || _class$i);

var _dec$h, _class$h;
(_dec$h = miniprogram.resourceLoader(miniprogram.AssetType.JSON, ["json"], false), _dec$h(_class$h = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(JSONLoader, _Loader);

  function JSONLoader() {
    return _Loader.apply(this, arguments) || this;
  }

  var _proto = JSONLoader.prototype;

  _proto.load = function load(item) {
    return this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
      type: "json"
    }));
  };

  return JSONLoader;
}(miniprogram.Loader)) || _class$h);

/**
 *
 * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts
 */
var HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)
// load types

var COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()

function getMipmaps(ktxContainer, loadMipmaps) {
  var mipmaps = []; // initialize width & height for level 1

  var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;
  var width = ktxContainer.pixelWidth;
  var height = ktxContainer.pixelHeight;
  var mipmapCount = loadMipmaps ? ktxContainer.numberOfMipmapLevels : 1;

  for (var level = 0; level < mipmapCount; level++) {
    var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps

    dataOffset += 4; // size of the image + 4 for the imageSize field

    for (var face = 0; face < ktxContainer.numberOfFaces; face++) {
      var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);
      mipmaps.push({
        data: byteArray,
        width: width,
        height: height
      });
      dataOffset += imageSize;
      dataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image
    }

    width = Math.max(1.0, width * 0.5);
    height = Math.max(1.0, height * 0.5);
  }

  return mipmaps;
}
/**
 * Checks if the given data starts with a KTX file identifier.
 * @param data the data to check
 * @returns true if the data is a KTX file or false otherwise
 */


function isValid(data) {
  if (data.byteLength >= 12) {
    // '«', 'K', 'T', 'X', ' ', '1', '1', '»', '\r', '\n', '\x1A', '\n'
    var identifier = new Uint8Array(data, 0, 12);

    if (identifier[0] === 0xab && identifier[1] === 0x4b && identifier[2] === 0x54 && identifier[3] === 0x58 && identifier[4] === 0x20 && identifier[5] === 0x31 && identifier[6] === 0x31 && identifier[7] === 0xbb && identifier[8] === 0x0d && identifier[9] === 0x0a && identifier[10] === 0x1a && identifier[11] === 0x0a) {
      return true;
    }
  }

  return false;
}

function getEngineFormat(internalFormat) {
  switch (internalFormat) {
    // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT3_EXT:
    // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
    // break;
    case miniprogram$2.GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:
      return miniprogram.TextureFormat.DXT1;

    case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
      return miniprogram.TextureFormat.DXT5;

    case miniprogram$2.GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:
      return miniprogram.TextureFormat.ETC1_RGB;

    case miniprogram$2.GLCompressedTextureInternalFormat.RGB8_ETC2:
      return miniprogram.TextureFormat.ETC2_RGB;

    case miniprogram$2.GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return miniprogram.TextureFormat.ETC2_RGBA5;

    case miniprogram$2.GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:
      return miniprogram.TextureFormat.ETC2_RGBA8;

    case miniprogram$2.GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:
      return miniprogram.TextureFormat.PVRTC_RGB2;

    case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:
      return miniprogram.TextureFormat.PVRTC_RGBA2;

    case miniprogram$2.GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:
      return miniprogram.TextureFormat.PVRTC_RGB4;

    case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:
      return miniprogram.TextureFormat.PVRTC_RGBA4;

    case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:
      return miniprogram.TextureFormat.ASTC_4x4;

    case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:
      return miniprogram.TextureFormat.ASTC_5x5;

    case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:
      return miniprogram.TextureFormat.ASTC_6x6;

    case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:
      return miniprogram.TextureFormat.ASTC_8x8;

    case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:
      return miniprogram.TextureFormat.ASTC_10x10;

    case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:
      return miniprogram.TextureFormat.ASTC_12x12;

    default:
      var formatName = miniprogram$2.GLCompressedTextureInternalFormat[internalFormat];
      throw new Error("this format is not supported in Oasis Engine: " + formatName);
  }
}
/**
 * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
 * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
 */


var khronosTextureContainerParser = {
  /**
   *
   * @param buffer contents of the KTX container file
   * @param facesExpected should be either 1 or 6, based whether a cube texture or or
   * @param threeDExpected provision for indicating that data should be a 3D texture, not implemented
   * @param textureArrayExpected provision for indicating that data should be a texture array, not implemented
   * @param mapEngineFormat get Oasis Engine native TextureFormat?
   */
  parse: function parse(buffer, facesExpected, withMipmaps, mapEngineFormat) {
    if (mapEngineFormat === void 0) {
      mapEngineFormat = false;
    }

    if (!isValid(buffer)) {
      throw new Error("khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier");
    } // load the reset of the header in native 32 bit uint


    var dataSize = Uint32Array.BYTES_PER_ELEMENT;
    var headerDataView = new DataView(buffer, 12, 13 * dataSize);
    var endianness = headerDataView.getUint32(0, true);
    var littleEndian = endianness === 0x04030201;
    var parsedResult = {
      buffer: buffer,
      glType: headerDataView.getUint32(1 * dataSize, littleEndian),
      // must be 0 for compressed textures
      glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian),
      // must be 1 for compressed textures
      glFormat: headerDataView.getUint32(3 * dataSize, littleEndian),
      // must be 0 for compressed textures
      glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian),
      // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)
      glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian),
      // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)
      pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian),
      // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)
      pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian),
      // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)
      pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian),
      // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)
      numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian),
      // used for texture arrays
      numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian),
      // used for cubemap textures, should either be 1 or 6
      numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian),
      // number of levels; disregard possibility of 0 for compressed textures
      bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian),
      // the amount of space after the header for meta-data
      // would need to make this more elaborate & adjust checks above to support more than one load type
      loadType: COMPRESSED_2D
    }; // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.

    if (parsedResult.glType !== 0) {
      throw new Error("only compressed formats currently supported");
    } else {
      // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
      parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);
    }

    if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {
      throw new Error("only 2D textures currently supported");
    }

    if (parsedResult.numberOfArrayElements !== 0) {
      throw new Error("texture arrays not currently supported");
    }

    if (parsedResult.numberOfFaces !== facesExpected) {
      throw new Error("number of faces expected" + facesExpected + ", but found " + parsedResult.numberOfFaces);
    }

    if (withMipmaps) {
      parsedResult.mipmaps = getMipmaps(parsedResult, true);
    }

    if (mapEngineFormat) {
      parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);
    }

    return parsedResult;
  }
};

function parseSingleKTX(data) {
  var ktx = khronosTextureContainerParser.parse(data, 1, true, true);
  return {
    mipmaps: ktx.mipmaps,
    engineFormat: ktx.engineFormat,
    internalFormat: ktx.glInternalFormat,
    width: ktx.pixelWidth,
    height: ktx.pixelHeight
  };
}
function parseCubeKTX(dataArray) {
  var mipmapsFaces = [];
  var internalFormat;
  var engineFormat;
  var width;
  var height;

  for (var i = 0; i < dataArray.length; i++) {
    var ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);
    mipmapsFaces.push(ktx.mipmaps);

    if (i === 0) {
      width = ktx.pixelWidth;
      height = ktx.pixelHeight;
      internalFormat = ktx.glInternalFormat;
      engineFormat = ktx.engineFormat;
    }
  }

  return {
    mipmapsFaces: mipmapsFaces,
    engineFormat: engineFormat,
    internalFormat: internalFormat,
    width: width,
    height: height
  };
}

var _dec$g, _class$g;
(_dec$g = miniprogram.resourceLoader(miniprogram.AssetType.KTXCube, []), _dec$g(_class$g = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(KTXCubeLoader, _Loader);

  function KTXCubeLoader() {
    return _Loader.apply(this, arguments) || this;
  }

  var _proto = KTXCubeLoader.prototype;

  _proto.load = function load(item, resourceManager) {
    var _this = this;

    return new miniprogram.AssetPromise(function (resolve, reject) {
      Promise.all(item.urls.map(function (url) {
        return _this.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "arraybuffer"
        }));
      })).then(function (data) {
        var parsedData = parseCubeKTX(data);
        var width = parsedData.width,
            mipmapsFaces = parsedData.mipmapsFaces,
            engineFormat = parsedData.engineFormat;
        var mipmap = mipmapsFaces[0].length > 1;
        var texture = new miniprogram.TextureCubeMap(resourceManager.engine, width, engineFormat, mipmap);

        for (var face = 0; face < 6; face++) {
          var length = mipmapsFaces[face].length;

          for (var miplevel = 0; miplevel < length; miplevel++) {
            var _mipmapsFaces$face$mi = mipmapsFaces[face][miplevel],
                _data = _mipmapsFaces$face$mi.data,
                _width = _mipmapsFaces$face$mi.width,
                height = _mipmapsFaces$face$mi.height;
            texture.setPixelBuffer(miniprogram.TextureCubeFace.PositiveX + face, _data, miplevel, 0, 0, _width, height);
          }
        }

        resolve(texture);
      }).catch(function (e) {
        reject(e);
      });
    });
  };

  return KTXCubeLoader;
}(miniprogram.Loader)) || _class$g);

var _dec$f, _class$f;
(_dec$f = miniprogram.resourceLoader(miniprogram.AssetType.KTX, ["ktx"]), _dec$f(_class$f = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(KTXLoader, _Loader);

  function KTXLoader() {
    return _Loader.apply(this, arguments) || this;
  }

  var _proto = KTXLoader.prototype;

  _proto.load = function load(item, resourceManager) {
    var _this = this;

    return new miniprogram.AssetPromise(function (resolve, reject) {
      _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
        type: "arraybuffer"
      })).then(function (bin) {
        var parsedData = parseSingleKTX(bin);
        var width = parsedData.width,
            height = parsedData.height,
            mipmaps = parsedData.mipmaps,
            engineFormat = parsedData.engineFormat;
        var mipmap = mipmaps.length > 1;
        var texture = new miniprogram.Texture2D(resourceManager.engine, width, height, engineFormat, mipmap);

        for (var miplevel = 0; miplevel < mipmaps.length; miplevel++) {
          var _mipmaps$miplevel = mipmaps[miplevel],
              _width = _mipmaps$miplevel.width,
              _height = _mipmaps$miplevel.height,
              data = _mipmaps$miplevel.data;
          texture.setPixelBuffer(data, miplevel, 0, 0, _width, _height);
        }

        resolve(texture);
      }).catch(function (e) {
        reject(e);
      });
    });
  };

  return KTXLoader;
}(miniprogram.Loader)) || _class$f);

var _dec$e, _class$e;
(_dec$e = miniprogram.resourceLoader(miniprogram.AssetType.Texture2D, ["png", "jpg", "webp", "jpeg"]), _dec$e(_class$e = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(Texture2DLoader, _Loader);

  function Texture2DLoader() {
    return _Loader.apply(this, arguments) || this;
  }

  var _proto = Texture2DLoader.prototype;

  _proto.load = function load(item, resourceManager) {
    var _this = this;

    return new miniprogram.AssetPromise(function (resolve, reject) {
      _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
        type: "image"
      })).then(function (image) {
        var texture = new miniprogram.Texture2D(resourceManager.engine, image.width, image.height);
        /** @ts-ignore */

        if (!texture._platformTexture) return;
        texture.setImageSource(image);
        texture.generateMipmaps();

        if (item.url.indexOf("data:") !== 0) {
          var splitPath = item.url.split("/");
          texture.name = splitPath[splitPath.length - 1];
        }

        resolve(texture);
      }).catch(function (e) {
        reject(e);
      });
    });
  };

  return Texture2DLoader;
}(miniprogram.Loader)) || _class$e);

var _dec$d, _class$d;
(_dec$d = miniprogram.resourceLoader(miniprogram.AssetType.TextureCube, [""]), _dec$d(_class$d = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(TextureCubeLoader, _Loader);

  function TextureCubeLoader() {
    return _Loader.apply(this, arguments) || this;
  }

  var _proto = TextureCubeLoader.prototype;

  _proto.load = function load(item, resourceManager) {
    var _this = this;

    return new miniprogram.AssetPromise(function (resolve, reject) {
      Promise.all(item.urls.map(function (url) {
        return _this.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "image"
        }));
      })).then(function (images) {
        var _images$ = images[0],
            width = _images$.width,
            height = _images$.height;

        if (width !== height) {
          console.error("The cube texture must have the same width and height");
          return;
        }

        var tex = new miniprogram.TextureCubeMap(resourceManager.engine, width);
        /** @ts-ignore */

        if (!tex._platformTexture) return;

        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
          tex.setImageSource(miniprogram.TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
        }

        tex.generateMipmaps();
        resolve(tex);
      }).catch(function (e) {
        reject(e);
      });
    });
  };

  return TextureCubeLoader;
}(miniprogram.Loader)) || _class$d);

var _dec$c, _class$c;
(_dec$c = miniprogram.resourceLoader(miniprogram.AssetType.SpriteAtlas, ["atlas"], false), _dec$c(_class$c = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(SpriteAtlasLoader, _Loader);

  function SpriteAtlasLoader() {
    return _Loader.apply(this, arguments) || this;
  }

  var _proto = SpriteAtlasLoader.prototype;

  _proto.load = function load(item, resourceManager) {
    var _this = this;

    return new miniprogram.AssetPromise(function (resolve, reject) {
      _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
        type: "json"
      })).then(function (atlasData) {
        var atlasItems = atlasData.atlasItems,
            format = atlasData.format;
        var atlasItemsLen = atlasItems.length;
        Promise.all(atlasItems.map(function (_ref) {
          var img = _ref.img;
          return _this.request(GLTFUtil.parseRelativeUrl(item.url, img), _objectSpread2(_objectSpread2({}, item), {}, {
            type: "image"
          }));
        })).then(function (imgs) {
          var engine = resourceManager.engine; // Generate a SpriteAtlas object.

          var tempRect = new miniprogram$1.Rect();
          var tempVect2 = new miniprogram$1.Vector2();
          var spriteAtlas = new miniprogram.SpriteAtlas(engine);

          for (var i = 0; i < atlasItemsLen; i++) {
            // Generate Texture2D according to configuration.
            var originalImg = imgs[i];
            var width = originalImg.width,
                height = originalImg.height;
            var texture = new miniprogram.Texture2D(engine, width, height, format);
            texture.setImageSource(originalImg);
            texture.generateMipmaps(); // Generate all the sprites on this texture.

            var atlasItem = atlasItems[i];
            var sprites = atlasItem.sprites;
            var sourceWidthReciprocal = 1.0 / width;
            var sourceHeightReciprocal = 1.0 / height;

            for (var j = sprites.length - 1; j >= 0; j--) {
              var atlasSprite = sprites[j];
              var region = atlasSprite.region,
                  pivot = atlasSprite.pivot,
                  atlasRegionOffset = atlasSprite.atlasRegionOffset,
                  atlasRegion = atlasSprite.atlasRegion,
                  id = atlasSprite.id;
              var sprite = new miniprogram.Sprite(engine, texture, region ? tempRect.setValue(region.x, region.y, region.w, region.h) : undefined, pivot ? tempVect2.setValue(pivot.x, pivot.y) : undefined, atlasSprite.pixelsPerUnit || undefined, atlasSprite.name);
              sprite.atlasRegion.setValue(atlasRegion.x * sourceWidthReciprocal, atlasRegion.y * sourceHeightReciprocal, atlasRegion.w * sourceWidthReciprocal, atlasRegion.h * sourceHeightReciprocal);
              atlasSprite.atlasRotated && (sprite.atlasRotated = true);

              if (atlasRegionOffset) {
                var offsetLeft = atlasRegionOffset.x,
                    offsetTop = atlasRegionOffset.y,
                    offsetRight = atlasRegionOffset.z,
                    offsetBottom = atlasRegionOffset.w;
                var originalWReciprocal = void 0,
                    originalHReciprocal = void 0;

                if (atlasSprite.atlasRotated) {
                  originalWReciprocal = 1 / (offsetLeft + atlasRegion.h + offsetRight);
                  originalHReciprocal = 1 / (offsetTop + atlasRegion.w + offsetBottom);
                } else {
                  originalWReciprocal = 1 / (offsetLeft + atlasRegion.w + offsetRight);
                  originalHReciprocal = 1 / (offsetTop + atlasRegion.h + offsetBottom);
                }

                sprite.atlasRegionOffset.setValue(offsetLeft * originalWReciprocal, offsetTop * originalHReciprocal, offsetRight * originalWReciprocal, offsetBottom * originalHReciprocal);
              }

              if (id !== undefined) {
                // @ts-ignore
                sprite._assetID = id;
              } // @ts-ignore


              spriteAtlas._addSprite(sprite);
            }
          }

          resolve(spriteAtlas);
        });
      }).catch(function (e) {
        reject(e);
      });
    });
  };

  return SpriteAtlasLoader;
}(miniprogram.Loader)) || _class$c);

var ExtensionParser = /*#__PURE__*/function () {
  function ExtensionParser() {}

  var _proto = ExtensionParser.prototype;

  _proto.initialize = function initialize() {};

  _proto.parseEngineResource = function parseEngineResource(schema, parseResource, context) {};

  _proto.createEngineResource = function createEngineResource(schema, context) {
    return null;
  };

  return ExtensionParser;
}();

var _dec$b, _class$b, _class2, _temp;
(_dec$b = registerExtension("KHR_draco_mesh_compression"), _dec$b(_class$b = (_temp = _class2 = /*#__PURE__*/function (_ExtensionParser) {
  _inheritsLoose(KHR_draco_mesh_compression, _ExtensionParser);

  function KHR_draco_mesh_compression() {
    return _ExtensionParser.apply(this, arguments) || this;
  }

  var _proto = KHR_draco_mesh_compression.prototype;

  _proto.initialize = function initialize() {
    if (!KHR_draco_mesh_compression._decoder) {
      KHR_draco_mesh_compression._decoder = new miniprogram$3.DRACODecoder();
    }
  };

  _proto.createEngineResource = function createEngineResource(schema, context, gltfPrimitive) {
    var gltf = context.gltf,
        buffers = context.buffers;
    var bufferViews = gltf.bufferViews,
        accessors = gltf.accessors;
    var bufferViewIndex = schema.bufferView,
        gltfAttributeMap = schema.attributes;
    var attributeMap = {};
    var attributeTypeMap = {};

    for (var attributeName in gltfAttributeMap) {
      attributeMap[attributeName] = gltfAttributeMap[attributeName];
    }

    for (var _attributeName in gltfPrimitive.attributes) {
      if (gltfAttributeMap[_attributeName] !== undefined) {
        var accessorDef = accessors[gltfPrimitive.attributes[_attributeName]];
        attributeTypeMap[_attributeName] = GLTFUtil.getComponentType(accessorDef.componentType).name;
      }
    }

    var indexAccessor = accessors[gltfPrimitive.indices];
    var indexType = GLTFUtil.getComponentType(indexAccessor.componentType).name;
    var taskConfig = {
      attributeIDs: attributeMap,
      attributeTypes: attributeTypeMap,
      useUniqueIDs: true,
      indexType: indexType
    };
    var buffer = GLTFUtil.getBufferViewData(bufferViews[bufferViewIndex], buffers);
    return KHR_draco_mesh_compression._decoder.decode(buffer, taskConfig).then(function (parsedGeometry) {
      return parsedGeometry;
    });
  };

  return KHR_draco_mesh_compression;
}(ExtensionParser), _class2._decoder = void 0, _temp)) || _class$b);

var _dec$a, _class$a;
(_dec$a = registerExtension("KHR_lights_punctual"), _dec$a(_class$a = /*#__PURE__*/function (_ExtensionParser) {
  _inheritsLoose(KHR_lights_punctual, _ExtensionParser);

  function KHR_lights_punctual() {
    return _ExtensionParser.apply(this, arguments) || this;
  }

  var _proto = KHR_lights_punctual.prototype;

  _proto.parseEngineResource = function parseEngineResource(schema, entity, context) {
    var color = schema.color,
        _schema$intensity = schema.intensity,
        intensity = _schema$intensity === void 0 ? 1 : _schema$intensity,
        type = schema.type,
        range = schema.range,
        spot = schema.spot;
    var light;

    if (type === "directional") {
      light = entity.addComponent(miniprogram.DirectLight);
    } else if (type === "point") {
      light = entity.addComponent(miniprogram.PointLight);
    } else if (type === "spot") {
      light = entity.addComponent(miniprogram.SpotLight);
    }

    if (color) {
      light.color.setValue(color[0], color[1], color[2], 1);
    }

    light.intensity = intensity;

    if (range && !(light instanceof miniprogram.DirectLight)) {
      light.distance = range;
    }

    if (spot && light instanceof miniprogram.SpotLight) {
      var _spot$innerConeAngle = spot.innerConeAngle,
          innerConeAngle = _spot$innerConeAngle === void 0 ? 0 : _spot$innerConeAngle,
          _spot$outerConeAngle = spot.outerConeAngle,
          outerConeAngle = _spot$outerConeAngle === void 0 ? Math.PI / 4 : _spot$outerConeAngle;
      light.angle = innerConeAngle;
      light.penumbra = outerConeAngle - innerConeAngle;
    }

    if (!context.lights) context.lights = [];
    context.lights.push(light);
  };

  return KHR_lights_punctual;
}(ExtensionParser)) || _class$a);

var _dec$9, _class$9;
(_dec$9 = registerExtension("KHR_materials_pbrSpecularGlossiness"), _dec$9(_class$9 = /*#__PURE__*/function (_ExtensionParser) {
  _inheritsLoose(KHR_materials_pbrSpecularGlossiness, _ExtensionParser);

  function KHR_materials_pbrSpecularGlossiness() {
    return _ExtensionParser.apply(this, arguments) || this;
  }

  var _proto = KHR_materials_pbrSpecularGlossiness.prototype;

  _proto.createEngineResource = function createEngineResource(schema, context) {
    var engine = context.engine,
        textures = context.textures;
    var material = new miniprogram.PBRSpecularMaterial(engine);
    var diffuseFactor = schema.diffuseFactor,
        diffuseTexture = schema.diffuseTexture,
        specularFactor = schema.specularFactor,
        glossinessFactor = schema.glossinessFactor,
        specularGlossinessTexture = schema.specularGlossinessTexture;

    if (diffuseFactor) {
      material.baseColor = _construct(miniprogram$1.Color, diffuseFactor);
    }

    if (diffuseTexture) {
      material.baseTexture = textures[diffuseTexture.index];

      MaterialParser._parseTextureTransform(material, diffuseTexture.extensions, context);
    }

    if (specularFactor) {
      material.specularColor = _construct(miniprogram$1.Color, specularFactor);
    }

    if (glossinessFactor !== undefined) {
      material.glossiness = glossinessFactor;
    }

    if (specularGlossinessTexture) {
      material.specularGlossinessTexture = textures[specularGlossinessTexture.index];

      MaterialParser._parseTextureTransform(material, specularGlossinessTexture.extensions, context);
    }

    return material;
  };

  return KHR_materials_pbrSpecularGlossiness;
}(ExtensionParser)) || _class$9);

var _dec$8, _class$8;
(_dec$8 = registerExtension("KHR_materials_unlit"), _dec$8(_class$8 = /*#__PURE__*/function (_ExtensionParser) {
  _inheritsLoose(KHR_materials_unlit, _ExtensionParser);

  function KHR_materials_unlit() {
    return _ExtensionParser.apply(this, arguments) || this;
  }

  var _proto = KHR_materials_unlit.prototype;

  _proto.createEngineResource = function createEngineResource(schema, context) {
    var engine = context.engine;
    var material = new miniprogram.UnlitMaterial(engine);
    return material;
  };

  return KHR_materials_unlit;
}(ExtensionParser)) || _class$8);

var _dec$7, _class$7;
(_dec$7 = registerExtension("KHR_materials_variants"), _dec$7(_class$7 = /*#__PURE__*/function (_ExtensionParser) {
  _inheritsLoose(KHR_materials_variants, _ExtensionParser);

  function KHR_materials_variants() {
    return _ExtensionParser.apply(this, arguments) || this;
  }

  var _proto = KHR_materials_variants.prototype;

  _proto.parseEngineResource = function parseEngineResource(schema, renderer, context) {
    var variantNames = context.gltf.extensions.KHR_materials_variants.variants,
        materials = context.materials;
    var mappings = schema.mappings;

    for (var i = 0; i < mappings.length; i++) {
      var _mappings$i = mappings[i],
          material = _mappings$i.material,
          variants = _mappings$i.variants;
      if (!context.variants) context.variants = [];
      context.variants.push({
        renderer: renderer,
        material: materials[material],
        variants: variants.map(function (index) {
          return variantNames[index].name;
        })
      });
    }
  };

  return KHR_materials_variants;
}(ExtensionParser)) || _class$7);

var _dec$6, _class$6;
(_dec$6 = registerExtension("KHR_mesh_quantization"), _dec$6(_class$6 = /*#__PURE__*/function (_ExtensionParser) {
  _inheritsLoose(KHR_mesh_quantization, _ExtensionParser);

  function KHR_mesh_quantization() {
    return _ExtensionParser.apply(this, arguments) || this;
  }

  return KHR_mesh_quantization;
}(ExtensionParser)) || _class$6);

var _dec$5, _class$5;
(_dec$5 = registerExtension("KHR_texture_transform"), _dec$5(_class$5 = /*#__PURE__*/function (_ExtensionParser) {
  _inheritsLoose(KHR_texture_transform, _ExtensionParser);

  function KHR_texture_transform() {
    return _ExtensionParser.apply(this, arguments) || this;
  }

  var _proto = KHR_texture_transform.prototype;

  _proto.parseEngineResource = function parseEngineResource(schema, material, context) {
    var offset = schema.offset,
        rotation = schema.rotation,
        scale = schema.scale,
        texCoord = schema.texCoord;

    if (offset) {
      material.tilingOffset.z = offset[0];
      material.tilingOffset.w = offset[1];
    }

    if (scale) {
      material.tilingOffset.x = scale[0];
      material.tilingOffset.y = scale[1];
    }

    if (rotation) {
      miniprogram.Logger.warn("rotation in KHR_texture_transform is not supported now");
    }

    if (texCoord) {
      miniprogram.Logger.warn("texCoord in KHR_texture_transform is not supported now");
    }
  };

  return KHR_texture_transform;
}(ExtensionParser)) || _class$5);

/**
 * @deprecated
 * Temporarily only for editor use.
 * Remove when editor finish change from gltf to prefab.
 */
var GLTFModel = /*#__PURE__*/function (_Component) {
  _inheritsLoose(GLTFModel, _Component);

  function GLTFModel(entity) {
    var _this;

    _this = _Component.call(this, entity) || this;
    _this._animatorController = void 0;
    _this._speed = 1.0;
    _this._animator = void 0;
    _this._asset = void 0;
    _this._glTFEntity = void 0;
    _this._clipPreview = void 0;
    _this._hasBuiltNode = false;
    _this._controllerUpdateFlag = void 0;
    return _this;
  }
  /**
   * Init.
   * @param props - Init props
   */


  var _proto = GLTFModel.prototype;

  _proto.init = function init(props) {
    var _props$asset = props.asset,
        asset = _props$asset === void 0 ? null : _props$asset,
        speed = props.speed,
        animatorController = props.animatorController,
        clipPreview = props.clipPreview,
        isClone = props.isClone;

    if (isClone) {
      var rootName = props.gltfRootName;

      if (rootName) {
        this._glTFEntity = this.entity.findByName(rootName);
      }
    }

    if (!this._glTFEntity) {
      var _rootName = "GLTF-" + Date.now();

      props.gltfRootName = _rootName;
      this._glTFEntity = this.entity.createChild(_rootName);
      this._hasBuiltNode = false;
    } else {
      this._hasBuiltNode = true;
    }

    this.asset = asset;
    this.animatorController = animatorController;
    this.speed = speed;
    this.clipPreview = clipPreview;
  };

  _proto.update = function update() {
    if (this._animator) {
      var _this$_controllerUpda;

      if ((_this$_controllerUpda = this._controllerUpdateFlag) !== null && _this$_controllerUpda !== void 0 && _this$_controllerUpda.flag) {
        this._playState();
      }
    }
  }
  /**
   * @override
   */
  ;

  _proto._onEnable = function _onEnable() {
    this._glTFEntity && (this._glTFEntity.isActive = true);

    this.engine._componentsManager.addOnUpdateAnimations(this);
  }
  /**
   * @override
   */
  ;

  _proto._onDisable = function _onDisable() {
    this._glTFEntity && (this._glTFEntity.isActive = false);

    this.engine._componentsManager.removeOnUpdateAnimations(this);
  };

  _proto._playState = function _playState() {
    var playStateName = this._clipPreview;

    if (playStateName) {
      var _this$_controllerUpda2;

      this._animator.play(playStateName, 0);

      if ((_this$_controllerUpda2 = this._controllerUpdateFlag) !== null && _this$_controllerUpda2 !== void 0 && _this$_controllerUpda2.flag) {
        this._controllerUpdateFlag.flag = false;
      }
    } else {
      this._playDefaultState();
    }
  };

  _proto._playDefaultState = function _playDefaultState() {
    var animatorController = this._animatorController,
        animator = this._animator;
    if (!animator) return;

    if (animatorController) {
      var layers = animatorController.layers;

      for (var i = 0, length = layers.length; i < length; ++i) {
        var _layers$i$stateMachin, _layers$i, _layers$i$stateMachin2, _layers$i2, _layers$i2$stateMachi;

        //@ts-ignore
        var defaultState = (_layers$i$stateMachin = (_layers$i = layers[i]) === null || _layers$i === void 0 ? void 0 : (_layers$i$stateMachin2 = _layers$i.stateMachine) === null || _layers$i$stateMachin2 === void 0 ? void 0 : _layers$i$stateMachin2._defaultState) != null ? _layers$i$stateMachin : (_layers$i2 = layers[i]) === null || _layers$i2 === void 0 ? void 0 : (_layers$i2$stateMachi = _layers$i2.stateMachine) === null || _layers$i2$stateMachi === void 0 ? void 0 : _layers$i2$stateMachi.states[0];
        var defaultStateName = defaultState === null || defaultState === void 0 ? void 0 : defaultState.name;

        if (defaultStateName) {
          var _this$_controllerUpda3;

          animator.play(defaultStateName, i);

          if ((_this$_controllerUpda3 = this._controllerUpdateFlag) !== null && _this$_controllerUpda3 !== void 0 && _this$_controllerUpda3.flag) {
            this._controllerUpdateFlag.flag = false;
          }
        }
      }
    }
  };

  _createClass(GLTFModel, [{
    key: "asset",
    get: function get() {
      return this._asset;
    },
    set: function set(value) {
      var animatorController = this._animatorController,
          speed = this._speed;
      var entity = this._glTFEntity;

      if (value && value.defaultSceneRoot === this._glTFEntity) {
        return;
      }

      if (!this._hasBuiltNode) {
        entity.clearChildren();

        if (value !== null) {
          entity === null || entity === void 0 ? void 0 : entity.destroy();
          var gltfEntity = value.defaultSceneRoot.clone();
          this._animator = gltfEntity.getComponent(miniprogram.Animator);
          this.entity.addChild(gltfEntity);
          gltfEntity.isActive = this.enabled;
          this._glTFEntity = gltfEntity;
        }
      }

      if (animatorController) {
        this._animator.animatorController = animatorController;
        this._animator.speed = speed;

        this._playState();
      }

      this._asset = value;
    }
  }, {
    key: "animatorController",
    get: function get() {
      return this._animatorController;
    },
    set: function set(animatorController) {
      var animator = this._animator;

      if (animatorController !== this._animatorController) {
        this._controllerUpdateFlag && this._controllerUpdateFlag.destroy(); // @ts-ignore

        this._controllerUpdateFlag = animatorController && animatorController._registerChangeFlag();
        this._animatorController = animatorController;

        if (animator) {
          animator.animatorController = animatorController;

          this._playState();
        }
      }
    }
  }, {
    key: "speed",
    get: function get() {
      return this._speed;
    },
    set: function set(speed) {
      var animator = this._animator;
      this._speed = speed;

      if (animator) {
        animator.speed = speed;

        this._playState();
      }
    }
  }, {
    key: "animator",
    get: function get() {
      return this._animator;
    }
  }, {
    key: "clipPreview",
    get: function get() {
      return this._clipPreview;
    },
    set: function set(value) {
      if (this._animator) {
        if (value) {
          this._animator.play(value, 0);
        } else {
          this._playDefaultState();
        }
      }

      this._clipPreview = value;
    }
  }]);

  return GLTFModel;
}(miniprogram.Component);

var Model = /*#__PURE__*/function (_MeshRenderer) {
  _inheritsLoose(Model, _MeshRenderer);

  function Model(entity) {
    var _this;

    _this = _MeshRenderer.call(this, entity) || this;
    _this._props = null;

    _this.setMaterial(new miniprogram.BlinnPhongMaterial(_this.engine));

    return _this;
  }

  var _proto = Model.prototype;

  _proto.setProps = function setProps(props) {
    if (props === void 0) {
      props = {};
    }

    if (this._props !== props) {
      this._props = props;
    }

    switch (props.geometryType) {
      case "Sphere":
        this.mesh = miniprogram.PrimitiveMesh.createSphere(this._engine, props.sphereRadius, props.sphereSegments);
        break;

      case "Cylinder":
        this.mesh = miniprogram.PrimitiveMesh.createCylinder(this._engine, props.cylinderRadiusTop, props.cylinderRadiusBottom, props.cylinderHeight, props.cylinderRadialSegments, props.cylinderHeightSegments);
        break;

      case "Plane":
        this.mesh = miniprogram.PrimitiveMesh.createPlane(this._engine, props.planeWidth, props.planeHeight, props.planeHorizontalSegments, props.planeVerticalSegments);
        break;

      case "Box":
        this.mesh = miniprogram.PrimitiveMesh.createCuboid(this._engine, props.boxWidth, props.boxHeight, props.boxDepth);
        break;
    }
  };

  _proto.updateProp = function updateProp(key, value) {
    var props = this._props;
    props[key] = value;
    this.setProps(props);
  };

  _createClass(Model, [{
    key: "material",
    get: function get() {
      return this.getMaterial();
    },
    set: function set(mtl) {
      this.setMaterial(mtl);
    }
  }]);

  return Model;
}(miniprogram.MeshRenderer);

var PluginManager = /*#__PURE__*/function () {
  function PluginManager() {
    this.registeredPlugins = new Set();
    this.plugins = [];
  }

  var _proto = PluginManager.prototype;

  _proto.register = function register(plugin) {
    this.registeredPlugins.add(plugin);
  };

  _proto.boot = function boot(oasis) {
    for (var _iterator = _createForOfIteratorHelperLoose(this.registeredPlugins.values()), _step; !(_step = _iterator()).done;) {
      var plugin = _step.value;

      if (typeof plugin === "function") {
        plugin = plugin(oasis);
      }

      this.plugins.push(plugin);
    }
  };

  _proto.reset = function reset() {
    this.registeredPlugins.clear();
    this.plugins = [];
  };

  _proto.nodeAdded = function nodeAdded(entity) {
    this.delegateMethod("nodeAdded", entity);
  };

  _proto.delegateMethod = function delegateMethod(name) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    this.plugins.forEach(function (plugin) {
      return plugin[name] && plugin[name].apply(plugin, args);
    });
  };

  return PluginManager;
}();
function pluginHook(options) {
  return function (target, propertyName, descriptor) {
    var method = descriptor.value;

    descriptor.value = function () {
      var _this$oasis$pluginMan,
          _this = this;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      options.before && (_this$oasis$pluginMan = this.oasis.pluginManager).delegateMethod.apply(_this$oasis$pluginMan, [options.before].concat(args));
      return Promise.resolve(method.apply(this, arguments)).then(function (returnObj) {
        options.after && _this.oasis.pluginManager.delegateMethod(options.after, returnObj);
        return returnObj;
      });
    };
  };
}

/**
 * temp compa
 * @param config
 */

function compatibleToV2(config) {
  var _config$abilities = config.abilities,
      abilities = _config$abilities === void 0 ? {} : _config$abilities,
      _config$assets = config.assets,
      assets = _config$assets === void 0 ? {} : _config$assets,
      _config$scene = config.scene,
      scene = _config$scene === void 0 ? {} : _config$scene;
  var ids = Object.keys(abilities);
  var assetKeys = Object.keys(assets);
  var sceneKeys = Object.keys(scene || {});

  for (var i = 0, l = ids.length; i < l; ++i) {
    handleComponents(abilities[ids[i]].props);
  }

  for (var _i = 0, _l = assetKeys.length; _i < _l; ++_i) {
    handleAssets(assets[assetKeys[_i]].props);
  }

  for (var _i2 = 0, _l2 = sceneKeys.length; _i2 < _l2; ++_i2) {
    handleSceneProps(scene[sceneKeys[_i2]].props);
  }

  return config;
} // TODO temp

function handleComponents(props) {
  var keys = Object.keys(props);

  for (var i = 0, l = keys.length; i < l; ++i) {
    var k = keys[i];
    var v = props[k];

    if (Array.isArray(v) && typeof v[0] !== "object") {
      if (["color", "diffuseColor", "specularColor"].indexOf(k) !== -1) {
        props[k] = new miniprogram$1.Color(v[0], v[1], v[2], v[3]);
      } else if (v.length === 4) {
        props[k] = new miniprogram$1.Vector4(v[0], v[1], v[2], v[3]);
      } else if (v.length === 3) {
        props[k] = new miniprogram$1.Vector3(v[0], v[1], v[2]);
      } else if (v.length === 2) {
        props[k] = new miniprogram$1.Vector2(v[0], v[1]);
      }
    }
  }
}

var sh = new miniprogram$1.SphericalHarmonics3();

function handleSceneProps(props) {
  var keys = Object.keys(props);

  for (var i = 0, l = keys.length; i < l; ++i) {
    var k = keys[i];
    var v = props[k];

    if (Array.isArray(v) && typeof v[0] !== "object") {
      if (/color/i.test(k)) {
        props[k] = new miniprogram$1.Color(v[0], v[1], v[2], v[3]);
      } else if (v.length === 4) {
        props[k] = new miniprogram$1.Vector4(v[0], v[1], v[2], v[3]);
      } else if (v.length === 3) {
        props[k] = new miniprogram$1.Vector3(v[0], v[1], v[2]);
      } else if (v.length === 2) {
        props[k] = new miniprogram$1.Vector2(v[0], v[1]);
      }
    } else if (v && k === "diffuseSphericalHarmonics") {
      sh.setValueByArray(JSON.parse(v));
      props[k] = sh;
    }
  }
}

function handleAssets(props) {
  if (props === void 0) {
    props = {};
  }

  if (!props) {
    return;
  }

  var keys = Object.keys(props);

  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    var value = props[key];

    if (key === "newMaterial" || key === "scripts") {
      continue;
    }

    if (Array.isArray(value) && typeof value[0] !== "object") {
      if (["emissiveColor", "diffuseColor", "specularColor", "baseColor"].indexOf(key) !== -1) {
        props[key] = new miniprogram$1.Color(value[0], value[1], value[2], value[3]);
      } else if (value.length === 4) {
        props[key] = new miniprogram$1.Vector4(value[0], value[1], value[2], value[3]);
      } else if (value.length === 3) {
        props[key] = new miniprogram$1.Vector3(value[0], value[1], value[2]);
      } else if (value.length === 2) {
        props[key] = new miniprogram$1.Vector2(value[0], value[1]);
      }
    }
  }
}

var CURRENT_SCHEMA_VERSION = 3;
var Parser = /*#__PURE__*/function () {
  var _proto = Parser.prototype;

  /**
   * Parse a scene config.
   * @param options - Options of scene
   */
  _proto.parse = function parse(options) {
    var _options$config;

    if ((options === null || options === void 0 ? void 0 : (_options$config = options.config) === null || _options$config === void 0 ? void 0 : _options$config.version) !== CURRENT_SCHEMA_VERSION) {
      var _options$config2;

      console.warn("schema-parser: schema version \"" + (options === null || options === void 0 ? void 0 : (_options$config2 = options.config) === null || _options$config2 === void 0 ? void 0 : _options$config2.version) + "\" is out of date, please re-pull the latest version (version " + CURRENT_SCHEMA_VERSION + ") of the schema");
    }

    compatibleToV2(options.config);
    return Oasis.create(options, this.pluginManager);
  };

  _proto.register = function register(plugin) {
    this.pluginManager.register(plugin);
  };

  _proto.resetPlugins = function resetPlugins() {
    this.pluginManager.reset();
  };

  function Parser() {
    this.pluginManager = new PluginManager();
  }

  Parser.create = function create() {
    var parser = new Parser();
    return parser;
  }
  /** @internal */
  ;

  /**
   * Register parsing component
   * @param namespace - Namespace
   * @param components - Components
   */
  Parser.registerComponents = function registerComponents(namespace, components) {
    if (!this._components[namespace]) {
      this._components[namespace] = {};
    }

    _extends(this._components[namespace], components);
  };

  return Parser;
}();
Parser._components = {};
var parser = Parser.create();

function switchElementsIndex(elements, currentIndex, targetIndex) {
  if (currentIndex === targetIndex || targetIndex === null || targetIndex === undefined) {
    return;
  }

  var _ref = [elements[targetIndex], elements[currentIndex]];
  elements[currentIndex] = _ref[0];
  elements[targetIndex] = _ref[1];
}
function isAsset(config) {
  return config && config.type === "asset";
}
function getAllGetters(obj) {
  var result = [];
  var prototype = Object.getPrototypeOf(obj);
  var prototype_property_descriptors = Object.getOwnPropertyDescriptors(prototype);

  for (var _i = 0, _Object$entries = Object.entries(prototype_property_descriptors); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _Object$entries[_i],
        property = _Object$entries$_i[0],
        descriptor = _Object$entries$_i[1];

    if (typeof descriptor.get === "function") {
      result.push(property);
    }
  }

  return result;
}

var SchemaResource = /*#__PURE__*/function () {
  var _proto = SchemaResource.prototype;

  _proto.setMeta = function setMeta() {};

  function SchemaResource(resourceManager, _resource) {
    this.resourceManager = resourceManager;
    this._resource = _resource;
    this._meta = {};
    this._attachedResources = [];
    this.setMeta();
  }

  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceLoader, assetConfig, oasis) {
    var _this = this;

    return new Promise(function (resolve, reject) {
      _this.load(resourceLoader, assetConfig, oasis).then(function () {
        resolve({
          resources: [_this],
          structure: {
            index: 0,
            props: {}
          }
        });
      }).catch(function (e) {
        reject(e);
      });
    });
  };

  _proto.getProps = function getProps() {
    return {};
  };

  _proto.bind = function bind() {};

  _proto.attach = function attach() {};

  _proto.update = function update(key, value) {
    if (isAsset(value)) {
      var resource = this.resourceManager.get(value.id);

      if (resource) {
        this._resource[key] = resource.resource;
      } else {
        miniprogram.Logger.warn("SchemaResource: " + this.meta.name + " can't find asset, which id is: " + value.id);
      }
    } else {
      this._resource[key] = value;
    }
  };

  _proto.updateMeta = function updateMeta(key, value) {
    this._meta[key] = value;
  };

  _proto.onDestroy = function onDestroy() {};

  _createClass(SchemaResource, [{
    key: "resource",
    get:
    /**
     * Resource
     */
    function get() {
      return this._resource;
    }
  }, {
    key: "meta",
    get: function get() {
      return this._meta;
    }
  }, {
    key: "attachedResources",
    get: function get() {
      return this._attachedResources;
    }
  }]);

  return SchemaResource;
}();

var AnimationClipResource = /*#__PURE__*/function (_SchemaResource) {
  _inheritsLoose(AnimationClipResource, _SchemaResource);

  function AnimationClipResource() {
    return _SchemaResource.apply(this, arguments) || this;
  }

  var _proto = AnimationClipResource.prototype;

  _proto.load = function load(resourceManager, assetConfig) {
    var _this = this;

    return new Promise(function (resolve) {
      _this._resource = assetConfig.props || {};

      _this.setMeta();

      resolve(_this);
    });
  };

  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this2 = this;

    return new Promise(function (resolve, reject) {
      var loadPromise;

      if (assetConfig.props) {
        loadPromise = _this2.load(resourceManager, assetConfig);
      } else {
        reject("Load AnimationClip Error");
      }

      if (loadPromise) {
        loadPromise.then(function () {
          var result = {
            resources: [_this2],
            structure: {
              index: 0,
              props: {}
            }
          };
          resolve(result);
        });
      }
    });
  };

  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };

  _proto.getProps = function getProps() {
    return this._resource;
  };

  return AnimationClipResource;
}(SchemaResource);

var AnimatorControllerResource = /*#__PURE__*/function (_SchemaResource) {
  _inheritsLoose(AnimatorControllerResource, _SchemaResource);

  function AnimatorControllerResource() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.gltf = void 0;
    _this.animatorControllerData = void 0;
    _this.animationClipAssets = void 0;
    _this.animationsIndices = void 0;
    return _this;
  }

  var _proto = AnimatorControllerResource.prototype;

  _proto.load = function load(resourceManager, assetConfig) {
    var _this2 = this;

    return new Promise(function (resolve) {
      var _ref = assetConfig.props || {},
          animatorController = _ref.animatorController,
          animationClipAssets = _ref.animationClips,
          animationsIndices = _ref.animationsIndices,
          gltf = _ref.gltf;

      _this2._resource = new miniprogram.AnimatorController();
      _this2.animatorControllerData = animatorController;
      _this2.animationsIndices = animationsIndices || [];
      _this2.animationClipAssets = animationClipAssets || [];
      _this2.gltf = gltf;
      !animatorController && _this2._setDefaultDataByAnimationClip();

      _this2.setMetaData("name", assetConfig.name);

      resolve(_this2);
    });
  };

  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this3 = this;

    return new Promise(function (resolve, reject) {
      var clipLoadPromises = [];

      _this3.load(resourceManager, assetConfig).then(function () {
        var result = {
          resources: [_this3],
          structure: {
            index: 0,
            props: {
              animationClips: []
            }
          }
        };
        var animations = _this3.animationsIndices;

        for (var i = 0, length = animations.length; i < length; ++i) {
          var clip = animations[i];
          var clipResourse = new AnimationClipResource(_this3.resourceManager);

          _this3.attachedResources.push(clipResourse);

          clipLoadPromises.push(clipResourse.loadWithAttachedResources(resourceManager, {
            type: "animationClip",
            name: clip.name,
            props: clip
          }));
        }

        Promise.all(clipLoadPromises).then(function (res) {
          var animationClips = result.structure.props.animationClips;
          res.forEach(function (clip) {
            var clipStructure = clip.structure;
            var clipResource = clip.resources[clipStructure.index];
            result.resources.push(clipResource);
            clipStructure.index = result.resources.length - 1;
            animationClips.push(clipStructure);
          });
          resolve(result);
        });
      });
    });
  };

  _proto.setMetaData = function setMetaData(key, value) {
    this._meta[key] = value;
  };

  _proto.update = function update(key, value) {
    this._initAnimatorController(value);
  };

  _proto.bind = function bind() {
    var animatorControllerData = this.animatorControllerData,
        animationClipAssets = this.animationClipAssets;

    this._bindClips(animationClipAssets);

    if (animatorControllerData) {
      this._initAnimatorController(animatorControllerData);
    } else {
      this._setDefaultDataByAnimationClipAsset();
    }
  };

  _proto._initAnimatorController = function _initAnimatorController(animatorControllerData) {
    var _ref2 = this.gltf || {},
        animations = _ref2.animations;

    var layers = animatorControllerData.layers;
    if (!animations || !layers) return;

    this._resource.clearLayers();

    for (var i = 0, length = layers.length; i < length; ++i) {
      var _layers$i = layers[i],
          name = _layers$i.name,
          blending = _layers$i.blending,
          weight = _layers$i.weight,
          stateMachineData = _layers$i.stateMachine;
      if (!stateMachineData) continue;
      var layer = new miniprogram.AnimatorControllerLayer(name);
      layer.blendingMode = blending;
      layer.weight = weight;
      var states = stateMachineData.states;
      var stateMachine = new miniprogram.AnimatorStateMachine();
      var stateMachineTransitions = [];

      for (var j = 0, _length = states.length; j < _length; ++j) {
        var stateData = states[j];
        var _name = stateData.name,
            transitions = stateData.transitions,
            clip = stateData.clip,
            speed = stateData.speed,
            wrapMode = stateData.wrapMode,
            clipStartNormalizedTime = stateData.clipStartNormalizedTime,
            clipEndNormalizedTime = stateData.clipEndNormalizedTime,
            isDefaultState = stateData.isDefaultState;

        var _ref3 = clip || {},
            clipAssetId = _ref3.id;

        if (!clipAssetId) continue;
        var uniqueName = stateMachine.makeUniqueStateName(_name);

        if (uniqueName !== _name) {
          console.warn("AnimatorState name is existed, name: " + _name + " reset to " + uniqueName);
        }

        var state = stateMachine.addState(uniqueName);
        state.speed = speed;
        state.wrapMode = wrapMode;
        var animationIndex = this.resourceManager.get(clipAssetId).resource;
        var animationClip = animations[animationIndex.index];
        if (!animationClip) continue;
        state.clip = animationClip;
        state.clipStartTime = animationClip.length * clipStartNormalizedTime;
        state.clipEndTime = animationClip.length * clipEndNormalizedTime;

        for (var _j = 0, _length2 = transitions.length; _j < _length2; ++_j) {
          var transition = transitions[_j];
          transitions[_j].srcState = state;
          stateMachineTransitions.push(transition);
        }

        if (isDefaultState) {
          //@ts-ignore
          stateMachine._defaultState = state;
        }
      }

      for (var _j2 = 0, _length3 = stateMachineTransitions.length; _j2 < _length3; ++_j2) {
        var transitionData = stateMachineTransitions[_j2];

        var _transition = new miniprogram.AnimatorStateTransition();

        _transition.duration = transitionData.duration;
        _transition.offset = transitionData.offset;
        _transition.exitTime = transitionData.exitTime;
        _transition.destinationState = stateMachine.findStateByName(transitionData.targetStateName);
        transitionData.srcState.addTransition(_transition);
        delete transitionData.srcState;
      }

      layer.stateMachine = stateMachine;

      this._resource.addLayer(layer);
    }
  };

  _proto._bindClips = function _bindClips(animationClips) {
    for (var i = 0, length = animationClips.length; i < length; i++) {
      var clipAsset = animationClips[i];
      var clipResource = this.resourceManager.get(clipAsset.id);

      if (clipResource) {
        this._attachedResources.push(clipResource);
      } else {
        "AnimatorResource: " + this.meta.name + " can't find asset \"animationClip\", which id is: " + clipAsset.id;
      }
    }
  };

  _proto._setDefaultDataByAnimationClipAsset = function _setDefaultDataByAnimationClipAsset() {
    var animationClipAssets = this.animationClipAssets;

    if (!animationClipAssets.length) {
      return;
    }

    var clips = [];

    for (var i = 0, length = animationClipAssets.length; i < length; i++) {
      var clipAsset = this.resourceManager.get(animationClipAssets[i].id);
      clips.push(clipAsset.resource);
    }

    this.animationsIndices = clips;

    this._setDefaultDataByAnimationClip();
  };

  _proto._setDefaultDataByAnimationClip = function _setDefaultDataByAnimationClip() {
    var animationsIndices = this.animationsIndices,
        animatorController = this._resource,
        gltf = this.gltf;

    if (!animationsIndices.length || !gltf) {
      return;
    }

    var animations = gltf.animations;
    var layer = new miniprogram.AnimatorControllerLayer("layer");
    var animatorStateMachine = new miniprogram.AnimatorStateMachine();
    animatorController.addLayer(layer);
    layer.stateMachine = animatorStateMachine;

    for (var i = 0, length = animationsIndices.length; i < length; i++) {
      var animationIndex = animationsIndices[i];
      var name = animationIndex.name,
          index = animationIndex.index;
      var uniqueName = animatorStateMachine.makeUniqueStateName(name);

      if (uniqueName !== name) {
        console.warn("AnimatorState name is existed, name: " + name + " reset to " + uniqueName);
      }

      var animatorState = animatorStateMachine.addState(uniqueName);
      animatorState.clip = animations[index];
    }
  };

  return AnimatorControllerResource;
}(SchemaResource);

var TextureResource = /*#__PURE__*/function (_SchemaResource) {
  _inheritsLoose(TextureResource, _SchemaResource);

  function TextureResource() {
    return _SchemaResource.apply(this, arguments) || this;
  }

  var _proto = TextureResource.prototype;

  _proto.load = function load(resourceManager, assetConfig, oasis) {
    var _this = this;

    return new Promise(function (resolve, reject) {
      var _assetConfig$props, _assetConfig$props$co, _url;

      var url;
      var assetType = miniprogram.AssetType.Texture2D;

      if (_this.resourceManager.useCompressedTexture && assetConfig !== null && assetConfig !== void 0 && (_assetConfig$props = assetConfig.props) !== null && _assetConfig$props !== void 0 && (_assetConfig$props$co = _assetConfig$props.compression) !== null && _assetConfig$props$co !== void 0 && _assetConfig$props$co.compressions.length) {
        var rhi = oasis.engine._hardwareRenderer;
        var compressions = assetConfig.props.compression.compressions;

        for (var i = 0; i < compressions.length; i++) {
          var compression = compressions[i];

          if (compression.container === "ktx" && rhi.canIUse(miniprogram.GLCapabilityType[compression.type])) {
            url = compression.url;
            assetType = miniprogram.AssetType.KTX;
            break;
          }
        }
      }

      url = (_url = url) != null ? _url : assetConfig.url;
      resourceManager.load({
        url: url,
        type: assetType
      }).then(function (res) {
        _this._resource = res;
        resolve(_this);
      }).catch(function (e) {
        reject(e);
      });
    });
  };

  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this._meta.name = this.resource.name;
    }
  };

  return TextureResource;
}(SchemaResource);

var BlinnPhongMaterialResource = /*#__PURE__*/function (_SchemaResource) {
  _inheritsLoose(BlinnPhongMaterialResource, _SchemaResource);

  function BlinnPhongMaterialResource() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.configProps = void 0;
    return _this;
  }

  var _proto = BlinnPhongMaterialResource.prototype;

  _proto.load = function load(resourceManager, assetConfig) {
    var _this2 = this;

    return new Promise(function (resolve) {
      var assetObj = new miniprogram.BlinnPhongMaterial(resourceManager.engine);
      _this2.configProps = assetConfig.props;
      _this2._resource = assetObj;

      for (var k in _this2.configProps) {
        if (!isAsset(_this2.configProps[k])) {
          assetObj[k] = _this2.configProps[k];
        }
      }

      _this2.setMeta();

      resolve(_this2);
    });
  };

  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this3 = this;

    return new Promise(function (resolve, reject) {
      var loadPromise;

      if (assetConfig.resource instanceof miniprogram.BlinnPhongMaterial) {
        loadPromise = new Promise(function (resolve) {
          _this3._resource = assetConfig.resource;

          _this3.setMeta();

          resolve(_this3);
        });
      } else if (assetConfig.props) {
        loadPromise = _this3.load(resourceManager, assetConfig);
      } else {
        reject("Load BlinnPhongMaterial Error");
      }

      if (loadPromise) {
        loadPromise.then(function () {
          var result = {
            resources: [_this3],
            structure: {
              index: 0,
              props: {}
            }
          };
          var material = _this3._resource;
          getAllGetters(_this3._resource).forEach(function (attr) {
            if (!(material[attr] instanceof miniprogram.Texture)) return;
            var textureResource = new TextureResource(_this3.resourceManager, material[attr]);

            _this3.attachedResources.push(textureResource);

            result.resources.push(textureResource);
            result.structure.props[attr] = {
              index: result.resources.length - 1
            };
          });
          resolve(result);
        });
      }
    });
  };

  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };

  _proto.bind = function bind() {
    var _this4 = this;

    var resource = this._resource;
    Object.keys(this.configProps).forEach(function (attr) {
      var value = _this4.configProps[attr];

      if (isAsset(value)) {
        var textureResource = _this4.resourceManager.get(value.id);

        if (textureResource && textureResource instanceof TextureResource) {
          resource[attr] = textureResource.resource;

          _this4._attachedResources.push(textureResource);
        } else {
          resource[attr] = null;
          miniprogram.Logger.warn("BlinnPhongMaterialResource: " + _this4.meta.name + " can't find asset \"" + attr + "\", which id is: " + value.id);
        }
      } else {
        resource[attr] = value;
      }
    });
  };

  return BlinnPhongMaterialResource;
}(SchemaResource);

var attrs$1 = ["metallic", "roughness", "roughnessMetallicTexture", // pbr base
"tilingOffset", "baseColor", "normalTextureIntensity", "emissiveColor", "occlusionTextureIntensity", "baseTexture", "normalTexture", "emissiveTexture", "occlusionTexture", // base material
"isTransparent", "alphaCutoff", "renderFace", "blendMode"];
var PBRMaterialResource = /*#__PURE__*/function (_SchemaResource) {
  _inheritsLoose(PBRMaterialResource, _SchemaResource);

  function PBRMaterialResource() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.configProps = void 0;
    return _this;
  }

  var _proto = PBRMaterialResource.prototype;

  _proto.load = function load(resourceManager, assetConfig) {
    var _this2 = this;

    return new Promise(function (resolve) {
      var assetObj = new miniprogram.PBRMaterial(resourceManager.engine);
      _this2.configProps = assetConfig.props;

      for (var k in _this2.configProps) {
        if (!isAsset(_this2.configProps[k])) {
          assetObj[k] = _this2.configProps[k];
        }
      }

      _this2._resource = assetObj;

      _this2.setMeta();

      resolve(_this2);
    });
  };

  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this3 = this;

    return new Promise(function (resolve, reject) {
      var loadPromise;

      if (assetConfig.resource instanceof miniprogram.PBRMaterial) {
        loadPromise = new Promise(function (resolve) {
          _this3._resource = assetConfig.resource;

          _this3.setMeta();

          resolve(_this3);
        });
      } else if (assetConfig.props) {
        loadPromise = _this3.load(resourceManager, assetConfig);
      } else {
        reject("Load PBRMaterial Error");
      }

      if (loadPromise) {
        loadPromise.then(function () {
          var result = {
            resources: [_this3],
            structure: {
              index: 0,
              props: {}
            }
          };
          var material = _this3._resource;
          attrs$1.forEach(function (attr) {
            if (!(material[attr] instanceof miniprogram.Texture)) return;
            var textureResource = new TextureResource(_this3.resourceManager, material[attr]);

            _this3.attachedResources.push(textureResource);

            result.resources.push(textureResource);
            result.structure.props[attr] = {
              index: result.resources.length - 1
            };
          });
          resolve(result);
        });
      }
    });
  };

  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };

  _proto.getProps = function getProps() {
    var _this4 = this;

    var result = {};
    attrs$1.forEach(function (prop) {
      return result[prop] = _this4.resource[prop];
    });
    return result;
  };

  _proto.bind = function bind() {
    var _this5 = this;

    var resource = this._resource;
    Object.keys(this.configProps).forEach(function (attr) {
      var value = _this5.configProps[attr];

      if (isAsset(value)) {
        var textureResource = _this5.resourceManager.get(value.id);

        if (textureResource && textureResource instanceof TextureResource) {
          resource[attr] = textureResource.resource;

          _this5._attachedResources.push(textureResource);
        } else {
          resource[attr] = null;
          miniprogram.Logger.warn("PBRMaterialResource: " + _this5.meta.name + " can't find asset \"" + attr + "\", which id is: " + value.id);
        }
      } else {
        resource[attr] = value;
      }
    });
  };

  return PBRMaterialResource;
}(SchemaResource);

var attrs = ["specularColor", "glossiness", "specularGlossinessTexture", // pbr base
"tilingOffset", "baseColor", "normalTextureIntensity", "emissiveColor", "occlusionTextureIntensity", "baseTexture", "normalTexture", "emissiveTexture", "occlusionTexture", // base material
"isTransparent", "alphaCutoff", "renderFace", "blendMode"];
var PBRSpecularMaterialResource = /*#__PURE__*/function (_SchemaResource) {
  _inheritsLoose(PBRSpecularMaterialResource, _SchemaResource);

  function PBRSpecularMaterialResource() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.configProps = void 0;
    return _this;
  }

  var _proto = PBRSpecularMaterialResource.prototype;

  _proto.load = function load(resourceManager, assetConfig) {
    var _this2 = this;

    return new Promise(function (resolve) {
      var assetObj = new miniprogram.PBRSpecularMaterial(resourceManager.engine);
      _this2.configProps = assetConfig.props;
      _this2._resource = assetObj;

      for (var k in _this2.configProps) {
        if (!isAsset(_this2.configProps[k])) {
          assetObj[k] = _this2.configProps[k];
        }
      }

      _this2.setMeta();

      resolve(_this2);
    });
  };

  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this3 = this;

    return new Promise(function (resolve, reject) {
      var loadPromise;

      if (assetConfig.resource instanceof miniprogram.PBRSpecularMaterial) {
        loadPromise = new Promise(function (resolve) {
          _this3._resource = assetConfig.resource;

          _this3.setMeta();

          resolve(_this3);
        });
      } else if (assetConfig.props) {
        loadPromise = _this3.load(resourceManager, assetConfig);
      } else {
        reject("Load PBRSpecularMaterial Error");
      }

      if (loadPromise) {
        loadPromise.then(function () {
          var result = {
            resources: [_this3],
            structure: {
              index: 0,
              props: {}
            }
          };
          var material = _this3._resource;
          Object.keys(_this3._resource).forEach(function (attr) {
            if (!(material[attr] instanceof miniprogram.Texture)) return;
            var textureResource = new TextureResource(_this3.resourceManager, material[attr]);

            _this3.attachedResources.push(textureResource);

            result.resources.push(textureResource);
            result.structure.props[attr] = {
              index: result.resources.length - 1
            };
          });
          resolve(result);
        });
      }
    });
  };

  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };

  _proto.getProps = function getProps() {
    var _this4 = this;

    var result = {};
    attrs.forEach(function (prop) {
      return result[prop] = _this4.resource[prop];
    });
    return result;
  };

  _proto.bind = function bind() {
    var _this5 = this;

    var resource = this._resource;
    Object.keys(this.configProps).forEach(function (attr) {
      var value = _this5.configProps[attr];

      if (isAsset(value)) {
        var textureResource = _this5.resourceManager.get(value.id);

        if (textureResource && textureResource instanceof TextureResource) {
          resource[attr] = textureResource.resource;

          _this5._attachedResources.push(textureResource);
        } else {
          resource[attr] = null;
          miniprogram.Logger.warn("PBRSpecularMaterialResource: " + _this5.meta.name + " can't find asset \"" + attr + "\", which id is: " + value.id);
        }
      } else {
        resource[attr] = value;
      }
    });
  };

  return PBRSpecularMaterialResource;
}(SchemaResource);

var UnlitMaterialResource = /*#__PURE__*/function (_SchemaResource) {
  _inheritsLoose(UnlitMaterialResource, _SchemaResource);

  function UnlitMaterialResource() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.configProps = void 0;
    return _this;
  }

  var _proto = UnlitMaterialResource.prototype;

  _proto.load = function load(resourceManager, assetConfig) {
    var _this2 = this;

    return new Promise(function (resolve) {
      var assetObj = new miniprogram.UnlitMaterial(resourceManager.engine);
      _this2.configProps = assetConfig.props;

      for (var k in _this2.configProps) {
        if (!isAsset(_this2.configProps[k])) {
          assetObj[k] = _this2.configProps[k];
        }
      }

      _this2._resource = assetObj;

      _this2.setMeta();

      resolve(_this2);
    });
  };

  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this3 = this;

    return new Promise(function (resolve, reject) {
      var loadPromise;

      if (assetConfig.resource instanceof miniprogram.UnlitMaterial) {
        loadPromise = new Promise(function (resolve) {
          _this3._resource = assetConfig.resource;

          _this3.setMeta();

          resolve(_this3);
        });
      } else if (assetConfig.props) {
        loadPromise = _this3.load(resourceManager, assetConfig);
      } else {
        reject("Load PBRMaterial Error");
      }

      if (loadPromise) {
        loadPromise.then(function () {
          var result = {
            resources: [_this3],
            structure: {
              index: 0,
              props: {}
            }
          };
          var material = _this3._resource;
          getAllGetters(_this3._resource).forEach(function (attr) {
            if (!(material[attr] instanceof miniprogram.Texture)) return;
            var textureResource = new TextureResource(_this3.resourceManager, material[attr]);

            _this3.attachedResources.push(textureResource);

            result.resources.push(textureResource);
            result.structure.props[attr] = {
              index: result.resources.length - 1
            };
          });
          resolve(result);
        });
      }
    });
  };

  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };

  _proto.getProps = function getProps() {
    var _this4 = this;

    var result = {};
    var props = getAllGetters(this.resource);
    props.forEach(function (prop) {
      return result[prop] = _this4.resource[prop];
    });
    return result;
  };

  _proto.bind = function bind() {
    var _this5 = this;

    var resource = this._resource;
    Object.keys(this.configProps).forEach(function (attr) {
      var value = _this5.configProps[attr];

      if (isAsset(value)) {
        var textureResource = _this5.resourceManager.get(value.id);

        if (textureResource && textureResource instanceof TextureResource) {
          resource[attr] = textureResource.resource;

          _this5._attachedResources.push(textureResource);
        } else {
          resource[attr] = null;
          miniprogram.Logger.warn("PBRMaterialResource: " + _this5.meta.name + " can't find asset \"" + attr + "\", which id is: " + value.id);
        }
      } else {
        resource[attr] = value;
      }
    });
  };

  return UnlitMaterialResource;
}(SchemaResource);

var GLTFResource = /*#__PURE__*/function (_SchemaResource) {
  _inheritsLoose(GLTFResource, _SchemaResource);

  function GLTFResource() {
    return _SchemaResource.apply(this, arguments) || this;
  }

  var _proto = GLTFResource.prototype;

  _proto.load = function load(resourceManager, assetConfig, oasis) {
    var _this = this;

    return resourceManager.load({
      url: assetConfig.url,
      type: miniprogram.AssetType.Prefab
    }).then(function (res) {
      var gltf = res;

      if (assetConfig.props) {
        gltf.newMaterial = assetConfig.props.newMaterial;
        gltf.animatorControllers = assetConfig.props.animatorControllers;
      }

      _this._resource = gltf;
    });
  };

  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig, oasis) {
    var _this2 = this;

    return new Promise(function (resolve) {
      _this2.load(resourceManager, assetConfig, oasis).then(function () {
        var gltf = _this2.resource;

        var _gltf$materials = gltf.materials,
            materials = _gltf$materials === void 0 ? [] : _gltf$materials,
            _gltf$_animationsIndi = gltf._animationsIndices,
            _animationsIndices = _gltf$_animationsIndi === void 0 ? [] : _gltf$_animationsIndi;

        var materialLoadPromises = [];
        var animatorControllerLoadPromise;
        var result = {
          resources: [_this2],
          structure: {
            index: 0,
            props: {
              newMaterial: [],
              animatorControllers: []
            }
          }
        };

        if (materials !== null && materials !== void 0 && materials.length) {
          for (var i = 0; i < materials.length; i++) {
            var material = materials[i];
            var materialResource = null;
            var type = "";

            if (material instanceof miniprogram.PBRMaterial) {
              materialResource = new PBRMaterialResource(_this2.resourceManager);
              type = "PBRMaterial";
            } else if (material instanceof miniprogram.UnlitMaterial) {
              materialResource = new UnlitMaterialResource(_this2.resourceManager);
              type = "UnlitMaterial";
            } else if (material instanceof miniprogram.PBRSpecularMaterial) {
              materialResource = new PBRSpecularMaterialResource(_this2.resourceManager);
              type = "PBRSpecularMaterial";
            } else {
              materialResource = new BlinnPhongMaterialResource(_this2.resourceManager);
              type = "BlinnPhongMaterial";
            }

            _this2._attachedResources.push(materialResource);

            materialLoadPromises.push(materialResource.loadWithAttachedResources(resourceManager, {
              type: type,
              name: material.name,
              resource: material
            }));
          }
        }

        if (_animationsIndices.length) {
          var animatorControllerResource = new AnimatorControllerResource(_this2.resourceManager);

          _this2._attachedResources.push(animatorControllerResource);

          animatorControllerLoadPromise = animatorControllerResource.loadWithAttachedResources(resourceManager, {
            type: "animatorController",
            name: "AnimatorController",
            props: {
              animationsIndices: _animationsIndices,
              gltf: _this2._resource
            }
          });
        }

        var loadAttachedMaterial = Promise.all(materialLoadPromises).then(function (res) {
          var newMaterial = result.structure.props.newMaterial;
          res.forEach(function (mat) {
            var matStructure = mat.structure;
            var matResource = mat.resources[matStructure.index];
            result.resources.push(matResource);
            matStructure.index = result.resources.length - 1;

            for (var key in matStructure.props) {
              if (matStructure.props.hasOwnProperty(key)) {
                var textureStructure = matStructure.props[key];
                var textureResource = mat.resources[textureStructure.index];
                result.resources.push(textureResource);
                textureStructure.index = result.resources.length - 1;
              }
            }

            newMaterial.push(matStructure);
          });
        });
        var loadAttachedController = animatorControllerLoadPromise ? animatorControllerLoadPromise.then(function (res) {
          var animatorControllers = result.structure.props.animatorControllers;
          var controllerStructure = res.structure;
          var controllerResource = res.resources[controllerStructure.index];
          result.resources.push(controllerResource);
          controllerStructure.index = result.resources.length - 1;
          var animationClips = controllerStructure.props.animationClips;

          if (animationClips) {
            for (var _i = 0, length = animationClips.length; _i < length; ++_i) {
              var clipStructure = animationClips[_i];
              var clipResource = res.resources[clipStructure.index];
              result.resources.push(clipResource);
              clipStructure.index = result.resources.length - 1;
            }
          }

          animatorControllers.push(controllerStructure);
        }) : Promise.resolve();
        Promise.all([loadAttachedMaterial, loadAttachedController]).then(function () {
          resolve(result);
        });
      });
    });
  };

  _proto.setMeta = function setMeta(assetConfig) {
    if (assetConfig) {
      this.meta.name = assetConfig.name;
    }
  };

  _proto.bind = function bind() {
    var resource = this._resource;
    this.bindMaterials(resource.newMaterial);
    this.bindAnimatorControllers(resource.animatorControllers);
  };

  _proto.update = function update(key, value) {
    if (key === "newMaterial") {
      this.bindMaterials(value);
    } else {
      this._resource[key] = value;
    }
  };

  _proto.bindMaterials = function bindMaterials(newMaterialsConfig) {
    var newMaterialCount = newMaterialsConfig.length;

    if (!newMaterialsConfig || !newMaterialsConfig.length) {
      return;
    }

    var gltf = this._resource;
    var newMaterials = new Array(newMaterialCount);
    gltf.newMaterial = newMaterials;

    for (var i = 0; i < newMaterialsConfig.length; i++) {
      var mtlResource = this.resourceManager.get(newMaterialsConfig[i].id);

      if (mtlResource) {
        this._attachedResources.push(mtlResource);

        newMaterials[i] = mtlResource.resource;
      } else {
        miniprogram.Logger.warn("GLTFResource: " + this.meta.name + " can't find asset \"material\", which id is: " + newMaterialsConfig[i].id);
      }
    }

    var gltfRoot = gltf.defaultSceneRoot;
    var originMaterials = gltf.materials;
    var meshRenderers = gltfRoot.getComponentsIncludeChildren(miniprogram.MeshRenderer, []);

    for (var _i2 = 0; _i2 < newMaterialCount; _i2++) {
      var newMaterial = newMaterials[_i2];
      var originMaterial = originMaterials[_i2];

      for (var j = 0; j < meshRenderers.length; j++) {
        var meshRenderer = meshRenderers[j];
        var meshMaterials = meshRenderer.getMaterials();

        for (var k = 0; k < meshMaterials.length; k++) {
          if (originMaterial === meshMaterials[k]) {
            meshRenderer.setMaterial(k, newMaterial);
          }
        }
      }
    }
  };

  _proto.bindAnimatorControllers = function bindAnimatorControllers(animatorControllers) {
    for (var i = 0, length = animatorControllers.length; i < length; i++) {
      var animatorControllerAsset = animatorControllers[i];
      var controllerResource = this.resourceManager.get(animatorControllerAsset.id);
      controllerResource.gltf = this._resource;

      if (controllerResource) {
        this._attachedResources.push(controllerResource);
      } else {
        "GLTFResource: " + this.meta.name + " can't find asset \"animatorController\", which id is: " + animatorControllerAsset.id;
      }
    }
  };

  return GLTFResource;
}(SchemaResource);

var scriptAbility = {};
function script(name) {
  return function (target) {
    scriptAbility[name] = target;
  };
}
var ScriptResource = /*#__PURE__*/function (_SchemaResource) {
  _inheritsLoose(ScriptResource, _SchemaResource);

  function ScriptResource() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.isInit = false;
    return _this;
  }

  var _proto = ScriptResource.prototype;

  _proto.initScriptContext = function initScriptContext() {
    if (this.isInit) {
      return;
    }

    this.isInit = true;
    miniprogramAdapter.window.__o3_script_context__ = {
      o3: Parser._components["o3"],
      script: function script(name) {
        return function (target) {
          scriptAbility[name] = target;
        };
      }
    };
  };

  _proto.load = function load(resourceLoader, assetConfig, oasis) {
    var _this2 = this;

    this.initScriptContext();
    return new Promise(function (resolve) {
      var config = assetConfig;
      var scripts = config.props.scripts;

      if (!_this2.resourceManager.isLocal) {
        var scriptDom = miniprogramAdapter.document.createElement("script");
        scriptDom.crossOrigin = "anonymous";

        _this2.setMeta(assetConfig);

        scriptDom.onload = function () {
          var o3Scripts = miniprogramAdapter.window.o3Scripts;

          for (var i = 0; i < scripts.length; i++) {
            var name = scripts[i].name;
            _this2._resource = o3Scripts && o3Scripts[name];
            scriptAbility[name] = _this2._resource;
          }

          resolve(_this2);
        };

        scriptDom.src = assetConfig.url;
        miniprogramAdapter.document.body.appendChild(scriptDom);
      } else {
        for (var i = 0; i < scripts.length; i++) {
          var _oasis$options;

          var name = scripts[i].name;
          scriptAbility[name] = (_oasis$options = oasis.options) === null || _oasis$options === void 0 ? void 0 : _oasis$options.scripts[name];
        }

        resolve(_this2);
      }
    });
  };

  _proto.setMeta = function setMeta(assetConfig) {
    if (assetConfig) {
      this._meta.name = assetConfig.name;
      this._meta.url = assetConfig.url;
      this._meta.source = assetConfig.source;
    }
  };

  return ScriptResource;
}(SchemaResource);

var SpriteResource = /*#__PURE__*/function (_SchemaResource) {
  _inheritsLoose(SpriteResource, _SchemaResource);

  function SpriteResource() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.configProps = void 0;
    return _this;
  }

  var _proto = SpriteResource.prototype;

  _proto.load = function load(resourceManager, assetConfig) {
    var _this2 = this;

    return new Promise(function (resolve) {
      var assetObj = new miniprogram.Sprite(resourceManager.engine);
      _this2.configProps = assetConfig.props;
      var configProps = _this2.configProps;
      var pivotType = configProps.pivotType,
          pivot = configProps.pivot;

      if (typeof pivot !== "undefined" && typeof pivotType !== "undefined" && pivotType !== exports.SpritePivotType.Custom) {
        switch (pivotType) {
          case exports.SpritePivotType.Center:
            pivot.x = 0.5;
            pivot.y = 0.5;
            break;

          case exports.SpritePivotType.TopLeft:
            pivot.x = 0;
            pivot.y = 1;
            break;

          case exports.SpritePivotType.Top:
            pivot.x = 0.5;
            pivot.y = 1;
            break;

          case exports.SpritePivotType.TopRight:
            pivot.x = 1;
            pivot.y = 1;
            break;

          case exports.SpritePivotType.Left:
            pivot.x = 0;
            pivot.y = 0.5;
            break;

          case exports.SpritePivotType.Right:
            pivot.x = 1;
            pivot.y = 0.5;
            break;

          case exports.SpritePivotType.BottomLeft:
            pivot.x = 0;
            pivot.y = 0;
            break;

          case exports.SpritePivotType.Bottom:
            pivot.x = 0.5;
            pivot.y = 0;
            break;

          case exports.SpritePivotType.BottomRight:
            pivot.x = 1;
            pivot.y = 0;
            break;
        }
      }

      for (var k in configProps) {
        if (!isAsset(configProps[k]) && typeof configProps[k] !== "undefined") {
          assetObj[k] = configProps[k];
        }
      }

      _this2._resource = assetObj;

      _this2.setMeta();

      resolve(_this2);
    });
  };

  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this3 = this;

    return new Promise(function (resolve, reject) {
      var loadPromise;

      if (assetConfig.resource instanceof SpriteResource) {
        loadPromise = new Promise(function (resolve) {
          _this3._resource = assetConfig.resource;

          _this3.setMeta();

          resolve(_this3);
        });
      } else if (assetConfig.props) {
        loadPromise = _this3.load(resourceManager, assetConfig);
      } else {
        reject("Load Sprite Error");
      }

      if (loadPromise) {
        loadPromise.then(function () {
          var result = {
            resources: [_this3],
            structure: {
              index: 0,
              props: {}
            }
          };
          var sprite = _this3._resource;
          getAllGetters(_this3._resource).forEach(function (attr) {
            if (!(sprite[attr] instanceof miniprogram.Texture)) return;
            var textureResource = new TextureResource(_this3.resourceManager, sprite[attr]);

            _this3.attachedResources.push(textureResource);

            result.resources.push(textureResource);
            result.structure.props[attr] = {
              index: result.resources.length - 1
            };
          });
          resolve(result);
        });
      }
    });
  };

  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };

  _proto.getProps = function getProps() {
    var _this4 = this;

    var result = {};
    var props = getAllGetters(this.resource);
    props.forEach(function (prop) {
      return result[prop] = _this4.resource[prop];
    });
    return result;
  };

  _proto.bind = function bind() {
    var _this5 = this;

    var resource = this._resource;
    this.configProps && Object.keys(this.configProps).forEach(function (attr) {
      var value = _this5.configProps[attr];

      if (isAsset(value)) {
        var textureResource = _this5.resourceManager.get(value.id);

        if (textureResource && textureResource instanceof TextureResource) {
          resource[attr] = textureResource.resource;

          _this5._attachedResources.push(textureResource);
        } else {
          resource[attr] = null;
          miniprogram.Logger.warn("SpriteResource: " + _this5.meta.name + " can't find asset \"" + attr + "\", which id is: " + value.id);
        }
      } else {
        resource[attr] = value;
      }
    });
  };

  return SpriteResource;
}(SchemaResource);
exports.SpritePivotType = void 0;

(function (SpritePivotType) {
  SpritePivotType[SpritePivotType["Center"] = 0] = "Center";
  SpritePivotType[SpritePivotType["TopLeft"] = 1] = "TopLeft";
  SpritePivotType[SpritePivotType["Top"] = 2] = "Top";
  SpritePivotType[SpritePivotType["TopRight"] = 3] = "TopRight";
  SpritePivotType[SpritePivotType["Left"] = 4] = "Left";
  SpritePivotType[SpritePivotType["Right"] = 5] = "Right";
  SpritePivotType[SpritePivotType["BottomLeft"] = 6] = "BottomLeft";
  SpritePivotType[SpritePivotType["Bottom"] = 7] = "Bottom";
  SpritePivotType[SpritePivotType["BottomRight"] = 8] = "BottomRight";
  SpritePivotType[SpritePivotType["Custom"] = 9] = "Custom";
})(exports.SpritePivotType || (exports.SpritePivotType = {}));

var imageOrderMap = {
  px: 0,
  nx: 1,
  py: 2,
  ny: 3,
  pz: 4,
  nz: 5
};
var TextureCubeMapResource = /*#__PURE__*/function (_SchemaResource) {
  _inheritsLoose(TextureCubeMapResource, _SchemaResource);

  function TextureCubeMapResource() {
    return _SchemaResource.apply(this, arguments) || this;
  }

  var _proto = TextureCubeMapResource.prototype;

  _proto.load = function load(resourceManager, assetConfig, oasis) {
    var _this = this;

    return new Promise(function (resolve, reject) {
      var _assetConfig$props, _assetConfig$props$co;

      var imageUrls = [];
      var type = miniprogram.AssetType.TextureCube;

      if (_this.resourceManager.useCompressedTexture && assetConfig !== null && assetConfig !== void 0 && (_assetConfig$props = assetConfig.props) !== null && _assetConfig$props !== void 0 && (_assetConfig$props$co = _assetConfig$props.compression) !== null && _assetConfig$props$co !== void 0 && _assetConfig$props$co.compressions.length) {
        var rhi = oasis.engine._hardwareRenderer;
        var compressions = assetConfig.props.compression.compressions;

        for (var i = 0; i < compressions.length; i++) {
          var compression = compressions[i];

          if (compression.container === "ktx" && rhi.canIUse(miniprogram.GLCapabilityType[compression.type])) {
            for (var key in compression.files) {
              if (compression.files.hasOwnProperty(key)) {
                var image = compression.files[key];
                imageUrls[imageOrderMap[key]] = image.url;
              }
            }

            console.warn(compression.type);
            type = miniprogram.AssetType.KTXCube;
            break;
          }
        }
      }

      if (type === miniprogram.AssetType.TextureCube) {
        for (var _key in assetConfig.props.images) {
          if (assetConfig.props.images.hasOwnProperty(_key)) {
            var _image = assetConfig.props.images[_key];
            imageUrls[imageOrderMap[_key]] = _image.url;
          }
        }
      }

      resourceManager.load({
        urls: imageUrls,
        type: type
      }).then(function (res) {
        _this._resource = res;
        resolve(_this);
      }).catch(function (e) {
        reject(e);
      });
    });
  };

  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };

  return TextureCubeMapResource;
}(SchemaResource);

var BaseResource = /*#__PURE__*/function (_SchemaResource) {
  _inheritsLoose(BaseResource, _SchemaResource);

  function BaseResource() {
    return _SchemaResource.apply(this, arguments) || this;
  }

  var _proto = BaseResource.prototype;

  _proto.load = function load(resourceLoader, assetConfig) {
    var _this = this;

    return new Promise(function (resolve) {
      _this._resource = assetConfig;

      _this.setMetaData("name", _this.resource.name);

      _this.setMetaData("url", _this.resource.url);

      resolve(_this);
    });
  };

  _proto.setMetaData = function setMetaData(key, value) {
    this._meta[key] = value;
  };

  return BaseResource;
}(SchemaResource);

var _dec$4, _dec2$2, _dec3$1, _class$4;
var AbilityManager = (_dec$4 = pluginHook({
  after: "abilityAdded",
  before: "beforeAbilityAdded"
}), _dec2$2 = pluginHook({
  before: "beforeAbilityUpdated",
  after: "abilityUpdated"
}), _dec3$1 = pluginHook({
  after: "abilityDeleted",
  before: "beforeAbilityDeleted"
}), (_class$4 = /*#__PURE__*/function () {
  function AbilityManager(oasis) {
    this.oasis = oasis;
    this.abilityMap = {};
  }

  var _proto = AbilityManager.prototype;

  _proto.add = function add(abilityConfig) {
    var type = abilityConfig.type,
        nodeId = abilityConfig.node,
        props = abilityConfig.props,
        id = abilityConfig.id,
        index = abilityConfig.index;
    var node = this.oasis.nodeManager.get(nodeId);
    var AbilityConstructor = this.getCompConstructor(type);

    if (!AbilityConstructor) {
      miniprogram.Logger.error(type + " abiltiy is not defined");
      return;
    }

    var abilityProps = this.mixPropsToExplicitProps(props);
    var ability = node.addComponent(AbilityConstructor);
    var enabled = abilityProps.enabled;

    if (enabled !== undefined) {
      ability.enabled = enabled;
    }

    if (type === "GLTFModel") {
      // TODO
      ability.init(abilityProps);
    } else if (type === "Model") {
      // TODO
      ability.setProps(abilityProps);

      if (abilityProps.material) {
        ability.material = abilityProps.material;
      }
    } else {
      for (var k in abilityProps) {
        if (abilityProps[k] !== null) {
          ability[k] = abilityProps[k];
        }
      }
    } //@ts-ignore


    var abilityArray = node._components;
    var currentIndex = abilityArray.length - 1;
    switchElementsIndex(abilityArray, currentIndex, index);
    ability.id = id;
    this.abilityMap[id] = ability;
    return ability;
  };

  _proto.update = function update(id, key, value) {
    if (value && this.checkIsAsset(value)) {
      this.get(id)[key] = this.oasis.resourceManager.get(value.id).resource;
    } else {
      if (this.get(id).constructor === Model) {
        this.get(id).updateProp(key, value);
      } else {
        this.get(id)[key] = value;
      }
    }

    return {
      id: id,
      key: key,
      value: value
    };
  };

  _proto.addRuntimeComponent = function addRuntimeComponent(componentId, component) {
    component.id = componentId;
    this.abilityMap[componentId] = component;
    return component;
  };

  _proto.get = function get(id) {
    return this.abilityMap[id];
  };

  _proto.delete = function _delete(id) {
    var ability = this.abilityMap[id];
    ability.destroy();
    delete this.abilityMap[id];
    return id;
  };

  _proto.getCompConstructor = function getCompConstructor(type) {
    var splits = type.split("."); // script

    if (splits[0] === "script") {
      return scriptAbility[splits[1]];
    }

    var constructor = Parser._components["o3"][type];

    if (!constructor) {
      console.warn(type + " is not defined");
    }

    return constructor;
  };

  _proto.mixPropsToExplicitProps = function mixPropsToExplicitProps(props) {
    var explicitProps = _objectSpread2({}, props);

    for (var k in props) {
      var prop = props[k];

      if (prop && this.checkIsAsset(prop)) {
        var res = this.oasis.resourceManager.get(prop.id);

        if (res) {
          explicitProps[k] = res.resource;
        } else {
          explicitProps[k] = null;
          miniprogram.Logger.warn("AbilityManager: can't get asset \"" + k + "\", which id is " + prop.id);
        }
      }
    }

    return explicitProps;
  };

  _proto.checkIsAsset = function checkIsAsset(prop) {
    return prop.type === "asset";
  };

  return AbilityManager;
}(), (_applyDecoratedDescriptor(_class$4.prototype, "add", [_dec$4], Object.getOwnPropertyDescriptor(_class$4.prototype, "add"), _class$4.prototype), _applyDecoratedDescriptor(_class$4.prototype, "update", [_dec2$2], Object.getOwnPropertyDescriptor(_class$4.prototype, "update"), _class$4.prototype), _applyDecoratedDescriptor(_class$4.prototype, "delete", [_dec3$1], Object.getOwnPropertyDescriptor(_class$4.prototype, "delete"), _class$4.prototype)), _class$4));

var _dec$3, _dec2$1, _dec3, _class$3;
var NodeManager = (_dec$3 = pluginHook({
  after: "nodeAdded"
}), _dec2$1 = pluginHook({
  before: "beforeNodeUpdated",
  after: "nodeUpdated"
}), _dec3 = pluginHook({
  before: "beforeNodeDeleted"
}), (_class$3 = /*#__PURE__*/function () {
  function NodeManager(oasis) {
    this.oasis = oasis;
    this.nodeMap = {};
    this.root = void 0;
    this.root = new miniprogram.Entity(this.oasis.engine, "root");
  }

  var _proto = NodeManager.prototype;

  _proto.addRootEntity = function addRootEntity() {
    this.oasis.engine.sceneManager.activeScene.addRootEntity(this.root);
  };

  _proto.add = function add(nodeConfig) {
    this.create(nodeConfig);
    this.append(nodeConfig.id, nodeConfig.parent, nodeConfig.index);
    return this.get(nodeConfig.id);
  };

  _proto.update = function update(id, key, value) {
    this.get(id)[key] = value;
    return {
      id: id,
      key: key,
      value: value
    };
  };

  _proto.get = function get(id) {
    return this.nodeMap[id];
  };

  _proto.reset = function reset() {
    this.nodeMap = {};
  };

  _proto.delete = function _delete(id) {
    this.nodeMap[id].destroy();
    delete this.nodeMap[id];
  };

  _proto.create = function create(nodeConfig) {
    var isActive = nodeConfig.isActive,
        position = nodeConfig.position,
        rotation = nodeConfig.rotation,
        scale = nodeConfig.scale,
        id = nodeConfig.id,
        name = nodeConfig.name;
    var entity = new miniprogram.Entity(this.oasis.engine, name);
    entity.isActive = isActive;
    entity.transform.position = new miniprogram$1.Vector3(position[0], position[1], position[2]);
    entity.transform.rotation = new miniprogram$1.Vector3(rotation[0], rotation[1], rotation[2]);
    entity.transform.scale = new miniprogram$1.Vector3(scale[0], scale[1], scale[2]);
    entity.id = id;
    this.nodeMap[id] = entity;
    return entity;
  };

  _proto.append = function append(childId, parentId, index) {
    var child = this.nodeMap[childId];
    var parent = this.nodeMap[parentId] || this.root;
    parent.addChild(child); //@ts-ignore

    var children = parent._children;
    var currentIndex = children.length - 1;
    switchElementsIndex(children, currentIndex, index);
  };

  return NodeManager;
}(), (_applyDecoratedDescriptor(_class$3.prototype, "add", [_dec$3], Object.getOwnPropertyDescriptor(_class$3.prototype, "add"), _class$3.prototype), _applyDecoratedDescriptor(_class$3.prototype, "update", [_dec2$1], Object.getOwnPropertyDescriptor(_class$3.prototype, "update"), _class$3.prototype), _applyDecoratedDescriptor(_class$3.prototype, "delete", [_dec3], Object.getOwnPropertyDescriptor(_class$3.prototype, "delete"), _class$3.prototype)), _class$3));

var _dec$2, _class$2;
var SceneManager = (_dec$2 = pluginHook({
  before: "beforeSceneUpdated",
  after: "sceneUpdated"
}), (_class$2 = /*#__PURE__*/function () {
  function SceneManager(oasis) {
    this.oasis = oasis;
  }

  var _proto = SceneManager.prototype;

  _proto.init = function init() {
    var _this = this;

    var scene = this.oasis.options.config.scene;

    if (scene) {
      Object.keys(scene).forEach(function (field) {
        var fieldConfig = scene[field];
        Object.keys(fieldConfig.props).forEach(function (key) {
          var prop = fieldConfig.props[key];

          _this.setProp(field, key, prop);
        });
      });
    }
  };

  _proto.update = function update(field, key, value) {
    this.setProp(field, key, value);
    return {
      field: field,
      key: key,
      value: value
    };
  };

  _proto.setProp = function setProp(field, key, prop) {
    var scene = this.oasis.engine.sceneManager.activeScene;

    if (field === "background" && key === "skyboxTexture") {
      var sky = scene.background.sky;

      if (prop) {
        sky.mesh = miniprogram.PrimitiveMesh.createCuboid(scene.engine, 2, 2, 2);
        var skyMaterial = new miniprogram.SkyBoxMaterial(scene.engine);
        skyMaterial.textureCubeMap = this.oasis.resourceManager.get(prop.id).resource;
        sky.material = skyMaterial;
      } else {
        sky.mesh = null;
        sky.material = null;
      }
    } else if (scene[field]) {
      if (prop && prop.type === "asset") {
        scene[field][key] = this.oasis.resourceManager.get(prop.id).resource;
      } else {
        scene[field][key] = prop;
      }
    }
  };

  return SceneManager;
}(), (_applyDecoratedDescriptor(_class$2.prototype, "update", [_dec$2], Object.getOwnPropertyDescriptor(_class$2.prototype, "update"), _class$2.prototype)), _class$2));

var SpriteAtlasResource = /*#__PURE__*/function (_SchemaResource) {
  _inheritsLoose(SpriteAtlasResource, _SchemaResource);

  function SpriteAtlasResource() {
    return _SchemaResource.apply(this, arguments) || this;
  }

  var _proto = SpriteAtlasResource.prototype;

  _proto.load = function load(resourceManager, assetConfig) {
    var _this = this;

    return new Promise(function (resolve) {
      _this.setMeta();

      if (assetConfig.source) {
        resourceManager.load({
          url: assetConfig.source,
          type: miniprogram.AssetType.SpriteAtlas
        }).then(function (spriteAtlas) {
          _this._resource = spriteAtlas;
          var sprites = spriteAtlas.sprites;
          var schemaResourceManager = _this.resourceManager;

          for (var index = sprites.length - 1; index >= 0; index--) {
            var sprite = sprites[index];
            var spriteResource = new SpriteResource(schemaResourceManager, sprite); // @ts-ignore

            var assetID = sprite._assetID; // @ts-ignore

            schemaResourceManager.maxId = Math.max(assetID, schemaResourceManager.maxId); // @ts-ignore

            schemaResourceManager.resourceMap[assetID] = spriteResource; // @ts-ignore

            schemaResourceManager.resourceIdMap.set(spriteResource, "" + assetID);
          }

          resolve(_this);
        });
      } else {
        if (!SpriteAtlasResource.defaultAtlas) {
          SpriteAtlasResource.defaultAtlas = new miniprogram.SpriteAtlas(resourceManager.engine);
        }

        _this._resource = SpriteAtlasResource.defaultAtlas;
        resolve(_this);
      }
    });
  };

  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };

  _proto.getProps = function getProps() {
    var _this2 = this;

    var result = {};
    var props = getAllGetters(this.resource);
    props.forEach(function (prop) {
      return result[prop] = _this2.resource[prop];
    });
    return result;
  };

  _proto.update = function update() {};

  return SpriteAtlasResource;
}(SchemaResource);
SpriteAtlasResource.defaultAtlas = void 0;

var _dec$1, _dec2, _class$1;
var RESOURCE_CLASS = {
  script: ScriptResource,
  gltf: GLTFResource,
  texture: TextureResource,
  // 'image': TextureResource,
  cubeTexture: TextureCubeMapResource,
  PBRMaterial: PBRMaterialResource,
  PBRSpecularMaterial: PBRSpecularMaterialResource,
  UnlitMaterial: UnlitMaterialResource,
  BlinnPhongMaterial: BlinnPhongMaterialResource,
  base: BaseResource,
  sprite: SpriteResource,
  SpriteAtlas: SpriteAtlasResource,
  animatorController: AnimatorControllerResource,
  animationClip: AnimationClipResource
};
var RESOURCE_TYPE = new Map();

for (var key in RESOURCE_CLASS) {
  if (RESOURCE_CLASS.hasOwnProperty(key)) {
    var element = RESOURCE_CLASS[key];
    RESOURCE_TYPE.set(element, key);
  }
}

var resourceFactory = {
  createResource: function createResource(resourceManager, type) {
    return new RESOURCE_CLASS[type](resourceManager);
  }
};
function registerResource(type, resource) {
  if (!RESOURCE_CLASS.hasOwnProperty(type)) {
    RESOURCE_CLASS[type] = resource;
    RESOURCE_TYPE.set(resource, type);
  }
}
var SchemaResourceManager = (_dec$1 = pluginHook({
  before: "beforeResourceRemove"
}), _dec2 = pluginHook({
  after: "resourceUpdated",
  before: "beforeResourceUpdate"
}), (_class$1 = /*#__PURE__*/function () {
  function SchemaResourceManager(oasis) {
    this.oasis = oasis;
    this.resourceMap = {};
    this.resourceIdMap = new WeakMap();
    this.maxId = 0;
    this.engineResourceManager = void 0;
    this.engineResourceManager = this.oasis.engine.resourceManager;
  }

  var _proto = SchemaResourceManager.prototype;

  _proto.load = function load(asset) {
    var _this = this;

    var resource = resourceFactory.createResource(this, asset.type);
    var loadPromise = resource.load(this.oasis.engine.resourceManager, asset, this.oasis);
    this.maxId = Math.max(+asset.id, this.maxId);
    loadPromise.then(function () {
      _this.resourceMap[asset.id] = resource;

      _this.resourceIdMap.set(resource, asset.id);
    });
    return loadPromise;
  };

  _proto.add = function add(asset) {
    var _this2 = this;

    var resource = resourceFactory.createResource(this, asset.type);
    return new Promise(function (resolve) {
      resource.loadWithAttachedResources(_this2.oasis.engine.resourceManager, asset, _this2.oasis).then(function (result) {
        resolve(_this2.getAddResourceResult(result.resources, result.structure));
      });
    });
  };

  _proto.remove = function remove(id) {
    var _this3 = this;

    return new Promise(function (resolve) {
      var resource = _this3.resourceMap[id];
      var result = [id];
      var hasAttachedResource = false;
      delete _this3.resourceMap[id];

      if (resource) {
        var attached = resource.attachedResources;

        for (var index = 0; index < attached.length; index++) {
          var attachedResource = attached[index];

          var attachedResourceId = _this3.resourceIdMap.get(attachedResource);

          if (attachedResourceId) {
            hasAttachedResource = true;

            _this3.remove(attachedResourceId).then(function (attachedResourceRemoveResult) {
              result.push.apply(result, attachedResourceRemoveResult);
              resolve(result);
            });
          }
        }
      }

      if (!hasAttachedResource) {
        resolve(result);
      }
    });
  };

  _proto.update = function update(id, key, value) {
    var resource = this.get(id);

    if (resource) {
      resource.update(key, value);
    }

    return {
      resource: resource,
      id: id,
      key: key,
      value: value
    };
  };

  _proto.updateMeta = function updateMeta(id, key, value) {
    var resource = this.get(id);

    if (resource) {
      resource.updateMeta(key, value);
    }
  };

  _proto.get = function get(id) {
    return this.resourceMap[id];
  };

  _proto.getAll = function getAll() {
    return miniprogram.ObjectValues(this.resourceMap);
  };

  _proto.getAddResourceResult = function getAddResourceResult(resources, structure) {
    var _this4 = this;

    var addResourceResult = {};
    var resource = resources[structure.index];
    var id = "" + ++this.maxId;
    this.resourceMap[id] = resource;
    this.resourceIdMap.set(resource, id);
    addResourceResult.id = this.maxId;
    addResourceResult.type = RESOURCE_TYPE.get(resource.constructor);
    addResourceResult.meta = resource.meta;
    addResourceResult.props = {};

    for (var _key in structure.props) {
      if (structure.props.hasOwnProperty(_key)) {
        var _element = structure.props[_key];

        if (_element) {
          if (Array.isArray(_element)) {
            addResourceResult.props[_key] = _element.map(function (child) {
              return _this4.getAddResourceResult(resources, child);
            });
          } else {
            addResourceResult.props[_key] = this.getAddResourceResult(resources, _element);
          }
        }
      }
    }

    return addResourceResult;
  };

  _createClass(SchemaResourceManager, [{
    key: "isLocal",
    get: function get() {
      return this.oasis.options.local;
    }
  }, {
    key: "useCompressedTexture",
    get: function get() {
      var _this$oasis$options$u;

      return (_this$oasis$options$u = this.oasis.options.useCompressedTexture) != null ? _this$oasis$options$u : true;
    }
  }]);

  return SchemaResourceManager;
}(), (_applyDecoratedDescriptor(_class$1.prototype, "remove", [_dec$1], Object.getOwnPropertyDescriptor(_class$1.prototype, "remove"), _class$1.prototype), _applyDecoratedDescriptor(_class$1.prototype, "update", [_dec2], Object.getOwnPropertyDescriptor(_class$1.prototype, "update"), _class$1.prototype)), _class$1));

var _dec, _class;
var Oasis = (_dec = pluginHook({
  after: "schemaParsed"
}), (_class = /*#__PURE__*/function (_EventDispatcher) {
  _inheritsLoose(Oasis, _EventDispatcher);

  function Oasis(_options, pluginManager) {
    var _options$scripts;

    var _this;

    _this = _EventDispatcher.call(this, _options.engine) || this;
    _this._options = _options;
    _this.pluginManager = pluginManager;
    _this.nodeManager = void 0;
    _this.abilityManager = void 0;
    _this.sceneManager = void 0;
    _this.resourceManager = void 0;
    _this._canvas = void 0;
    _this.schema = void 0;
    _this.timeout = void 0;
    _this.oasis = _assertThisInitialized(_this);
    _this.schema = _options.config;
    _this.timeout = _options.timeout;
    _options.scripts = (_options$scripts = _options.scripts) != null ? _options$scripts : {};
    _this.nodeManager = new NodeManager(_assertThisInitialized(_this));
    _this.abilityManager = new AbilityManager(_assertThisInitialized(_this));
    _this.nodeManager.add = _this.nodeManager.add.bind(_this.nodeManager);
    _this.abilityManager.add = _this.abilityManager.add.bind(_this.abilityManager);
    _this.resourceManager = new SchemaResourceManager(_assertThisInitialized(_this));
    _this.sceneManager = new SceneManager(_assertThisInitialized(_this));

    if (_options.fps) {
      _this.engine.targetFrameRate = _options.fps;
      _this.engine.vSyncCount = 0;
    }

    return _this;
  }

  var _proto = Oasis.prototype;

  _proto.updateConfig = function updateConfig(config) {
    this.schema = config;
    this.init();
  };

  _proto.init = function init() {
    var _this2 = this;

    return this.loadResources().then(function () {
      _this2.bindResources();

      _this2.parseEntities();

      _this2.attach();

      _this2.nodeManager.addRootEntity();

      _this2.sceneManager.init();

      _this2.parseNodeAbilities();

      _this2.pluginManager.boot(_this2);
    });
  };

  _proto.loadResources = function loadResources() {
    var _this3 = this;

    var _this$schema$assets = this.schema.assets,
        assets = _this$schema$assets === void 0 ? {} : _this$schema$assets;
    var loadingPromises = miniprogram.ObjectValues(assets).filter(function (asset) {
      if (RESOURCE_CLASS[asset.type]) {
        return true;
      }

      console.warn(asset.type + " loader is not defined. the " + asset.type + " type will be ignored.");
      return false;
    }).map(function (asset) {
      return _this3.resourceManager.load(asset);
    });
    return Promise.all(loadingPromises);
  };

  _proto.bindResources = function bindResources() {
    this.resourceManager.getAll().forEach(function (resource) {
      resource.bind();
    });
  };

  _proto.parseEntities = function parseEntities() {
    var nodes = this.schema.nodes;
    var indices = this.bfsNodes();
    indices.map(function (index) {
      return nodes[index];
    }).forEach(this.nodeManager.add);
  };

  _proto.parseNodeAbilities = function parseNodeAbilities() {
    var abilities = this.schema.abilities;
    Object.keys(abilities).map(function (id) {
      return _objectSpread2({
        id: id
      }, abilities[id]);
    }).forEach(this.abilityManager.add);
  };

  _proto.bfsNodes = function bfsNodes() {
    var nodes = this.schema.nodes;
    var roots = miniprogram.ObjectValues(nodes).filter(function (node) {
      return !nodes[node.parent];
    }).map(function (node) {
      return node.id;
    });
    var result = [];

    var traverseChildren = function traverseChildren(roots) {
      result = result.concat(roots);
      roots.forEach(function (id) {
        var children = nodes[id].children;
        children && traverseChildren(children);
      });
    };

    traverseChildren(roots);
    return result;
  };

  _proto.attach = function attach() {
    this.resourceManager.getAll().forEach(function (resource) {
      resource.attach();
    });
  };

  Oasis.create = function create(options, pluginManager) {
    var oasis = new Oasis(options, pluginManager);
    return oasis.init().then(function () {
      options.autoPlay && oasis.engine.run();
      return oasis;
    });
  };

  _createClass(Oasis, [{
    key: "canvas",
    get: function get() {
      return this._options.canvas;
    }
  }, {
    key: "options",
    get: function get() {
      return this._options;
    }
  }]);

  return Oasis;
}(miniprogram.EventDispatcher), (_applyDecoratedDescriptor(_class.prototype, "init", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "init"), _class.prototype)), _class));

exports.GLTFModel = GLTFModel;
exports.GLTFResource = GLTFResource$1;
exports.Model = Model;
exports.Oasis = Oasis;
exports.Parser = Parser;
exports.SchemaResource = SchemaResource;
exports.parseSingleKTX = parseSingleKTX;
exports.parser = parser;
exports.registerResource = registerResource;
exports.script = script;
