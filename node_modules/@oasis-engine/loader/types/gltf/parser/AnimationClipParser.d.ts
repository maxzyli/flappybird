import { Entity, EngineObject, Component, AnimationCurve, InterpolationType } from "@oasis-engine/core";
import { Quaternion } from "@oasis-engine/math";
interface AnimationClipCurveData<T extends Component> {
    curve: AnimationCurve;
    relativePath: string;
    type: new (entity: Entity) => T;
    propertyName: string;
}
interface IChannel {
    sampler: ISample;
    target: ITarget;
}
interface ISample {
    input: List;
    output: List;
    outputSize: number;
    interpolation: InterpolationType;
}
interface ITarget {
    relativePath: string;
    propertyName: string;
}
export declare type List = number[] | Float32Array;
export declare type Value = number | List | Quaternion;
export declare enum TagetType {
    position = 0,
    rotation = 1,
    scale = 2,
    other = 3
}
/**
 * Data for an animation, set of Samples and Channels.
 */
export declare class AnimationClipParser extends EngineObject {
    private static _tagetTypeMap;
    duration: number;
    durationIndex: number;
    samplers: ISample[];
    channels: IChannel[];
    /**
     * @param name - The AnimationClip's name.
     */
    constructor();
    /**
     * Add sampler to samplers of the AnimationClip.
     * @param _input - The index of an accessor containing keyframe input values.
     * @param _output - The index of an accessor containing keyframe output values.
     * @param _outputSize - The length of the output values.
     * @param _interpolation - Interpolation algorithm.
     */
    addSampler(_input: List, _output: List, _outputSize: number, _interpolation?: InterpolationType): void;
    /**
     * Add channel to channels of the AnimationClip.
     * @param samplerIndex - The sampler's index in channel's sampler property.
     * @param relativePath - The Entity's relativePath.
     * @param propertyName - Transform property name: position, rotation, scale.
     */
    addChannel(samplerIndex: number, relativePath: string, propertyName: string): void;
    /**
     * Get length of the channel.
     * @return {number} Number of channels.
     */
    getChannelCount(): number;
    /**
     * Get the object which the channel acting on.
     * @return Channel objects.
     * @param channelIndex - The channel's index in AnimationClip's channels property.
     */
    getChannelObject(channelIndex: number): IChannel;
    /**
     * Get frame count of the channel.
     * @return Channel frame count.
     * @param channelIndex - The channel's index in AnimationClip's channels property.
     */
    getFrameCount(channelIndex: number): number;
    /**
     * Get frame time of the channel by channelIndex and frameIndex.
     * @return channel frame time
     * @param channelIndex - The channel's index in AnimationClip's channels property.
     * @param frameIndex - The keyframe's index in sampler.input.
     */
    getFrameTime(channelIndex: number, frameIndex: number): number;
    /**
     * Get length of the channel.
     * @return channel time length
     * @param channelIndex - The channel's index in AnimationClip's channels property.
     */
    getChannelTimeLength(channelIndex: number): number;
    /**
     * Get the channel value.
     * @return channel value
     * @param channelIndex - The channel's index in AnimationClip's channels property.
     */
    createChannelValue(channelIndex: number): number | Float32Array | number[];
    /**
     * @param outValue - The output value after interpolation.
     * @param channelIndex - The channel's index in AnimationClip's channels property.
     * @param frameIndex - The keyframe's index in sampler.input.
     * @param nextFrameIndex - The next keyframe's index in sampler.input.
     * @param alpha - The weight of the next keyframe in interpolation algorithm.
     */
    evaluate(outValue: Value, channelIndex: number, frameIndex: number, nextFrameIndex: number, alpha: number): Value;
    evaluateCubicSpline(outValue: Value, output: List, outputSize: number, frameIndex: number, nextFrameIndex: number, alpha: number): void;
    evaluateLinear(outValue: Value, output: List, outputSize: number, frameIndex: number, nextFrameIndex: number, alpha: number): void;
    getCurveDatas(): AnimationClipCurveData<Component>[];
    private _quaSlerp;
}
export {};
