(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('oasis-engine')) :
  typeof define === 'function' && define.amd ? define(['exports', 'oasis-engine'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['@oasis-engine/touch'] = {}, global.oasisEngine));
}(this, (function (exports, oasisEngine) { 'use strict';

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  var TouchManager = /*#__PURE__*/function () {
    function TouchManager() {
      var _this = this;

      this.CanvasEvent = {
        touchend: "touchend",
        touchstart: "touchstart",
        mouseup: "mouseup",
        mousedown: "mousedown",
        click: "click"
      };
      this.nowListenHash = void 0;
      this.webCanvas = void 0;
      this.tempVPVec = void 0;
      this.tempCameraVPVec = void 0;
      this.tempRay = void 0;
      this.tempHit = void 0;
      this.listenerState = 0;
      this.engine = void 0;

      this.touchToVPPos = function (touchEvt, pos) {
        var _touchEvt$changedTouc = touchEvt.changedTouches,
            changedTouches = _touchEvt$changedTouc === void 0 ? [] : _touchEvt$changedTouc,
            target = touchEvt.target;

        if (changedTouches.length > 0) {
          // @ts-ignore
          var _ref = target && target.getBoundingClientRect(),
              _ref$left = _ref.left,
              left = _ref$left === void 0 ? 0 : _ref$left,
              _ref$top = _ref.top,
              top = _ref$top === void 0 ? 0 : _ref$top;

          var touchPos = changedTouches[0];
          var webCanvas = _this.webCanvas;
          pos.setValue((touchPos.clientX - left) / webCanvas.clientWidth, (touchPos.clientY - top) / webCanvas.clientHeight);
          return true;
        } else {
          return false;
        }
      };

      this.mouseToVPPos = function (mouseEvt, pos) {
        var pageX = mouseEvt.pageX,
            pageY = mouseEvt.pageY,
            target = mouseEvt.target;

        if (target) {
          // @ts-ignore
          var _target$offsetLeft = target.offsetLeft,
              offsetLeft = _target$offsetLeft === void 0 ? 0 : _target$offsetLeft,
              _target$offsetTop = target.offsetTop,
              offsetTop = _target$offsetTop === void 0 ? 0 : _target$offsetTop;
          var webCanvas = _this.webCanvas;
          pos.setValue((pageX - offsetLeft) / webCanvas.clientWidth, (pageY - offsetTop) / webCanvas.clientHeight);
          return true;
        } else {
          return false;
        }
      };

      this.pointToRay = function (camera, pos) {
        var tempVPVec = _this.tempVPVec,
            tempRay = _this.tempRay;
        var viewport = camera.viewport;
        pos.setValue((tempVPVec.x - viewport.x) / viewport.z, (tempVPVec.y - viewport.y) / viewport.w);

        if (pos.x >= 0 && pos.x <= 1 && pos.y >= 0 && pos.y <= 1) {
          camera.viewportPointToRay(pos, tempRay);
          return true;
        } else {
          return false;
        }
      };

      this.checkHit = function (touchType, evt) {
        if (!_this.engine) {
          console.warn("Please call the TouchManager.init method to initialize before use");
        } // 根据触摸点获取真实的 clientpos


        var scene = _this.engine.sceneManager.activeScene; // @ts-ignore

        var actCameras = scene._activeCameras; // 对活动的相机的优先级进行一个排序，

        actCameras.sort(function (camera1, camera2) {
          return camera1.priority - camera2.priority;
        });
        var tempCameraVPVec = _this.tempCameraVPVec,
            tempRay = _this.tempRay; // 遍历活动着的相机，先检查后渲染的

        for (var index = actCameras.length - 1; index >= 0; index--) {
          var tempCamera = actCameras[index]; // 这个相机是活动着的 并且点击区域在这个相机的 viewPort 中

          if (tempCamera.enabled && _this.pointToRay(tempCamera, tempCameraVPVec)) {
            // 当前 touch 事件对应的 entity
            var colliderList = _this.nowListenHash[touchType]; // 只检查监听了这个事件的碰撞体

            var collider = _this.hitCollider(tempRay, colliderList);

            if (collider) {
              // @ts-ignore
              var cbListHash = collider.touchCBListHash;
              var cbList = cbListHash ? cbListHash[touchType] : null;
              var cbLen = cbList ? cbList.length : 0;

              if (cbLen > 0) {
                for (var i = 0; i < cbLen; i++) {
                  cbList[i](evt);
                }
              }
            }

            break;
          }
        }
      };

      this.updateListener = function (optType, touchType) {
        var preState = (_this.listenerState & touchType) !== 0;

        if (preState && optType == OptType.Add) {
          //已经监听，此时再增加则无需改变
          return;
        }

        if (!preState && optType == OptType.Del) {
          //没有监听，此时再移除也无需改变
          return;
        }

        var CanvasEvent = _this.CanvasEvent,
            webCanvas = _this.webCanvas;

        switch (optType) {
          case OptType.Add:
            switch (touchType) {
              case exports.TouchType.MouseDown:
                webCanvas.addEventListener(CanvasEvent.mousedown, _this.onMouseDown);
                webCanvas.addEventListener(CanvasEvent.touchstart, _this.onTouchStart);
                break;

              case exports.TouchType.MouseUp:
                webCanvas.addEventListener(CanvasEvent.mouseup, _this.onMouseUp);
                webCanvas.addEventListener(CanvasEvent.touchend, _this.onTouchEnd);
                break;
            }

            _this.listenerState |= touchType;
            break;

          case OptType.Del:
            // 判断是否需要监听
            if (_this.checkNeedListen(touchType) != preState) {
              switch (touchType) {
                case exports.TouchType.MouseDown:
                  webCanvas.removeEventListener(CanvasEvent.mousedown, _this.onMouseDown);
                  webCanvas.removeEventListener(CanvasEvent.touchstart, _this.onTouchStart);
                  break;

                case exports.TouchType.MouseUp:
                  webCanvas.removeEventListener(CanvasEvent.mouseup, _this.onMouseUp);
                  webCanvas.removeEventListener(CanvasEvent.touchend, _this.onTouchEnd);
                  break;
              }

              _this.listenerState &= ~touchType;
            }

            break;
        }
      };

      this.checkNeedListen = function (touchType) {
        var colliderList = _this.nowListenHash[touchType];
        return colliderList && colliderList.length > 0;
      };

      this.onMouseDown = function (mouseEvt) {
        if (mouseEvt && _this.mouseToVPPos(mouseEvt, _this.tempVPVec)) {
          _this.checkHit(exports.TouchType.MouseDown, mouseEvt);
        }
      };

      this.onTouchStart = function (touchEvt) {
        if (touchEvt && _this.touchToVPPos(touchEvt, _this.tempVPVec)) {
          _this.checkHit(exports.TouchType.MouseDown, touchEvt);
        }
      };

      this.onMouseUp = function (mouseEvt) {
        if (mouseEvt && _this.mouseToVPPos(mouseEvt, _this.tempVPVec)) {
          _this.checkHit(exports.TouchType.MouseUp, mouseEvt);
        }
      };

      this.onTouchEnd = function (touchEvt) {
        if (touchEvt && _this.touchToVPPos(touchEvt, _this.tempVPVec)) {
          _this.checkHit(exports.TouchType.MouseUp, touchEvt);
        }
      };

      this.nowListenHash = {};
      this.tempVPVec = new oasisEngine.Vector2();
      this.tempCameraVPVec = new oasisEngine.Vector2();
      this.tempRay = new oasisEngine.Ray();
      this.tempHit = new oasisEngine.HitResult();
    }

    var _proto = TouchManager.prototype;

    _proto.initEngine = function initEngine(engine) {
      // 当前的 engine
      if (this.engine != engine) {
        this.engine = engine; // @ts-ignore

        this.webCanvas = this.engine.canvas._webCanvas;
      }
    };

    _proto.addTouch = function addTouch(type, collider) {
      var nowListenHash = this.nowListenHash;

      if (nowListenHash[type]) {
        var index = nowListenHash[type].indexOf(collider);

        if (index < 0) {
          nowListenHash[type].push(collider);
        }
      } else {
        nowListenHash[type] = [collider];
      }

      this.updateListener(OptType.Add, type);
    };

    _proto.removeTouch = function removeTouch(type, collider) {
      var colliderList = this.nowListenHash[type];

      if (colliderList) {
        var index = colliderList.indexOf(collider);

        if (index >= 0) {
          colliderList.splice(index, 1);
        }
      }

      this.updateListener(OptType.Del, type);
    } // 触摸时将屏幕上点转换为 viewport 上的点
    ;

    _proto.hitCollider = function hitCollider(ray, colliders) {
      var nearestHit = new oasisEngine.HitResult();
      nearestHit.distance = Number.MAX_VALUE;
      var hit = this.tempHit;

      for (var i = 0, len = colliders.length; i < len; i++) {
        var collider = colliders[i];

        if (!collider.entity.isActiveInHierarchy) {
          continue;
        } // @ts-ignore


        if (collider._raycast(ray, hit)) {
          if (hit.distance < nearestHit.distance) {
            nearestHit = hit;
          }
        }
      }

      return nearestHit.collider;
    } // 只更新有差异的 canvas 监听
    ;

    _createClass(TouchManager, null, [{
      key: "ins",
      get: function get() {
        if (!this._ins) {
          this._ins = new TouchManager();
        }

        return this._ins;
      }
    }]);

    return TouchManager;
  }();
  TouchManager._ins = void 0;
  var OptType;

  (function (OptType) {
    OptType[OptType["Add"] = 0] = "Add";
    OptType[OptType["Del"] = 1] = "Del";
  })(OptType || (OptType = {}));

  exports.TouchType = void 0;

  (function (TouchType) {
    TouchType[TouchType["MouseDown"] = 1] = "MouseDown";
    TouchType[TouchType["MouseUp"] = 2] = "MouseUp";
    TouchType[TouchType["Click"] = 4] = "Click";
  })(exports.TouchType || (exports.TouchType = {}));

  var Touch = /*#__PURE__*/function (_Component) {
    _inheritsLoose(Touch, _Component);

    function Touch(entity) {
      var _this;

      _this = _Component.call(this, entity) || this;
      _this.collider = void 0;
      _this.collider = _this.entity.getComponent(oasisEngine.ACollider);

      if (_this.collider) {
        // @ts-ignore
        _this.collider.touchCBListHash = {};
      } else {
        console.warn("Please set the collider first");
      }

      return _this;
    } // Add listener


    var _proto = Touch.prototype;

    _proto.on = function on(type, cbFun) {
      // @ts-ignore
      var touchCBListHash = this.collider.touchCBListHash;

      if (!touchCBListHash[type]) {
        touchCBListHash[type] = [];
      }

      var cbList = touchCBListHash[type];

      if (cbList.indexOf(cbFun) < 0) {
        cbList.push(cbFun);
        TouchManager.ins.addTouch(type, this.collider);
      }
    } // Remove listener
    ;

    _proto.off = function off(type, cbFun) {
      // @ts-ignore
      var cbList = this.collider.touchCBListHash[type];

      if (cbFun) {
        var index = cbList ? cbList.indexOf(cbFun) : -1;

        if (index >= 0) {
          cbList.splice(index, 1);
          TouchManager.ins.removeTouch(type, this.collider);
        }
      } else {
        cbList && (cbList.length = 0);
      }
    };

    return Touch;
  }(oasisEngine.Component);

  exports.Touch = Touch;
  exports.TouchManager = TouchManager;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
