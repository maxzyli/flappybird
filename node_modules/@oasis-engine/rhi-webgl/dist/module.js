import { Vector2, Vector4, Color } from '@oasis-engine/math';
import { GLCapabilityType, Logger, TextureWrapMode, TextureFilterMode, TextureFormat, RenderBufferColorFormat, RenderBufferDepthFormat, RenderDepthTexture, CameraClearFlags, ColorWriteMask, Engine } from '@oasis-engine/core';

/**
 * Smoothing plug-in.
 * */

/**
 * @deprecated
 */
var GLCompressedTextureInternalFormat;

(function (GLCompressedTextureInternalFormat) {
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_4X4_KHR"] = 37808] = "RGBA_ASTC_4X4_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_5X4_KHR"] = 37809] = "RGBA_ASTC_5X4_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_5X5_KHR"] = 37810] = "RGBA_ASTC_5X5_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_6X5_KHR"] = 37811] = "RGBA_ASTC_6X5_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_6X6_KHR"] = 37812] = "RGBA_ASTC_6X6_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X5_KHR"] = 37813] = "RGBA_ASTC_8X5_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X6_KHR"] = 37814] = "RGBA_ASTC_8X6_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X8_KHR"] = 37815] = "RGBA_ASTC_8X8_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X5_KHR"] = 37816] = "RGBA_ASTC_10X5_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X6_KHR"] = 37817] = "RGBA_ASTC_10X6_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X8_KHR"] = 37818] = "RGBA_ASTC_10X8_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X10_KHR"] = 37819] = "RGBA_ASTC_10X10_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_12X10_KHR"] = 37820] = "RGBA_ASTC_12X10_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_12X12_KHR"] = 37821] = "RGBA_ASTC_12X12_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_4X4_KHR"] = 37840] = "SRGB8_ALPHA8_ASTC_4X4_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_5X4_KHR"] = 37841] = "SRGB8_ALPHA8_ASTC_5X4_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_5X5_KHR"] = 37842] = "SRGB8_ALPHA8_ASTC_5X5_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_6X5_KHR"] = 37843] = "SRGB8_ALPHA8_ASTC_6X5_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_6X6_KHR"] = 37844] = "SRGB8_ALPHA8_ASTC_6X6_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X5_KHR"] = 37845] = "SRGB8_ALPHA8_ASTC_8X5_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X6_KHR"] = 37846] = "SRGB8_ALPHA8_ASTC_8X6_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X8_KHR"] = 37847] = "SRGB8_ALPHA8_ASTC_8X8_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X5_KHR"] = 37848] = "SRGB8_ALPHA8_ASTC_10X5_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X6_KHR"] = 37849] = "SRGB8_ALPHA8_ASTC_10X6_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X8_KHR"] = 37850] = "SRGB8_ALPHA8_ASTC_10X8_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X10_KHR"] = 37851] = "SRGB8_ALPHA8_ASTC_10X10_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_12X10_KHR"] = 37852] = "SRGB8_ALPHA8_ASTC_12X10_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_12X12_KHR"] = 37853] = "SRGB8_ALPHA8_ASTC_12X12_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_ETC1_WEBGL"] = 36196] = "RGB_ETC1_WEBGL";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["R11_EAC"] = 37488] = "R11_EAC";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SIGNED_R11_EAC"] = 37489] = "SIGNED_R11_EAC";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RG11_EAC"] = 37490] = "RG11_EAC";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SIGNED_RG11_EAC"] = 37491] = "SIGNED_RG11_EAC";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB8_ETC2"] = 37492] = "RGB8_ETC2";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ETC2"] = 37493] = "SRGB8_ETC2";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA8_ETC2_EAC"] = 37496] = "RGBA8_ETC2_EAC";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "SRGB8_ALPHA8_ETC2_EAC";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_PVRTC_4BPPV1_IMG"] = 35840] = "RGB_PVRTC_4BPPV1_IMG";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_PVRTC_2BPPV1_IMG"] = 35841] = "RGB_PVRTC_2BPPV1_IMG";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "RGBA_PVRTC_4BPPV1_IMG";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "RGBA_PVRTC_2BPPV1_IMG";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_S3TC_DXT1_EXT"] = 33776] = "RGB_S3TC_DXT1_EXT";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT1_EXT"] = 33777] = "RGBA_S3TC_DXT1_EXT";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT3_EXT"] = 33778] = "RGBA_S3TC_DXT3_EXT";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT5_EXT"] = 33779] = "RGBA_S3TC_DXT5_EXT";
})(GLCompressedTextureInternalFormat || (GLCompressedTextureInternalFormat = {}));

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

/**
 * The canvas used on the web, which can support HTMLCanvasElement and OffscreenCanvas.
 */

var WebCanvas = /*#__PURE__*/function () {
  var _proto = WebCanvas.prototype;

  /**
   * Resize the rendering size according to the clientWidth and clientHeight of the canvas.
   * @param pixelRatio - Pixel ratio
   */
  _proto.resizeByClientSize = function resizeByClientSize(pixelRatio) {
    if (pixelRatio === void 0) {
      pixelRatio = window.devicePixelRatio;
    }

    var webCanvas = this._webCanvas;

    if (webCanvas instanceof HTMLCanvasElement) {
      var width = webCanvas.clientWidth;
      var height = webCanvas.clientHeight;
      this.width = width * pixelRatio;
      this.height = height * pixelRatio;
    }
  }
  /**
   * Create a web canvas.
   * @param webCanvas - Web native canvas
   */
  ;

  function WebCanvas(webCanvas) {
    this._webCanvas = void 0;
    this._width = void 0;
    this._height = void 0;
    this._scale = new Vector2();
    var width = webCanvas.width;
    var height = webCanvas.height;
    this._webCanvas = webCanvas;
    this._width = width;
    this._height = height;
  }
  /**
   * Set scale.
   * @param x - Scale along the X axis
   * @param y - Scale along the Y axis
   */


  _proto.setScale = function setScale(x, y) {
    this._scale.setValue(x, y);

    this.scale = this._scale;
  };

  _createClass(WebCanvas, [{
    key: "width",
    get:
    /**
     * @inheritdoc
     */
    function get() {
      return this._width;
    },
    set: function set(value) {
      if (this._width !== value) {
        this._webCanvas.width = value;
        this._width = value;
      }
    }
    /**
     * @inheritdoc
     */

  }, {
    key: "height",
    get: function get() {
      return this._height;
    },
    set: function set(value) {
      if (this._height !== value) {
        this._webCanvas.height = value;
        this._height = value;
      }
    }
    /**
     * The scale of canvas, the value is visible width/height divide the render width/height.
     * @remarks Need to re-assign after modification to ensure that the modification takes effect.
     */

  }, {
    key: "scale",
    get: function get() {
      var webCanvas = this._webCanvas;

      if (webCanvas instanceof HTMLCanvasElement) {
        this._scale.setValue(webCanvas.clientWidth * devicePixelRatio / webCanvas.width, webCanvas.clientHeight * devicePixelRatio / webCanvas.height);
      }

      return this._scale;
    },
    set: function set(value) {
      var webCanvas = this._webCanvas;

      if (webCanvas instanceof HTMLCanvasElement) {
        webCanvas.style.transformOrigin = "left top";
        webCanvas.style.transform = "scale(" + value.x + ", " + value.y + ")";
      }
    }
  }]);

  return WebCanvas;
}();

/**
 * GL capability.
 */
var GLCapability = /*#__PURE__*/function () {
  function GLCapability(rhi) {
    this._maxDrawBuffers = void 0;
    this._maxAnisoLevel = void 0;
    this._maxAntiAliasing = void 0;
    this._rhi = void 0;
    this.capabilityList = void 0;
    this._rhi = rhi;
    this.capabilityList = new Map();

    this._init();

    this._compatibleAllInterface();
  }
  /**
   * Check device capabilities.
   */


  var _proto = GLCapability.prototype;

  _proto.canIUse = function canIUse(capabilityType) {
    return this.capabilityList.get(capabilityType);
  }
  /**
   * Check if can use some compressed texture format.
   */
  ;

  _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(internalType) {
    var RGBA_ASTC_4X4_KHR = GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
        RGBA_ASTC_12X12_KHR = GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
        SRGB8_ALPHA8_ASTC_4X4_KHR = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_4X4_KHR,
        SRGB8_ALPHA8_ASTC_12X12_KHR = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_12X12_KHR,
        RGB_ETC1_WEBGL = GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
        R11_EAC = GLCompressedTextureInternalFormat.R11_EAC,
        SRGB8_ALPHA8_ETC2_EAC = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ETC2_EAC,
        RGB_PVRTC_4BPPV1_IMG = GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
        RGBA_PVRTC_2BPPV1_IMG = GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
        RGB_S3TC_DXT1_EXT = GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
        RGBA_S3TC_DXT5_EXT = GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT;

    if (internalType >= RGBA_ASTC_4X4_KHR && RGBA_ASTC_12X12_KHR <= RGBA_ASTC_12X12_KHR || internalType >= SRGB8_ALPHA8_ASTC_4X4_KHR && internalType <= SRGB8_ALPHA8_ASTC_12X12_KHR) {
      return this.canIUse(GLCapabilityType.astc);
    } else if (internalType === RGB_ETC1_WEBGL) {
      return this.canIUse(GLCapabilityType.etc1);
    } else if (internalType >= R11_EAC && internalType <= SRGB8_ALPHA8_ETC2_EAC) {
      return this.canIUse(GLCapabilityType.etc);
    } else if (internalType >= RGB_PVRTC_4BPPV1_IMG && internalType <= RGBA_PVRTC_2BPPV1_IMG) {
      return this.canIUse(GLCapabilityType.pvrtc);
    } else if (internalType >= RGB_S3TC_DXT1_EXT && internalType <= RGBA_S3TC_DXT5_EXT) {
      return this.canIUse(GLCapabilityType.s3tc);
    }

    return false;
  }
  /**
   *  Init capabilities.
   */
  ;

  _proto._init = function _init() {
    var cap = this.capabilityList;
    var isWebGL2 = this.rhi.isWebGL2;
    var requireExtension = this.rhi.requireExtension.bind(this.rhi);
    var shaderVertexID = GLCapabilityType.shaderVertexID,
        standardDerivatives = GLCapabilityType.standardDerivatives,
        shaderTextureLod = GLCapabilityType.shaderTextureLod,
        elementIndexUint = GLCapabilityType.elementIndexUint,
        depthTexture = GLCapabilityType.depthTexture,
        vertexArrayObject = GLCapabilityType.vertexArrayObject,
        instancedArrays = GLCapabilityType.instancedArrays,
        multipleSample = GLCapabilityType.multipleSample,
        drawBuffers = GLCapabilityType.drawBuffers,
        astc = GLCapabilityType.astc,
        astc_webkit = GLCapabilityType.astc_webkit,
        etc = GLCapabilityType.etc,
        etc_webkit = GLCapabilityType.etc_webkit,
        etc1 = GLCapabilityType.etc1,
        etc1_webkit = GLCapabilityType.etc1_webkit,
        pvrtc = GLCapabilityType.pvrtc,
        pvrtc_webkit = GLCapabilityType.pvrtc_webkit,
        s3tc = GLCapabilityType.s3tc,
        s3tc_webkit = GLCapabilityType.s3tc_webkit,
        textureFloat = GLCapabilityType.textureFloat,
        textureHalfFloat = GLCapabilityType.textureHalfFloat,
        textureFloatLinear = GLCapabilityType.textureFloatLinear,
        textureHalfFloatLinear = GLCapabilityType.textureHalfFloatLinear,
        WEBGL_colorBufferFloat = GLCapabilityType.WEBGL_colorBufferFloat,
        colorBufferFloat = GLCapabilityType.colorBufferFloat,
        colorBufferHalfFloat = GLCapabilityType.colorBufferHalfFloat,
        textureFilterAnisotropic = GLCapabilityType.textureFilterAnisotropic;
    cap.set(shaderVertexID, isWebGL2);
    cap.set(standardDerivatives, isWebGL2 || !!requireExtension(standardDerivatives));
    cap.set(shaderTextureLod, isWebGL2 || !!requireExtension(shaderTextureLod));
    cap.set(elementIndexUint, isWebGL2 || !!requireExtension(elementIndexUint));
    cap.set(depthTexture, isWebGL2 || !!requireExtension(depthTexture));
    cap.set(vertexArrayObject, isWebGL2 || !!requireExtension(vertexArrayObject));
    cap.set(instancedArrays, isWebGL2 || !!requireExtension(instancedArrays));
    cap.set(multipleSample, isWebGL2);
    cap.set(drawBuffers, isWebGL2 || !!requireExtension(drawBuffers));
    cap.set(textureFloat, isWebGL2 || !!requireExtension(textureFloat));
    cap.set(textureHalfFloat, isWebGL2 || !!requireExtension(textureHalfFloat));
    cap.set(textureFloatLinear, !!requireExtension(textureFloatLinear));
    cap.set(textureHalfFloatLinear, isWebGL2 || !!requireExtension(textureHalfFloatLinear));
    cap.set(colorBufferFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(WEBGL_colorBufferFloat));
    cap.set(colorBufferHalfFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(colorBufferHalfFloat));
    cap.set(textureFilterAnisotropic, !!requireExtension(textureFilterAnisotropic));
    cap.set(astc, !!(requireExtension(astc) || requireExtension(astc_webkit)));
    cap.set(etc, !!(requireExtension(etc) || requireExtension(etc_webkit)));
    cap.set(etc1, !!(requireExtension(etc1) || requireExtension(etc1_webkit)));
    cap.set(pvrtc, !!(requireExtension(pvrtc) || requireExtension(pvrtc_webkit)));
    cap.set(s3tc, !!(requireExtension(s3tc) || requireExtension(s3tc_webkit)));
  }
  /**
   * If there are extensions that can supplement this ability, smooth out the difference.
   * @example
   * compatible(GLCapabilityType.depthTexture,{
   *    UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
   * })
   * gl.UNSIGNED_INT_24_8 = ext.UNSIGNED_INT_24_8_WEBGL
   */
  ;

  _proto._compatibleInterface = function _compatibleInterface(capabilityType, flatItem) {
    var rhi = this.rhi;
    var gl = rhi.gl;
    var ext = null;

    if (ext = rhi.requireExtension(capabilityType)) {
      for (var _glKey in flatItem) {
        var _extensionKey = flatItem[_glKey];
        var extensionVal = ext[_extensionKey]; // Mini game hack the native function,use “.bind” to smooth out if is “Funcion”.

        if (extensionVal !== null && extensionVal !== void 0 && extensionVal.bind) {
          gl[_glKey] = extensionVal.bind(ext);
        } else {
          gl[_glKey] = extensionVal;
        }
      }
    }
  };

  _proto._compatibleAllInterface = function _compatibleAllInterface() {
    var depthTexture = GLCapabilityType.depthTexture,
        vertexArrayObject = GLCapabilityType.vertexArrayObject,
        instancedArrays = GLCapabilityType.instancedArrays,
        drawBuffers = GLCapabilityType.drawBuffers,
        textureFilterAnisotropic = GLCapabilityType.textureFilterAnisotropic,
        textureHalfFloat = GLCapabilityType.textureHalfFloat,
        colorBufferHalfFloat = GLCapabilityType.colorBufferHalfFloat,
        WEBGL_colorBufferFloat = GLCapabilityType.WEBGL_colorBufferFloat;
    var isWebGL2 = this.rhi.isWebGL2;

    if (!isWebGL2) {
      this._compatibleInterface(depthTexture, {
        UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
      });

      this._compatibleInterface(vertexArrayObject, {
        createVertexArray: "createVertexArrayOES",
        deleteVertexArray: "deleteVertexArrayOES",
        isVertexArray: "isVertexArrayOES",
        bindVertexArray: "bindVertexArrayOES"
      });

      this._compatibleInterface(instancedArrays, {
        drawArraysInstanced: "drawArraysInstancedANGLE",
        drawElementsInstanced: "drawElementsInstancedANGLE",
        vertexAttribDivisor: "vertexAttribDivisorANGLE"
      });

      this._compatibleInterface(drawBuffers, {
        MAX_DRAW_BUFFERS: "MAX_DRAW_BUFFERS_WEBGL"
      });

      var items = {};

      if (this.canIUse(GLCapabilityType.drawBuffers)) {
        var maxDrawBuffers = this.maxDrawBuffers;

        for (var i = 0; i < maxDrawBuffers; i++) {
          i != 0 && (items["COLOR_ATTACHMENT" + i] = "COLOR_ATTACHMENT" + i + "_WEBGL");
          items["DRAW_BUFFER" + i] = "DRAW_BUFFER" + i + "_WEBGL";
        }

        this._compatibleInterface(drawBuffers, _objectSpread2({
          drawBuffers: "drawBuffersWEBGL"
        }, items));
      }

      this._compatibleInterface(textureHalfFloat, {
        HAFL_FLOAT: "HALF_FLOAT_OES"
      });

      this._compatibleInterface(colorBufferHalfFloat, {
        RGBA16F: "RBGA16F_EXT"
      });

      this._compatibleInterface(WEBGL_colorBufferFloat, {
        RGBA32F: "RBGA32F_EXT"
      });
    }

    this._compatibleInterface(textureFilterAnisotropic, {
      TEXTURE_MAX_ANISOTROPY_EXT: "TEXTURE_MAX_ANISOTROPY_EXT"
    });
  };

  _createClass(GLCapability, [{
    key: "canUseFloatTextureBlendShape",
    get: function get() {
      return this.canIUse(GLCapabilityType.shaderVertexID) && this.canIUse(GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
    }
    /**
     * Whether can use more joints.
     */

  }, {
    key: "canIUseMoreJoints",
    get: function get() {
      return this.canIUse(GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
    }
  }, {
    key: "maxDrawBuffers",
    get: function get() {
      if (!this._maxDrawBuffers) {
        if (this.canIUse(GLCapabilityType.drawBuffers)) {
          this._maxDrawBuffers = this._rhi.gl.getParameter(this._rhi.gl.MAX_DRAW_BUFFERS);
        } else {
          this._maxDrawBuffers = 1;
        }
      }

      return this._maxDrawBuffers;
    }
    /**
     * Max anisoLevel.
     */

  }, {
    key: "maxAnisoLevel",
    get: function get() {
      if (!this._maxAnisoLevel) {
        var ext = this._rhi.requireExtension(GLCapabilityType.textureFilterAnisotropic);

        this._maxAnisoLevel = ext ? this._rhi.gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
      }

      return this._maxAnisoLevel;
    }
    /**
     * Max MSAA count.
     */

  }, {
    key: "maxAntiAliasing",
    get: function get() {
      if (!this._maxAntiAliasing) {
        var gl = this._rhi.gl;
        var canMSAA = this.canIUse(GLCapabilityType.multipleSample);
        this._maxAntiAliasing = canMSAA ? gl.getParameter(gl.MAX_SAMPLES) : 1;
      }

      return this._maxAntiAliasing;
    }
  }, {
    key: "rhi",
    get: function get() {
      return this._rhi;
    }
  }]);

  return GLCapability;
}();

/**
 * GLContext extension.
 */
var GLExtensions = /*#__PURE__*/function () {
  function GLExtensions(rhi) {
    this.rhi = void 0;
    this._requireResult = void 0;
    this.rhi = rhi;
    this._requireResult = {};
  }
  /**
   * Require an extension.
   */


  var _proto = GLExtensions.prototype;

  _proto.requireExtension = function requireExtension(ext) {
    if (this._requireResult[ext] !== undefined) {
      return this._requireResult[ext];
    }

    this._requireResult[ext] = this.rhi.gl.getExtension(ext);
    return this._requireResult[ext];
  };

  return GLExtensions;
}();

/**
 * Improvement of VAO:
 * 1) WebGL2.0 must support VAO, almost all devices support vao extensions in webgl1.0, we can use PollyFill,only keep VAO mode.
 * 2) VAO implementation now has bugs, change IndexBuffer、VertexBuffer、VertexElements need to update VAO.
 */

/**
 * @internal
 * GL platform primitive.
 */
var GLPrimitive = /*#__PURE__*/function () {
  function GLPrimitive(rhi, primitive) {
    this.attribLocArray = void 0;
    this._primitive = void 0;
    this.canUseInstancedArrays = void 0;
    this.gl = void 0;
    this.vao = new Map();
    this._useVao = void 0;
    this._primitive = primitive;
    this.canUseInstancedArrays = rhi.canIUse(GLCapabilityType.instancedArrays);
    this._useVao = rhi.canIUse(GLCapabilityType.vertexArrayObject);
    this.gl = rhi.gl;
  }
  /**
   * Draw the primitive.
   */


  var _proto = GLPrimitive.prototype;

  _proto.draw = function draw(shaderProgram, subMesh) {
    var gl = this.gl;
    var primitive = this._primitive;

    if (this._useVao) {
      if (!this.vao.has(shaderProgram.id)) {
        this.registerVAO(shaderProgram);
      }

      var vao = this.vao.get(shaderProgram.id);
      gl.bindVertexArray(vao);
    } else {
      this.bindBufferAndAttrib(shaderProgram);
    } // @ts-ignore


    var _indexBufferBinding = primitive._indexBufferBinding,
        _instanceCount = primitive._instanceCount,
        _glIndexType = primitive._glIndexType,
        _glIndexByteCount = primitive._glIndexByteCount;
    var topology = subMesh.topology,
        start = subMesh.start,
        count = subMesh.count;

    if (!_instanceCount) {
      if (_indexBufferBinding) {
        if (this._useVao) {
          gl.drawElements(topology, count, _glIndexType, start * _glIndexByteCount);
        } else {
          var _nativeBuffer = _indexBufferBinding.buffer._nativeBuffer;
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer);
          gl.drawElements(topology, count, _glIndexType, start * _glIndexByteCount);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
      } else {
        gl.drawArrays(topology, start, count);
      }
    } else {
      if (this.canUseInstancedArrays) {
        if (_indexBufferBinding) {
          if (this._useVao) {
            gl.drawElementsInstanced(topology, count, _glIndexType, start * _glIndexByteCount, _instanceCount);
          } else {
            var _nativeBuffer2 = _indexBufferBinding.buffer._nativeBuffer;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer2);
            gl.drawElementsInstanced(topology, count, _glIndexType, start * _glIndexByteCount, _instanceCount);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }
        } else {
          gl.drawArraysInstanced(topology, start, count, _instanceCount);
        }
      } else {
        Logger.error("ANGLE_instanced_arrays extension is not supported");
      }
    } // unbind


    if (this._useVao) {
      gl.bindVertexArray(null);
    } else {
      this.disableAttrib();
    }
  };

  _proto.destroy = function destroy() {
    if (this._useVao) {
      var gl = this.gl;
      this.vao.forEach(function (vao) {
        gl.deleteVertexArray(vao);
      });
      this.vao.clear();
    }
  }
  /**
   * Bind buffer and attribute.
   */
  ;

  _proto.bindBufferAndAttrib = function bindBufferAndAttrib(shaderProgram) {
    var gl = this.gl;
    var primitive = this._primitive; // @ts-ignore

    var vertexBufferBindings = primitive._vertexBufferBindings;
    this.attribLocArray = [];
    var attributeLocation = shaderProgram.attributeLocation;
    var attributes = primitive._vertexElementMap;
    var vbo;
    var lastBoundVbo;

    for (var name in attributeLocation) {
      var loc = attributeLocation[name];
      if (loc === -1) continue;
      var element = attributes[name];

      if (element) {
        var _vertexBufferBindings = vertexBufferBindings[element.bindingIndex],
            buffer = _vertexBufferBindings.buffer,
            stride = _vertexBufferBindings.stride;
        vbo = buffer._nativeBuffer; // prevent binding the vbo which already bound at the last loop, e.g. a buffer with multiple attributes.

        if (lastBoundVbo !== vbo) {
          lastBoundVbo = vbo;
          gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        }

        gl.enableVertexAttribArray(loc);
        var _element$_glElementIn = element._glElementInfo,
            size = _element$_glElementIn.size,
            type = _element$_glElementIn.type,
            normalized = _element$_glElementIn.normalized;
        gl.vertexAttribPointer(loc, size, type, normalized, stride, element.offset);

        if (this.canUseInstancedArrays) {
          gl.vertexAttribDivisor(loc, element.instanceStepRate);
        }

        this.attribLocArray.push(loc);
      } else {
        Logger.warn("vertex attribute not found: " + name);
      }
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, null);
  };

  _proto.disableAttrib = function disableAttrib() {
    var gl = this.gl;

    for (var i = 0, l = this.attribLocArray.length; i < l; i++) {
      gl.disableVertexAttribArray(this.attribLocArray[i]);
    }
  };

  _proto.registerVAO = function registerVAO(shaderProgram) {
    var gl = this.gl;
    var vao = gl.createVertexArray();
    /** register VAO */

    gl.bindVertexArray(vao); // @ts-ignore

    var _indexBufferBinding = this._primitive._indexBufferBinding;

    if (_indexBufferBinding) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _indexBufferBinding.buffer._nativeBuffer);
    }

    this.bindBufferAndAttrib(shaderProgram);
    /** unbind */

    gl.bindVertexArray(null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    this.disableAttrib();
    this.vao.set(shaderProgram.id, vao);
  };

  return GLPrimitive;
}();

/**
 * Texture in WebGL platform.
 */
var GLTexture = /*#__PURE__*/function () {
  /** @internal */

  /** @internal */
  GLTexture._isPowerOf2 = function _isPowerOf2(v) {
    return (v & v - 1) === 0;
  }
  /**
   * Get more texture info from TextureFormat.
   * @internal
   */
  ;

  GLTexture._getFormatDetail = function _getFormatDetail(format, gl, isWebGL2) {
    switch (format) {
      case TextureFormat.R8G8B8:
        return {
          internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };

      case TextureFormat.R8G8B8A8:
        return {
          internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };

      case TextureFormat.R4G4B4A4:
        return {
          internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_4_4_4_4,
          isCompressed: false
        };

      case TextureFormat.R5G5B5A1:
        return {
          internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_5_5_5_1,
          isCompressed: false
        };

      case TextureFormat.R5G6B5:
        return {
          internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_SHORT_5_6_5,
          isCompressed: false
        };

      case TextureFormat.Alpha8:
        return {
          internalFormat: gl.ALPHA,
          baseFormat: gl.ALPHA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };

      case TextureFormat.LuminanceAlpha:
        return {
          internalFormat: gl.LUMINANCE_ALPHA,
          baseFormat: gl.LUMINANCE_ALPHA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };

      case TextureFormat.R32G32B32A32:
        return {
          internalFormat: gl.RGBA32F,
          baseFormat: gl.RGBA,
          dataType: gl.FLOAT,
          isCompressed: false
        };

      case TextureFormat.DXT1:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
          isCompressed: true
        };

      case TextureFormat.DXT5:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT,
          isCompressed: true
        };

      case TextureFormat.ETC1_RGB:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
          isCompressed: true
        };

      case TextureFormat.ETC2_RGB:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB8_ETC2,
          isCompressed: true
        };

      case TextureFormat.ETC2_RGBA5:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
          isCompressed: true
        };

      case TextureFormat.ETC2_RGBA8:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC,
          isCompressed: true
        };

      case TextureFormat.PVRTC_RGB2:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG,
          isCompressed: true
        };

      case TextureFormat.PVRTC_RGBA2:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
          isCompressed: true
        };

      case TextureFormat.PVRTC_RGB4:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
          isCompressed: true
        };

      case TextureFormat.PVRTC_RGBA4:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG,
          isCompressed: true
        };

      case TextureFormat.ASTC_4x4:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
          isCompressed: true
        };

      case TextureFormat.ASTC_5x5:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR,
          isCompressed: true
        };

      case TextureFormat.ASTC_6x6:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR,
          isCompressed: true
        };

      case TextureFormat.ASTC_8x8:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR,
          isCompressed: true
        };

      case TextureFormat.ASTC_10x10:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR,
          isCompressed: true
        };

      case TextureFormat.ASTC_12x12:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
          isCompressed: true
        };

      default:
        throw new Error("this TextureFormat is not supported in Oasis Engine: " + format);
    }
  }
  /**
   * @internal
   */
  ;

  GLTexture._getRenderBufferColorFormatDetail = function _getRenderBufferColorFormatDetail(format, gl, isWebGL2) {
    switch (format) {
      case RenderBufferColorFormat.R8G8B8:
        return {
          internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };

      case RenderBufferColorFormat.R8G8B8A8:
        return {
          internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };

      case RenderBufferColorFormat.R4G4B4A4:
        return {
          internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_4_4_4_4,
          isCompressed: false
        };

      case RenderBufferColorFormat.R5G5B5A1:
        return {
          internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_5_5_5_1,
          isCompressed: false
        };

      case RenderBufferColorFormat.R5G6B5:
        return {
          internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_SHORT_5_6_5,
          isCompressed: false
        };

      case RenderBufferColorFormat.Alpha8:
        return {
          internalFormat: gl.ALPHA,
          baseFormat: gl.ALPHA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };

      case RenderBufferColorFormat.R16G16B16A16:
        return {
          internalFormat: gl.RGBA16F,
          baseFormat: gl.RGBA,
          dataType: gl.HALF_FLOAT,
          isCompressed: false
        };

      case RenderBufferColorFormat.R32G32B32A32:
        return {
          internalFormat: gl.RGBA32F,
          baseFormat: gl.RGBA,
          dataType: gl.FLOAT,
          isCompressed: false
        };

      default:
        throw new Error("this RenderBufferColorFormat is not supported in Oasis Engine: " + format);
    }
  }
  /**
   * In WebGL 1, internalformat must be the same as baseFormat when call texImage2D.
   * @internal
   */
  ;

  GLTexture._getRenderBufferDepthFormatDetail = function _getRenderBufferDepthFormatDetail(format, gl, isWebGL2) {
    switch (format) {
      case RenderBufferDepthFormat.Depth:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_INT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };

      case RenderBufferDepthFormat.DepthStencil:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: gl.UNSIGNED_INT_24_8,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };

      case RenderBufferDepthFormat.Stencil:
        return {
          internalFormat: gl.STENCIL_INDEX8,
          baseFormat: gl.STENCIL_ATTACHMENT,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false,
          attachment: gl.STENCIL_ATTACHMENT
        };

      case RenderBufferDepthFormat.Depth16:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT16,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.UNSIGNED_INT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };

      case RenderBufferDepthFormat.Depth24:
        return {
          internalFormat: gl.DEPTH_COMPONENT24,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.UNSIGNED_INT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };

      case RenderBufferDepthFormat.Depth32:
        return {
          internalFormat: gl.DEPTH_COMPONENT32F,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.FLOAT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };

      case RenderBufferDepthFormat.Depth24Stencil8:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: gl.UNSIGNED_INT_24_8,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };

      case RenderBufferDepthFormat.Depth32Stencil8:
        return {
          internalFormat: gl.DEPTH32F_STENCIL8,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };

      default:
        throw new Error("this RenderBufferDepthFormat is not supported in Oasis Engine: " + format);
    }
  }
  /**
   * Check whether the corresponding texture format is supported.
   * @internal
   */
  ;

  GLTexture._supportTextureFormat = function _supportTextureFormat(format, rhi) {
    var isSupported = true;

    switch (format) {
      case TextureFormat.R32G32B32A32:
        {
          if (!rhi.canIUse(GLCapabilityType.textureFloat)) {
            isSupported = false;
          }
        }
        break;
    }

    return isSupported;
  }
  /**
   * @internal
   */
  ;

  GLTexture._supportRenderBufferColorFormat = function _supportRenderBufferColorFormat(format, rhi) {
    var isSupported = true;

    switch (format) {
      case RenderBufferColorFormat.R32G32B32A32:
        {
          if (!rhi.canIUse(GLCapabilityType.colorBufferFloat) || !rhi.canIUse(GLCapabilityType.textureFloat)) {
            isSupported = false;
          }
        }
        break;

      case RenderBufferColorFormat.R16G16B16A16:
        {
          if (!rhi.canIUse(GLCapabilityType.colorBufferHalfFloat) || !rhi.canIUse(GLCapabilityType.textureHalfFloat)) {
            isSupported = false;
          }
        }
        break;
    }

    return isSupported;
  }
  /**
   * @internal
   */
  ;

  GLTexture._supportRenderBufferDepthFormat = function _supportRenderBufferDepthFormat(format, rhi, isTexture) {
    var isWebGL2 = rhi.isWebGL2;
    var isSupported = true;

    if (isTexture && !rhi.canIUse(GLCapabilityType.depthTexture)) {
      return false;
    }

    switch (format) {
      case RenderBufferDepthFormat.Stencil:
        {
          isSupported = false;
        }
        break;

      case RenderBufferDepthFormat.Depth24:
      case RenderBufferDepthFormat.Depth32:
      case RenderBufferDepthFormat.Depth32Stencil8:
        {
          if (!isWebGL2) {
            isSupported = false;
          }
        }
        break;
    }

    return isSupported;
  }
  /** @internal */
  ;

  /**
   * Create texture in WebGL platform.
   */
  function GLTexture(rhi, texture, target) {
    this._texture = void 0;
    this._glTexture = void 0;
    this._rhi = void 0;
    this._gl = void 0;
    this._isWebGL2 = void 0;
    this._target = void 0;
    this._formatDetail = void 0;
    this._texture = texture;
    this._rhi = rhi;
    this._gl = rhi.gl;
    this._isWebGL2 = rhi.isWebGL2;
    this._target = target;
    this._glTexture = this._gl.createTexture();
  }
  /**
   * Destroy texture.
   */


  var _proto = GLTexture.prototype;

  _proto.destroy = function destroy() {
    this._gl.deleteTexture(this._glTexture);

    this._texture = null;
    this._glTexture = null;
    this._formatDetail = null;
  }
  /**
   * Generate multi-level textures based on the 0th level data.
   */
  ;

  _proto.generateMipmaps = function generateMipmaps() {
    this._bind();

    this._gl.generateMipmap(this._target);
  };

  _proto._bind = function _bind() {
    this._rhi.bindTexture(this);
  }
  /**
   * Pre-development mipmapping GPU memory.
   */
  ;

  _proto._initMipmap = function _initMipmap(isCube) {
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var _this$_formatDetail = this._formatDetail,
        internalFormat = _this$_formatDetail.internalFormat,
        baseFormat = _this$_formatDetail.baseFormat,
        dataType = _this$_formatDetail.dataType;
    var _this$_texture = this._texture,
        mipmapCount = _this$_texture.mipmapCount,
        width = _this$_texture.width,
        height = _this$_texture.height;

    this._bind();

    if (isWebGL2 && !(baseFormat === gl.LUMINANCE_ALPHA || baseFormat === gl.ALPHA)) {
      gl.texStorage2D(this._target, mipmapCount, internalFormat, width, height);
    } else {
      // In WebGL 1, internalformat must be the same as baseFormat
      if (baseFormat !== internalFormat) {
        internalFormat = baseFormat;
      }

      if (!isCube) {
        for (var i = 0; i < mipmapCount; i++) {
          var mipWidth = Math.max(1, width >> i);
          var mipHeight = Math.max(1, height >> i);
          gl.texImage2D(this._target, i, internalFormat, mipWidth, mipHeight, 0, baseFormat, dataType, null);
        }
      } else {
        for (var _i = 0; _i < mipmapCount; _i++) {
          var size = Math.max(1, width >> _i);

          for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, _i, internalFormat, size, size, 0, baseFormat, dataType, null);
          }
        }
      }
    }
  }
  /**
   * Get the pixel color buffer according to the specified cube face and area.
   * @param face - You can choose which cube face to read
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Area width
   * @param height - Area height
   * @param out - Color buffer
   */
  ;

  _proto._getPixelBuffer = function _getPixelBuffer(face, x, y, width, height, out) {
    var gl = this._gl;
    var _this$_formatDetail2 = this._formatDetail,
        baseFormat = _this$_formatDetail2.baseFormat,
        dataType = _this$_formatDetail2.dataType;

    if (!GLTexture._readFrameBuffer) {
      GLTexture._readFrameBuffer = gl.createFramebuffer();
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, GLTexture._readFrameBuffer);

    if (face != null) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, this._glTexture, 0);
    } else {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._glTexture, 0);
    }

    gl.readPixels(x, y, width, height, baseFormat, dataType, out);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  };

  _proto._setWrapMode = function _setWrapMode(value, pname) {
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var target = this._target;
    var _this$_texture2 = this._texture,
        width = _this$_texture2.width,
        height = _this$_texture2.height;

    if (!isWebGL2 && value !== TextureWrapMode.Clamp && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for REPEAT or MIRRORED_REPEAT in WebGL1,and has automatically downgraded to CLAMP_TO_EDGE");
      value = TextureWrapMode.Clamp;
    }

    switch (value) {
      case TextureWrapMode.Clamp:
        gl.texParameteri(target, pname, gl.CLAMP_TO_EDGE);
        break;

      case TextureWrapMode.Repeat:
        gl.texParameteri(target, pname, gl.REPEAT);
        break;

      case TextureWrapMode.Mirror:
        gl.texParameteri(target, pname, gl.MIRRORED_REPEAT);
        break;
    }
  };

  _createClass(GLTexture, [{
    key: "wrapModeU",
    set:
    /**
     * Wrapping mode for texture coordinate S.
     */
    function set(value) {
      this._bind();

      this._setWrapMode(value, this._gl.TEXTURE_WRAP_S);
    }
    /**
     * Wrapping mode for texture coordinate T.
     */

  }, {
    key: "wrapModeV",
    set: function set(value) {
      this._bind();

      this._setWrapMode(value, this._gl.TEXTURE_WRAP_T);
    }
    /**
     * Filter mode for texture.
     */

  }, {
    key: "filterMode",
    set: function set(value) {
      var gl = this._gl;
      var target = this._target;
      /** @ts-ignore */

      var _mipmap = this._texture._mipmap;

      this._bind();

      switch (value) {
        case TextureFilterMode.Point:
          gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST);
          break;

        case TextureFilterMode.Bilinear:
          gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR);
          break;

        case TextureFilterMode.Trilinear:
          gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
          break;
      }
    }
    /**
     * Anisotropic level for texture.
     */

  }, {
    key: "anisoLevel",
    set: function set(value) {
      var gl = this._gl;

      this._bind();

      gl.texParameterf(this._target, gl.TEXTURE_MAX_ANISOTROPY_EXT, value);
    }
  }]);

  return GLTexture;
}();
GLTexture._readFrameBuffer = null;

/**
 * The texture in WebGL platform is used for the output of color information in off-screen rendering.
 */
var GLRenderColorTexture = /*#__PURE__*/function (_GLTexture) {
  _inheritsLoose(GLRenderColorTexture, _GLTexture);

  /**
   * Create render color texture in WebGL platform.
   */
  function GLRenderColorTexture(rhi, texture) {
    var _this;

    _this = _GLTexture.call(this, rhi, texture, texture.isCube ? rhi.gl.TEXTURE_CUBE_MAP : rhi.gl.TEXTURE_2D) || this;
    /** @ts-ignore */

    var format = texture.format,
        _mipmap = texture._mipmap,
        width = texture.width,
        height = texture.height,
        isCube = texture.isCube;
    var isWebGL2 = _this._isWebGL2;

    if (!GLTexture._supportRenderBufferColorFormat(format, rhi)) {
      throw new Error("RenderBufferColorFormat is not supported:" + RenderBufferColorFormat[format]);
    }

    if (isCube && width !== height) {
      throw new Error("The cube texture must have the same width and height");
    }

    if (_mipmap && !isWebGL2 && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      /** @ts-ignore */

      texture._mipmap = false;
      /** @ts-ignore */

      texture._mipmapCount = texture._getMipmapCount();
    }

    _this._formatDetail = GLTexture._getRenderBufferColorFormatDetail(format, _this._gl, isWebGL2);

    _this._initMipmap(isCube);

    return _this;
  }
  /**
   * Get the pixel color buffer according to the specified cube face and area.
   * @param face - You can choose which cube face to read if it's cube texture
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Area width
   * @param height - Area height
   * @param out - Color buffer
   */


  var _proto = GLRenderColorTexture.prototype;

  _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, out) {
    _GLTexture.prototype._getPixelBuffer.call(this, face, x, y, width, height, out);
  };

  return GLRenderColorTexture;
}(GLTexture);

/**
 * The texture in WebGL platform is used for the output of depth information in off-screen rendering.
 */
var GLRenderDepthTexture = /*#__PURE__*/function (_GLTexture) {
  _inheritsLoose(GLRenderDepthTexture, _GLTexture);

  /**
   * Create render depth texture in WebGL platform.
   */
  function GLRenderDepthTexture(rhi, texture) {
    var _this;

    _this = _GLTexture.call(this, rhi, texture, texture.isCube ? rhi.gl.TEXTURE_CUBE_MAP : rhi.gl.TEXTURE_2D) || this;
    /** @ts-ignore */

    var format = texture.format,
        _mipmap = texture._mipmap,
        width = texture.width,
        height = texture.height,
        isCube = texture.isCube;
    var isWebGL2 = _this._isWebGL2;

    if (!GLTexture._supportRenderBufferDepthFormat(format, rhi, true)) {
      throw new Error("RenderBufferDepthFormat is not supported:" + RenderBufferDepthFormat[format]);
    }

    if (isCube && width !== height) {
      throw new Error("The cube texture must have the same width and height");
    }

    if (_mipmap && !isWebGL2 && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      /** @ts-ignore */

      texture._mipmap = false;
      /** @ts-ignore */

      texture._mipmapCount = texture._getMipmapCount();
    }

    _this._formatDetail = GLTexture._getRenderBufferDepthFormatDetail(format, _this._gl, isWebGL2);

    _this._initMipmap(isCube);

    return _this;
  }

  return GLRenderDepthTexture;
}(GLTexture);

/**
 * @private
 */
var GLRenderStates = /*#__PURE__*/function () {
  /**
   * @param {WebGLRenderingContext} gl
   */
  function GLRenderStates(gl) {
    this._gl = void 0;
    this._parameters = {};
    this._gl = gl;
    this._parameters = {}; // current gl state parameters

    /** cache */

    this._parameters[gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    this._parameters[gl.MAX_VERTEX_UNIFORM_VECTORS] = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    this._parameters[gl.MAX_VERTEX_ATTRIBS] = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    this._parameters[gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    this._parameters[gl.MAX_TEXTURE_SIZE] = gl.getParameter(gl.MAX_TEXTURE_SIZE); // init blend state same as BlendState default value.

    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    gl.colorMask(true, true, true, true);
    gl.blendColor(0, 0, 0, 0);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE); // init depth state same as DepthState default value.

    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LESS);
    gl.depthMask(true); // init stencil state same as StencilState default value.

    gl.disable(gl.STENCIL_TEST);
    gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 0, 0xff);
    gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 0, 0xff);
    gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilMask(0xff); // init raster state same as RasterState default value.

    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.polygonOffset(0, 0);
  }
  /**
   * Get a parameter.
   */


  var _proto = GLRenderStates.prototype;

  _proto.getParameter = function getParameter(pname) {
    return this._parameters[pname];
  };

  return GLRenderStates;
}();

/**
 * The render target in WebGL platform is used for off-screen rendering.
 */
var GLRenderTarget = /*#__PURE__*/function () {
  /**
   * Create render target in WebGL platform.
   */
  function GLRenderTarget(rhi, target) {
    this._gl = void 0;
    this._isWebGL2 = void 0;
    this._target = void 0;
    this._frameBuffer = void 0;
    this._MSAAFrameBuffer = void 0;
    this._depthRenderBuffer = void 0;
    this._MSAAColorRenderBuffers = [];
    this._MSAADepthRenderBuffer = void 0;
    this._oriDrawBuffers = void 0;
    this._blitDrawBuffers = void 0;
    this._gl = rhi.gl;
    this._isWebGL2 = rhi.isWebGL2;
    this._target = target;
    /** @ts-ignore */

    var _colorTextures = target._colorTextures,
        _depth = target._depth,
        width = target.width,
        height = target.height;
    /** todo
     * MRT + Cube + [,MSAA]
     * MRT + MSAA
     */

    if (!(_depth instanceof RenderDepthTexture) && !GLTexture._supportRenderBufferDepthFormat(_depth, rhi, false)) {
      throw new Error("RenderBufferDepthFormat is not supported:" + RenderBufferDepthFormat[_depth]);
    }

    if (_colorTextures.length > 1 && !rhi.canIUse(GLCapabilityType.drawBuffers)) {
      throw new Error("MRT is not supported");
    }

    if (_colorTextures.some(function (v) {
      return v.width !== width || v.height !== height;
    })) {
      throw new Error("RenderColorTexture's size must as same as RenderTarget");
    }

    if (_depth instanceof RenderDepthTexture && (_depth.width !== width || _depth.height !== height)) {
      throw new Error("RenderDepthTexture's size must as same as RenderTarget");
    } // todo: necessary to support MRT + Cube + [,MSAA] ?


    if (_colorTextures.length > 1 && _colorTextures.some(function (v) {
      return v.isCube;
    })) {
      throw new Error("MRT+Cube+[,MSAA] is not supported");
    }

    var maxAntiAliasing = rhi.capability.maxAntiAliasing;

    if (target.antiAliasing > maxAntiAliasing) {
      Logger.warn("MSAA antiAliasing exceeds the limit and is automatically downgraded to:" + maxAntiAliasing);
      /** @ts-ignore */

      target._antiAliasing = maxAntiAliasing;
    }

    this._frameBuffer = this._gl.createFramebuffer(); // bind main FBO

    this._bindMainFBO(); // bind MSAA FBO


    if (target.antiAliasing > 1) {
      this._MSAAFrameBuffer = this._gl.createFramebuffer();

      this._bindMSAAFBO();
    }
  }
  /**
   * Set which face of the cube texture to render to.
   * @param faceIndex - Cube texture face
   */


  var _proto = GLRenderTarget.prototype;

  _proto.setRenderTargetFace = function setRenderTargetFace(faceIndex) {
    var gl = this._gl;

    var colorTexture = this._target.getColorTexture(0);

    var depthTexture = this._target.depthTexture;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer); // bind render color texture

    if (colorTexture !== null && colorTexture !== void 0 && colorTexture.isCube) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,
      /** @ts-ignore */
      colorTexture._platformTexture._glTexture, 0);
    } // bind depth texture


    if (depthTexture !== null && depthTexture !== void 0 && depthTexture.isCube) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER,
      /** @ts-ignore */
      depthTexture._platformTexture._formatDetail.attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,
      /** @ts-ignore */
      depthTexture._platformTexture._glTexture, 0);
    } // revert current activated render target


    this._activeRenderTarget();
  }
  /**
   * Blit FBO.
   */
  ;

  _proto.blitRenderTarget = function blitRenderTarget() {
    if (!this._MSAAFrameBuffer) return;
    var gl = this._gl;
    var mask = gl.COLOR_BUFFER_BIT | (this._target.depthTexture ? gl.DEPTH_BUFFER_BIT : 0);
    var _this$_target = this._target,
        colorTextureCount = _this$_target.colorTextureCount,
        width = _this$_target.width,
        height = _this$_target.height;
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._MSAAFrameBuffer);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);

    for (var textureIndex = 0; textureIndex < colorTextureCount; textureIndex++) {
      var attachment = gl.COLOR_ATTACHMENT0 + textureIndex;
      this._blitDrawBuffers[textureIndex] = attachment;
      gl.readBuffer(attachment);
      gl.drawBuffers(this._blitDrawBuffers);
      gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);
      this._blitDrawBuffers[textureIndex] = gl.NONE;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
  /**
   * Destroy render target.
   */
  ;

  _proto.destroy = function destroy() {
    var gl = this._gl;
    this._frameBuffer && gl.deleteFramebuffer(this._frameBuffer);
    this._depthRenderBuffer && gl.deleteRenderbuffer(this._depthRenderBuffer);
    this._MSAAFrameBuffer && gl.deleteFramebuffer(this._MSAAFrameBuffer);
    this._MSAADepthRenderBuffer && gl.deleteRenderbuffer(this._MSAADepthRenderBuffer);

    for (var i = 0; i < this._MSAAColorRenderBuffers.length; i++) {
      gl.deleteRenderbuffer(this._MSAAColorRenderBuffers[i]);
    }

    this._frameBuffer = null;
    this._depthRenderBuffer = null;
    this._MSAAFrameBuffer = null;
    this._MSAAColorRenderBuffers.length = 0;
    this._MSAADepthRenderBuffer = null;
  }
  /**
   * Activate this RenderTarget.
   * @internal
   * @remarks
   * If MSAA is turned on, MSAA FBO is activated, and then this._blitRenderTarget() is performed to exchange FBO.
   * If MSAA is not turned on, activate the main FBO.
   */
  ;

  _proto._activeRenderTarget = function _activeRenderTarget() {
    var gl = this._gl;

    if (this._MSAAFrameBuffer) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    }
  };

  _proto._bindMainFBO = function _bindMainFBO() {
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    /** @ts-ignore */

    var _this$_target2 = this._target,
        _depth = _this$_target2._depth,
        colorTextureCount = _this$_target2.colorTextureCount,
        width = _this$_target2.width,
        height = _this$_target2.height;
    var drawBuffers = new Array(colorTextureCount);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    /** color render buffer */

    for (var i = 0; i < colorTextureCount; i++) {
      var colorTexture = this._target.getColorTexture(i);

      var attachment = gl.COLOR_ATTACHMENT0 + i;
      drawBuffers[i] = attachment; // Cube texture please call _setRenderTargetFace()

      if (!colorTexture.isCube) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D,
        /** @ts-ignore */
        colorTexture._platformTexture._glTexture, 0);
      }
    }

    if (colorTextureCount > 1) {
      gl.drawBuffers(drawBuffers);
    }

    this._oriDrawBuffers = drawBuffers;
    /** depth render buffer */

    if (_depth !== null) {
      if (_depth instanceof RenderDepthTexture) {
        // Cube texture please call _setRenderTargetFace()
        if (!_depth.isCube) {
          gl.framebufferTexture2D(gl.FRAMEBUFFER,
          /** @ts-ignore */
          _depth._platformTexture._formatDetail.attachment, gl.TEXTURE_2D,
          /** @ts-ignore */
          _depth._platformTexture._glTexture, 0);
        }
      } else if (this._target.antiAliasing <= 1) {
        var _GLTexture$_getRender = GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2),
            internalFormat = _GLTexture$_getRender.internalFormat,
            _attachment = _GLTexture$_getRender.attachment;

        var depthRenderBuffer = gl.createRenderbuffer();
        this._depthRenderBuffer = depthRenderBuffer;
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, _attachment, gl.RENDERBUFFER, depthRenderBuffer);
      }
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  };

  _proto._bindMSAAFBO = function _bindMSAAFBO() {
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var MSAADepthRenderBuffer = gl.createRenderbuffer();
    /** @ts-ignore */

    var _this$_target3 = this._target,
        _depth = _this$_target3._depth,
        colorTextureCount = _this$_target3.colorTextureCount,
        antiAliasing = _this$_target3.antiAliasing,
        width = _this$_target3.width,
        height = _this$_target3.height;
    this._blitDrawBuffers = new Array(colorTextureCount);
    this._MSAADepthRenderBuffer = MSAADepthRenderBuffer;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer); // prepare MRT+MSAA color RBOs

    for (var i = 0; i < colorTextureCount; i++) {
      var MSAAColorRenderBuffer = gl.createRenderbuffer();
      this._MSAAColorRenderBuffers[i] = MSAAColorRenderBuffer;
      this._blitDrawBuffers[i] = gl.NONE;
      gl.bindRenderbuffer(gl.RENDERBUFFER, MSAAColorRenderBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, antiAliasing,
      /** @ts-ignore */
      this._target.getColorTexture(i)._platformTexture._formatDetail.internalFormat, width, height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, MSAAColorRenderBuffer);
    }

    gl.drawBuffers(this._oriDrawBuffers); // prepare MSAA depth RBO

    if (_depth !== null) {
      var _ref = _depth instanceof RenderDepthTexture ?
      /** @ts-ignore */
      _depth._platformTexture._formatDetail : GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2),
          internalFormat = _ref.internalFormat,
          attachment = _ref.attachment;

      gl.bindRenderbuffer(gl.RENDERBUFFER, MSAADepthRenderBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, antiAliasing, internalFormat, width, height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, MSAADepthRenderBuffer);
    }

    this._checkFrameBuffer();

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  };

  _proto._checkFrameBuffer = function _checkFrameBuffer() {
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

    switch (e) {
      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete");

      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        throw new Error("There is no attachment");

      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        throw new Error(" Height and width of the attachment are not the same.");

      case gl.FRAMEBUFFER_UNSUPPORTED:
        throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer");
    }

    if (isWebGL2 && e === gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {
      throw new Error("The values of gl.RENDERBUFFER_SAMPLES are different among attached renderbuffers, or are non-zero if the attached images are a mix of renderbuffers and textures.");
    }
  };

  return GLRenderTarget;
}();

/**
 * Texture 2d in WebGL platform.
 */
var GLTexture2D = /*#__PURE__*/function (_GLTexture) {
  _inheritsLoose(GLTexture2D, _GLTexture);

  /**
   * Backward compatible with WebGL1.0.
   */

  /**
   * Create texture2D in WebGL platform.
   */
  function GLTexture2D(rhi, texture2D) {
    var _this;

    _this = _GLTexture.call(this, rhi, texture2D, rhi.gl.TEXTURE_2D) || this;
    /** @ts-ignore */

    _this._compressedMipFilled = 0;
    var format = texture2D.format,
        _mipmap = texture2D._mipmap,
        width = texture2D.width,
        height = texture2D.height;
    var isWebGL2 = _this._isWebGL2;

    if (!GLTexture._supportTextureFormat(format, rhi)) {
      throw new Error("Texture format is not supported:" + TextureFormat[format]);
    }

    if (_mipmap && !isWebGL2 && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      /** @ts-ignore */

      texture2D._mipmap = false;
      /** @ts-ignore */

      texture2D._mipmapCount = texture2D._getMipmapCount();
    }

    _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, isWebGL2);
    _this._formatDetail.isCompressed && !isWebGL2 || _this._initMipmap(false);
    return _this;
  }
  /**
   * Setting pixels data through color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
   * @remarks If it is the WebGL1.0 platform and the texture format is compressed, the first upload must be filled with textures.
   * @param colorBuffer - Color buffer data
   * @param mipLevel - Texture mipmapping level
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Data width. if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
   * @param height - Data height. if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
   */


  var _proto = GLTexture2D.prototype;

  _proto.setPixelBuffer = function setPixelBuffer(colorBuffer, mipLevel, x, y, width, height) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }

    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var _this$_formatDetail = this._formatDetail,
        internalFormat = _this$_formatDetail.internalFormat,
        baseFormat = _this$_formatDetail.baseFormat,
        dataType = _this$_formatDetail.dataType,
        isCompressed = _this$_formatDetail.isCompressed;
    var mipWidth = Math.max(1, this._texture.width >> mipLevel);
    var mipHeight = Math.max(1, this._texture.height >> mipLevel);
    x = x || 0;
    y = y || 0;
    width = width || mipWidth - x;
    height = height || mipHeight - y;

    this._bind();

    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);

    if (isCompressed) {
      var mipBit = 1 << mipLevel;

      if (isWebGL2 || this._compressedMipFilled & mipBit) {
        gl.compressedTexSubImage2D(this._target, mipLevel, x, y, width, height, internalFormat, colorBuffer);
      } else {
        gl.compressedTexImage2D(this._target, mipLevel, internalFormat, width, height, 0, colorBuffer);
        this._compressedMipFilled |= mipBit;
      }
    } else {
      gl.texSubImage2D(this._target, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
    }
  }
  /**
   * Setting pixels data through TexImageSource, designated area and texture mipmapping level.
   * @param imageSource - The source of texture
   * @param mipLevel - Texture mipmapping level
   * @param flipY - Whether to flip the Y axis
   * @param premultiplyAlpha - Whether to premultiply the transparent channel
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   */
  ;

  _proto.setImageSource = function setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }

    if (flipY === void 0) {
      flipY = false;
    }

    if (premultiplyAlpha === void 0) {
      premultiplyAlpha = false;
    }

    var gl = this._gl;
    var _this$_formatDetail2 = this._formatDetail,
        baseFormat = _this$_formatDetail2.baseFormat,
        dataType = _this$_formatDetail2.dataType;

    this._bind();

    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
    gl.texSubImage2D(this._target, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
  }
  /**
   * Get the pixel color buffer according to the specified area.
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Area width
   * @param height - Area height
   * @param out - Color buffer
   */
  ;

  _proto.getPixelBuffer = function getPixelBuffer(x, y, width, height, out) {
    if (this._formatDetail.isCompressed) {
      throw new Error("Unable to read compressed texture");
    }

    _GLTexture.prototype._getPixelBuffer.call(this, null, x, y, width, height, out);
  };

  return GLTexture2D;
}(GLTexture);

/**
 * Cube texture in WebGL platform.
 */
var GLTextureCubeMap = /*#__PURE__*/function (_GLTexture) {
  _inheritsLoose(GLTextureCubeMap, _GLTexture);

  /**
   * Backward compatible with WebGL1.0.。
   */

  /**
   * Create cube texture in WebGL platform.
   */
  function GLTextureCubeMap(rhi, textureCube) {
    var _this;

    _this = _GLTexture.call(this, rhi, textureCube, rhi.gl.TEXTURE_CUBE_MAP) || this;
    /** @ts-ignore */

    _this._compressedFaceFilled = [0, 0, 0, 0, 0, 0];
    var format = textureCube.format,
        _mipmap = textureCube._mipmap,
        size = textureCube.width;
    var isWebGL2 = _this._isWebGL2;

    if (!GLTexture._supportTextureFormat(format, rhi)) {
      throw new Error("Texture format is not supported:" + TextureFormat[format]);
    }

    if (_mipmap && !isWebGL2 && !GLTexture._isPowerOf2(size)) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      /** @ts-ignore */

      textureCube._mipmap = false;
      /** @ts-ignore */

      textureCube._mipmapCount = textureCube._getMipmapCount();
    }

    _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, isWebGL2);
    _this._formatDetail.isCompressed && !isWebGL2 || _this._initMipmap(true);
    return _this;
  }
  /**
   * Setting pixels data through cube face,color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
   * @remarks When compressed texture is in WebGL1, the texture must be filled first before writing the sub-region
   * @param face - Cube face
   * @param colorBuffer - Color buffer data
   * @param mipLevel - Texture mipmapping level
   * @param x - X coordinate of area start
   * @param y -  Y coordinate of area start
   * @param width - Data width.if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
   * @param height - Data height.if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
   */


  var _proto = GLTextureCubeMap.prototype;

  _proto.setPixelBuffer = function setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }

    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var _this$_formatDetail = this._formatDetail,
        internalFormat = _this$_formatDetail.internalFormat,
        baseFormat = _this$_formatDetail.baseFormat,
        dataType = _this$_formatDetail.dataType,
        isCompressed = _this$_formatDetail.isCompressed;
    var mipSize = Math.max(1, this._texture.width >> mipLevel);
    x = x || 0;
    y = y || 0;
    width = width || mipSize - x;
    height = height || mipSize - y;

    this._bind();

    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);

    if (isCompressed) {
      var mipBit = 1 << mipLevel;

      if (isWebGL2 || this._compressedFaceFilled[face] & mipBit) {
        gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, internalFormat, colorBuffer);
      } else {
        gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, internalFormat, width, height, 0, colorBuffer);
        this._compressedFaceFilled[face] |= mipBit;
      }
    } else {
      gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
    }
  }
  /**
   * Setting pixels data through cube face, TexImageSource, designated area and texture mipmapping level.
   * @param face - Cube face
   * @param imageSource - The source of texture
   * @param mipLevel - Texture mipmapping level
   * @param flipY - Whether to flip the Y axis
   * @param premultiplyAlpha - Whether to premultiply the transparent channel
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   */
  ;

  _proto.setImageSource = function setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }

    if (flipY === void 0) {
      flipY = false;
    }

    if (premultiplyAlpha === void 0) {
      premultiplyAlpha = false;
    }

    var gl = this._gl;
    var _this$_formatDetail2 = this._formatDetail,
        baseFormat = _this$_formatDetail2.baseFormat,
        dataType = _this$_formatDetail2.dataType;

    this._bind();

    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
    gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
  }
  /**
   * Get the pixel color buffer according to the specified cube face and area.
   * @param face - You can choose which cube face to read
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Area width
   * @param height - Area height
   * @param out - Color buffer
   */
  ;

  _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, out) {
    if (this._formatDetail.isCompressed) {
      throw new Error("Unable to read compressed texture");
    }

    _GLTexture.prototype._getPixelBuffer.call(this, face, x, y, width, height, out);
  };

  return GLTextureCubeMap;
}(GLTexture);

/**
 * WebGL mode.
 */
var WebGLMode;
/**
 * WebGL renderer options.
 */

(function (WebGLMode) {
  WebGLMode[WebGLMode["Auto"] = 0] = "Auto";
  WebGLMode[WebGLMode["WebGL2"] = 1] = "WebGL2";
  WebGLMode[WebGLMode["WebGL1"] = 2] = "WebGL1";
})(WebGLMode || (WebGLMode = {}));

/**
 * WebGL renderer, including WebGL1.0 and WebGL2.0.
 */
var WebGLRenderer = /*#__PURE__*/function () {
  function WebGLRenderer(options) {
    if (options === void 0) {
      options = {};
    }

    this._currentBind = void 0;
    this._options = void 0;
    this._gl = void 0;
    this._renderStates = void 0;
    this._extensions = void 0;
    this._capability = void 0;
    this._isWebGL2 = void 0;
    this._activeTextureID = void 0;
    this._activeTextures = new Array(32);
    this._lastViewport = new Vector4(null, null, null, null);
    this._lastClearColor = new Color(null, null, null, null);
    this._options = options;
  }

  var _proto = WebGLRenderer.prototype;

  _proto.init = function init(canvas) {
    var option = this._options;
    option.alpha === undefined && (option.alpha = false);
    option.stencil === undefined && (option.stencil = true);
    var webCanvas = canvas._webCanvas;
    var webGLMode = option.webGLMode || WebGLMode.Auto;
    var gl;

    if (webGLMode == WebGLMode.Auto || webGLMode == WebGLMode.WebGL2) {
      gl = webCanvas.getContext("webgl2", option);

      if (!gl && webCanvas instanceof HTMLCanvasElement) {
        gl = webCanvas.getContext("experimental-webgl2", option);
      }

      this._isWebGL2 = true; // Prevent weird browsers to lie (such as safari!)

      if (gl && !gl.deleteQuery) {
        this._isWebGL2 = false;
      }
    }

    if (!gl) {
      if (webGLMode == WebGLMode.Auto || webGLMode == WebGLMode.WebGL1) {
        gl = webCanvas.getContext("webgl", option);

        if (!gl && webCanvas instanceof HTMLCanvasElement) {
          gl = webCanvas.getContext("experimental-webgl", option);
        }

        this._isWebGL2 = false;
      }
    }

    if (!gl) {
      throw new Error("Get GL Context FAILED.");
    }

    this._gl = gl;
    this._activeTextureID = gl.TEXTURE0;
    this._renderStates = new GLRenderStates(gl);
    this._extensions = new GLExtensions(this);
    this._capability = new GLCapability(this); // Make sure the active texture in gl context is on default, because gl context may be used in other webgl renderer.

    gl.activeTexture(gl.TEXTURE0);
    this._options = null;
  };

  _proto.createPlatformPrimitive = function createPlatformPrimitive(primitive) {
    return new GLPrimitive(this, primitive);
  };

  _proto.createPlatformTexture2D = function createPlatformTexture2D(texture2D) {
    return new GLTexture2D(this, texture2D);
  };

  _proto.createPlatformTextureCubeMap = function createPlatformTextureCubeMap(textureCube) {
    return new GLTextureCubeMap(this, textureCube);
  };

  _proto.createPlatformRenderColorTexture = function createPlatformRenderColorTexture(texture) {
    return new GLRenderColorTexture(this, texture);
  };

  _proto.createPlatformRenderDepthTexture = function createPlatformRenderDepthTexture(texture) {
    return new GLRenderDepthTexture(this, texture);
  };

  _proto.createPlatformRenderTarget = function createPlatformRenderTarget(target) {
    return new GLRenderTarget(this, target);
  };

  _proto.requireExtension = function requireExtension(ext) {
    return this._extensions.requireExtension(ext);
  };

  _proto.canIUse = function canIUse(capabilityType) {
    return this.capability.canIUse(capabilityType);
  };

  _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(type) {
    return this.capability.canIUseCompressedTextureInternalFormat(type);
  };

  _proto.viewport = function viewport(x, y, width, height) {
    // gl.enable(gl.SCISSOR_TEST);
    // gl.scissor(x, transformY, width, height);
    var gl = this._gl;
    var lv = this._lastViewport;

    if (x !== lv.x || y !== lv.y || width !== lv.z || height !== lv.w) {
      gl.viewport(x, y, width, height);
      lv.setValue(x, y, width, height);
    }
  };

  _proto.colorMask = function colorMask(r, g, b, a) {
    this._gl.colorMask(r, g, b, a);
  };

  _proto.clearRenderTarget = function clearRenderTarget(engine, clearFlags, clearColor) {
    var gl = this._gl;
    var _engine$_lastRenderSt = engine._lastRenderState,
        targetBlendState = _engine$_lastRenderSt.blendState.targetBlendState,
        depthState = _engine$_lastRenderSt.depthState,
        stencilState = _engine$_lastRenderSt.stencilState;
    var clearFlag = gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT;

    if (clearFlags === CameraClearFlags.DepthColor) {
      clearFlag |= gl.COLOR_BUFFER_BIT;
      var lc = this._lastClearColor;
      var r = clearColor.r,
          g = clearColor.g,
          b = clearColor.b,
          a = clearColor.a;

      if (clearColor && (r !== lc.r || g !== lc.g || b !== lc.b || a !== lc.a)) {
        gl.clearColor(r, g, b, a);
        lc.setValue(r, g, b, a);
      }

      if (targetBlendState.colorWriteMask !== ColorWriteMask.All) {
        gl.colorMask(true, true, true, true);
        targetBlendState.colorWriteMask = ColorWriteMask.All;
      }
    }

    if (depthState.writeEnabled !== true) {
      gl.depthMask(true);
      depthState.writeEnabled = true;
    }

    if (stencilState.writeMask !== 0xff) {
      gl.stencilMask(0xff);
      stencilState.writeMask = 0xff;
    }

    gl.clear(clearFlag);
  };

  _proto.drawPrimitive = function drawPrimitive(primitive, subPrimitive, shaderProgram) {
    // todo: VAO not support morph animation
    if (primitive) {
      //@ts-ignore
      primitive._draw(shaderProgram, subPrimitive);
    } else {
      Logger.error("draw primitive failed.");
    }
  };

  _proto.activeRenderTarget = function activeRenderTarget(renderTarget, camera) {
    var gl = this._gl;

    if (renderTarget) {
      var _renderTarget$_platfo;

      /** @ts-ignore */
      (_renderTarget$_platfo = renderTarget._platformRenderTarget) === null || _renderTarget$_platfo === void 0 ? void 0 : _renderTarget$_platfo._activeRenderTarget();
      var width = renderTarget.width,
          height = renderTarget.height;
      this.viewport(0, 0, width, height);
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      var viewport = camera.viewport;
      var drawingBufferWidth = gl.drawingBufferWidth,
          drawingBufferHeight = gl.drawingBufferHeight;

      var _width = drawingBufferWidth * viewport.z;

      var _height = drawingBufferHeight * viewport.w;

      var x = viewport.x * drawingBufferWidth;
      var y = drawingBufferHeight - viewport.y * drawingBufferHeight - _height;
      this.viewport(x, y, _width, _height);
    }
  };

  _proto.destroy = function destroy() {};

  _proto.activeTexture = function activeTexture(textureID) {
    if (this._activeTextureID !== textureID) {
      this._gl.activeTexture(textureID);

      this._activeTextureID = textureID;
    }
  };

  _proto.bindTexture = function bindTexture(texture) {
    var index = this._activeTextureID - this._gl.TEXTURE0;

    if (this._activeTextures[index] !== texture) {
      this._gl.bindTexture(texture._target, texture._glTexture);

      this._activeTextures[index] = texture;
    }
  };

  _createClass(WebGLRenderer, [{
    key: "isWebGL2",
    get: // cache value
    function get() {
      return this._isWebGL2;
    }
    /**
     * GL Context
     * @member {WebGLRenderingContext}
     */

  }, {
    key: "gl",
    get: function get() {
      return this._gl;
    }
  }, {
    key: "renderStates",
    get: function get() {
      return this._renderStates;
    }
  }, {
    key: "capability",
    get: function get() {
      return this._capability;
    }
  }, {
    key: "canIUseMoreJoints",
    get: function get() {
      return this.capability.canIUseMoreJoints;
    }
  }]);

  return WebGLRenderer;
}();

/**
 * WebGL platform engine,support includes WebGL1.0 and WebGL2.0.
 */

var WebGLEngine = /*#__PURE__*/function (_Engine) {
  _inheritsLoose(WebGLEngine, _Engine);

  /**
   * Create an engine suitable for the WebGL platform.
   * @param canvas - Native web canvas
   * @param webGLRendererOptions - WebGL renderer options
   */
  function WebGLEngine(canvas, webGLRendererOptions) {
    var webCanvas = new WebCanvas(typeof canvas === "string" ? document.getElementById(canvas) : canvas);
    var hardwareRenderer = new WebGLRenderer(webGLRendererOptions);
    return _Engine.call(this, webCanvas, hardwareRenderer) || this;
  }
  /**
   * Web canvas.
   */


  _createClass(WebGLEngine, [{
    key: "canvas",
    get: function get() {
      return this._canvas;
    }
  }]);

  return WebGLEngine;
}(Engine);

export { GLCompressedTextureInternalFormat, WebCanvas, WebGLEngine, WebGLMode, WebGLRenderer };
//# sourceMappingURL=module.js.map
