{"version":3,"file":"module.js","sources":["../src/DRACOWorker.ts","../src/worker/worker.js","../src/decoder.ts"],"sourcesContent":["import { Logger } from \"@oasis-engine/core\";\n\nexport class DRACOWorker {\n  // Worker instance.\n  private _worker: Worker;\n  // Record byteLength of each task.\n  private _costs: { [taskId: number]: number } = {};\n  // The sum of bytelength that the worker is currently dealing with, in order to sort the workers.\n  private _currentLoad: number = 0;\n  private _callbacks: { [taskId: number]: IResolveReject } = {};\n  get currentLoad(): number {\n    return this._currentLoad;\n  }\n\n  constructor(workerSourceURL: string, decoderWASMBinary?: ArrayBuffer) {\n    this._worker = new Worker(workerSourceURL);\n    this._worker.onmessage = (e) => {\n      const message = e.data;\n      switch (message.type) {\n        case \"decode\":\n          this._callbacks[message.id].resolve(message.geometry);\n          break;\n\n        case \"error\":\n          this._callbacks[message.id].reject(message);\n          break;\n        default:\n          Logger.error('DRACOWorker: Unexpected message, \"' + message.type + '\"');\n      }\n    };\n    if (decoderWASMBinary) {\n      this._worker.postMessage({ type: \"init\", decoderConfig: { wasmBinary: decoderWASMBinary } });\n    } else {\n      this._worker.postMessage({ type: \"init\", decoderConfig: {} });\n    }\n  }\n\n  setCosts(taskId: number, cost: number) {\n    this._costs[taskId] = cost;\n  }\n\n  addCurrentLoad(cost: number) {\n    this._currentLoad += cost;\n  }\n\n  setCallback(taskId: number, resolve: (any) => void, reject: (any) => void) {\n    this._callbacks[taskId] = { resolve, reject };\n  }\n\n  decode(taskId: number, taskConfig: ITaskConfig, buffer: ArrayBuffer) {\n    this._worker.postMessage({ type: \"decode\", id: taskId, taskConfig, buffer }, [buffer]);\n  }\n\n  releaseTask(taskId: number) {\n    this._currentLoad -= this._costs[taskId];\n    delete this._callbacks[taskId];\n    delete this._costs[taskId];\n  }\n}\n\ninterface IResolveReject {\n  resolve: (any) => void;\n  reject: (any) => void;\n}\n\nexport interface ITaskConfig {\n  attributeIDs: { [attribute: string]: number };\n  attributeTypes: { [attribute: string]: string };\n  useUniqueIDs: boolean;\n  indexType: string;\n}\n","export default `let decoderPending;\nlet decoderConfig;\n\nonmessage = function(e) {\n  const message = e.data;\n\n  switch (message.type) {\n    case \"init\":\n      decoderConfig = message.decoderConfig;\n      decoderPending = new Promise(function(resolve /*, reject*/) {\n        decoderConfig.onModuleLoaded = function(draco) {\n          // Module is Promise-like. Wrap before resolving to avoid loop.\n          resolve({ draco: draco });\n        };\n        DracoDecoderModule(decoderConfig);\n      });\n      break;\n\n    case \"decode\":\n      const buffer = message.buffer;\n      const taskConfig = message.taskConfig;\n      decoderPending.then(module => {\n        const draco = module.draco;\n        const decoder = new draco.Decoder();\n        const decoderBuffer = new draco.DecoderBuffer();\n        decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n        try {\n          const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n          const buffers = geometry.attributes.map(attr => attr.array.buffer);\n          if (geometry.index) buffers.push(geometry.index.array.buffer);\n          self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n        } catch (error) {\n          console.error(error);\n          self.postMessage({ type: \"error\", id: message.id, error: error.message });\n        } finally {\n          draco.destroy(decoderBuffer);\n          draco.destroy(decoder);\n        }\n      });\n      break;\n  }\n};\n\nfunction decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n  const attributeIDs = taskConfig.attributeIDs;\n  const attributeTypes = taskConfig.attributeTypes;\n\n  let dracoGeometry;\n  let decodingStatus;\n\n  const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    dracoGeometry = new draco.Mesh();\n    decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n  } else {\n    throw new Error(\"DRACODecoder worker: Unexpected geometry type.\");\n  }\n\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new Error(\"DRACODecoder worker: Decoding failed: \" + decodingStatus.error_msg());\n  }\n\n  const geometry = { index: null, attributes: [] };\n\n  // Gather all vertex attributes.\n  for (let attributeName in attributeIDs) {\n    const attributeType = self[attributeTypes[attributeName]];\n\n    let attribute;\n    let attributeID;\n\n    // A Draco file may be created with default vertex attributes, whose attribute IDs\n    // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n    // a Draco file may contain a custom set of attributes, identified by known unique\n    // IDs. glTF files always do the latter, and .drc files typically do the former.\n    if (taskConfig.useUniqueIDs) {\n      attributeID = attributeIDs[attributeName];\n      attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n    } else {\n      attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n      if (attributeID === -1) continue;\n      attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n    }\n    geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n  }\n  // Add index.\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    // Generate mesh faces.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    let dataSize;\n    let ptr;\n    let index;\n    const indexType = self[taskConfig.indexType];\n\n    switch (indexType) {\n      case Uint16Array:\n        dataSize = numIndices * 2;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt16Array(dracoGeometry, dataSize, ptr);\n        index = new Uint16Array(draco.HEAPU16.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      case Uint32Array:\n        dataSize = numIndices * 4;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, dataSize, ptr);\n        index = new Uint32Array(draco.HEAPU32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      default:\n        throw new Error(\"DRACODecoder: Unexpected index type.\");\n    }\n    geometry.index = { array: index, itemSize: 1 };\n  }\n  draco.destroy(dracoGeometry);\n  return geometry;\n}\n\nfunction decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n  const numComponents = attribute.num_components();\n  const numPoints = dracoGeometry.num_points();\n  const numValues = numPoints * numComponents;\n  let ptr;\n  let array;\n  let dataSize;\n  switch (attributeType) {\n    case Float32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr);\n      array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT8, numValues, ptr);\n      array = new Int8Array(draco.HEAP8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr);\n      array = new Int16Array(draco.HEAP16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr);\n      array = new Int32Array(draco.HEAP32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr);\n      array = new Uint8Array(draco.HEAPU8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr);\n      array = new Uint16Array(draco.HEAPU16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr);\n      array = new Uint32Array(draco.HEAPU32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    default:\n      throw new Error(\"DRACODecoder: Unexpected attribute type.\");\n  }\n\n  return {\n    name: attributeName,\n    array: array,\n    itemSize: numComponents\n  };\n}\n`;","import { Logger, request } from \"@oasis-engine/core\";\n\nimport { DRACOWorker, ITaskConfig } from \"./DRACOWorker\";\n\nimport workerString from \"./worker/worker.js\";\n\nconst LIB_PATH = \"https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/\";\nconst JS_FILE = \"draco_decoder_gltf.js\";\n\nconst WASM_FILE = \"draco_decoder_gltf.r3bin\";\nconst WASM_WRAPPER_FILE = \"draco_wasm_wrapper_gltf.js\";\n\nexport class DRACODecoder {\n  private pool: DRACOWorker[] = [];\n  private workerLimit = Math.min(navigator.hardwareConcurrency || 4, 4);\n  private useJS: boolean;\n  private currentTaskId: number = 1;\n  private taskCache = new WeakMap();\n  private loadLibPromise: Promise<any>;\n\n  constructor(config: IDecoderConfig = { type: \"wasm\", workerLimit: 4 }) {\n    if (config.workerLimit > this.workerLimit) {\n      Logger.warn(\"DRACOWorkerPool: Can not initialize worker pool with limit:\" + config.workerLimit);\n    } else {\n      this.workerLimit = config.workerLimit ?? 4;\n    }\n    this.useJS = typeof WebAssembly !== \"object\" || config.type === \"js\";\n    this.loadLibPromise = this.preloadLib();\n  }\n\n  private preloadLib(): Promise<any> {\n    if (this.loadLibPromise) {\n      return this.loadLibPromise;\n    }\n\n    return new Promise((resolve, reject) => {\n      if (this.useJS) {\n        request(`${LIB_PATH}${JS_FILE}`, { type: \"text\" })\n          .then((jsSource) => {\n            const body = [jsSource, workerString].join(\"\\n\");\n            const workerSourceURL = URL.createObjectURL(new Blob([body]));\n            resolve({ workerSourceURL, decoderWASMBinary: null });\n          })\n          .catch((reason) => {\n            reject(reason);\n          });\n      } else {\n        Promise.all([\n          request(`${LIB_PATH}${WASM_WRAPPER_FILE}`, { type: \"text\" }),\n          request(`${LIB_PATH}${WASM_FILE}`, { type: \"arraybuffer\" })\n        ])\n          .then((resources) => {\n            const [wrapperSource, decoderWASMBinary] = resources;\n            const body = [wrapperSource, workerString].join(\"\\n\");\n            const workerSourceURL = URL.createObjectURL(new Blob([body]));\n            resolve({ workerSourceURL, decoderWASMBinary });\n          })\n          .catch((reason) => {\n            reject(reason);\n          });\n      }\n    });\n  }\n\n  private getWorker(): Promise<DRACOWorker> {\n    return this.preloadLib().then((worderResources) => {\n      if (this.pool.length < this.workerLimit) {\n        const dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);\n        this.pool.push(dracoWorker);\n      } else {\n        this.pool.sort(function (a, b) {\n          return a.currentLoad > b.currentLoad ? -1 : 1;\n        });\n      }\n      return this.pool[this.pool.length - 1];\n    });\n  }\n\n  decode(buffer: ArrayBuffer, taskConfig: ITaskConfig): Promise<any> {\n    const taskKey = JSON.stringify(taskConfig);\n\n    // Check for an existing task using this buffer. A transferred buffer cannot be transferred.\n    // again from this thread.\n    if (this.taskCache.has(buffer)) {\n      const cachedTask = this.taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        // After using transferable to transfer data, the data in the original environment will be cleared, so it is judged that byteLength is 0, which means it has been transferred.\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error(\n          \"DRACODecoder: Unable to re-decode a buffer with different \" +\n            \"settings. Buffer has already been transferred.\"\n        );\n      }\n    }\n\n    const taskId = this.currentTaskId++;\n    const cost = buffer.byteLength;\n    let taskWorker;\n    const task = new Promise((resolve, reject) => {\n      this.getWorker()\n        .then((worker) => {\n          taskWorker = worker;\n          worker.setCosts(taskId, cost);\n          worker.addCurrentLoad(cost);\n\n          worker.setCallback(taskId, resolve, reject);\n          worker.decode(taskId, taskConfig, buffer);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n    task.finally(() => {\n      if (taskWorker && taskId) {\n        taskWorker.releaseTask(taskId);\n      }\n    });\n\n    this.taskCache.set(buffer, {\n      key: taskKey,\n      promise: task\n    });\n    return task;\n  }\n}\n\ninterface IDecoderConfig {\n  type?: \"js\" | \"wasm\";\n  workerLimit?: number;\n}\n"],"names":["DRACOWorker","workerSourceURL","decoderWASMBinary","_worker","_costs","_currentLoad","_callbacks","Worker","onmessage","e","message","data","type","id","resolve","geometry","reject","Logger","error","postMessage","decoderConfig","wasmBinary","setCosts","taskId","cost","addCurrentLoad","setCallback","decode","taskConfig","buffer","releaseTask","LIB_PATH","JS_FILE","WASM_FILE","WASM_WRAPPER_FILE","DRACODecoder","config","workerLimit","pool","Math","min","navigator","hardwareConcurrency","useJS","currentTaskId","taskCache","WeakMap","loadLibPromise","warn","WebAssembly","preloadLib","Promise","request","then","jsSource","body","workerString","join","URL","createObjectURL","Blob","catch","reason","all","resources","wrapperSource","getWorker","worderResources","length","dracoWorker","push","sort","a","b","currentLoad","taskKey","JSON","stringify","has","cachedTask","get","key","promise","byteLength","Error","taskWorker","task","worker","finally","set"],"mappings":"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"}