{"version":3,"file":"editor.esm.js","sources":["../src/spine-core/Utils.ts","../src/spine-core/BoneData.ts","../src/spine-core/PathConstraintData.ts","../src/spine-core/Bone.ts","../src/spine-core/Slot.ts","../src/spine-core/IkConstraint.ts","../src/spine-core/TransformConstraint.ts","../src/spine-core/ConstraintData.ts","../src/spine-core/attachments/Attachment.ts","../src/spine-core/attachments/PathAttachment.ts","../src/spine-core/PathConstraint.ts","../src/spine-core/attachments/RegionAttachment.ts","../src/spine-core/Texture.ts","../src/spine-core/Animation.ts","../src/spine-core/TextureAtlas.ts","../src/spine-core/attachments/MeshAttachment.ts","../src/spine-core/Skeleton.ts","../src/spine-core/AnimationState.ts","../src/spine-core/AnimationStateData.ts","../src/spine-core/attachments/ClippingAttachment.ts","../src/spine-core/Triangulator.ts","../src/spine-core/SkeletonClipping.ts","../src/core/SpineMesh.ts","../src/core/MeshGenerator.ts","../src/spine-core/BlendMode.ts","../src/SpineAnimation.ts","../src/editor/SpineComponent.ts","../src/editor/SpineResource.ts","../src/spine-core/AssetManager.ts","../src/spine-core/attachments/BoundingBoxAttachment.ts","../src/spine-core/attachments/PointAttachment.ts","../src/spine-core/AtlasAttachmentLoader.ts","../src/spine-core/SkeletonData.ts","../src/spine-core/SlotData.ts","../src/spine-core/IkConstraintData.ts","../src/spine-core/TransformConstraintData.ts","../src/spine-core/Skin.ts","../src/spine-core/EventData.ts","../src/spine-core/attachments/AttachmentType.ts","../src/spine-core/Event.ts","../src/spine-core/SkeletonJson.ts","../src/spine-core/SkeletonBinary.ts","../src/SpineLoader.ts","../src/editor/index.ts"],"sourcesContent":["\r\n\r\nimport { MixBlend } from \"./Animation\";\r\nimport { Skeleton } from \"./Skeleton\";\r\n\r\n\r\nexport interface Map<T> {\r\n\t[key: string]: T;\r\n}\r\n\r\nexport class IntSet {\r\n\tarray = new Array<number>();\r\n\r\n\tadd (value: number): boolean {\r\n\t\tlet contains = this.contains(value);\r\n\t\tthis.array[value | 0] = value | 0;\r\n\t\treturn !contains;\r\n\t}\r\n\r\n\tcontains (value: number) {\r\n\t\treturn this.array[value | 0] != undefined;\r\n\t}\r\n\r\n\tremove (value: number) {\r\n\t\tthis.array[value | 0] = undefined;\r\n\t}\r\n\r\n\tclear () {\r\n\t\tthis.array.length = 0;\r\n\t}\r\n}\r\n\r\nexport interface Disposable {\r\n\tdispose (): void;\r\n}\r\n\r\nexport interface Restorable {\r\n\trestore (): void;\r\n}\r\n\r\nexport class Color {\r\n\tpublic static WHITE = new Color(1, 1, 1, 1);\r\n\tpublic static RED = new Color(1, 0, 0, 1);\r\n\tpublic static GREEN = new Color(0, 1, 0, 1);\r\n\tpublic static BLUE = new Color(0, 0, 1, 1);\r\n\tpublic static MAGENTA = new Color(1, 0, 1, 1);\r\n\r\n\tconstructor (public r: number = 0, public g: number = 0, public b: number = 0, public a: number = 0) {\r\n\t}\r\n\r\n\tset (r: number, g: number, b: number, a: number) {\r\n\t\tthis.r = r;\r\n\t\tthis.g = g;\r\n\t\tthis.b = b;\r\n\t\tthis.a = a;\r\n\t\tthis.clamp();\r\n\t\treturn this;\r\n\t}\r\n\r\n\tsetFromColor (c: Color) {\r\n\t\tthis.r = c.r;\r\n\t\tthis.g = c.g;\r\n\t\tthis.b = c.b;\r\n\t\tthis.a = c.a;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tsetFromString (hex: string) {\r\n\t\thex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\r\n\t\tthis.r = parseInt(hex.substr(0, 2), 16) / 255.0;\r\n\t\tthis.g = parseInt(hex.substr(2, 2), 16) / 255.0;\r\n\t\tthis.b = parseInt(hex.substr(4, 2), 16) / 255.0;\r\n\t\tthis.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tadd (r: number, g: number, b: number, a: number) {\r\n\t\tthis.r += r;\r\n\t\tthis.g += g;\r\n\t\tthis.b += b;\r\n\t\tthis.a += a;\r\n\t\tthis.clamp();\r\n\t\treturn this;\r\n\t}\r\n\r\n\tclamp () {\r\n\t\tif (this.r < 0) this.r = 0;\r\n\t\telse if (this.r > 1) this.r = 1;\r\n\r\n\t\tif (this.g < 0) this.g = 0;\r\n\t\telse if (this.g > 1) this.g = 1;\r\n\r\n\t\tif (this.b < 0) this.b = 0;\r\n\t\telse if (this.b > 1) this.b = 1;\r\n\r\n\t\tif (this.a < 0) this.a = 0;\r\n\t\telse if (this.a > 1) this.a = 1;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tstatic rgba8888ToColor(color: Color, value: number) {\r\n\t\tcolor.r = ((value & 0xff000000) >>> 24) / 255;\r\n\t\tcolor.g = ((value & 0x00ff0000) >>> 16) / 255;\r\n\t\tcolor.b = ((value & 0x0000ff00) >>> 8) / 255;\r\n\t\tcolor.a = ((value & 0x000000ff)) / 255;\r\n\t}\r\n\r\n\tstatic rgb888ToColor (color: Color, value: number) {\r\n\t\tcolor.r = ((value & 0x00ff0000) >>> 16) / 255;\r\n\t\tcolor.g = ((value & 0x0000ff00) >>> 8) / 255;\r\n\t\tcolor.b = ((value & 0x000000ff)) / 255;\r\n\t}\r\n}\r\n\r\nexport class MathUtils {\r\n\tstatic PI = 3.1415927;\r\n\tstatic PI2 = MathUtils.PI * 2;\r\n\tstatic radiansToDegrees = 180 / MathUtils.PI;\r\n\tstatic radDeg = MathUtils.radiansToDegrees;\r\n\tstatic degreesToRadians = MathUtils.PI / 180;\r\n\tstatic degRad = MathUtils.degreesToRadians;\r\n\r\n\tstatic clamp (value: number, min: number, max: number) {\r\n\t\tif (value < min) return min;\r\n\t\tif (value > max) return max;\r\n\t\treturn value;\r\n\t}\r\n\r\n\tstatic cosDeg (degrees: number) {\r\n\t\treturn Math.cos(degrees * MathUtils.degRad);\r\n\t}\r\n\r\n\tstatic sinDeg (degrees: number) {\r\n\t\treturn Math.sin(degrees * MathUtils.degRad);\r\n\t}\r\n\r\n\tstatic signum (value: number): number {\r\n\t\treturn value > 0 ? 1 : value < 0 ? -1 : 0;\r\n\t}\r\n\r\n\tstatic toInt (x: number) {\r\n\t\treturn x > 0 ? Math.floor(x) : Math.ceil(x);\r\n\t}\r\n\r\n\tstatic cbrt (x: number) {\r\n\t\tlet y = Math.pow(Math.abs(x), 1/3);\r\n\t\treturn x < 0 ? -y : y;\r\n\t}\r\n\r\n\tstatic randomTriangular (min: number, max: number): number {\r\n\t\treturn MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\r\n\t}\r\n\r\n\tstatic randomTriangularWith (min: number, max: number, mode: number): number {\r\n\t\tlet u = Math.random();\r\n\t\tlet d = max - min;\r\n\t\tif (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));\r\n\t\treturn max - Math.sqrt((1 - u) * d * (max - mode));\r\n\t}\r\n}\r\n\r\nexport abstract class Interpolation {\r\n\tprotected abstract applyInternal (a: number): number;\r\n\tapply(start: number, end: number, a: number): number {\r\n\t\treturn start + (end - start) * this.applyInternal(a);\r\n\t}\r\n}\r\n\r\nexport class Pow extends Interpolation {\r\n\tprotected power = 2;\r\n\r\n\tconstructor (power: number) {\r\n\t\tsuper();\r\n\t\tthis.power = power;\r\n\t}\r\n\r\n\tapplyInternal (a: number): number {\r\n\t\tif (a <= 0.5) return Math.pow(a * 2, this.power) / 2;\r\n\t\treturn Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\r\n\t}\r\n}\r\n\r\nexport class PowOut extends Pow {\r\n\tconstructor (power: number) {\r\n\t\tsuper(power);\r\n\t}\r\n\r\n\tapplyInternal (a: number) : number {\r\n\t\treturn Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\r\n\t}\r\n}\r\n\r\nexport class Utils {\r\n\tstatic SUPPORTS_TYPED_ARRAYS = typeof(Float32Array) !== \"undefined\";\r\n\r\n\tstatic arrayCopy<T> (source: ArrayLike<T>, sourceStart: number, dest: ArrayLike<T>, destStart: number, numElements: number) {\r\n\t\tfor (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\r\n\t\t\tdest[j] = source[i];\r\n\t\t}\r\n\t}\r\n\r\n\tstatic setArraySize<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\r\n\t\tlet oldSize = array.length;\r\n\t\tif (oldSize == size) return array;\r\n\t\tarray.length = size;\r\n\t\tif (oldSize < size) {\r\n\t\t\tfor (let i = oldSize; i < size; i++) array[i] = value;\r\n\t\t}\r\n\t\treturn array;\r\n\t}\r\n\r\n\tstatic ensureArrayCapacity<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\r\n\t\tif (array.length >= size) return array;\r\n\t\treturn Utils.setArraySize(array, size, value);\r\n\t}\r\n\r\n\tstatic newArray<T> (size: number, defaultValue: T): Array<T> {\r\n\t\tlet array = new Array<T>(size);\r\n\t\tfor (let i = 0; i < size; i++) array[i] = defaultValue;\r\n\t\treturn array;\r\n\t}\r\n\r\n\tstatic newFloatArray (size: number): ArrayLike<number> {\r\n\t\tif (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n\t\t\treturn new Float32Array(size)\r\n\t\t} else {\r\n\t\t\t\tlet array = new Array<number>(size);\r\n\t\t\t\tfor (let i = 0; i < array.length; i++) array[i] = 0;\r\n\t\t\t\treturn array;\r\n\t\t}\r\n\t}\r\n\r\n\tstatic newShortArray (size: number): ArrayLike<number> {\r\n\t\tif (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n\t\t\treturn new Int16Array(size)\r\n\t\t} else {\r\n\t\t\t\tlet array = new Array<number>(size);\r\n\t\t\t\tfor (let i = 0; i < array.length; i++) array[i] = 0;\r\n\t\t\t\treturn array;\r\n\t\t}\r\n\t}\r\n\r\n\tstatic toFloatArray (array: Array<number>) {\r\n\t\treturn Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\r\n\t}\r\n\r\n\tstatic toSinglePrecision (value: number) {\r\n\t\treturn Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\r\n\t}\r\n\r\n\t// This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n\tstatic webkit602BugfixHelper (alpha: number, blend: MixBlend) {\r\n\r\n\t}\r\n\r\n\tstatic contains<T> (array: Array<T>, element: T, identity = true) {\r\n\t\tfor (var i = 0; i < array.length; i++) {\r\n\t\t\tif (array[i] == element) return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nexport class DebugUtils {\r\n\tstatic logBones(skeleton: Skeleton) {\r\n\t\tfor (let i = 0; i < skeleton.bones.length; i++) {\r\n\t\t\tlet bone = skeleton.bones[i];\r\n\t\t\tconsole.log(bone.data.name + \", \" + bone.a + \", \" + bone.b + \", \" + bone.c + \", \" + bone.d + \", \" + bone.worldX + \", \" + bone.worldY);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport class Pool<T> {\r\n\tprivate items = new Array<T>();\r\n\tprivate instantiator: () => T;\r\n\r\n\tconstructor (instantiator: () => T) {\r\n\t\tthis.instantiator = instantiator;\r\n\t}\r\n\r\n\tobtain () {\r\n\t\treturn this.items.length > 0 ? this.items.pop() : this.instantiator();\r\n\t}\r\n\r\n\tfree (item: T) {\r\n\t\tif ((item as any).reset) (item as any).reset();\r\n\t\tthis.items.push(item);\r\n\t}\r\n\r\n\tfreeAll (items: ArrayLike<T>) {\r\n\t\tfor (let i = 0; i < items.length; i++) {\r\n\t\t\tthis.free(items[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tclear () {\r\n\t\tthis.items.length = 0;\r\n\t}\r\n}\r\n\r\nexport class Vector2 {\r\n\tconstructor (public x = 0, public y = 0) {\r\n\t}\r\n\r\n\tset (x: number, y: number): Vector2 {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tlength () {\r\n\t\tlet x = this.x;\r\n\t\tlet y = this.y;\r\n\t\treturn Math.sqrt(x * x + y * y);\r\n\t}\r\n\r\n\tnormalize () {\r\n\t\tlet len = this.length();\r\n\t\tif (len != 0) {\r\n\t\t\tthis.x /= len;\r\n\t\t\tthis.y /= len;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n}\r\n\r\nexport class TimeKeeper {\r\n\tmaxDelta = 0.064;\r\n\tframesPerSecond = 0;\r\n\tdelta = 0;\r\n\ttotalTime = 0;\r\n\r\n\tprivate lastTime = Date.now() / 1000;\r\n\tprivate frameCount = 0;\r\n\tprivate frameTime = 0;\r\n\r\n\tupdate () {\r\n\t\tlet now = Date.now() / 1000;\r\n\t\tthis.delta = now - this.lastTime;\r\n\t\tthis.frameTime += this.delta;\r\n\t\tthis.totalTime += this.delta;\r\n\t\tif (this.delta > this.maxDelta) this.delta = this.maxDelta;\r\n\t\tthis.lastTime = now;\r\n\r\n\t\tthis.frameCount++;\r\n\t\tif (this.frameTime > 1) {\r\n\t\t\tthis.framesPerSecond = this.frameCount / this.frameTime;\r\n\t\t\tthis.frameTime = 0;\r\n\t\t\tthis.frameCount = 0;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport interface ArrayLike<T> {\r\n\tlength: number;\r\n\t[n: number]: T;\r\n}\r\n\r\nexport class WindowedMean {\r\n\tvalues: Array<number>;\r\n\taddedValues = 0;\r\n\tlastValue = 0;\r\n\tmean = 0;\r\n\tdirty = true;\r\n\r\n\tconstructor (windowSize: number = 32) {\r\n\t\tthis.values = new Array<number>(windowSize);\r\n\t}\r\n\r\n\thasEnoughData () {\r\n\t\treturn this.addedValues >= this.values.length;\r\n\t}\r\n\r\n\taddValue (value: number) {\r\n\t\tif (this.addedValues < this.values.length)\r\n\t\t\tthis.addedValues++;\r\n\t\tthis.values[this.lastValue++] = value;\r\n\t\tif (this.lastValue > this.values.length - 1) this.lastValue = 0;\r\n\t\tthis.dirty = true;\r\n\t}\r\n\r\n\tgetMean () {\r\n\t\tif (this.hasEnoughData()) {\r\n\t\t\tif (this.dirty) {\r\n\t\t\t\tlet mean = 0;\r\n\t\t\t\tfor (let i = 0; i < this.values.length; i++) {\r\n\t\t\t\t\tmean += this.values[i];\r\n\t\t\t\t}\r\n\t\t\t\tthis.mean = mean / this.values.length;\r\n\t\t\t\tthis.dirty = false;\r\n\t\t\t}\r\n\t\t\treturn this.mean;\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n}\r\n","\r\n\r\nimport { Color } from \"./Utils\";\r\n\r\n\r\n\r\n\t/** Stores the setup pose for a {@link Bone}. */\r\n\texport class BoneData {\r\n\t\t/** The index of the bone in {@link Skeleton#getBones()}. */\r\n\t\tindex: number;\r\n\r\n\t\t/** The name of the bone, which is unique across all bones in the skeleton. */\r\n\t\tname: string;\r\n\r\n\t\t/** @returns May be null. */\r\n\t\tparent: BoneData;\r\n\r\n\t\t/** The bone's length. */\r\n\t\tlength: number;\r\n\r\n\t\t/** The local x translation. */\r\n\t\tx = 0;\r\n\r\n\t\t/** The local y translation. */\r\n\t\ty = 0;\r\n\r\n\t\t/** The local rotation. */\r\n\t\trotation = 0;\r\n\r\n\t\t/** The local scaleX. */\r\n\t\tscaleX = 1;\r\n\r\n\t\t/** The local scaleY. */\r\n\t\tscaleY = 1;\r\n\r\n\t\t/** The local shearX. */\r\n\t\tshearX = 0;\r\n\r\n\t\t/** The local shearX. */\r\n\t\tshearY = 0;\r\n\r\n\t\t/** The transform mode for how parent world transforms affect this bone. */\r\n\t\ttransformMode = TransformMode.Normal;\r\n\r\n\t\t/** When true, {@link Skeleton#updateWorldTransform()} only updates this bone if the {@link Skeleton#skin} contains this\r\n\t \t* bone.\r\n\t \t* @see Skin#bones */\r\n\t\tskinRequired = false;\r\n\r\n\t\t/** The color of the bone as it was in Spine. Available only when nonessential data was exported. Bones are not usually\r\n\t\t * rendered at runtime. */\r\n\t\tcolor = new Color();\r\n\r\n\t\tconstructor (index: number, name: string, parent: BoneData) {\r\n\t\t\tif (index < 0) throw new Error(\"index must be >= 0.\");\r\n\t\t\tif (name == null) throw new Error(\"name cannot be null.\");\r\n\t\t\tthis.index = index;\r\n\t\t\tthis.name = name;\r\n\t\t\tthis.parent = parent;\r\n\t\t}\r\n\t}\r\n\r\n\t/** Determines how a bone inherits world transforms from parent bones. */\r\n\texport enum TransformMode {\r\n\t\tNormal, OnlyTranslation, NoRotationOrReflection, NoScale, NoScaleOrReflection\r\n\t}\r\n","\r\n\r\nimport { ConstraintData } from \"./ConstraintData\";\r\nimport { BoneData } from \"./BoneData\";\r\nimport { SlotData } from \"./SlotData\";\r\n\r\n\r\n\r\n\t/** Stores the setup pose for a {@link PathConstraint}.\r\n\t *\r\n\t * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide. */\r\n\texport class PathConstraintData extends ConstraintData {\r\n\r\n\t\t/** The bones that will be modified by this path constraint. */\r\n\t\tbones = new Array<BoneData>();\r\n\r\n\t\t/** The slot whose path attachment will be used to constrained the bones. */\r\n\t\ttarget: SlotData;\r\n\r\n\t\t/** The mode for positioning the first bone on the path. */\r\n\t\tpositionMode: PositionMode;\r\n\r\n\t\t/** The mode for positioning the bones after the first bone on the path. */\r\n\t\tspacingMode: SpacingMode;\r\n\r\n\t\t/** The mode for adjusting the rotation of the bones. */\r\n\t\trotateMode: RotateMode;\r\n\r\n\t\t/** An offset added to the constrained bone rotation. */\r\n\t\toffsetRotation: number;\r\n\r\n\t\t/** The position along the path. */\r\n\t\tposition: number;\r\n\r\n\t\t/** The spacing between bones. */\r\n\t\tspacing: number;\r\n\r\n\t\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\r\n\t\trotateMix: number;\r\n\r\n\t\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained translations. */\r\n\t\ttranslateMix: number;\r\n\r\n\t\tconstructor (name: string) {\r\n\t\t\tsuper(name, 0, false);\r\n\t\t}\r\n\t}\r\n\r\n\t/** Controls how the first bone is positioned along the path.\r\n\t *\r\n\t * See [Position mode](http://esotericsoftware.com/spine-path-constraints#Position-mode) in the Spine User Guide. */\r\n\texport enum PositionMode {\r\n\t\tFixed, Percent\r\n\t}\r\n\r\n\t/** Controls how bones after the first bone are positioned along the path.\r\n\t *\r\n\t * [Spacing mode](http://esotericsoftware.com/spine-path-constraints#Spacing-mode) in the Spine User Guide. */\r\n\texport enum SpacingMode {\r\n\t\tLength, Fixed, Percent\r\n\t}\r\n\r\n\t/** Controls how bones are rotated, translated, and scaled to match the path.\r\n\t *\r\n\t * [Rotate mode](http://esotericsoftware.com/spine-path-constraints#Rotate-mod) in the Spine User Guide. */\r\n\texport enum RotateMode {\r\n\t\tTangent, Chain, ChainScale\r\n\t}\r\n","\r\n\r\nimport { Updatable } from \"./Updatable\";\r\nimport { BoneData, TransformMode } from \"./BoneData\";\r\nimport { Skeleton } from \"./Skeleton\";\r\nimport { MathUtils, Vector2 } from \"./Utils\";\r\n\r\n\r\n/** Stores a bone's current pose.\r\n *\r\n * A bone has a local transform which is used to compute its world transform. A bone also has an applied transform, which is a\r\n * local transform that can be applied to compute the world transform. The local transform and applied transform may differ if a\r\n * constraint or application code modifies the world transform after it was computed from the local transform. */\r\nexport class Bone implements Updatable {\r\n\t/** The bone's setup pose data. */\r\n\tdata: BoneData;\r\n\r\n\t/** The skeleton this bone belongs to. */\r\n\tskeleton: Skeleton;\r\n\r\n\t/** The parent bone, or null if this is the root bone. */\r\n\tparent: Bone;\r\n\r\n\t/** The immediate children of this bone. */\r\n\tchildren = new Array<Bone>();\r\n\r\n\t/** The local x translation. */\r\n\tx = 0;\r\n\r\n\t/** The local y translation. */\r\n\ty = 0;\r\n\r\n\t/** The local rotation in degrees, counter clockwise. */\r\n\trotation = 0;\r\n\r\n\t/** The local scaleX. */\r\n\tscaleX = 0;\r\n\r\n\t/** The local scaleY. */\r\n\tscaleY = 0;\r\n\r\n\t/** The local shearX. */\r\n\tshearX = 0;\r\n\r\n\t/** The local shearY. */\r\n\tshearY = 0;\r\n\r\n\t/** The applied local x translation. */\r\n\tax = 0;\r\n\r\n\t/** The applied local y translation. */\r\n\tay = 0;\r\n\r\n\t/** The applied local rotation in degrees, counter clockwise. */\r\n\tarotation = 0;\r\n\r\n\t/** The applied local scaleX. */\r\n\tascaleX = 0;\r\n\r\n\t/** The applied local scaleY. */\r\n\tascaleY = 0;\r\n\r\n\t/** The applied local shearX. */\r\n\tashearX = 0;\r\n\r\n\t/** The applied local shearY. */\r\n\tashearY = 0;\r\n\r\n\t/** If true, the applied transform matches the world transform. If false, the world transform has been modified since it was\r\n\t* computed and {@link #updateAppliedTransform()} must be called before accessing the applied transform. */\r\n\tappliedValid = false;\r\n\r\n\t/** Part of the world transform matrix for the X axis. If changed, {@link #appliedValid} should be set to false. */\r\n\ta = 0;\r\n\r\n\t/** Part of the world transform matrix for the Y axis. If changed, {@link #appliedValid} should be set to false. */\r\n\tb = 0;\r\n\r\n\t/** Part of the world transform matrix for the X axis. If changed, {@link #appliedValid} should be set to false. */\r\n\tc = 0;\r\n\r\n\t/** Part of the world transform matrix for the Y axis. If changed, {@link #appliedValid} should be set to false. */\r\n\td = 0;\r\n\r\n\t/** The world X position. If changed, {@link #appliedValid} should be set to false. */\r\n\tworldY = 0;\r\n\r\n\t/** The world Y position. If changed, {@link #appliedValid} should be set to false. */\r\n\tworldX = 0;\r\n\r\n\tsorted = false;\r\n\tactive = false;\r\n\r\n\t/** @param parent May be null. */\r\n\tconstructor (data: BoneData, skeleton: Skeleton, parent: Bone) {\r\n\t\tif (data == null) throw new Error(\"data cannot be null.\");\r\n\t\tif (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n\t\tthis.data = data;\r\n\t\tthis.skeleton = skeleton;\r\n\t\tthis.parent = parent;\r\n\t\tthis.setToSetupPose();\r\n\t}\r\n\r\n\t/** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the\r\n\t* {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */\r\n\tisActive () {\r\n\t\treturn this.active;\r\n\t}\r\n\r\n\t/** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\r\n\tupdate () {\r\n\t\tthis.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n\t}\r\n\r\n\t/** Computes the world transform using the parent bone and this bone's local transform.\r\n\t *\r\n\t * See {@link #updateWorldTransformWith()}. */\r\n\tupdateWorldTransform () {\r\n\t\tthis.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n\t}\r\n\r\n\t/** Computes the world transform using the parent bone and the specified local transform. Child bones are not updated.\r\n\t *\r\n\t * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n\t * Runtimes Guide. */\r\n\tupdateWorldTransformWith (x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\r\n\t\tthis.ax = x;\r\n\t\tthis.ay = y;\r\n\t\tthis.arotation = rotation;\r\n\t\tthis.ascaleX = scaleX;\r\n\t\tthis.ascaleY = scaleY;\r\n\t\tthis.ashearX = shearX;\r\n\t\tthis.ashearY = shearY;\r\n\t\tthis.appliedValid = true;\r\n\r\n\t\tlet parent = this.parent;\r\n\t\tif (parent == null) { // Root bone.\r\n\t\t\tlet skeleton = this.skeleton;\r\n\t\t\tlet rotationY = rotation + 90 + shearY;\r\n\t\t\tlet sx = skeleton.scaleX;\r\n\t\t\tlet sy = skeleton.scaleY;\r\n\t\t\tthis.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\r\n\t\t\tthis.b = MathUtils.cosDeg(rotationY) * scaleY * sx;\r\n\t\t\tthis.c = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\r\n\t\t\tthis.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\r\n\t\t\tthis.worldX = x * sx + skeleton.x;\r\n\t\t\tthis.worldY = y * sy + skeleton.y;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\r\n\t\tthis.worldX = pa * x + pb * y + parent.worldX;\r\n\t\tthis.worldY = pc * x + pd * y + parent.worldY;\r\n\r\n\t\tswitch (this.data.transformMode) {\r\n\t\tcase TransformMode.Normal: {\r\n\t\t\tlet rotationY = rotation + 90 + shearY;\r\n\t\t\tlet la = MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n\t\t\tlet lb = MathUtils.cosDeg(rotationY) * scaleY;\r\n\t\t\tlet lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n\t\t\tlet ld = MathUtils.sinDeg(rotationY) * scaleY;\r\n\t\t\tthis.a = pa * la + pb * lc;\r\n\t\t\tthis.b = pa * lb + pb * ld;\r\n\t\t\tthis.c = pc * la + pd * lc;\r\n\t\t\tthis.d = pc * lb + pd * ld;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tcase TransformMode.OnlyTranslation: {\r\n\t\t\tlet rotationY = rotation + 90 + shearY;\r\n\t\t\tthis.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n\t\t\tthis.b = MathUtils.cosDeg(rotationY) * scaleY;\r\n\t\t\tthis.c = MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n\t\t\tthis.d = MathUtils.sinDeg(rotationY) * scaleY;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase TransformMode.NoRotationOrReflection: {\r\n\t\t\tlet s = pa * pa + pc * pc;\r\n\t\t\tlet prx = 0;\r\n\t\t\tif (s > 0.0001) {\r\n\t\t\t\ts = Math.abs(pa * pd - pb * pc) / s;\r\n\t\t\t\tpa /= this.skeleton.scaleX;\r\n\t\t\t\tpc /= this.skeleton.scaleY;\r\n\t\t\t\tpb = pc * s;\r\n\t\t\t\tpd = pa * s;\r\n\t\t\t\tprx = Math.atan2(pc, pa) * MathUtils.radDeg;\r\n\t\t\t} else {\r\n\t\t\t\tpa = 0;\r\n\t\t\t\tpc = 0;\r\n\t\t\t\tprx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\r\n\t\t\t}\r\n\t\t\tlet rx = rotation + shearX - prx;\r\n\t\t\tlet ry = rotation + shearY - prx + 90;\r\n\t\t\tlet la = MathUtils.cosDeg(rx) * scaleX;\r\n\t\t\tlet lb = MathUtils.cosDeg(ry) * scaleY;\r\n\t\t\tlet lc = MathUtils.sinDeg(rx) * scaleX;\r\n\t\t\tlet ld = MathUtils.sinDeg(ry) * scaleY;\r\n\t\t\tthis.a = pa * la - pb * lc;\r\n\t\t\tthis.b = pa * lb - pb * ld;\r\n\t\t\tthis.c = pc * la + pd * lc;\r\n\t\t\tthis.d = pc * lb + pd * ld;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase TransformMode.NoScale:\r\n\t\tcase TransformMode.NoScaleOrReflection: {\r\n\t\t\tlet cos = MathUtils.cosDeg(rotation);\r\n\t\t\tlet sin = MathUtils.sinDeg(rotation);\r\n\t\t\tlet za = (pa * cos + pb * sin) / this.skeleton.scaleX;\r\n\t\t\tlet zc = (pc * cos + pd * sin) / this.skeleton.scaleY;\r\n\t\t\tlet s = Math.sqrt(za * za + zc * zc);\r\n\t\t\tif (s > 0.00001) s = 1 / s;\r\n\t\t\tza *= s;\r\n\t\t\tzc *= s;\r\n\t\t\ts = Math.sqrt(za * za + zc * zc);\r\n\t\t\tif (this.data.transformMode == TransformMode.NoScale\r\n\t\t\t\t&& (pa * pd - pb * pc < 0) != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0)) s = -s;\r\n\t\t\tlet r = Math.PI / 2 + Math.atan2(zc, za);\r\n\t\t\tlet zb = Math.cos(r) * s;\r\n\t\t\tlet zd = Math.sin(r) * s;\r\n\t\t\tlet la = MathUtils.cosDeg(shearX) * scaleX;\r\n\t\t\tlet lb = MathUtils.cosDeg(90 + shearY) * scaleY;\r\n\t\t\tlet lc = MathUtils.sinDeg(shearX) * scaleX;\r\n\t\t\tlet ld = MathUtils.sinDeg(90 + shearY) * scaleY;\r\n\t\t\tthis.a = za * la + zb * lc;\r\n\t\t\tthis.b = za * lb + zb * ld;\r\n\t\t\tthis.c = zc * la + zd * lc;\r\n\t\t\tthis.d = zc * lb + zd * ld;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t}\r\n\t\tthis.a *= this.skeleton.scaleX;\r\n\t\tthis.b *= this.skeleton.scaleX;\r\n\t\tthis.c *= this.skeleton.scaleY;\r\n\t\tthis.d *= this.skeleton.scaleY;\r\n\t}\r\n\r\n\t/** Sets this bone's local transform to the setup pose. */\r\n\tsetToSetupPose () {\r\n\t\tlet data = this.data;\r\n\t\tthis.x = data.x;\r\n\t\tthis.y = data.y;\r\n\t\tthis.rotation = data.rotation;\r\n\t\tthis.scaleX = data.scaleX;\r\n\t\tthis.scaleY = data.scaleY;\r\n\t\tthis.shearX = data.shearX;\r\n\t\tthis.shearY = data.shearY;\r\n\t}\r\n\r\n\t/** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */\r\n\tgetWorldRotationX () {\r\n\t\treturn Math.atan2(this.c, this.a) * MathUtils.radDeg;\r\n\t}\r\n\r\n\t/** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */\r\n\tgetWorldRotationY () {\r\n\t\treturn Math.atan2(this.d, this.b) * MathUtils.radDeg;\r\n\t}\r\n\r\n\t/** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */\r\n\tgetWorldScaleX () {\r\n\t\treturn Math.sqrt(this.a * this.a + this.c * this.c);\r\n\t}\r\n\r\n\t/** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */\r\n\tgetWorldScaleY () {\r\n\t\treturn Math.sqrt(this.b * this.b + this.d * this.d);\r\n\t}\r\n\r\n\t/** Computes the applied transform values from the world transform. This allows the applied transform to be accessed after the\r\n\t * world transform has been modified (by a constraint, {@link #rotateWorld()}, etc).\r\n\t *\r\n\t * If {@link #updateWorldTransform()} has been called for a bone and {@link #appliedValid} is false, then\r\n\t * {@link #updateAppliedTransform()} must be called before accessing the applied transform.\r\n\t *\r\n\t * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after\r\n\t * calling this method is equivalent to the local tranform used to compute the world transform, but may not be identical. */\r\n\tupdateAppliedTransform () {\r\n\t\tthis.appliedValid = true;\r\n\t\tlet parent = this.parent;\r\n\t\tif (parent == null) {\r\n\t\t\tthis.ax = this.worldX;\r\n\t\t\tthis.ay = this.worldY;\r\n\t\t\tthis.arotation = Math.atan2(this.c, this.a) * MathUtils.radDeg;\r\n\t\t\tthis.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);\r\n\t\t\tthis.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);\r\n\t\t\tthis.ashearX = 0;\r\n\t\t\tthis.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * MathUtils.radDeg;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\r\n\t\tlet pid = 1 / (pa * pd - pb * pc);\r\n\t\tlet dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;\r\n\t\tthis.ax = (dx * pd * pid - dy * pb * pid);\r\n\t\tthis.ay = (dy * pa * pid - dx * pc * pid);\r\n\t\tlet ia = pid * pd;\r\n\t\tlet id = pid * pa;\r\n\t\tlet ib = pid * pb;\r\n\t\tlet ic = pid * pc;\r\n\t\tlet ra = ia * this.a - ib * this.c;\r\n\t\tlet rb = ia * this.b - ib * this.d;\r\n\t\tlet rc = id * this.c - ic * this.a;\r\n\t\tlet rd = id * this.d - ic * this.b;\r\n\t\tthis.ashearX = 0;\r\n\t\tthis.ascaleX = Math.sqrt(ra * ra + rc * rc);\r\n\t\tif (this.ascaleX > 0.0001) {\r\n\t\t\tlet det = ra * rd - rb * rc;\r\n\t\t\tthis.ascaleY = det / this.ascaleX;\r\n\t\t\tthis.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\r\n\t\t\tthis.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\r\n\t\t} else {\r\n\t\t\tthis.ascaleX = 0;\r\n\t\t\tthis.ascaleY = Math.sqrt(rb * rb + rd * rd);\r\n\t\t\tthis.ashearY = 0;\r\n\t\t\tthis.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\r\n\t\t}\r\n\t}\r\n\r\n\t/** Transforms a point from world coordinates to the bone's local coordinates. */\r\n\tworldToLocal (world: Vector2) {\r\n\t\tlet a = this.a, b = this.b, c = this.c, d = this.d;\r\n\t\tlet invDet = 1 / (a * d - b * c);\r\n\t\tlet x = world.x - this.worldX, y = world.y - this.worldY;\r\n\t\tworld.x = (x * d * invDet - y * b * invDet);\r\n\t\tworld.y = (y * a * invDet - x * c * invDet);\r\n\t\treturn world;\r\n\t}\r\n\r\n\t/** Transforms a point from the bone's local coordinates to world coordinates. */\r\n\tlocalToWorld (local: Vector2) {\r\n\t\tlet x = local.x, y = local.y;\r\n\t\tlocal.x = x * this.a + y * this.b + this.worldX;\r\n\t\tlocal.y = x * this.c + y * this.d + this.worldY;\r\n\t\treturn local;\r\n\t}\r\n\r\n\t/** Transforms a world rotation to a local rotation. */\r\n\tworldToLocalRotation (worldRotation: number) {\r\n\t\tlet sin = MathUtils.sinDeg(worldRotation), cos = MathUtils.cosDeg(worldRotation);\r\n\t\treturn Math.atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * MathUtils.radDeg + this.rotation - this.shearX;\r\n\t}\r\n\r\n\t/** Transforms a local rotation to a world rotation. */\r\n\tlocalToWorldRotation (localRotation: number) {\r\n\t\tlocalRotation -= this.rotation - this.shearX;\r\n\t\tlet sin = MathUtils.sinDeg(localRotation), cos = MathUtils.cosDeg(localRotation);\r\n\t\treturn Math.atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * MathUtils.radDeg;\r\n\t}\r\n\r\n\t/** Rotates the world transform the specified amount and sets {@link #appliedValid} to false.\r\n\t * {@link #updateWorldTransform()} will need to be called on any child bones, recursively, and any constraints reapplied. */\r\n\trotateWorld (degrees: number) {\r\n\t\tlet a = this.a, b = this.b, c = this.c, d = this.d;\r\n\t\tlet cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);\r\n\t\tthis.a = cos * a - sin * c;\r\n\t\tthis.b = cos * b - sin * d;\r\n\t\tthis.c = sin * a + cos * c;\r\n\t\tthis.d = sin * b + cos * d;\r\n\t\tthis.appliedValid = false;\r\n\t}\r\n}\r\n","\r\n\r\nimport { SlotData } from \"./SlotData\";\r\nimport { Bone } from \"./Bone\";\r\nimport { Color } from \"./Utils\";\r\nimport { Attachment } from \"./attachments/Attachment\";\r\nimport { Skeleton } from \"./Skeleton\";\r\n\r\n\r\n\r\n/** Stores a slot's current pose. Slots organize attachments for {@link Skeleton#drawOrder} purposes and provide a place to store\r\n * state for an attachment. State cannot be stored in an attachment itself because attachments are stateless and may be shared\r\n * across multiple skeletons. */\r\nexport class Slot {\r\n\t/** The slot's setup pose data. */\r\n\tdata: SlotData;\r\n\r\n\t/** The bone this slot belongs to. */\r\n\tbone: Bone;\r\n\r\n\t/** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\r\n\t * color tinting. */\r\n\tcolor: Color;\r\n\r\n\t/** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\r\n\t * color's alpha is not used. */\r\n\tdarkColor: Color;\r\n\r\n\tattachment: Attachment;\r\n\r\n\tprivate attachmentTime: number;\r\n\r\n\tattachmentState: number;\r\n\r\n\t/** Values to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a\r\n\t * weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.\r\n\t *\r\n\t * See {@link VertexAttachment#computeWorldVertices()} and {@link DeformTimeline}. */\r\n\tdeform = new Array<number>();\r\n\r\n\tconstructor (data: SlotData, bone: Bone) {\r\n\t\tif (data == null) throw new Error(\"data cannot be null.\");\r\n\t\tif (bone == null) throw new Error(\"bone cannot be null.\");\r\n\t\tthis.data = data;\r\n\t\tthis.bone = bone;\r\n\t\tthis.color = new Color();\r\n\t\tthis.darkColor = data.darkColor == null ? null : new Color();\r\n\t\tthis.setToSetupPose();\r\n\t}\r\n\r\n\t/** The skeleton this slot belongs to. */\r\n\tgetSkeleton (): Skeleton {\r\n\t\treturn this.bone.skeleton;\r\n\t}\r\n\r\n\t/** The current attachment for the slot, or null if the slot has no attachment. */\r\n\tgetAttachment (): Attachment {\r\n\t\treturn this.attachment;\r\n\t}\r\n\r\n\t/** Sets the slot's attachment and, if the attachment changed, resets {@link #attachmentTime} and clears {@link #deform}.\r\n\t * @param attachment May be null. */\r\n\tsetAttachment (attachment: Attachment) {\r\n\t\tif (this.attachment == attachment) return;\r\n\t\tthis.attachment = attachment;\r\n\t\tthis.attachmentTime = this.bone.skeleton.time;\r\n\t\tthis.deform.length = 0;\r\n\t}\r\n\r\n\tsetAttachmentTime (time: number) {\r\n\t\tthis.attachmentTime = this.bone.skeleton.time - time;\r\n\t}\r\n\r\n\t/** The time that has elapsed since the last time the attachment was set or cleared. Relies on Skeleton\r\n\t * {@link Skeleton#time}. */\r\n\tgetAttachmentTime (): number {\r\n\t\treturn this.bone.skeleton.time - this.attachmentTime;\r\n\t}\r\n\r\n\t/** Sets this slot to the setup pose. */\r\n\tsetToSetupPose () {\r\n\t\tthis.color.setFromColor(this.data.color);\r\n\t\tif (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\r\n\t\tif (this.data.attachmentName == null)\r\n\t\t\tthis.attachment = null;\r\n\t\telse {\r\n\t\t\tthis.attachment = null;\r\n\t\t\tthis.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\r\n\t\t}\r\n\t}\r\n}\r\n","\r\n\r\nimport { Updatable } from \"./Updatable\";\r\nimport { IkConstraintData } from \"./IkConstraintData\";\r\nimport { Bone } from \"./Bone\";\r\nimport { Skeleton } from \"./Skeleton\";\r\nimport { TransformMode } from \"./BoneData\";\r\nimport { MathUtils } from \"./Utils\";\r\n\r\n\r\n\r\n\t/** Stores the current pose for an IK constraint. An IK constraint adjusts the rotation of 1 or 2 constrained bones so the tip of\r\n\t * the last bone is as close to the target bone as possible.\r\n\t *\r\n\t * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide. */\r\n\texport class IkConstraint implements Updatable {\r\n\t\t/** The IK constraint's setup pose data. */\r\n\t\tdata: IkConstraintData;\r\n\r\n\t\t/** The bones that will be modified by this IK constraint. */\r\n\t\tbones: Array<Bone>;\r\n\r\n\t\t/** The bone that is the IK target. */\r\n\t\ttarget: Bone;\r\n\r\n\t\t/** Controls the bend direction of the IK bones, either 1 or -1. */\r\n\t\tbendDirection = 0;\r\n\r\n\t\t/** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\r\n\t\tcompress = false;\r\n\r\n\t\t/** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\r\n\t\t * and the parent bone has local nonuniform scale, stretch is not applied. */\r\n\t\tstretch = false;\r\n\r\n\t\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\r\n\t\tmix = 1;\r\n\r\n\t\t/** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\r\n\t\tsoftness = 0;\r\n\t\tactive = false;\r\n\r\n\t\tconstructor (data: IkConstraintData, skeleton: Skeleton) {\r\n\t\t\tif (data == null) throw new Error(\"data cannot be null.\");\r\n\t\t\tif (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.mix = data.mix;\r\n\t\t\tthis.softness = data.softness;\r\n\t\t\tthis.bendDirection = data.bendDirection;\r\n\t\t\tthis.compress = data.compress;\r\n\t\t\tthis.stretch = data.stretch;\r\n\r\n\t\t\tthis.bones = new Array<Bone>();\r\n\t\t\tfor (let i = 0; i < data.bones.length; i++)\r\n\t\t\t\tthis.bones.push(skeleton.findBone(data.bones[i].name));\r\n\t\t\tthis.target = skeleton.findBone(data.target.name);\r\n\t\t}\r\n\r\n\t\tisActive () {\r\n\t\t\treturn this.active;\r\n\t\t}\r\n\r\n\t\t/** Applies the constraint to the constrained bones. */\r\n\t\tapply () {\r\n\t\t\tthis.update();\r\n\t\t}\r\n\r\n\t\tupdate () {\r\n\t\t\tlet target = this.target;\r\n\t\t\tlet bones = this.bones;\r\n\t\t\tswitch (bones.length) {\r\n\t\t\tcase 1:\r\n\t\t\t\tthis.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tthis.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/** Applies 1 bone IK. The target is specified in the world coordinate system. */\r\n\t\tapply1 (bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number) {\r\n\t\t\tif (!bone.appliedValid) bone.updateAppliedTransform();\r\n\t\t\tlet p = bone.parent;\r\n\r\n\t\t\tlet pa = p.a, pb = p.b, pc = p.c, pd = p.d;\r\n\t\t\tlet rotationIK = -bone.ashearX - bone.arotation, tx = 0, ty = 0;\r\n\r\n\t\t\tswitch(bone.data.transformMode) {\r\n\t\t\t\tcase TransformMode.OnlyTranslation:\r\n\t\t\t\t\ttx = targetX - bone.worldX;\r\n\t\t\t\t\tty = targetY - bone.worldY;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase TransformMode.NoRotationOrReflection:\r\n\t\t\t\t\tlet s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\r\n\t\t\t\t\tlet sa = pa / bone.skeleton.scaleX;\r\n\t\t\t\t\tlet sc = pc / bone.skeleton.scaleY;\r\n\t\t\t\t\tpb = -sc * s * bone.skeleton.scaleX;\r\n\t\t\t\t\tpd = sa * s * bone.skeleton.scaleY;\r\n\t\t\t\t\trotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\r\n\t\t\t\t\t// Fall through\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tlet x = targetX - p.worldX, y = targetY - p.worldY;\r\n\t\t\t\t\tlet d = pa * pd - pb * pc;\r\n\t\t\t\t\ttx = (x * pd - y * pb) / d - bone.ax;\r\n\t\t\t\t\tty = (y * pa - x * pc) / d - bone.ay;\r\n\t\t\t}\r\n\t\t\trotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\r\n\t\t\tif (bone.ascaleX < 0) rotationIK += 180;\r\n\t\t\tif (rotationIK > 180)\r\n\t\t\t\trotationIK -= 360;\r\n\t\t\telse if (rotationIK < -180) rotationIK += 360;\r\n\t\t\tlet sx = bone.ascaleX, sy = bone.ascaleY;\r\n\t\t\tif (compress || stretch) {\r\n\t\t\t\tswitch (bone.data.transformMode) {\r\n\t\t\t\t\tcase TransformMode.NoScale:\r\n\t\t\t\t\tcase TransformMode.NoScaleOrReflection:\r\n\t\t\t\t\t\ttx = targetX - bone.worldX;\r\n\t\t\t\t\t\tty = targetY - bone.worldY;\r\n\t\t\t\t}\r\n\t\t\t\tlet b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty);\r\n\t\t\t\tif ((compress && dd < b) || (stretch && dd > b) && b > 0.0001) {\r\n\t\t\t\t\tlet s = (dd / b - 1) * alpha + 1;\r\n\t\t\t\t\tsx *= s;\r\n\t\t\t\t\tif (uniform) sy *= s;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX,\r\n\t\t\t\tbone.ashearY);\r\n\t\t}\r\n\r\n\t\t/** Applies 2 bone IK. The target is specified in the world coordinate system.\r\n\t\t * @param child A direct descendant of the parent bone. */\r\n\t\tapply2 (parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, softness: number, alpha: number) {\r\n\t\t\tif (alpha == 0) {\r\n\t\t\t\tchild.updateWorldTransform();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (!parent.appliedValid) parent.updateAppliedTransform();\r\n\t\t\tif (!child.appliedValid) child.updateAppliedTransform();\r\n\t\t\tlet px = parent.ax, py = parent.ay, psx = parent.ascaleX, sx = psx, psy = parent.ascaleY, csx = child.ascaleX;\r\n\t\t\tlet os1 = 0, os2 = 0, s2 = 0;\r\n\t\t\tif (psx < 0) {\r\n\t\t\t\tpsx = -psx;\r\n\t\t\t\tos1 = 180;\r\n\t\t\t\ts2 = -1;\r\n\t\t\t} else {\r\n\t\t\t\tos1 = 0;\r\n\t\t\t\ts2 = 1;\r\n\t\t\t}\r\n\t\t\tif (psy < 0) {\r\n\t\t\t\tpsy = -psy;\r\n\t\t\t\ts2 = -s2;\r\n\t\t\t}\r\n\t\t\tif (csx < 0) {\r\n\t\t\t\tcsx = -csx;\r\n\t\t\t\tos2 = 180;\r\n\t\t\t} else\r\n\t\t\t\tos2 = 0;\r\n\t\t\tlet cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = parent.a, b = parent.b, c = parent.c, d = parent.d;\r\n\t\t\tlet u = Math.abs(psx - psy) <= 0.0001;\r\n\t\t\tif (!u) {\r\n\t\t\t\tcy = 0;\r\n\t\t\t\tcwx = a * cx + parent.worldX;\r\n\t\t\t\tcwy = c * cx + parent.worldY;\r\n\t\t\t} else {\r\n\t\t\t\tcy = child.ay;\r\n\t\t\t\tcwx = a * cx + b * cy + parent.worldX;\r\n\t\t\t\tcwy = c * cx + d * cy + parent.worldY;\r\n\t\t\t}\r\n\t\t\tlet pp = parent.parent;\r\n\t\t\ta = pp.a;\r\n\t\t\tb = pp.b;\r\n\t\t\tc = pp.c;\r\n\t\t\td = pp.d;\r\n\t\t\tlet id = 1 / (a * d - b * c), x = cwx - pp.worldX, y = cwy - pp.worldY;\r\n\t\t\tlet dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\r\n\t\t\tlet l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\r\n\t\t\tif (l1 < 0.0001) {\r\n\t\t\t\tthis.apply1(parent, targetX, targetY, false, stretch, false, alpha);\r\n\t\t\t\tchild.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tx = targetX - pp.worldX;\r\n\t\t\ty = targetY - pp.worldY;\r\n\t\t\tlet tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\r\n\t\t\tlet dd = tx * tx + ty * ty;\r\n\t\t\tif (softness != 0) {\r\n\t\t\t\tsoftness *= psx * (csx + 1) / 2;\r\n\t\t\t\tlet td = Math.sqrt(dd), sd = td - l1 - l2 * psx + softness;\r\n\t\t\t\tif (sd > 0) {\r\n\t\t\t\t\tlet p = Math.min(1, sd / (softness * 2)) - 1;\r\n\t\t\t\t\tp = (sd - softness * (1 - p * p)) / td;\r\n\t\t\t\t\ttx -= p * tx;\r\n\t\t\t\t\tty -= p * ty;\r\n\t\t\t\t\tdd = tx * tx + ty * ty;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\touter:\r\n\t\t\tif (u) {\r\n\t\t\t\tl2 *= psx;\r\n\t\t\t\tlet cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n\t\t\t\tif (cos < -1)\r\n\t\t\t\t\tcos = -1;\r\n\t\t\t\telse if (cos > 1) {\r\n\t\t\t\t\tcos = 1;\r\n\t\t\t\t\tif (stretch) sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\r\n\t\t\t\t}\r\n\t\t\t\ta2 = Math.acos(cos) * bendDir;\r\n\t\t\t\ta = l1 + l2 * cos;\r\n\t\t\t\tb = l2 * Math.sin(a2);\r\n\t\t\t\ta1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\r\n\t\t\t} else {\r\n\t\t\t\ta = psx * l2;\r\n\t\t\t\tb = psy * l2;\r\n\t\t\t\tlet aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);\r\n\t\t\t\tc = bb * l1 * l1 + aa * dd - aa * bb;\r\n\t\t\t\tlet c1 = -2 * bb * l1, c2 = bb - aa;\r\n\t\t\t\td = c1 * c1 - 4 * c2 * c;\r\n\t\t\t\tif (d >= 0) {\r\n\t\t\t\t\tlet q = Math.sqrt(d);\r\n\t\t\t\t\tif (c1 < 0) q = -q;\r\n\t\t\t\t\tq = -(c1 + q) / 2;\r\n\t\t\t\t\tlet r0 = q / c2, r1 = c / q;\r\n\t\t\t\t\tlet r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n\t\t\t\t\tif (r * r <= dd) {\r\n\t\t\t\t\t\ty = Math.sqrt(dd - r * r) * bendDir;\r\n\t\t\t\t\t\ta1 = ta - Math.atan2(y, r);\r\n\t\t\t\t\t\ta2 = Math.atan2(y / psy, (r - l1) / psx);\r\n\t\t\t\t\t\tbreak outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tlet minAngle = MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\r\n\t\t\t\tlet maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\r\n\t\t\t\tc = -a * l1 / (aa - bb);\r\n\t\t\t\tif (c >= -1 && c <= 1) {\r\n\t\t\t\t\tc = Math.acos(c);\r\n\t\t\t\t\tx = a * Math.cos(c) + l1;\r\n\t\t\t\t\ty = b * Math.sin(c);\r\n\t\t\t\t\td = x * x + y * y;\r\n\t\t\t\t\tif (d < minDist) {\r\n\t\t\t\t\t\tminAngle = c;\r\n\t\t\t\t\t\tminDist = d;\r\n\t\t\t\t\t\tminX = x;\r\n\t\t\t\t\t\tminY = y;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (d > maxDist) {\r\n\t\t\t\t\t\tmaxAngle = c;\r\n\t\t\t\t\t\tmaxDist = d;\r\n\t\t\t\t\t\tmaxX = x;\r\n\t\t\t\t\t\tmaxY = y;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (dd <= (minDist + maxDist) / 2) {\r\n\t\t\t\t\ta1 = ta - Math.atan2(minY * bendDir, minX);\r\n\t\t\t\t\ta2 = minAngle * bendDir;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ta1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n\t\t\t\t\ta2 = maxAngle * bendDir;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlet os = Math.atan2(cy, cx) * s2;\r\n\t\t\tlet rotation = parent.arotation;\r\n\t\t\ta1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\r\n\t\t\tif (a1 > 180)\r\n\t\t\t\ta1 -= 360;\r\n\t\t\telse if (a1 < -180) a1 += 360;\r\n\t\t\tparent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\r\n\t\t\trotation = child.arotation;\r\n\t\t\ta2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\r\n\t\t\tif (a2 > 180)\r\n\t\t\t\ta2 -= 360;\r\n\t\t\telse if (a2 < -180) a2 += 360;\r\n\t\t\tchild.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n\t\t}\r\n\t}\r\n","\r\n\r\nimport { Updatable } from \"./Updatable\";\r\nimport { TransformConstraintData } from \"./TransformConstraintData\";\r\nimport { Bone } from \"./Bone\";\r\nimport { Skeleton } from \"./Skeleton\";\r\nimport { MathUtils, Vector2 } from \"./Utils\";\r\n\r\n\r\n\r\n/** Stores the current pose for a transform constraint. A transform constraint adjusts the world transform of the constrained\r\n * bones to match that of the target bone.\r\n *\r\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide. */\r\nexport class TransformConstraint implements Updatable {\r\n\r\n\t/** The transform constraint's setup pose data. */\r\n\tdata: TransformConstraintData;\r\n\r\n\t/** The bones that will be modified by this transform constraint. */\r\n\tbones: Array<Bone>;\r\n\r\n\t/** The target bone whose world transform will be copied to the constrained bones. */\r\n\ttarget: Bone;\r\n\r\n\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\r\n\trotateMix = 0;\r\n\r\n\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained translations. */\r\n\ttranslateMix = 0;\r\n\r\n\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained scales. */\r\n\tscaleMix = 0;\r\n\r\n\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained scales. */\r\n\tshearMix = 0;\r\n\r\n\ttemp = new Vector2();\r\n\tactive = false;\r\n\r\n\tconstructor (data: TransformConstraintData, skeleton: Skeleton) {\r\n\t\tif (data == null) throw new Error(\"data cannot be null.\");\r\n\t\tif (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n\t\tthis.data = data;\r\n\t\tthis.rotateMix = data.rotateMix;\r\n\t\tthis.translateMix = data.translateMix;\r\n\t\tthis.scaleMix = data.scaleMix;\r\n\t\tthis.shearMix = data.shearMix;\r\n\t\tthis.bones = new Array<Bone>();\r\n\t\tfor (let i = 0; i < data.bones.length; i++)\r\n\t\t\tthis.bones.push(skeleton.findBone(data.bones[i].name));\r\n\t\tthis.target = skeleton.findBone(data.target.name);\r\n\t}\r\n\r\n\tisActive () {\r\n\t\treturn this.active;\r\n\t}\r\n\r\n\t/** Applies the constraint to the constrained bones. */\r\n\tapply () {\r\n\t\tthis.update();\r\n\t}\r\n\r\n\tupdate () {\r\n\t\tif (this.data.local) {\r\n\t\t\tif (this.data.relative)\r\n\t\t\t\tthis.applyRelativeLocal();\r\n\t\t\telse\r\n\t\t\t\tthis.applyAbsoluteLocal();\r\n\r\n\t\t} else {\r\n\t\t\tif (this.data.relative)\r\n\t\t\t\tthis.applyRelativeWorld();\r\n\t\t\telse\r\n\t\t\t\tthis.applyAbsoluteWorld();\r\n\t\t}\r\n\t}\r\n\r\n\tapplyAbsoluteWorld () {\r\n\t\tlet rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n\t\tlet target = this.target;\r\n\t\tlet ta = target.a, tb = target.b, tc = target.c, td = target.d;\r\n\t\tlet degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n\t\tlet offsetRotation = this.data.offsetRotation * degRadReflect;\r\n\t\tlet offsetShearY = this.data.offsetShearY * degRadReflect;\r\n\t\tlet bones = this.bones;\r\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\r\n\t\t\tlet bone = bones[i];\r\n\t\t\tlet modified = false;\r\n\r\n\t\t\tif (rotateMix != 0) {\r\n\t\t\t\tlet a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n\t\t\t\tlet r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\r\n\t\t\t\tif (r > MathUtils.PI)\r\n\t\t\t\t\tr -= MathUtils.PI2;\r\n\t\t\t\telse if (r < -MathUtils.PI)\r\n\t\t\t\t\tr += MathUtils.PI2;\r\n\t\t\t\tr *= rotateMix;\r\n\t\t\t\tlet cos = Math.cos(r), sin = Math.sin(r);\r\n\t\t\t\tbone.a = cos * a - sin * c;\r\n\t\t\t\tbone.b = cos * b - sin * d;\r\n\t\t\t\tbone.c = sin * a + cos * c;\r\n\t\t\t\tbone.d = sin * b + cos * d;\r\n\t\t\t\tmodified = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (translateMix != 0) {\r\n\t\t\t\tlet temp = this.temp;\r\n\t\t\t\ttarget.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n\t\t\t\tbone.worldX += (temp.x - bone.worldX) * translateMix;\r\n\t\t\t\tbone.worldY += (temp.y - bone.worldY) * translateMix;\r\n\t\t\t\tmodified = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (scaleMix > 0) {\r\n\t\t\t\tlet s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);\r\n\t\t\t\tlet ts = Math.sqrt(ta * ta + tc * tc);\r\n\t\t\t\tif (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\r\n\t\t\t\tbone.a *= s;\r\n\t\t\t\tbone.c *= s;\r\n\t\t\t\ts = Math.sqrt(bone.b * bone.b + bone.d * bone.d);\r\n\t\t\t\tts = Math.sqrt(tb * tb + td * td);\r\n\t\t\t\tif (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\r\n\t\t\t\tbone.b *= s;\r\n\t\t\t\tbone.d *= s;\r\n\t\t\t\tmodified = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (shearMix > 0) {\r\n\t\t\t\tlet b = bone.b, d = bone.d;\r\n\t\t\t\tlet by = Math.atan2(d, b);\r\n\t\t\t\tlet r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(bone.c, bone.a));\r\n\t\t\t\tif (r > MathUtils.PI)\r\n\t\t\t\t\tr -= MathUtils.PI2;\r\n\t\t\t\telse if (r < -MathUtils.PI)\r\n\t\t\t\t\tr += MathUtils.PI2;\r\n\t\t\t\tr = by + (r + offsetShearY) * shearMix;\r\n\t\t\t\tlet s = Math.sqrt(b * b + d * d);\r\n\t\t\t\tbone.b = Math.cos(r) * s;\r\n\t\t\t\tbone.d = Math.sin(r) * s;\r\n\t\t\t\tmodified = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (modified) bone.appliedValid = false;\r\n\t\t}\r\n\t}\r\n\r\n\tapplyRelativeWorld () {\r\n\t\tlet rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n\t\tlet target = this.target;\r\n\t\tlet ta = target.a, tb = target.b, tc = target.c, td = target.d;\r\n\t\tlet degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n\t\tlet offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;\r\n\t\tlet bones = this.bones;\r\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\r\n\t\t\tlet bone = bones[i];\r\n\t\t\tlet modified = false;\r\n\r\n\t\t\tif (rotateMix != 0) {\r\n\t\t\t\tlet a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n\t\t\t\tlet r = Math.atan2(tc, ta) + offsetRotation;\r\n\t\t\t\tif (r > MathUtils.PI)\r\n\t\t\t\t\tr -= MathUtils.PI2;\r\n\t\t\t\telse if (r < -MathUtils.PI) r += MathUtils.PI2;\r\n\t\t\t\tr *= rotateMix;\r\n\t\t\t\tlet cos = Math.cos(r), sin = Math.sin(r);\r\n\t\t\t\tbone.a = cos * a - sin * c;\r\n\t\t\t\tbone.b = cos * b - sin * d;\r\n\t\t\t\tbone.c = sin * a + cos * c;\r\n\t\t\t\tbone.d = sin * b + cos * d;\r\n\t\t\t\tmodified = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (translateMix != 0) {\r\n\t\t\t\tlet temp = this.temp;\r\n\t\t\t\ttarget.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n\t\t\t\tbone.worldX += temp.x * translateMix;\r\n\t\t\t\tbone.worldY += temp.y * translateMix;\r\n\t\t\t\tmodified = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (scaleMix > 0) {\r\n\t\t\t\tlet s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\r\n\t\t\t\tbone.a *= s;\r\n\t\t\t\tbone.c *= s;\r\n\t\t\t\ts = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\r\n\t\t\t\tbone.b *= s;\r\n\t\t\t\tbone.d *= s;\r\n\t\t\t\tmodified = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (shearMix > 0) {\r\n\t\t\t\tlet r = Math.atan2(td, tb) - Math.atan2(tc, ta);\r\n\t\t\t\tif (r > MathUtils.PI)\r\n\t\t\t\t\tr -= MathUtils.PI2;\r\n\t\t\t\telse if (r < -MathUtils.PI) r += MathUtils.PI2;\r\n\t\t\t\tlet b = bone.b, d = bone.d;\r\n\t\t\t\tr = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;\r\n\t\t\t\tlet s = Math.sqrt(b * b + d * d);\r\n\t\t\t\tbone.b = Math.cos(r) * s;\r\n\t\t\t\tbone.d = Math.sin(r) * s;\r\n\t\t\t\tmodified = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (modified) bone.appliedValid = false;\r\n\t\t}\r\n\t}\r\n\r\n\tapplyAbsoluteLocal () {\r\n\t\tlet rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n\t\tlet target = this.target;\r\n\t\tif (!target.appliedValid) target.updateAppliedTransform();\r\n\t\tlet bones = this.bones;\r\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\r\n\t\t\tlet bone = bones[i];\r\n\t\t\tif (!bone.appliedValid) bone.updateAppliedTransform();\r\n\r\n\t\t\tlet rotation = bone.arotation;\r\n\t\t\tif (rotateMix != 0) {\r\n\t\t\t\tlet r = target.arotation - rotation + this.data.offsetRotation;\r\n\t\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n\t\t\t\trotation += r * rotateMix;\r\n\t\t\t}\r\n\r\n\t\t\tlet x = bone.ax, y = bone.ay;\r\n\t\t\tif (translateMix != 0) {\r\n\t\t\t\tx += (target.ax - x + this.data.offsetX) * translateMix;\r\n\t\t\t\ty += (target.ay - y + this.data.offsetY) * translateMix;\r\n\t\t\t}\r\n\r\n\t\t\tlet scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n\t\t\tif (scaleMix != 0) {\r\n\t\t\t\tif (scaleX > 0.00001) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\r\n\t\t\t\tif (scaleY > 0.00001) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\r\n\t\t\t}\r\n\r\n\t\t\tlet shearY = bone.ashearY;\r\n\t\t\tif (shearMix != 0) {\r\n\t\t\t\tlet r = target.ashearY - shearY + this.data.offsetShearY;\r\n\t\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n\t\t\t\tbone.shearY += r * shearMix;\r\n\t\t\t}\r\n\r\n\t\t\tbone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n\t\t}\r\n\t}\r\n\r\n\tapplyRelativeLocal () {\r\n\t\tlet rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n\t\tlet target = this.target;\r\n\t\tif (!target.appliedValid) target.updateAppliedTransform();\r\n\t\tlet bones = this.bones;\r\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\r\n\t\t\tlet bone = bones[i];\r\n\t\t\tif (!bone.appliedValid) bone.updateAppliedTransform();\r\n\r\n\t\t\tlet rotation = bone.arotation;\r\n\t\t\tif (rotateMix != 0) rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\r\n\r\n\t\t\tlet x = bone.ax, y = bone.ay;\r\n\t\t\tif (translateMix != 0) {\r\n\t\t\t\tx += (target.ax + this.data.offsetX) * translateMix;\r\n\t\t\t\ty += (target.ay + this.data.offsetY) * translateMix;\r\n\t\t\t}\r\n\r\n\t\t\tlet scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n\t\t\tif (scaleMix != 0) {\r\n\t\t\t\tif (scaleX > 0.00001) scaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;\r\n\t\t\t\tif (scaleY > 0.00001) scaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;\r\n\t\t\t}\r\n\r\n\t\t\tlet shearY = bone.ashearY;\r\n\t\t\tif (shearMix != 0) shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\r\n\r\n\t\t\tbone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n\t\t}\r\n\t}\r\n}\r\n","\n\n\n\t/** The base class for all constraint datas. */\n\texport abstract class ConstraintData {\n\t\tconstructor(public name: string, public order: number, public skinRequired: boolean) { }\n\t}\n","\r\n\r\nimport { Slot } from \"../Slot\";\r\nimport { Utils, ArrayLike } from \"../Utils\";\r\n\r\n/** The base class for all attachments. */\r\nexport abstract class Attachment {\r\n\tname: string;\r\n\r\n\tconstructor (name: string) {\r\n\t\tif (name == null) throw new Error(\"name cannot be null.\");\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\tabstract copy (): Attachment;\r\n}\r\n\r\n/** Base class for an attachment with vertices that are transformed by one or more bones and can be deformed by a slot's\r\n * {@link Slot#deform}. */\r\nexport abstract class VertexAttachment extends Attachment {\r\n\tprivate static nextID = 0;\r\n\r\n\t/** The unique ID for this attachment. */\r\n\tid = (VertexAttachment.nextID++ & 65535) << 11;\r\n\r\n\t/** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting\r\n\t * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null\r\n\t * if this attachment has no weights. */\r\n\tbones: Array<number>;\r\n\r\n\t/** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`\r\n\t * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting\r\n\t * each vertex. */\r\n\tvertices: ArrayLike<number>;\r\n\r\n\t/** The maximum number of world vertex values that can be output by\r\n\t * {@link #computeWorldVertices()} using the `count` parameter. */\r\n\tworldVerticesLength = 0;\r\n\r\n\t/** Deform keys for the deform attachment are also applied to this attachment. May be null if no deform keys should be applied. */\r\n\tdeformAttachment: VertexAttachment = this;\r\n\r\n\tconstructor (name: string) {\r\n\t\tsuper(name);\r\n\t}\r\n\r\n\t/** Transforms the attachment's local {@link vertices} to world coordinates. If the slot's {@link Slot#deform} is\r\n\t * not empty, it is used to deform the vertices.\r\n\t *\r\n\t * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n\t * Runtimes Guide.\r\n\t * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.\r\n\t * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.\r\n\t * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *\r\n\t *           `stride` / 2.\r\n\t * @param offset The `worldVertices` index to begin writing values.\r\n\t * @param stride The number of `worldVertices` entries between the value pairs written. */\r\n\tcomputeWorldVertices (slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number) {\r\n\t\tcount = offset + (count >> 1) * stride;\r\n\t\tlet skeleton = slot.bone.skeleton;\r\n\t\tlet deformArray = slot.deform;\r\n\t\tlet vertices = this.vertices;\r\n\t\tlet bones = this.bones;\r\n\t\tif (bones == null) {\r\n\t\t\tif (deformArray.length > 0) vertices = deformArray;\r\n\t\t\tlet bone = slot.bone;\r\n\t\t\tlet x = bone.worldX;\r\n\t\t\tlet y = bone.worldY;\r\n\t\t\tlet a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n\t\t\tfor (let v = start, w = offset; w < count; v += 2, w += stride) {\r\n\t\t\t\tlet vx = vertices[v], vy = vertices[v + 1];\r\n\t\t\t\tworldVertices[w] = vx * a + vy * b + x;\r\n\t\t\t\tworldVertices[w + 1] = vx * c + vy * d + y;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet v = 0, skip = 0;\r\n\t\tfor (let i = 0; i < start; i += 2) {\r\n\t\t\tlet n = bones[v];\r\n\t\t\tv += n + 1;\r\n\t\t\tskip += n;\r\n\t\t}\r\n\t\tlet skeletonBones = skeleton.bones;\r\n\t\tif (deformArray.length == 0) {\r\n\t\t\tfor (let w = offset, b = skip * 3; w < count; w += stride) {\r\n\t\t\t\tlet wx = 0, wy = 0;\r\n\t\t\t\tlet n = bones[v++];\r\n\t\t\t\tn += v;\r\n\t\t\t\tfor (; v < n; v++, b += 3) {\r\n\t\t\t\t\tlet bone = skeletonBones[bones[v]];\r\n\t\t\t\t\tlet vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\r\n\t\t\t\t\twx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\r\n\t\t\t\t\twy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\r\n\t\t\t\t}\r\n\t\t\t\tworldVertices[w] = wx;\r\n\t\t\t\tworldVertices[w + 1] = wy;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlet deform = deformArray;\r\n\t\t\tfor (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\r\n\t\t\t\tlet wx = 0, wy = 0;\r\n\t\t\t\tlet n = bones[v++];\r\n\t\t\t\tn += v;\r\n\t\t\t\tfor (; v < n; v++, b += 3, f += 2) {\r\n\t\t\t\t\tlet bone = skeletonBones[bones[v]];\r\n\t\t\t\t\tlet vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\r\n\t\t\t\t\twx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\r\n\t\t\t\t\twy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\r\n\t\t\t\t}\r\n\t\t\t\tworldVertices[w] = wx;\r\n\t\t\t\tworldVertices[w + 1] = wy;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/** Does not copy id (generated) or name (set on construction). **/\r\n\tcopyTo (attachment: VertexAttachment) {\r\n\t\tif (this.bones != null) {\r\n\t\t\tattachment.bones = new Array<number>(this.bones.length);\r\n\t\t\tUtils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\r\n\t\t} else\r\n\t\t\tattachment.bones = null;\r\n\r\n\t\tif (this.vertices != null) {\r\n\t\t\tattachment.vertices = Utils.newFloatArray(this.vertices.length);\r\n\t\t\tUtils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\r\n\t\t} else\r\n\t\t\tattachment.vertices = null;\r\n\r\n\t\tattachment.worldVerticesLength = this.worldVerticesLength;\r\n\t\tattachment.deformAttachment = this.deformAttachment;\r\n\t}\r\n}\r\n","\r\n\r\nimport { VertexAttachment, Attachment } from \"./Attachment\";\r\nimport { Color, Utils } from \"../Utils\";\r\n\r\n\r\n\r\n/** An attachment whose vertices make up a composite Bezier curve.\r\n *\r\n * See {@link PathConstraint} and [Paths](http://esotericsoftware.com/spine-paths) in the Spine User Guide. */\r\nexport class PathAttachment extends VertexAttachment {\r\n\r\n\t/** The lengths along the path in the setup pose from the start of the path to the end of each Bezier curve. */\r\n\tlengths: Array<number>;\r\n\r\n\t/** If true, the start and end knots are connected. */\r\n\tclosed = false;\r\n\r\n\t/** If true, additional calculations are performed to make calculating positions along the path more accurate. If false, fewer\r\n\t * calculations are performed but calculating positions along the path is less accurate. */\r\n\tconstantSpeed = false;\r\n\r\n\t/** The color of the path as it was in Spine. Available only when nonessential data was exported. Paths are not usually\r\n\t * rendered at runtime. */\r\n\tcolor = new Color(1, 1, 1, 1);\r\n\r\n\tconstructor (name: string) {\r\n\t\tsuper(name);\r\n\t}\r\n\r\n\tcopy (): Attachment {\r\n\t\tlet copy = new PathAttachment(this.name);\r\n\t\tthis.copyTo(copy);\r\n\t\tcopy.lengths = new Array<number>(this.lengths.length);\r\n\t\tUtils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\r\n\t\tcopy.closed = closed;\r\n\t\tcopy.constantSpeed = this.constantSpeed;\r\n\t\tcopy.color.setFromColor(this.color);\r\n\t\treturn copy;\r\n\t}\r\n}\r\n","\r\n\r\nimport { Updatable } from \"./Updatable\";\r\nimport { PathConstraintData, SpacingMode, RotateMode, PositionMode } from \"./PathConstraintData\";\r\nimport { Bone } from \"./Bone\";\r\nimport { Slot } from \"./Slot\";\r\nimport { Skeleton } from \"./Skeleton\";\r\nimport { PathAttachment } from \"./attachments/PathAttachment\";\r\nimport { Utils, MathUtils } from \"./Utils\";\r\n\r\n\r\n\r\n/** Stores the current pose for a path constraint. A path constraint adjusts the rotation, translation, and scale of the\r\n * constrained bones so they follow a {@link PathAttachment}.\r\n *\r\n * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide. */\r\nexport class PathConstraint implements Updatable {\r\n\tstatic NONE = -1; static BEFORE = -2; static AFTER = -3;\r\n\tstatic epsilon = 0.00001;\r\n\r\n\t/** The path constraint's setup pose data. */\r\n\tdata: PathConstraintData;\r\n\r\n\t/** The bones that will be modified by this path constraint. */\r\n\tbones: Array<Bone>;\r\n\r\n\t/** The slot whose path attachment will be used to constrained the bones. */\r\n\ttarget: Slot;\r\n\r\n\t/** The position along the path. */\r\n\tposition = 0;\r\n\r\n\t/** The spacing between bones. */\r\n\tspacing = 0;\r\n\r\n\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\r\n\trotateMix = 0;\r\n\r\n\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained translations. */\r\n\ttranslateMix = 0;\r\n\r\n\tspaces = new Array<number>(); positions = new Array<number>();\r\n\tworld = new Array<number>(); curves = new Array<number>(); lengths = new Array<number>();\r\n\tsegments = new Array<number>();\r\n\r\n\tactive = false;\r\n\r\n\tconstructor (data: PathConstraintData, skeleton: Skeleton) {\r\n\t\tif (data == null) throw new Error(\"data cannot be null.\");\r\n\t\tif (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n\t\tthis.data = data;\r\n\t\tthis.bones = new Array<Bone>();\r\n\t\tfor (let i = 0, n = data.bones.length; i < n; i++)\r\n\t\t\tthis.bones.push(skeleton.findBone(data.bones[i].name));\r\n\t\tthis.target = skeleton.findSlot(data.target.name);\r\n\t\tthis.position = data.position;\r\n\t\tthis.spacing = data.spacing;\r\n\t\tthis.rotateMix = data.rotateMix;\r\n\t\tthis.translateMix = data.translateMix;\r\n\t}\r\n\r\n\tisActive () {\r\n\t\treturn this.active;\r\n\t}\r\n\r\n\t/** Applies the constraint to the constrained bones. */\r\n\tapply () {\r\n\t\tthis.update();\r\n\t}\r\n\r\n\tupdate () {\r\n\t\tlet attachment = this.target.getAttachment();\r\n\t\tif (!(attachment instanceof PathAttachment)) return;\r\n\r\n\t\tlet rotateMix = this.rotateMix, translateMix = this.translateMix;\r\n\t\tlet translate = translateMix > 0, rotate = rotateMix > 0;\r\n\t\tif (!translate && !rotate) return;\r\n\r\n\t\tlet data = this.data;\r\n\t\tlet percentSpacing = data.spacingMode == SpacingMode.Percent;\r\n\t\tlet rotateMode = data.rotateMode;\r\n\t\tlet tangents = rotateMode == RotateMode.Tangent, scale = rotateMode == RotateMode.ChainScale;\r\n\t\tlet boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\r\n\t\tlet bones = this.bones;\r\n\t\tlet spaces = Utils.setArraySize(this.spaces, spacesCount), lengths: Array<number> = null;\r\n\t\tlet spacing = this.spacing;\r\n\t\tif (scale || !percentSpacing) {\r\n\t\t\tif (scale) lengths = Utils.setArraySize(this.lengths, boneCount);\r\n\t\t\tlet lengthSpacing = data.spacingMode == SpacingMode.Length;\r\n\t\t\tfor (let i = 0, n = spacesCount - 1; i < n;) {\r\n\t\t\t\tlet bone = bones[i];\r\n\t\t\t\tlet setupLength = bone.data.length;\r\n\t\t\t\tif (setupLength < PathConstraint.epsilon) {\r\n\t\t\t\t\tif (scale) lengths[i] = 0;\r\n\t\t\t\t\tspaces[++i] = 0;\r\n\t\t\t\t} else if (percentSpacing) {\r\n\t\t\t\t\tif (scale) {\r\n\t\t\t\t\t\tlet x = setupLength * bone.a, y = setupLength * bone.c;\r\n\t\t\t\t\t\tlet length = Math.sqrt(x * x + y * y);\r\n\t\t\t\t\t\tlengths[i] = length;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tspaces[++i] = spacing;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet x = setupLength * bone.a, y = setupLength * bone.c;\r\n\t\t\t\t\tlet length = Math.sqrt(x * x + y * y);\r\n\t\t\t\t\tif (scale) lengths[i] = length;\r\n\t\t\t\t\tspaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (let i = 1; i < spacesCount; i++)\r\n\t\t\t\tspaces[i] = spacing;\r\n\t\t}\r\n\r\n\t\tlet positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents,\r\n\t\t\tdata.positionMode == PositionMode.Percent, percentSpacing);\r\n\t\tlet boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\r\n\t\tlet tip = false;\r\n\t\tif (offsetRotation == 0)\r\n\t\t\ttip = rotateMode == RotateMode.Chain;\r\n\t\telse {\r\n\t\t\ttip = false;\r\n\t\t\tlet p = this.target.bone;\r\n\t\t\toffsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n\t\t}\r\n\t\tfor (let i = 0, p = 3; i < boneCount; i++, p += 3) {\r\n\t\t\tlet bone = bones[i];\r\n\t\t\tbone.worldX += (boneX - bone.worldX) * translateMix;\r\n\t\t\tbone.worldY += (boneY - bone.worldY) * translateMix;\r\n\t\t\tlet x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\r\n\t\t\tif (scale) {\r\n\t\t\t\tlet length = lengths[i];\r\n\t\t\t\tif (length != 0) {\r\n\t\t\t\t\tlet s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\r\n\t\t\t\t\tbone.a *= s;\r\n\t\t\t\t\tbone.c *= s;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tboneX = x;\r\n\t\t\tboneY = y;\r\n\t\t\tif (rotate) {\r\n\t\t\t\tlet a = bone.a, b = bone.b, c = bone.c, d = bone.d, r = 0, cos = 0, sin = 0;\r\n\t\t\t\tif (tangents)\r\n\t\t\t\t\tr = positions[p - 1];\r\n\t\t\t\telse if (spaces[i + 1] == 0)\r\n\t\t\t\t\tr = positions[p + 2];\r\n\t\t\t\telse\r\n\t\t\t\t\tr = Math.atan2(dy, dx);\r\n\t\t\t\tr -= Math.atan2(c, a);\r\n\t\t\t\tif (tip) {\r\n\t\t\t\t\tcos = Math.cos(r);\r\n\t\t\t\t\tsin = Math.sin(r);\r\n\t\t\t\t\tlet length = bone.data.length;\r\n\t\t\t\t\tboneX += (length * (cos * a - sin * c) - dx) * rotateMix;\r\n\t\t\t\t\tboneY += (length * (sin * a + cos * c) - dy) * rotateMix;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tr += offsetRotation;\r\n\t\t\t\t}\r\n\t\t\t\tif (r > MathUtils.PI)\r\n\t\t\t\t\tr -= MathUtils.PI2;\r\n\t\t\t\telse if (r < -MathUtils.PI) //\r\n\t\t\t\t\tr += MathUtils.PI2;\r\n\t\t\t\tr *= rotateMix;\r\n\t\t\t\tcos = Math.cos(r);\r\n\t\t\t\tsin = Math.sin(r);\r\n\t\t\t\tbone.a = cos * a - sin * c;\r\n\t\t\t\tbone.b = cos * b - sin * d;\r\n\t\t\t\tbone.c = sin * a + cos * c;\r\n\t\t\t\tbone.d = sin * b + cos * d;\r\n\t\t\t}\r\n\t\t\tbone.appliedValid = false;\r\n\t\t}\r\n\t}\r\n\r\n\tcomputeWorldPositions (path: PathAttachment, spacesCount: number, tangents: boolean, percentPosition: boolean,\r\n\t\tpercentSpacing: boolean) {\r\n\t\tlet target = this.target;\r\n\t\tlet position = this.position;\r\n\t\tlet spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world: Array<number> = null;\r\n\t\tlet closed = path.closed;\r\n\t\tlet verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\r\n\r\n\t\tif (!path.constantSpeed) {\r\n\t\t\tlet lengths = path.lengths;\r\n\t\t\tcurveCount -= closed ? 1 : 2;\r\n\t\t\tlet pathLength = lengths[curveCount];\r\n\t\t\tif (percentPosition) position *= pathLength;\r\n\t\t\tif (percentSpacing) {\r\n\t\t\t\tfor (let i = 1; i < spacesCount; i++)\r\n\t\t\t\t\tspaces[i] *= pathLength;\r\n\t\t\t}\r\n\t\t\tworld = Utils.setArraySize(this.world, 8);\r\n\t\t\tfor (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\r\n\t\t\t\tlet space = spaces[i];\r\n\t\t\t\tposition += space;\r\n\t\t\t\tlet p = position;\r\n\r\n\t\t\t\tif (closed) {\r\n\t\t\t\t\tp %= pathLength;\r\n\t\t\t\t\tif (p < 0) p += pathLength;\r\n\t\t\t\t\tcurve = 0;\r\n\t\t\t\t} else if (p < 0) {\r\n\t\t\t\t\tif (prevCurve != PathConstraint.BEFORE) {\r\n\t\t\t\t\t\tprevCurve = PathConstraint.BEFORE;\r\n\t\t\t\t\t\tpath.computeWorldVertices(target, 2, 4, world, 0, 2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.addBeforePosition(p, world, 0, out, o);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else if (p > pathLength) {\r\n\t\t\t\t\tif (prevCurve != PathConstraint.AFTER) {\r\n\t\t\t\t\t\tprevCurve = PathConstraint.AFTER;\r\n\t\t\t\t\t\tpath.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.addAfterPosition(p - pathLength, world, 0, out, o);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Determine curve containing position.\r\n\t\t\t\tfor (;; curve++) {\r\n\t\t\t\t\tlet length = lengths[curve];\r\n\t\t\t\t\tif (p > length) continue;\r\n\t\t\t\t\tif (curve == 0)\r\n\t\t\t\t\t\tp /= length;\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tlet prev = lengths[curve - 1];\r\n\t\t\t\t\t\tp = (p - prev) / (length - prev);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (curve != prevCurve) {\r\n\t\t\t\t\tprevCurve = curve;\r\n\t\t\t\t\tif (closed && curve == curveCount) {\r\n\t\t\t\t\t\tpath.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\r\n\t\t\t\t\t\tpath.computeWorldVertices(target, 0, 4, world, 4, 2);\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tpath.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\r\n\t\t\t\t}\r\n\t\t\t\tthis.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o,\r\n\t\t\t\t\ttangents || (i > 0 && space == 0));\r\n\t\t\t}\r\n\t\t\treturn out;\r\n\t\t}\r\n\r\n\t\t// World vertices.\r\n\t\tif (closed) {\r\n\t\t\tverticesLength += 2;\r\n\t\t\tworld = Utils.setArraySize(this.world, verticesLength);\r\n\t\t\tpath.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\r\n\t\t\tpath.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\r\n\t\t\tworld[verticesLength - 2] = world[0];\r\n\t\t\tworld[verticesLength - 1] = world[1];\r\n\t\t} else {\r\n\t\t\tcurveCount--;\r\n\t\t\tverticesLength -= 4;\r\n\t\t\tworld = Utils.setArraySize(this.world, verticesLength);\r\n\t\t\tpath.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\r\n\t\t}\r\n\r\n\t\t// Curve lengths.\r\n\t\tlet curves = Utils.setArraySize(this.curves, curveCount);\r\n\t\tlet pathLength = 0;\r\n\t\tlet x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\r\n\t\tlet tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\r\n\t\tfor (let i = 0, w = 2; i < curveCount; i++, w += 6) {\r\n\t\t\tcx1 = world[w];\r\n\t\t\tcy1 = world[w + 1];\r\n\t\t\tcx2 = world[w + 2];\r\n\t\t\tcy2 = world[w + 3];\r\n\t\t\tx2 = world[w + 4];\r\n\t\t\ty2 = world[w + 5];\r\n\t\t\ttmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\r\n\t\t\ttmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\r\n\t\t\tdddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\r\n\t\t\tdddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\r\n\t\t\tddfx = tmpx * 2 + dddfx;\r\n\t\t\tddfy = tmpy * 2 + dddfy;\r\n\t\t\tdfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\r\n\t\t\tdfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\r\n\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\tdfx += ddfx;\r\n\t\t\tdfy += ddfy;\r\n\t\t\tddfx += dddfx;\r\n\t\t\tddfy += dddfy;\r\n\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\tdfx += ddfx;\r\n\t\t\tdfy += ddfy;\r\n\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\tdfx += ddfx + dddfx;\r\n\t\t\tdfy += ddfy + dddfy;\r\n\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\tcurves[i] = pathLength;\r\n\t\t\tx1 = x2;\r\n\t\t\ty1 = y2;\r\n\t\t}\r\n\t\tif (percentPosition)\r\n\t\t\tposition *= pathLength;\r\n\t\telse\r\n\t\t\tposition *= pathLength / path.lengths[curveCount - 1];\r\n\t\tif (percentSpacing) {\r\n\t\t\tfor (let i = 1; i < spacesCount; i++)\r\n\t\t\t\tspaces[i] *= pathLength;\r\n\t\t}\r\n\r\n\t\tlet segments = this.segments;\r\n\t\tlet curveLength = 0;\r\n\t\tfor (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\r\n\t\t\tlet space = spaces[i];\r\n\t\t\tposition += space;\r\n\t\t\tlet p = position;\r\n\r\n\t\t\tif (closed) {\r\n\t\t\t\tp %= pathLength;\r\n\t\t\t\tif (p < 0) p += pathLength;\r\n\t\t\t\tcurve = 0;\r\n\t\t\t} else if (p < 0) {\r\n\t\t\t\tthis.addBeforePosition(p, world, 0, out, o);\r\n\t\t\t\tcontinue;\r\n\t\t\t} else if (p > pathLength) {\r\n\t\t\t\tthis.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// Determine curve containing position.\r\n\t\t\tfor (;; curve++) {\r\n\t\t\t\tlet length = curves[curve];\r\n\t\t\t\tif (p > length) continue;\r\n\t\t\t\tif (curve == 0)\r\n\t\t\t\t\tp /= length;\r\n\t\t\t\telse {\r\n\t\t\t\t\tlet prev = curves[curve - 1];\r\n\t\t\t\t\tp = (p - prev) / (length - prev);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// Curve segment lengths.\r\n\t\t\tif (curve != prevCurve) {\r\n\t\t\t\tprevCurve = curve;\r\n\t\t\t\tlet ii = curve * 6;\r\n\t\t\t\tx1 = world[ii];\r\n\t\t\t\ty1 = world[ii + 1];\r\n\t\t\t\tcx1 = world[ii + 2];\r\n\t\t\t\tcy1 = world[ii + 3];\r\n\t\t\t\tcx2 = world[ii + 4];\r\n\t\t\t\tcy2 = world[ii + 5];\r\n\t\t\t\tx2 = world[ii + 6];\r\n\t\t\t\ty2 = world[ii + 7];\r\n\t\t\t\ttmpx = (x1 - cx1 * 2 + cx2) * 0.03;\r\n\t\t\t\ttmpy = (y1 - cy1 * 2 + cy2) * 0.03;\r\n\t\t\t\tdddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\r\n\t\t\t\tdddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\r\n\t\t\t\tddfx = tmpx * 2 + dddfx;\r\n\t\t\t\tddfy = tmpy * 2 + dddfy;\r\n\t\t\t\tdfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\r\n\t\t\t\tdfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\r\n\t\t\t\tcurveLength = Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\tsegments[0] = curveLength;\r\n\t\t\t\tfor (ii = 1; ii < 8; ii++) {\r\n\t\t\t\t\tdfx += ddfx;\r\n\t\t\t\t\tdfy += ddfy;\r\n\t\t\t\t\tddfx += dddfx;\r\n\t\t\t\t\tddfy += dddfy;\r\n\t\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\t\tsegments[ii] = curveLength;\r\n\t\t\t\t}\r\n\t\t\t\tdfx += ddfx;\r\n\t\t\t\tdfy += ddfy;\r\n\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\tsegments[8] = curveLength;\r\n\t\t\t\tdfx += ddfx + dddfx;\r\n\t\t\t\tdfy += ddfy + dddfy;\r\n\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\tsegments[9] = curveLength;\r\n\t\t\t\tsegment = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// Weight by segment length.\r\n\t\t\tp *= curveLength;\r\n\t\t\tfor (;; segment++) {\r\n\t\t\t\tlet length = segments[segment];\r\n\t\t\t\tif (p > length) continue;\r\n\t\t\t\tif (segment == 0)\r\n\t\t\t\t\tp /= length;\r\n\t\t\t\telse {\r\n\t\t\t\t\tlet prev = segments[segment - 1];\r\n\t\t\t\t\tp = segment + (p - prev) / (length - prev);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tthis.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\r\n\t\t}\r\n\t\treturn out;\r\n\t}\r\n\r\n\taddBeforePosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n\t\tlet x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\r\n\t\tout[o] = x1 + p * Math.cos(r);\r\n\t\tout[o + 1] = y1 + p * Math.sin(r);\r\n\t\tout[o + 2] = r;\r\n\t}\r\n\r\n\taddAfterPosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n\t\tlet x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\r\n\t\tout[o] = x1 + p * Math.cos(r);\r\n\t\tout[o + 1] = y1 + p * Math.sin(r);\r\n\t\tout[o + 2] = r;\r\n\t}\r\n\r\n\taddCurvePosition (p: number, x1: number, y1: number, cx1: number, cy1: number, cx2: number, cy2: number, x2: number, y2: number,\r\n\t\tout: Array<number>, o: number, tangents: boolean) {\r\n\t\tif (p == 0 || isNaN(p)) {\r\n\t\t\tout[o] = x1;\r\n\t\t\tout[o + 1] = y1;\r\n\t\t\tout[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\r\n\t\tlet ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\r\n\t\tlet x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\r\n\t\tout[o] = x;\r\n\t\tout[o + 1] = y;\r\n\t\tif (tangents) {\r\n\t\t\tif (p < 0.001)\r\n\t\t\t\tout[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\r\n\t\t\telse\r\n\t\t\t\tout[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\r\n\t\t}\r\n\t}\r\n}\r\n","\r\n\r\nimport { Attachment } from \"./Attachment\";\r\nimport { Color, Utils, ArrayLike } from \"../Utils\";\r\nimport { TextureRegion } from \"../Texture\";\r\nimport { Bone } from \"../Bone\";\r\n\r\n\r\n\r\n/** An attachment that displays a textured quadrilateral.\r\n *\r\n * See [Region attachments](http://esotericsoftware.com/spine-regions) in the Spine User Guide. */\r\nexport class RegionAttachment extends Attachment {\r\n\tstatic OX1 = 0;\r\n\tstatic OY1 = 1;\r\n\tstatic OX2 = 2;\r\n\tstatic OY2 = 3;\r\n\tstatic OX3 = 4;\r\n\tstatic OY3 = 5;\r\n\tstatic OX4 = 6;\r\n\tstatic OY4 = 7;\r\n\r\n\tstatic X1 = 0;\r\n\tstatic Y1 = 1;\r\n\tstatic C1R = 2;\r\n\tstatic C1G = 3;\r\n\tstatic C1B = 4;\r\n\tstatic C1A = 5;\r\n\tstatic U1 = 6;\r\n\tstatic V1 = 7;\r\n\r\n\tstatic X2 = 8;\r\n\tstatic Y2 = 9;\r\n\tstatic C2R = 10;\r\n\tstatic C2G = 11;\r\n\tstatic C2B = 12;\r\n\tstatic C2A = 13;\r\n\tstatic U2 = 14;\r\n\tstatic V2 = 15;\r\n\r\n\tstatic X3 = 16;\r\n\tstatic Y3 = 17;\r\n\tstatic C3R = 18;\r\n\tstatic C3G = 19;\r\n\tstatic C3B = 20;\r\n\tstatic C3A = 21;\r\n\tstatic U3 = 22;\r\n\tstatic V3 = 23;\r\n\r\n\tstatic X4 = 24;\r\n\tstatic Y4 = 25;\r\n\tstatic C4R = 26;\r\n\tstatic C4G = 27;\r\n\tstatic C4B = 28;\r\n\tstatic C4A = 29;\r\n\tstatic U4 = 30;\r\n\tstatic V4 = 31;\r\n\r\n\t/** The local x translation. */\r\n\tx = 0;\r\n\r\n\t/** The local y translation. */\r\n\ty = 0;\r\n\r\n\t/** The local scaleX. */\r\n\tscaleX = 1;\r\n\r\n\t/** The local scaleY. */\r\n\tscaleY = 1;\r\n\r\n\t/** The local rotation. */\r\n\trotation = 0;\r\n\r\n\t/** The width of the region attachment in Spine. */\r\n\twidth = 0;\r\n\r\n\t/** The height of the region attachment in Spine. */\r\n\theight = 0;\r\n\r\n\t/** The color to tint the region attachment. */\r\n\tcolor = new Color(1, 1, 1, 1);\r\n\r\n\t/** The name of the texture region for this attachment. */\r\n\tpath: string;\r\n\r\n\trendererObject: any;\r\n\tregion: TextureRegion;\r\n\r\n\t/** For each of the 4 vertices, a pair of <code>x,y</code> values that is the local position of the vertex.\r\n\t *\r\n\t * See {@link #updateOffset()}. */\r\n\toffset = Utils.newFloatArray(8);\r\n\r\n\r\n\tuvs = Utils.newFloatArray(8);\r\n\r\n\ttempColor = new Color(1, 1, 1, 1);\r\n\r\n\tconstructor (name:string) {\r\n\t\tsuper(name);\r\n\t}\r\n\r\n\t/** Calculates the {@link #offset} using the region settings. Must be called after changing region settings. */\r\n\tupdateOffset () : void {\r\n\t\tlet regionScaleX = this.width / this.region.originalWidth * this.scaleX;\r\n\t\tlet regionScaleY = this.height / this.region.originalHeight * this.scaleY;\r\n\t\tlet localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\r\n\t\tlet localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\r\n\t\tlet localX2 = localX + this.region.width * regionScaleX;\r\n\t\tlet localY2 = localY + this.region.height * regionScaleY;\r\n\t\tlet radians = this.rotation * Math.PI / 180;\r\n\t\tlet cos = Math.cos(radians);\r\n\t\tlet sin = Math.sin(radians);\r\n\t\tlet localXCos = localX * cos + this.x;\r\n\t\tlet localXSin = localX * sin;\r\n\t\tlet localYCos = localY * cos + this.y;\r\n\t\tlet localYSin = localY * sin;\r\n\t\tlet localX2Cos = localX2 * cos + this.x;\r\n\t\tlet localX2Sin = localX2 * sin;\r\n\t\tlet localY2Cos = localY2 * cos + this.y;\r\n\t\tlet localY2Sin = localY2 * sin;\r\n\t\tlet offset = this.offset;\r\n\t\toffset[RegionAttachment.OX1] = localXCos - localYSin;\r\n\t\toffset[RegionAttachment.OY1] = localYCos + localXSin;\r\n\t\toffset[RegionAttachment.OX2] = localXCos - localY2Sin;\r\n\t\toffset[RegionAttachment.OY2] = localY2Cos + localXSin;\r\n\t\toffset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\r\n\t\toffset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\r\n\t\toffset[RegionAttachment.OX4] = localX2Cos - localYSin;\r\n\t\toffset[RegionAttachment.OY4] = localYCos + localX2Sin;\r\n\t}\r\n\r\n\tsetRegion (region: TextureRegion) : void {\r\n\t\tthis.region = region;\r\n\t\tlet uvs = this.uvs;\r\n\t\tif (region.rotate) {\r\n\t\t\tuvs[2] = region.u;\r\n\t\t\tuvs[3] = region.v2;\r\n\t\t\tuvs[4] = region.u;\r\n\t\t\tuvs[5] = region.v;\r\n\t\t\tuvs[6] = region.u2;\r\n\t\t\tuvs[7] = region.v;\r\n\t\t\tuvs[0] = region.u2;\r\n\t\t\tuvs[1] = region.v2;\r\n\t\t} else {\r\n\t\t\tuvs[0] = region.u;\r\n\t\t\tuvs[1] = region.v2;\r\n\t\t\tuvs[2] = region.u;\r\n\t\t\tuvs[3] = region.v;\r\n\t\t\tuvs[4] = region.u2;\r\n\t\t\tuvs[5] = region.v;\r\n\t\t\tuvs[6] = region.u2;\r\n\t\t\tuvs[7] = region.v2;\r\n\t\t}\r\n\t}\r\n\r\n\t/** Transforms the attachment's four vertices to world coordinates.\r\n\t *\r\n\t * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n\t * Runtimes Guide.\r\n\t * @param worldVertices The output world vertices. Must have a length >= `offset` + 8.\r\n\t * @param offset The `worldVertices` index to begin writing values.\r\n\t * @param stride The number of `worldVertices` entries between the value pairs written. */\r\n\tcomputeWorldVertices (bone: Bone, worldVertices: ArrayLike<number>, offset: number, stride: number) {\r\n\t\tlet vertexOffset = this.offset;\r\n\t\tlet x = bone.worldX, y = bone.worldY;\r\n\t\tlet a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n\t\tlet offsetX = 0, offsetY = 0;\r\n\r\n\t\toffsetX = vertexOffset[RegionAttachment.OX1];\r\n\t\toffsetY = vertexOffset[RegionAttachment.OY1];\r\n\t\tworldVertices[offset] = offsetX * a + offsetY * b + x; // br\r\n\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n\t\toffset += stride;\r\n\r\n\t\toffsetX = vertexOffset[RegionAttachment.OX2];\r\n\t\toffsetY = vertexOffset[RegionAttachment.OY2];\r\n\t\tworldVertices[offset] = offsetX * a + offsetY * b + x; // bl\r\n\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n\t\toffset += stride;\r\n\r\n\t\toffsetX = vertexOffset[RegionAttachment.OX3];\r\n\t\toffsetY = vertexOffset[RegionAttachment.OY3];\r\n\t\tworldVertices[offset] = offsetX * a + offsetY * b + x; // ul\r\n\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n\t\toffset += stride;\r\n\r\n\t\toffsetX = vertexOffset[RegionAttachment.OX4];\r\n\t\toffsetY = vertexOffset[RegionAttachment.OY4];\r\n\t\tworldVertices[offset] = offsetX * a + offsetY * b + x; // ur\r\n\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n\t}\r\n\r\n\tcopy (): Attachment {\r\n\t\tlet copy = new RegionAttachment(this.name);\r\n\t\tcopy.region = this.region;\r\n\t\tcopy.rendererObject = this.rendererObject;\r\n\t\tcopy.path = this.path;\r\n\t\tcopy.x = this.x;\r\n\t\tcopy.y = this.y;\r\n\t\tcopy.scaleX = this.scaleX;\r\n\t\tcopy.scaleY = this.scaleY;\r\n\t\tcopy.rotation = this.rotation;\r\n\t\tcopy.width = this.width;\r\n\t\tcopy.height = this.height;\r\n\t\tUtils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\r\n\t\tUtils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\r\n\t\tcopy.color.setFromColor(this.color);\r\n\t\treturn copy;\r\n\t}\r\n}\r\n","export abstract class Texture {\r\n\tprotected _image: HTMLImageElement | ImageBitmap;\r\n\r\n\tconstructor (image: HTMLImageElement | ImageBitmap) {\r\n\t\tthis._image = image;\r\n\t}\r\n\r\n\tgetImage (): HTMLImageElement | ImageBitmap {\r\n\t\treturn this._image;\r\n\t}\r\n\r\n\tabstract setFilters (minFilter: TextureFilter, magFilter: TextureFilter): void;\r\n\tabstract setWraps (uWrap: TextureWrap, vWrap: TextureWrap): void;\r\n\tabstract dispose (): void;\r\n\r\n\tpublic static filterFromString (text: string): TextureFilter {\r\n\t\tswitch (text.toLowerCase()) {\r\n\t\t\tcase \"nearest\": return TextureFilter.Nearest;\r\n\t\t\tcase \"linear\": return TextureFilter.Linear;\r\n\t\t\tcase \"mipmap\": return TextureFilter.MipMap;\r\n\t\t\tcase \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\r\n\t\t\tcase \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\r\n\t\t\tcase \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\r\n\t\t\tcase \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\r\n\t\t\tdefault: throw new Error(`Unknown texture filter ${text}`);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static wrapFromString (text: string): TextureWrap {\r\n\t\tswitch (text.toLowerCase()) {\r\n\t\t\tcase \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\r\n\t\t\tcase \"clamptoedge\": return TextureWrap.ClampToEdge;\r\n\t\t\tcase \"repeat\": return TextureWrap.Repeat;\r\n\t\t\tdefault: throw new Error(`Unknown texture wrap ${text}`);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport enum TextureFilter {\r\n\tNearest = 9728, // WebGLRenderingContext.NEAREST\r\n\tLinear = 9729, // WebGLRenderingContext.LINEAR\r\n\tMipMap = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\r\n\tMipMapNearestNearest = 9984, // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\r\n\tMipMapLinearNearest = 9985, // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\r\n\tMipMapNearestLinear = 9986, // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\r\n\tMipMapLinearLinear = 9987 // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\r\n}\r\n\r\nexport enum TextureWrap {\r\n\tMirroredRepeat = 33648, // WebGLRenderingContext.MIRRORED_REPEAT\r\n\tClampToEdge = 33071, // WebGLRenderingContext.CLAMP_TO_EDGE\r\n\tRepeat = 10497 // WebGLRenderingContext.REPEAT\r\n}\r\n\r\nexport class TextureRegion {\r\n\trenderObject: any;\r\n\tu = 0; v = 0;\r\n\tu2 = 0; v2 = 0;\r\n\twidth = 0; height = 0;\r\n\trotate = false;\r\n\toffsetX = 0; offsetY = 0;\r\n\toriginalWidth = 0; originalHeight = 0;\r\n}\r\n\r\nexport class FakeTexture extends Texture {\r\n\tsetFilters(minFilter: TextureFilter, magFilter: TextureFilter) { }\r\n\tsetWraps(uWrap: TextureWrap, vWrap: TextureWrap) { }\r\n\tdispose() { }\r\n}\r\n","\r\n\r\nimport { Skeleton } from \"./Skeleton\";\r\nimport { Utils, MathUtils, ArrayLike } from \"./Utils\";\r\nimport { Slot } from \"./Slot\";\r\nimport { VertexAttachment, Attachment } from \"./attachments/Attachment\";\r\nimport { IkConstraint } from \"./IkConstraint\";\r\nimport { TransformConstraint } from \"./TransformConstraint\";\r\nimport { PathConstraint } from \"./PathConstraint\";\r\nimport { Event } from \"./Event\";\r\n\r\n\r\n\r\n/** A simple container for a list of timelines and a name. */\r\nexport class Animation {\r\n\t/** The animation's name, which is unique across all animations in the skeleton. */\r\n\tname: string;\r\n\ttimelines: Array<Timeline>;\r\n\ttimelineIds: Array<boolean>;\r\n\r\n\t/** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */\r\n\tduration: number;\r\n\r\n\tconstructor (name: string, timelines: Array<Timeline>, duration: number) {\r\n\t\tif (name == null) throw new Error(\"name cannot be null.\");\r\n\t\tif (timelines == null) throw new Error(\"timelines cannot be null.\");\r\n\t\tthis.name = name;\r\n\t\tthis.timelines = timelines;\r\n\t\tthis.timelineIds = [];\r\n\t\tfor (var i = 0; i < timelines.length; i++)\r\n\t\t\tthis.timelineIds[timelines[i].getPropertyId()] = true;\r\n\t\tthis.duration = duration;\r\n\t}\r\n\r\n\thasTimeline (id: number) {\r\n\t\treturn this.timelineIds[id] == true;\r\n\t}\r\n\r\n\t/** Applies all the animation's timelines to the specified skeleton.\r\n\t *\r\n\t * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n\t * @param loop If true, the animation repeats after {@link #getDuration()}.\r\n\t * @param events May be null to ignore fired events. */\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n\t\tif (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n\r\n\t\tif (loop && this.duration != 0) {\r\n\t\t\ttime %= this.duration;\r\n\t\t\tif (lastTime > 0) lastTime %= this.duration;\r\n\t\t}\r\n\r\n\t\tlet timelines = this.timelines;\r\n\t\tfor (let i = 0, n = timelines.length; i < n; i++)\r\n\t\t\ttimelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\r\n\t}\r\n\r\n\t/** @param target After the first and before the last value.\r\n\t * @returns index of first value greater than the target. */\r\n\tstatic binarySearch (values: ArrayLike<number>, target: number, step: number = 1) {\r\n\t\tlet low = 0;\r\n\t\tlet high = values.length / step - 2;\r\n\t\tif (high == 0) return step;\r\n\t\tlet current = high >>> 1;\r\n\t\twhile (true) {\r\n\t\t\tif (values[(current + 1) * step] <= target)\r\n\t\t\t\tlow = current + 1;\r\n\t\t\telse\r\n\t\t\t\thigh = current;\r\n\t\t\tif (low == high) return (low + 1) * step;\r\n\t\t\tcurrent = (low + high) >>> 1;\r\n\t\t}\r\n\t}\r\n\r\n\tstatic linearSearch (values: ArrayLike<number>, target: number, step: number) {\r\n\t\tfor (let i = 0, last = values.length - step; i <= last; i += step)\r\n\t\t\tif (values[i] > target) return i;\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\n/** The interface for all timelines. */\r\nexport interface Timeline {\r\n\t/** Applies this timeline to the skeleton.\r\n\t * @param skeleton The skeleton the timeline is being applied to. This provides access to the bones, slots, and other\r\n\t *           skeleton components the timeline may change.\r\n\t * @param lastTime The time this timeline was last applied. Timelines such as {@link EventTimeline}} trigger only at specific\r\n\t *           times rather than every frame. In that case, the timeline triggers everything between `lastTime`\r\n\t *           (exclusive) and `time` (inclusive).\r\n\t * @param time The time within the animation. Most timelines find the key before and the key after this time so they can\r\n\t *           interpolate between the keys.\r\n\t * @param events If any events are fired, they are added to this list. Can be null to ignore fired events or if the timeline\r\n\t *           does not fire events.\r\n\t * @param alpha 0 applies the current or setup value (depending on `blend`). 1 applies the timeline value.\r\n\t *           Between 0 and 1 applies a value between the current or setup value and the timeline value. By adjusting\r\n\t *           `alpha` over time, an animation can be mixed in or out. `alpha` can also be useful to\r\n\t *           apply animations on top of each other (layering).\r\n\t * @param blend Controls how mixing is applied when `alpha` < 1.\r\n\t * @param direction Indicates whether the timeline is mixing in or out. Used by timelines which perform instant transitions,\r\n\t *           such as {@link DrawOrderTimeline} or {@link AttachmentTimeline}. */\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\r\n\r\n\t/** Uniquely encodes both the type of this timeline and the skeleton property that it affects. */\r\n\tgetPropertyId (): number;\r\n}\r\n\r\n/** Controls how a timeline value is mixed with the setup pose value or current pose value when a timeline's `alpha`\r\n * < 1.\r\n *\r\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}. */\r\nexport enum MixBlend {\r\n\t/** Transitions from the setup value to the timeline value (the current value is not used). Before the first key, the setup\r\n\t * value is set. */\r\n\tsetup,\r\n\t/** Transitions from the current value to the timeline value. Before the first key, transitions from the current value to\r\n\t * the setup value. Timelines which perform instant transitions, such as {@link DrawOrderTimeline} or\r\n\t * {@link AttachmentTimeline}, use the setup value before the first key.\r\n\t *\r\n\t * `first` is intended for the first animations applied, not for animations layered on top of those. */\r\n\tfirst,\r\n\t/** Transitions from the current value to the timeline value. No change is made before the first key (the current value is\r\n\t * kept until the first key).\r\n\t *\r\n\t * `replace` is intended for animations layered on top of others, not for the first animations applied. */\r\n\treplace,\r\n\t/** Transitions from the current value to the current value plus the timeline value. No change is made before the first key\r\n\t * (the current value is kept until the first key).\r\n\t *\r\n\t * `add` is intended for animations layered on top of others, not for the first animations applied. Properties\r\n\t * keyed by additive animations must be set manually or by another animation before applying the additive animations, else\r\n\t * the property values will increase continually. */\r\n\tadd\r\n}\r\n\r\n/** Indicates whether a timeline's `alpha` is mixing out over time toward 0 (the setup or current pose value) or\r\n * mixing in toward 1 (the timeline's value).\r\n *\r\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}. */\r\nexport enum MixDirection {\r\n\tmixIn, mixOut\r\n}\r\n\r\nexport enum TimelineType {\r\n\trotate, translate, scale, shear,\r\n\tattachment, color, deform,\r\n\tevent, drawOrder,\r\n\tikConstraint, transformConstraint,\r\n\tpathConstraintPosition, pathConstraintSpacing, pathConstraintMix,\r\n\ttwoColor\r\n}\r\n\r\n/** The base class for timelines that use interpolation between key frame values. */\r\nexport abstract class CurveTimeline implements Timeline {\r\n\tstatic LINEAR = 0; static STEPPED = 1; static BEZIER = 2;\r\n\tstatic BEZIER_SIZE = 10 * 2 - 1;\r\n\r\n\tprivate curves: ArrayLike<number>; // type, x, y, ...\r\n\r\n\tabstract getPropertyId(): number;\r\n\r\n\tconstructor (frameCount: number) {\r\n\t\tif (frameCount <= 0) throw new Error(\"frameCount must be > 0: \" + frameCount);\r\n\t\tthis.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\r\n\t}\r\n\r\n\t/** The number of key frames for this timeline. */\r\n\tgetFrameCount () {\r\n\t\treturn this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\r\n\t}\r\n\r\n\t/** Sets the specified key frame to linear interpolation. */\r\n\tsetLinear (frameIndex: number) {\r\n\t\tthis.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\r\n\t}\r\n\r\n\t/** Sets the specified key frame to stepped interpolation. */\r\n\tsetStepped (frameIndex: number) {\r\n\t\tthis.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\r\n\t}\r\n\r\n\t/** Returns the interpolation type for the specified key frame.\r\n\t * @returns Linear is 0, stepped is 1, Bezier is 2. */\r\n\tgetCurveType (frameIndex: number): number {\r\n\t\tlet index = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n\t\tif (index == this.curves.length) return CurveTimeline.LINEAR;\r\n\t\tlet type = this.curves[index];\r\n\t\tif (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\r\n\t\tif (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\r\n\t\treturn CurveTimeline.BEZIER;\r\n\t}\r\n\r\n\t/** Sets the specified key frame to Bezier interpolation. `cx1` and `cx2` are from 0 to 1,\r\n\t * representing the percent of time between the two key frames. `cy1` and `cy2` are the percent of the\r\n\t * difference between the key frame's values. */\r\n\tsetCurve (frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\r\n\t\tlet tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\r\n\t\tlet dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\r\n\t\tlet ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\r\n\t\tlet dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\r\n\r\n\t\tlet i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n\t\tlet curves = this.curves;\r\n\t\tcurves[i++] = CurveTimeline.BEZIER;\r\n\r\n\t\tlet x = dfx, y = dfy;\r\n\t\tfor (let n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n\t\t\tcurves[i] = x;\r\n\t\t\tcurves[i + 1] = y;\r\n\t\t\tdfx += ddfx;\r\n\t\t\tdfy += ddfy;\r\n\t\t\tddfx += dddfx;\r\n\t\t\tddfy += dddfy;\r\n\t\t\tx += dfx;\r\n\t\t\ty += dfy;\r\n\t\t}\r\n\t}\r\n\r\n\t/** Returns the interpolated percentage for the specified key frame and linear percentage. */\r\n\tgetCurvePercent (frameIndex: number, percent: number) {\r\n\t\tpercent = MathUtils.clamp(percent, 0, 1);\r\n\t\tlet curves = this.curves;\r\n\t\tlet i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n\t\tlet type = curves[i];\r\n\t\tif (type == CurveTimeline.LINEAR) return percent;\r\n\t\tif (type == CurveTimeline.STEPPED) return 0;\r\n\t\ti++;\r\n\t\tlet x = 0;\r\n\t\tfor (let start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n\t\t\tx = curves[i];\r\n\t\t\tif (x >= percent) {\r\n\t\t\t\tlet prevX: number, prevY: number;\r\n\t\t\t\tif (i == start) {\r\n\t\t\t\t\tprevX = 0;\r\n\t\t\t\t\tprevY = 0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tprevX = curves[i - 2];\r\n\t\t\t\t\tprevY = curves[i - 1];\r\n\t\t\t\t}\r\n\t\t\t\treturn prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet y = curves[i - 1];\r\n\t\treturn y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\r\n\t}\r\n\r\n\tabstract apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#rotation}. */\r\nexport class RotateTimeline extends CurveTimeline {\r\n\tstatic ENTRIES = 2;\r\n\tstatic PREV_TIME = -2; static PREV_ROTATION = -1;\r\n\tstatic ROTATION = 1;\r\n\r\n\t/** The index of the bone in {@link Skeleton#bones} that will be changed. */\r\n\tboneIndex: number;\r\n\r\n\t/** The time in seconds and rotation in degrees for each key frame. */\r\n\tframes: ArrayLike<number>; // time, degrees, ...\r\n\r\n\tconstructor (frameCount: number) {\r\n\t\tsuper(frameCount);\r\n\t\tthis.frames = Utils.newFloatArray(frameCount << 1);\r\n\t}\r\n\r\n\tgetPropertyId () {\r\n\t\treturn (TimelineType.rotate << 24) + this.boneIndex;\r\n\t}\r\n\r\n\t/** Sets the time and angle of the specified keyframe. */\r\n\tsetFrame (frameIndex: number, time: number, degrees: number) {\r\n\t\tframeIndex <<= 1;\r\n\t\tthis.frames[frameIndex] = time;\r\n\t\tthis.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\r\n\t}\r\n\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n\t\tlet frames = this.frames;\r\n\r\n\t\tlet bone = skeleton.bones[this.boneIndex];\r\n\t\tif (!bone.active) return;\r\n\t\tif (time < frames[0]) {\r\n\t\t\tswitch (blend) {\r\n\t\t\tcase MixBlend.setup:\r\n\t\t\t\tbone.rotation = bone.data.rotation;\r\n\t\t\t\treturn;\r\n\t\t\tcase MixBlend.first:\r\n\t\t\t\tlet r = bone.data.rotation - bone.rotation;\r\n\t\t\t\tbone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (time >= frames[frames.length - RotateTimeline.ENTRIES]) { // Time is after last frame.\r\n\t\t\tlet r = frames[frames.length + RotateTimeline.PREV_ROTATION];\r\n\t\t\tswitch (blend) {\r\n\t\t\tcase MixBlend.setup:\r\n\t\t\t\tbone.rotation = bone.data.rotation + r * alpha;\r\n\t\t\t\tbreak;\r\n\t\t\tcase MixBlend.first:\r\n\t\t\tcase MixBlend.replace:\r\n\t\t\t\tr += bone.data.rotation - bone.rotation;\r\n\t\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360; // Wrap within -180 and 180.\r\n\t\t\tcase MixBlend.add:\r\n\t\t\t\tbone.rotation += r * alpha;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Interpolate between the previous frame and the current frame.\r\n\t\tlet frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n\t\tlet prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n\t\tlet frameTime = frames[frame];\r\n\t\tlet percent = this.getCurvePercent((frame >> 1) - 1,\r\n\t\t\t1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n\r\n\t\tlet r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n\t\tr = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;\r\n\t\tswitch (blend) {\r\n\t\tcase MixBlend.setup:\r\n\t\t\tbone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n\t\t\tbreak;\r\n\t\tcase MixBlend.first:\r\n\t\tcase MixBlend.replace:\r\n\t\t\tr += bone.data.rotation - bone.rotation;\r\n\t\tcase MixBlend.add:\r\n\t\t\tbone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#x} and {@link Bone#y}. */\r\nexport class TranslateTimeline extends CurveTimeline {\r\n\tstatic ENTRIES = 3;\r\n\tstatic PREV_TIME = -3; static PREV_X = -2; static PREV_Y = -1;\r\n\tstatic X = 1; static Y = 2;\r\n\r\n\t/** The index of the bone in {@link Skeleton#bones} that will be changed. */\r\n\tboneIndex: number;\r\n\r\n\t/** The time in seconds, x, and y values for each key frame. */\r\n\tframes: ArrayLike<number>; // time, x, y, ...\r\n\r\n\tconstructor (frameCount: number) {\r\n\t\tsuper(frameCount);\r\n\t\tthis.frames = Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\r\n\t}\r\n\r\n\tgetPropertyId () {\r\n\t\treturn (TimelineType.translate << 24) + this.boneIndex;\r\n\t}\r\n\r\n\t/** Sets the time in seconds, x, and y values for the specified key frame. */\r\n\tsetFrame (frameIndex: number, time: number, x: number, y: number) {\r\n\t\tframeIndex *= TranslateTimeline.ENTRIES;\r\n\t\tthis.frames[frameIndex] = time;\r\n\t\tthis.frames[frameIndex + TranslateTimeline.X] = x;\r\n\t\tthis.frames[frameIndex + TranslateTimeline.Y] = y;\r\n\t}\r\n\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n\t\tlet frames = this.frames;\r\n\r\n\t\tlet bone = skeleton.bones[this.boneIndex];\r\n\t\tif (!bone.active) return;\r\n\t\tif (time < frames[0]) {\r\n\t\t\tswitch (blend) {\r\n\t\t\tcase MixBlend.setup:\r\n\t\t\t\tbone.x = bone.data.x;\r\n\t\t\t\tbone.y = bone.data.y;\r\n\t\t\t\treturn;\r\n\t\t\tcase MixBlend.first:\r\n\t\t\t\tbone.x += (bone.data.x - bone.x) * alpha;\r\n\t\t\t\tbone.y += (bone.data.y - bone.y) * alpha;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet x = 0, y = 0;\r\n\t\tif (time >= frames[frames.length - TranslateTimeline.ENTRIES]) { // Time is after last frame.\r\n\t\t\tx = frames[frames.length + TranslateTimeline.PREV_X];\r\n\t\t\ty = frames[frames.length + TranslateTimeline.PREV_Y];\r\n\t\t} else {\r\n\t\t\t// Interpolate between the previous frame and the current frame.\r\n\t\t\tlet frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\r\n\t\t\tx = frames[frame + TranslateTimeline.PREV_X];\r\n\t\t\ty = frames[frame + TranslateTimeline.PREV_Y];\r\n\t\t\tlet frameTime = frames[frame];\r\n\t\t\tlet percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1,\r\n\t\t\t\t1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\r\n\r\n\t\t\tx += (frames[frame + TranslateTimeline.X] - x) * percent;\r\n\t\t\ty += (frames[frame + TranslateTimeline.Y] - y) * percent;\r\n\t\t}\r\n\t\tswitch (blend) {\r\n\t\tcase MixBlend.setup:\r\n\t\t\tbone.x = bone.data.x + x * alpha;\r\n\t\t\tbone.y = bone.data.y + y * alpha;\r\n\t\t\tbreak;\r\n\t\tcase MixBlend.first:\r\n\t\tcase MixBlend.replace:\r\n\t\t\tbone.x += (bone.data.x + x - bone.x) * alpha;\r\n\t\t\tbone.y += (bone.data.y + y - bone.y) * alpha;\r\n\t\t\tbreak;\r\n\t\tcase MixBlend.add:\r\n\t\t\tbone.x += x * alpha;\r\n\t\t\tbone.y += y * alpha;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}. */\r\nexport class ScaleTimeline extends TranslateTimeline {\r\n\tconstructor (frameCount: number) {\r\n\t\tsuper(frameCount);\r\n\t}\r\n\r\n\tgetPropertyId () {\r\n\t\treturn (TimelineType.scale << 24) + this.boneIndex;\r\n\t}\r\n\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n\t\tlet frames = this.frames;\r\n\r\n\t\tlet bone = skeleton.bones[this.boneIndex];\r\n\t\tif (!bone.active) return;\r\n\t\tif (time < frames[0]) {\r\n\t\t\tswitch (blend) {\r\n\t\t\tcase MixBlend.setup:\r\n\t\t\t\tbone.scaleX = bone.data.scaleX;\r\n\t\t\t\tbone.scaleY = bone.data.scaleY;\r\n\t\t\t\treturn;\r\n\t\t\tcase MixBlend.first:\r\n\t\t\t\tbone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n\t\t\t\tbone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet x = 0, y = 0;\r\n\t\tif (time >= frames[frames.length - ScaleTimeline.ENTRIES]) { // Time is after last frame.\r\n\t\t\tx = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\r\n\t\t\ty = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\r\n\t\t} else {\r\n\t\t\t// Interpolate between the previous frame and the current frame.\r\n\t\t\tlet frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\r\n\t\t\tx = frames[frame + ScaleTimeline.PREV_X];\r\n\t\t\ty = frames[frame + ScaleTimeline.PREV_Y];\r\n\t\t\tlet frameTime = frames[frame];\r\n\t\t\tlet percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1,\r\n\t\t\t\t1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\r\n\r\n\t\t\tx = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\r\n\t\t\ty = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\r\n\t\t}\r\n\t\tif (alpha == 1) {\r\n\t\t\tif (blend == MixBlend.add) {\r\n\t\t\t\tbone.scaleX += x - bone.data.scaleX;\r\n\t\t\t\tbone.scaleY += y - bone.data.scaleY;\r\n\t\t\t} else {\r\n\t\t\t\tbone.scaleX = x;\r\n\t\t\t\tbone.scaleY = y;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlet bx = 0, by = 0;\r\n\t\t\tif (direction == MixDirection.mixOut) {\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\tbx = bone.data.scaleX;\r\n\t\t\t\t\tby = bone.data.scaleY;\r\n\t\t\t\t\tbone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n\t\t\t\t\tbone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase MixBlend.first:\r\n\t\t\t\tcase MixBlend.replace:\r\n\t\t\t\t\tbx = bone.scaleX;\r\n\t\t\t\t\tby = bone.scaleY;\r\n\t\t\t\t\tbone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n\t\t\t\t\tbone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase MixBlend.add:\r\n\t\t\t\t\tbx = bone.scaleX;\r\n\t\t\t\t\tby = bone.scaleY;\r\n\t\t\t\t\tbone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\r\n\t\t\t\t\tbone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\tbx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\r\n\t\t\t\t\tby = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\r\n\t\t\t\t\tbone.scaleX = bx + (x - bx) * alpha;\r\n\t\t\t\t\tbone.scaleY = by + (y - by) * alpha;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase MixBlend.first:\r\n\t\t\t\tcase MixBlend.replace:\r\n\t\t\t\t\tbx = Math.abs(bone.scaleX) * MathUtils.signum(x);\r\n\t\t\t\t\tby = Math.abs(bone.scaleY) * MathUtils.signum(y);\r\n\t\t\t\t\tbone.scaleX = bx + (x - bx) * alpha;\r\n\t\t\t\t\tbone.scaleY = by + (y - by) * alpha;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase MixBlend.add:\r\n\t\t\t\t\tbx = MathUtils.signum(x);\r\n\t\t\t\t\tby = MathUtils.signum(y);\r\n\t\t\t\t\tbone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\r\n\t\t\t\t\tbone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}. */\r\nexport class ShearTimeline extends TranslateTimeline {\r\n\tconstructor (frameCount: number) {\r\n\t\tsuper(frameCount);\r\n\t}\r\n\r\n\tgetPropertyId () {\r\n\t\treturn (TimelineType.shear << 24) + this.boneIndex;\r\n\t}\r\n\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n\t\tlet frames = this.frames;\r\n\r\n\t\tlet bone = skeleton.bones[this.boneIndex];\r\n\t\tif (!bone.active) return;\r\n\t\tif (time < frames[0]) {\r\n\t\t\tswitch (blend) {\r\n\t\t\tcase MixBlend.setup:\r\n\t\t\t\tbone.shearX = bone.data.shearX;\r\n\t\t\t\tbone.shearY = bone.data.shearY;\r\n\t\t\t\treturn;\r\n\t\t\tcase MixBlend.first:\r\n\t\t\t\tbone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n\t\t\t\tbone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet x = 0, y = 0;\r\n\t\tif (time >= frames[frames.length - ShearTimeline.ENTRIES]) { // Time is after last frame.\r\n\t\t\tx = frames[frames.length + ShearTimeline.PREV_X];\r\n\t\t\ty = frames[frames.length + ShearTimeline.PREV_Y];\r\n\t\t} else {\r\n\t\t\t// Interpolate between the previous frame and the current frame.\r\n\t\t\tlet frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\r\n\t\t\tx = frames[frame + ShearTimeline.PREV_X];\r\n\t\t\ty = frames[frame + ShearTimeline.PREV_Y];\r\n\t\t\tlet frameTime = frames[frame];\r\n\t\t\tlet percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1,\r\n\t\t\t\t1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\r\n\r\n\t\t\tx = x + (frames[frame + ShearTimeline.X] - x) * percent;\r\n\t\t\ty = y + (frames[frame + ShearTimeline.Y] - y) * percent;\r\n\t\t}\r\n\t\tswitch (blend) {\r\n\t\tcase MixBlend.setup:\r\n\t\t\tbone.shearX = bone.data.shearX + x * alpha;\r\n\t\t\tbone.shearY = bone.data.shearY + y * alpha;\r\n\t\t\tbreak;\r\n\t\tcase MixBlend.first:\r\n\t\tcase MixBlend.replace:\r\n\t\t\tbone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n\t\t\tbone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n\t\t\tbreak;\r\n\t\tcase MixBlend.add:\r\n\t\t\tbone.shearX += x * alpha;\r\n\t\t\tbone.shearY += y * alpha;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color}. */\r\nexport class ColorTimeline extends CurveTimeline {\r\n\tstatic ENTRIES = 5;\r\n\tstatic PREV_TIME = -5; static PREV_R = -4; static PREV_G = -3; static PREV_B = -2; static PREV_A = -1;\r\n\tstatic R = 1; static G = 2; static B = 3; static A = 4;\r\n\r\n\t/** The index of the slot in {@link Skeleton#slots} that will be changed. */\r\n\tslotIndex: number;\r\n\r\n\t/** The time in seconds, red, green, blue, and alpha values for each key frame. */\r\n\tframes: ArrayLike<number>; // time, r, g, b, a, ...\r\n\r\n\tconstructor (frameCount: number) {\r\n\t\tsuper(frameCount);\r\n\t\tthis.frames = Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\r\n\t}\r\n\r\n\tgetPropertyId () {\r\n\t\treturn (TimelineType.color << 24) + this.slotIndex;\r\n\t}\r\n\r\n\t/** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\r\n\tsetFrame (frameIndex: number, time: number, r: number, g: number, b: number, a: number) {\r\n\t\tframeIndex *= ColorTimeline.ENTRIES;\r\n\t\tthis.frames[frameIndex] = time;\r\n\t\tthis.frames[frameIndex + ColorTimeline.R] = r;\r\n\t\tthis.frames[frameIndex + ColorTimeline.G] = g;\r\n\t\tthis.frames[frameIndex + ColorTimeline.B] = b;\r\n\t\tthis.frames[frameIndex + ColorTimeline.A] = a;\r\n\t}\r\n\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n\t\tlet slot = skeleton.slots[this.slotIndex];\r\n\t\tif (!slot.bone.active) return;\r\n\t\tlet frames = this.frames;\r\n\t\tif (time < frames[0]) {\r\n\t\t\tswitch (blend) {\r\n\t\t\tcase MixBlend.setup:\r\n\t\t\t\tslot.color.setFromColor(slot.data.color);\r\n\t\t\t\treturn;\r\n\t\t\tcase MixBlend.first:\r\n\t\t\t\tlet color = slot.color, setup = slot.data.color;\r\n\t\t\t\tcolor.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha,\r\n\t\t\t\t\t(setup.a - color.a) * alpha);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet r = 0, g = 0, b = 0, a = 0;\r\n\t\tif (time >= frames[frames.length - ColorTimeline.ENTRIES]) { // Time is after last frame.\r\n\t\t\tlet i = frames.length;\r\n\t\t\tr = frames[i + ColorTimeline.PREV_R];\r\n\t\t\tg = frames[i + ColorTimeline.PREV_G];\r\n\t\t\tb = frames[i + ColorTimeline.PREV_B];\r\n\t\t\ta = frames[i + ColorTimeline.PREV_A];\r\n\t\t} else {\r\n\t\t\t// Interpolate between the previous frame and the current frame.\r\n\t\t\tlet frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\r\n\t\t\tr = frames[frame + ColorTimeline.PREV_R];\r\n\t\t\tg = frames[frame + ColorTimeline.PREV_G];\r\n\t\t\tb = frames[frame + ColorTimeline.PREV_B];\r\n\t\t\ta = frames[frame + ColorTimeline.PREV_A];\r\n\t\t\tlet frameTime = frames[frame];\r\n\t\t\tlet percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1,\r\n\t\t\t\t1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\r\n\r\n\t\t\tr += (frames[frame + ColorTimeline.R] - r) * percent;\r\n\t\t\tg += (frames[frame + ColorTimeline.G] - g) * percent;\r\n\t\t\tb += (frames[frame + ColorTimeline.B] - b) * percent;\r\n\t\t\ta += (frames[frame + ColorTimeline.A] - a) * percent;\r\n\t\t}\r\n\t\tif (alpha == 1)\r\n\t\t\tslot.color.set(r, g, b, a);\r\n\t\telse {\r\n\t\t\tlet color = slot.color;\r\n\t\t\tif (blend == MixBlend.setup) color.setFromColor(slot.data.color);\r\n\t\t\tcolor.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting. */\r\nexport class TwoColorTimeline extends CurveTimeline {\r\n\tstatic ENTRIES = 8;\r\n\tstatic PREV_TIME = -8; static PREV_R = -7; static PREV_G = -6; static PREV_B = -5; static PREV_A = -4;\r\n\tstatic PREV_R2 = -3; static PREV_G2 = -2; static PREV_B2 = -1;\r\n\tstatic R = 1; static G = 2; static B = 3; static A = 4; static R2 = 5; static G2 = 6; static B2 = 7;\r\n\r\n\t/** The index of the slot in {@link Skeleton#slots()} that will be changed. The {@link Slot#darkColor()} must not be\r\n\t * null. */\r\n\tslotIndex: number;\r\n\r\n\t/** The time in seconds, red, green, blue, and alpha values of the color, red, green, blue of the dark color, for each key frame. */\r\n\tframes: ArrayLike<number>; // time, r, g, b, a, r2, g2, b2, ...\r\n\r\n\tconstructor (frameCount: number) {\r\n\t\tsuper(frameCount);\r\n\t\tthis.frames = Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\r\n\t}\r\n\r\n\tgetPropertyId () {\r\n\t\treturn (TimelineType.twoColor << 24) + this.slotIndex;\r\n\t}\r\n\r\n\t/** Sets the time in seconds, light, and dark colors for the specified key frame. */\r\n\tsetFrame (frameIndex: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\r\n\t\tframeIndex *= TwoColorTimeline.ENTRIES;\r\n\t\tthis.frames[frameIndex] = time;\r\n\t\tthis.frames[frameIndex + TwoColorTimeline.R] = r;\r\n\t\tthis.frames[frameIndex + TwoColorTimeline.G] = g;\r\n\t\tthis.frames[frameIndex + TwoColorTimeline.B] = b;\r\n\t\tthis.frames[frameIndex + TwoColorTimeline.A] = a;\r\n\t\tthis.frames[frameIndex + TwoColorTimeline.R2] = r2;\r\n\t\tthis.frames[frameIndex + TwoColorTimeline.G2] = g2;\r\n\t\tthis.frames[frameIndex + TwoColorTimeline.B2] = b2;\r\n\t}\r\n\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n\t\tlet slot = skeleton.slots[this.slotIndex];\r\n\t\tif (!slot.bone.active) return;\r\n\t\tlet frames = this.frames;\r\n\t\tif (time < frames[0]) {\r\n\t\t\tswitch (blend) {\r\n\t\t\tcase MixBlend.setup:\r\n\t\t\t\tslot.color.setFromColor(slot.data.color);\r\n\t\t\t\tslot.darkColor.setFromColor(slot.data.darkColor);\r\n\t\t\t\treturn;\r\n\t\t\tcase MixBlend.first:\r\n\t\t\t\tlet light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;\r\n\t\t\t\tlight.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha,\r\n\t\t\t\t\t(setupLight.a - light.a) * alpha);\r\n\t\t\t\tdark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\r\n\t\tif (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) { // Time is after last frame.\r\n\t\t\tlet i = frames.length;\r\n\t\t\tr = frames[i + TwoColorTimeline.PREV_R];\r\n\t\t\tg = frames[i + TwoColorTimeline.PREV_G];\r\n\t\t\tb = frames[i + TwoColorTimeline.PREV_B];\r\n\t\t\ta = frames[i + TwoColorTimeline.PREV_A];\r\n\t\t\tr2 = frames[i + TwoColorTimeline.PREV_R2];\r\n\t\t\tg2 = frames[i + TwoColorTimeline.PREV_G2];\r\n\t\t\tb2 = frames[i + TwoColorTimeline.PREV_B2];\r\n\t\t} else {\r\n\t\t\t// Interpolate between the previous frame and the current frame.\r\n\t\t\tlet frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\r\n\t\t\tr = frames[frame + TwoColorTimeline.PREV_R];\r\n\t\t\tg = frames[frame + TwoColorTimeline.PREV_G];\r\n\t\t\tb = frames[frame + TwoColorTimeline.PREV_B];\r\n\t\t\ta = frames[frame + TwoColorTimeline.PREV_A];\r\n\t\t\tr2 = frames[frame + TwoColorTimeline.PREV_R2];\r\n\t\t\tg2 = frames[frame + TwoColorTimeline.PREV_G2];\r\n\t\t\tb2 = frames[frame + TwoColorTimeline.PREV_B2];\r\n\t\t\tlet frameTime = frames[frame];\r\n\t\t\tlet percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1,\r\n\t\t\t\t1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\r\n\r\n\t\t\tr += (frames[frame + TwoColorTimeline.R] - r) * percent;\r\n\t\t\tg += (frames[frame + TwoColorTimeline.G] - g) * percent;\r\n\t\t\tb += (frames[frame + TwoColorTimeline.B] - b) * percent;\r\n\t\t\ta += (frames[frame + TwoColorTimeline.A] - a) * percent;\r\n\t\t\tr2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\r\n\t\t\tg2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\r\n\t\t\tb2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\r\n\t\t}\r\n\t\tif (alpha == 1) {\r\n\t\t\tslot.color.set(r, g, b, a);\r\n\t\t\tslot.darkColor.set(r2, g2, b2, 1);\r\n\t\t} else {\r\n\t\t\tlet light = slot.color, dark = slot.darkColor;\r\n\t\t\tif (blend == MixBlend.setup) {\r\n\t\t\t\tlight.setFromColor(slot.data.color);\r\n\t\t\t\tdark.setFromColor(slot.data.darkColor);\r\n\t\t\t}\r\n\t\t\tlight.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\r\n\t\t\tdark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** Changes a slot's {@link Slot#attachment}. */\r\nexport class AttachmentTimeline implements Timeline {\r\n\t/** The index of the slot in {@link Skeleton#slots} that will be changed. */\r\n\tslotIndex: number;\r\n\r\n\t/** The time in seconds for each key frame. */\r\n\tframes: ArrayLike<number> // time, ...\r\n\r\n\t/** The attachment name for each key frame. May contain null values to clear the attachment. */\r\n\tattachmentNames: Array<string>;\r\n\r\n\tconstructor (frameCount: number) {\r\n\t\tthis.frames = Utils.newFloatArray(frameCount);\r\n\t\tthis.attachmentNames = new Array<string>(frameCount);\r\n\t}\r\n\r\n\tgetPropertyId () {\r\n\t\treturn (TimelineType.attachment << 24) + this.slotIndex;\r\n\t}\r\n\r\n\t/** The number of key frames for this timeline. */\r\n\tgetFrameCount () {\r\n\t\treturn this.frames.length;\r\n\t}\r\n\r\n\t/** Sets the time in seconds and the attachment name for the specified key frame. */\r\n\tsetFrame (frameIndex: number, time: number, attachmentName: string) {\r\n\t\tthis.frames[frameIndex] = time;\r\n\t\tthis.attachmentNames[frameIndex] = attachmentName;\r\n\t}\r\n\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n\t\tlet slot = skeleton.slots[this.slotIndex];\r\n\t\tif (!slot.bone.active) return;\r\n\t\tif (direction == MixDirection.mixOut) {\r\n\t\t\tif (blend == MixBlend.setup)\r\n\t\t\t\tthis.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet frames = this.frames;\r\n\t\tif (time < frames[0]) {\r\n\t\t\tif (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet frameIndex = 0;\r\n\t\tif (time >= frames[frames.length - 1]) // Time is after last frame.\r\n\t\t\tframeIndex = frames.length - 1;\r\n\t\telse\r\n\t\t\tframeIndex = Animation.binarySearch(frames, time, 1) - 1;\r\n\r\n\t\tlet attachmentName = this.attachmentNames[frameIndex];\r\n\t\tskeleton.slots[this.slotIndex]\r\n\t\t\t.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n\t}\r\n\r\n\tsetAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string) {\r\n\t\tslot.attachment = attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName);\r\n\t}\r\n}\r\n\r\nlet zeros : ArrayLike<number> = null;\r\n\r\n/** Changes a slot's {@link Slot#deform} to deform a {@link VertexAttachment}. */\r\nexport class DeformTimeline extends CurveTimeline {\r\n\t/** The index of the slot in {@link Skeleton#getSlots()} that will be changed. */\r\n\tslotIndex: number;\r\n\r\n\t/** The attachment that will be deformed. */\r\n\tattachment: VertexAttachment;\r\n\r\n\t/** The time in seconds for each key frame. */\r\n\tframes: ArrayLike<number>; // time, ...\r\n\r\n\t/** The vertices for each key frame. */\r\n\tframeVertices: Array<ArrayLike<number>>;\r\n\r\n\tconstructor (frameCount: number) {\r\n\t\tsuper(frameCount);\r\n\t\tthis.frames = Utils.newFloatArray(frameCount);\r\n\t\tthis.frameVertices = new Array<ArrayLike<number>>(frameCount);\r\n\t\tif (zeros == null) zeros = Utils.newFloatArray(64);\r\n\t}\r\n\r\n\tgetPropertyId () {\r\n\t\treturn (TimelineType.deform << 27) + + this.attachment.id + this.slotIndex;\r\n\t}\r\n\r\n\t/** Sets the time in seconds and the vertices for the specified key frame.\r\n\t * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\r\n\tsetFrame (frameIndex: number, time: number, vertices: ArrayLike<number>) {\r\n\t\tthis.frames[frameIndex] = time;\r\n\t\tthis.frameVertices[frameIndex] = vertices;\r\n\t}\r\n\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n\t\tlet slot: Slot = skeleton.slots[this.slotIndex];\r\n\t\tif (!slot.bone.active) return;\r\n\t\tlet slotAttachment: Attachment = slot.getAttachment();\r\n\t\tif (!(slotAttachment instanceof VertexAttachment) || !((<VertexAttachment>slotAttachment).deformAttachment == this.attachment)) return;\r\n\r\n\t\tlet deformArray: Array<number> = slot.deform;\r\n\t\tif (deformArray.length == 0) blend = MixBlend.setup;\r\n\r\n\t\tlet frameVertices = this.frameVertices;\r\n\t\tlet vertexCount = frameVertices[0].length;\r\n\r\n\t\tlet frames = this.frames;\r\n\t\tif (time < frames[0]) {\r\n\t\t\tlet vertexAttachment = <VertexAttachment>slotAttachment;\r\n\t\t\tswitch (blend) {\r\n\t\t\tcase MixBlend.setup:\r\n\t\t\t\tdeformArray.length = 0;\r\n\t\t\t\treturn;\r\n\t\t\tcase MixBlend.first:\r\n\t\t\t\tif (alpha == 1) {\r\n\t\t\t\t\tdeformArray.length = 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tlet deform: Array<number> = Utils.setArraySize(deformArray, vertexCount);\r\n\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\t// Unweighted vertex positions.\r\n\t\t\t\t\tlet setupVertices = vertexAttachment.vertices;\r\n\t\t\t\t\tfor (var i = 0; i < vertexCount; i++)\r\n\t\t\t\t\t\tdeform[i] += (setupVertices[i] - deform[i]) * alpha;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Weighted deform offsets.\r\n\t\t\t\t\talpha = 1 - alpha;\r\n\t\t\t\t\tfor (var i = 0; i < vertexCount; i++)\r\n\t\t\t\t\t\tdeform[i] *= alpha;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet deform: Array<number> = Utils.setArraySize(deformArray, vertexCount);\r\n\t\tif (time >= frames[frames.length - 1]) { // Time is after last frame.\r\n\t\t\tlet lastVertices = frameVertices[frames.length - 1];\r\n\t\t\tif (alpha == 1) {\r\n\t\t\t\tif (blend == MixBlend.add) {\r\n\t\t\t\t\tlet vertexAttachment = slotAttachment as VertexAttachment;\r\n\t\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\t\t// Unweighted vertex positions, with alpha.\r\n\t\t\t\t\t\tlet setupVertices = vertexAttachment.vertices;\r\n\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\r\n\t\t\t\t\t\t\tdeform[i] += lastVertices[i] - setupVertices[i];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Weighted deform offsets, with alpha.\r\n\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++)\r\n\t\t\t\t\t\t\tdeform[i] += lastVertices[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tUtils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\tcase MixBlend.setup: {\r\n\t\t\t\t\tlet vertexAttachment = slotAttachment as VertexAttachment;\r\n\t\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\t\t// Unweighted vertex positions, with alpha.\r\n\t\t\t\t\t\tlet setupVertices = vertexAttachment.vertices;\r\n\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\r\n\t\t\t\t\t\t\tlet setup = setupVertices[i];\r\n\t\t\t\t\t\t\tdeform[i] = setup + (lastVertices[i] - setup) * alpha;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Weighted deform offsets, with alpha.\r\n\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++)\r\n\t\t\t\t\t\t\tdeform[i] = lastVertices[i] * alpha;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase MixBlend.first:\r\n\t\t\t\tcase MixBlend.replace:\r\n\t\t\t\t\tfor (let i = 0; i < vertexCount; i++)\r\n\t\t\t\t\t\tdeform[i] += (lastVertices[i] - deform[i]) * alpha;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase MixBlend.add:\r\n\t\t\t\t\tlet vertexAttachment = slotAttachment as VertexAttachment;\r\n\t\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\t\t// Unweighted vertex positions, with alpha.\r\n\t\t\t\t\t\tlet setupVertices = vertexAttachment.vertices;\r\n\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\r\n\t\t\t\t\t\t\tdeform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Weighted deform offsets, with alpha.\r\n\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++)\r\n\t\t\t\t\t\t\tdeform[i] += lastVertices[i] * alpha;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Interpolate between the previous frame and the current frame.\r\n\t\tlet frame = Animation.binarySearch(frames, time);\r\n\t\tlet prevVertices = frameVertices[frame - 1];\r\n\t\tlet nextVertices = frameVertices[frame];\r\n\t\tlet frameTime = frames[frame];\r\n\t\tlet percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\r\n\r\n\t\tif (alpha == 1) {\r\n\t\t\tif (blend == MixBlend.add) {\r\n\t\t\t\tlet vertexAttachment = slotAttachment as VertexAttachment;\r\n\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\t// Unweighted vertex positions, with alpha.\r\n\t\t\t\t\tlet setupVertices = vertexAttachment.vertices;\r\n\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\r\n\t\t\t\t\t\tlet prev = prevVertices[i];\r\n\t\t\t\t\t\tdeform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Weighted deform offsets, with alpha.\r\n\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\r\n\t\t\t\t\t\tlet prev = prevVertices[i];\r\n\t\t\t\t\t\tdeform[i] += prev + (nextVertices[i] - prev) * percent;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\r\n\t\t\t\t\tlet prev = prevVertices[i];\r\n\t\t\t\t\tdeform[i] = prev + (nextVertices[i] - prev) * percent;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tswitch (blend) {\r\n\t\t\tcase MixBlend.setup: {\r\n\t\t\t\tlet vertexAttachment = slotAttachment as VertexAttachment;\r\n\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\t// Unweighted vertex positions, with alpha.\r\n\t\t\t\t\tlet setupVertices = vertexAttachment.vertices;\r\n\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\r\n\t\t\t\t\t\tlet prev = prevVertices[i], setup = setupVertices[i];\r\n\t\t\t\t\t\tdeform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Weighted deform offsets, with alpha.\r\n\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\r\n\t\t\t\t\t\tlet prev = prevVertices[i];\r\n\t\t\t\t\t\tdeform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase MixBlend.first:\r\n\t\t\tcase MixBlend.replace:\r\n\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\r\n\t\t\t\t\tlet prev = prevVertices[i];\r\n\t\t\t\t\tdeform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MixBlend.add:\r\n\t\t\t\tlet vertexAttachment = slotAttachment as VertexAttachment;\r\n\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\t// Unweighted vertex positions, with alpha.\r\n\t\t\t\t\tlet setupVertices = vertexAttachment.vertices;\r\n\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\r\n\t\t\t\t\t\tlet prev = prevVertices[i];\r\n\t\t\t\t\t\tdeform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Weighted deform offsets, with alpha.\r\n\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\r\n\t\t\t\t\t\tlet prev = prevVertices[i];\r\n\t\t\t\t\t\tdeform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** Fires an {@link Event} when specific animation times are reached. */\r\nexport class EventTimeline implements Timeline {\r\n\t/** The time in seconds for each key frame. */\r\n\tframes: ArrayLike<number>; // time, ...\r\n\r\n\t/** The event for each key frame. */\r\n\tevents: Array<Event>;\r\n\r\n\tconstructor (frameCount: number) {\r\n\t\tthis.frames = Utils.newFloatArray(frameCount);\r\n\t\tthis.events = new Array<Event>(frameCount);\r\n\t}\r\n\r\n\tgetPropertyId () {\r\n\t\treturn TimelineType.event << 24;\r\n\t}\r\n\r\n\t/** The number of key frames for this timeline. */\r\n\tgetFrameCount () {\r\n\t\treturn this.frames.length;\r\n\t}\r\n\r\n\t/** Sets the time in seconds and the event for the specified key frame. */\r\n\tsetFrame (frameIndex: number, event: Event) {\r\n\t\tthis.frames[frameIndex] = event.time;\r\n\t\tthis.events[frameIndex] = event;\r\n\t}\r\n\r\n\t/** Fires events for frames > `lastTime` and <= `time`. */\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n\t\tif (firedEvents == null) return;\r\n\t\tlet frames = this.frames;\r\n\t\tlet frameCount = this.frames.length;\r\n\r\n\t\tif (lastTime > time) { // Fire events after last time for looped animations.\r\n\t\t\tthis.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\r\n\t\t\tlastTime = -1;\r\n\t\t} else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\r\n\t\t\treturn;\r\n\t\tif (time < frames[0]) return; // Time is before first frame.\r\n\r\n\t\tlet frame = 0;\r\n\t\tif (lastTime < frames[0])\r\n\t\t\tframe = 0;\r\n\t\telse {\r\n\t\t\tframe = Animation.binarySearch(frames, lastTime);\r\n\t\t\tlet frameTime = frames[frame];\r\n\t\t\twhile (frame > 0) { // Fire multiple events with the same frame.\r\n\t\t\t\tif (frames[frame - 1] != frameTime) break;\r\n\t\t\t\tframe--;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (; frame < frameCount && time >= frames[frame]; frame++)\r\n\t\t\tfiredEvents.push(this.events[frame]);\r\n\t}\r\n}\r\n\r\n/** Changes a skeleton's {@link Skeleton#drawOrder}. */\r\nexport class DrawOrderTimeline implements Timeline {\r\n\t/** The time in seconds for each key frame. */\r\n\tframes: ArrayLike<number>; // time, ...\r\n\r\n\t/** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */\r\n\tdrawOrders: Array<Array<number>>;\r\n\r\n\tconstructor (frameCount: number) {\r\n\t\tthis.frames = Utils.newFloatArray(frameCount);\r\n\t\tthis.drawOrders = new Array<Array<number>>(frameCount);\r\n\t}\r\n\r\n\tgetPropertyId () {\r\n\t\treturn TimelineType.drawOrder << 24;\r\n\t}\r\n\r\n\t/** The number of key frames for this timeline. */\r\n\tgetFrameCount () {\r\n\t\treturn this.frames.length;\r\n\t}\r\n\r\n\t/** Sets the time in seconds and the draw order for the specified key frame.\r\n\t * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\r\n\t *           draw order. */\r\n\tsetFrame (frameIndex: number, time: number, drawOrder: Array<number>) {\r\n\t\tthis.frames[frameIndex] = time;\r\n\t\tthis.drawOrders[frameIndex] = drawOrder;\r\n\t}\r\n\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n\t\tlet drawOrder: Array<Slot> = skeleton.drawOrder;\r\n\t\tlet slots: Array<Slot> = skeleton.slots;\r\n\t\tif (direction == MixDirection.mixOut) {\r\n\t\t\tif (blend == MixBlend.setup) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet frames = this.frames;\r\n\t\tif (time < frames[0]) {\r\n\t\t\tif (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet frame = 0;\r\n\t\tif (time >= frames[frames.length - 1]) // Time is after last frame.\r\n\t\t\tframe = frames.length - 1;\r\n\t\telse\r\n\t\t\tframe = Animation.binarySearch(frames, time) - 1;\r\n\r\n\t\tlet drawOrderToSetupIndex = this.drawOrders[frame];\r\n\t\tif (drawOrderToSetupIndex == null)\r\n\t\t\tUtils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\r\n\t\telse {\r\n\t\t\tfor (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n\t\t\t\tdrawOrder[i] = slots[drawOrderToSetupIndex[i]];\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** Changes an IK constraint's {@link IkConstraint#mix}, {@link IkConstraint#softness},\r\n * {@link IkConstraint#bendDirection}, {@link IkConstraint#stretch}, and {@link IkConstraint#compress}. */\r\nexport class IkConstraintTimeline extends CurveTimeline {\r\n\tstatic ENTRIES = 6;\r\n\tstatic PREV_TIME = -6; static PREV_MIX = -5; static PREV_SOFTNESS = -4; static PREV_BEND_DIRECTION = -3; static PREV_COMPRESS = -2; static PREV_STRETCH = -1;\r\n\tstatic MIX = 1; static SOFTNESS = 2; static BEND_DIRECTION = 3; static COMPRESS = 4; static STRETCH = 5;\r\n\r\n\t/** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\r\n\tikConstraintIndex: number;\r\n\r\n\t/** The time in seconds, mix, softness, bend direction, compress, and stretch for each key frame. */\r\n\tframes: ArrayLike<number>; // time, mix, softness, bendDirection, compress, stretch, ...\r\n\r\n\tconstructor (frameCount: number) {\r\n\t\tsuper(frameCount);\r\n\t\tthis.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\r\n\t}\r\n\r\n\tgetPropertyId () {\r\n\t\treturn (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\r\n\t}\r\n\r\n\t/** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\r\n\tsetFrame (frameIndex: number, time: number, mix: number, softness: number, bendDirection: number, compress: boolean, stretch: boolean) {\r\n\t\tframeIndex *= IkConstraintTimeline.ENTRIES;\r\n\t\tthis.frames[frameIndex] = time;\r\n\t\tthis.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\r\n\t\tthis.frames[frameIndex + IkConstraintTimeline.SOFTNESS] = softness;\r\n\t\tthis.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\r\n\t\tthis.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\r\n\t\tthis.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\r\n\t}\r\n\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n\t\tlet frames = this.frames;\r\n\t\tlet constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\t\tif (!constraint.active) return;\r\n\t\tif (time < frames[0]) {\r\n\t\t\tswitch (blend) {\r\n\t\t\tcase MixBlend.setup:\r\n\t\t\t\tconstraint.mix = constraint.data.mix;\r\n\t\t\t\tconstraint.softness = constraint.data.softness;\r\n\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\r\n\t\t\t\tconstraint.compress = constraint.data.compress;\r\n\t\t\t\tconstraint.stretch = constraint.data.stretch;\r\n\t\t\t\treturn;\r\n\t\t\tcase MixBlend.first:\r\n\t\t\t\tconstraint.mix += (constraint.data.mix - constraint.mix) * alpha;\r\n\t\t\t\tconstraint.softness += (constraint.data.softness - constraint.softness) * alpha;\r\n\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\r\n\t\t\t\tconstraint.compress = constraint.data.compress;\r\n\t\t\t\tconstraint.stretch = constraint.data.stretch;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) { // Time is after last frame.\r\n\t\t\tif (blend == MixBlend.setup) {\r\n\t\t\t\tconstraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\r\n\t\t\t\tconstraint.softness = constraint.data.softness\r\n\t\t\t\t\t+ (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;\r\n\t\t\t\tif (direction == MixDirection.mixOut) {\r\n\t\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\r\n\t\t\t\t\tconstraint.compress = constraint.data.compress;\r\n\t\t\t\t\tconstraint.stretch = constraint.data.stretch;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconstraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION]\r\n\t\t\t\t\tconstraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n\t\t\t\t\tconstraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconstraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\r\n\t\t\t\tconstraint.softness += (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;\r\n\t\t\t\tif (direction == MixDirection.mixIn) {\r\n\t\t\t\t\tconstraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n\t\t\t\t\tconstraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n\t\t\t\t\tconstraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Interpolate between the previous frame and the current frame.\r\n\t\tlet frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\r\n\t\tlet mix = frames[frame + IkConstraintTimeline.PREV_MIX];\r\n\t\tlet softness = frames[frame + IkConstraintTimeline.PREV_SOFTNESS];\r\n\t\tlet frameTime = frames[frame];\r\n\t\tlet percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1,\r\n\t\t\t1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\r\n\r\n\t\tif (blend == MixBlend.setup) {\r\n\t\t\tconstraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\r\n\t\t\tconstraint.softness = constraint.data.softness\r\n\t\t\t\t+ (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha;\r\n\t\t\tif (direction == MixDirection.mixOut) {\r\n\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\r\n\t\t\t\tconstraint.compress = constraint.data.compress;\r\n\t\t\t\tconstraint.stretch = constraint.data.stretch;\r\n\t\t\t} else {\r\n\t\t\t\tconstraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n\t\t\t\tconstraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n\t\t\t\tconstraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tconstraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\r\n\t\t\tconstraint.softness += (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.softness) * alpha;\r\n\t\t\tif (direction == MixDirection.mixIn) {\r\n\t\t\t\tconstraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n\t\t\t\tconstraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n\t\t\t\tconstraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** Changes a transform constraint's {@link TransformConstraint#rotateMix}, {@link TransformConstraint#translateMix},\r\n * {@link TransformConstraint#scaleMix}, and {@link TransformConstraint#shearMix}. */\r\nexport class TransformConstraintTimeline extends CurveTimeline {\r\n\tstatic ENTRIES = 5;\r\n\tstatic PREV_TIME = -5; static PREV_ROTATE = -4; static PREV_TRANSLATE = -3; static PREV_SCALE = -2; static PREV_SHEAR = -1;\r\n\tstatic ROTATE = 1; static TRANSLATE = 2; static SCALE = 3; static SHEAR = 4;\r\n\r\n\t/** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\r\n\ttransformConstraintIndex: number;\r\n\r\n\t/** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for each key frame. */\r\n\tframes: ArrayLike<number>; // time, rotate mix, translate mix, scale mix, shear mix, ...\r\n\r\n\tconstructor (frameCount: number) {\r\n\t\tsuper(frameCount);\r\n\t\tthis.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\r\n\t}\r\n\r\n\tgetPropertyId () {\r\n\t\treturn (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\r\n\t}\r\n\r\n\t/** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\r\n\tsetFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number) {\r\n\t\tframeIndex *= TransformConstraintTimeline.ENTRIES;\r\n\t\tthis.frames[frameIndex] = time;\r\n\t\tthis.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\r\n\t\tthis.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\r\n\t\tthis.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\r\n\t\tthis.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\r\n\t}\r\n\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n\t\tlet frames = this.frames;\r\n\r\n\t\tlet constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n\t\tif (!constraint.active) return;\r\n\t\tif (time < frames[0]) {\r\n\t\t\tlet data = constraint.data;\r\n\t\t\tswitch (blend) {\r\n\t\t\tcase MixBlend.setup:\r\n\t\t\t\tconstraint.rotateMix = data.rotateMix;\r\n\t\t\t\tconstraint.translateMix = data.translateMix;\r\n\t\t\t\tconstraint.scaleMix = data.scaleMix;\r\n\t\t\t\tconstraint.shearMix = data.shearMix;\r\n\t\t\t\treturn;\r\n\t\t\tcase MixBlend.first:\r\n\t\t\t\tconstraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\r\n\t\t\t\tconstraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\r\n\t\t\t\tconstraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\r\n\t\t\t\tconstraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet rotate = 0, translate = 0, scale = 0, shear = 0;\r\n\t\tif (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) { // Time is after last frame.\r\n\t\t\tlet i = frames.length;\r\n\t\t\trotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\r\n\t\t\ttranslate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\r\n\t\t\tscale = frames[i + TransformConstraintTimeline.PREV_SCALE];\r\n\t\t\tshear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\r\n\t\t} else {\r\n\t\t\t// Interpolate between the previous frame and the current frame.\r\n\t\t\tlet frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\r\n\t\t\trotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\r\n\t\t\ttranslate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\r\n\t\t\tscale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\r\n\t\t\tshear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\r\n\t\t\tlet frameTime = frames[frame];\r\n\t\t\tlet percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1,\r\n\t\t\t\t1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\r\n\r\n\t\t\trotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\r\n\t\t\ttranslate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\r\n\t\t\tscale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\r\n\t\t\tshear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\r\n\t\t}\r\n\t\tif (blend == MixBlend.setup) {\r\n\t\t\tlet data = constraint.data;\r\n\t\t\tconstraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\r\n\t\t\tconstraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\r\n\t\t\tconstraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\r\n\t\t\tconstraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\r\n\t\t} else {\r\n\t\t\tconstraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n\t\t\tconstraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n\t\t\tconstraint.scaleMix += (scale - constraint.scaleMix) * alpha;\r\n\t\t\tconstraint.shearMix += (shear - constraint.shearMix) * alpha;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** Changes a path constraint's {@link PathConstraint#position}. */\r\nexport class PathConstraintPositionTimeline extends CurveTimeline {\r\n\tstatic ENTRIES = 2;\r\n\tstatic PREV_TIME = -2; static PREV_VALUE = -1;\r\n\tstatic VALUE = 1;\r\n\r\n\t/** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\r\n\tpathConstraintIndex: number;\r\n\r\n\t/** The time in seconds and path constraint position for each key frame. */\r\n\tframes: ArrayLike<number>; // time, position, ...\r\n\r\n\tconstructor (frameCount: number) {\r\n\t\tsuper(frameCount);\r\n\t\tthis.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\r\n\t}\r\n\r\n\tgetPropertyId () {\r\n\t\treturn (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\r\n\t}\r\n\r\n\t/** Sets the time in seconds and path constraint position for the specified key frame. */\r\n\tsetFrame (frameIndex: number, time: number, value: number) {\r\n\t\tframeIndex *= PathConstraintPositionTimeline.ENTRIES;\r\n\t\tthis.frames[frameIndex] = time;\r\n\t\tthis.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\r\n\t}\r\n\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n\t\tlet frames = this.frames;\r\n\t\tlet constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\t\tif (!constraint.active) return;\r\n\t\tif (time < frames[0]) {\r\n\t\t\tswitch (blend) {\r\n\t\t\tcase MixBlend.setup:\r\n\t\t\t\tconstraint.position = constraint.data.position;\r\n\t\t\t\treturn;\r\n\t\t\tcase MixBlend.first:\r\n\t\t\t\tconstraint.position += (constraint.data.position - constraint.position) * alpha;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet position = 0;\r\n\t\tif (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) // Time is after last frame.\r\n\t\t\tposition = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\r\n\t\telse {\r\n\t\t\t// Interpolate between the previous frame and the current frame.\r\n\t\t\tlet frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\r\n\t\t\tposition = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\r\n\t\t\tlet frameTime = frames[frame];\r\n\t\t\tlet percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1,\r\n\t\t\t\t1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\r\n\r\n\t\t\tposition += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\r\n\t\t}\r\n\t\tif (blend == MixBlend.setup)\r\n\t\t\tconstraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\r\n\t\telse\r\n\t\t\tconstraint.position += (position - constraint.position) * alpha;\r\n\t}\r\n}\r\n\r\n/** Changes a path constraint's {@link PathConstraint#spacing}. */\r\nexport class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\r\n\tconstructor (frameCount: number) {\r\n\t\tsuper(frameCount);\r\n\t}\r\n\r\n\tgetPropertyId () {\r\n\t\treturn (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\r\n\t}\r\n\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n\t\tlet frames = this.frames;\r\n\t\tlet constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\t\tif (!constraint.active) return;\r\n\t\tif (time < frames[0]) {\r\n\t\t\tswitch (blend) {\r\n\t\t\tcase MixBlend.setup:\r\n\t\t\t\tconstraint.spacing = constraint.data.spacing;\r\n\t\t\t\treturn;\r\n\t\t\tcase MixBlend.first:\r\n\t\t\t\tconstraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet spacing = 0;\r\n\t\tif (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) // Time is after last frame.\r\n\t\t\tspacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\r\n\t\telse {\r\n\t\t\t// Interpolate between the previous frame and the current frame.\r\n\t\t\tlet frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\r\n\t\t\tspacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\r\n\t\t\tlet frameTime = frames[frame];\r\n\t\t\tlet percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1,\r\n\t\t\t\t1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\r\n\r\n\t\t\tspacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\r\n\t\t}\r\n\r\n\t\tif (blend == MixBlend.setup)\r\n\t\t\tconstraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\r\n\t\telse\r\n\t\t\tconstraint.spacing += (spacing - constraint.spacing) * alpha;\r\n\t}\r\n}\r\n\r\n/** Changes a transform constraint's {@link PathConstraint#rotateMix} and\r\n * {@link TransformConstraint#translateMix}. */\r\nexport class PathConstraintMixTimeline extends CurveTimeline {\r\n\tstatic ENTRIES = 3;\r\n\tstatic PREV_TIME = -3; static PREV_ROTATE = -2; static PREV_TRANSLATE = -1;\r\n\tstatic ROTATE = 1; static TRANSLATE = 2;\r\n\r\n\t/** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\r\n\tpathConstraintIndex: number;\r\n\r\n\t/** The time in seconds, rotate mix, and translate mix for each key frame. */\r\n\tframes: ArrayLike<number>; // time, rotate mix, translate mix, ...\r\n\r\n\tconstructor (frameCount: number) {\r\n\t\tsuper(frameCount);\r\n\t\tthis.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\r\n\t}\r\n\r\n\tgetPropertyId () {\r\n\t\treturn (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\r\n\t}\r\n\r\n\t/** The time in seconds, rotate mix, and translate mix for the specified key frame. */\r\n\tsetFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number) {\r\n\t\tframeIndex *= PathConstraintMixTimeline.ENTRIES;\r\n\t\tthis.frames[frameIndex] = time;\r\n\t\tthis.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\r\n\t\tthis.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\r\n\t}\r\n\r\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n\t\tlet frames = this.frames;\r\n\t\tlet constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\t\tif (!constraint.active) return;\r\n\t\tif (time < frames[0]) {\r\n\t\t\tswitch (blend) {\r\n\t\t\tcase MixBlend.setup:\r\n\t\t\t\tconstraint.rotateMix = constraint.data.rotateMix;\r\n\t\t\t\tconstraint.translateMix = constraint.data.translateMix;\r\n\t\t\t\treturn;\r\n\t\t\tcase MixBlend.first:\r\n\t\t\t\tconstraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\r\n\t\t\t\tconstraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet rotate = 0, translate = 0;\r\n\t\tif (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) { // Time is after last frame.\r\n\t\t\trotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\r\n\t\t\ttranslate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n\t\t} else {\r\n\t\t\t// Interpolate between the previous frame and the current frame.\r\n\t\t\tlet frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\r\n\t\t\trotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\r\n\t\t\ttranslate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n\t\t\tlet frameTime = frames[frame];\r\n\t\t\tlet percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1,\r\n\t\t\t\t1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\r\n\r\n\t\t\trotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\r\n\t\t\ttranslate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\r\n\t\t}\r\n\r\n\t\tif (blend == MixBlend.setup) {\r\n\t\t\tconstraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\r\n\t\t\tconstraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\r\n\t\t} else {\r\n\t\t\tconstraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n\t\t\tconstraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n\t\t}\r\n\t}\r\n}\r\n","\r\n\r\nimport { Disposable } from \"./Utils\";\r\nimport { Texture, TextureFilter } from \"./Texture\";\r\nimport { TextureWrap, TextureRegion } from \"./Texture\";\r\n\r\n\r\n\texport class TextureAtlas implements Disposable {\r\n\t\tpages = new Array<TextureAtlasPage>();\r\n\t\tregions = new Array<TextureAtlasRegion>();\r\n\r\n\t\tconstructor (atlasText: string, textureLoader: (path: string, width?: number, height?: number) => any) {\r\n\t\t\tthis.load(atlasText, textureLoader);\r\n\t\t}\r\n\r\n\t\tprivate load (atlasText: string, textureLoader: (path: string, width?: number, height?: number) => any) {\r\n\t\t\tif (textureLoader == null)\r\n\t\t\t\tthrow new Error(\"textureLoader cannot be null.\");\r\n\r\n\t\t\tlet reader = new TextureAtlasReader(atlasText);\r\n\t\t\tlet tuple = new Array<string>(4);\r\n\t\t\tlet page:TextureAtlasPage = null;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet line = reader.readLine();\r\n\t\t\t\tif (line == null)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tline = line.trim();\r\n\t\t\t\tif (line.length == 0)\r\n\t\t\t\t\tpage = null;\r\n\t\t\t\telse if (!page) {\r\n\t\t\t\t\tpage = new TextureAtlasPage();\r\n\t\t\t\t\tpage.name = line;\r\n\r\n\t\t\t\t\tif (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.\r\n\t\t\t\t\t\tpage.width = parseInt(tuple[0]);\r\n\t\t\t\t\t\tpage.height = parseInt(tuple[1]);\r\n\t\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// page.format = Format[tuple[0]]; we don't need format in WebGL\r\n\r\n\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\tpage.minFilter = Texture.filterFromString(tuple[0]);\r\n\t\t\t\t\tpage.magFilter = Texture.filterFromString(tuple[1]);\r\n\r\n\t\t\t\t\tlet direction= reader.readValue();\r\n\t\t\t\t\tpage.uWrap = TextureWrap.ClampToEdge;\r\n\t\t\t\t\tpage.vWrap = TextureWrap.ClampToEdge;\r\n\t\t\t\t\tif (direction == \"x\")\r\n\t\t\t\t\t\tpage.uWrap = TextureWrap.Repeat;\r\n\t\t\t\t\telse if (direction == \"y\")\r\n\t\t\t\t\t\tpage.vWrap = TextureWrap.Repeat;\r\n\t\t\t\t\telse if (direction == \"xy\")\r\n\t\t\t\t\t\tpage.uWrap = page.vWrap = TextureWrap.Repeat;\r\n\r\n\t\t\t\t\tpage.texture = textureLoader(line);\r\n\t\t\t\t\tpage.texture.setFilters(page.minFilter, page.magFilter);\r\n\t\t\t\t\tpage.texture.setWraps(page.uWrap, page.vWrap);\r\n\t\t\t\t\tpage.width = page.texture.getImage().width;\r\n\t\t\t\t\tpage.height = page.texture.getImage().height;\r\n\t\t\t\t\tthis.pages.push(page);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet region:TextureAtlasRegion = new TextureAtlasRegion();\r\n\t\t\t\t\tregion.name = line;\r\n\t\t\t\t\tregion.page = page;\r\n\r\n\t\t\t\t\tlet rotateValue = reader.readValue();\r\n\t\t\t\t\tif (rotateValue.toLocaleLowerCase() == \"true\") {\r\n\t\t\t\t\t\tregion.degrees = 90;\r\n\t\t\t\t\t} else if (rotateValue.toLocaleLowerCase() == \"false\") {\r\n\t\t\t\t\t\tregion.degrees = 0;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tregion.degrees = parseFloat(rotateValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tregion.rotate = region.degrees == 90;\r\n\r\n\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\tlet x = parseInt(tuple[0]);\r\n\t\t\t\t\tlet y = parseInt(tuple[1]);\r\n\r\n\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\tlet width = parseInt(tuple[0]);\r\n\t\t\t\t\tlet height = parseInt(tuple[1]);\r\n\r\n\t\t\t\t\tregion.u = x / page.width;\r\n\t\t\t\t\tregion.v = y / page.height;\r\n\t\t\t\t\tif (region.rotate) {\r\n\t\t\t\t\t\tregion.u2 = (x + height) / page.width;\r\n\t\t\t\t\t\tregion.v2 = (y + width) / page.height;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tregion.u2 = (x + width) / page.width;\r\n\t\t\t\t\t\tregion.v2 = (y + height) / page.height;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tregion.x = x;\r\n\t\t\t\t\tregion.y = y;\r\n\t\t\t\t\tregion.width = Math.abs(width);\r\n\t\t\t\t\tregion.height = Math.abs(height);\r\n\r\n\t\t\t\t\tif (reader.readTuple(tuple) == 4) { // split is optional\r\n\t\t\t\t\t\t// region.splits = new Vector.<int>(parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]));\r\n\t\t\t\t\t\tif (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\r\n\t\t\t\t\t\t\t//region.pads = Vector.<int>(parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]));\r\n\t\t\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tregion.originalWidth = parseInt(tuple[0]);\r\n\t\t\t\t\tregion.originalHeight = parseInt(tuple[1]);\r\n\r\n\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\tregion.offsetX = parseInt(tuple[0]);\r\n\t\t\t\t\tregion.offsetY = parseInt(tuple[1]);\r\n\r\n\t\t\t\t\tregion.index = parseInt(reader.readValue());\r\n\r\n\t\t\t\t\tregion.texture = page.texture;\r\n\t\t\t\t\tthis.regions.push(region);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfindRegion (name: string): TextureAtlasRegion {\r\n\t\t\tfor (let i = 0; i < this.regions.length; i++) {\r\n\t\t\t\tif (this.regions[i].name == name) {\r\n\t\t\t\t\treturn this.regions[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tdispose () {\r\n\t\t\tfor (let i = 0; i < this.pages.length; i++) {\r\n\t\t\t\tthis.pages[i].texture.dispose();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tclass TextureAtlasReader {\r\n\t\tlines: Array<string>;\r\n\t\tindex: number = 0;\r\n\r\n\t\tconstructor (text: string) {\r\n\t\t\tthis.lines = text.split(/\\r\\n|\\r|\\n/);\r\n\t\t}\r\n\r\n\t\treadLine (): string {\r\n\t\t\tif (this.index >= this.lines.length)\r\n\t\t\t\treturn null;\r\n\t\t\treturn this.lines[this.index++];\r\n\t\t}\r\n\r\n\t\treadValue (): string {\r\n\t\t\tlet line = this.readLine();\r\n\t\t\tlet colon= line.indexOf(\":\");\r\n\t\t\tif (colon == -1)\r\n\t\t\t\tthrow new Error(\"Invalid line: \" + line);\r\n\t\t\treturn line.substring(colon + 1).trim();\r\n\t\t}\r\n\r\n\t\treadTuple (tuple: Array<string>): number {\r\n\t\t\tlet line = this.readLine();\r\n\t\t\tlet colon = line.indexOf(\":\");\r\n\t\t\tif (colon == -1)\r\n\t\t\t\tthrow new Error(\"Invalid line: \" + line);\r\n\t\t\tlet i = 0, lastMatch = colon + 1;\r\n\t\t\tfor (; i < 3; i++) {\r\n\t\t\t\tlet comma = line.indexOf(\",\", lastMatch);\r\n\t\t\t\tif (comma == -1) break;\r\n\t\t\t\ttuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\r\n\t\t\t\tlastMatch = comma + 1;\r\n\t\t\t}\r\n\t\t\ttuple[i] = line.substring(lastMatch).trim();\r\n\t\t\treturn i + 1;\r\n\t\t}\r\n\t}\r\n\r\n\texport class TextureAtlasPage {\r\n\t\tname: string;\r\n\t\tminFilter: TextureFilter;\r\n\t\tmagFilter: TextureFilter;\r\n\t\tuWrap: TextureWrap;\r\n\t\tvWrap: TextureWrap;\r\n\t\ttexture: Texture;\r\n\t\twidth: number;\r\n\t\theight: number;\r\n\t}\r\n\r\n\texport class TextureAtlasRegion extends TextureRegion {\r\n\t\tpage: TextureAtlasPage;\r\n\t\tname: string;\r\n\t\tx: number;\r\n\t\ty: number;\r\n\t\tindex: number;\r\n\t\trotate: boolean;\r\n\t\tdegrees: number;\r\n\t\ttexture: Texture;\r\n\t}\r\n","\r\n\r\nimport { VertexAttachment, Attachment } from \"./Attachment\";\r\nimport { TextureRegion } from \"../Texture\";\r\nimport { Color, Utils, ArrayLike } from \"../Utils\";\r\nimport { TextureAtlasRegion } from \"../TextureAtlas\";\r\n\r\n\r\n/** An attachment that displays a textured mesh. A mesh has hull vertices and internal vertices within the hull. Holes are not\r\n * supported. Each vertex has UVs (texture coordinates) and triangles are used to map an image on to the mesh.\r\n *\r\n * See [Mesh attachments](http://esotericsoftware.com/spine-meshes) in the Spine User Guide. */\r\nexport class MeshAttachment extends VertexAttachment {\r\n\tregion: TextureRegion;\r\n\r\n\t/** The name of the texture region for this attachment. */\r\n\tpath: string;\r\n\r\n\t/** The UV pair for each vertex, normalized within the texture region. */\r\n\tregionUVs: ArrayLike<number>;\r\n\r\n\t/** The UV pair for each vertex, normalized within the entire texture.\r\n\t *\r\n\t * See {@link #updateUVs}. */\r\n\tuvs: ArrayLike<number>;\r\n\r\n\t/** Triplets of vertex indices which describe the mesh's triangulation. */\r\n\ttriangles: Array<number>;\r\n\r\n\t/** The color to tint the mesh. */\r\n\tcolor = new Color(1, 1, 1, 1);\r\n\r\n\t/** The width of the mesh's image. Available only when nonessential data was exported. */\r\n\twidth: number;\r\n\r\n\t/** The height of the mesh's image. Available only when nonessential data was exported. */\r\n\theight: number;\r\n\r\n\t/** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */\r\n\thullLength: number;\r\n\r\n\t/** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if\r\n\t * nonessential data was exported. Triangulation is not performed at runtime. */\r\n\tedges: Array<number>;\r\n\r\n\tprivate parentMesh: MeshAttachment;\r\n\ttempColor = new Color(0, 0, 0, 0);\r\n\r\n\tconstructor (name: string) {\r\n\t\tsuper(name);\r\n\t}\r\n\r\n\t/** Calculates {@link #uvs} using {@link #regionUVs} and the {@link #region}. Must be called after changing the region UVs or\r\n\t * region. */\r\n\tupdateUVs () {\r\n\t\tlet regionUVs = this.regionUVs;\r\n\t\tif (this.uvs == null || this.uvs.length != regionUVs.length) this.uvs = Utils.newFloatArray(regionUVs.length);\r\n\t\tlet uvs = this.uvs;\r\n\t\tlet n = this.uvs.length;\r\n\t\tlet u = this.region.u, v = this.region.v, width = 0, height = 0;\r\n\t\tif (this.region instanceof TextureAtlasRegion) {\r\n\t\t\tlet region = this.region;\r\n\t\t\tlet textureWidth = region.texture.getImage().width, textureHeight = region.texture.getImage().height;\r\n\t\t\tswitch(region.degrees) {\r\n\t\t\tcase 90:\r\n\t\t\t\tu -= (region.originalHeight - region.offsetY - region.height) / textureWidth;\r\n\t\t\t\tv -= (region.originalWidth - region.offsetX - region.width) / textureHeight;\r\n\t\t\t\twidth = region.originalHeight / textureWidth;\r\n\t\t\t\theight = region.originalWidth / textureHeight;\r\n\t\t\t\tfor (let i = 0; i < n; i += 2) {\r\n\t\t\t\t\tuvs[i] = u + regionUVs[i + 1] * width;\r\n\t\t\t\t\tuvs[i + 1] = v + (1 - regionUVs[i]) * height;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\tcase 180:\r\n\t\t\t\tu -= (region.originalWidth - region.offsetX - region.width) / textureWidth;\r\n\t\t\t\tv -= region.offsetY / textureHeight;\r\n\t\t\t\twidth = region.originalWidth / textureWidth;\r\n\t\t\t\theight = region.originalHeight / textureHeight;\r\n\t\t\t\tfor (let i = 0; i < n; i += 2) {\r\n\t\t\t\t\tuvs[i] = u + (1 - regionUVs[i]) * width;\r\n\t\t\t\t\tuvs[i + 1] = v + (1 - regionUVs[i + 1]) * height;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\tcase 270:\r\n\t\t\t\tu -= region.offsetY / textureWidth;\r\n\t\t\t\tv -= region.offsetX / textureHeight;\r\n\t\t\t\twidth = region.originalHeight / textureWidth;\r\n\t\t\t\theight = region.originalWidth / textureHeight;\r\n\t\t\t\tfor (let i = 0; i < n; i += 2) {\r\n\t\t\t\t\tuvs[i] = u + (1 - regionUVs[i + 1]) * width;\r\n\t\t\t\t\tuvs[i + 1] = v + regionUVs[i] * height;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tu -= region.offsetX / textureWidth;\r\n\t\t\tv -= (region.originalHeight - region.offsetY - region.height) / textureHeight;\r\n\t\t\twidth = region.originalWidth / textureWidth;\r\n\t\t\theight = region.originalHeight / textureHeight;\r\n\t\t} else if (this.region == null) {\r\n\t\t\tu = v = 0;\r\n\t\t\twidth = height = 1;\r\n\t\t} else {\r\n\t\t\twidth = this.region.u2 - u;\r\n\t\t\theight = this.region.v2 - v;\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < n; i += 2) {\r\n\t\t\tuvs[i] = u + regionUVs[i] * width;\r\n\t\t\tuvs[i + 1] = v + regionUVs[i + 1] * height;\r\n\t\t}\r\n\t}\r\n\r\n\t/** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},\r\n\t * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the\r\n\t * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */\r\n\tgetParentMesh () {\r\n\t\treturn this.parentMesh;\r\n\t}\r\n\r\n\t/** @param parentMesh May be null. */\r\n\tsetParentMesh (parentMesh: MeshAttachment) {\r\n\t\tthis.parentMesh = parentMesh;\r\n\t\tif (parentMesh != null) {\r\n\t\t\tthis.bones = parentMesh.bones;\r\n\t\t\tthis.vertices = parentMesh.vertices;\r\n\t\t\tthis.worldVerticesLength = parentMesh.worldVerticesLength;\r\n\t\t\tthis.regionUVs = parentMesh.regionUVs;\r\n\t\t\tthis.triangles = parentMesh.triangles;\r\n\t\t\tthis.hullLength = parentMesh.hullLength;\r\n\t\t\tthis.worldVerticesLength = parentMesh.worldVerticesLength\r\n\t\t}\r\n\t}\r\n\r\n\tcopy (): Attachment {\r\n\t\tif (this.parentMesh != null) return this.newLinkedMesh();\r\n\r\n\t\tlet copy = new MeshAttachment(this.name);\r\n\t\tcopy.region = this.region;\r\n\t\tcopy.path = this.path;\r\n\t\tcopy.color.setFromColor(this.color);\r\n\r\n\t\tthis.copyTo(copy);\r\n\t\tcopy.regionUVs = new Array<number>(this.regionUVs.length);\r\n\t\tUtils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\r\n\t\tcopy.uvs = new Array<number>(this.uvs.length);\r\n\t\tUtils.arrayCopy(this.uvs, 0, copy.uvs, 0, this.uvs.length);\r\n\t\tcopy.triangles = new Array<number>(this.triangles.length);\r\n\t\tUtils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\r\n\t\tcopy.hullLength = this.hullLength;\r\n\r\n\t\t// Nonessential.\r\n\t\tif (this.edges != null) {\r\n\t\t\tcopy.edges = new Array<number>(this.edges.length);\r\n\t\t\tUtils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\r\n\t\t}\r\n\t\tcopy.width = this.width;\r\n\t\tcopy.height = this.height;\r\n\r\n\t\treturn copy;\r\n\t}\r\n\r\n\t/** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/\r\n\tnewLinkedMesh (): MeshAttachment {\r\n\t\tlet copy = new MeshAttachment(this.name);\r\n\t\tcopy.region = this.region;\r\n\t\tcopy.path = this.path;\r\n\t\tcopy.color.setFromColor(this.color);\r\n\t\tcopy.deformAttachment = this.deformAttachment;\r\n\t\tcopy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);\r\n\t\tcopy.updateUVs();\r\n\t\treturn copy;\r\n\t}\r\n}\r\n\r\n","\r\n\r\nimport { SkeletonData } from \"./SkeletonData\";\r\nimport { Bone } from \"./Bone\";\r\nimport { Slot } from \"./Slot\";\r\nimport { IkConstraint } from \"./IkConstraint\";\r\nimport { TransformConstraint } from \"./TransformConstraint\";\r\nimport { PathConstraint } from \"./PathConstraint\";\r\nimport { Updatable } from \"./Updatable\";\r\nimport { Skin } from \"./Skin\";\r\nimport { Color, Utils, Vector2 } from \"./Utils\";\r\nimport { PathAttachment } from \"./attachments/PathAttachment\";\r\nimport { Attachment } from \"./attachments/Attachment\";\r\nimport { RegionAttachment } from \"./attachments/RegionAttachment\";\r\nimport { MeshAttachment } from \"./attachments/MeshAttachment\";\r\n\r\n/** Stores the current pose for a skeleton.\r\n *\r\n * See [Instance objects](http://esotericsoftware.com/spine-runtime-architecture#Instance-objects) in the Spine Runtimes Guide. */\r\nexport class Skeleton {\r\n\t/** The skeleton's setup pose data. */\r\n\tdata: SkeletonData;\r\n\r\n\t/** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\r\n\tbones: Array<Bone>;\r\n\r\n\t/** The skeleton's slots. */\r\n\tslots: Array<Slot>;\r\n\r\n\t/** The skeleton's slots in the order they should be drawn. The returned array may be modified to change the draw order. */\r\n\tdrawOrder: Array<Slot>;\r\n\r\n\t/** The skeleton's IK constraints. */\r\n\tikConstraints: Array<IkConstraint>;\r\n\r\n\t/** The skeleton's transform constraints. */\r\n\ttransformConstraints: Array<TransformConstraint>;\r\n\r\n\t/** The skeleton's path constraints. */\r\n\tpathConstraints: Array<PathConstraint>;\r\n\r\n\t/** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */\r\n\t_updateCache = new Array<Updatable>();\r\n\tupdateCacheReset = new Array<Updatable>();\r\n\r\n\t/** The skeleton's current skin. May be null. */\r\n\tskin: Skin;\r\n\r\n\t/** The color to tint all the skeleton's attachments. */\r\n\tcolor: Color;\r\n\r\n\t/** Returns the skeleton's time. This can be used for tracking, such as with Slot {@link Slot#attachmentTime}.\r\n\t * <p>\r\n\t * See {@link #update()}. */\r\n\ttime = 0;\r\n\r\n\t/** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale\r\n\t* inheritance. */\r\n\tscaleX = 1;\r\n\r\n\t/** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale\r\n\t* inheritance. */\r\n\tscaleY = 1;\r\n\r\n\t/** Sets the skeleton X position, which is added to the root bone worldX position. */\r\n\tx = 0;\r\n\r\n\t/** Sets the skeleton Y position, which is added to the root bone worldY position. */\r\n\ty = 0;\r\n\r\n\tconstructor(data: SkeletonData) {\r\n\t\tif (data == null) throw new Error(\"data cannot be null.\");\r\n\t\tthis.data = data;\r\n\r\n\t\tthis.bones = new Array<Bone>();\r\n\t\tfor (let i = 0; i < data.bones.length; i++) {\r\n\t\t\tlet boneData = data.bones[i];\r\n\t\t\tlet bone: Bone;\r\n\t\t\tif (boneData.parent == null)\r\n\t\t\t\tbone = new Bone(boneData, this, null);\r\n\t\t\telse {\r\n\t\t\t\tlet parent = this.bones[boneData.parent.index];\r\n\t\t\t\tbone = new Bone(boneData, this, parent);\r\n\t\t\t\tparent.children.push(bone);\r\n\t\t\t}\r\n\t\t\tthis.bones.push(bone);\r\n\t\t}\r\n\r\n\t\tthis.slots = new Array<Slot>();\r\n\t\tthis.drawOrder = new Array<Slot>();\r\n\t\tfor (let i = 0; i < data.slots.length; i++) {\r\n\t\t\tlet slotData = data.slots[i];\r\n\t\t\tlet bone = this.bones[slotData.boneData.index];\r\n\t\t\tlet slot = new Slot(slotData, bone);\r\n\t\t\tthis.slots.push(slot);\r\n\t\t\tthis.drawOrder.push(slot);\r\n\t\t}\r\n\r\n\t\tthis.ikConstraints = new Array<IkConstraint>();\r\n\t\tfor (let i = 0; i < data.ikConstraints.length; i++) {\r\n\t\t\tlet ikConstraintData = data.ikConstraints[i];\r\n\t\t\tthis.ikConstraints.push(new IkConstraint(ikConstraintData, this));\r\n\t\t}\r\n\r\n\t\tthis.transformConstraints = new Array<TransformConstraint>();\r\n\t\tfor (let i = 0; i < data.transformConstraints.length; i++) {\r\n\t\t\tlet transformConstraintData = data.transformConstraints[i];\r\n\t\t\tthis.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\r\n\t\t}\r\n\r\n\t\tthis.pathConstraints = new Array<PathConstraint>();\r\n\t\tfor (let i = 0; i < data.pathConstraints.length; i++) {\r\n\t\t\tlet pathConstraintData = data.pathConstraints[i];\r\n\t\t\tthis.pathConstraints.push(new PathConstraint(pathConstraintData, this));\r\n\t\t}\r\n\r\n\t\tthis.color = new Color(1, 1, 1, 1);\r\n\t\tthis.updateCache();\r\n\t}\r\n\r\n\t/** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,\r\n\t * constraints, or weighted path attachments are added or removed. */\r\n\tupdateCache() {\r\n\t\tlet updateCache = this._updateCache;\r\n\t\tupdateCache.length = 0;\r\n\t\tthis.updateCacheReset.length = 0;\r\n\r\n\t\tlet bones = this.bones;\r\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\r\n\t\t\tlet bone = bones[i];\r\n\t\t\tbone.sorted = bone.data.skinRequired;\r\n\t\t\tbone.active = !bone.sorted;\r\n\t\t}\r\n\r\n\t\tif (this.skin != null) {\r\n\t\t\tlet skinBones = this.skin.bones;\r\n\t\t\tfor (let i = 0, n = this.skin.bones.length; i < n; i++) {\r\n\t\t\t\tlet bone = this.bones[skinBones[i].index];\r\n\t\t\t\tdo {\r\n\t\t\t\t\tbone.sorted = false;\r\n\t\t\t\t\tbone.active = true;\r\n\t\t\t\t\tbone = bone.parent;\r\n\t\t\t\t} while (bone != null);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// IK first, lowest hierarchy depth first.\r\n\t\tlet ikConstraints = this.ikConstraints;\r\n\t\tlet transformConstraints = this.transformConstraints;\r\n\t\tlet pathConstraints = this.pathConstraints;\r\n\t\tlet ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\r\n\t\tlet constraintCount = ikCount + transformCount + pathCount;\r\n\r\n\t\touter:\r\n\t\tfor (let i = 0; i < constraintCount; i++) {\r\n\t\t\tfor (let ii = 0; ii < ikCount; ii++) {\r\n\t\t\t\tlet constraint = ikConstraints[ii];\r\n\t\t\t\tif (constraint.data.order == i) {\r\n\t\t\t\t\tthis.sortIkConstraint(constraint);\r\n\t\t\t\t\tcontinue outer;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (let ii = 0; ii < transformCount; ii++) {\r\n\t\t\t\tlet constraint = transformConstraints[ii];\r\n\t\t\t\tif (constraint.data.order == i) {\r\n\t\t\t\t\tthis.sortTransformConstraint(constraint);\r\n\t\t\t\t\tcontinue outer;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (let ii = 0; ii < pathCount; ii++) {\r\n\t\t\t\tlet constraint = pathConstraints[ii];\r\n\t\t\t\tif (constraint.data.order == i) {\r\n\t\t\t\t\tthis.sortPathConstraint(constraint);\r\n\t\t\t\t\tcontinue outer;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (let i = 0, n = bones.length; i < n; i++)\r\n\t\t\tthis.sortBone(bones[i]);\r\n\t}\r\n\r\n\tsortIkConstraint(constraint: IkConstraint) {\r\n\t\tconstraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\r\n\t\tif (!constraint.active) return;\r\n\r\n\t\tlet target = constraint.target;\r\n\t\tthis.sortBone(target);\r\n\r\n\t\tlet constrained = constraint.bones;\r\n\t\tlet parent = constrained[0];\r\n\t\tthis.sortBone(parent);\r\n\r\n\t\tif (constrained.length > 1) {\r\n\t\t\tlet child = constrained[constrained.length - 1];\r\n\t\t\tif (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\r\n\t\t}\r\n\r\n\t\tthis._updateCache.push(constraint);\r\n\r\n\t\tthis.sortReset(parent.children);\r\n\t\tconstrained[constrained.length - 1].sorted = true;\r\n\t}\r\n\r\n\tsortPathConstraint(constraint: PathConstraint) {\r\n\t\tconstraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\r\n\t\tif (!constraint.active) return;\r\n\r\n\t\tlet slot = constraint.target;\r\n\t\tlet slotIndex = slot.data.index;\r\n\t\tlet slotBone = slot.bone;\r\n\t\tif (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\r\n\t\tif (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\r\n\t\t\tthis.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\r\n\t\tfor (let i = 0, n = this.data.skins.length; i < n; i++)\r\n\t\t\tthis.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\r\n\r\n\t\tlet attachment = slot.getAttachment();\r\n\t\tif (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\r\n\r\n\t\tlet constrained = constraint.bones;\r\n\t\tlet boneCount = constrained.length;\r\n\t\tfor (let i = 0; i < boneCount; i++)\r\n\t\t\tthis.sortBone(constrained[i]);\r\n\r\n\t\tthis._updateCache.push(constraint);\r\n\r\n\t\tfor (let i = 0; i < boneCount; i++)\r\n\t\t\tthis.sortReset(constrained[i].children);\r\n\t\tfor (let i = 0; i < boneCount; i++)\r\n\t\t\tconstrained[i].sorted = true;\r\n\t}\r\n\r\n\tsortTransformConstraint(constraint: TransformConstraint) {\r\n\t\tconstraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\r\n\t\tif (!constraint.active) return;\r\n\r\n\t\tthis.sortBone(constraint.target);\r\n\r\n\t\tlet constrained = constraint.bones;\r\n\t\tlet boneCount = constrained.length;\r\n\t\tif (constraint.data.local) {\r\n\t\t\tfor (let i = 0; i < boneCount; i++) {\r\n\t\t\t\tlet child = constrained[i];\r\n\t\t\t\tthis.sortBone(child.parent);\r\n\t\t\t\tif (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (let i = 0; i < boneCount; i++) {\r\n\t\t\t\tthis.sortBone(constrained[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._updateCache.push(constraint);\r\n\r\n\t\tfor (let ii = 0; ii < boneCount; ii++)\r\n\t\t\tthis.sortReset(constrained[ii].children);\r\n\t\tfor (let ii = 0; ii < boneCount; ii++)\r\n\t\t\tconstrained[ii].sorted = true;\r\n\t}\r\n\r\n\tsortPathConstraintAttachment(skin: Skin, slotIndex: number, slotBone: Bone) {\r\n\t\tlet attachments = skin.attachments[slotIndex];\r\n\t\tif (!attachments) return;\r\n\t\tfor (let key in attachments) {\r\n\t\t\tthis.sortPathConstraintAttachmentWith(attachments[key], slotBone);\r\n\t\t}\r\n\t}\r\n\r\n\tsortPathConstraintAttachmentWith(attachment: Attachment, slotBone: Bone) {\r\n\t\tif (!(attachment instanceof PathAttachment)) return;\r\n\t\tlet pathBones = (<PathAttachment>attachment).bones;\r\n\t\tif (pathBones == null)\r\n\t\t\tthis.sortBone(slotBone);\r\n\t\telse {\r\n\t\t\tlet bones = this.bones;\r\n\t\t\tlet i = 0;\r\n\t\t\twhile (i < pathBones.length) {\r\n\t\t\t\tlet boneCount = pathBones[i++];\r\n\t\t\t\tfor (let n = i + boneCount; i < n; i++) {\r\n\t\t\t\t\tlet boneIndex = pathBones[i];\r\n\t\t\t\t\tthis.sortBone(bones[boneIndex]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tsortBone(bone: Bone) {\r\n\t\tif (bone.sorted) return;\r\n\t\tlet parent = bone.parent;\r\n\t\tif (parent != null) this.sortBone(parent);\r\n\t\tbone.sorted = true;\r\n\t\tthis._updateCache.push(bone);\r\n\t}\r\n\r\n\tsortReset(bones: Array<Bone>) {\r\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\r\n\t\t\tlet bone = bones[i];\r\n\t\t\tif (!bone.active) continue;\r\n\t\t\tif (bone.sorted) this.sortReset(bone.children);\r\n\t\t\tbone.sorted = false;\r\n\t\t}\r\n\t}\r\n\r\n\t/** Updates the world transform for each bone and applies all constraints.\r\n\t *\r\n\t * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n\t * Runtimes Guide. */\r\n\tupdateWorldTransform() {\r\n\t\tlet updateCacheReset = this.updateCacheReset;\r\n\t\tfor (let i = 0, n = updateCacheReset.length; i < n; i++) {\r\n\t\t\tlet bone = updateCacheReset[i] as Bone;\r\n\t\t\tbone.ax = bone.x;\r\n\t\t\tbone.ay = bone.y;\r\n\t\t\tbone.arotation = bone.rotation;\r\n\t\t\tbone.ascaleX = bone.scaleX;\r\n\t\t\tbone.ascaleY = bone.scaleY;\r\n\t\t\tbone.ashearX = bone.shearX;\r\n\t\t\tbone.ashearY = bone.shearY;\r\n\t\t\tbone.appliedValid = true;\r\n\t\t}\r\n\t\tlet updateCache = this._updateCache;\r\n\t\tfor (let i = 0, n = updateCache.length; i < n; i++)\r\n\t\t\tupdateCache[i].update();\r\n\t}\r\n\r\n\t/** Sets the bones, constraints, and slots to their setup pose values. */\r\n\tsetToSetupPose() {\r\n\t\tthis.setBonesToSetupPose();\r\n\t\tthis.setSlotsToSetupPose();\r\n\t}\r\n\r\n\t/** Sets the bones and constraints to their setup pose values. */\r\n\tsetBonesToSetupPose() {\r\n\t\tlet bones = this.bones;\r\n\t\tfor (let i = 0, n = bones.length; i < n; i++)\r\n\t\t\tbones[i].setToSetupPose();\r\n\r\n\t\tlet ikConstraints = this.ikConstraints;\r\n\t\tfor (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n\t\t\tlet constraint = ikConstraints[i];\r\n\t\t\tconstraint.mix = constraint.data.mix;\r\n\t\t\tconstraint.softness = constraint.data.softness;\r\n\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\r\n\t\t\tconstraint.compress = constraint.data.compress;\r\n\t\t\tconstraint.stretch = constraint.data.stretch;\r\n\t\t}\r\n\r\n\t\tlet transformConstraints = this.transformConstraints;\r\n\t\tfor (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n\t\t\tlet constraint = transformConstraints[i];\r\n\t\t\tlet data = constraint.data;\r\n\t\t\tconstraint.rotateMix = data.rotateMix;\r\n\t\t\tconstraint.translateMix = data.translateMix;\r\n\t\t\tconstraint.scaleMix = data.scaleMix;\r\n\t\t\tconstraint.shearMix = data.shearMix;\r\n\t\t}\r\n\r\n\t\tlet pathConstraints = this.pathConstraints;\r\n\t\tfor (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n\t\t\tlet constraint = pathConstraints[i];\r\n\t\t\tlet data = constraint.data;\r\n\t\t\tconstraint.position = data.position;\r\n\t\t\tconstraint.spacing = data.spacing;\r\n\t\t\tconstraint.rotateMix = data.rotateMix;\r\n\t\t\tconstraint.translateMix = data.translateMix;\r\n\t\t}\r\n\t}\r\n\r\n\t/** Sets the slots and draw order to their setup pose values. */\r\n\tsetSlotsToSetupPose() {\r\n\t\tlet slots = this.slots;\r\n\t\tUtils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\r\n\t\tfor (let i = 0, n = slots.length; i < n; i++)\r\n\t\t\tslots[i].setToSetupPose();\r\n\t}\r\n\r\n\t/** @returns May return null. */\r\n\tgetRootBone() {\r\n\t\tif (this.bones.length == 0) return null;\r\n\t\treturn this.bones[0];\r\n\t}\r\n\r\n\t/** @returns May be null. */\r\n\tfindBone(boneName: string) {\r\n\t\tif (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n\t\tlet bones = this.bones;\r\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\r\n\t\t\tlet bone = bones[i];\r\n\t\t\tif (bone.data.name == boneName) return bone;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** @returns -1 if the bone was not found. */\r\n\tfindBoneIndex(boneName: string) {\r\n\t\tif (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n\t\tlet bones = this.bones;\r\n\t\tfor (let i = 0, n = bones.length; i < n; i++)\r\n\t\t\tif (bones[i].data.name == boneName) return i;\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\r\n\t * repeatedly.\r\n\t * @returns May be null. */\r\n\tfindSlot(slotName: string) {\r\n\t\tif (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n\t\tlet slots = this.slots;\r\n\t\tfor (let i = 0, n = slots.length; i < n; i++) {\r\n\t\t\tlet slot = slots[i];\r\n\t\t\tif (slot.data.name == slotName) return slot;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** @returns -1 if the bone was not found. */\r\n\tfindSlotIndex(slotName: string) {\r\n\t\tif (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n\t\tlet slots = this.slots;\r\n\t\tfor (let i = 0, n = slots.length; i < n; i++)\r\n\t\t\tif (slots[i].data.name == slotName) return i;\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/** Sets a skin by name.\r\n\t *\r\n\t * See {@link #setSkin()}. */\r\n\tsetSkinByName(skinName: string) {\r\n\t\tlet skin = this.data.findSkin(skinName);\r\n\t\tif (skin == null) throw new Error(\"Skin not found: \" + skinName);\r\n\t\tthis.setSkin(skin);\r\n\t}\r\n\r\n\t/** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the\r\n\t * skin is changed, {@link #updateCache()} is called.\r\n\t *\r\n\t * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\r\n\t * old skin, each slot's setup mode attachment is attached from the new skin.\r\n\t *\r\n\t * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling\r\n\t * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the\r\n\t * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.\r\n\t * @param newSkin May be null. */\r\n\tsetSkin(newSkin: Skin) {\r\n\t\tif (newSkin == this.skin) return;\r\n\t\tif (newSkin != null) {\r\n\t\t\tif (this.skin != null)\r\n\t\t\t\tnewSkin.attachAll(this, this.skin);\r\n\t\t\telse {\r\n\t\t\t\tlet slots = this.slots;\r\n\t\t\t\tfor (let i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\t\tlet slot = slots[i];\r\n\t\t\t\t\tlet name = slot.data.attachmentName;\r\n\t\t\t\t\tif (name != null) {\r\n\t\t\t\t\t\tlet attachment: Attachment = newSkin.getAttachment(i, name);\r\n\t\t\t\t\t\tif (attachment != null) slot.setAttachment(attachment);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.skin = newSkin;\r\n\t\tthis.updateCache();\r\n\t}\r\n\r\n\r\n\t/** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment\r\n\t * name.\r\n\t *\r\n\t * See {@link #getAttachment()}.\r\n\t * @returns May be null. */\r\n\tgetAttachmentByName(slotName: string, attachmentName: string): Attachment {\r\n\t\treturn this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\r\n\t}\r\n\r\n\t/** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and\r\n\t * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.\r\n\t *\r\n\t * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\r\n\t * @returns May be null. */\r\n\tgetAttachment(slotIndex: number, attachmentName: string): Attachment {\r\n\t\tif (attachmentName == null) throw new Error(\"attachmentName cannot be null.\");\r\n\t\tif (this.skin != null) {\r\n\t\t\tlet attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n\t\t\tif (attachment != null) return attachment;\r\n\t\t}\r\n\t\tif (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with\r\n\t * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.\r\n\t * @param attachmentName May be null to clear the slot's attachment. */\r\n\tsetAttachment(slotName: string, attachmentName: string) {\r\n\t\tif (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n\t\tlet slots = this.slots;\r\n\t\tfor (let i = 0, n = slots.length; i < n; i++) {\r\n\t\t\tlet slot = slots[i];\r\n\t\t\tif (slot.data.name == slotName) {\r\n\t\t\t\tlet attachment: Attachment = null;\r\n\t\t\t\tif (attachmentName != null) {\r\n\t\t\t\t\tattachment = this.getAttachment(i, attachmentName);\r\n\t\t\t\t\tif (attachment == null)\r\n\t\t\t\t\t\tthrow new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\r\n\t\t\t\t}\r\n\t\t\t\tslot.setAttachment(attachment);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow new Error(\"Slot not found: \" + slotName);\r\n\t}\r\n\r\n\r\n\t/** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\r\n\t * than to call it repeatedly.\r\n\t * @return May be null. */\r\n\tfindIkConstraint(constraintName: string) {\r\n\t\tif (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n\t\tlet ikConstraints = this.ikConstraints;\r\n\t\tfor (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n\t\t\tlet ikConstraint = ikConstraints[i];\r\n\t\t\tif (ikConstraint.data.name == constraintName) return ikConstraint;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\r\n\t * this method than to call it repeatedly.\r\n\t * @return May be null. */\r\n\tfindTransformConstraint(constraintName: string) {\r\n\t\tif (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n\t\tlet transformConstraints = this.transformConstraints;\r\n\t\tfor (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n\t\t\tlet constraint = transformConstraints[i];\r\n\t\t\tif (constraint.data.name == constraintName) return constraint;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\r\n\t * than to call it repeatedly.\r\n\t * @return May be null. */\r\n\tfindPathConstraint(constraintName: string) {\r\n\t\tif (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n\t\tlet pathConstraints = this.pathConstraints;\r\n\t\tfor (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n\t\t\tlet constraint = pathConstraints[i];\r\n\t\t\tif (constraint.data.name == constraintName) return constraint;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\r\n\t * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.\r\n\t * @param size An output value, the width and height of the AABB.\r\n\t * @param temp Working memory to temporarily store attachments' computed world vertices. */\r\n\tgetBounds(offset: Vector2, size: Vector2, temp: Array<number> = new Array<number>(2)) {\r\n\t\tif (offset == null) throw new Error(\"offset cannot be null.\");\r\n\t\tif (size == null) throw new Error(\"size cannot be null.\");\r\n\t\tlet drawOrder = this.drawOrder;\r\n\t\tlet minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n\t\tfor (let i = 0, n = drawOrder.length; i < n; i++) {\r\n\t\t\tlet slot = drawOrder[i];\r\n\t\t\tif (!slot.bone.active) continue;\r\n\t\t\tlet verticesLength = 0;\r\n\t\t\tlet vertices: ArrayLike<number> = null;\r\n\t\t\tlet attachment = slot.getAttachment();\r\n\t\t\tif (attachment instanceof RegionAttachment) {\r\n\t\t\t\tverticesLength = 8;\r\n\t\t\t\tvertices = Utils.setArraySize(temp, verticesLength, 0);\r\n\t\t\t\t(<RegionAttachment>attachment).computeWorldVertices(slot.bone, vertices, 0, 2);\r\n\t\t\t} else if (attachment instanceof MeshAttachment) {\r\n\t\t\t\tlet mesh = (<MeshAttachment>attachment);\r\n\t\t\t\tverticesLength = mesh.worldVerticesLength;\r\n\t\t\t\tvertices = Utils.setArraySize(temp, verticesLength, 0);\r\n\t\t\t\tmesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\r\n\t\t\t}\r\n\t\t\tif (vertices != null) {\r\n\t\t\t\tfor (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\r\n\t\t\t\t\tlet x = vertices[ii], y = vertices[ii + 1];\r\n\t\t\t\t\tminX = Math.min(minX, x);\r\n\t\t\t\t\tminY = Math.min(minY, y);\r\n\t\t\t\t\tmaxX = Math.max(maxX, x);\r\n\t\t\t\t\tmaxY = Math.max(maxY, y);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\toffset.set(minX, minY);\r\n\t\tsize.set(maxX - minX, maxY - minY);\r\n\t}\r\n\r\n\t/** Increments the skeleton's {@link #time}. */\r\n\tupdate(delta: number) {\r\n\t\tthis.time += delta;\r\n\t}\r\n}\r\n","\r\n\r\nimport { AnimationStateData } from \"./AnimationStateData\";\r\nimport { IntSet, Pool, Utils, MathUtils } from \"./Utils\";\r\nimport { Skeleton } from \"./Skeleton\";\r\nimport { MixBlend, AttachmentTimeline, MixDirection, RotateTimeline, DrawOrderTimeline, Timeline, EventTimeline } from \"./Animation\";\r\nimport { Slot } from \"./Slot\";\r\nimport { Animation } from \"./Animation\";\r\nimport { Event } from \"./Event\";\r\n\r\n\r\n/** Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies\r\n * multiple animations on top of each other (layering).\r\n *\r\n * See [Applying Animations](http://esotericsoftware.com/spine-applying-animations/) in the Spine Runtimes Guide. */\r\nexport class AnimationState {\r\n\tstatic emptyAnimation = new Animation(\"<empty>\", [], 0);\r\n\r\n\t/** 1. A previously applied timeline has set this property.\r\n\t *\r\n\t * Result: Mix from the current pose to the timeline pose. */\r\n\tstatic SUBSEQUENT = 0;\r\n\t/** 1. This is the first timeline to set this property.\r\n\t * 2. The next track entry applied after this one does not have a timeline to set this property.\r\n\t *\r\n\t * Result: Mix from the setup pose to the timeline pose. */\r\n\tstatic FIRST = 1;\r\n\t/** 1) A previously applied timeline has set this property.<br>\r\n\t * 2) The next track entry to be applied does have a timeline to set this property.<br>\r\n\t * 3) The next track entry after that one does not have a timeline to set this property.<br>\r\n\t * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\r\n\t * animations that key the same property. A subsequent timeline will set this property using a mix. */\r\n\tstatic HOLD_SUBSEQUENT = 2;\r\n\t/** 1) This is the first timeline to set this property.<br>\r\n\t * 2) The next track entry to be applied does have a timeline to set this property.<br>\r\n\t * 3) The next track entry after that one does not have a timeline to set this property.<br>\r\n\t * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\r\n\t * that key the same property. A subsequent timeline will set this property using a mix. */\r\n\tstatic HOLD_FIRST = 3;\r\n\t/** 1. This is the first timeline to set this property.\r\n\t * 2. The next track entry to be applied does have a timeline to set this property.\r\n\t * 3. The next track entry after that one does have a timeline to set this property.\r\n\t * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\r\n\t *\r\n\t * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\r\n\t * 2 track entries in a row have a timeline that sets the same property.\r\n\t *\r\n\t * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\r\n\t * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\r\n\t * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\r\n\t * place. */\r\n\tstatic HOLD_MIX = 4;\r\n\r\n\tstatic SETUP = 1;\r\n\tstatic CURRENT = 2;\r\n\r\n\t/** The AnimationStateData to look up mix durations. */\r\n\tdata: AnimationStateData;\r\n\r\n\t/** The list of tracks that currently have animations, which may contain null entries. */\r\n\ttracks = new Array<TrackEntry>();\r\n\r\n\t/** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\r\n\t * or faster. Defaults to 1.\r\n\t *\r\n\t * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\r\n\ttimeScale = 1;\r\n\tunkeyedState = 0;\r\n\r\n\tevents = new Array<Event>();\r\n\tlisteners = new Array<AnimationStateListener>();\r\n\tqueue = new EventQueue(this);\r\n\tpropertyIDs = new IntSet();\r\n\tanimationsChanged = false;\r\n\r\n\ttrackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\r\n\r\n\tconstructor (data: AnimationStateData) {\r\n\t\tthis.data = data;\r\n\t}\r\n\r\n\t/** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\r\n\tupdate (delta: number) {\r\n\t\tdelta *= this.timeScale;\r\n\t\tlet tracks = this.tracks;\r\n\t\tfor (let i = 0, n = tracks.length; i < n; i++) {\r\n\t\t\tlet current = tracks[i];\r\n\t\t\tif (current == null) continue;\r\n\r\n\t\t\tcurrent.animationLast = current.nextAnimationLast;\r\n\t\t\tcurrent.trackLast = current.nextTrackLast;\r\n\r\n\t\t\tlet currentDelta = delta * current.timeScale;\r\n\r\n\t\t\tif (current.delay > 0) {\r\n\t\t\t\tcurrent.delay -= currentDelta;\r\n\t\t\t\tif (current.delay > 0) continue;\r\n\t\t\t\tcurrentDelta = -current.delay;\r\n\t\t\t\tcurrent.delay = 0;\r\n\t\t\t}\r\n\r\n\t\t\tlet next = current.next;\r\n\t\t\tif (next != null) {\r\n\t\t\t\t// When the next entry's delay is passed, change to the next entry, preserving leftover time.\r\n\t\t\t\tlet nextTime = current.trackLast - next.delay;\r\n\t\t\t\tif (nextTime >= 0) {\r\n\t\t\t\t\tnext.delay = 0;\r\n\t\t\t\t\tnext.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\r\n\t\t\t\t\tcurrent.trackTime += currentDelta;\r\n\t\t\t\t\tthis.setCurrent(i, next, true);\r\n\t\t\t\t\twhile (next.mixingFrom != null) {\r\n\t\t\t\t\t\tnext.mixTime += delta;\r\n\t\t\t\t\t\tnext = next.mixingFrom;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t} else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\r\n\t\t\t\ttracks[i] = null;\r\n\t\t\t\tthis.queue.end(current);\r\n\t\t\t\tthis.disposeNext(current);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\r\n\t\t\t\t// End mixing from entries once all have completed.\r\n\t\t\t\tlet from = current.mixingFrom;\r\n\t\t\t\tcurrent.mixingFrom = null;\r\n\t\t\t\tif (from != null) from.mixingTo = null;\r\n\t\t\t\twhile (from != null) {\r\n\t\t\t\t\tthis.queue.end(from);\r\n\t\t\t\t\tfrom = from.mixingFrom;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tcurrent.trackTime += currentDelta;\r\n\t\t}\r\n\r\n\t\tthis.queue.drain();\r\n\t}\r\n\r\n\t/** Returns true when all mixing from entries are complete. */\r\n\tupdateMixingFrom (to: TrackEntry, delta: number): boolean {\r\n\t\tlet from = to.mixingFrom;\r\n\t\tif (from == null) return true;\r\n\r\n\t\tlet finished = this.updateMixingFrom(from, delta);\r\n\r\n\t\tfrom.animationLast = from.nextAnimationLast;\r\n\t\tfrom.trackLast = from.nextTrackLast;\r\n\r\n\t\t// Require mixTime > 0 to ensure the mixing from entry was applied at least once.\r\n\t\tif (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\r\n\t\t\t// Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\r\n\t\t\tif (from.totalAlpha == 0 || to.mixDuration == 0) {\r\n\t\t\t\tto.mixingFrom = from.mixingFrom;\r\n\t\t\t\tif (from.mixingFrom != null) from.mixingFrom.mixingTo = to;\r\n\t\t\t\tto.interruptAlpha = from.interruptAlpha;\r\n\t\t\t\tthis.queue.end(from);\r\n\t\t\t}\r\n\t\t\treturn finished;\r\n\t\t}\r\n\r\n\t\tfrom.trackTime += delta * from.timeScale;\r\n\t\tto.mixTime += delta;\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\r\n\t * animation state can be applied to multiple skeletons to pose them identically.\r\n\t * @returns True if any animations were applied. */\r\n\tapply (skeleton: Skeleton) : boolean {\r\n\t\tif (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n\t\tif (this.animationsChanged) this._animationsChanged();\r\n\r\n\t\tlet events = this.events;\r\n\t\tlet tracks = this.tracks;\r\n\t\tlet applied = false;\r\n\r\n\t\tfor (let i = 0, n = tracks.length; i < n; i++) {\r\n\t\t\tlet current = tracks[i];\r\n\t\t\tif (current == null || current.delay > 0) continue;\r\n\t\t\tapplied = true;\r\n\t\t\tlet blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\r\n\r\n\t\t\t// Apply mixing from entries first.\r\n\t\t\tlet mix = current.alpha;\r\n\t\t\tif (current.mixingFrom != null)\r\n\t\t\t\tmix *= this.applyMixingFrom(current, skeleton, blend);\r\n\t\t\telse if (current.trackTime >= current.trackEnd && current.next == null)\r\n\t\t\t\tmix = 0;\r\n\r\n\t\t\t// Apply current entry.\r\n\t\t\tlet animationLast = current.animationLast, animationTime = current.getAnimationTime();\r\n\t\t\tlet timelineCount = current.animation.timelines.length;\r\n\t\t\tlet timelines = current.animation.timelines;\r\n\t\t\tif ((i == 0 && mix == 1) || blend == MixBlend.add) {\r\n\t\t\t\tfor (let ii = 0; ii < timelineCount; ii++) {\r\n\t\t\t\t\t// Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\r\n\t\t\t\t\t// to sometimes stop rendering when using color correction, as their RGBA values become NaN.\r\n\t\t\t\t\t// (https://github.com/pixijs/pixi-spine/issues/302)\r\n\t\t\t\t\tUtils.webkit602BugfixHelper(mix, blend);\r\n\t\t\t\t\tvar timeline = timelines[ii];\r\n\t\t\t\t\tif (timeline instanceof AttachmentTimeline)\r\n\t\t\t\t\t\tthis.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ttimeline.apply(skeleton, animationLast, animationTime, events, mix, blend, MixDirection.mixIn);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tlet timelineMode = current.timelineMode;\r\n\r\n\t\t\t\tlet firstFrame = current.timelinesRotation.length == 0;\r\n\t\t\t\tif (firstFrame) Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\r\n\t\t\t\tlet timelinesRotation = current.timelinesRotation;\r\n\r\n\t\t\t\tfor (let ii = 0; ii < timelineCount; ii++) {\r\n\t\t\t\t\tlet timeline = timelines[ii];\r\n\t\t\t\t\tlet timelineBlend = timelineMode[ii]  == AnimationState.SUBSEQUENT ? blend : MixBlend.setup;\r\n\t\t\t\t\tif (timeline instanceof RotateTimeline) {\r\n\t\t\t\t\t\tthis.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\r\n\t\t\t\t\t} else if (timeline instanceof AttachmentTimeline) {\r\n\t\t\t\t\t\tthis.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n\t\t\t\t\t\tUtils.webkit602BugfixHelper(mix, blend);\r\n\t\t\t\t\t\ttimeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, MixDirection.mixIn);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.queueEvents(current, animationTime);\r\n\t\t\tevents.length = 0;\r\n\t\t\tcurrent.nextAnimationLast = animationTime;\r\n\t\t\tcurrent.nextTrackLast = current.trackTime;\r\n\t\t}\r\n\r\n\t\t// Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so\r\n\t\t// subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or\r\n\t\t// the time is before the first key).\r\n\t\tvar setupState = this.unkeyedState + AnimationState.SETUP;\r\n\t\tvar slots = skeleton.slots;\r\n\t\tfor (var i = 0, n = skeleton.slots.length; i < n; i++) {\r\n\t\t\tvar slot = slots[i];\r\n\t\t\tif (slot.attachmentState == setupState) {\r\n\t\t\t\tvar attachmentName = slot.data.attachmentName;\r\n\t\t\t\tslot.attachment = (attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.unkeyedState += 2; // Increasing after each use avoids the need to reset attachmentState for every slot.\r\n\r\n\t\tthis.queue.drain();\r\n\t\treturn applied;\r\n\t}\r\n\r\n\tapplyMixingFrom (to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\r\n\t\tlet from = to.mixingFrom;\r\n\t\tif (from.mixingFrom != null) this.applyMixingFrom(from, skeleton, blend);\r\n\r\n\t\tlet mix = 0;\r\n\t\tif (to.mixDuration == 0) { // Single frame mix to undo mixingFrom changes.\r\n\t\t\tmix = 1;\r\n\t\t\tif (blend == MixBlend.first) blend = MixBlend.setup;\r\n\t\t} else {\r\n\t\t\tmix = to.mixTime / to.mixDuration;\r\n\t\t\tif (mix > 1) mix = 1;\r\n\t\t\tif (blend != MixBlend.first) blend = from.mixBlend;\r\n\t\t}\r\n\r\n\t\tlet events = mix < from.eventThreshold ? this.events : null;\r\n\t\tlet attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;\r\n\t\tlet animationLast = from.animationLast, animationTime = from.getAnimationTime();\r\n\t\tlet timelineCount = from.animation.timelines.length;\r\n\t\tlet timelines = from.animation.timelines;\r\n\t\tlet alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);\r\n\t\tif (blend == MixBlend.add) {\r\n\t\t\tfor (let i = 0; i < timelineCount; i++)\r\n\t\t\t\ttimelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);\r\n\t\t} else {\r\n\t\t\tlet timelineMode = from.timelineMode;\r\n\t\t\tlet timelineHoldMix = from.timelineHoldMix;\r\n\r\n\t\t\tlet firstFrame = from.timelinesRotation.length == 0;\r\n\t\t\tif (firstFrame) Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\r\n\t\t\tlet timelinesRotation = from.timelinesRotation;\r\n\r\n\t\t\tfrom.totalAlpha = 0;\r\n\t\t\tfor (let i = 0; i < timelineCount; i++) {\r\n\t\t\t\tlet timeline = timelines[i];\r\n\t\t\t\tlet direction = MixDirection.mixOut;\r\n\t\t\t\tlet timelineBlend: MixBlend;\r\n\t\t\t\tlet alpha = 0;\r\n\t\t\t\tswitch (timelineMode[i]) {\r\n\t\t\t\tcase AnimationState.SUBSEQUENT:\r\n\t\t\t\t\tif (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\r\n\t\t\t\t\ttimelineBlend = blend;\r\n\t\t\t\t\talpha = alphaMix;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase AnimationState.FIRST:\r\n\t\t\t\t\ttimelineBlend = MixBlend.setup;\r\n\t\t\t\t\talpha = alphaMix;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase AnimationState.HOLD_SUBSEQUENT:\r\n\t\t\t\t\ttimelineBlend = blend;\r\n\t\t\t\t\talpha = alphaHold;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase AnimationState.HOLD_FIRST:\r\n\t\t\t\t\ttimelineBlend = MixBlend.setup;\r\n\t\t\t\t\talpha = alphaHold;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\ttimelineBlend = MixBlend.setup;\r\n\t\t\t\t\tlet holdMix = timelineHoldMix[i];\r\n\t\t\t\t\talpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tfrom.totalAlpha += alpha;\r\n\r\n\t\t\t\tif (timeline instanceof RotateTimeline)\r\n\t\t\t\t\tthis.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\r\n\t\t\t\telse if (timeline instanceof AttachmentTimeline)\r\n\t\t\t\t\tthis.applyAttachmentTimeline(timeline, skeleton, animationTime, timelineBlend, attachments);\r\n\t\t\t\telse {\r\n\t\t\t\t\t// This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n\t\t\t\t\tUtils.webkit602BugfixHelper(alpha, blend);\r\n\t\t\t\t\tif (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup)\r\n\t\t\t\t\t\tdirection = MixDirection.mixIn;\r\n\t\t\t\t\ttimeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (to.mixDuration > 0) this.queueEvents(from, animationTime);\r\n\t\tthis.events.length = 0;\r\n\t\tfrom.nextAnimationLast = animationTime;\r\n\t\tfrom.nextTrackLast = from.trackTime;\r\n\r\n\t\treturn mix;\r\n\t}\r\n\r\n\tapplyAttachmentTimeline (timeline: AttachmentTimeline, skeleton: Skeleton, time: number, blend: MixBlend, attachments: boolean) {\r\n\r\n\t\tvar slot = skeleton.slots[timeline.slotIndex];\r\n\t\tif (!slot.bone.active) return;\r\n\r\n\t\tvar frames = timeline.frames;\r\n\t\tif (time < frames[0]) { // Time is before first frame.\r\n\t\t\tif (blend == MixBlend.setup || blend == MixBlend.first)\r\n\t\t\t\tthis.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tvar frameIndex;\r\n\t\t\tif (time >= frames[frames.length - 1]) // Time is after last frame.\r\n\t\t\t\tframeIndex = frames.length - 1;\r\n\t\t\telse\r\n\t\t\t\tframeIndex = Animation.binarySearch(frames, time) - 1;\r\n\t\t\tthis.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);\r\n\t\t}\r\n\r\n\t\t// If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.\r\n\t\tif (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + AnimationState.SETUP;\r\n\t}\r\n\r\n\tsetAttachment (skeleton: Skeleton, slot: Slot, attachmentName: string, attachments: boolean) {\r\n\t\tslot.attachment = attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName);\r\n\t\tif (attachments) slot.attachmentState = this.unkeyedState + AnimationState.CURRENT;\r\n\t}\r\n\r\n\r\n\tapplyRotateTimeline (timeline: Timeline, skeleton: Skeleton, time: number, alpha: number, blend: MixBlend,\r\n\t\ttimelinesRotation: Array<number>, i: number, firstFrame: boolean) {\r\n\r\n\t\tif (firstFrame) timelinesRotation[i] = 0;\r\n\r\n\t\tif (alpha == 1) {\r\n\t\t\ttimeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet rotateTimeline = timeline as RotateTimeline;\r\n\t\tlet frames = rotateTimeline.frames;\r\n\t\tlet bone = skeleton.bones[rotateTimeline.boneIndex];\r\n\t\tif (!bone.active) return;\r\n\t\tlet r1 = 0, r2 = 0;\r\n\t\tif (time < frames[0]) {\r\n\t\t\tswitch (blend) {\r\n\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\tbone.rotation = bone.data.rotation;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn;\r\n\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\tr1 = bone.rotation;\r\n\t\t\t\t\tr2 = bone.data.rotation;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tr1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\r\n\t\t\tif (time >= frames[frames.length - RotateTimeline.ENTRIES]) // Time is after last frame.\r\n\t\t\t\tr2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION];\r\n\t\t\telse {\r\n\t\t\t\t// Interpolate between the previous frame and the current frame.\r\n\t\t\t\tlet frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n\t\t\t\tlet prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n\t\t\t\tlet frameTime = frames[frame];\r\n\t\t\t\tlet percent = rotateTimeline.getCurvePercent((frame >> 1) - 1,\r\n\t\t\t\t\t1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n\r\n\t\t\t\tr2 = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n\t\t\t\tr2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n\t\t\t\tr2 = prevRotation + r2 * percent + bone.data.rotation;\r\n\t\t\t\tr2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\r\n\t\tlet total = 0, diff = r2 - r1;\r\n\t\tdiff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\r\n\t\tif (diff == 0) {\r\n\t\t\ttotal = timelinesRotation[i];\r\n\t\t} else {\r\n\t\t\tlet lastTotal = 0, lastDiff = 0;\r\n\t\t\tif (firstFrame) {\r\n\t\t\t\tlastTotal = 0;\r\n\t\t\t\tlastDiff = diff;\r\n\t\t\t} else {\r\n\t\t\t\tlastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\r\n\t\t\t\tlastDiff = timelinesRotation[i + 1]; // Difference between bones.\r\n\t\t\t}\r\n\t\t\tlet current = diff > 0, dir = lastTotal >= 0;\r\n\t\t\t// Detect cross at 0 (not 180).\r\n\t\t\tif (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\r\n\t\t\t\t// A cross after a 360 rotation is a loop.\r\n\t\t\t\tif (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\r\n\t\t\t\tdir = current;\r\n\t\t\t}\r\n\t\t\ttotal = diff + lastTotal - lastTotal % 360; // Store loops as part of lastTotal.\r\n\t\t\tif (dir != current) total += 360 * MathUtils.signum(lastTotal);\r\n\t\t\ttimelinesRotation[i] = total;\r\n\t\t}\r\n\t\ttimelinesRotation[i + 1] = diff;\r\n\t\tr1 += total * alpha;\r\n\t\tbone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\r\n\t}\r\n\r\n\tqueueEvents (entry: TrackEntry, animationTime: number) {\r\n\t\tlet animationStart = entry.animationStart, animationEnd = entry.animationEnd;\r\n\t\tlet duration = animationEnd - animationStart;\r\n\t\tlet trackLastWrapped = entry.trackLast % duration;\r\n\r\n\t\t// Queue events before complete.\r\n\t\tlet events = this.events;\r\n\t\tlet i = 0, n = events.length;\r\n\t\tfor (; i < n; i++) {\r\n\t\t\tlet event = events[i];\r\n\t\t\tif (event.time < trackLastWrapped) break;\r\n\t\t\tif (event.time > animationEnd) continue; // Discard events outside animation start/end.\r\n\t\t\tthis.queue.event(entry, event);\r\n\t\t}\r\n\r\n\t\t// Queue complete if completed a loop iteration or the animation.\r\n\t\tlet complete = false;\r\n\t\tif (entry.loop)\r\n\t\t\tcomplete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\r\n\t\telse\r\n\t\t\tcomplete = animationTime >= animationEnd && entry.animationLast < animationEnd;\r\n\t\tif (complete) this.queue.complete(entry);\r\n\r\n\t\t// Queue events after complete.\r\n\t\tfor (; i < n; i++) {\r\n\t\t\tlet event = events[i];\r\n\t\t\tif (event.time < animationStart) continue; // Discard events outside animation start/end.\r\n\t\t\tthis.queue.event(entry, events[i]);\r\n\t\t}\r\n\t}\r\n\r\n\t/** Removes all animations from all tracks, leaving skeletons in their current pose.\r\n\t *\r\n\t * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\r\n\t * rather than leaving them in their current pose. */\r\n\tclearTracks () {\r\n\t\tlet oldDrainDisabled = this.queue.drainDisabled;\r\n\t\tthis.queue.drainDisabled = true;\r\n\t\tfor (let i = 0, n = this.tracks.length; i < n; i++)\r\n\t\t\tthis.clearTrack(i);\r\n\t\tthis.tracks.length = 0;\r\n\t\tthis.queue.drainDisabled = oldDrainDisabled;\r\n\t\tthis.queue.drain();\r\n\t}\r\n\r\n\t/** Removes all animations from the track, leaving skeletons in their current pose.\r\n\t *\r\n\t * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\r\n\t * rather than leaving them in their current pose. */\r\n\tclearTrack (trackIndex: number) {\r\n\t\tif (trackIndex >= this.tracks.length) return;\r\n\t\tlet current = this.tracks[trackIndex];\r\n\t\tif (current == null) return;\r\n\r\n\t\tthis.queue.end(current);\r\n\r\n\t\tthis.disposeNext(current);\r\n\r\n\t\tlet entry = current;\r\n\t\twhile (true) {\r\n\t\t\tlet from = entry.mixingFrom;\r\n\t\t\tif (from == null) break;\r\n\t\t\tthis.queue.end(from);\r\n\t\t\tentry.mixingFrom = null;\r\n\t\t\tentry.mixingTo = null;\r\n\t\t\tentry = from;\r\n\t\t}\r\n\r\n\t\tthis.tracks[current.trackIndex] = null;\r\n\r\n\t\tthis.queue.drain();\r\n\t}\r\n\r\n\tsetCurrent (index: number, current: TrackEntry, interrupt: boolean) {\r\n\t\tlet from = this.expandToIndex(index);\r\n\t\tthis.tracks[index] = current;\r\n\r\n\t\tif (from != null) {\r\n\t\t\tif (interrupt) this.queue.interrupt(from);\r\n\t\t\tcurrent.mixingFrom = from;\r\n\t\t\tfrom.mixingTo = current;\r\n\t\t\tcurrent.mixTime = 0;\r\n\r\n\t\t\t// Store the interrupted mix percentage.\r\n\t\t\tif (from.mixingFrom != null && from.mixDuration > 0)\r\n\t\t\t\tcurrent.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\r\n\r\n\t\t\tfrom.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\r\n\t\t}\r\n\r\n\t\tthis.queue.start(current);\r\n\t}\r\n\r\n\t/** Sets an animation by name.\r\n\t*\r\n\t* {@link #setAnimationWith(}. */\r\n\tsetAnimation (trackIndex: number, animationName: string, loop: boolean) {\r\n\t\tlet animation = this.data.skeletonData.findAnimation(animationName);\r\n\t\tif (animation == null) throw new Error(\"Animation not found: \" + animationName);\r\n\t\treturn this.setAnimationWith(trackIndex, animation, loop);\r\n\t}\r\n\r\n\t/** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\r\n\t * applied to a skeleton, it is replaced (not mixed from).\r\n\t * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\r\n\t *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\r\n\t * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n\t *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n\tsetAnimationWith (trackIndex: number, animation: Animation, loop: boolean) {\r\n\t\tif (animation == null) throw new Error(\"animation cannot be null.\");\r\n\t\tlet interrupt = true;\r\n\t\tlet current = this.expandToIndex(trackIndex);\r\n\t\tif (current != null) {\r\n\t\t\tif (current.nextTrackLast == -1) {\r\n\t\t\t\t// Don't mix from an entry that was never applied.\r\n\t\t\t\tthis.tracks[trackIndex] = current.mixingFrom;\r\n\t\t\t\tthis.queue.interrupt(current);\r\n\t\t\t\tthis.queue.end(current);\r\n\t\t\t\tthis.disposeNext(current);\r\n\t\t\t\tcurrent = current.mixingFrom;\r\n\t\t\t\tinterrupt = false;\r\n\t\t\t} else\r\n\t\t\t\tthis.disposeNext(current);\r\n\t\t}\r\n\t\tlet entry = this.trackEntry(trackIndex, animation, loop, current);\r\n\t\tthis.setCurrent(trackIndex, entry, interrupt);\r\n\t\tthis.queue.drain();\r\n\t\treturn entry;\r\n\t}\r\n\r\n\t/** Queues an animation by name.\r\n\t *\r\n\t * See {@link #addAnimationWith()}. */\r\n\taddAnimation (trackIndex: number, animationName: string, loop: boolean, delay: number) {\r\n\t\tlet animation = this.data.skeletonData.findAnimation(animationName);\r\n\t\tif (animation == null) throw new Error(\"Animation not found: \" + animationName);\r\n\t\treturn this.addAnimationWith(trackIndex, animation, loop, delay);\r\n\t}\r\n\r\n\t/** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\r\n\t * equivalent to calling {@link #setAnimationWith()}.\r\n\t * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\r\n\t *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\r\n\t *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\r\n\t *           previous entry is looping, its next loop completion is used instead of its duration.\r\n\t * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n\t *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n\taddAnimationWith (trackIndex: number, animation: Animation, loop: boolean, delay: number) {\r\n\t\tif (animation == null) throw new Error(\"animation cannot be null.\");\r\n\r\n\t\tlet last = this.expandToIndex(trackIndex);\r\n\t\tif (last != null) {\r\n\t\t\twhile (last.next != null)\r\n\t\t\t\tlast = last.next;\r\n\t\t}\r\n\r\n\t\tlet entry = this.trackEntry(trackIndex, animation, loop, last);\r\n\r\n\t\tif (last == null) {\r\n\t\t\tthis.setCurrent(trackIndex, entry, true);\r\n\t\t\tthis.queue.drain();\r\n\t\t} else {\r\n\t\t\tlast.next = entry;\r\n\t\t\tif (delay <= 0) {\r\n\t\t\t\tlet duration = last.animationEnd - last.animationStart;\r\n\t\t\t\tif (duration != 0) {\r\n\t\t\t\t\tif (last.loop)\r\n\t\t\t\t\t\tdelay += duration * (1 + ((last.trackTime / duration) | 0));\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tdelay += Math.max(duration, last.trackTime);\r\n\t\t\t\t\tdelay -= this.data.getMix(last.animation, animation);\r\n\t\t\t\t} else\r\n\t\t\t\t\tdelay = last.trackTime;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tentry.delay = delay;\r\n\t\treturn entry;\r\n\t}\r\n\r\n\t/** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\r\n\t * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\r\n\t *\r\n\t * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\r\n\t * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\r\n\t * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\r\n\t * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\r\n\t * 0 still mixes out over one frame.\r\n\t *\r\n\t * Mixing in is done by first setting an empty animation, then adding an animation using\r\n\t * {@link #addAnimation()} and on the returned track entry, set the\r\n\t * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\r\n\t * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\r\n\t * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\r\n\tsetEmptyAnimation (trackIndex: number, mixDuration: number) {\r\n\t\tlet entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\r\n\t\tentry.mixDuration = mixDuration;\r\n\t\tentry.trackEnd = mixDuration;\r\n\t\treturn entry;\r\n\t}\r\n\r\n\t/** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\r\n\t * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\r\n\t * {@link #setEmptyAnimation()}.\r\n\t *\r\n\t * See {@link #setEmptyAnimation()}.\r\n\t * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\r\n\t *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\r\n\t *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\r\n\t *           loop completion is used instead of its duration.\r\n\t * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n\t *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n\taddEmptyAnimation (trackIndex: number, mixDuration: number, delay: number) {\r\n\t\tif (delay <= 0) delay -= mixDuration;\r\n\t\tlet entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\r\n\t\tentry.mixDuration = mixDuration;\r\n\t\tentry.trackEnd = mixDuration;\r\n\t\treturn entry;\r\n\t}\r\n\r\n\t/** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\r\n\t* duration. */\r\n\tsetEmptyAnimations (mixDuration: number) {\r\n\t\tlet oldDrainDisabled = this.queue.drainDisabled;\r\n\t\tthis.queue.drainDisabled = true;\r\n\t\tfor (let i = 0, n = this.tracks.length; i < n; i++) {\r\n\t\t\tlet current = this.tracks[i];\r\n\t\t\tif (current != null) this.setEmptyAnimation(current.trackIndex, mixDuration);\r\n\t\t}\r\n\t\tthis.queue.drainDisabled = oldDrainDisabled;\r\n\t\tthis.queue.drain();\r\n\t}\r\n\r\n\texpandToIndex (index: number) {\r\n\t\tif (index < this.tracks.length) return this.tracks[index];\r\n\t\tUtils.ensureArrayCapacity(this.tracks, index + 1, null);\r\n\t\tthis.tracks.length = index + 1;\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** @param last May be null. */\r\n\ttrackEntry (trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry) {\r\n\t\tlet entry = this.trackEntryPool.obtain();\r\n\t\tentry.trackIndex = trackIndex;\r\n\t\tentry.animation = animation;\r\n\t\tentry.loop = loop;\r\n\t\tentry.holdPrevious = false;\r\n\r\n\t\tentry.eventThreshold = 0;\r\n\t\tentry.attachmentThreshold = 0;\r\n\t\tentry.drawOrderThreshold = 0;\r\n\r\n\t\tentry.animationStart = 0;\r\n\t\tentry.animationEnd = animation.duration;\r\n\t\tentry.animationLast = -1;\r\n\t\tentry.nextAnimationLast = -1;\r\n\r\n\t\tentry.delay = 0;\r\n\t\tentry.trackTime = 0;\r\n\t\tentry.trackLast = -1;\r\n\t\tentry.nextTrackLast = -1;\r\n\t\tentry.trackEnd = Number.MAX_VALUE;\r\n\t\tentry.timeScale = 1;\r\n\r\n\t\tentry.alpha = 1;\r\n\t\tentry.interruptAlpha = 1;\r\n\t\tentry.mixTime = 0;\r\n\t\tentry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\r\n\t\tentry.mixBlend = MixBlend.replace;\r\n\t\treturn entry;\r\n\t}\r\n\r\n\tdisposeNext (entry: TrackEntry) {\r\n\t\tlet next = entry.next;\r\n\t\twhile (next != null) {\r\n\t\t\tthis.queue.dispose(next);\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\t\tentry.next = null;\r\n\t}\r\n\r\n\t_animationsChanged () {\r\n\t\tthis.animationsChanged = false;\r\n\r\n\t\tthis.propertyIDs.clear();\r\n\r\n\t\tfor (let i = 0, n = this.tracks.length; i < n; i++) {\r\n\t\t\tlet entry = this.tracks[i];\r\n\t\t\tif (entry == null) continue;\r\n\t\t\twhile (entry.mixingFrom != null)\r\n\t\t\t\tentry = entry.mixingFrom;\r\n\r\n\t\t\tdo {\r\n\t\t\t\tif (entry.mixingFrom == null || entry.mixBlend != MixBlend.add) this.computeHold(entry);\r\n\t\t\t\tentry = entry.mixingTo;\r\n\t\t\t} while (entry != null)\r\n\t\t}\r\n\t}\r\n\r\n\tcomputeHold (entry: TrackEntry) {\r\n\t\tlet to = entry.mixingTo;\r\n\t\tlet timelines = entry.animation.timelines;\r\n\t\tlet timelinesCount = entry.animation.timelines.length;\r\n\t\tlet timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);\r\n\t\tentry.timelineHoldMix.length = 0;\r\n\t\tlet timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\r\n\t\tlet propertyIDs = this.propertyIDs;\r\n\r\n\t\tif (to != null && to.holdPrevious) {\r\n\t\t\tfor (let i = 0; i < timelinesCount; i++) {\r\n\t\t\t\ttimelineMode[i] = propertyIDs.add(timelines[i].getPropertyId()) ? AnimationState.HOLD_FIRST : AnimationState.HOLD_SUBSEQUENT;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\touter:\r\n\t\tfor (let i = 0; i < timelinesCount; i++) {\r\n\t\t\tlet timeline = timelines[i];\r\n\t\t\tlet id = timeline.getPropertyId();\r\n\t\t\tif (!propertyIDs.add(id))\r\n\t\t\t\ttimelineMode[i] = AnimationState.SUBSEQUENT;\r\n\t\t\telse if (to == null || timeline instanceof AttachmentTimeline || timeline instanceof DrawOrderTimeline\r\n\t\t\t\t|| timeline instanceof EventTimeline || !to.animation.hasTimeline(id)) {\r\n\t\t\t\ttimelineMode[i] = AnimationState.FIRST;\r\n\t\t\t} else {\r\n\t\t\t\tfor (let next = to.mixingTo; next != null; next = next.mixingTo) {\r\n\t\t\t\t\tif (next.animation.hasTimeline(id)) continue;\r\n\t\t\t\t\tif (entry.mixDuration > 0) {\r\n\t\t\t\t\t\ttimelineMode[i] = AnimationState.HOLD_MIX;\r\n\t\t\t\t\t\ttimelineDipMix[i] = next;\r\n\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\ttimelineMode[i] = AnimationState.HOLD_FIRST;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\r\n\tgetCurrent (trackIndex: number) {\r\n\t\tif (trackIndex >= this.tracks.length) return null;\r\n\t\treturn this.tracks[trackIndex];\r\n\t}\r\n\r\n\t/** Adds a listener to receive events for all track entries. */\r\n\taddListener (listener: AnimationStateListener) {\r\n\t\tif (listener == null) throw new Error(\"listener cannot be null.\");\r\n\t\tthis.listeners.push(listener);\r\n\t}\r\n\r\n\t/** Removes the listener added with {@link #addListener()}. */\r\n\tremoveListener (listener: AnimationStateListener) {\r\n\t\tlet index = this.listeners.indexOf(listener);\r\n\t\tif (index >= 0) this.listeners.splice(index, 1);\r\n\t}\r\n\r\n\t/** Removes all listeners added with {@link #addListener()}. */\r\n\tclearListeners () {\r\n\t\tthis.listeners.length = 0;\r\n\t}\r\n\r\n\t/** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\r\n\t * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\r\n\t * are not wanted because new animations are being set. */\r\n\tclearListenerNotifications () {\r\n\t\tthis.queue.clear();\r\n\t}\r\n}\r\n\r\n/** Stores settings and other state for the playback of an animation on an {@link AnimationState} track.\r\n *\r\n * References to a track entry must not be kept after the {@link AnimationStateListener#dispose()} event occurs. */\r\nexport class TrackEntry {\r\n\t/** The animation to apply for this track entry. */\r\n\tanimation: Animation;\r\n\r\n\t/** The animation queued to start after this animation, or null. `next` makes up a linked list. */\r\n\tnext: TrackEntry;\r\n\r\n\t/** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\r\n\t * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\r\n\tmixingFrom: TrackEntry;\r\n\r\n\t/** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\r\n\t * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\r\n\tmixingTo: TrackEntry;\r\n\r\n\t/** The listener for events generated by this track entry, or null.\r\n\t *\r\n\t * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\r\n\t * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\r\n\tlistener: AnimationStateListener;\r\n\r\n\t/** The index of the track where this track entry is either current or queued.\r\n\t *\r\n\t * See {@link AnimationState#getCurrent()}. */\r\n\ttrackIndex: number;\r\n\r\n\t/** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\r\n\t * duration. */\r\n\tloop: boolean;\r\n\r\n\t/** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\r\n\t * of being mixed out.\r\n\t *\r\n\t * When mixing between animations that key the same property, if a lower track also keys that property then the value will\r\n\t * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\r\n\t * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\r\n\t * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\r\n\t * keys the property, only when a higher track also keys the property.\r\n\t *\r\n\t * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\r\n\t * previous animation. */\r\n\tholdPrevious: boolean;\r\n\r\n\t/** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\r\n\t * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\r\n\t * timelines are not applied while this animation is being mixed out. */\r\n\teventThreshold: number;\r\n\r\n\t/** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\r\n\t * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\r\n\t * 0, so attachment timelines are not applied while this animation is being mixed out. */\r\n\tattachmentThreshold: number;\r\n\r\n\t/** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\r\n\t * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\r\n\t * so draw order timelines are not applied while this animation is being mixed out. */\r\n\tdrawOrderThreshold: number;\r\n\r\n\t/** Seconds when this animation starts, both initially and after looping. Defaults to 0.\r\n\t *\r\n\t * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\r\n\t * value to prevent timeline keys before the start time from triggering. */\r\n\tanimationStart: number;\r\n\r\n\t/** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\r\n\t * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\r\n\tanimationEnd: number;\r\n\r\n\r\n\t/** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\r\n\t * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\r\n\t * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\r\n\t * is applied. */\r\n\tanimationLast: number;\r\n\r\n\tnextAnimationLast: number;\r\n\r\n\t/** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\r\n\t * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\r\n\t * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\r\n\t * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\r\n\t *\r\n\t * {@link #timeScale} affects the delay. */\r\n\tdelay: number;\r\n\r\n\t/** Current time in seconds this track entry has been the current track entry. The track time determines\r\n\t * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\r\n\t * looping. */\r\n\ttrackTime: number;\r\n\r\n\ttrackLast: number; nextTrackLast: number;\r\n\r\n\t/** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\r\n\t * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\r\n\t * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\r\n\t * properties keyed by the animation are set to the setup pose and the track is cleared.\r\n\t *\r\n\t * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\r\n\t * abruptly cease being applied. */\r\n\ttrackEnd: number;\r\n\r\n\t/** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\r\n\t * faster. Defaults to 1.\r\n\t *\r\n\t * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\r\n\t * match the animation speed.\r\n\t *\r\n\t * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\r\n\t * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\r\n\t * the time scale is not 1, the delay may need to be adjusted.\r\n\t *\r\n\t * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\r\n\ttimeScale: number;\r\n\r\n\t/** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\r\n\t * to 1, which overwrites the skeleton's current pose with this animation.\r\n\t *\r\n\t * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\r\n\t * use alpha on track 0 if the skeleton pose is from the last frame render. */\r\n\talpha: number;\r\n\r\n\t/** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\r\n\t * slightly more than `mixDuration` when the mix is complete. */\r\n\tmixTime: number;\r\n\r\n\t/** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\r\n\t * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\r\n\t *\r\n\t * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\r\n\t * properties it was animating.\r\n\t *\r\n\t * The `mixDuration` can be set manually rather than use the value from\r\n\t * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\r\n\t * track entry only before {@link AnimationState#update(float)} is first called.\r\n\t *\r\n\t * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\r\n\t * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\r\n\t * afterward. */\r\n\tmixDuration: number; interruptAlpha: number; totalAlpha: number;\r\n\r\n\t/** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\r\n\t * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\r\n\t * the values from the lower tracks.\r\n\t *\r\n\t * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\r\n\t * called. */\r\n\tmixBlend = MixBlend.replace;\r\n\ttimelineMode = new Array<number>();\r\n\ttimelineHoldMix = new Array<TrackEntry>();\r\n\ttimelinesRotation = new Array<number>();\r\n\r\n\treset () {\r\n\t\tthis.next = null;\r\n\t\tthis.mixingFrom = null;\r\n\t\tthis.mixingTo = null;\r\n\t\tthis.animation = null;\r\n\t\tthis.listener = null;\r\n\t\tthis.timelineMode.length = 0;\r\n\t\tthis.timelineHoldMix.length = 0;\r\n\t\tthis.timelinesRotation.length = 0;\r\n\t}\r\n\r\n\t/** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\r\n\t * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\r\n\t * `animationStart` time. */\r\n\tgetAnimationTime () {\r\n\t\tif (this.loop) {\r\n\t\t\tlet duration = this.animationEnd - this.animationStart;\r\n\t\t\tif (duration == 0) return this.animationStart;\r\n\t\t\treturn (this.trackTime % duration) + this.animationStart;\r\n\t\t}\r\n\t\treturn Math.min(this.trackTime + this.animationStart, this.animationEnd);\r\n\t}\r\n\r\n\tsetAnimationLast(animationLast: number) {\r\n\t\tthis.animationLast = animationLast;\r\n\t\tthis.nextAnimationLast = animationLast;\r\n\t}\r\n\r\n\t/** Returns true if at least one loop has been completed.\r\n\t *\r\n\t * See {@link AnimationStateListener#complete()}. */\r\n\tisComplete () {\r\n\t\treturn this.trackTime >= this.animationEnd - this.animationStart;\r\n\t}\r\n\r\n\t/** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\r\n\t * long way around when using {@link #alpha} and starting animations on other tracks.\r\n\t *\r\n\t * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\r\n\t * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\r\n\t * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\r\n\t * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\r\n\tresetRotationDirections () {\r\n\t\tthis.timelinesRotation.length = 0;\r\n\t}\r\n}\r\n\r\nexport class EventQueue {\r\n\tobjects: Array<any> = [];\r\n\tdrainDisabled = false;\r\n\tanimState: AnimationState;\r\n\r\n\tconstructor(animState: AnimationState) {\r\n\t\tthis.animState = animState;\r\n\t}\r\n\r\n\tstart (entry: TrackEntry) {\r\n\t\tthis.objects.push(EventType.start);\r\n\t\tthis.objects.push(entry);\r\n\t\tthis.animState.animationsChanged = true;\r\n\t}\r\n\r\n\tinterrupt (entry: TrackEntry) {\r\n\t\tthis.objects.push(EventType.interrupt);\r\n\t\tthis.objects.push(entry);\r\n\t}\r\n\r\n\tend (entry: TrackEntry) {\r\n\t\tthis.objects.push(EventType.end);\r\n\t\tthis.objects.push(entry);\r\n\t\tthis.animState.animationsChanged = true;\r\n\t}\r\n\r\n\tdispose (entry: TrackEntry) {\r\n\t\tthis.objects.push(EventType.dispose);\r\n\t\tthis.objects.push(entry);\r\n\t}\r\n\r\n\tcomplete (entry: TrackEntry) {\r\n\t\tthis.objects.push(EventType.complete);\r\n\t\tthis.objects.push(entry);\r\n\t}\r\n\r\n\tevent (entry: TrackEntry, event: Event) {\r\n\t\tthis.objects.push(EventType.event);\r\n\t\tthis.objects.push(entry);\r\n\t\tthis.objects.push(event);\r\n\t}\r\n\r\n\tdrain () {\r\n\t\tif (this.drainDisabled) return;\r\n\t\tthis.drainDisabled = true;\r\n\r\n\t\tlet objects = this.objects;\r\n\t\tlet listeners = this.animState.listeners;\r\n\r\n\t\tfor (let i = 0; i < objects.length; i += 2) {\r\n\t\t\tlet type = objects[i] as EventType;\r\n\t\t\tlet entry = objects[i + 1] as TrackEntry;\r\n\t\t\tswitch (type) {\r\n\t\t\tcase EventType.start:\r\n\t\t\t\tif (entry.listener != null && entry.listener.start) entry.listener.start(entry);\r\n\t\t\t\tfor (let ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\tif (listeners[ii].start) listeners[ii].start(entry);\r\n\t\t\t\tbreak;\r\n\t\t\tcase EventType.interrupt:\r\n\t\t\t\tif (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);\r\n\t\t\t\tfor (let ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\tif (listeners[ii].interrupt) listeners[ii].interrupt(entry);\r\n\t\t\t\tbreak;\r\n\t\t\tcase EventType.end:\r\n\t\t\t\tif (entry.listener != null && entry.listener.end) entry.listener.end(entry);\r\n\t\t\t\tfor (let ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\tif (listeners[ii].end) listeners[ii].end(entry);\r\n\t\t\t\t// Fall through.\r\n\t\t\tcase EventType.dispose:\r\n\t\t\t\tif (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);\r\n\t\t\t\tfor (let ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\tif (listeners[ii].dispose) listeners[ii].dispose(entry);\r\n\t\t\t\tthis.animState.trackEntryPool.free(entry);\r\n\t\t\t\tbreak;\r\n\t\t\tcase EventType.complete:\r\n\t\t\t\tif (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);\r\n\t\t\t\tfor (let ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\tif (listeners[ii].complete) listeners[ii].complete(entry);\r\n\t\t\t\tbreak;\r\n\t\t\tcase EventType.event:\r\n\t\t\t\tlet event = objects[i++ + 2] as Event;\r\n\t\t\t\tif (entry.listener != null && entry.listener.event) entry.listener.event(entry, event);\r\n\t\t\t\tfor (let ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\tif (listeners[ii].event) listeners[ii].event(entry, event);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.clear();\r\n\r\n\t\tthis.drainDisabled = false;\r\n\t}\r\n\r\n\tclear () {\r\n\t\tthis.objects.length = 0;\r\n\t}\r\n}\r\n\r\nexport enum EventType {\r\n\tstart, interrupt, end, dispose, complete, event\r\n}\r\n\r\n/** The interface to implement for receiving TrackEntry events. It is always safe to call AnimationState methods when receiving\r\n * events.\r\n *\r\n * See TrackEntry {@link TrackEntry#listener} and AnimationState\r\n * {@link AnimationState#addListener()}. */\r\nexport interface AnimationStateListener {\r\n\t/** Invoked when this entry has been set as the current entry. */\r\n\tstart (entry: TrackEntry): void;\r\n\r\n\t/** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\r\n\t * mixing. */\r\n\tinterrupt (entry: TrackEntry): void;\r\n\r\n\t/** Invoked when this entry is no longer the current entry and will never be applied again. */\r\n\tend (entry: TrackEntry): void;\r\n\r\n\t/** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\r\n\t * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\r\n\tdispose (entry: TrackEntry): void;\r\n\r\n\t/** Invoked every time this entry's animation completes a loop. */\r\n\tcomplete (entry: TrackEntry): void;\r\n\r\n\t/** Invoked when this entry's animation triggers an event. */\r\n\tevent (entry: TrackEntry, event: Event): void;\r\n}\r\n\r\nexport abstract class AnimationStateAdapter implements AnimationStateListener {\r\n\tstart (entry: TrackEntry) {\r\n\t}\r\n\r\n\tinterrupt (entry: TrackEntry) {\r\n\t}\r\n\r\n\tend (entry: TrackEntry) {\r\n\t}\r\n\r\n\tdispose (entry: TrackEntry) {\r\n\t}\r\n\r\n\tcomplete (entry: TrackEntry) {\r\n\t}\r\n\r\n\tevent (entry: TrackEntry, event: Event) {\r\n\t}\r\n}\r\n","\r\n\r\nimport { SkeletonData } from \"./SkeletonData\";\r\nimport { Animation } from \"./Animation\";\r\nimport { Map } from \"./Utils\"\r\n\r\n\r\n/** Stores mix (crossfade) durations to be applied when {@link AnimationState} animations are changed. */\r\nexport class AnimationStateData {\r\n\t/** The SkeletonData to look up animations when they are specified by name. */\r\n\tskeletonData: SkeletonData;\r\n\r\n\tanimationToMixTime: Map<number> = {};\r\n\r\n\t/** The mix duration to use when no mix duration has been defined between two animations. */\r\n\tdefaultMix = 0;\r\n\r\n\tconstructor (skeletonData: SkeletonData) {\r\n\t\tif (skeletonData == null) throw new Error(\"skeletonData cannot be null.\");\r\n\t\tthis.skeletonData = skeletonData;\r\n\t}\r\n\r\n\t/** Sets a mix duration by animation name.\r\n\t *\r\n\t * See {@link #setMixWith()}. */\r\n\tsetMix (fromName: string, toName: string, duration: number) {\r\n\t\tlet from = this.skeletonData.findAnimation(fromName);\r\n\t\tif (from == null) throw new Error(\"Animation not found: \" + fromName);\r\n\t\tlet to = this.skeletonData.findAnimation(toName);\r\n\t\tif (to == null) throw new Error(\"Animation not found: \" + toName);\r\n\t\tthis.setMixWith(from, to, duration);\r\n\t}\r\n\r\n\t/** Sets the mix duration when changing from the specified animation to the other.\r\n\t *\r\n\t * See {@link TrackEntry#mixDuration}. */\r\n\tsetMixWith (from: Animation, to: Animation, duration: number) {\r\n\t\tif (from == null) throw new Error(\"from cannot be null.\");\r\n\t\tif (to == null) throw new Error(\"to cannot be null.\");\r\n\t\tlet key = from.name + \".\" + to.name;\r\n\t\tthis.animationToMixTime[key] = duration;\r\n\t}\r\n\r\n\t/** Returns the mix duration to use when changing from the specified animation to the other, or the {@link #defaultMix} if\r\n\t* no mix duration has been set. */\r\n\tgetMix (from: Animation, to: Animation) {\r\n\t\tlet key = from.name + \".\" + to.name;\r\n\t\tlet value = this.animationToMixTime[key];\r\n\t\treturn value === undefined ? this.defaultMix : value;\r\n\t}\r\n}\r\n","\n\nimport { VertexAttachment, Attachment } from \"./Attachment\";\nimport { SlotData } from \"../SlotData\";\nimport { Color } from \"../Utils\";\n\n\n/** An attachment with vertices that make up a polygon used for clipping the rendering of other attachments. */\nexport class ClippingAttachment extends VertexAttachment {\n\t/** Clipping is performed between the clipping polygon's slot and the end slot. Returns null if clipping is done until the end of\n\t * the skeleton's rendering. */\n\tendSlot: SlotData;\n\n\t// Nonessential.\n\t/** The color of the clipping polygon as it was in Spine. Available only when nonessential data was exported. Clipping polygons\n\t * are not usually rendered at runtime. */\n\tcolor = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\n\n\tconstructor (name: string) {\n\t\tsuper(name);\n\t}\n\n\tcopy (): Attachment {\n\t\tlet copy = new ClippingAttachment(this.name);\n\t\tthis.copyTo(copy);\n\t\tcopy.endSlot = this.endSlot;\n\t\tcopy.color.setFromColor(this.color);\n\t\treturn copy;\n\t}\n}\n","\n\nimport { Pool } from \"./Utils\";\n\n\nexport class Triangulator {\n\tprivate convexPolygons = new Array<Array<number>>();\n\tprivate convexPolygonsIndices = new Array<Array<number>>();\n\n\tprivate indicesArray = new Array<number>();\n\tprivate isConcaveArray = new Array<boolean>();\n\tprivate triangles = new Array<number>();\n\n\tprivate polygonPool = new Pool<Array<number>>(() => {\n\t\treturn new Array<number>();\n\t});\n\n\tprivate polygonIndicesPool = new Pool<Array<number>>(() => {\n\t\treturn new Array<number>();\n\t});\n\n\tpublic triangulate (verticesArray: ArrayLike<number>): Array<number> {\n\t\tlet vertices = verticesArray;\n\t\tlet vertexCount = verticesArray.length >> 1;\n\n\t\tlet indices = this.indicesArray;\n\t\tindices.length = 0;\n\t\tfor (let i = 0; i < vertexCount; i++)\n\t\t\tindices[i] = i;\n\n\t\tlet isConcave = this.isConcaveArray;\n\t\tisConcave.length = 0;\n\t\tfor (let i = 0, n = vertexCount; i < n; ++i)\n\t\t\tisConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\n\n\t\tlet triangles = this.triangles;\n\t\ttriangles.length = 0;\n\n\t\twhile (vertexCount > 3) {\n\t\t\t// Find ear tip.\n\t\t\tlet previous = vertexCount - 1, i = 0, next = 1;\n\t\t\twhile (true) {\n\t\t\t\touter:\n\t\t\t\tif (!isConcave[i]) {\n\t\t\t\t\tlet p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1;\n\t\t\t\t\tlet p1x = vertices[p1], p1y = vertices[p1 + 1];\n\t\t\t\t\tlet p2x = vertices[p2], p2y = vertices[p2 + 1];\n\t\t\t\t\tlet p3x = vertices[p3], p3y = vertices[p3 + 1];\n\t\t\t\t\tfor (let ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\n\t\t\t\t\t\tif (!isConcave[ii]) continue;\n\t\t\t\t\t\tlet v = indices[ii] << 1;\n\t\t\t\t\t\tlet vx = vertices[v], vy = vertices[v + 1];\n\t\t\t\t\t\tif (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\n\t\t\t\t\t\t\tif (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\n\t\t\t\t\t\t\t\tif (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy)) break outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (next == 0) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (!isConcave[i]) break;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t} while (i > 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tprevious = i;\n\t\t\t\ti = next;\n\t\t\t\tnext = (next + 1) % vertexCount;\n\t\t\t}\n\n\t\t\t// Cut ear tip.\n\t\t\ttriangles.push(indices[(vertexCount + i - 1) % vertexCount]);\n\t\t\ttriangles.push(indices[i]);\n\t\t\ttriangles.push(indices[(i + 1) % vertexCount]);\n\t\t\tindices.splice(i, 1);\n\t\t\tisConcave.splice(i, 1);\n\t\t\tvertexCount--;\n\n\t\t\tlet previousIndex = (vertexCount + i - 1) % vertexCount;\n\t\t\tlet nextIndex = i == vertexCount ? 0 : i;\n\t\t\tisConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\n\t\t\tisConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\n\t\t}\n\n\t\tif (vertexCount == 3) {\n\t\t\ttriangles.push(indices[2]);\n\t\t\ttriangles.push(indices[0]);\n\t\t\ttriangles.push(indices[1]);\n\t\t}\n\n\t\treturn triangles;\n\t}\n\n\tdecompose (verticesArray: Array<number>, triangles: Array<number>) : Array<Array<number>> {\n\t\tlet vertices = verticesArray;\n\t\tlet convexPolygons = this.convexPolygons;\n\t\tthis.polygonPool.freeAll(convexPolygons);\n\t\tconvexPolygons.length = 0;\n\n\t\tlet convexPolygonsIndices = this.convexPolygonsIndices;\n\t\tthis.polygonIndicesPool.freeAll(convexPolygonsIndices);\n\t\tconvexPolygonsIndices.length = 0;\n\n\t\tlet polygonIndices = this.polygonIndicesPool.obtain();\n\t\tpolygonIndices.length = 0;\n\n\t\tlet polygon = this.polygonPool.obtain();\n\t\tpolygon.length = 0;\n\n\t\t// Merge subsequent triangles if they form a triangle fan.\n\t\tlet fanBaseIndex = -1, lastWinding = 0;\n\t\tfor (let i = 0, n = triangles.length; i < n; i += 3) {\n\t\t\tlet t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1;\n\t\t\tlet x1 = vertices[t1], y1 = vertices[t1 + 1];\n\t\t\tlet x2 = vertices[t2], y2 = vertices[t2 + 1];\n\t\t\tlet x3 = vertices[t3], y3 = vertices[t3 + 1];\n\n\t\t\t// If the base of the last triangle is the same as this triangle, check if they form a convex polygon (triangle fan).\n\t\t\tlet merged = false;\n\t\t\tif (fanBaseIndex == t1) {\n\t\t\t\tlet o = polygon.length - 4;\n\t\t\t\tlet winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\n\t\t\t\tlet winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\n\t\t\t\tif (winding1 == lastWinding && winding2 == lastWinding) {\n\t\t\t\t\tpolygon.push(x3);\n\t\t\t\t\tpolygon.push(y3);\n\t\t\t\t\tpolygonIndices.push(t3);\n\t\t\t\t\tmerged = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise make this triangle the new base.\n\t\t\tif (!merged) {\n\t\t\t\tif (polygon.length > 0) {\n\t\t\t\t\tconvexPolygons.push(polygon);\n\t\t\t\t\tconvexPolygonsIndices.push(polygonIndices);\n\t\t\t\t} else {\n\t\t\t\t\tthis.polygonPool.free(polygon)\n\t\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\n\t\t\t\t}\n\t\t\t\tpolygon = this.polygonPool.obtain();\n\t\t\t\tpolygon.length = 0;\n\t\t\t\tpolygon.push(x1);\n\t\t\t\tpolygon.push(y1);\n\t\t\t\tpolygon.push(x2);\n\t\t\t\tpolygon.push(y2);\n\t\t\t\tpolygon.push(x3);\n\t\t\t\tpolygon.push(y3);\n\t\t\t\tpolygonIndices = this.polygonIndicesPool.obtain();\n\t\t\t\tpolygonIndices.length = 0;\n\t\t\t\tpolygonIndices.push(t1);\n\t\t\t\tpolygonIndices.push(t2);\n\t\t\t\tpolygonIndices.push(t3);\n\t\t\t\tlastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\n\t\t\t\tfanBaseIndex = t1;\n\t\t\t}\n\t\t}\n\n\t\tif (polygon.length > 0) {\n\t\t\tconvexPolygons.push(polygon);\n\t\t\tconvexPolygonsIndices.push(polygonIndices);\n\t\t}\n\n\t\t// Go through the list of polygons and try to merge the remaining triangles with the found triangle fans.\n\t\tfor (let i = 0, n = convexPolygons.length; i < n; i++) {\n\t\t\tpolygonIndices = convexPolygonsIndices[i];\n\t\t\tif (polygonIndices.length == 0) continue;\n\t\t\tlet firstIndex = polygonIndices[0];\n\t\t\tlet lastIndex = polygonIndices[polygonIndices.length - 1];\n\n\t\t\tpolygon = convexPolygons[i];\n\t\t\tlet o = polygon.length - 4;\n\t\t\tlet prevPrevX = polygon[o], prevPrevY = polygon[o + 1];\n\t\t\tlet prevX = polygon[o + 2], prevY = polygon[o + 3];\n\t\t\tlet firstX = polygon[0], firstY = polygon[1];\n\t\t\tlet secondX = polygon[2], secondY = polygon[3];\n\t\t\tlet winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\n\n\t\t\tfor (let ii = 0; ii < n; ii++) {\n\t\t\t\tif (ii == i) continue;\n\t\t\t\tlet otherIndices = convexPolygonsIndices[ii];\n\t\t\t\tif (otherIndices.length != 3) continue;\n\t\t\t\tlet otherFirstIndex = otherIndices[0];\n\t\t\t\tlet otherSecondIndex = otherIndices[1];\n\t\t\t\tlet otherLastIndex = otherIndices[2];\n\n\t\t\t\tlet otherPoly = convexPolygons[ii];\n\t\t\t\tlet x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];\n\n\t\t\t\tif (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex) continue;\n\t\t\t\tlet winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\n\t\t\t\tlet winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\n\t\t\t\tif (winding1 == winding && winding2 == winding) {\n\t\t\t\t\totherPoly.length = 0;\n\t\t\t\t\totherIndices.length = 0;\n\t\t\t\t\tpolygon.push(x3);\n\t\t\t\t\tpolygon.push(y3);\n\t\t\t\t\tpolygonIndices.push(otherLastIndex);\n\t\t\t\t\tprevPrevX = prevX;\n\t\t\t\t\tprevPrevY = prevY;\n\t\t\t\t\tprevX = x3;\n\t\t\t\t\tprevY = y3;\n\t\t\t\t\tii = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove empty polygons that resulted from the merge step above.\n\t\tfor (let i = convexPolygons.length - 1; i >= 0; i--) {\n\t\t\tpolygon = convexPolygons[i];\n\t\t\tif (polygon.length == 0) {\n\t\t\t\tconvexPolygons.splice(i, 1);\n\t\t\t\tthis.polygonPool.free(polygon);\n\t\t\t\tpolygonIndices = convexPolygonsIndices[i]\n\t\t\t\tconvexPolygonsIndices.splice(i, 1)\n\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\n\t\t\t}\n\t\t}\n\n\t\treturn convexPolygons;\n\t}\n\n\tprivate static isConcave (index: number, vertexCount: number, vertices: ArrayLike<number>, indices: ArrayLike<number>): boolean {\n\t\tlet previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\n\t\tlet current = indices[index] << 1;\n\t\tlet next = indices[(index + 1) % vertexCount] << 1;\n\t\treturn !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next],\n\t\t\tvertices[next + 1]);\n\t}\n\n\tprivate static positiveArea (p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): boolean {\n\t\treturn p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\n\t}\n\n\tprivate static winding (p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): number {\n\t\tlet px = p2x - p1x, py = p2y - p1y;\n\t\treturn p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\n\t}\n}\n","import { Triangulator } from \"./Triangulator\";\nimport { ClippingAttachment } from \"./attachments/ClippingAttachment\";\nimport { Slot } from \"./Slot\";\nimport { Utils, Color, ArrayLike } from \"./Utils\";\n\n\nexport class SkeletonClipping {\n\tprivate triangulator = new Triangulator();\n\tprivate clippingPolygon = new Array<number>();\n\tprivate clipOutput = new Array<number>();\n\tclippedVertices = new Array<number>();\n\tclippedTriangles = new Array<number>();\n\tprivate scratch = new Array<number>();\n\n\tprivate clipAttachment: ClippingAttachment;\n\tprivate clippingPolygons: Array<Array<number>>;\n\n\tclipStart (slot: Slot, clip: ClippingAttachment): number {\n\t\tif (this.clipAttachment != null) return 0;\n\t\tthis.clipAttachment = clip;\n\n\t\tlet n = clip.worldVerticesLength;\n\t\tlet vertices = Utils.setArraySize(this.clippingPolygon, n);\n\t\tclip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n\t\tlet clippingPolygon = this.clippingPolygon;\n\t\tSkeletonClipping.makeClockwise(clippingPolygon);\n\t\tlet clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));\n\t\tfor (let i = 0, n = clippingPolygons.length; i < n; i++) {\n\t\t\tlet polygon = clippingPolygons[i];\n\t\t\tSkeletonClipping.makeClockwise(polygon);\n\t\t\tpolygon.push(polygon[0]);\n\t\t\tpolygon.push(polygon[1]);\n\t\t}\n\n\t\treturn clippingPolygons.length;\n\t}\n\n\tclipEndWithSlot (slot: Slot) {\n\t\tif (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data) this.clipEnd();\n\t}\n\n\tclipEnd () {\n\t\tif (this.clipAttachment == null) return;\n\t\tthis.clipAttachment = null;\n\t\tthis.clippingPolygons = null;\n\t\tthis.clippedVertices.length = 0;\n\t\tthis.clippedTriangles.length = 0;\n\t\tthis.clippingPolygon.length = 0;\n\t}\n\n\tisClipping (): boolean {\n\t\treturn this.clipAttachment != null;\n\t}\n\n\tclipTriangles (vertices: ArrayLike<number>, verticesLength: number, triangles: ArrayLike<number>, trianglesLength: number, uvs: ArrayLike<number>,\n\t\tlight: Color, dark: Color, twoColor: boolean) {\n\n\t\tlet clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;\n\t\tlet clippedTriangles = this.clippedTriangles;\n\t\tlet polygons = this.clippingPolygons;\n\t\tlet polygonsCount = this.clippingPolygons.length;\n\t\tlet vertexSize = twoColor ? 12 : 8;\n\n\t\tlet index = 0;\n\t\tclippedVertices.length = 0;\n\t\tclippedTriangles.length = 0;\n\t\touter:\n\t\tfor (let i = 0; i < trianglesLength; i += 3) {\n\t\t\tlet vertexOffset = triangles[i] << 1;\n\t\t\tlet x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];\n\t\t\tlet u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];\n\n\t\t\tvertexOffset = triangles[i + 1] << 1;\n\t\t\tlet x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];\n\t\t\tlet u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];\n\n\t\t\tvertexOffset = triangles[i + 2] << 1;\n\t\t\tlet x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];\n\t\t\tlet u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];\n\n\t\t\tfor (let p = 0; p < polygonsCount; p++) {\n\t\t\t\tlet s = clippedVertices.length;\n\t\t\t\tif (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\n\t\t\t\t\tlet clipOutputLength = clipOutput.length;\n\t\t\t\t\tif (clipOutputLength == 0) continue;\n\t\t\t\t\tlet d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;\n\t\t\t\t\tlet d = 1 / (d0 * d2 + d1 * (y1 - y3));\n\n\t\t\t\t\tlet clipOutputCount = clipOutputLength >> 1;\n\t\t\t\t\tlet clipOutputItems = this.clipOutput;\n\t\t\t\t\tlet clippedVerticesItems = Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\n\t\t\t\t\tfor (let ii = 0; ii < clipOutputLength; ii += 2) {\n\t\t\t\t\t\tlet x = clipOutputItems[ii], y = clipOutputItems[ii + 1];\n\t\t\t\t\t\tclippedVerticesItems[s] = x;\n\t\t\t\t\t\tclippedVerticesItems[s + 1] = y;\n\t\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\n\t\t\t\t\t\tlet c0 = x - x3, c1 = y - y3;\n\t\t\t\t\t\tlet a = (d0 * c0 + d1 * c1) * d;\n\t\t\t\t\t\tlet b = (d4 * c0 + d2 * c1) * d;\n\t\t\t\t\t\tlet c = 1 - a - b;\n\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\n\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\n\t\t\t\t\t\tif (twoColor) {\n\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts += vertexSize;\n\t\t\t\t\t}\n\n\t\t\t\t\ts = clippedTriangles.length;\n\t\t\t\t\tlet clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\n\t\t\t\t\tclipOutputCount--;\n\t\t\t\t\tfor (let ii = 1; ii < clipOutputCount; ii++) {\n\t\t\t\t\t\tclippedTrianglesItems[s] = index;\n\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + ii);\n\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + ii + 1);\n\t\t\t\t\t\ts += 3;\n\t\t\t\t\t}\n\t\t\t\t\tindex += clipOutputCount + 1;\n\n\t\t\t\t} else {\n\t\t\t\t\tlet clippedVerticesItems = Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\n\t\t\t\t\tclippedVerticesItems[s] = x1;\n\t\t\t\t\tclippedVerticesItems[s + 1] = y1;\n\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\n\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\n\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\n\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\n\t\t\t\t\tif (!twoColor) {\n\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\n\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\n\n\t\t\t\t\t\tclippedVerticesItems[s + 8] = x2;\n\t\t\t\t\t\tclippedVerticesItems[s + 9] = y2;\n\t\t\t\t\t\tclippedVerticesItems[s + 10] = light.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 11] = light.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 12] = light.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 13] = light.a;\n\t\t\t\t\t\tclippedVerticesItems[s + 14] = u2;\n\t\t\t\t\t\tclippedVerticesItems[s + 15] = v2;\n\n\t\t\t\t\t\tclippedVerticesItems[s + 16] = x3;\n\t\t\t\t\t\tclippedVerticesItems[s + 17] = y3;\n\t\t\t\t\t\tclippedVerticesItems[s + 18] = light.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 19] = light.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 20] = light.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 21] = light.a;\n\t\t\t\t\t\tclippedVerticesItems[s + 22] = u3;\n\t\t\t\t\t\tclippedVerticesItems[s + 23] = v3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\n\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\n\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\n\n\t\t\t\t\t\tclippedVerticesItems[s + 12] = x2;\n\t\t\t\t\t\tclippedVerticesItems[s + 13] = y2;\n\t\t\t\t\t\tclippedVerticesItems[s + 14] = light.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 15] = light.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 16] = light.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 17] = light.a;\n\t\t\t\t\t\tclippedVerticesItems[s + 18] = u2;\n\t\t\t\t\t\tclippedVerticesItems[s + 19] = v2;\n\t\t\t\t\t\tclippedVerticesItems[s + 20] = dark.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 21] = dark.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 22] = dark.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 23] = dark.a;\n\n\t\t\t\t\t\tclippedVerticesItems[s + 24] = x3;\n\t\t\t\t\t\tclippedVerticesItems[s + 25] = y3;\n\t\t\t\t\t\tclippedVerticesItems[s + 26] = light.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 27] = light.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 28] = light.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 29] = light.a;\n\t\t\t\t\t\tclippedVerticesItems[s + 30] = u3;\n\t\t\t\t\t\tclippedVerticesItems[s + 31] = v3;\n\t\t\t\t\t\tclippedVerticesItems[s + 32] = dark.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 33] = dark.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 34] = dark.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 35] = dark.a;\n\t\t\t\t\t}\n\n\t\t\t\t\ts = clippedTriangles.length;\n\t\t\t\t\tlet clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s + 3);\n\t\t\t\t\tclippedTrianglesItems[s] = index;\n\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + 1);\n\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + 2);\n\t\t\t\t\tindex += 3;\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Clips the input triangle against the convex, clockwise clipping area. If the triangle lies entirely within the clipping\n\t * area, false is returned. The clipping area must duplicate the first vertex at the end of the vertices list. */\n\tclip (x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, clippingArea: Array<number>, output: Array<number>) {\n\t\tlet originalOutput = output;\n\t\tlet clipped = false;\n\n\t\t// Avoid copy at the end.\n\t\tlet input: Array<number> = null;\n\t\tif (clippingArea.length % 4 >= 2) {\n\t\t\tinput = output;\n\t\t\toutput = this.scratch;\n\t\t} else\n\t\t\tinput = this.scratch;\n\n\t\tinput.length = 0;\n\t\tinput.push(x1);\n\t\tinput.push(y1);\n\t\tinput.push(x2);\n\t\tinput.push(y2);\n\t\tinput.push(x3);\n\t\tinput.push(y3);\n\t\tinput.push(x1);\n\t\tinput.push(y1);\n\t\toutput.length = 0;\n\n\t\tlet clippingVertices = clippingArea;\n\t\tlet clippingVerticesLast = clippingArea.length - 4;\n\t\tfor (let i = 0;; i += 2) {\n\t\t\tlet edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1];\n\t\t\tlet edgeX2 = clippingVertices[i + 2], edgeY2 = clippingVertices[i + 3];\n\t\t\tlet deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;\n\n\t\t\tlet inputVertices = input;\n\t\t\tlet inputVerticesLength = input.length - 2, outputStart = output.length;\n\t\t\tfor (let ii = 0; ii < inputVerticesLength; ii += 2) {\n\t\t\t\tlet inputX = inputVertices[ii], inputY = inputVertices[ii + 1];\n\t\t\t\tlet inputX2 = inputVertices[ii + 2], inputY2 = inputVertices[ii + 3];\n\t\t\t\tlet side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;\n\t\t\t\tif (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {\n\t\t\t\t\tif (side2) { // v1 inside, v2 inside\n\t\t\t\t\t\toutput.push(inputX2);\n\t\t\t\t\t\toutput.push(inputY2);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// v1 inside, v2 outside\n\t\t\t\t\tlet c0 = inputY2 - inputY, c2 = inputX2 - inputX;\n\t\t\t\t\tlet s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);\n\t\t\t\t\tif (Math.abs(s) > 0.000001) {\n\t\t\t\t\t\tlet ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;\n\t\t\t\t\t\toutput.push(edgeX + (edgeX2 - edgeX) * ua);\n\t\t\t\t\t\toutput.push(edgeY + (edgeY2 - edgeY) * ua);\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput.push(edgeX);\n\t\t\t\t\t\toutput.push(edgeY);\n\t\t\t\t\t}\n\t\t\t\t} else if (side2) { // v1 outside, v2 inside\n\t\t\t\t\tlet c0 = inputY2 - inputY, c2 = inputX2 - inputX;\n\t\t\t\t\tlet s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);\n\t\t\t\t\tif (Math.abs(s) > 0.000001) {\n\t\t\t\t\t\tlet ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;\n\t\t\t\t\t\toutput.push(edgeX + (edgeX2 - edgeX) * ua);\n\t\t\t\t\t\toutput.push(edgeY + (edgeY2 - edgeY) * ua);\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput.push(edgeX);\n\t\t\t\t\t\toutput.push(edgeY);\n\t\t\t\t\t}\n\t\t\t\t\toutput.push(inputX2);\n\t\t\t\t\toutput.push(inputY2);\n\t\t\t\t}\n\t\t\t\tclipped = true;\n\t\t\t}\n\n\t\t\tif (outputStart == output.length) { // All edges outside.\n\t\t\t\toriginalOutput.length = 0;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\toutput.push(output[0]);\n\t\t\toutput.push(output[1]);\n\n\t\t\tif (i == clippingVerticesLast) break;\n\t\t\tlet temp = output;\n\t\t\toutput = input;\n\t\t\toutput.length = 0;\n\t\t\tinput = temp;\n\t\t}\n\n\t\tif (originalOutput != output) {\n\t\t\toriginalOutput.length = 0;\n\t\t\tfor (let i = 0, n = output.length - 2; i < n; i++)\n\t\t\t\toriginalOutput[i] = output[i];\n\t\t} else\n\t\t\toriginalOutput.length = originalOutput.length - 2;\n\n\t\treturn clipped;\n\t}\n\n\tpublic static makeClockwise (polygon: ArrayLike<number>) {\n\t\tlet vertices = polygon;\n\t\tlet verticeslength = polygon.length;\n\n\t\tlet area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;\n\t\tfor (let i = 0, n = verticeslength - 3; i < n; i += 2) {\n\t\t\tp1x = vertices[i];\n\t\t\tp1y = vertices[i + 1];\n\t\t\tp2x = vertices[i + 2];\n\t\t\tp2y = vertices[i + 3];\n\t\t\tarea += p1x * p2y - p2x * p1y;\n\t\t}\n\t\tif (area < 0) return;\n\n\t\tfor (let i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\n\t\t\tlet x = vertices[i], y = vertices[i + 1];\n\t\t\tlet other = lastX - i;\n\t\t\tvertices[i] = vertices[other];\n\t\t\tvertices[i + 1] = vertices[other + 1];\n\t\t\tvertices[other] = x;\n\t\t\tvertices[other + 1] = y;\n\t\t}\n\t}\n}\n","import {\n  BufferMesh,\n  Engine,\n  Buffer,\n  VertexElement,\n  VertexElementFormat,\n  BufferBindFlag,\n  IndexFormat,\n  BufferUsage,\n} from 'oasis-engine';\nimport { MeshGenerator } from './MeshGenerator';\n\nexport class SpineMesh {\n\n  private _mesh: BufferMesh;\n\n  private _indexBuffer: Buffer;\n  private _vertexBuffer: Buffer;\n\n  get mesh() {\n    return this._mesh;\n  }\n\n  get indexBuffer() {\n    return this._indexBuffer;\n  }\n\n  get vertexBuffer() {\n    return this._vertexBuffer;\n  }\n\n  initialize(engine: Engine, vertexCount: number) {\n    const mesh = this._mesh = new BufferMesh(engine);\n\n    const vertexElements = [\n      new VertexElement('POSITION', 0, VertexElementFormat.Vector3, 0),\n      new VertexElement('COLOR_0', 12, VertexElementFormat.Vector4, 0),\n      new VertexElement('TEXCOORD_0', 28, VertexElementFormat.Vector2, 0),\n    ];\n\n    const vertexStride = (MeshGenerator.VERTEX_STRIDE) * 4; // position + color + uv * Float32 byteLen\n    const byteLength = vertexStride * vertexCount;\n    const vertexBuffer = new Buffer(\n      engine,\n      BufferBindFlag.VertexBuffer,\n      byteLength,\n      BufferUsage.Dynamic\n    );\n\n    const indexBuffer = new Buffer(\n      engine,\n      BufferBindFlag.IndexBuffer,\n      vertexCount * 2,\n      BufferUsage.Dynamic\n    );\n\n    this._indexBuffer = indexBuffer;\n    this._vertexBuffer = vertexBuffer;\n\n    mesh.setVertexBufferBinding(vertexBuffer, vertexStride);\n    mesh.setIndexBufferBinding(indexBuffer, IndexFormat.UInt16);\n    mesh.setVertexElements(vertexElements);\n    mesh.addSubMesh(0, vertexCount);\n  }\n\n  changeBuffer(engine: Engine, vertexCount: number) {\n    const vertexStride = (MeshGenerator.VERTEX_STRIDE) * 4; // position + color + uv * Float32 byteLen\n    const byteLength = vertexStride * vertexCount;\n    const vertexBuffer = new Buffer(\n      engine,\n      BufferBindFlag.VertexBuffer,\n      byteLength,\n      BufferUsage.Dynamic\n    );\n\n    const indexBuffer = new Buffer(\n      engine,\n      BufferBindFlag.IndexBuffer,\n      vertexCount * 2,\n      BufferUsage.Dynamic\n    );\n    const mesh = this._mesh;\n    this._indexBuffer = indexBuffer;\n    this._vertexBuffer = vertexBuffer;\n    mesh.setVertexBufferBinding(vertexBuffer, vertexStride);\n    mesh.setIndexBufferBinding(indexBuffer, IndexFormat.UInt16);\n  }\n}","import {\n  Engine,\n  Entity,\n  MeshRenderer,\n  SubMesh,\n} from 'oasis-engine';\nimport { Skeleton } from '../spine-core/Skeleton';\nimport { SkeletonData } from '../spine-core/SkeletonData';\nimport { RegionAttachment } from '../spine-core/attachments/RegionAttachment';\nimport { MeshAttachment } from '../spine-core/attachments/MeshAttachment';\nimport { ClippingAttachment } from '../spine-core/attachments/ClippingAttachment';\nimport { ArrayLike, Color } from '../spine-core/Utils';\nimport { SkeletonClipping } from '../spine-core/SkeletonClipping';\nimport { SpineMesh } from './SpineMesh';\nimport { SpineRenderSetting } from '../types';\n\ntype SubMeshItem = {\n  subMesh: SubMesh;\n  name: string;\n}\nexport class MeshGenerator {\n  static QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\n  static VERTEX_SIZE = 8; // 2 2 4 position without z, uv, color\n  static VERTEX_STRIDE = 9; // 3 2 4 position with z, uv, color\n  static tempColor: Color = new Color();\n\n  private _setting: SpineRenderSetting;\n  private _engine: Engine;\n  private _entity: Entity;\n  private _clipper: SkeletonClipping = new SkeletonClipping();\n  private _spineMesh: SpineMesh = new SpineMesh();\n\n  private _vertexCount: number;\n  private _vertices: Float32Array;\n  private _verticesWithZ: Float32Array;\n  private _indices: Uint16Array;\n  private _needResize: boolean = false;\n  private _meshRenderer: MeshRenderer;\n  private _subMeshItems: SubMeshItem[] = [];\n  readonly separateSlots: string[] = [];\n\n  get mesh() {\n    return this._spineMesh.mesh;\n  }\n\n  get subMeshItems() {\n    return this._subMeshItems;\n  }\n\n  constructor(engine: Engine, entity: Entity) {\n    this._engine = engine;\n    this._entity = entity;\n  }\n\n  initialize(skeletonData: SkeletonData, setting?: SpineRenderSetting) {\n    if (!skeletonData) return;\n\n    const meshRenderer = this._entity.getComponent(MeshRenderer);\n    if (!meshRenderer) {\n      console.warn('You need add MeshRenderer component to entity first');\n      return;\n    }\n    this._meshRenderer = meshRenderer;\n\n    if (setting) {\n      this._setting = setting;\n    }\n\n    // Prepare buffer by using all attachment data but clippingAttachment\n    const { defaultSkin: { attachments } } = skeletonData;\n    let vertexCount: number = 0;\n    const QUAD_TRIANGLE_LENGTH = MeshGenerator.QUAD_TRIANGLES.length;\n    for (let i = 0, n = attachments.length; i < n; i++) {\n      const slotAttachment = attachments[i];\n      for (let key in slotAttachment) {\n        const attachment = slotAttachment[key];\n        if (!attachment) {\n          continue;\n        } else if (attachment instanceof RegionAttachment) {\n          vertexCount += QUAD_TRIANGLE_LENGTH;\n        } else if (attachment instanceof MeshAttachment) {\n          let mesh = attachment;\n          vertexCount += mesh.triangles.length;\n        } else continue;\n      }\n    }\n    this._vertexCount = vertexCount;\n    this._prepareBufferData(this._vertexCount);\n    const { _spineMesh } = this;\n    _spineMesh.initialize(this._engine, this._vertexCount);\n    meshRenderer.mesh = _spineMesh.mesh;\n  }\n\n  buildMesh(skeleton: Skeleton) {\n    const {\n      useClipping = true,\n      zSpacing = 0.01,\n    } = this._setting || {};\n\n    let verticesLength = 0;\n    let indicesLength = 0;\n    this._subMeshItems.length = 0;\n    \n    const meshRenderer = this._meshRenderer;\n    const drawOrder = skeleton.drawOrder;\n    const maxSlotCount = drawOrder.length;\n    const { _clipper, _spineMesh } = this;\n    const { mesh } = _spineMesh;\n    const subMeshItems = this._subMeshItems;\n    let vertices: ArrayLike<number> = this._vertices;\n    let triangles: Array<number>;\n    let uvs: ArrayLike<number>;\n    let start = 0;\n    let count = 0;\n    for (let slotIndex = 0; slotIndex < maxSlotCount; slotIndex += 1) {\n      const slot = drawOrder[slotIndex];\n\n      if (!slot.bone.active) {\n        _clipper.clipEndWithSlot(slot);\n        continue;\n      }\n      const attachment = slot.getAttachment();\n      let attachmentColor: Color = null;\n      let texture = null;\n      const z = zSpacing * slotIndex;\n      let numFloats = 0;\n      let vertexSize = _clipper.isClipping() ? 2 : MeshGenerator.VERTEX_SIZE;\n      if (\n        attachment instanceof RegionAttachment\n      ) {\n        let regionAttachment = <RegionAttachment>attachment;\n        attachmentColor = regionAttachment.color;\n        vertices = this._vertices;\n        numFloats = vertexSize * 4;\n        regionAttachment.computeWorldVertices(slot.bone, vertices, 0, vertexSize);\n        triangles = MeshGenerator.QUAD_TRIANGLES;\n        uvs = regionAttachment.uvs;\n        texture = regionAttachment.region.renderObject.texture;\n      } else if (\n        attachment instanceof MeshAttachment\n      ) {\n        let meshAttachment = <MeshAttachment>attachment;\n        attachmentColor = meshAttachment.color;\n        vertices = this._vertices;\n        numFloats = (meshAttachment.worldVerticesLength >> 1) * vertexSize;\n        if (numFloats > vertices.length) {\n          vertices = this._vertices = new Float32Array(numFloats);\n        }\n        meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, vertexSize);\n        triangles = meshAttachment.triangles;\n        uvs = meshAttachment.uvs;\n        texture = meshAttachment.region.renderObject.texture;\n      }  else if (\n        attachment instanceof ClippingAttachment\n      ) {\n        if (useClipping) {\n          let clip = <ClippingAttachment>(attachment);\n          _clipper.clipStart(slot, clip);\n          continue;\n        }\n      } else if (useClipping) { // attachment might be null or BoundingBoxAttachment\n        _clipper.clipEndWithSlot(slot);\n        continue;\n      }\n\n      if (texture != null) {\n        let finalVertices: ArrayLike<number>;\n        let finalVerticesLength: number;\n        let finalIndices: ArrayLike<number>;\n        let finalIndicesLength: number;\n\n        let skeleton = slot.bone.skeleton;\n        let skeletonColor = skeleton.color;\n        let slotColor = slot.color;\n        let alpha = skeletonColor.a * slotColor.a * attachmentColor.a;\n        let color = MeshGenerator.tempColor;\n        color.set(skeletonColor.r * slotColor.r * attachmentColor.r,\n            skeletonColor.g * slotColor.g * attachmentColor.g,\n            skeletonColor.b * slotColor.b * attachmentColor.b,\n            alpha);\n\n        if (_clipper.isClipping()) {\n          _clipper.clipTriangles(vertices, numFloats, triangles, triangles.length, uvs, color, null, false);\n          let clippedVertices = _clipper.clippedVertices;\n          let clippedTriangles = _clipper.clippedTriangles;\n          finalVertices = clippedVertices;\n          finalVerticesLength = clippedVertices.length;\n          finalIndices = clippedTriangles;\n          finalIndicesLength = clippedTriangles.length;\n        } else {\n          let verts = vertices;\n          for (let v = 2, u = 0, n = numFloats; v < n; v += vertexSize, u += 2) {\n            verts[v] = color.r;\n            verts[v + 1] = color.g;\n            verts[v + 2] = color.b;\n            verts[v + 3] = color.a;\n            verts[v + 4] = uvs[u];\n            verts[v + 5] = uvs[u + 1];\n          }\n          finalVertices = vertices;\n          finalVerticesLength = numFloats;\n          finalIndices = triangles;\n          finalIndicesLength = triangles.length;\n        }\n\n        let indexStart = verticesLength / MeshGenerator.VERTEX_STRIDE;\n        let verticesWithZ = this._verticesWithZ;\n        let i = verticesLength;\n        let j = 0;\n        for (; j < finalVerticesLength;) {\n          verticesWithZ[i++] = finalVertices[j++];\n          verticesWithZ[i++] = finalVertices[j++];\n          verticesWithZ[i++] = z;\n          verticesWithZ[i++] = finalVertices[j++];\n          verticesWithZ[i++] = finalVertices[j++];\n          verticesWithZ[i++] = finalVertices[j++];\n          verticesWithZ[i++] = finalVertices[j++];\n          verticesWithZ[i++] = finalVertices[j++];\n          verticesWithZ[i++] = finalVertices[j++];\n        }\n        verticesLength = i;\n\n        let indicesArray = this._indices;\n        for (i = indicesLength, j = 0; j < finalIndicesLength; i++, j++) {\n          indicesArray[i] = finalIndices[j] + indexStart;\n        }\n\n        // add submesh\n        const slotName = slot.data.name;\n        const needSeparate = this.separateSlots.includes(slotName);\n\n        if (needSeparate) {\n          const subMesh = new SubMesh(indicesLength, finalIndicesLength);\n          subMeshItems.push({\n            name: slotName,\n            subMesh,\n          });\n          if (count > 0) {\n            const prevSubMesh = new SubMesh(start, count);\n            subMeshItems.push({\n              name: 'default',\n              subMesh: prevSubMesh,\n            });\n            count = 0;\n          }\n          start = indicesLength + finalIndicesLength;\n        } else {\n          count += finalIndicesLength;\n        }\n        \n        indicesLength += finalIndicesLength;\n\n        const materials = meshRenderer.getMaterials();\n        const materialLength = materials.length;\n        for (let i = 0; i < materialLength; i += 1) {\n          const mtl = materials[i];\n          if (!mtl.shaderData.getTexture('u_cusTomTexture')) {\n            mtl.shaderData.setTexture('u_cusTomTexture', texture.texture);\n          }\n        }\n      }\n\n      _clipper.clipEndWithSlot(slot);\n\n    } // slot traverse end\n\n    _clipper.clipEnd();\n\n    // add reset sub mesh\n    if (count > 0) {\n      const subMesh = new SubMesh(start, count);\n      subMeshItems.push({\n        name: 'default',\n        subMesh,\n      });\n      count = 0;\n    }\n\n    // sort sub-mesh\n    subMeshItems.sort((a, b) => a.subMesh.start - b.subMesh.start);\n\n    // update buffer when vertex count change\n    if (indicesLength > 0 && indicesLength !== this._vertexCount) {\n      if (indicesLength > this._vertexCount) {\n        this._vertexCount = indicesLength;\n        this._prepareBufferData(this._vertexCount);\n        this._needResize = true;\n        return;\n      }\n    }\n\n    // update sub-mesh\n    mesh.clearSubMesh();\n    const subMeshItemLength = subMeshItems.length;\n    for (let i = 0; i < subMeshItemLength; i += 1) {\n      mesh.addSubMesh(subMeshItems[i].subMesh);\n    }\n\n    if (this._needResize) {\n      // #1\n      _spineMesh.vertexBuffer.resize(this._verticesWithZ.byteLength);\n      _spineMesh.indexBuffer.resize(this._indices.byteLength);\n      // #2 https://github.com/oasis-engine/engine/issues/376\n      // spineMesh.changeBuffer(this.engine, this.vertexCount);\n      this._needResize = false;\n    }\n    _spineMesh.vertexBuffer.setData(this._verticesWithZ);\n    _spineMesh.indexBuffer.setData(this._indices);\n  }\n\n  addSeparateSlot(slotName: string) {\n    this.separateSlots.push(slotName);\n  }\n\n  private _prepareBufferData(vertexCount: number) {\n    this._vertices = new Float32Array(vertexCount * MeshGenerator.VERTEX_SIZE);\n    this._verticesWithZ = new Float32Array(vertexCount * MeshGenerator.VERTEX_STRIDE);\n    this._indices = new Uint16Array(vertexCount);\n  }\n}","\r\n\r\n\r\n\r\n\t/** Determines how images are blended with existing pixels when drawn. */\r\n\texport enum BlendMode {\r\n\t\tNormal,\r\n\t\tAdditive,\r\n\t\tMultiply,\r\n\t\tScreen\r\n\t}\r\n","import { Skeleton } from './spine-core/Skeleton';\nimport { SkeletonData } from './spine-core/SkeletonData';\nimport { AnimationState } from './spine-core/AnimationState';\nimport { AnimationStateData } from './spine-core/AnimationStateData';\nimport { MeshGenerator } from './core/MeshGenerator';\nimport { SpineRenderSetting } from './types';\nimport {\n  Script,\n  Entity,\n  ignoreClone,\n  MeshRenderer,\n  Texture2D,\n} from 'oasis-engine';\n\nexport class SpineAnimation extends Script {\n  @ignoreClone\n  private _skeletonData: SkeletonData;\n  @ignoreClone\n  private _skeleton: Skeleton;\n  @ignoreClone\n  private _state: AnimationState;\n  @ignoreClone\n  protected _meshGenerator: MeshGenerator;\n  @ignoreClone\n  setting: SpineRenderSetting;\n  autoUpdate: boolean = true;\n\n  get skeletonData() {\n    return this._skeletonData;\n  }\n\n  get skeleton() {\n    return this._skeleton;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  get mesh() {\n    return this._meshGenerator.mesh;\n  }\n\n  set scale(v: number) {\n    if (this._skeleton) {\n      this._skeleton.scaleX = v;\n      this._skeleton.scaleY = v;\n    }\n  }\n\n  constructor(entity: Entity) {\n    super(entity);\n    this._meshGenerator = new MeshGenerator(this.engine, entity);\n  }\n\n  setSkeletonData(skeletonData: SkeletonData, setting?: SpineRenderSetting) {\n    if (!skeletonData) {\n      console.error('SkeletonData is undefined');\n    }\n    this.setting = setting;\n    this._skeletonData = skeletonData;\n    this._skeleton = new Skeleton(skeletonData);\n    const animationData = new AnimationStateData(skeletonData);\n    this._state = new AnimationState(animationData);\n    this._meshGenerator.initialize(skeletonData, this.setting);\n  }\n\n  /**\n   * Separate slot by slot name. This will add a new sub mesh, and new materials.\n   */\n  addSeparateSlot(slotName: string) {\n    if (!this.skeleton) {\n      console.error('Skeleton not found!');\n    }\n    const meshRenderer = this.entity.getComponent(MeshRenderer);\n    if (!meshRenderer) {\n      console.warn('You need add MeshRenderer component to entity first');\n    }\n    const slot = this.skeleton.findSlot(slotName);\n    if (slot) {\n      this._meshGenerator.addSeparateSlot(slotName);\n      // add sprite default material for new sub mesh\n      const mtl1 = this.engine._spriteDefaultMaterial.clone();\n      const mtl2 = this.engine._spriteDefaultMaterial.clone();\n      const { materialCount } = meshRenderer;\n      // one split will generate two sub mesh, thus two materials required\n      // if no sub mesh generated, redundant material will ignored by renderer\n      meshRenderer.setMaterial(materialCount, mtl1);\n      meshRenderer.setMaterial(materialCount + 1, mtl2);\n    } else {\n      console.warn(`Slot: ${slotName} not find.`);\n    }\n  }\n\n  /**\n   * Change texture of a separated slot by name.\n   */\n  hackSeparateSlotTexture(slotName: string, texture: Texture2D) {\n    this._meshGenerator.buildMesh(this._skeleton);\n    const { separateSlots, subMeshItems } = this._meshGenerator;\n    if (separateSlots.length === 0) {\n      console.warn('You need add separate slot');\n      return;\n    }\n    if (separateSlots.includes(slotName)) {\n      const meshRenderer = this.entity.getComponent(MeshRenderer);\n      const subMeshIndex = subMeshItems.findIndex(item => item.name === slotName);\n      const mtl = meshRenderer.getMaterial(subMeshIndex);\n      mtl.shaderData.setTexture('u_cusTomTexture', texture);\n    } else {\n      console.warn(`Slot ${slotName} is not separated. You should use addSeparateSlot to separate it`);\n    }\n  }\n\n  disposeCurrentSkeleton() {\n    this._skeletonData = null;\n    // TODO\n  }\n\n  onUpdate(delta: number) {\n    if (this.autoUpdate) {\n      this.updateState(delta * 0.001);\n    }\n  }\n\n  updateState(deltaTime: number) {\n    if (!this._skeleton || !this.state) return;\n    const state = this._state;\n    const skeleton = this._skeleton;\n\n    state.update(deltaTime);\n    state.apply(skeleton);\n    skeleton.updateWorldTransform();\n\n    this.updateGeometry();\n  }\n\n  updateGeometry() {\n    if (!this._skeleton) return;\n    this._meshGenerator.buildMesh(this._skeleton);\n  }\n\n  /**\n   * Spine animation custom clone.\n   */\n  _cloneTo(target: SpineAnimation) {\n    target.setSkeletonData(this.skeletonData);\n    const _cloneSetting = {...this.setting};\n    target.setting = _cloneSetting;\n  }\n}","import { Script, Entity } from 'oasis-engine';\nimport { SpineAnimation } from '../SpineAnimation';\n\nexport class SpineComponent extends Script {\n  private _autoPlay = false;\n\n  private _scale = 0.005;\n\n  private _animationName = '';\n\n  private _resource: any;\n\n  onStart() {\n    const spineEntity: Entity = this._resource;\n    if (!spineEntity) return;\n    const spineAnimation = spineEntity.getComponent(SpineAnimation);\n    spineAnimation.scale = this._scale;\n    this.entity.addChild(spineEntity);\n    if (this.autoPlay && this.animationName) {\n      spineAnimation.state.setAnimation(0, this.animationName, true);\n    }\n  }\n\n  get animationName() {\n    return this._animationName;\n  }\n\n  set animationName(name: string) {\n    this._animationName = name;\n    const spineEntity: Entity = this._resource;\n    if (!spineEntity) return;\n    const spineAnimation = spineEntity.getComponent(SpineAnimation);\n    spineAnimation.state.setAnimation(0, name, true);\n  }\n\n  get resource() {\n    return this._resource;\n  }\n\n  set resource(r) {\n    if (this._resource) {\n      this._resource.parent = null;\n    }\n    this._resource = r;\n    if (r) {\n      this.onStart();\n    }\n  }\n\n  get autoPlay() {\n    return this._autoPlay;\n  }\n\n  set autoPlay(value) {\n    this._autoPlay = value;\n    const spineEntity: Entity = this._resource;\n    if (!spineEntity) return;\n    const spineAnimation = spineEntity.getComponent(SpineAnimation);\n    if (value === false) {\n      spineAnimation.state.setEmptyAnimation(0, 1);\n    } else if (value === true) {\n      spineAnimation.state.setAnimation(0, this.animationName, true);\n    }\n  }\n\n  get scale() {\n    return this._scale;\n  }\n\n  set scale(value: number) {\n    this._scale = value;\n    const spineEntity: Entity = this._resource;\n    if (!spineEntity) return;\n    const spineAnimation = spineEntity.getComponent(SpineAnimation);\n    spineAnimation.scale = value;\n  }\n\n  onDestroy() {\n    if (this._resource) {\n      this._resource.parent = null;\n    }\n  }\n}\n","import { AssetConfig, Entity, ResourceManager, SchemaResource } from 'oasis-engine';\nimport '@oasis-engine/spine';\n\nexport class SpineResource extends SchemaResource {\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig): Promise<any> {\n    const { spineAssets } = assetConfig.props;\n    const urls = [];\n    const keys = Object.keys(spineAssets);\n    for (let i = 0; i < keys.length; i += 1) {\n      const { url } = spineAssets[keys[i]];\n      urls.push(url);\n    }\n    return resourceManager\n      .load<any>({\n        urls,\n        type: 'spine',\n      })\n      .then((spineEntity: Entity) => {\n        this._resource = spineEntity;\n      });\n  }\n}\n","import { Disposable, Map } from \"./Utils\";\r\nimport { TextureAtlas } from \"./TextureAtlas\";\r\nimport { FakeTexture } from \"./Texture\";\r\n\r\nexport class AssetManager implements Disposable {\r\n\t// todo: enhance asset manager: load image data\r\n\tprotected pathPrefix: string;\r\n\tprotected textureLoader: (image: HTMLImageElement) => any;\r\n\tprotected assets: Map<any> = {};\r\n\tprotected errors: Map<string> = {};\r\n\tprotected toLoad = 0;\r\n\tprotected loaded = 0;\r\n\tprotected rawDataUris: Map<string> = {};\r\n\r\n\tconstructor (textureLoader: (image: HTMLImageElement) => any, pathPrefix: string = \"\") {\r\n\t\tthis.textureLoader = textureLoader;\r\n\t\tthis.pathPrefix = pathPrefix;\r\n\t}\r\n\r\n\tprivate downloadText (url: string, success: (data: string) => void, error: (status: number, responseText: string) => void) {\r\n\t\tlet request = new XMLHttpRequest();\r\n\t\trequest.overrideMimeType(\"text/html\");\r\n\t\tif (this.rawDataUris[url]) url = this.rawDataUris[url];\r\n\t\trequest.open(\"GET\", url, true);\r\n\t\trequest.onload = () => {\r\n\t\t\tif (request.status == 200) {\r\n\t\t\t\tsuccess(request.responseText);\r\n\t\t\t} else {\r\n\t\t\t\terror(request.status, request.responseText);\r\n\t\t\t}\r\n\t\t}\r\n\t\trequest.onerror = () => {\r\n\t\t\terror(request.status, request.responseText);\r\n\t\t}\r\n\t\trequest.send();\r\n\t}\r\n\r\n\tprotected downloadBinary (url: string, success: (data: Uint8Array) => void, error: (status: number, responseText: string) => void) {\r\n\t\tlet request = new XMLHttpRequest();\r\n\t\tif (this.rawDataUris[url]) url = this.rawDataUris[url];\r\n\t\trequest.open(\"GET\", url, true);\r\n\t\trequest.responseType = \"arraybuffer\";\r\n\t\trequest.onload = () => {\r\n\t\t\tif (request.status == 200) {\r\n\t\t\t\tsuccess(new Uint8Array(request.response as ArrayBuffer));\r\n\t\t\t} else {\r\n\t\t\t\terror(request.status, request.responseText);\r\n\t\t\t}\r\n\t\t}\r\n\t\trequest.onerror = () => {\r\n\t\t\terror(request.status, request.responseText);\r\n\t\t}\r\n\t\trequest.send();\r\n\t}\r\n\r\n\tsetRawDataURI(path: string, data: string) {\r\n\t\tthis.rawDataUris[this.pathPrefix + path] = data;\r\n\t}\r\n\r\n\tloadBinary(path: string,\r\n\t\tsuccess: (path: string, binary: Uint8Array) => void = null,\r\n\t\terror: (path: string, error: string) => void = null) {\r\n\t\tpath = this.pathPrefix + path;\r\n\t\tthis.toLoad++;\r\n\r\n\t\tthis.downloadBinary(path, (data: Uint8Array): void => {\r\n\t\t\tthis.assets[path] = data;\r\n\t\t\tif (success) success(path, data);\r\n\t\t\tthis.toLoad--;\r\n\t\t\tthis.loaded++;\r\n\t\t}, (state: number, responseText: string): void => {\r\n\t\t\tthis.errors[path] = `Couldn't load binary ${path}: status ${status}, ${responseText}`;\r\n\t\t\tif (error) error(path, `Couldn't load binary ${path}: status ${status}, ${responseText}`);\r\n\t\t\tthis.toLoad--;\r\n\t\t\tthis.loaded++;\r\n\t\t});\r\n\t}\r\n\r\n\tloadText(path: string,\r\n\t\tsuccess: (path: string, text: string) => void = null,\r\n\t\terror: (path: string, error: string) => void = null) {\r\n\t\tpath = this.pathPrefix + path;\r\n\t\tthis.toLoad++;\r\n\r\n\t\tthis.downloadText(path, (data: string): void => {\r\n\t\t\tthis.assets[path] = data;\r\n\t\t\tif (success) success(path, data);\r\n\t\t\tthis.toLoad--;\r\n\t\t\tthis.loaded++;\r\n\t\t}, (state: number, responseText: string): void => {\r\n\t\t\tthis.errors[path] = `Couldn't load text ${path}: status ${status}, ${responseText}`;\r\n\t\t\tif (error) error(path, `Couldn't load text ${path}: status ${status}, ${responseText}`);\r\n\t\t\tthis.toLoad--;\r\n\t\t\tthis.loaded++;\r\n\t\t});\r\n\t}\r\n\r\n\tloadTexture (path: string,\r\n\t\tsuccess: (path: string, image: HTMLImageElement) => void = null,\r\n\t\terror: (path: string, error: string) => void = null) {\r\n\t\tpath = this.pathPrefix + path;\r\n\t\tlet storagePath = path;\r\n\t\tthis.toLoad++;\r\n\t\tlet img = new Image();\r\n\t\timg.crossOrigin = \"anonymous\";\r\n\t\timg.onload = (ev) => {\r\n\t\t\tlet texture = this.textureLoader(img);\r\n\t\t\tthis.assets[storagePath] = texture;\r\n\t\t\tthis.toLoad--;\r\n\t\t\tthis.loaded++;\r\n\t\t\tif (success) success(path, img);\r\n\t\t}\r\n\t\timg.onerror = (ev) => {\r\n\t\t\tthis.errors[path] = `Couldn't load image ${path}`;\r\n\t\t\tthis.toLoad--;\r\n\t\t\tthis.loaded++;\r\n\t\t\tif (error) error(path, `Couldn't load image ${path}`);\r\n\t\t}\r\n\t\tif (this.rawDataUris[path]) path = this.rawDataUris[path];\r\n\t\timg.src = path;\r\n\t}\r\n\r\n\tloadTextureAtlas (path: string,\r\n\t\tsuccess: (path: string, atlas: TextureAtlas) => void = null,\r\n\t\terror: (path: string, error: string) => void = null\r\n\t) {\r\n\t\tlet parent = path.lastIndexOf(\"/\") >= 0 ? path.substring(0, path.lastIndexOf(\"/\")) : \"\";\r\n\t\tpath = this.pathPrefix + path;\r\n\t\tthis.toLoad++;\r\n\r\n\t\tthis.downloadText(path, (atlasData: string): void => {\r\n\t\t\tlet pagesLoaded: any = { count: 0 };\r\n\t\t\tlet atlasPages = new Array<string>();\r\n\t\t\ttry {\r\n\t\t\t\tlet atlas = new TextureAtlas(atlasData, (path: string) => {\r\n\t\t\t\t\tatlasPages.push(parent == \"\" ? path : parent + \"/\" + path);\r\n\t\t\t\t\tlet image = document.createElement(\"img\") as HTMLImageElement;\r\n\t\t\t\t\timage.width = 16;\r\n\t\t\t\t\timage.height = 16;\r\n\t\t\t\t\treturn new FakeTexture(image);\r\n\t\t\t\t});\r\n\t\t\t} catch (e) {\r\n\t\t\t\tlet ex = e as Error;\r\n\t\t\t\tthis.errors[path] = `Couldn't load texture atlas ${path}: ${ex.message}`;\r\n\t\t\t\tif (error) error(path, `Couldn't load texture atlas ${path}: ${ex.message}`);\r\n\t\t\t\tthis.toLoad--;\r\n\t\t\t\tthis.loaded++;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tfor (let atlasPage of atlasPages) {\r\n\t\t\t\tlet pageLoadError = false;\r\n\t\t\t\tthis.loadTexture(atlasPage, (imagePath: string, image: HTMLImageElement) => {\r\n\t\t\t\t\tpagesLoaded.count++;\r\n\r\n\t\t\t\t\tif (pagesLoaded.count == atlasPages.length) {\r\n\t\t\t\t\t\tif (!pageLoadError) {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tlet atlas = new TextureAtlas(atlasData, (path: string) => {\r\n\t\t\t\t\t\t\t\t\treturn this.get(parent == \"\" ? path : parent + \"/\" + path);\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\tthis.assets[path] = atlas;\r\n\t\t\t\t\t\t\t\tif (success) success(path, atlas);\r\n\t\t\t\t\t\t\t\tthis.toLoad--;\r\n\t\t\t\t\t\t\t\tthis.loaded++;\r\n\t\t\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t\t\tlet ex = e as Error;\r\n\t\t\t\t\t\t\t\tthis.errors[path] = `Couldn't load texture atlas ${path}: ${ex.message}`;\r\n\t\t\t\t\t\t\t\tif (error) error(path, `Couldn't load texture atlas ${path}: ${ex.message}`);\r\n\t\t\t\t\t\t\t\tthis.toLoad--;\r\n\t\t\t\t\t\t\t\tthis.loaded++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.errors[path] = `Couldn't load texture atlas page ${imagePath}} of atlas ${path}`;\r\n\t\t\t\t\t\t\tif (error) error(path, `Couldn't load texture atlas page ${imagePath} of atlas ${path}`);\r\n\t\t\t\t\t\t\tthis.toLoad--;\r\n\t\t\t\t\t\t\tthis.loaded++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}, (imagePath: string, errorMessage: string) => {\r\n\t\t\t\t\tpageLoadError = true;\r\n\t\t\t\t\tpagesLoaded.count++;\r\n\r\n\t\t\t\t\tif (pagesLoaded.count == atlasPages.length) {\r\n\t\t\t\t\t\tthis.errors[path] = `Couldn't load texture atlas page ${imagePath}} of atlas ${path}`;\r\n\t\t\t\t\t\tif (error) error(path, `Couldn't load texture atlas page ${imagePath} of atlas ${path}`);\r\n\t\t\t\t\t\tthis.toLoad--;\r\n\t\t\t\t\t\tthis.loaded++;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}, (state: number, responseText: string): void => {\r\n\t\t\tthis.errors[path] = `Couldn't load texture atlas ${path}: status ${status}, ${responseText}`;\r\n\t\t\tif (error) error(path, `Couldn't load texture atlas ${path}: status ${status}, ${responseText}`);\r\n\t\t\tthis.toLoad--;\r\n\t\t\tthis.loaded++;\r\n\t\t});\r\n\t}\r\n\r\n\tget (path: string) {\r\n\t\tpath = this.pathPrefix + path;\r\n\t\treturn this.assets[path];\r\n\t}\r\n\r\n\tremove (path: string) {\r\n\t\tpath = this.pathPrefix + path;\r\n\t\tlet asset = this.assets[path];\r\n\t\tif ((<any>asset).dispose) (<any>asset).dispose();\r\n\t\tthis.assets[path] = null;\r\n\t}\r\n\r\n\tremoveAll () {\r\n\t\tfor (let key in this.assets) {\r\n\t\t\tlet asset = this.assets[key];\r\n\t\t\tif ((<any>asset).dispose) (<any>asset).dispose();\r\n\t\t}\r\n\t\tthis.assets = {};\r\n\t}\r\n\r\n\tisLoadingComplete (): boolean {\r\n\t\treturn this.toLoad == 0;\r\n\t}\r\n\r\n\tgetToLoad (): number {\r\n\t\treturn this.toLoad;\r\n\t}\r\n\r\n\tgetLoaded (): number {\r\n\t\treturn this.loaded;\r\n\t}\r\n\r\n\tdispose () {\r\n\t\tthis.removeAll();\r\n\t}\r\n\r\n\thasErrors() {\r\n\t\treturn Object.keys(this.errors).length > 0;\r\n\t}\r\n\r\n\tgetErrors() {\r\n\t\treturn this.errors;\r\n\t}\r\n}\r\n","\r\n\r\nimport { VertexAttachment, Attachment } from \"./Attachment\";\r\nimport { Color } from \"../Utils\";\r\n\r\n\r\n\r\n/** An attachment with vertices that make up a polygon. Can be used for hit detection, creating physics bodies, spawning particle\r\n * effects, and more.\r\n *\r\n * See {@link SkeletonBounds} and [Bounding Boxes](http://esotericsoftware.com/spine-bounding-boxes) in the Spine User\r\n * Guide. */\r\nexport class BoundingBoxAttachment extends VertexAttachment {\r\ncolor = new Color(1, 1, 1, 1);\r\n\r\nconstructor (name: string) {\r\n\tsuper(name);\r\n}\r\n\r\ncopy (): Attachment {\r\n\tlet copy = new BoundingBoxAttachment(this.name);\r\n\tthis.copyTo(copy);\r\n\tcopy.color.setFromColor(this.color);\r\n\treturn copy;\r\n}\r\n}\r\n","\n\nimport { VertexAttachment, Attachment } from \"./Attachment\";\nimport { Color, MathUtils, Vector2 } from \"../Utils\";\nimport { Bone } from \"../Bone\";\n\n\n/** An attachment which is a single point and a rotation. This can be used to spawn projectiles, particles, etc. A bone can be\n * used in similar ways, but a PointAttachment is slightly less expensive to compute and can be hidden, shown, and placed in a\n * skin.\n *\n * See [Point Attachments](http://esotericsoftware.com/spine-point-attachments) in the Spine User Guide. */\nexport class PointAttachment extends VertexAttachment {\n\tx: number; y: number; rotation: number;\n\n\t/** The color of the point attachment as it was in Spine. Available only when nonessential data was exported. Point attachments\n\t * are not usually rendered at runtime. */\n\tcolor = new Color(0.38, 0.94, 0, 1);\n\n\tconstructor (name: string) {\n\t\tsuper(name);\n\t\tthis.name = name;\n\t}\n\n\tcomputeWorldPosition (bone: Bone, point: Vector2) {\n\t\tpoint.x = this.x * bone.a + this.y * bone.b + bone.worldX;\n\t\tpoint.y = this.x * bone.c + this.y * bone.d + bone.worldY;\n\t\treturn point;\n\t}\n\n\tcomputeWorldRotation (bone: Bone) {\n\t\tlet cos = MathUtils.cosDeg(this.rotation), sin = MathUtils.sinDeg(this.rotation);\n\t\tlet x = cos * bone.a + sin * bone.b;\n\t\tlet y = cos * bone.c + sin * bone.d;\n\t\treturn Math.atan2(y, x) * MathUtils.radDeg;\n\t}\n\n\tcopy (): Attachment {\n\t\tlet copy = new PointAttachment(this.name);\n\t\tcopy.x = this.x;\n\t\tcopy.y = this.y;\n\t\tcopy.rotation = this.rotation;\n\t\tcopy.color.setFromColor(this.color);\n\t\treturn copy;\n\t}\n}\n","\n\nimport { AttachmentLoader } from \"./attachments/AttachmentLoader\";\nimport { TextureAtlas } from \"./TextureAtlas\";\nimport { Skin } from \"./Skin\";\nimport { RegionAttachment } from \"./attachments/RegionAttachment\";\nimport { MeshAttachment } from \"./attachments/MeshAttachment\";\nimport { BoundingBoxAttachment } from \"./attachments/BoundingBoxAttachment\";\nimport { PathAttachment } from \"./attachments/PathAttachment\";\nimport { PointAttachment } from \"./attachments/PointAttachment\";\nimport { ClippingAttachment } from \"./attachments/ClippingAttachment\";\n\n/** An {@link AttachmentLoader} that configures attachments using texture regions from an {@link TextureAtlas}.\n *\n * See [Loading skeleton data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the\n * Spine Runtimes Guide. */\nexport class AtlasAttachmentLoader implements AttachmentLoader {\n\tatlas: TextureAtlas;\n\n\tconstructor (atlas: TextureAtlas) {\n\t\tthis.atlas = atlas;\n\t}\n\n\tnewRegionAttachment (skin: Skin, name: string, path: string): RegionAttachment {\n\t\tlet region = this.atlas.findRegion(path);\n\t\tif (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\n\t\tregion.renderObject = region;\n\t\tlet attachment = new RegionAttachment(name);\n\t\tattachment.setRegion(region);\n\t\treturn attachment;\n\t}\n\n\tnewMeshAttachment (skin: Skin, name: string, path: string) : MeshAttachment {\n\t\tlet region = this.atlas.findRegion(path);\n\t\tif (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\n\t\tregion.renderObject = region;\n\t\tlet attachment = new MeshAttachment(name);\n\t\tattachment.region = region;\n\t\treturn attachment;\n\t}\n\n\tnewBoundingBoxAttachment (skin: Skin, name: string) : BoundingBoxAttachment {\n\t\treturn new BoundingBoxAttachment(name);\n\t}\n\n\tnewPathAttachment (skin: Skin, name: string): PathAttachment {\n\t\treturn new PathAttachment(name);\n\t}\n\n\tnewPointAttachment(skin: Skin, name: string): PointAttachment {\n\t\treturn new PointAttachment(name);\n\t}\n\n\tnewClippingAttachment(skin: Skin, name: string): ClippingAttachment {\n\t\treturn new ClippingAttachment(name);\n\t}\n}\n","\r\n\r\nimport { BoneData } from \"./BoneData\";\r\nimport { SlotData } from \"./SlotData\";\r\nimport { Skin } from \"./Skin\";\r\nimport { EventData } from \"./EventData\";\r\nimport { IkConstraintData } from \"./IkConstraintData\";\r\nimport { TransformConstraintData } from \"./TransformConstraintData\";\r\nimport { PathConstraintData } from \"./PathConstraintData\";\r\nimport { Animation} from \"./Animation\";\r\n\r\n\r\n/** Stores the setup pose and all of the stateless data for a skeleton.\r\n *\r\n * See [Data objects](http://esotericsoftware.com/spine-runtime-architecture#Data-objects) in the Spine Runtimes\r\n * Guide. */\r\nexport class SkeletonData {\r\n\r\n\t/** The skeleton's name, which by default is the name of the skeleton data file, if possible. May be null. */\r\n\tname: string;\r\n\r\n\t/** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\r\n\tbones = new Array<BoneData>(); // Ordered parents first.\r\n\r\n\t/** The skeleton's slots. */\r\n\tslots = new Array<SlotData>(); // Setup pose draw order.\r\n\tskins = new Array<Skin>();\r\n\r\n\t/** The skeleton's default skin. By default this skin contains all attachments that were not in a skin in Spine.\r\n\t *\r\n\t * See {@link Skeleton#getAttachmentByName()}.\r\n\t * May be null. */\r\n\tdefaultSkin: Skin;\r\n\r\n\t/** The skeleton's events. */\r\n\tevents = new Array<EventData>();\r\n\r\n\t/** The skeleton's animations. */\r\n\tanimations = new Array<Animation>();\r\n\r\n\t/** The skeleton's IK constraints. */\r\n\tikConstraints = new Array<IkConstraintData>();\r\n\r\n\t/** The skeleton's transform constraints. */\r\n\ttransformConstraints = new Array<TransformConstraintData>();\r\n\r\n\t/** The skeleton's path constraints. */\r\n\tpathConstraints = new Array<PathConstraintData>();\r\n\r\n\t/** The X coordinate of the skeleton's axis aligned bounding box in the setup pose. */\r\n\tx: number;\r\n\r\n\t/** The Y coordinate of the skeleton's axis aligned bounding box in the setup pose. */\r\n\ty: number;\r\n\r\n\t/** The width of the skeleton's axis aligned bounding box in the setup pose. */\r\n\twidth: number;\r\n\r\n\t/** The height of the skeleton's axis aligned bounding box in the setup pose. */\r\n\theight: number;\r\n\r\n\t/** The Spine version used to export the skeleton data, or null. */\r\n\tversion: string;\r\n\r\n\t/** The skeleton data hash. This value will change if any of the skeleton data has changed. May be null. */\r\n\thash: string;\r\n\r\n\t// Nonessential\r\n\t/** The dopesheet FPS in Spine. Available only when nonessential data was exported. */\r\n\tfps = 0;\r\n\r\n\t/** The path to the images directory as defined in Spine. Available only when nonessential data was exported. May be null. */\r\n\timagesPath: string;\r\n\r\n\t/** The path to the audio directory as defined in Spine. Available only when nonessential data was exported. May be null. */\r\n\taudioPath: string;\r\n\r\n\t/** Finds a bone by comparing each bone's name. It is more efficient to cache the results of this method than to call it\r\n\t * multiple times.\r\n\t * @returns May be null. */\r\n\tfindBone (boneName: string) {\r\n\t\tif (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n\t\tlet bones = this.bones;\r\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\r\n\t\t\tlet bone = bones[i];\r\n\t\t\tif (bone.name == boneName) return bone;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tfindBoneIndex (boneName: string) {\r\n\t\tif (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n\t\tlet bones = this.bones;\r\n\t\tfor (let i = 0, n = bones.length; i < n; i++)\r\n\t\t\tif (bones[i].name == boneName) return i;\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\r\n\t * multiple times.\r\n\t * @returns May be null. */\r\n\tfindSlot (slotName: string) {\r\n\t\tif (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n\t\tlet slots = this.slots;\r\n\t\tfor (let i = 0, n = slots.length; i < n; i++) {\r\n\t\t\tlet slot = slots[i];\r\n\t\t\tif (slot.name == slotName) return slot;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tfindSlotIndex (slotName: string) {\r\n\t\tif (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n\t\tlet slots = this.slots;\r\n\t\tfor (let i = 0, n = slots.length; i < n; i++)\r\n\t\t\tif (slots[i].name == slotName) return i;\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/** Finds a skin by comparing each skin's name. It is more efficient to cache the results of this method than to call it\r\n\t * multiple times.\r\n\t * @returns May be null. */\r\n\tfindSkin (skinName: string) {\r\n\t\tif (skinName == null) throw new Error(\"skinName cannot be null.\");\r\n\t\tlet skins = this.skins;\r\n\t\tfor (let i = 0, n = skins.length; i < n; i++) {\r\n\t\t\tlet skin = skins[i];\r\n\t\t\tif (skin.name == skinName) return skin;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Finds an event by comparing each events's name. It is more efficient to cache the results of this method than to call it\r\n\t * multiple times.\r\n\t * @returns May be null. */\r\n\tfindEvent (eventDataName: string) {\r\n\t\tif (eventDataName == null) throw new Error(\"eventDataName cannot be null.\");\r\n\t\tlet events = this.events;\r\n\t\tfor (let i = 0, n = events.length; i < n; i++) {\r\n\t\t\tlet event = events[i];\r\n\t\t\tif (event.name == eventDataName) return event;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Finds an animation by comparing each animation's name. It is more efficient to cache the results of this method than to\r\n\t * call it multiple times.\r\n\t * @returns May be null. */\r\n\tfindAnimation (animationName: string) {\r\n\t\tif (animationName == null) throw new Error(\"animationName cannot be null.\");\r\n\t\tlet animations = this.animations;\r\n\t\tfor (let i = 0, n = animations.length; i < n; i++) {\r\n\t\t\tlet animation = animations[i];\r\n\t\t\tif (animation.name == animationName) return animation;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\r\n\t * than to call it multiple times.\r\n\t * @return May be null. */\r\n\tfindIkConstraint (constraintName: string) {\r\n\t\tif (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n\t\tlet ikConstraints = this.ikConstraints;\r\n\t\tfor (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n\t\t\tlet constraint = ikConstraints[i];\r\n\t\t\tif (constraint.name == constraintName) return constraint;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\r\n\t * this method than to call it multiple times.\r\n\t * @return May be null. */\r\n\tfindTransformConstraint (constraintName: string) {\r\n\t\tif (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n\t\tlet transformConstraints = this.transformConstraints;\r\n\t\tfor (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n\t\t\tlet constraint = transformConstraints[i];\r\n\t\t\tif (constraint.name == constraintName) return constraint;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\r\n\t * than to call it multiple times.\r\n\t * @return May be null. */\r\n\tfindPathConstraint (constraintName: string) {\r\n\t\tif (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n\t\tlet pathConstraints = this.pathConstraints;\r\n\t\tfor (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n\t\t\tlet constraint = pathConstraints[i];\r\n\t\t\tif (constraint.name == constraintName) return constraint;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tfindPathConstraintIndex (pathConstraintName: string) {\r\n\t\tif (pathConstraintName == null) throw new Error(\"pathConstraintName cannot be null.\");\r\n\t\tlet pathConstraints = this.pathConstraints;\r\n\t\tfor (let i = 0, n = pathConstraints.length; i < n; i++)\r\n\t\t\tif (pathConstraints[i].name == pathConstraintName) return i;\r\n\t\treturn -1;\r\n\t}\r\n}\r\n","\r\n\r\nimport { BoneData } from \"./BoneData\";\r\nimport { Color } from \"./Utils\";\r\nimport { BlendMode } from \"./BlendMode\";\r\n\r\n\r\n\r\n/** Stores the setup pose for a {@link Slot}. */\r\nexport class SlotData {\r\n\r\n\t/** The index of the slot in {@link Skeleton#getSlots()}. */\r\n\tindex: number;\r\n\r\n\t/** The name of the slot, which is unique across all slots in the skeleton. */\r\n\tname: string;\r\n\r\n\t/** The bone this slot belongs to. */\r\n\tboneData: BoneData;\r\n\r\n\t/** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\r\n\t * color tinting. */\r\n\tcolor = new Color(1, 1, 1, 1);\r\n\r\n\t/** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\r\n\t * color's alpha is not used. */\r\n\tdarkColor: Color;\r\n\r\n\t/** The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible. */\r\n\tattachmentName: string;\r\n\r\n\t/** The blend mode for drawing the slot's attachment. */\r\n\tblendMode: BlendMode;\r\n\r\n\tconstructor (index: number, name: string, boneData: BoneData) {\r\n\t\tif (index < 0) throw new Error(\"index must be >= 0.\");\r\n\t\tif (name == null) throw new Error(\"name cannot be null.\");\r\n\t\tif (boneData == null) throw new Error(\"boneData cannot be null.\");\r\n\t\tthis.index = index;\r\n\t\tthis.name = name;\r\n\t\tthis.boneData = boneData;\r\n\t}\r\n}\r\n","\r\n\r\nimport { ConstraintData } from \"./ConstraintData\";\r\nimport { BoneData } from \"./BoneData\";\r\n\r\n\r\n\r\n/** Stores the setup pose for an {@link IkConstraint}.\r\n * <p>\r\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide. */\r\nexport class IkConstraintData extends ConstraintData {\r\n\t/** The bones that are constrained by this IK constraint. */\r\n\tbones = new Array<BoneData>();\r\n\r\n\t/** The bone that is the IK target. */\r\n\ttarget: BoneData;\r\n\r\n\t/** Controls the bend direction of the IK bones, either 1 or -1. */\r\n\tbendDirection = 1;\r\n\r\n\t/** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\r\n\tcompress = false;\r\n\r\n\t/** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\r\n\t * and the parent bone has local nonuniform scale, stretch is not applied. */\r\n\tstretch = false;\r\n\r\n\t/** When true, only a single bone is being constrained, and {@link #getCompress()} or {@link #getStretch()} is used, the bone\r\n\t * is scaled on both the X and Y axes. */\r\n\tuniform = false;\r\n\r\n\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\r\n\tmix = 1;\r\n\r\n\t/** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\r\n\tsoftness = 0;\r\n\r\n\tconstructor (name: string) {\r\n\t\tsuper(name, 0, false);\r\n\t}\r\n}\r\n","\r\n\r\nimport { ConstraintData } from \"./ConstraintData\";\r\nimport { BoneData } from \"./BoneData\";\r\n\r\n\r\n/** Stores the setup pose for a {@link TransformConstraint}.\r\n *\r\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide. */\r\nexport class TransformConstraintData extends ConstraintData {\r\n\r\n\t/** The bones that will be modified by this transform constraint. */\r\n\tbones = new Array<BoneData>();\r\n\r\n\t/** The target bone whose world transform will be copied to the constrained bones. */\r\n\ttarget: BoneData;\r\n\r\n\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\r\n\trotateMix = 0;\r\n\r\n\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained translations. */\r\n\ttranslateMix = 0;\r\n\r\n\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained scales. */\r\n\tscaleMix = 0;\r\n\r\n\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained shears. */\r\n\tshearMix = 0;\r\n\r\n\t/** An offset added to the constrained bone rotation. */\r\n\toffsetRotation = 0;\r\n\r\n\t/** An offset added to the constrained bone X translation. */\r\n\toffsetX = 0;\r\n\r\n\t/** An offset added to the constrained bone Y translation. */\r\n\toffsetY = 0;\r\n\r\n\t/** An offset added to the constrained bone scaleX. */\r\n\toffsetScaleX = 0;\r\n\r\n\t/** An offset added to the constrained bone scaleY. */\r\n\toffsetScaleY = 0;\r\n\r\n\t/** An offset added to the constrained bone shearY. */\r\n\toffsetShearY = 0;\r\n\r\n\trelative = false;\r\n\tlocal = false;\r\n\r\n\tconstructor (name: string) {\r\n\t\tsuper(name, 0, false);\r\n\t}\r\n}\r\n","\r\n\r\nimport { Attachment } from \"./attachments/Attachment\";\r\nimport { BoneData } from \"./BoneData\";\r\nimport { ConstraintData } from \"./ConstraintData\";\r\nimport { Skeleton } from \"./Skeleton\";\r\nimport { MeshAttachment } from \"./attachments/MeshAttachment\";\r\nimport { Map } from './Utils'\r\n\r\n/** Stores an entry in the skin consisting of the slot index, name, and attachment **/\r\nexport class SkinEntry {\r\n\tconstructor(public slotIndex: number, public name: string, public attachment: Attachment) { }\r\n}\r\n\r\n/** Stores attachments by slot index and attachment name.\r\n *\r\n * See SkeletonData {@link SkeletonData#defaultSkin}, Skeleton {@link Skeleton#skin}, and\r\n * [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide. */\r\nexport class Skin {\r\n\t/** The skin's name, which is unique across all skins in the skeleton. */\r\n\tname: string;\r\n\r\n\tattachments = new Array<Map<Attachment>>();\r\n\tbones = Array<BoneData>();\r\n\tconstraints = new Array<ConstraintData>();\r\n\r\n\tconstructor (name: string) {\r\n\t\tif (name == null) throw new Error(\"name cannot be null.\");\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\t/** Adds an attachment to the skin for the specified slot index and name. */\r\n\tsetAttachment (slotIndex: number, name: string, attachment: Attachment) {\r\n\t\tif (attachment == null) throw new Error(\"attachment cannot be null.\");\r\n\t\tlet attachments = this.attachments;\r\n\t\tif (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\r\n\t\tif (!attachments[slotIndex]) attachments[slotIndex] = { };\r\n\t\tattachments[slotIndex][name] = attachment;\r\n\t}\r\n\r\n\t/** Adds all attachments, bones, and constraints from the specified skin to this skin. */\r\n\taddSkin (skin: Skin) {\r\n\t\tfor(let i = 0; i < skin.bones.length; i++) {\r\n\t\t\tlet bone = skin.bones[i];\r\n\t\t\tlet contained = false;\r\n\t\t\tfor (let j = 0; j < this.bones.length; j++) {\r\n\t\t\t\tif (this.bones[j] == bone) {\r\n\t\t\t\t\tcontained = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!contained) this.bones.push(bone);\r\n\t\t}\r\n\r\n\t\tfor(let i = 0; i < skin.constraints.length; i++) {\r\n\t\t\tlet constraint = skin.constraints[i];\r\n\t\t\tlet contained = false;\r\n\t\t\tfor (let j = 0; j < this.constraints.length; j++) {\r\n\t\t\t\tif (this.constraints[j] == constraint) {\r\n\t\t\t\t\tcontained = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!contained) this.constraints.push(constraint);\r\n\t\t}\r\n\r\n\t\tlet attachments = skin.getAttachments();\r\n\t\tfor (let i = 0; i < attachments.length; i++) {\r\n\t\t\tvar attachment = attachments[i];\r\n\t\t\tthis.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n\t\t}\r\n\t}\r\n\r\n\t/** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not\r\n\t * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */\r\n\tcopySkin (skin: Skin) {\r\n\t\tfor(let i = 0; i < skin.bones.length; i++) {\r\n\t\t\tlet bone = skin.bones[i];\r\n\t\t\tlet contained = false;\r\n\t\t\tfor (let j = 0; j < this.bones.length; j++) {\r\n\t\t\t\tif (this.bones[j] == bone) {\r\n\t\t\t\t\tcontained = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!contained) this.bones.push(bone);\r\n\t\t}\r\n\r\n\t\tfor(let i = 0; i < skin.constraints.length; i++) {\r\n\t\t\tlet constraint = skin.constraints[i];\r\n\t\t\tlet contained = false;\r\n\t\t\tfor (let j = 0; j < this.constraints.length; j++) {\r\n\t\t\t\tif (this.constraints[j] == constraint) {\r\n\t\t\t\t\tcontained = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!contained) this.constraints.push(constraint);\r\n\t\t}\r\n\r\n\t\tlet attachments = skin.getAttachments();\r\n\t\tfor (let i = 0; i < attachments.length; i++) {\r\n\t\t\tvar attachment = attachments[i];\r\n\t\t\tif (attachment.attachment == null) continue;\r\n\t\t\tif (attachment.attachment instanceof MeshAttachment) {\r\n\t\t\t\tattachment.attachment = attachment.attachment.newLinkedMesh();\r\n\t\t\t\tthis.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n\t\t\t} else {\r\n\t\t\t\tattachment.attachment = attachment.attachment.copy();\r\n\t\t\t\tthis.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/** Returns the attachment for the specified slot index and name, or null. */\r\n\tgetAttachment (slotIndex: number, name: string): Attachment {\r\n\t\tlet dictionary = this.attachments[slotIndex];\r\n\t\treturn dictionary ? dictionary[name] : null;\r\n\t}\r\n\r\n\t/** Removes the attachment in the skin for the specified slot index and name, if any. */\r\n\tremoveAttachment (slotIndex: number, name: string) {\r\n\t\tlet dictionary = this.attachments[slotIndex];\r\n\t\tif (dictionary) dictionary[name] = null;\r\n\t}\r\n\r\n\t/** Returns all attachments in this skin. */\r\n\tgetAttachments (): Array<SkinEntry> {\r\n\t\tlet entries = new Array<SkinEntry>();\r\n\t\tfor (var i = 0; i < this.attachments.length; i++) {\r\n\t\t\tlet slotAttachments = this.attachments[i];\r\n\t\t\tif (slotAttachments) {\r\n\t\t\t\tfor (let name in slotAttachments) {\r\n\t\t\t\t\tlet attachment = slotAttachments[name];\r\n\t\t\t\t\tif (attachment) entries.push(new SkinEntry(i, name, attachment));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn entries;\r\n\t}\r\n\r\n\t/** Returns all attachments in this skin for the specified slot index. */\r\n\tgetAttachmentsForSlot (slotIndex: number, attachments: Array<SkinEntry>) {\r\n\t\tlet slotAttachments = this.attachments[slotIndex];\r\n\t\tif (slotAttachments) {\r\n\t\t\tfor (let name in slotAttachments) {\r\n\t\t\t\tlet attachment = slotAttachments[name];\r\n\t\t\t\tif (attachment) attachments.push(new SkinEntry(slotIndex, name, attachment));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/** Clears all attachments, bones, and constraints. */\r\n\tclear () {\r\n\t\tthis.attachments.length = 0;\r\n\t\tthis.bones.length = 0;\r\n\t\tthis.constraints.length = 0;\r\n\t}\r\n\r\n\t/** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\r\n\tattachAll (skeleton: Skeleton, oldSkin: Skin) {\r\n\t\tlet slotIndex = 0;\r\n\t\tfor (let i = 0; i < skeleton.slots.length; i++) {\r\n\t\t\tlet slot = skeleton.slots[i];\r\n\t\t\tlet slotAttachment = slot.getAttachment();\r\n\t\t\tif (slotAttachment && slotIndex < oldSkin.attachments.length) {\r\n\t\t\t\tlet dictionary = oldSkin.attachments[slotIndex];\r\n\t\t\t\tfor (let key in dictionary) {\r\n\t\t\t\t\tlet skinAttachment:Attachment = dictionary[key];\r\n\t\t\t\t\tif (slotAttachment == skinAttachment) {\r\n\t\t\t\t\t\tlet attachment = this.getAttachment(slotIndex, key);\r\n\t\t\t\t\t\tif (attachment != null) slot.setAttachment(attachment);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tslotIndex++;\r\n\t\t}\r\n\t}\r\n}\r\n","\r\n\r\n\r\n\t/** Stores the setup pose values for an {@link Event}.\r\n\t *\r\n\t * See [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide. */\r\n\texport class EventData {\r\n\t\tname: string;\r\n\t\tintValue: number;\r\n\t\tfloatValue: number;\r\n\t\tstringValue: string;\r\n\t\taudioPath: string;\r\n\t\tvolume: number;\r\n\t\tbalance: number;\r\n\r\n\t\tconstructor (name: string) {\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t}\r\n","\r\n\r\n\r\nexport enum AttachmentType {\r\n\tRegion, BoundingBox, Mesh, LinkedMesh, Path, Point, Clipping\r\n}\r\n","\r\n\r\nimport { EventData } from \"./EventData\";\r\n\r\n\r\n\r\n/** Stores the current pose values for an {@link Event}.\r\n *\r\n * See Timeline {@link Timeline#apply()},\r\n * AnimationStateListener {@link AnimationStateListener#event()}, and\r\n * [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide. */\r\nexport class Event {\r\n\tdata: EventData;\r\n\tintValue: number;\r\n\tfloatValue: number;\r\n\tstringValue: string;\r\n\ttime: number;\r\n\tvolume: number;\r\n\tbalance: number;\r\n\r\n\tconstructor (time: number, data: EventData) {\r\n\t\tif (data == null) throw new Error(\"data cannot be null.\");\r\n\t\tthis.time = time;\r\n\t\tthis.data = data;\r\n\t}\r\n}\r\n","\r\n\r\nimport { AttachmentLoader } from \"./attachments/AttachmentLoader\";\r\nimport { SkeletonData } from \"./SkeletonData\";\r\nimport { BoneData, TransformMode } from \"./BoneData\";\r\nimport { SlotData } from \"./SlotData\";\r\nimport { Color, Utils, ArrayLike } from \"./Utils\";\r\nimport { IkConstraintData } from \"./IkConstraintData\";\r\nimport { TransformConstraintData } from \"./TransformConstraintData\";\r\nimport { PathConstraintData, PositionMode, SpacingMode, RotateMode } from \"./PathConstraintData\";\r\nimport { Skin } from \"./Skin\";\r\nimport { VertexAttachment, Attachment } from \"./attachments/Attachment\";\r\nimport { MeshAttachment } from \"./attachments/MeshAttachment\";\r\nimport { EventData } from \"./EventData\";\r\nimport { Timeline, AttachmentTimeline, ColorTimeline, TwoColorTimeline, RotateTimeline, TranslateTimeline, ScaleTimeline, ShearTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintPositionTimeline, PathConstraintSpacingTimeline, PathConstraintMixTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, CurveTimeline } from \"./Animation\";\r\nimport { BlendMode } from \"./BlendMode\";\r\nimport { Event } from \"./Event\";\r\nimport { Animation } from \"./Animation\";\r\n\r\n/** Loads skeleton data in the Spine JSON format.\r\n *\r\n * See [Spine JSON format](http://esotericsoftware.com/spine-json-format) and\r\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\r\n * Runtimes Guide. */\r\nexport class SkeletonJson {\r\n\tattachmentLoader: AttachmentLoader;\r\n\r\n\t/** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\r\n\t * runtime than were used in Spine.\r\n\t *\r\n\t * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\r\n\tscale = 1;\r\n\tprivate linkedMeshes = new Array<LinkedMesh>();\r\n\r\n\tconstructor (attachmentLoader: AttachmentLoader) {\r\n\t\tthis.attachmentLoader = attachmentLoader;\r\n\t}\r\n\r\n\treadSkeletonData (json: string | any): SkeletonData {\r\n\t\tlet scale = this.scale;\r\n\t\tlet skeletonData = new SkeletonData();\r\n\t\tlet root = typeof(json) === \"string\" ? JSON.parse(json) : json;\r\n\r\n\t\t// Skeleton\r\n\t\tlet skeletonMap = root.skeleton;\r\n\t\tif (skeletonMap != null) {\r\n\t\t\tskeletonData.hash = skeletonMap.hash;\r\n\t\t\tskeletonData.version = skeletonMap.spine;\r\n\t\t\tif (\"3.8.75\" == skeletonData.version)\r\n\t\t\t\tthrow new Error(\"Unsupported skeleton data, please export with a newer version of Spine.\");\r\n\t\t\tskeletonData.x = skeletonMap.x;\r\n\t\t\tskeletonData.y = skeletonMap.y;\r\n\t\t\tskeletonData.width = skeletonMap.width;\r\n\t\t\tskeletonData.height = skeletonMap.height;\r\n\t\t\tskeletonData.fps = skeletonMap.fps;\r\n\t\t\tskeletonData.imagesPath = skeletonMap.images;\r\n\t\t}\r\n\r\n\t\t// Bones\r\n\t\tif (root.bones) {\r\n\t\t\tfor (let i = 0; i < root.bones.length; i++) {\r\n\t\t\t\tlet boneMap = root.bones[i];\r\n\r\n\t\t\t\tlet parent: BoneData = null;\r\n\t\t\t\tlet parentName: string = this.getValue(boneMap, \"parent\", null);\r\n\t\t\t\tif (parentName != null) {\r\n\t\t\t\t\tparent = skeletonData.findBone(parentName);\r\n\t\t\t\t\tif (parent == null) throw new Error(\"Parent bone not found: \" + parentName);\r\n\t\t\t\t}\r\n\t\t\t\tlet data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\r\n\t\t\t\tdata.length = this.getValue(boneMap, \"length\", 0) * scale;\r\n\t\t\t\tdata.x = this.getValue(boneMap, \"x\", 0) * scale;\r\n\t\t\t\tdata.y = this.getValue(boneMap, \"y\", 0) * scale;\r\n\t\t\t\tdata.rotation = this.getValue(boneMap, \"rotation\", 0);\r\n\t\t\t\tdata.scaleX = this.getValue(boneMap, \"scaleX\", 1);\r\n\t\t\t\tdata.scaleY = this.getValue(boneMap, \"scaleY\", 1);\r\n\t\t\t\tdata.shearX = this.getValue(boneMap, \"shearX\", 0);\r\n\t\t\t\tdata.shearY = this.getValue(boneMap, \"shearY\", 0);\r\n\t\t\t\tdata.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\r\n\t\t\t\tdata.skinRequired = this.getValue(boneMap, \"skin\", false);\r\n\r\n\t\t\t\tskeletonData.bones.push(data);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Slots.\r\n\t\tif (root.slots) {\r\n\t\t\tfor (let i = 0; i < root.slots.length; i++) {\r\n\t\t\t\tlet slotMap = root.slots[i];\r\n\t\t\t\tlet slotName: string = slotMap.name;\r\n\t\t\t\tlet boneName: string = slotMap.bone;\r\n\t\t\t\tlet boneData = skeletonData.findBone(boneName);\r\n\t\t\t\tif (boneData == null) throw new Error(\"Slot bone not found: \" + boneName);\r\n\t\t\t\tlet data = new SlotData(skeletonData.slots.length, slotName, boneData);\r\n\r\n\t\t\t\tlet color: string = this.getValue(slotMap, \"color\", null);\r\n\t\t\t\tif (color != null) data.color.setFromString(color);\r\n\r\n\t\t\t\tlet dark: string = this.getValue(slotMap, \"dark\", null);\r\n\t\t\t\tif (dark != null) {\r\n\t\t\t\t\tdata.darkColor = new Color(1, 1, 1, 1);\r\n\t\t\t\t\tdata.darkColor.setFromString(dark);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdata.attachmentName = this.getValue(slotMap, \"attachment\", null);\r\n\t\t\t\tdata.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\r\n\t\t\t\tskeletonData.slots.push(data);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// IK constraints\r\n\t\tif (root.ik) {\r\n\t\t\tfor (let i = 0; i < root.ik.length; i++) {\r\n\t\t\t\tlet constraintMap = root.ik[i];\r\n\t\t\t\tlet data = new IkConstraintData(constraintMap.name);\r\n\t\t\t\tdata.order = this.getValue(constraintMap, \"order\", 0);\r\n\t\t\t\tdata.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n\r\n\t\t\t\tfor (let j = 0; j < constraintMap.bones.length; j++) {\r\n\t\t\t\t\tlet boneName = constraintMap.bones[j];\r\n\t\t\t\t\tlet bone = skeletonData.findBone(boneName);\r\n\t\t\t\t\tif (bone == null) throw new Error(\"IK bone not found: \" + boneName);\r\n\t\t\t\t\tdata.bones.push(bone);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet targetName: string = constraintMap.target;\r\n\t\t\t\tdata.target = skeletonData.findBone(targetName);\r\n\t\t\t\tif (data.target == null) throw new Error(\"IK target bone not found: \" + targetName);\r\n\r\n\t\t\t\tdata.mix = this.getValue(constraintMap, \"mix\", 1);\r\n\t\t\t\tdata.softness = this.getValue(constraintMap, \"softness\", 0) * scale;\r\n\t\t\t\tdata.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\r\n\t\t\t\tdata.compress = this.getValue(constraintMap, \"compress\", false);\r\n\t\t\t\tdata.stretch = this.getValue(constraintMap, \"stretch\", false);\r\n\t\t\t\tdata.uniform = this.getValue(constraintMap, \"uniform\", false);\r\n\r\n\t\t\t\tskeletonData.ikConstraints.push(data);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Transform constraints.\r\n\t\tif (root.transform) {\r\n\t\t\tfor (let i = 0; i < root.transform.length; i++) {\r\n\t\t\t\tlet constraintMap = root.transform[i];\r\n\t\t\t\tlet data = new TransformConstraintData(constraintMap.name);\r\n\t\t\t\tdata.order = this.getValue(constraintMap, \"order\", 0);\r\n\t\t\t\tdata.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n\r\n\t\t\t\tfor (let j = 0; j < constraintMap.bones.length; j++) {\r\n\t\t\t\t\tlet boneName = constraintMap.bones[j];\r\n\t\t\t\t\tlet bone = skeletonData.findBone(boneName);\r\n\t\t\t\t\tif (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n\t\t\t\t\tdata.bones.push(bone);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet targetName: string = constraintMap.target;\r\n\t\t\t\tdata.target = skeletonData.findBone(targetName);\r\n\t\t\t\tif (data.target == null) throw new Error(\"Transform constraint target bone not found: \" + targetName);\r\n\r\n\t\t\t\tdata.local = this.getValue(constraintMap, \"local\", false);\r\n\t\t\t\tdata.relative = this.getValue(constraintMap, \"relative\", false);\r\n\t\t\t\tdata.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n\t\t\t\tdata.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\r\n\t\t\t\tdata.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\r\n\t\t\t\tdata.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\r\n\t\t\t\tdata.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\r\n\t\t\t\tdata.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\r\n\r\n\t\t\t\tdata.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n\t\t\t\tdata.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n\t\t\t\tdata.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\r\n\t\t\t\tdata.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\r\n\r\n\t\t\t\tskeletonData.transformConstraints.push(data);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Path constraints.\r\n\t\tif (root.path) {\r\n\t\t\tfor (let i = 0; i < root.path.length; i++) {\r\n\t\t\t\tlet constraintMap = root.path[i];\r\n\t\t\t\tlet data = new PathConstraintData(constraintMap.name);\r\n\t\t\t\tdata.order = this.getValue(constraintMap, \"order\", 0);\r\n\t\t\t\tdata.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n\r\n\t\t\t\tfor (let j = 0; j < constraintMap.bones.length; j++) {\r\n\t\t\t\t\tlet boneName = constraintMap.bones[j];\r\n\t\t\t\t\tlet bone = skeletonData.findBone(boneName);\r\n\t\t\t\t\tif (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n\t\t\t\t\tdata.bones.push(bone);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet targetName: string = constraintMap.target;\r\n\t\t\t\tdata.target = skeletonData.findSlot(targetName);\r\n\t\t\t\tif (data.target == null) throw new Error(\"Path target slot not found: \" + targetName);\r\n\r\n\t\t\t\tdata.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\r\n\t\t\t\tdata.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\r\n\t\t\t\tdata.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\r\n\t\t\t\tdata.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n\t\t\t\tdata.position = this.getValue(constraintMap, \"position\", 0);\r\n\t\t\t\tif (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n\t\t\t\tdata.spacing = this.getValue(constraintMap, \"spacing\", 0);\r\n\t\t\t\tif (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n\t\t\t\tdata.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n\t\t\t\tdata.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n\r\n\t\t\t\tskeletonData.pathConstraints.push(data);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Skins.\r\n\t\tif (root.skins) {\r\n\t\t\tfor (let i = 0; i < root.skins.length; i++) {\r\n\t\t\t\tlet skinMap = root.skins[i]\r\n\t\t\t\tlet skin = new Skin(skinMap.name);\r\n\r\n\t\t\t\tif (skinMap.bones) {\r\n\t\t\t\t\tfor (let ii = 0; ii < skinMap.bones.length; ii++) {\r\n\t\t\t\t\t\tlet bone = skeletonData.findBone(skinMap.bones[ii]);\r\n\t\t\t\t\t\tif (bone == null) throw new Error(\"Skin bone not found: \" + skinMap.bones[i]);\r\n\t\t\t\t\t\tskin.bones.push(bone);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (skinMap.ik) {\r\n\t\t\t\t\tfor (let ii = 0; ii < skinMap.ik.length; ii++) {\r\n\t\t\t\t\t\tlet constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\r\n\t\t\t\t\t\tif (constraint == null) throw new Error(\"Skin IK constraint not found: \" + skinMap.ik[i]);\r\n\t\t\t\t\t\tskin.constraints.push(constraint);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (skinMap.transform) {\r\n\t\t\t\t\tfor (let ii = 0; ii < skinMap.transform.length; ii++) {\r\n\t\t\t\t\t\tlet constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\r\n\t\t\t\t\t\tif (constraint == null) throw new Error(\"Skin transform constraint not found: \" + skinMap.transform[i]);\r\n\t\t\t\t\t\tskin.constraints.push(constraint);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (skinMap.path) {\r\n\t\t\t\t\tfor (let ii = 0; ii < skinMap.path.length; ii++) {\r\n\t\t\t\t\t\tlet constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\r\n\t\t\t\t\t\tif (constraint == null) throw new Error(\"Skin path constraint not found: \" + skinMap.path[i]);\r\n\t\t\t\t\t\tskin.constraints.push(constraint);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (let slotName in skinMap.attachments) {\r\n\t\t\t\t\tlet slot = skeletonData.findSlot(slotName);\r\n\t\t\t\t\tif (slot == null) throw new Error(\"Slot not found: \" + slotName);\r\n\t\t\t\t\tlet slotMap = skinMap.attachments[slotName];\r\n\t\t\t\t\tfor (let entryName in slotMap) {\r\n\t\t\t\t\t\tlet attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\r\n\t\t\t\t\t\tif (attachment != null) skin.setAttachment(slot.index, entryName, attachment);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tskeletonData.skins.push(skin);\r\n\t\t\t\tif (skin.name == \"default\") skeletonData.defaultSkin = skin;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Linked meshes.\r\n\t\tfor (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\r\n\t\t\tlet linkedMesh = this.linkedMeshes[i];\r\n\t\t\tlet skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n\t\t\tif (skin == null) throw new Error(\"Skin not found: \" + linkedMesh.skin);\r\n\t\t\tlet parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n\t\t\tif (parent == null) throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\r\n\t\t\tlinkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? <VertexAttachment>parent : <VertexAttachment>linkedMesh.mesh;\r\n\t\t\tlinkedMesh.mesh.setParentMesh(<MeshAttachment> parent);\r\n\t\t\tlinkedMesh.mesh.updateUVs();\r\n\t\t}\r\n\t\tthis.linkedMeshes.length = 0;\r\n\r\n\t\t// Events.\r\n\t\tif (root.events) {\r\n\t\t\tfor (let eventName in root.events) {\r\n\t\t\t\tlet eventMap = root.events[eventName];\r\n\t\t\t\tlet data = new EventData(eventName);\r\n\t\t\t\tdata.intValue = this.getValue(eventMap, \"int\", 0);\r\n\t\t\t\tdata.floatValue = this.getValue(eventMap, \"float\", 0);\r\n\t\t\t\tdata.stringValue = this.getValue(eventMap, \"string\", \"\");\r\n\t\t\t\tdata.audioPath = this.getValue(eventMap, \"audio\", null);\r\n\t\t\t\tif (data.audioPath != null) {\r\n\t\t\t\t\tdata.volume = this.getValue(eventMap, \"volume\", 1);\r\n\t\t\t\t\tdata.balance = this.getValue(eventMap, \"balance\", 0);\r\n\t\t\t\t}\r\n\t\t\t\tskeletonData.events.push(data);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Animations.\r\n\t\tif (root.animations) {\r\n\t\t\tfor (let animationName in root.animations) {\r\n\t\t\t\tlet animationMap = root.animations[animationName];\r\n\t\t\t\tthis.readAnimation(animationMap, animationName, skeletonData);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn skeletonData;\r\n\t}\r\n\r\n\treadAttachment (map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment {\r\n\t\tlet scale = this.scale;\r\n\t\tname = this.getValue(map, \"name\", name);\r\n\r\n\t\tlet type = this.getValue(map, \"type\", \"region\");\r\n\r\n\t\tswitch (type) {\r\n\t\t\tcase \"region\": {\r\n\t\t\t\tlet path = this.getValue(map, \"path\", name);\r\n\t\t\t\tlet region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n\t\t\t\tif (region == null) return null;\r\n\t\t\t\tregion.path = path;\r\n\t\t\t\tregion.x = this.getValue(map, \"x\", 0) * scale;\r\n\t\t\t\tregion.y = this.getValue(map, \"y\", 0) * scale;\r\n\t\t\t\tregion.scaleX = this.getValue(map, \"scaleX\", 1);\r\n\t\t\t\tregion.scaleY = this.getValue(map, \"scaleY\", 1);\r\n\t\t\t\tregion.rotation = this.getValue(map, \"rotation\", 0);\r\n\t\t\t\tregion.width = map.width * scale;\r\n\t\t\t\tregion.height = map.height * scale;\r\n\r\n\t\t\t\tlet color: string = this.getValue(map, \"color\", null);\r\n\t\t\t\tif (color != null) region.color.setFromString(color);\r\n\r\n\t\t\t\tregion.updateOffset();\r\n\t\t\t\treturn region;\r\n\t\t\t}\r\n\t\t\tcase \"boundingbox\": {\r\n\t\t\t\tlet box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n\t\t\t\tif (box == null) return null;\r\n\t\t\t\tthis.readVertices(map, box, map.vertexCount << 1);\r\n\t\t\t\tlet color: string = this.getValue(map, \"color\", null);\r\n\t\t\t\tif (color != null) box.color.setFromString(color);\r\n\t\t\t\treturn box;\r\n\t\t\t}\r\n\t\t\tcase \"mesh\":\r\n\t\t\tcase \"linkedmesh\": {\r\n\t\t\t\tlet path = this.getValue(map, \"path\", name);\r\n\t\t\t\tlet mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n\t\t\t\tif (mesh == null) return null;\r\n\t\t\t\tmesh.path = path;\r\n\r\n\t\t\t\tlet color = this.getValue(map, \"color\", null);\r\n\t\t\t\tif (color != null) mesh.color.setFromString(color);\r\n\r\n\t\t\t\tmesh.width = this.getValue(map, \"width\", 0) * scale;\r\n\t\t\t\tmesh.height = this.getValue(map, \"height\", 0) * scale;\r\n\r\n\t\t\t\tlet parent: string = this.getValue(map, \"parent\", null);\r\n\t\t\t\tif (parent != null) {\r\n\t\t\t\t\tthis.linkedMeshes.push(new LinkedMesh(mesh, <string> this.getValue(map, \"skin\", null), slotIndex, parent, this.getValue(map, \"deform\", true)));\r\n\t\t\t\t\treturn mesh;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet uvs: Array<number> = map.uvs;\r\n\t\t\t\tthis.readVertices(map, mesh, uvs.length);\r\n\t\t\t\tmesh.triangles = map.triangles;\r\n\t\t\t\tmesh.regionUVs = uvs;\r\n\t\t\t\tmesh.updateUVs();\r\n\r\n\t\t\t\tmesh.edges = this.getValue(map, \"edges\", null);\r\n\t\t\t\tmesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\r\n\t\t\t\treturn mesh;\r\n\t\t\t}\r\n\t\t\tcase \"path\": {\r\n\t\t\t\tlet path = this.attachmentLoader.newPathAttachment(skin, name);\r\n\t\t\t\tif (path == null) return null;\r\n\t\t\t\tpath.closed = this.getValue(map, \"closed\", false);\r\n\t\t\t\tpath.constantSpeed = this.getValue(map, \"constantSpeed\", true);\r\n\r\n\t\t\t\tlet vertexCount = map.vertexCount;\r\n\t\t\t\tthis.readVertices(map, path, vertexCount << 1);\r\n\r\n\t\t\t\tlet lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\r\n\t\t\t\tfor (let i = 0; i < map.lengths.length; i++)\r\n\t\t\t\t\tlengths[i] = map.lengths[i] * scale;\r\n\t\t\t\tpath.lengths = lengths;\r\n\r\n\t\t\t\tlet color: string = this.getValue(map, \"color\", null);\r\n\t\t\t\tif (color != null) path.color.setFromString(color);\r\n\t\t\t\treturn path;\r\n\t\t\t}\r\n\t\t\tcase \"point\": {\r\n\t\t\t\tlet point = this.attachmentLoader.newPointAttachment(skin, name);\r\n\t\t\t\tif (point == null) return null;\r\n\t\t\t\tpoint.x = this.getValue(map, \"x\", 0) * scale;\r\n\t\t\t\tpoint.y = this.getValue(map, \"y\", 0) * scale;\r\n\t\t\t\tpoint.rotation = this.getValue(map, \"rotation\", 0);\r\n\r\n\t\t\t\tlet color = this.getValue(map, \"color\", null);\r\n\t\t\t\tif (color != null) point.color.setFromString(color);\r\n\t\t\t\treturn point;\r\n\t\t\t}\r\n\t\t\tcase \"clipping\": {\r\n\t\t\t\tlet clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n\t\t\t\tif (clip == null) return null;\r\n\r\n\t\t\t\tlet end = this.getValue(map, \"end\", null);\r\n\t\t\t\tif (end != null) {\r\n\t\t\t\t\tlet slot = skeletonData.findSlot(end);\r\n\t\t\t\t\tif (slot == null) throw new Error(\"Clipping end slot not found: \" + end);\r\n\t\t\t\t\tclip.endSlot = slot;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet vertexCount = map.vertexCount;\r\n\t\t\t\tthis.readVertices(map, clip, vertexCount << 1);\r\n\r\n\t\t\t\tlet color: string = this.getValue(map, \"color\", null);\r\n\t\t\t\tif (color != null) clip.color.setFromString(color);\r\n\t\t\t\treturn clip;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\treadVertices (map: any, attachment: VertexAttachment, verticesLength: number) {\r\n\t\tlet scale = this.scale;\r\n\t\tattachment.worldVerticesLength = verticesLength;\r\n\t\tlet vertices: Array<number> = map.vertices;\r\n\t\tif (verticesLength == vertices.length) {\r\n\t\t\tlet scaledVertices = Utils.toFloatArray(vertices);\r\n\t\t\tif (scale != 1) {\r\n\t\t\t\tfor (let i = 0, n = vertices.length; i < n; i++)\r\n\t\t\t\t\tscaledVertices[i] *= scale;\r\n\t\t\t}\r\n\t\t\tattachment.vertices = scaledVertices;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet weights = new Array<number>();\r\n\t\tlet bones = new Array<number>();\r\n\t\tfor (let i = 0, n = vertices.length; i < n;) {\r\n\t\t\tlet boneCount = vertices[i++];\r\n\t\t\tbones.push(boneCount);\r\n\t\t\tfor (let nn = i + boneCount * 4; i < nn; i += 4) {\r\n\t\t\t\tbones.push(vertices[i]);\r\n\t\t\t\tweights.push(vertices[i + 1] * scale);\r\n\t\t\t\tweights.push(vertices[i + 2] * scale);\r\n\t\t\t\tweights.push(vertices[i + 3]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tattachment.bones = bones;\r\n\t\tattachment.vertices = Utils.toFloatArray(weights);\r\n\t}\r\n\r\n\treadAnimation (map: any, name: string, skeletonData: SkeletonData) {\r\n\t\tlet scale = this.scale;\r\n\t\tlet timelines = new Array<Timeline>();\r\n\t\tlet duration = 0;\r\n\r\n\t\t// Slot timelines.\r\n\t\tif (map.slots) {\r\n\t\t\tfor (let slotName in map.slots) {\r\n\t\t\t\tlet slotMap = map.slots[slotName];\r\n\t\t\t\tlet slotIndex = skeletonData.findSlotIndex(slotName);\r\n\t\t\t\tif (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\r\n\t\t\t\tfor (let timelineName in slotMap) {\r\n\t\t\t\t\tlet timelineMap = slotMap[timelineName];\r\n\t\t\t\t\tif (timelineName == \"attachment\") {\r\n\t\t\t\t\t\tlet timeline = new AttachmentTimeline(timelineMap.length);\r\n\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\r\n\t\t\t\t\t\tlet frameIndex = 0;\r\n\t\t\t\t\t\tfor (let i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\tlet valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex++, this.getValue(valueMap, \"time\", 0), valueMap.name);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\t\t\t\t\t} else if (timelineName == \"color\") {\r\n\t\t\t\t\t\tlet timeline = new ColorTimeline(timelineMap.length);\r\n\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\r\n\t\t\t\t\t\tlet frameIndex = 0;\r\n\t\t\t\t\t\tfor (let i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\tlet valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\tlet color = new Color();\r\n\t\t\t\t\t\t\tcolor.setFromString(valueMap.color);\r\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), color.r, color.g, color.b, color.a);\r\n\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\r\n\r\n\t\t\t\t\t} else if (timelineName == \"twoColor\") {\r\n\t\t\t\t\t\tlet timeline = new TwoColorTimeline(timelineMap.length);\r\n\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\r\n\t\t\t\t\t\tlet frameIndex = 0;\r\n\t\t\t\t\t\tfor (let i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\tlet valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\tlet light = new Color();\r\n\t\t\t\t\t\t\tlet dark = new Color();\r\n\t\t\t\t\t\t\tlight.setFromString(valueMap.light);\r\n\t\t\t\t\t\t\tdark.setFromString(valueMap.dark);\r\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\r\n\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);\r\n\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tthrow new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Bone timelines.\r\n\t\tif (map.bones) {\r\n\t\t\tfor (let boneName in map.bones) {\r\n\t\t\t\tlet boneMap = map.bones[boneName];\r\n\t\t\t\tlet boneIndex = skeletonData.findBoneIndex(boneName);\r\n\t\t\t\tif (boneIndex == -1) throw new Error(\"Bone not found: \" + boneName);\r\n\t\t\t\tfor (let timelineName in boneMap) {\r\n\t\t\t\t\tlet timelineMap = boneMap[timelineName];\r\n\t\t\t\t\tif (timelineName === \"rotate\") {\r\n\t\t\t\t\t\tlet timeline = new RotateTimeline(timelineMap.length);\r\n\t\t\t\t\t\ttimeline.boneIndex = boneIndex;\r\n\r\n\t\t\t\t\t\tlet frameIndex = 0;\r\n\t\t\t\t\t\tfor (let i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\tlet valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"angle\", 0));\r\n\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\r\n\r\n\t\t\t\t\t} else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\r\n\t\t\t\t\t\tlet timeline: TranslateTimeline = null;\r\n\t\t\t\t\t\tlet timelineScale = 1, defaultValue = 0;\r\n\t\t\t\t\t\tif (timelineName === \"scale\") {\r\n\t\t\t\t\t\t\ttimeline = new ScaleTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\tdefaultValue = 1;\r\n\t\t\t\t\t\t} else if (timelineName === \"shear\")\r\n\t\t\t\t\t\t\ttimeline = new ShearTimeline(timelineMap.length);\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\ttimeline = new TranslateTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimelineScale = scale;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimeline.boneIndex = boneIndex;\r\n\r\n\t\t\t\t\t\tlet frameIndex = 0;\r\n\t\t\t\t\t\tfor (let i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\tlet valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\tlet x = this.getValue(valueMap, \"x\", defaultValue), y = this.getValue(valueMap, \"y\", defaultValue);\r\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), x * timelineScale, y * timelineScale);\r\n\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\r\n\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tthrow new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// IK constraint timelines.\r\n\t\tif (map.ik) {\r\n\t\t\tfor (let constraintName in map.ik) {\r\n\t\t\t\tlet constraintMap = map.ik[constraintName];\r\n\t\t\t\tlet constraint = skeletonData.findIkConstraint(constraintName);\r\n\t\t\t\tlet timeline = new IkConstraintTimeline(constraintMap.length);\r\n\t\t\t\ttimeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\r\n\t\t\t\tlet frameIndex = 0;\r\n\t\t\t\tfor (let i = 0; i < constraintMap.length; i++) {\r\n\t\t\t\t\tlet valueMap = constraintMap[i];\r\n\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"mix\", 1), this.getValue(valueMap, \"softness\", 0) * scale,\r\n\t\t\t\t\t\tthis.getValue(valueMap, \"bendPositive\", true) ? 1 : -1, this.getValue(valueMap, \"compress\", false), this.getValue(valueMap, \"stretch\", false));\r\n\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\tframeIndex++;\r\n\t\t\t\t}\r\n\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Transform constraint timelines.\r\n\t\tif (map.transform) {\r\n\t\t\tfor (let constraintName in map.transform) {\r\n\t\t\t\tlet constraintMap = map.transform[constraintName];\r\n\t\t\t\tlet constraint = skeletonData.findTransformConstraint(constraintName);\r\n\t\t\t\tlet timeline = new TransformConstraintTimeline(constraintMap.length);\r\n\t\t\t\ttimeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\r\n\t\t\t\tlet frameIndex = 0;\r\n\t\t\t\tfor (let i = 0; i < constraintMap.length; i++) {\r\n\t\t\t\t\tlet valueMap = constraintMap[i];\r\n\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"rotateMix\", 1),\r\n\t\t\t\t\t\tthis.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\r\n\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\tframeIndex++;\r\n\t\t\t\t}\r\n\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\tduration = Math.max(duration,\r\n\t\t\t\t\ttimeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Path constraint timelines.\r\n\t\tif (map.path) {\r\n\t\t\tfor (let constraintName in map.path) {\r\n\t\t\t\tlet constraintMap = map.path[constraintName];\r\n\t\t\t\tlet index = skeletonData.findPathConstraintIndex(constraintName);\r\n\t\t\t\tif (index == -1) throw new Error(\"Path constraint not found: \" + constraintName);\r\n\t\t\t\tlet data = skeletonData.pathConstraints[index];\r\n\t\t\t\tfor (let timelineName in constraintMap) {\r\n\t\t\t\t\tlet timelineMap = constraintMap[timelineName];\r\n\t\t\t\t\tif (timelineName === \"position\" || timelineName === \"spacing\") {\r\n\t\t\t\t\t\tlet timeline: PathConstraintPositionTimeline = null;\r\n\t\t\t\t\t\tlet timelineScale = 1;\r\n\t\t\t\t\t\tif (timelineName === \"spacing\") {\r\n\t\t\t\t\t\t\ttimeline = new PathConstraintSpacingTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\tif (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttimeline = new PathConstraintPositionTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\tif (data.positionMode == PositionMode.Fixed) timelineScale = scale;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimeline.pathConstraintIndex = index;\r\n\t\t\t\t\t\tlet frameIndex = 0;\r\n\t\t\t\t\t\tfor (let i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\tlet valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, timelineName, 0) * timelineScale);\r\n\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\tduration = Math.max(duration,\r\n\t\t\t\t\t\t\ttimeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\r\n\t\t\t\t\t} else if (timelineName === \"mix\") {\r\n\t\t\t\t\t\tlet timeline = new PathConstraintMixTimeline(timelineMap.length);\r\n\t\t\t\t\t\ttimeline.pathConstraintIndex = index;\r\n\t\t\t\t\t\tlet frameIndex = 0;\r\n\t\t\t\t\t\tfor (let i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\tlet valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"rotateMix\", 1),\r\n\t\t\t\t\t\t\t\tthis.getValue(valueMap, \"translateMix\", 1));\r\n\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\tduration = Math.max(duration,\r\n\t\t\t\t\t\t\ttimeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Deform timelines.\r\n\t\tif (map.deform) {\r\n\t\t\tfor (let deformName in map.deform) {\r\n\t\t\t\tlet deformMap = map.deform[deformName];\r\n\t\t\t\tlet skin = skeletonData.findSkin(deformName);\r\n\t\t\t\tif (skin == null) throw new Error(\"Skin not found: \" + deformName);\r\n\t\t\t\tfor (let slotName in deformMap) {\r\n\t\t\t\t\tlet slotMap = deformMap[slotName];\r\n\t\t\t\t\tlet slotIndex = skeletonData.findSlotIndex(slotName);\r\n\t\t\t\t\tif (slotIndex == -1) throw new Error(\"Slot not found: \" + slotMap.name);\r\n\t\t\t\t\tfor (let timelineName in slotMap) {\r\n\t\t\t\t\t\tlet timelineMap = slotMap[timelineName];\r\n\t\t\t\t\t\tlet attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\r\n\t\t\t\t\t\tif (attachment == null) throw new Error(\"Deform attachment not found: \" + timelineMap.name);\r\n\t\t\t\t\t\tlet weighted = attachment.bones != null;\r\n\t\t\t\t\t\tlet vertices = attachment.vertices;\r\n\t\t\t\t\t\tlet deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n\r\n\t\t\t\t\t\tlet timeline = new DeformTimeline(timelineMap.length);\r\n\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\ttimeline.attachment = attachment;\r\n\r\n\t\t\t\t\t\tlet frameIndex = 0;\r\n\t\t\t\t\t\tfor (let j = 0; j < timelineMap.length; j++) {\r\n\t\t\t\t\t\t\tlet valueMap = timelineMap[j];\r\n\t\t\t\t\t\t\tlet deform: ArrayLike<number>;\r\n\t\t\t\t\t\t\tlet verticesValue: Array<Number> = this.getValue(valueMap, \"vertices\", null);\r\n\t\t\t\t\t\t\tif (verticesValue == null)\r\n\t\t\t\t\t\t\t\tdeform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tdeform = Utils.newFloatArray(deformLength);\r\n\t\t\t\t\t\t\t\tlet start = <number>this.getValue(valueMap, \"offset\", 0);\r\n\t\t\t\t\t\t\t\tUtils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\r\n\t\t\t\t\t\t\t\tif (scale != 1) {\r\n\t\t\t\t\t\t\t\t\tfor (let i = start, n = i + verticesValue.length; i < n; i++)\r\n\t\t\t\t\t\t\t\t\t\tdeform[i] *= scale;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (!weighted) {\r\n\t\t\t\t\t\t\t\t\tfor (let i = 0; i < deformLength; i++)\r\n\t\t\t\t\t\t\t\t\t\tdeform[i] += vertices[i];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), deform);\r\n\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Draw order timeline.\r\n\t\tlet drawOrderNode = map.drawOrder;\r\n\t\tif (drawOrderNode == null) drawOrderNode = map.draworder;\r\n\t\tif (drawOrderNode != null) {\r\n\t\t\tlet timeline = new DrawOrderTimeline(drawOrderNode.length);\r\n\t\t\tlet slotCount = skeletonData.slots.length;\r\n\t\t\tlet frameIndex = 0;\r\n\t\t\tfor (let j = 0; j < drawOrderNode.length; j++) {\r\n\t\t\t\tlet drawOrderMap = drawOrderNode[j];\r\n\t\t\t\tlet drawOrder: Array<number> = null;\r\n\t\t\t\tlet offsets = this.getValue(drawOrderMap, \"offsets\", null);\r\n\t\t\t\tif (offsets != null) {\r\n\t\t\t\t\tdrawOrder = Utils.newArray<number>(slotCount, -1);\r\n\t\t\t\t\tlet unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\r\n\t\t\t\t\tlet originalIndex = 0, unchangedIndex = 0;\r\n\t\t\t\t\tfor (let i = 0; i < offsets.length; i++) {\r\n\t\t\t\t\t\tlet offsetMap = offsets[i];\r\n\t\t\t\t\t\tlet slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\r\n\t\t\t\t\t\tif (slotIndex == -1) throw new Error(\"Slot not found: \" + offsetMap.slot);\r\n\t\t\t\t\t\t// Collect unchanged items.\r\n\t\t\t\t\t\twhile (originalIndex != slotIndex)\r\n\t\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\r\n\t\t\t\t\t\t// Set changed items.\r\n\t\t\t\t\t\tdrawOrder[originalIndex + offsetMap.offset] = originalIndex++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Collect remaining unchanged items.\r\n\t\t\t\t\twhile (originalIndex < slotCount)\r\n\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\r\n\t\t\t\t\t// Fill in unchanged items.\r\n\t\t\t\t\tfor (let i = slotCount - 1; i >= 0; i--)\r\n\t\t\t\t\t\tif (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\r\n\t\t\t\t}\r\n\t\t\t\ttimeline.setFrame(frameIndex++, this.getValue(drawOrderMap, \"time\", 0), drawOrder);\r\n\t\t\t}\r\n\t\t\ttimelines.push(timeline);\r\n\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\t\t}\r\n\r\n\t\t// Event timeline.\r\n\t\tif (map.events) {\r\n\t\t\tlet timeline = new EventTimeline(map.events.length);\r\n\t\t\tlet frameIndex = 0;\r\n\t\t\tfor (let i = 0; i < map.events.length; i++) {\r\n\t\t\t\tlet eventMap = map.events[i];\r\n\t\t\t\tlet eventData = skeletonData.findEvent(eventMap.name);\r\n\t\t\t\tif (eventData == null) throw new Error(\"Event not found: \" + eventMap.name);\r\n\t\t\t\tlet event = new Event(Utils.toSinglePrecision(this.getValue(eventMap, \"time\", 0)), eventData);\r\n\t\t\t\tevent.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\r\n\t\t\t\tevent.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\r\n\t\t\t\tevent.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\r\n\t\t\t\tif (event.data.audioPath != null) {\r\n\t\t\t\t\tevent.volume = this.getValue(eventMap, \"volume\", 1);\r\n\t\t\t\t\tevent.balance = this.getValue(eventMap, \"balance\", 0);\r\n\t\t\t\t}\r\n\t\t\t\ttimeline.setFrame(frameIndex++, event);\r\n\t\t\t}\r\n\t\t\ttimelines.push(timeline);\r\n\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\t\t}\r\n\r\n\t\tif (isNaN(duration)) {\r\n\t\t\tthrow new Error(\"Error while parsing animation, duration is NaN\");\r\n\t\t}\r\n\r\n\t\tskeletonData.animations.push(new Animation(name, timelines, duration));\r\n\t}\r\n\r\n\treadCurve (map: any, timeline: CurveTimeline, frameIndex: number) {\r\n\t\tif (!map.hasOwnProperty(\"curve\")) return;\r\n\t\tif (map.curve == \"stepped\")\r\n\t\t\ttimeline.setStepped(frameIndex);\r\n\t\telse {\r\n\t\t\tlet curve: number = map.curve;\r\n\t\t\ttimeline.setCurve(frameIndex, curve, this.getValue(map, \"c2\", 0), this.getValue(map, \"c3\", 1), this.getValue(map, \"c4\", 1));\r\n\t\t}\r\n\t}\r\n\r\n\tgetValue (map: any, prop: string, defaultValue: any) {\r\n\t\treturn map[prop] !== undefined ? map[prop] : defaultValue;\r\n\t}\r\n\r\n\tstatic blendModeFromString (str: string) {\r\n\t\tstr = str.toLowerCase();\r\n\t\tif (str == \"normal\") return BlendMode.Normal;\r\n\t\tif (str == \"additive\") return BlendMode.Additive;\r\n\t\tif (str == \"multiply\") return BlendMode.Multiply;\r\n\t\tif (str == \"screen\") return BlendMode.Screen;\r\n\t\tthrow new Error(`Unknown blend mode: ${str}`);\r\n\t}\r\n\r\n\tstatic positionModeFromString (str: string) {\r\n\t\tstr = str.toLowerCase();\r\n\t\tif (str == \"fixed\") return PositionMode.Fixed;\r\n\t\tif (str == \"percent\") return PositionMode.Percent;\r\n\t\tthrow new Error(`Unknown position mode: ${str}`);\r\n\t}\r\n\r\n\tstatic spacingModeFromString (str: string) {\r\n\t\tstr = str.toLowerCase();\r\n\t\tif (str == \"length\") return SpacingMode.Length;\r\n\t\tif (str == \"fixed\") return SpacingMode.Fixed;\r\n\t\tif (str == \"percent\") return SpacingMode.Percent;\r\n\t\tthrow new Error(`Unknown position mode: ${str}`);\r\n\t}\r\n\r\n\tstatic rotateModeFromString (str: string) {\r\n\t\tstr = str.toLowerCase();\r\n\t\tif (str == \"tangent\") return RotateMode.Tangent;\r\n\t\tif (str == \"chain\") return RotateMode.Chain;\r\n\t\tif (str == \"chainscale\") return RotateMode.ChainScale;\r\n\t\tthrow new Error(`Unknown rotate mode: ${str}`);\r\n\t}\r\n\r\n\tstatic transformModeFromString(str: string) {\r\n\t\tstr = str.toLowerCase();\r\n\t\tif (str == \"normal\") return TransformMode.Normal;\r\n\t\tif (str == \"onlytranslation\") return TransformMode.OnlyTranslation;\r\n\t\tif (str == \"norotationorreflection\") return TransformMode.NoRotationOrReflection;\r\n\t\tif (str == \"noscale\") return TransformMode.NoScale;\r\n\t\tif (str == \"noscaleorreflection\") return TransformMode.NoScaleOrReflection;\r\n\t\tthrow new Error(`Unknown transform mode: ${str}`);\r\n\t}\r\n}\r\n\r\nclass LinkedMesh {\r\n\tparent: string; skin: string;\r\n\tslotIndex: number;\r\n\tmesh: MeshAttachment;\r\n\tinheritDeform: boolean;\r\n\r\n\tconstructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\r\n\t\tthis.mesh = mesh;\r\n\t\tthis.skin = skin;\r\n\t\tthis.slotIndex = slotIndex;\r\n\t\tthis.parent = parent;\r\n\t\tthis.inheritDeform = inheritDeform;\r\n\t}\r\n}\r\n","\n\nimport { TransformMode, BoneData } from \"./BoneData\";\nimport { PositionMode, SpacingMode, RotateMode, PathConstraintData } from \"./PathConstraintData\";\nimport { BlendMode } from \"./BlendMode\";\nimport { AttachmentLoader } from \"./attachments/AttachmentLoader\";\nimport { SkeletonData } from \"./SkeletonData\";\nimport { Color, Utils } from \"./Utils\";\nimport { SlotData } from \"./SlotData\";\nimport { IkConstraintData } from \"./IkConstraintData\";\nimport { TransformConstraintData } from \"./TransformConstraintData\";\nimport { VertexAttachment, Attachment } from \"./attachments/Attachment\";\nimport { MeshAttachment } from \"./attachments/MeshAttachment\";\nimport { EventData } from \"./EventData\";\nimport { Skin } from \"./Skin\";\nimport { AttachmentType } from \"./attachments/AttachmentType\";\nimport { Timeline, AttachmentTimeline, ColorTimeline, TwoColorTimeline, RotateTimeline, ScaleTimeline, ShearTimeline, TranslateTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintSpacingTimeline, PathConstraintPositionTimeline, PathConstraintMixTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, CurveTimeline } from \"./Animation\";\nimport { Animation } from \"./Animation\";\nimport { Event } from \"./Event\";\n\n/** Loads skeleton data in the Spine binary format.\n *\n * See [Spine binary format](http://esotericsoftware.com/spine-binary-format) and\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\n * Runtimes Guide. */\nexport class SkeletonBinary {\n\tstatic AttachmentTypeValues = [ 0 /*AttachmentType.Region*/, 1/*AttachmentType.BoundingBox*/, 2/*AttachmentType.Mesh*/, 3/*AttachmentType.LinkedMesh*/, 4/*AttachmentType.Path*/, 5/*AttachmentType.Point*/, 6/*AttachmentType.Clipping*/ ];\n\tstatic TransformModeValues = [TransformMode.Normal, TransformMode.OnlyTranslation, TransformMode.NoRotationOrReflection, TransformMode.NoScale, TransformMode.NoScaleOrReflection];\n\tstatic PositionModeValues = [ PositionMode.Fixed, PositionMode.Percent ];\n\tstatic SpacingModeValues = [ SpacingMode.Length, SpacingMode.Fixed, SpacingMode.Percent];\n\tstatic RotateModeValues = [ RotateMode.Tangent, RotateMode.Chain, RotateMode.ChainScale ];\n\tstatic BlendModeValues = [ BlendMode.Normal, BlendMode.Additive, BlendMode.Multiply, BlendMode.Screen];\n\n\tstatic BONE_ROTATE = 0;\n\tstatic BONE_TRANSLATE = 1;\n\tstatic BONE_SCALE = 2;\n\tstatic BONE_SHEAR = 3;\n\n\tstatic SLOT_ATTACHMENT = 0;\n\tstatic SLOT_COLOR = 1;\n\tstatic SLOT_TWO_COLOR = 2;\n\n\tstatic PATH_POSITION = 0;\n\tstatic PATH_SPACING = 1;\n\tstatic PATH_MIX = 2;\n\n\tstatic CURVE_LINEAR = 0;\n\tstatic CURVE_STEPPED = 1;\n\tstatic CURVE_BEZIER = 2;\n\n\t/** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n\t * runtime than were used in Spine.\n\t *\n\t * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n\tscale = 1;\n\n\tattachmentLoader: AttachmentLoader;\n\tprivate linkedMeshes = new Array<LinkedMesh>();\n\n\tconstructor (attachmentLoader: AttachmentLoader) {\n\t\tthis.attachmentLoader = attachmentLoader;\n\t}\n\n\treadSkeletonData (binary: Uint8Array): SkeletonData {\n\t\tlet scale = this.scale;\n\n\t\tlet skeletonData = new SkeletonData();\n\t\tskeletonData.name = \"\"; // BOZO\n\n\t\tlet input = new BinaryInput(binary);\n\n\t\tskeletonData.hash = input.readString();\n\t\tskeletonData.version = input.readString();\n\t\tif (\"3.8.75\" == skeletonData.version)\n\t\t\t\tthrow new Error(\"Unsupported skeleton data, please export with a newer version of Spine.\");\n\t\tskeletonData.x = input.readFloat();\n\t\tskeletonData.y = input.readFloat();\n\t\tskeletonData.width = input.readFloat();\n\t\tskeletonData.height = input.readFloat();\n\n\t\tlet nonessential = input.readBoolean();\n\t\tif (nonessential) {\n\t\t\tskeletonData.fps = input.readFloat();\n\n\t\t\tskeletonData.imagesPath = input.readString();\n\t\t\tskeletonData.audioPath = input.readString();\n\t\t}\n\n\t\tlet n = 0;\n\t\t// Strings.\n\t\tn = input.readInt(true)\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tinput.strings.push(input.readString());\n\n\t\t// Bones.\n\t\tn = input.readInt(true)\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet name = input.readString();\n\t\t\tlet parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\n\t\t\tlet data = new BoneData(i, name, parent);\n\t\t\tdata.rotation = input.readFloat();\n\t\t\tdata.x = input.readFloat() * scale;\n\t\t\tdata.y = input.readFloat() * scale;\n\t\t\tdata.scaleX = input.readFloat();\n\t\t\tdata.scaleY = input.readFloat();\n\t\t\tdata.shearX = input.readFloat();\n\t\t\tdata.shearY = input.readFloat();\n\t\t\tdata.length = input.readFloat() * scale;\n\t\t\tdata.transformMode = SkeletonBinary.TransformModeValues[input.readInt(true)];\n\t\t\tdata.skinRequired = input.readBoolean();\n\t\t\tif (nonessential) Color.rgba8888ToColor(data.color, input.readInt32());\n\t\t\tskeletonData.bones.push(data);\n\t\t}\n\n\t\t// Slots.\n\t\tn = input.readInt(true);\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet slotName = input.readString();\n\t\t\tlet boneData = skeletonData.bones[input.readInt(true)];\n\t\t\tlet data = new SlotData(i, slotName, boneData);\n\t\t\tColor.rgba8888ToColor(data.color, input.readInt32());\n\n\t\t\tlet darkColor = input.readInt32();\n\t\t\tif (darkColor != -1) Color.rgb888ToColor(data.darkColor = new Color(), darkColor);\n\n\t\t\tdata.attachmentName = input.readStringRef();\n\t\t\tdata.blendMode = SkeletonBinary.BlendModeValues[input.readInt(true)];\n\t\t\tskeletonData.slots.push(data);\n\t\t}\n\n\t\t// IK constraints.\n\t\tn = input.readInt(true);\n\t\tfor (let i = 0, nn; i < n; i++) {\n\t\t\tlet data = new IkConstraintData(input.readString());\n\t\t\tdata.order = input.readInt(true);\n\t\t\tdata.skinRequired = input.readBoolean();\n\t\t\tnn = input.readInt(true);\n\t\t\tfor (let ii = 0; ii < nn; ii++)\n\t\t\t\tdata.bones.push(skeletonData.bones[input.readInt(true)]);\n\t\t\tdata.target = skeletonData.bones[input.readInt(true)];\n\t\t\tdata.mix = input.readFloat();\n\t\t\tdata.softness = input.readFloat() * scale;\n\t\t\tdata.bendDirection = input.readByte();\n\t\t\tdata.compress = input.readBoolean();\n\t\t\tdata.stretch = input.readBoolean();\n\t\t\tdata.uniform = input.readBoolean();\n\t\t\tskeletonData.ikConstraints.push(data);\n\t\t}\n\n\t\t// Transform constraints.\n\t\tn = input.readInt(true);\n\t\tfor (let i = 0, nn; i < n; i++) {\n\t\t\tlet data = new TransformConstraintData(input.readString());\n\t\t\tdata.order = input.readInt(true);\n\t\t\tdata.skinRequired = input.readBoolean();\n\t\t\tnn = input.readInt(true);\n\t\t\tfor (let ii = 0; ii < nn; ii++)\n\t\t\t\tdata.bones.push(skeletonData.bones[input.readInt(true)]);\n\t\t\tdata.target = skeletonData.bones[input.readInt(true)];\n\t\t\tdata.local = input.readBoolean();\n\t\t\tdata.relative = input.readBoolean();\n\t\t\tdata.offsetRotation = input.readFloat();\n\t\t\tdata.offsetX = input.readFloat() * scale;\n\t\t\tdata.offsetY = input.readFloat() * scale;\n\t\t\tdata.offsetScaleX = input.readFloat();\n\t\t\tdata.offsetScaleY = input.readFloat();\n\t\t\tdata.offsetShearY = input.readFloat();\n\t\t\tdata.rotateMix = input.readFloat();\n\t\t\tdata.translateMix = input.readFloat();\n\t\t\tdata.scaleMix = input.readFloat();\n\t\t\tdata.shearMix = input.readFloat();\n\t\t\tskeletonData.transformConstraints.push(data);\n\t\t}\n\n\t\t// Path constraints.\n\t\tn = input.readInt(true);\n\t\tfor (let i = 0, nn; i < n; i++) {\n\t\t\tlet data = new PathConstraintData(input.readString());\n\t\t\tdata.order = input.readInt(true);\n\t\t\tdata.skinRequired = input.readBoolean();\n\t\t\tnn = input.readInt(true);\n\t\t\tfor (let ii = 0; ii < nn; ii++)\n\t\t\t\tdata.bones.push(skeletonData.bones[input.readInt(true)]);\n\t\t\tdata.target = skeletonData.slots[input.readInt(true)];\n\t\t\tdata.positionMode = SkeletonBinary.PositionModeValues[input.readInt(true)];\n\t\t\tdata.spacingMode = SkeletonBinary.SpacingModeValues[input.readInt(true)];\n\t\t\tdata.rotateMode = SkeletonBinary.RotateModeValues[input.readInt(true)];\n\t\t\tdata.offsetRotation = input.readFloat();\n\t\t\tdata.position = input.readFloat();\n\t\t\tif (data.positionMode == PositionMode.Fixed) data.position *= scale;\n\t\t\tdata.spacing = input.readFloat();\n\t\t\tif (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n\t\t\tdata.rotateMix = input.readFloat();\n\t\t\tdata.translateMix = input.readFloat();\n\t\t\tskeletonData.pathConstraints.push(data);\n\t\t}\n\n\t\t// Default skin.\n\t\tlet defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\n\t\tif (defaultSkin != null) {\n\t\t\tskeletonData.defaultSkin = defaultSkin;\n\t\t\tskeletonData.skins.push(defaultSkin);\n\t\t}\n\n\t\t// Skins.\n\t\t{\n\t\t\tlet i = skeletonData.skins.length;\n\t\t\tUtils.setArraySize(skeletonData.skins, n = i + input.readInt(true));\n\t\t\tfor (; i < n; i++)\n\t\t\t\tskeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);\n\t\t}\n\n\t\t// Linked meshes.\n\t\tn = this.linkedMeshes.length;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet linkedMesh = this.linkedMeshes[i];\n\t\t\tlet skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n\t\t\tif (skin == null) throw new Error(\"Skin not found: \" + linkedMesh.skin);\n\t\t\tlet parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\t\t\tif (parent == null) throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\n\t\t\tlinkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent as VertexAttachment : linkedMesh.mesh;\n\t\t\tlinkedMesh.mesh.setParentMesh(parent as MeshAttachment);\n\t\t\tlinkedMesh.mesh.updateUVs();\n\t\t}\n\t\tthis.linkedMeshes.length = 0;\n\n\t\t// Events.\n\t\tn = input.readInt(true);\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet data = new EventData(input.readStringRef());\n\t\t\tdata.intValue = input.readInt(false);\n\t\t\tdata.floatValue = input.readFloat();\n\t\t\tdata.stringValue = input.readString();\n\t\t\tdata.audioPath = input.readString();\n\t\t\tif (data.audioPath != null) {\n\t\t\t\tdata.volume = input.readFloat();\n\t\t\t\tdata.balance = input.readFloat();\n\t\t\t}\n\t\t\tskeletonData.events.push(data);\n\t\t}\n\n\t\t// Animations.\n\t\tn = input.readInt(true);\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tskeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));\n\t\treturn skeletonData;\n\t}\n\n\tprivate readSkin (input: BinaryInput, skeletonData: SkeletonData, defaultSkin: boolean, nonessential: boolean): Skin {\n\t\tlet skin = null;\n\t\tlet slotCount = 0;\n\n\t\tif (defaultSkin) {\n\t\t\tslotCount = input.readInt(true)\n\t\t\tif (slotCount == 0) return null;\n\t\t\tskin = new Skin(\"default\");\n\t\t} else {\n\t\t\tskin = new Skin(input.readStringRef());\n\t\t\tskin.bones.length = input.readInt(true);\n\t\t\tfor (let i = 0, n = skin.bones.length; i < n; i++)\n\t\t\t\tskin.bones[i] = skeletonData.bones[input.readInt(true)];\n\n\t\t\tfor (let i = 0, n = input.readInt(true); i < n; i++)\n\t\t\t\tskin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\n\t\t\tfor (let i = 0, n = input.readInt(true); i < n; i++)\n\t\t\t\tskin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\n\t\t\tfor (let i = 0, n = input.readInt(true); i < n; i++)\n\t\t\t\tskin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\n\n\t\t\tslotCount = input.readInt(true);\n\t\t}\n\n\t\tfor (let i = 0; i < slotCount; i++) {\n\t\t\tlet slotIndex = input.readInt(true);\n\t\t\tfor (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n\t\t\t\tlet name = input.readStringRef();\n\t\t\t\tlet attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\n\t\t\t\tif (attachment != null) skin.setAttachment(slotIndex, name, attachment);\n\t\t\t}\n\t\t}\n\t\treturn skin;\n\t}\n\n\tprivate readAttachment(input: BinaryInput, skeletonData: SkeletonData, skin: Skin, slotIndex: number, attachmentName: string, nonessential: boolean): Attachment {\n\t\tlet scale = this.scale;\n\n\t\tlet name = input.readStringRef();\n\t\tif (name == null) name = attachmentName;\n\n\t\tlet typeIndex = input.readByte();\n\t\tlet type = SkeletonBinary.AttachmentTypeValues[typeIndex];\n\t\tswitch (type) {\n\t\tcase AttachmentType.Region: {\n\t\t\tlet path = input.readStringRef();\n\t\t\tlet rotation = input.readFloat();\n\t\t\tlet x = input.readFloat();\n\t\t\tlet y = input.readFloat();\n\t\t\tlet scaleX = input.readFloat();\n\t\t\tlet scaleY = input.readFloat();\n\t\t\tlet width = input.readFloat();\n\t\t\tlet height = input.readFloat();\n\t\t\tlet color = input.readInt32();\n\n\t\t\tif (path == null) path = name;\n\t\t\tlet region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n\t\t\tif (region == null) return null;\n\t\t\tregion.path = path;\n\t\t\tregion.x = x * scale;\n\t\t\tregion.y = y * scale;\n\t\t\tregion.scaleX = scaleX;\n\t\t\tregion.scaleY = scaleY;\n\t\t\tregion.rotation = rotation;\n\t\t\tregion.width = width * scale;\n\t\t\tregion.height = height * scale;\n\t\t\tColor.rgba8888ToColor(region.color, color);\n\t\t\tregion.updateOffset();\n\t\t\treturn region;\n\t\t}\n\t\tcase AttachmentType.BoundingBox: {\n\t\t\tlet vertexCount = input.readInt(true);\n\t\t\tlet vertices = this.readVertices(input, vertexCount);\n\t\t\tlet color = nonessential ? input.readInt32() : 0;\n\n\t\t\tlet box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\t\t\tif (box == null) return null;\n\t\t\tbox.worldVerticesLength = vertexCount << 1;\n\t\t\tbox.vertices = vertices.vertices;\n\t\t\tbox.bones = vertices.bones;\n\t\t\tif (nonessential) Color.rgba8888ToColor(box.color, color);\n\t\t\treturn box;\n\t\t}\n\t\tcase AttachmentType.Mesh: {\n\t\t\tlet path = input.readStringRef();\n\t\t\tlet color = input.readInt32();\n\t\t\tlet vertexCount = input.readInt(true);\n\t\t\tlet uvs = this.readFloatArray(input, vertexCount << 1, 1);\n\t\t\tlet triangles = this.readShortArray(input);\n\t\t\tlet vertices = this.readVertices(input, vertexCount);\n\t\t\tlet hullLength = input.readInt(true);\n\t\t\tlet edges = null;\n\t\t\tlet width = 0, height = 0;\n\t\t\tif (nonessential) {\n\t\t\t\tedges = this.readShortArray(input);\n\t\t\t\twidth = input.readFloat();\n\t\t\t\theight = input.readFloat();\n\t\t\t}\n\n\t\t\tif (path == null) path = name;\n\t\t\tlet mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n\t\t\tif (mesh == null) return null;\n\t\t\tmesh.path = path;\n\t\t\tColor.rgba8888ToColor(mesh.color, color);\n\t\t\tmesh.bones = vertices.bones;\n\t\t\tmesh.vertices = vertices.vertices;\n\t\t\tmesh.worldVerticesLength = vertexCount << 1;\n\t\t\tmesh.triangles = triangles;\n\t\t\tmesh.regionUVs = uvs;\n\t\t\tmesh.updateUVs();\n\t\t\tmesh.hullLength = hullLength << 1;\n\t\t\tif (nonessential) {\n\t\t\t\tmesh.edges = edges;\n\t\t\t\tmesh.width = width * scale;\n\t\t\t\tmesh.height = height * scale;\n\t\t\t}\n\t\t\treturn mesh;\n\t\t}\n\t\tcase AttachmentType.LinkedMesh: {\n\t\t\tlet path = input.readStringRef();\n\t\t\tlet color = input.readInt32();\n\t\t\tlet skinName = input.readStringRef();\n\t\t\tlet parent = input.readStringRef();\n\t\t\tlet inheritDeform = input.readBoolean();\n\t\t\tlet width = 0, height = 0;\n\t\t\tif (nonessential) {\n\t\t\t\twidth = input.readFloat();\n\t\t\t\theight = input.readFloat();\n\t\t\t}\n\n\t\t\tif (path == null) path = name;\n\t\t\tlet mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n\t\t\tif (mesh == null) return null;\n\t\t\tmesh.path = path;\n\t\t\tColor.rgba8888ToColor(mesh.color, color);\n\t\t\tif (nonessential) {\n\t\t\t\tmesh.width = width * scale;\n\t\t\t\tmesh.height = height * scale;\n\t\t\t}\n\t\t\tthis.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritDeform));\n\t\t\treturn mesh;\n\t\t}\n\t\tcase AttachmentType.Path: {\n\t\t\tlet closed = input.readBoolean();\n\t\t\tlet constantSpeed = input.readBoolean();\n\t\t\tlet vertexCount = input.readInt(true);\n\t\t\tlet vertices = this.readVertices(input, vertexCount);\n\t\t\tlet lengths = Utils.newArray(vertexCount / 3, 0);\n\t\t\tfor (let i = 0, n = lengths.length; i < n; i++)\n\t\t\t\tlengths[i] = input.readFloat() * scale;\n\t\t\tlet color = nonessential ? input.readInt32() : 0;\n\n\t\t\tlet path = this.attachmentLoader.newPathAttachment(skin, name);\n\t\t\tif (path == null) return null;\n\t\t\tpath.closed = closed;\n\t\t\tpath.constantSpeed = constantSpeed;\n\t\t\tpath.worldVerticesLength = vertexCount << 1;\n\t\t\tpath.vertices = vertices.vertices;\n\t\t\tpath.bones = vertices.bones;\n\t\t\tpath.lengths = lengths;\n\t\t\tif (nonessential) Color.rgba8888ToColor(path.color, color);\n\t\t\treturn path;\n\t\t}\n\t\tcase AttachmentType.Point: {\n\t\t\tlet rotation = input.readFloat();\n\t\t\tlet x = input.readFloat();\n\t\t\tlet y = input.readFloat();\n\t\t\tlet color = nonessential ? input.readInt32() : 0;\n\n\t\t\tlet point = this.attachmentLoader.newPointAttachment(skin, name);\n\t\t\tif (point == null) return null;\n\t\t\tpoint.x = x * scale;\n\t\t\tpoint.y = y * scale;\n\t\t\tpoint.rotation = rotation;\n\t\t\tif (nonessential) Color.rgba8888ToColor(point.color, color);\n\t\t\treturn point;\n\t\t}\n\t\tcase AttachmentType.Clipping: {\n\t\t\tlet endSlotIndex = input.readInt(true);\n\t\t\tlet vertexCount = input.readInt(true);\n\t\t\tlet vertices = this.readVertices(input, vertexCount);\n\t\t\tlet color = nonessential ? input.readInt32() : 0;\n\n\t\t\tlet clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\t\t\tif (clip == null) return null;\n\t\t\tclip.endSlot = skeletonData.slots[endSlotIndex];\n\t\t\tclip.worldVerticesLength = vertexCount << 1;\n\t\t\tclip.vertices = vertices.vertices;\n\t\t\tclip.bones = vertices.bones;\n\t\t\tif (nonessential) Color.rgba8888ToColor(clip.color, color);\n\t\t\treturn clip;\n\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate readVertices (input: BinaryInput, vertexCount: number): Vertices {\n\t\tlet verticesLength = vertexCount << 1;\n\t\tlet vertices = new Vertices();\n\t\tlet scale = this.scale;\n\t\tif (!input.readBoolean()) {\n\t\t\tvertices.vertices = this.readFloatArray(input, verticesLength, scale);\n\t\t\treturn vertices;\n\t\t}\n\t\tlet weights = new Array<number>();\n\t\tlet bonesArray = new Array<number>();\n\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\tlet boneCount = input.readInt(true);\n\t\t\tbonesArray.push(boneCount);\n\t\t\tfor (let ii = 0; ii < boneCount; ii++) {\n\t\t\t\tbonesArray.push(input.readInt(true));\n\t\t\t\tweights.push(input.readFloat() * scale);\n\t\t\t\tweights.push(input.readFloat() * scale);\n\t\t\t\tweights.push(input.readFloat());\n\t\t\t}\n\t\t}\n\t\tvertices.vertices = Utils.toFloatArray(weights);\n\t\tvertices.bones = bonesArray;\n\t\treturn vertices;\n\t}\n\n\tprivate readFloatArray (input: BinaryInput, n: number, scale: number): number[] {\n\t\tlet array = new Array<number>(n);\n\t\tif (scale == 1) {\n\t\t\tfor (let i = 0; i < n; i++)\n\t\t\t\tarray[i] = input.readFloat();\n\t\t} else {\n\t\t\tfor (let i = 0; i < n; i++)\n\t\t\t\tarray[i] = input.readFloat() * scale;\n\t\t}\n\t\treturn array;\n\t}\n\n\tprivate readShortArray (input: BinaryInput): number[] {\n\t\tlet n = input.readInt(true);\n\t\tlet array = new Array<number>(n);\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tarray[i] = input.readShort();\n\t\treturn array;\n\t}\n\n\tprivate readAnimation (input: BinaryInput, name: string, skeletonData: SkeletonData): Animation {\n\t\tlet timelines = new Array<Timeline>();\n\t\tlet scale = this.scale;\n\t\tlet duration = 0;\n\t\tlet tempColor1 = new Color();\n\t\tlet tempColor2 = new Color();\n\n\t\t// Slot timelines.\n\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\tlet slotIndex = input.readInt(true);\n\t\t\tfor (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n\t\t\t\tlet timelineType = input.readByte();\n\t\t\t\tlet frameCount = input.readInt(true);\n\t\t\t\tswitch (timelineType) {\n\t\t\t\tcase SkeletonBinary.SLOT_ATTACHMENT: {\n\t\t\t\t\tlet timeline = new AttachmentTimeline(frameCount);\n\t\t\t\t\ttimeline.slotIndex = slotIndex;\n\t\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++)\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());\n\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[frameCount - 1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase SkeletonBinary.SLOT_COLOR: {\n\t\t\t\t\tlet timeline = new ColorTimeline(frameCount);\n\t\t\t\t\ttimeline.slotIndex = slotIndex;\n\t\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\t\t\tlet time = input.readFloat();\n\t\t\t\t\t\tColor.rgba8888ToColor(tempColor1, input.readInt32());\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);\n\t\t\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n\t\t\t\t\t}\n\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * ColorTimeline.ENTRIES]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase SkeletonBinary.SLOT_TWO_COLOR: {\n\t\t\t\t\tlet timeline = new TwoColorTimeline(frameCount);\n\t\t\t\t\ttimeline.slotIndex = slotIndex;\n\t\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\t\t\tlet time = input.readFloat();\n\t\t\t\t\t\tColor.rgba8888ToColor(tempColor1, input.readInt32());\n\t\t\t\t\t\tColor.rgb888ToColor(tempColor2, input.readInt32());\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r,\n\t\t\t\t\t\t\ttempColor2.g, tempColor2.b);\n\t\t\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n\t\t\t\t\t}\n\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * TwoColorTimeline.ENTRIES]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Bone timelines.\n\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\tlet boneIndex = input.readInt(true);\n\t\t\tfor (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n\t\t\t\tlet timelineType = input.readByte();\n\t\t\t\tlet frameCount = input.readInt(true);\n\t\t\t\tswitch (timelineType) {\n\t\t\t\tcase SkeletonBinary.BONE_ROTATE: {\n\t\t\t\t\tlet timeline = new RotateTimeline(frameCount);\n\t\t\t\t\ttimeline.boneIndex = boneIndex;\n\t\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat());\n\t\t\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n\t\t\t\t\t}\n\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * RotateTimeline.ENTRIES]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase SkeletonBinary.BONE_TRANSLATE:\n\t\t\t\tcase SkeletonBinary.BONE_SCALE:\n\t\t\t\tcase SkeletonBinary.BONE_SHEAR: {\n\t\t\t\t\tlet timeline;\n\t\t\t\t\tlet timelineScale = 1;\n\t\t\t\t\tif (timelineType == SkeletonBinary.BONE_SCALE)\n\t\t\t\t\t\ttimeline = new ScaleTimeline(frameCount);\n\t\t\t\t\telse if (timelineType == SkeletonBinary.BONE_SHEAR)\n\t\t\t\t\t\ttimeline = new ShearTimeline(frameCount);\n\t\t\t\t\telse {\n\t\t\t\t\t\ttimeline = new TranslateTimeline(frameCount);\n\t\t\t\t\t\ttimelineScale = scale;\n\t\t\t\t\t}\n\t\t\t\t\ttimeline.boneIndex = boneIndex;\n\t\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale,\n\t\t\t\t\t\t\tinput.readFloat() * timelineScale);\n\t\t\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n\t\t\t\t\t}\n\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * TranslateTimeline.ENTRIES]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// IK constraint timelines.\n\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\tlet index = input.readInt(true);\n\t\t\tlet frameCount = input.readInt(true);\n\t\t\tlet timeline = new IkConstraintTimeline(frameCount);\n\t\t\ttimeline.ikConstraintIndex = index;\n\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(),\n\t\t\t\t\tinput.readBoolean());\n\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n\t\t\t}\n\t\t\ttimelines.push(timeline);\n\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * IkConstraintTimeline.ENTRIES]);\n\t\t}\n\n\t\t// Transform constraint timelines.\n\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\tlet index = input.readInt(true);\n\t\t\tlet frameCount = input.readInt(true);\n\t\t\tlet timeline = new TransformConstraintTimeline(frameCount);\n\t\t\ttimeline.transformConstraintIndex = index;\n\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(),\n\t\t\t\t\tinput.readFloat());\n\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n\t\t\t}\n\t\t\ttimelines.push(timeline);\n\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * TransformConstraintTimeline.ENTRIES]);\n\t\t}\n\n\t\t// Path constraint timelines.\n\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\tlet index = input.readInt(true);\n\t\t\tlet data = skeletonData.pathConstraints[index];\n\t\t\tfor (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n\t\t\t\tlet timelineType = input.readByte();\n\t\t\t\tlet frameCount = input.readInt(true);\n\t\t\t\tswitch (timelineType) {\n\t\t\t\tcase SkeletonBinary.PATH_POSITION:\n\t\t\t\tcase SkeletonBinary.PATH_SPACING: {\n\t\t\t\t\tlet timeline;\n\t\t\t\t\tlet timelineScale = 1;\n\t\t\t\t\tif (timelineType == SkeletonBinary.PATH_SPACING) {\n\t\t\t\t\t\ttimeline = new PathConstraintSpacingTimeline(frameCount);\n\t\t\t\t\t\tif (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttimeline = new PathConstraintPositionTimeline(frameCount);\n\t\t\t\t\t\tif (data.positionMode == PositionMode.Fixed) timelineScale = scale;\n\t\t\t\t\t}\n\t\t\t\t\ttimeline.pathConstraintIndex = index;\n\t\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);\n\t\t\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n\t\t\t\t\t}\n\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintPositionTimeline.ENTRIES]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase SkeletonBinary.PATH_MIX: {\n\t\t\t\t\tlet timeline = new PathConstraintMixTimeline(frameCount);\n\t\t\t\t\ttimeline.pathConstraintIndex = index;\n\t\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());\n\t\t\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n\t\t\t\t\t}\n\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintMixTimeline.ENTRIES]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Deform timelines.\n\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\tlet skin = skeletonData.skins[input.readInt(true)];\n\t\t\tfor (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n\t\t\t\tlet slotIndex = input.readInt(true);\n\t\t\t\tfor (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\n\t\t\t\t\tlet attachment = skin.getAttachment(slotIndex, input.readStringRef()) as VertexAttachment;\n\t\t\t\t\tlet weighted = attachment.bones != null;\n\t\t\t\t\tlet vertices = attachment.vertices;\n\t\t\t\t\tlet deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n\n\t\t\t\t\tlet frameCount = input.readInt(true);\n\t\t\t\t\tlet timeline = new DeformTimeline(frameCount);\n\t\t\t\t\ttimeline.slotIndex = slotIndex;\n\t\t\t\t\ttimeline.attachment = attachment;\n\n\t\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\t\t\tlet time = input.readFloat();\n\t\t\t\t\t\tlet deform;\n\t\t\t\t\t\tlet end = input.readInt(true);\n\t\t\t\t\t\tif (end == 0)\n\t\t\t\t\t\t\tdeform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdeform = Utils.newFloatArray(deformLength);\n\t\t\t\t\t\t\tlet start = input.readInt(true);\n\t\t\t\t\t\t\tend += start;\n\t\t\t\t\t\t\tif (scale == 1) {\n\t\t\t\t\t\t\t\tfor (let v = start; v < end; v++)\n\t\t\t\t\t\t\t\t\tdeform[v] = input.readFloat();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (let v = start; v < end; v++)\n\t\t\t\t\t\t\t\t\tdeform[v] = input.readFloat() * scale;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!weighted) {\n\t\t\t\t\t\t\t\tfor (let v = 0, vn = deform.length; v < vn; v++)\n\t\t\t\t\t\t\t\t\tdeform[v] += vertices[v];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, time, deform);\n\t\t\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n\t\t\t\t\t}\n\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[frameCount - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Draw order timeline.\n\t\tlet drawOrderCount = input.readInt(true);\n\t\tif (drawOrderCount > 0) {\n\t\t\tlet timeline = new DrawOrderTimeline(drawOrderCount);\n\t\t\tlet slotCount = skeletonData.slots.length;\n\t\t\tfor (let i = 0; i < drawOrderCount; i++) {\n\t\t\t\tlet time = input.readFloat();\n\t\t\t\tlet offsetCount = input.readInt(true);\n\t\t\t\tlet drawOrder = Utils.newArray(slotCount, 0);\n\t\t\t\tfor (let ii = slotCount - 1; ii >= 0; ii--)\n\t\t\t\t\tdrawOrder[ii] = -1;\n\t\t\t\tlet unchanged = Utils.newArray(slotCount - offsetCount, 0);\n\t\t\t\tlet originalIndex = 0, unchangedIndex = 0;\n\t\t\t\tfor (let ii = 0; ii < offsetCount; ii++) {\n\t\t\t\t\tlet slotIndex = input.readInt(true);\n\t\t\t\t\t// Collect unchanged items.\n\t\t\t\t\twhile (originalIndex != slotIndex)\n\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\n\t\t\t\t\t// Set changed items.\n\t\t\t\t\tdrawOrder[originalIndex + input.readInt(true)] = originalIndex++;\n\t\t\t\t}\n\t\t\t\t// Collect remaining unchanged items.\n\t\t\t\twhile (originalIndex < slotCount)\n\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\n\t\t\t\t// Fill in unchanged items.\n\t\t\t\tfor (let ii = slotCount - 1; ii >= 0; ii--)\n\t\t\t\t\tif (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n\t\t\t\ttimeline.setFrame(i, time, drawOrder);\n\t\t\t}\n\t\t\ttimelines.push(timeline);\n\t\t\tduration = Math.max(duration, timeline.frames[drawOrderCount - 1]);\n\t\t}\n\n\t\t// Event timeline.\n\t\tlet eventCount = input.readInt(true);\n\t\tif (eventCount > 0) {\n\t\t\tlet timeline = new EventTimeline(eventCount);\n\t\t\tfor (let i = 0; i < eventCount; i++) {\n\t\t\t\tlet time = input.readFloat();\n\t\t\t\tlet eventData = skeletonData.events[input.readInt(true)];\n\t\t\t\tlet event = new Event(time, eventData);\n\t\t\t\tevent.intValue = input.readInt(false);\n\t\t\t\tevent.floatValue = input.readFloat();\n\t\t\t\tevent.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\n\t\t\t\tif (event.data.audioPath != null) {\n\t\t\t\t\tevent.volume = input.readFloat();\n\t\t\t\t\tevent.balance = input.readFloat();\n\t\t\t\t}\n\t\t\t\ttimeline.setFrame(i, event);\n\t\t\t}\n\t\t\ttimelines.push(timeline);\n\t\t\tduration = Math.max(duration, timeline.frames[eventCount - 1]);\n\t\t}\n\n\t\treturn new Animation(name, timelines, duration);\n\t}\n\n\tprivate readCurve (input: BinaryInput, frameIndex: number, timeline: CurveTimeline) {\n\t\tswitch (input.readByte()) {\n\t\tcase SkeletonBinary.CURVE_STEPPED:\n\t\t\ttimeline.setStepped(frameIndex);\n\t\t\tbreak;\n\t\tcase SkeletonBinary.CURVE_BEZIER:\n\t\t\tthis.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsetCurve (timeline: CurveTimeline, frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\n\t\ttimeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);\n\t}\n}\n\nclass BinaryInput {\n\tconstructor(data: Uint8Array, public strings = new Array<string>(), private index: number = 0, private buffer = new DataView(data.buffer)) { \n\n\t}\n\n\treadByte(): number {\n\t\treturn this.buffer.getInt8(this.index++);\n\t}\n\n\treadShort(): number {\n\t\tlet value = this.buffer.getInt16(this.index);\n\t\tthis.index += 2;\n\t\treturn value;\n\t}\n\n\treadInt32(): number {\n\t\t\tlet value = this.buffer.getInt32(this.index)\n\t\t\tthis.index += 4;\n\t\t\treturn value;\n\t}\n\n\treadInt(optimizePositive: boolean) {\n\t\tlet b = this.readByte();\n\t\tlet result = b & 0x7F;\n\t\tif ((b & 0x80) != 0) {\n\t\t\tb = this.readByte();\n\t\t\tresult |= (b & 0x7F) << 7;\n\t\t\tif ((b & 0x80) != 0) {\n\t\t\t\tb = this.readByte();\n\t\t\t\tresult |= (b & 0x7F) << 14;\n\t\t\t\tif ((b & 0x80) != 0) {\n\t\t\t\t\tb = this.readByte();\n\t\t\t\t\tresult |= (b & 0x7F) << 21;\n\t\t\t\t\tif ((b & 0x80) != 0) {\n\t\t\t\t\t\tb = this.readByte();\n\t\t\t\t\t\tresult |= (b & 0x7F) << 28;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn optimizePositive ? result : ((result >>> 1) ^ -(result & 1));\n\t}\n\n\treadStringRef (): string {\n\t\tlet index = this.readInt(true);\n\t\treturn index == 0 ? null : this.strings[index - 1];\n\t}\n\n\treadString (): string {\n\t\tlet byteCount = this.readInt(true);\n\t\tswitch (byteCount) {\n\t\tcase 0:\n\t\t\treturn null;\n\t\tcase 1:\n\t\t\treturn \"\";\n\t\t}\n\t\tbyteCount--;\n\t\tlet chars = \"\";\n\t\tlet charCount = 0;\n\t\tfor (let i = 0; i < byteCount;) {\n\t\t\tlet b = this.readByte();\n\t\t\tswitch (b >> 4) {\n\t\t\tcase 12:\n\t\t\tcase 13:\n\t\t\t\tchars += String.fromCharCode(((b & 0x1F) << 6 | this.readByte() & 0x3F));\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tcase 14:\n\t\t\t\tchars += String.fromCharCode(((b & 0x0F) << 12 | (this.readByte() & 0x3F) << 6 | this.readByte() & 0x3F));\n\t\t\t\ti += 3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tchars += String.fromCharCode(b);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn chars;\n\t}\n\n\treadFloat (): number {\n\t\tlet value = this.buffer.getFloat32(this.index);\n\t\tthis.index += 4;\n\t\treturn value;\n\t}\n\n\treadBoolean (): boolean {\n\t\treturn this.readByte() != 0;\n\t}\n}\n\nclass LinkedMesh {\n\tparent: string; skin: string;\n\tslotIndex: number;\n\tmesh: MeshAttachment;\n\tinheritDeform: boolean;\n\n\tconstructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\n\t\tthis.mesh = mesh;\n\t\tthis.skin = skin;\n\t\tthis.slotIndex = slotIndex;\n\t\tthis.parent = parent;\n\t\tthis.inheritDeform = inheritDeform;\n\t}\n}\n\nclass Vertices {\n\tconstructor(public bones: Array<number> = null, public vertices: Array<number> | Float32Array = null) { }\n}","import {\n  AssetPromise,\n  Loader,\n  LoadItem,\n  resourceLoader,\n  ResourceManager,\n  TextureFilterMode,\n  TextureWrapMode,\n  Texture2D,\n  Engine,\n  Entity,\n  MeshRenderer\n} from 'oasis-engine';\nimport { AssetManager } from './spine-core/AssetManager';\nimport { TextureAtlas } from './spine-core/TextureAtlas';\nimport { Texture } from './spine-core/Texture';\nimport { AtlasAttachmentLoader } from './spine-core/AtlasAttachmentLoader';\nimport { SkeletonJson } from './spine-core/SkeletonJson';\nimport { SkeletonBinary } from './spine-core/SkeletonBinary';\nimport { SpineAnimation } from './SpineAnimation';\n\ntype SpineResouce = {\n  skeletonFile: string\n  atlasFile: string\n  textureFile?: string\n}\n\ntype SpineOpt = {\n  scale: number;\n}\n\ntype SpineLoadItem = LoadItem & SpineOpt;\n\n// @ts-ignore\n@resourceLoader('spine', ['json', 'bin'])\nclass SpineLoader extends Loader<Entity> {\n  load(item: SpineLoadItem, resourceManager: ResourceManager): AssetPromise<Entity> {\n    return new AssetPromise((resolve, reject) => {\n      // @ts-ignore\n      if (item.type !== 'spine') {\n        reject('Asset type must be spine.');\n      }\n\n      let resource: SpineResouce;\n\n      if (!item.urls && item.url && this.checkUrl(item.url)) {\n        resource = this.getResouceFromUrl(item.url);\n      }\n\n      if (item.urls && this.checkUrls(item.urls)) {\n        resource = this.getResouceFromUrls(item.urls);\n      }\n      \n      let autoLoadTexture: boolean = false;\n      let assetManager: AssetManager;\n      let skeletonLoader: SkeletonJson | SkeletonBinary;\n      assetManager = new AssetManager((data) => {\n        return new AdaptiveTexture(data, resourceManager.engine);\n      });\n      const { skeletonFile, atlasFile, textureFile } = resource;\n      if (skeletonFile && atlasFile && textureFile) {\n        assetManager.loadText(skeletonFile);\n        assetManager.loadText(atlasFile);\n        assetManager.loadTexture(textureFile);\n      } else if (skeletonFile && atlasFile && !textureFile) {\n        autoLoadTexture = true;\n        assetManager.loadText(skeletonFile);\n        assetManager.loadTextureAtlas(atlasFile);\n      } else {\n        reject('Resouce param error');\n      }\n\n      this.onLoad(assetManager).then((loadRes) => {\n        if (loadRes !== 'loaded') {\n          reject(loadRes);\n        }\n        let atlas: TextureAtlas;\n        if (autoLoadTexture) {\n          atlas = assetManager.get(atlasFile);\n        } else {\n          atlas = new TextureAtlas(assetManager.get(atlasFile), function () {\n            return assetManager.get(textureFile);\n          });\n        }\n\n        const atlasLoader = new AtlasAttachmentLoader(atlas);\n        if (this.isBinFile(skeletonFile)) {\n          skeletonLoader = new SkeletonBinary(atlasLoader);\n        } else {\n          skeletonLoader = new SkeletonJson(atlasLoader);\n        }\n        const skeletonData = skeletonLoader.readSkeletonData(assetManager.get(skeletonFile));\n        const { engine } = resourceManager;\n        const entity = new Entity(engine);\n        const meshRenderer = entity.addComponent(MeshRenderer);\n        meshRenderer.shaderData.enableMacro('USE_MODEL_MATRIX');\n        meshRenderer.shaderData.enableMacro('USE_CUSTOM_TEXTURE');\n        const mtl = resourceManager.engine._spriteDefaultMaterial.clone();\n        meshRenderer.setMaterial(mtl);\n        const spineAnimation = entity.addComponent(SpineAnimation);\n        spineAnimation.setSkeletonData(skeletonData);\n        resolve(entity);\n      })\n    });\n  }\n\n  isBinFile(url: string): boolean {\n    const ext = this.getExtFromUrl(url);\n    return ext === 'bin';\n  }\n\n  checkUrl(url: string): boolean {\n    const ext = this.getExtFromUrl(url);\n    if (ext === 'json' || ext === 'bin') {\n      return true\n    }\n    console.error('When use url as params, url must be json or bin file');\n    return false;\n  }\n\n  getResouceFromUrl(url): SpineResouce {\n    const skeletonFile = url;\n    const atlasSuffix = '.atlas';\n    let atlasFile = url;\n    let queryStringPos = atlasFile.indexOf('?');\n    if (queryStringPos > 0) {\n      atlasFile = atlasFile.substr(0, queryStringPos);\n    }\n    atlasFile = atlasFile.substr(0, atlasFile.lastIndexOf('.')) + atlasSuffix;\n    return { skeletonFile, atlasFile };\n  }\n\n  checkUrls(urls: string[]): boolean {\n    if (urls.length < 2) {\n      console.error('When use urls as params, urls should at least contain: json/bin and atlas');\n      return false;\n    }\n    if (urls.length > 3) {\n      console.error('Spine runtime dont support multiple texture now');\n      return false;\n    }\n    \n    const { skeletonFile, atlasFile, textureFile } = this.getResouceFromUrls(urls);\n    if (skeletonFile &&  atlasFile) {\n      return true;\n    }\n    console.error(`Lack ${skeletonFile ? '' : 'skeletonFile'}${!atlasFile ? '' : ' atlasFile'}`);\n    return false;\n  }\n\n  getResouceFromUrls(urls: string[]): SpineResouce {\n    let skeletonFile: string;\n    let atlasFile: string;\n    let textureFile: string;\n    for (let i = 0; i < urls.length; i += 1) {\n      const url = urls[i];\n      const ext = this.getExtFromUrl(url);\n      if (ext === 'json' || ext === 'bin') {\n        skeletonFile = url;\n      }\n      if (ext === 'atlas') {\n        atlasFile = url;\n      }\n      const imgMap = ['png', 'jpg', 'webp', 'jpeg'];\n      if (imgMap.includes(ext)) {\n        textureFile = url;\n      }\n    }\n    return {\n      skeletonFile,\n      atlasFile,\n      textureFile\n    };\n  }\n\n  getExtFromUrl(url: string): string {\n    return url.split(/[#?]/)[0].split('.').pop().trim();\n  }\n\n  onLoad(loader: AssetManager): Promise<any> {\n    return new Promise((res, rej) => {\n      setInterval(() => {\n        if (loader.isLoadingComplete()) {\n          if (loader.hasErrors()) {\n            rej(loader.getErrors());\n          } else {\n            res('loaded');\n          }\n        }\n      }, 100);\n    })\n  }\n  \n\n}\n\nexport class AdaptiveTexture extends Texture {\n  texture: Texture2D;\n\n  constructor(data: HTMLImageElement, engine: Engine) {\n    super(data);\n    this.texture = new Texture2D(engine, data.width, data.height);\n    this.texture.setImageSource(data);\n    this.texture.generateMipmaps();\n  }\n\n  setFilters(minFilter: any, magFilter: any) {\n    if (minFilter === WebGLRenderingContext.NEAREST) {\n      this.texture.filterMode = TextureFilterMode.Point;\n    } else if (magFilter === WebGLRenderingContext.LINEAR_MIPMAP_LINEAR) {\n      this.texture.filterMode = TextureFilterMode.Trilinear;\n    } else {\n      this.texture.filterMode = TextureFilterMode.Bilinear;\n    }\n  }\n\n  // @ts-ignore\n  setWraps(uWrap: TextureWrapMode, vWrap: TextureWrapMode) {\n    this.texture.wrapModeU = uWrap;\n    this.texture.wrapModeV = vWrap;\n  }\n\n  dispose() {}\n}\n\n\n\nexport { SpineLoader };\n","import { Parser, registerResource } from 'oasis-engine';\nimport { SpineComponent } from './SpineComponent';\nimport { SpineResource } from './SpineResource';\nimport '../SpineLoader';\n\nParser.registerComponents('o3', {\n  SpineComponent,\n});\n\nregisterResource('spine', SpineResource);\n\nexport { SpineComponent } from './SpineComponent';\nexport { SpineResource } from './SpineResource';\n"],"names":["IntSet","array","Array","value","contains","this","undefined","length","Color","r","g","b","a","clamp","c","hex","charAt","substr","parseInt","color","WHITE","RED","GREEN","BLUE","MAGENTA","MathUtils","min","max","degrees","Math","cos","degRad","sin","x","floor","ceil","y","pow","abs","randomTriangularWith","mode","u","random","d","sqrt","PI","PI2","radiansToDegrees","radDeg","degreesToRadians","Utils","source","sourceStart","dest","destStart","numElements","i","j","size","oldSize","setArraySize","defaultValue","SUPPORTS_TYPED_ARRAYS","Float32Array","Int16Array","fround","alpha","blend","element","TransformMode","Pool","instantiator","items","pop","item","reset","push","free","Vector2","len","BoneData","index","name","parent","rotation","scaleX","scaleY","shearX","shearY","transformMode","Normal","skinRequired","Error","PositionMode","SpacingMode","RotateMode","Bone","data","skeleton","children","ax","ay","arotation","ascaleX","ascaleY","ashearX","ashearY","appliedValid","worldY","worldX","sorted","active","setToSetupPose","updateWorldTransformWith","rotationY","sx","sy","cosDeg","sinDeg","pa","pb","pc","pd","la","lb","lc","ld","OnlyTranslation","NoRotationOrReflection","s","prx","atan2","rx","ry","NoScale","NoScaleOrReflection","za","zc","zb","zd","pid","dx","dy","ia","id","ib","ic","ra","rb","rc","rd","det","world","invDet","local","worldRotation","localRotation","Slot","bone","darkColor","attachment","attachmentTime","attachmentState","deform","time","setFromColor","attachmentName","setAttachment","getAttachment","IkConstraint","bones","target","bendDirection","compress","stretch","mix","softness","findBone","update","apply1","uniform","apply2","targetX","targetY","updateAppliedTransform","p","rotationIK","tx","ty","sa","sc","dd","child","bendDir","px","py","psx","psy","csx","os1","os2","s2","cx","cy","cwx","cwy","pp","a1","a2","l1","l2","td","sd","outer","acos","aa","bb","ta","c1","c2","q","r0","r1","minAngle","minX","minDist","minY","maxAngle","maxX","maxDist","maxY","os","updateWorldTransform","TransformConstraint","rotateMix","translateMix","scaleMix","shearMix","temp","relative","applyRelativeLocal","applyAbsoluteLocal","applyRelativeWorld","applyAbsoluteWorld","tb","tc","degRadReflect","offsetRotation","offsetShearY","n","modified","localToWorld","set","offsetX","offsetY","ts","offsetScaleX","offsetScaleY","by","ConstraintData","order","PathConstraintData","positionMode","spacingMode","rotateMode","position","spacing","Attachment","VertexAttachment","nextID","vertices","worldVerticesLength","deformAttachment","slot","start","count","worldVertices","offset","stride","deformArray","v","skip","skeletonBones","w","wx","wy","vx","vy","weight","f","arrayCopy","newFloatArray","PathAttachment","lengths","closed","constantSpeed","copy","copyTo","PathConstraint","spaces","positions","curves","segments","findSlot","rotate","percentSpacing","Percent","tangents","Tangent","scale","ChainScale","boneCount","spacesCount","lengthSpacing","Length","setupLength","epsilon","computeWorldPositions","boneX","boneY","tip","Chain","path","percentPosition","out","verticesLength","curveCount","prevCurve","NONE","pathLength","o","curve","space","BEFORE","computeWorldVertices","addBeforePosition","AFTER","addAfterPosition","prev","addCurvePosition","x1","y1","cx1","cy1","cx2","cy2","x2","y2","tmpx","tmpy","dddfx","dddfy","ddfx","ddfy","dfx","dfy","curveLength","segment","ii","isNaN","tt","ttt","uu","uuu","ut","ut3","uut3","utt3","RegionAttachment","width","height","rendererObject","region","uvs","tempColor","regionScaleX","originalWidth","regionScaleY","originalHeight","localX","localY","localX2","localY2","radians","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","OX1","OY1","OX2","OY2","OX3","OY3","OX4","OY4","v2","u2","vertexOffset","X1","Y1","C1R","C1G","C1B","C1A","U1","V1","X2","Y2","C2R","C2G","C2B","C2A","U2","V2","X3","Y3","C3R","C3G","C3B","C3A","U3","V3","X4","Y4","C4R","C4G","C4B","C4A","U4","V4","TextureFilter","TextureWrap","Texture","image","_image","text","toLowerCase","Nearest","Linear","MipMap","MipMapNearestNearest","MipMapLinearNearest","MipMapNearestLinear","MipMapLinearLinear","MirroredRepeat","ClampToEdge","Repeat","MixBlend","MixDirection","TimelineType","TextureRegion","renderObject","FakeTexture","minFilter","magFilter","uWrap","vWrap","TextureAtlas","atlasText","textureLoader","pages","regions","load","reader","TextureAtlasReader","tuple","page","line","readLine","trim","TextureAtlasRegion","rotateValue","readValue","toLocaleLowerCase","parseFloat","readTuple","texture","TextureAtlasPage","filterFromString","direction","setFilters","setWraps","getImage","dispose","lines","split","colon","indexOf","substring","lastMatch","comma","MeshAttachment","regionUVs","triangles","hullLength","edges","parentMesh","textureWidth","textureHeight","newLinkedMesh","setParentMesh","updateUVs","Skeleton","slots","drawOrder","ikConstraints","transformConstraints","pathConstraints","_updateCache","updateCacheReset","skin","boneData","slotData","ikConstraintData","transformConstraintData","pathConstraintData","updateCache","skinBones","ikCount","transformCount","pathCount","constraintCount","constraint","sortIkConstraint","sortTransformConstraint","sortPathConstraint","sortBone","isActive","constraints","constrained","sortReset","slotIndex","slotBone","sortPathConstraintAttachment","defaultSkin","skins","sortPathConstraintAttachmentWith","attachments","key","pathBones","boneIndex","setBonesToSetupPose","setSlotsToSetupPose","boneName","slotName","skinName","findSkin","setSkin","newSkin","attachAll","findSlotIndex","constraintName","ikConstraint","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","mesh","nn","delta","Animation","timelines","duration","timelineIds","getPropertyId","lastTime","loop","events","apply","values","step","low","high","current","last","CurveTimeline","frameCount","BEZIER_SIZE","frameIndex","LINEAR","STEPPED","type","BEZIER","percent","prevX","prevY","RotateTimeline","frames","ROTATION","setup","first","ENTRIES","PREV_ROTATION","replace","add","frame","binarySearch","prevRotation","frameTime","getCurvePercent","PREV_TIME","TranslateTimeline","translate","X","Y","PREV_X","PREV_Y","ScaleTimeline","bx","mixOut","signum","ShearTimeline","shear","ColorTimeline","R","G","B","A","PREV_R","PREV_G","PREV_B","PREV_A","TwoColorTimeline","twoColor","r2","g2","b2","R2","G2","B2","light","dark","setupLight","setupDark","PREV_R2","PREV_G2","PREV_B2","AttachmentTimeline","attachmentNames","zeros","DeformTimeline","frameVertices","firedEvents","slotAttachment","vertexCount","vertexAttachment","setupVertices","lastVertices","prevVertices","nextVertices","EventTimeline","event","MAX_VALUE","DrawOrderTimeline","drawOrders","drawOrderToSetupIndex","IkConstraintTimeline","ikConstraintIndex","MIX","SOFTNESS","BEND_DIRECTION","COMPRESS","STRETCH","PREV_MIX","PREV_SOFTNESS","PREV_BEND_DIRECTION","PREV_COMPRESS","PREV_STRETCH","mixIn","TransformConstraintTimeline","transformConstraintIndex","transformConstraint","ROTATE","TRANSLATE","SCALE","SHEAR","PREV_ROTATE","PREV_TRANSLATE","PREV_SCALE","PREV_SHEAR","PathConstraintPositionTimeline","pathConstraintIndex","pathConstraintPosition","VALUE","PREV_VALUE","PathConstraintSpacingTimeline","pathConstraintSpacing","PathConstraintMixTimeline","pathConstraintMix","AnimationState","tracks","timeScale","unkeyedState","listeners","queue","EventQueue","propertyIDs","animationsChanged","trackEntryPool","TrackEntry","animationLast","nextAnimationLast","trackLast","nextTrackLast","currentDelta","delay","next","nextTime","trackTime","setCurrent","mixingFrom","mixTime","trackEnd","end","disposeNext","updateMixingFrom","from","mixingTo","drain","to","finished","mixDuration","totalAlpha","interruptAlpha","_animationsChanged","applied","mixBlend","applyMixingFrom","animationTime","getAnimationTime","timelineCount","animation","webkit602BugfixHelper","timeline","applyAttachmentTimeline","timelineMode","firstFrame","timelinesRotation","timelineBlend","SUBSEQUENT","applyRotateTimeline","queueEvents","setupState","SETUP","eventThreshold","attachmentThreshold","drawOrderThreshold","alphaHold","alphaMix","timelineHoldMix","FIRST","HOLD_SUBSEQUENT","HOLD_FIRST","holdMix","CURRENT","rotateTimeline","total","diff","lastTotal","lastDiff","dir","entry","animationStart","animationEnd","trackLastWrapped","complete","oldDrainDisabled","drainDisabled","clearTrack","trackIndex","interrupt","expandToIndex","animationName","skeletonData","findAnimation","setAnimationWith","trackEntry","addAnimationWith","getMix","emptyAnimation","setEmptyAnimation","ensureArrayCapacity","obtain","holdPrevious","clear","computeHold","timelinesCount","timelineDipMix","hasTimeline","HOLD_MIX","listener","splice","EventType","animState","objects","AnimationStateData","animationToMixTime","defaultMix","fromName","toName","setMixWith","ClippingAttachment","endSlot","Triangulator","convexPolygons","convexPolygonsIndices","indicesArray","isConcaveArray","polygonPool","polygonIndicesPool","verticesArray","indices","isConcave","previous","p1","p2","p3","p1x","p1y","p2x","p2y","p3x","p3y","positiveArea","previousIndex","nextIndex","freeAll","polygonIndices","polygon","fanBaseIndex","lastWinding","t1","t2","t3","x3","y3","merged","winding1","winding","winding2","firstIndex","lastIndex","prevPrevX","prevPrevY","firstX","firstY","secondX","secondY","otherIndices","otherFirstIndex","otherSecondIndex","otherLastIndex","otherPoly","SkeletonClipping","triangulator","clippingPolygon","clipOutput","clippedVertices","clippedTriangles","scratch","clipAttachment","clippingPolygons","clip","makeClockwise","decompose","triangulate","clipEnd","trianglesLength","polygons","polygonsCount","vertexSize","u1","v1","u3","v3","clippedVerticesItems","clippedTrianglesItems","clipOutputLength","d0","d1","d2","d4","clipOutputCount","clipOutputItems","c0","clippingArea","output","originalOutput","clipped","input","clippingVertices","clippingVerticesLast","edgeX","edgeY","edgeX2","edgeY2","deltaX","deltaY","inputVertices","inputVerticesLength","outputStart","inputX","inputY","inputX2","inputY2","side2","ua","verticeslength","area","lastX","other","SpineMesh","_mesh","_indexBuffer","_vertexBuffer","engine","BufferMesh","vertexElements","VertexElement","VertexElementFormat","Vector3","Vector4","vertexStride","MeshGenerator","VERTEX_STRIDE","byteLength","vertexBuffer","Buffer","BufferBindFlag","VertexBuffer","BufferUsage","Dynamic","indexBuffer","IndexBuffer","setVertexBufferBinding","setIndexBufferBinding","IndexFormat","UInt16","setVertexElements","addSubMesh","entity","_setting","_engine","_entity","_clipper","_spineMesh","_vertexCount","_vertices","_verticesWithZ","_indices","_needResize","_meshRenderer","_subMeshItems","separateSlots","setting","meshRenderer","getComponent","MeshRenderer","QUAD_TRIANGLE_LENGTH","QUAD_TRIANGLES","_prepareBufferData","initialize","console","warn","useClipping","zSpacing","indicesLength","maxSlotCount","subMeshItems","attachmentColor","z","numFloats","isClipping","VERTEX_SIZE","regionAttachment","meshAttachment","clipStart","clipEndWithSlot","finalVertices","finalVerticesLength","finalIndices","finalIndicesLength","skeletonColor","slotColor","clipTriangles","verts","indexStart","verticesWithZ","includes","subMesh","SubMesh","prevSubMesh","materials","getMaterials","materialLength","mtl","shaderData","getTexture","setTexture","sort","clearSubMesh","subMeshItemLength","resize","setData","Uint16Array","BlendMode","SpineAnimation","Script","autoUpdate","_meshGenerator","_this","_skeletonData","_skeleton","_state","error","animationData","addSeparateSlot","mtl1","_spriteDefaultMaterial","clone","mtl2","materialCount","setMaterial","buildMesh","subMeshIndex","findIndex","getMaterial","updateState","deltaTime","state","updateGeometry","setSkeletonData","_cloneSetting","ignoreClone","SpineComponent","_autoPlay","_scale","_animationName","_resource","spineEntity","spineAnimation","addChild","autoPlay","setAnimation","onStart","SpineResource","SchemaResource","resourceManager","assetConfig","spineAssets","props","urls","keys","Object","url","then","AssetManager","pathPrefix","assets","errors","toLoad","loaded","rawDataUris","success","request","XMLHttpRequest","overrideMimeType","open","onload","status","responseText","onerror","send","responseType","Uint8Array","response","downloadBinary","downloadText","_this2","storagePath","img","Image","crossOrigin","ev","_this3","src","lastIndexOf","atlasData","pagesLoaded","atlasPages","document","createElement","e","ex","_this4","message","atlasPage","pageLoadError","loadTexture","imagePath","atlas","get","errorMessage","asset","removeAll","BoundingBoxAttachment","PointAttachment","point","AtlasAttachmentLoader","findRegion","setRegion","SkeletonData","animations","version","hash","fps","imagesPath","audioPath","eventDataName","pathConstraintName","SlotData","blendMode","IkConstraintData","TransformConstraintData","SkinEntry","Skin","contained","getAttachments","dictionary","entries","slotAttachments","oldSkin","EventData","intValue","floatValue","stringValue","volume","balance","AttachmentType","Event","SkeletonJson","attachmentLoader","linkedMeshes","json","root","JSON","parse","skeletonMap","spine","images","boneMap","parentName","getValue","transformModeFromString","slotMap","setFromString","blendModeFromString","ik","constraintMap","targetName","transform","positionModeFromString","spacingModeFromString","rotateModeFromString","Fixed","skinMap","findIkConstraint","findTransformConstraint","findPathConstraint","entryName","readAttachment","linkedMesh","inheritDeform","eventName","eventMap","animationMap","readAnimation","map","newRegionAttachment","updateOffset","box","newBoundingBoxAttachment","readVertices","newMeshAttachment","LinkedMesh","newPathAttachment","newArray","newPointAttachment","newClippingAttachment","weights","toFloatArray","scaledVertices","timelineName","timelineMap","valueMap","setFrame","getFrameCount","readCurve","findBoneIndex","timelineScale","findPathConstraintIndex","deformName","deformMap","weighted","deformLength","verticesValue","drawOrderNode","draworder","slotCount","drawOrderMap","offsets","unchanged","originalIndex","unchangedIndex","offsetMap","eventData","findEvent","toSinglePrecision","hasOwnProperty","setStepped","setCurve","prop","str","Additive","Multiply","Screen","SkeletonBinary","binary","BinaryInput","readString","readFloat","nonessential","readBoolean","readInt","strings","TransformModeValues","rgba8888ToColor","readInt32","rgb888ToColor","readStringRef","BlendModeValues","readByte","PositionModeValues","SpacingModeValues","RotateModeValues","readSkin","typeIndex","AttachmentTypeValues","Region","BoundingBox","Mesh","readFloatArray","readShortArray","Path","Point","Clipping","endSlotIndex","Vertices","bonesArray","readShort","tempColor1","tempColor2","timelineType","SLOT_ATTACHMENT","SLOT_COLOR","SLOT_TWO_COLOR","BONE_ROTATE","BONE_TRANSLATE","BONE_SCALE","BONE_SHEAR","PATH_POSITION","PATH_SPACING","PATH_MIX","iii","nnn","vn","drawOrderCount","offsetCount","eventCount","CURVE_STEPPED","CURVE_BEZIER","CURVE_LINEAR","buffer","DataView","getInt8","getInt16","getInt32","optimizePositive","result","byteCount","chars","String","fromCharCode","getFloat32","resourceLoader","Loader","AssetPromise","resolve","reject","resource","checkUrl","getResouceFromUrl","checkUrls","getResouceFromUrls","assetManager","autoLoadTexture","AdaptiveTexture","skeletonFile","atlasFile","textureFile","loadText","loadTextureAtlas","onLoad","loadRes","atlasLoader","isBinFile","readSkeletonData","Entity","addComponent","enableMacro","getExtFromUrl","ext","queryStringPos","loader","Promise","res","rej","setInterval","isLoadingComplete","hasErrors","getErrors","Texture2D","setImageSource","generateMipmaps","WebGLRenderingContext","NEAREST","filterMode","TextureFilterMode","LINEAR_MIPMAP_LINEAR","Trilinear","Bilinear","wrapModeU","wrapModeV","Parser","registerComponents","registerResource"],"mappings":"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"}