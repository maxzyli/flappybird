import { Vector3, Quaternion, Matrix3x3, Matrix, MathUtil, Vector4, Vector2, Color, BoundingBox, Ray, Plane, BoundingSphere, BoundingFrustum, Rect } from '@oasis-engine/math';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _initializerDefineProperty(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * Asset Promise Status
 */
var AssetPromiseStatus;
/**
 * Asset Loading Promise.
 */

(function (AssetPromiseStatus) {
  AssetPromiseStatus[AssetPromiseStatus["Success"] = 0] = "Success";
  AssetPromiseStatus[AssetPromiseStatus["Pending"] = 1] = "Pending";
  AssetPromiseStatus[AssetPromiseStatus["Failed"] = 2] = "Failed";
})(AssetPromiseStatus || (AssetPromiseStatus = {}));

var AssetPromise = /*#__PURE__*/function (_Promise) {
  _inheritsLoose(AssetPromise, _Promise);

  /**
   * Return a new resource Promise through the provided asset promise collection.
   * The resolved of the new AssetPromise will be triggered when all the Promises in the provided set are completed.
   * @param - AssetPromise Collection
   * @returns AssetPromise
   */
  AssetPromise.all = function all(promises) {
    return new AssetPromise(function (resolve, reject, setProgress) {
      if (!Array.isArray(promises)) {
        return resolve([promises]);
      }

      var completed = 0;
      var total = promises.length;
      var results = new Array(total);
      promises.forEach(function (value, index) {
        Promise.resolve(value).then(function (result) {
          results[index] = result;
          completed += 1;
          setProgress(completed / total);

          if (completed == total) {
            resolve(results);
          }
        }).catch(function (err) {
          return reject(err);
        });
      });
    });
  };

  var _proto = AssetPromise.prototype;

  /**
   * Progress callback.
   * @param callback - Progress callback
   * @returns Asset Promise
   */
  _proto.onProgress = function onProgress(callback) {
    this._listeners.add(callback);

    return this;
  }
  /**
   * Cancel promise request.
   * @returns Asset promise
   */
  ;

  _proto.cancel = function cancel() {
    if (this._status !== AssetPromiseStatus.Pending) {
      return this;
    }

    this._reject("Promise Canceled");

    return this;
  }
  /**
   * Create an asset loading Promise.
   * @param executor - A callback used to initialize the promise. This callback is passed two arguments:
   * a resolve callback used to resolve the promise with a value or the result of another promise,
   * and a reject callback used to reject the promise with a provided reason or error.
   * and a setProgress callback used to set promise progress with a percent.
   */
  ;

  function AssetPromise(executor) {
    var _this;

    var newReject;

    var setProgress = function setProgress(progress) {
      if (progress <= _this._progress) {
        return;
      }

      _this._progress = progress;

      for (var _iterator = _createForOfIteratorHelperLoose(_this._listeners), _step; !(_step = _iterator()).done;) {
        var listener = _step.value;
        listener(progress);
      }
    };

    _this = _Promise.call(this, function (resolve, reject) {
      newReject = function newReject(reason) {
        // Add it to the micro task to avoid reporting an error when calling this directly.
        Promise.resolve().then(function () {
          _this._status = AssetPromiseStatus.Failed;
          reject(reason);
        });
      };

      executor(function (value) {
        // Add it to the micro task to avoid reporting an error when calling this directly.
        Promise.resolve().then(function () {
          setProgress(1);
          _this._status = AssetPromiseStatus.Success;
          resolve(value);
        });
      }, newReject, function (progress) {
        // Add it to the micro task to avoid reporting an error when calling this directly
        Promise.resolve().then(function () {
          setProgress(progress);
        });
      });
    }) || this;
    _this._status = void 0;
    _this._progress = void 0;
    _this._reject = void 0;
    _this._listeners = void 0;
    _this._reject = newReject;
    _this._listeners = new Set();
    _this._progress = 0;
    _this._status = AssetPromiseStatus.Pending;
    return _this;
  }

  _createClass(AssetPromise, [{
    key: "status",
    get:
    /**
     * Current promise state.
     */
    function get() {
      return this._status;
    }
    /**
     * Loading progress.
     */

  }, {
    key: "progress",
    get: function get() {
      return this._progress;
    }
  }]);

  return AssetPromise;
}( /*#__PURE__*/_wrapNativeSuper(Promise));

var Util = {
  isArray: "isArray" in Array ? Array.isArray : function (value) {
    return toString.call(value) === "[object Array]";
  },
  isArrayLike: function isArrayLike(x) {
    return !!x && typeof x.length === "number" && typeof x !== "function";
  },
  clone: function clone(obj) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }

    var rst;

    if (Util.isArrayLike(obj)) {
      rst = obj.slice();

      for (var i = 0, l = obj.length; i < l; i++) {
        rst[i] = Util.clone(obj[i]);
      }
    } else {
      rst = {};

      for (var k in obj) {
        if (obj.hasOwnProperty(k)) {
          rst[k] = Util.clone(obj[k]);
        }
      }
    }

    return rst;
  },
  downloadBlob: function downloadBlob(blob, fileName) {
    if (fileName === void 0) {
      fileName = "";
    }

    if (navigator && navigator.msSaveBlob) {
      navigator.msSaveBlob(blob, fileName);
      return;
    }

    var url = window.URL.createObjectURL(blob);
    var a = document.createElement("a");
    document.body.appendChild(a);
    a.style.display = "none";
    a.href = url;
    a.download = fileName;
    a.addEventListener("click", function () {
      if (a.parentElement) {
        a.parentElement.removeChild(a);
      }
    });
    a.click();
    window.URL.revokeObjectURL(url);
  }
};
/**
 * Fastly remove an element from array.
 * @param array - Array
 * @param item - Element
 */

function removeFromArray(array, item) {
  var index = array.indexOf(item);

  if (index < 0) {
    return false;
  }

  var last = array.length - 1;

  if (index !== last) {
    var end = array[last];
    array[index] = end;
  }

  array.length--;
  return true;
}
function ObjectValues(obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}

/**
 * ResourceManager
 */

var ResourceManager = /*#__PURE__*/function () {
  /** Loader collection. */

  /**
   * @internal
   */
  ResourceManager._addLoader = function _addLoader(type, loader, extnames) {
    this._loaders[type] = loader;

    for (var i = 0, len = extnames.length; i < len; i++) {
      this._extTypeMapping[extnames[i]] = type;
    }
  };

  ResourceManager._getTypeByUrl = function _getTypeByUrl(url) {
    var path = url.split("?")[0];
    return this._extTypeMapping[path.substring(path.lastIndexOf(".") + 1)];
  }
  /** The number of retries after failing to load assets. */
  ;

  /**
   * Create a ResourceManager.
   * @param engine - Engine to which the current ResourceManager belongs
   */
  function ResourceManager(engine) {
    this.engine = engine;
    this.retryCount = 1;
    this.retryInterval = 0;
    this.timeout = 20000;
    this._assetPool = Object.create(null);
    this._assetUrlPool = Object.create(null);
    this._refObjectPool = Object.create(null);
    this._loadingPromises = {};
  }
  /**
   * Load asset asynchronously through the path.
   * @param path - Path
   * @returns Asset promise
   */


  var _proto = ResourceManager.prototype;

  _proto.load = function load(assetInfo) {
    var _this = this;

    // single item
    if (!Array.isArray(assetInfo)) {
      return this._loadSingleItem(assetInfo);
    } // multi items


    var promises = assetInfo.map(function (item) {
      return _this._loadSingleItem(item);
    });
    return AssetPromise.all(promises);
  }
  /**
   * Cancel all assets that have not finished loading.
   */
  ;

  _proto.cancelNotLoaded = function cancelNotLoaded(url) {
    var _this2 = this;

    if (!url) {
      ObjectValues(this._loadingPromises).forEach(function (promise) {
        promise.cancel();
      });
    } else if (typeof url === "string") {
      var _this$_loadingPromise;

      (_this$_loadingPromise = this._loadingPromises[url]) === null || _this$_loadingPromise === void 0 ? void 0 : _this$_loadingPromise.cancel();
    } else {
      url.forEach(function (p) {
        var _this2$_loadingPromis;

        (_this2$_loadingPromis = _this2._loadingPromises[p]) === null || _this2$_loadingPromis === void 0 ? void 0 : _this2$_loadingPromis.cancel();
      });
    }
  }
  /**
   * Garbage collection will release resource objects managed by reference counting.
   * @remarks The release principle is that it is not referenced by the components, including direct and indirect reference.
   */
  ;

  _proto.gc = function gc() {
    var objects = ObjectValues(this._refObjectPool);

    for (var i = 0, len = objects.length; i < len; i++) {
      if (!objects[i].isGCIgnored) {
        objects[i].destroy();
      }
    }
  }
  /**
   * Get asset url from instanceId.
   * @param instanceId - Engine instance id
   * @returns Asset url
   */
  ;

  _proto.getAssetPath = function getAssetPath(instanceId) {
    return this._assetPool[instanceId];
  }
  /**
   * @internal
   */
  ;

  _proto._addAsset = function _addAsset(path, asset) {
    this._assetPool[asset.instanceId] = path;
    this._assetUrlPool[path] = asset;
  }
  /**
   * @internal
   */
  ;

  _proto._deleteAsset = function _deleteAsset(asset) {
    var id = asset.instanceId;
    var path = this._assetPool[id];

    if (path) {
      delete this._assetPool[id];
      delete this._assetUrlPool[path];
    }
  }
  /**
   * @internal
   */
  ;

  _proto._addRefObject = function _addRefObject(id, asset) {
    this._refObjectPool[id] = asset;
  }
  /**
   * @internal
   */
  ;

  _proto._deleteRefObject = function _deleteRefObject(id) {
    delete this._refObjectPool[id];
  };

  _proto._assignDefaultOptions = function _assignDefaultOptions(assetInfo) {
    var _assetInfo$type, _assetInfo$retryCount, _assetInfo$timeout, _assetInfo$retryInter, _assetInfo$url;

    assetInfo.type = (_assetInfo$type = assetInfo.type) != null ? _assetInfo$type : ResourceManager._getTypeByUrl(assetInfo.url);

    if (assetInfo.type === undefined) {
      throw "asset type should be specified: " + assetInfo.url;
    }

    assetInfo.retryCount = (_assetInfo$retryCount = assetInfo.retryCount) != null ? _assetInfo$retryCount : this.retryCount;
    assetInfo.timeout = (_assetInfo$timeout = assetInfo.timeout) != null ? _assetInfo$timeout : this.timeout;
    assetInfo.retryInterval = (_assetInfo$retryInter = assetInfo.retryInterval) != null ? _assetInfo$retryInter : this.retryInterval;
    assetInfo.url = (_assetInfo$url = assetInfo.url) != null ? _assetInfo$url : assetInfo.urls.join(",");
    return assetInfo;
  };

  _proto._loadSingleItem = function _loadSingleItem(item) {
    var _this3 = this;

    var info = this._assignDefaultOptions(typeof item === "string" ? {
      url: item
    } : item);

    var url = info.url; // has cache

    if (this._assetUrlPool[url]) {
      return new AssetPromise(function (resolve) {
        resolve(_this3._assetUrlPool[url]);
      });
    } // loading


    if (this._loadingPromises[url]) {
      return this._loadingPromises[info.url];
    }

    var loader = ResourceManager._loaders[info.type];
    var promise = loader.load(info, this);
    this._loadingPromises[url] = promise;
    promise.then(function (res) {
      if (loader.useCache) _this3._addAsset(url, res);
      delete _this3._loadingPromises[url];
    }).catch(function () {});
    return promise;
  };

  return ResourceManager;
}();
/**
 * Declare ResourceLoader's decorator.
 * @param assetType - Type of asset
 * @param extnames - Name of file extension
 */

ResourceManager._loaders = {};
ResourceManager._extTypeMapping = {};
function resourceLoader(assetType, extnames, useCache) {
  if (useCache === void 0) {
    useCache = true;
  }

  return function (Target) {
    var loader = new Target(useCache);

    ResourceManager._addLoader(assetType, loader, extnames);
  };
}

/** Event Object. * @class */
var Event = /*#__PURE__*/function () {
  function Event(type, target, data, bubbles) {
    if (target === void 0) {
      target = null;
    }

    if (data === void 0) {
      data = {};
    }

    if (bubbles === void 0) {
      bubbles = true;
    }

    this.data = void 0;
    this._timeStamp = void 0;
    this._target = void 0;
    this._currentTarget = void 0;
    this._bubbles = void 0;
    this._propagationStopped = void 0;
    this._type = void 0;
    this._timeStamp = new Date().getTime();
    this._target = target;
    this.data = data;
    this._currentTarget = null;
    this._bubbles = bubbles;
    this._propagationStopped = false;
    this._type = type;
  }

  var _proto = Event.prototype;

  _proto.stopPropagation = function stopPropagation() {
    this._propagationStopped = true;
  };

  _createClass(Event, [{
    key: "propagationStopped",
    get: function get() {
      return this._propagationStopped;
    }
  }, {
    key: "target",
    get: function get() {
      return this._target;
    },
    set: function set(t) {
      this._target = t;
    }
  }, {
    key: "timeStamp",
    get: function get() {
      return this._timeStamp;
    }
  }, {
    key: "currentTarget",
    get: function get() {
      return this._currentTarget;
    },
    set: function set(t) {
      this._currentTarget = t;
    }
  }, {
    key: "bubbles",
    get: function get() {
      return this._bubbles;
    }
  }, {
    key: "type",
    get: function get() {
      return this._type;
    }
  }]);

  return Event;
}();

/**
 * Clone mode.
 */
var CloneMode;

(function (CloneMode) {
  CloneMode[CloneMode["Ignore"] = 0] = "Ignore";
  CloneMode[CloneMode["Assignment"] = 1] = "Assignment";
  CloneMode[CloneMode["Shallow"] = 2] = "Shallow";
  CloneMode[CloneMode["Deep"] = 3] = "Deep";
})(CloneMode || (CloneMode = {}));

/**
 * Property decorator, ignore the property when cloning.
 */
function ignoreClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Ignore);
}
/**
 * Property decorator, assign value to the property when cloning.
 *
 * @remarks
 * If it's a primitive type, the value will be copied.
 * If it's a class type, the reference will be copied.
 */

function assignmentClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Assignment);
}
/**
 * Property decorator, shallow clone the property when cloning.
 * After cloning, it will keep its own reference independent, and use the method of assignment to clone all its internal properties.
 * if the internal property is a primitive type, the value will be copied, if the internal property is a reference type, its reference address will be copied.ã€‚
 *
 * @remarks
 * Applicable to Object, Array, TypedArray and Class types.
 */

function shallowClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Shallow);
}
/**
 * Property decorator, deep clone the property when cloning.
 * After cloning, it will maintain its own reference independence, and all its internal deep properties will remain completely independent.
 *
 * @remarks
 * Applicable to Object, Array, TypedArray and Class types.
 * If Class is encountered during the deep cloning process, the custom cloning function of the object will be called first.
 * Custom cloning requires the object to implement the IClone interface.
 */

function deepClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Deep);
}
/**
 * @internal
 * Clone manager.
 */

var CloneManager = /*#__PURE__*/function () {
  function CloneManager() {}

  /** @internal */

  /** @internal */

  /**
   * Register clone mode.
   * @param target - Clone target
   * @param propertyKey - Clone property name
   * @param mode - Clone mode
   */
  CloneManager.registerCloneMode = function registerCloneMode(target, propertyKey, mode) {
    var targetMap = CloneManager._subCloneModeMap.get(target.constructor);

    if (!targetMap) {
      targetMap = Object.create(null);

      CloneManager._subCloneModeMap.set(target.constructor, targetMap);
    }

    targetMap[propertyKey] = mode;
  }
  /**
   * Get the clone mode according to the prototype chain.
   */
  ;

  CloneManager.getCloneMode = function getCloneMode(type) {
    var cloneModes = CloneManager._cloneModeMap.get(type);

    if (!cloneModes) {
      cloneModes = Object.create(null);

      CloneManager._cloneModeMap.set(type, cloneModes);

      var objectType = CloneManager._objectType;
      var cloneModeMap = CloneManager._subCloneModeMap;

      while (type !== objectType) {
        var subCloneModes = cloneModeMap.get(type);

        if (subCloneModes) {
          _extends(cloneModes, subCloneModes);
        }

        type = Object.getPrototypeOf(type);
      }
    }

    return cloneModes;
  }
  /**
   * Deep clone the object.
   * @param source - Clone source
   * @param target - Clone target
   */
  ;

  CloneManager.deepCloneObject = function deepCloneObject(source, target) {
    var type = source.constructor;

    switch (type) {
      case Uint8Array:
      case Uint16Array:
      case Uint32Array:
      case Int8Array:
      case Int16Array:
      case Int32Array:
      case Float32Array:
      case Float64Array:
        // Type array clone.
        target.set(source);
        break;

      case Array:
        // Array clone.
        for (var i = 0, n = source.length; i < n; i++) {
          CloneManager._deepCloneObjectItem(source, target, i);
        }

        break;

      default:
        var customSource = source;

        if (customSource.clone && customSource.cloneTo) {
          // Custom clone.
          customSource.cloneTo(target);
        } else {
          // Object or other class not implements custom clone.
          var keys = Object.keys(source);

          for (var _i = 0, _n = keys.length; _i < _n; _i++) {
            CloneManager._deepCloneObjectItem(source, target, keys[_i]);
          }
        }

    }
  };

  CloneManager._deepCloneObjectItem = function _deepCloneObjectItem(source, target, k) {
    var sourceItem = source[k];

    if (sourceItem instanceof Object) {
      var itemType = sourceItem.constructor;

      switch (itemType) {
        case Uint8Array:
        case Uint16Array:
        case Uint32Array:
        case Int8Array:
        case Int16Array:
        case Int32Array:
        case Float32Array:
        case Float64Array:
          // Type array clone.
          var sourceTypeArrayItem = sourceItem;
          var targetTypeArrayItem = target[k];

          if (targetTypeArrayItem == null) {
            target[k] = sourceTypeArrayItem.slice();
          } else {
            targetTypeArrayItem.set(sourceTypeArrayItem);
          }

          break;

        case Array:
          // Array clone.
          var sourceArrayItem = sourceItem;
          var targetArrayItem = target[k];

          if (targetArrayItem == null) {
            target[k] = new Array(sourceArrayItem.length);
          } else {
            targetArrayItem.length = sourceArrayItem.length;
          }

          CloneManager.deepCloneObject(sourceArrayItem, targetArrayItem);
          break;

        default:
          if (sourceItem.clone && sourceItem.cloneTo) {
            // Custom clone.
            var sourceCustomItem = sourceItem;
            var targetCustomItem = target[k];

            if (targetCustomItem) {
              sourceCustomItem.cloneTo(targetCustomItem);
            } else {
              target[k] = sourceCustomItem.clone();
            }
          } else {
            // Object or other class not implements custom clone.
            var targetItem = target[k];
            targetItem == null && (target[k] = targetItem = new sourceItem.constructor());
            CloneManager.deepCloneObject(sourceItem, targetItem);
            break;
          }

      }
    } else {
      // Null or undefined and primitive type.
      target[k] = sourceItem;
    }
  };

  return CloneManager;
}();
CloneManager._subCloneModeMap = new Map();
CloneManager._cloneModeMap = new Map();
CloneManager._objectType = Object.getPrototypeOf(Object);

var _class$b, _descriptor$b, _descriptor2$a, _class2$8, _temp$8;

/**
 * EngineObject.
 */
var EngineObject = (_class$b = (_temp$8 = _class2$8 = /*#__PURE__*/function () {
  function EngineObject(engine) {
    _initializerDefineProperty(this, "instanceId", _descriptor$b, this);

    _initializerDefineProperty(this, "_engine", _descriptor2$a, this);

    this._engine = engine;
  }

  _createClass(EngineObject, [{
    key: "engine",
    get:
    /** Engine unique id. */

    /** Engine to which the object belongs. */

    /**
     * Get the engine which the object belongs.
     */
    function get() {
      return this._engine;
    }
  }]);

  return EngineObject;
}(), _class2$8._instanceIdCounter = 0, _temp$8), (_descriptor$b = _applyDecoratedDescriptor(_class$b.prototype, "instanceId", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return ++EngineObject._instanceIdCounter;
  }
}), _descriptor2$a = _applyDecoratedDescriptor(_class$b.prototype, "_engine", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class$b);

var _class$a, _descriptor$a;
/**
 * EventDispatcher, which can be inherited as a base class.
 */

var EventDispatcher = (_class$a = /*#__PURE__*/function (_EngineObject) {
  _inheritsLoose(EventDispatcher, _EngineObject);

  function EventDispatcher() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _EngineObject.call.apply(_EngineObject, [this].concat(args)) || this;

    _initializerDefineProperty(_this, "_evts", _descriptor$a, _assertThisInitialized(_this));

    _this._evtCount = 0;
    return _this;
  }

  var _proto = EventDispatcher.prototype;

  /**
   * Determine whether there is event listening.
   * @param event - Event name
   * @returns Returns whether there is a corresponding event
   */
  _proto.hasEvent = function hasEvent(event) {
    return this._evts[event] != null;
  }
  /**
   * Returns the names of all registered events.
   * @returns All event names
   */
  ;

  _proto.eventNames = function eventNames() {
    if (this._evtCount === 0) return [];
    return Object.keys(this._evts);
  }
  /**
   * Returns the number of listeners with the specified event name.
   * @param event - Event name
   * @returns The count of listeners
   */
  ;

  _proto.listenerCount = function listenerCount(event) {
    var listeners = this._evts[event];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  }
  /**
   * Dispatch the event with the specified event name.
   * @param event - Event name
   * @param data - Data
   * @returns - Whether the dispatching is successful
   */
  ;

  _proto.dispatch = function dispatch(event, data) {
    if (!this._evts[event]) {
      return false;
    }

    var listeners = this._evts[event];

    if (listeners.fn) {
      if (listeners.once) this.removeEventListener(event, listeners.fn);
      listeners.fn(data);
    } else {
      var l = listeners.length;

      for (var i = 0; i < l; i++) {
        if (listeners[i].once) this.removeEventListener(event, listeners[i].fn);
        listeners[i].fn(data);
      }
    }

    return true;
  }
  /**
   * Add a listener/
   * @param event - Event name
   * @param fn - Function
   * @returns This
   */
  ;

  _proto.on = function on(event, fn) {
    return this.addEventListener(event, fn);
  }
  /**
   * Add a one-time listener.
   * @param event - Event name
   * @param fn - Function
   * @returns This
   */
  ;

  _proto.once = function once(event, fn) {
    return this.addEventListener(event, fn, true);
  }
  /**
   * @deprecated Use `on/once` instead.
   * Add a listener function with the specified event name.
   * @param event - Event name
   * @param fn - Function
   * @param once - Is it a one-time listener
   * @returns this
   */
  ;

  _proto.addEventListener = function addEventListener(event, fn, once) {
    var listener = {
      fn: fn,
      once: once
    };
    var events = this._evts;

    if (!events[event]) {
      events[event] = listener;
      this._evtCount++;
    } else if (!events[event].fn) {
      events[event].push(listener);
    } else {
      events[event] = [events[event], listener];
    }

    return this;
  }
  /**
   * Remove the event listener(s) of the specified event name.
   * @param event - Event name
   * @param fn - Function, If is undefined, delete all corresponding event listeners.
   */
  ;

  _proto.off = function off(event, fn) {
    if (!this._evts[event]) return this;

    if (!fn) {
      this._clearEvent(event);

      return this;
    }

    var listeners = this._evts[event];

    if (listeners.fn && listeners.fn === fn) {
      this._clearEvent(event);
    } else {
      var index = listeners.indexOf(fn);

      if (index > -1) {
        var temp = listeners[listeners.length - 1];
        listeners[index] = temp;
        listeners.length--;

        if (listeners.length === 1) {
          this._evts[event] = listeners[0];
        }
      }
    }

    return this;
  }
  /**
   * @deprecated Use `off` instead.
   * Remove the event listener(s) of the specified event name.
   * @param event - Event name
   * @param fn - Function, If is undefined, delete all corresponding event listeners.
   */
  ;

  _proto.removeEventListener = function removeEventListener(event, fn) {
    return this.off(event, fn);
  }
  /**
   * Remove all event listeners.
   * @param event - Event name, delete all events if not passed
   */
  ;

  _proto.removeAllEventListeners = function removeAllEventListeners(event) {
    if (event) {
      if (this._evts[event]) this._clearEvent(event);
    } else {
      this._evts = Object.create(null);
      this._evtCount = 0;
    }
  }
  /**
   * @deprecated Use `dispatch` instead.
   */
  ;

  _proto.trigger = function trigger(e) {
    this.dispatch(e.type, e.data);
  };

  _proto._clearEvent = function _clearEvent(event) {
    if (--this._evtCount === 0) {
      this._evts = Object.create(null);
    } else {
      delete this._evts[event];
    }
  };

  return EventDispatcher;
}(EngineObject), (_descriptor$a = _applyDecoratedDescriptor(_class$a.prototype, "_evts", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return Object.create(null);
  }
})), _class$a);

/**
 * @class
 * @private
 */

/* tslint:disable */
var noop = function noop(message) {};

var debug = console.log.bind(console);
var info = console.info.bind(console);
var warn = console.warn.bind(console);
var error = console.error.bind(console);
var Logger = {
  debug: noop,
  info: noop,
  warn: noop,
  error: noop,
  isEnabled: false,

  /** Turn on log */
  enable: function enable() {
    this.debug = debug;
    this.info = info;
    this.warn = warn;
    this.error = error;
    this.isEnabled = true;
  },

  /** Turn off log */
  disable: function disable() {
    this.debug = noop;
    this.info = noop;
    this.warn = noop;
    this.error = noop;
    this.isEnabled = false;
  }
};

/**
 * Tools for calculating the time per frame.
 */
var Time = /*#__PURE__*/function () {
  /**
   * Constructor of the Time.
   */
  function Time() {
    this._clock = void 0;
    this._timeScale = void 0;
    this._deltaTime = void 0;
    this._startTime = void 0;
    this._lastTickTime = void 0;
    this._clock = performance ? performance : Date;
    this._timeScale = 1.0;
    this._deltaTime = 0.0001;

    var now = this._clock.now();

    this._startTime = now;
    this._lastTickTime = now;
  }

  var _proto = Time.prototype;

  _proto.reset = function reset() {
    this._lastTickTime = this._clock.now();
  }
  /**
   * Current Time
   */
  ;

  /**
   * Call every frame, update delta time and other data.
   */
  _proto.tick = function tick() {
    var now = this.nowTime;
    this._deltaTime = (now - this._lastTickTime) * this._timeScale;
    this._lastTickTime = now;
  };

  _createClass(Time, [{
    key: "nowTime",
    get: function get() {
      return this._clock.now();
    }
    /**
     * Time between two ticks
     */

  }, {
    key: "deltaTime",
    get: function get() {
      return this._deltaTime;
    }
    /**
     * Scaled delta time.
     */

  }, {
    key: "timeScale",
    get: function get() {
      return this._timeScale;
    },
    set: function set(s) {
      this._timeScale = s;
    }
    /**
     * Unscaled delta time.
     */

  }, {
    key: "unscaledDeltaTime",
    get: function get() {
      return this._deltaTime / this._timeScale;
    }
    /**
     * The elapsed time, after the clock is initialized.
     */

  }, {
    key: "timeSinceStartup",
    get: function get() {
      return this.nowTime - this._startTime;
    }
  }]);

  return Time;
}();

/**
 * Data type enumeration
 */
var DataType;
/**
 * GL Capabilities
 * Some capabilities can be smoothed out by extension, and some capabilities must use WebGL 2.0.
 * */

(function (DataType) {
  DataType[DataType["FLOAT"] = 5126] = "FLOAT";
  DataType[DataType["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  DataType[DataType["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  DataType[DataType["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  DataType[DataType["INT"] = 5124] = "INT";
  DataType[DataType["INT_VEC2"] = 35667] = "INT_VEC2";
  DataType[DataType["INT_VEC3"] = 35668] = "INT_VEC3";
  DataType[DataType["INT_VEC4"] = 35669] = "INT_VEC4";
  DataType[DataType["BOOL"] = 35670] = "BOOL";
  DataType[DataType["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  DataType[DataType["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  DataType[DataType["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  DataType[DataType["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  DataType[DataType["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  DataType[DataType["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  DataType[DataType["FLOAT_ARRAY"] = 35677] = "FLOAT_ARRAY";
  DataType[DataType["FLOAT_VEC2_ARRAY"] = 100000] = "FLOAT_VEC2_ARRAY";
  DataType[DataType["FLOAT_VEC3_ARRAY"] = 100001] = "FLOAT_VEC3_ARRAY";
  DataType[DataType["FLOAT_VEC4_ARRAY"] = 100002] = "FLOAT_VEC4_ARRAY";
  DataType[DataType["INT_ARRAY"] = 100003] = "INT_ARRAY";
  DataType[DataType["INT_VEC2_ARRAY"] = 100004] = "INT_VEC2_ARRAY";
  DataType[DataType["INT_VEC3_ARRAY"] = 100005] = "INT_VEC3_ARRAY";
  DataType[DataType["INT_VEC4_ARRAY"] = 100006] = "INT_VEC4_ARRAY";
  DataType[DataType["FLOAT_MAT2_ARRAY"] = 100007] = "FLOAT_MAT2_ARRAY";
  DataType[DataType["FLOAT_MAT3_ARRAY"] = 100008] = "FLOAT_MAT3_ARRAY";
  DataType[DataType["FLOAT_MAT4_ARRAY"] = 100009] = "FLOAT_MAT4_ARRAY";
  DataType[DataType["SAMPLER_2D_ARRAY"] = 100010] = "SAMPLER_2D_ARRAY";
  DataType[DataType["SAMPLER_CUBE_ARRAY"] = 100011] = "SAMPLER_CUBE_ARRAY";
  DataType[DataType["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
  DataType[DataType["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
  DataType[DataType["BYTE"] = 5120] = "BYTE";
  DataType[DataType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  DataType[DataType["SHORT"] = 5122] = "SHORT";
  DataType[DataType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  DataType[DataType["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
})(DataType || (DataType = {}));

var GLCapabilityType;

(function (GLCapabilityType) {
  GLCapabilityType["shaderVertexID"] = "shaderVertexID";
  GLCapabilityType["standardDerivatives"] = "OES_standard_derivatives";
  GLCapabilityType["shaderTextureLod"] = "EXT_shader_texture_lod";
  GLCapabilityType["elementIndexUint"] = "OES_element_index_uint";
  GLCapabilityType["depthTexture"] = "WEBGL_depth_texture";
  GLCapabilityType["drawBuffers"] = "WEBGL_draw_buffers";
  GLCapabilityType["vertexArrayObject"] = "OES_vertex_array_object";
  GLCapabilityType["instancedArrays"] = "ANGLE_instanced_arrays";
  GLCapabilityType["multipleSample"] = "multipleSampleOnlySupportedInWebGL2";
  GLCapabilityType["textureFloat"] = "OES_texture_float";
  GLCapabilityType["textureFloatLinear"] = "OES_texture_float_linear";
  GLCapabilityType["textureHalfFloat"] = "OES_texture_half_float";
  GLCapabilityType["textureHalfFloatLinear"] = "OES_texture_half_float_linear";
  GLCapabilityType["WEBGL_colorBufferFloat"] = "WEBGL_color_buffer_float";
  GLCapabilityType["colorBufferFloat"] = "EXT_color_buffer_float";
  GLCapabilityType["colorBufferHalfFloat"] = "EXT_color_buffer_half_float";
  GLCapabilityType["textureFilterAnisotropic"] = "EXT_texture_filter_anisotropic";
  GLCapabilityType["blendMinMax"] = "EXT_blend_minmax";
  GLCapabilityType["astc"] = "WEBGL_compressed_texture_astc";
  GLCapabilityType["astc_webkit"] = "WEBKIT_WEBGL_compressed_texture_astc";
  GLCapabilityType["etc"] = "WEBGL_compressed_texture_etc";
  GLCapabilityType["etc_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc";
  GLCapabilityType["etc1"] = "WEBGL_compressed_texture_etc1";
  GLCapabilityType["etc1_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc1";
  GLCapabilityType["pvrtc"] = "WEBGL_compressed_texture_pvrtc";
  GLCapabilityType["pvrtc_webkit"] = "WEBKIT_WEBGL_compressed_texture_pvrtc";
  GLCapabilityType["s3tc"] = "WEBGL_compressed_texture_s3tc";
  GLCapabilityType["s3tc_webkit"] = "WEBKIT_WEBGL_compressed_texture_s3tc";
})(GLCapabilityType || (GLCapabilityType = {}));

/**
 * High-performance unordered array, delete uses exchange method to improve performance, internal capacity only increases.
 */
var DisorderedArray = /*#__PURE__*/function () {
  function DisorderedArray(count) {
    if (count === void 0) {
      count = 0;
    }

    this._elements = void 0;
    this.length = 0;
    this._elements = new Array(count);
  }

  var _proto = DisorderedArray.prototype;

  _proto.add = function add(element) {
    if (this.length === this._elements.length) this._elements.push(element);else this._elements[this.length] = element;
    this.length++;
  };

  _proto.delete = function _delete(element) {
    //TODO: It can be optimized for custom binary search and other algorithms, currently this._elements>=this.length wastes performance.
    var index = this._elements.indexOf(element);

    this.deleteByIndex(index);
  };

  _proto.get = function get(index) {
    if (index >= this.length) {
      throw "Index is out of range.";
    }

    return this._elements[index];
  }
  /**
   *
   * @param index
   * @returns The replaced item is used to reset its index.
   */
  ;

  _proto.deleteByIndex = function deleteByIndex(index) {
    var elements = this._elements;
    var end = null;
    var lastIndex = this.length - 1;

    if (index !== lastIndex) {
      end = elements[lastIndex];
      elements[index] = end;
    }

    this.length--;
    return end;
  };

  _proto.garbageCollection = function garbageCollection() {
    this._elements.length = this.length;
  };

  return DisorderedArray;
}();

/**
 * Shader macro collection.
 * @internal
 */
var ShaderMacroCollection = /*#__PURE__*/function () {
  function ShaderMacroCollection() {
    this._mask = [];
    this._length = 0;
  }

  /**
   * Union of two macro collection.
   * @param left - input macro collection
   * @param right - input macro collection
   * @param out - union output macro collection
   */
  ShaderMacroCollection.unionCollection = function unionCollection(left, right, out) {
    var outMask = out._mask;
    var minSize, maxSize;
    var minMask, maxMask;

    if (left._length < right._length) {
      minSize = left._length;
      maxSize = right._length;
      minMask = left._mask;
      maxMask = right._mask;
    } else {
      minSize = right._length;
      maxSize = left._length;
      minMask = right._mask;
      maxMask = left._mask;
    }

    var i = 0;
    outMask.length < maxSize && (outMask.length = maxSize);

    for (; i < minSize; i++) {
      outMask[i] = minMask[i] | maxMask[i];
    }

    for (; i < maxSize; i++) {
      outMask[i] = maxMask[i];
    }

    out._length = maxSize;
  }
  /** @internal */
  ;

  var _proto = ShaderMacroCollection.prototype;

  /**
   * Enable one macro in this macro collection.
   * @param macro - ShaderMacro
   */
  _proto.enable = function enable(macro) {
    var index = macro._index;
    var size = index + 1;
    var mask = this._mask;
    var maskStart = this._length; // must from this._length because this._length maybe less than mask.length and have dirty data should clear.

    if (maskStart < size) {
      mask.length < size && (mask.length = size); // mask.length maybe small than size,maybe not.

      for (; maskStart < index; maskStart++) {
        mask[maskStart] = 0;
      }

      mask[index] = macro._value;
      this._length = size;
    } else {
      mask[index] |= macro._value;
    }
  }
  /**
   * Disable one macro in this macro collection.
   * @param macro - ShaderMacro
   */
  ;

  _proto.disable = function disable(macro) {
    var index = macro._index;
    var mask = this._mask;
    var endIndex = this._length - 1;

    if (index > endIndex) {
      return;
    }

    var newValue = mask[index] & ~macro._value;

    if (index == endIndex && newValue === 0) {
      this._length--;
    } else {
      mask[index] = newValue;
    }
  }
  /**
   * Union of this and other macro collection.
   * @param macroCollection - macro collection
   */
  ;

  _proto.unionCollection = function unionCollection(macroCollection) {
    var addMask = macroCollection._mask;
    var addSize = macroCollection._length;
    var mask = this._mask;
    var maskSize = this._length;

    if (maskSize < addSize) {
      mask.length < addSize && (mask.length = addSize);
      var i = 0;

      for (; i < maskSize; i++) {
        mask[i] |= addMask[i];
      }

      for (; i < addSize; i++) {
        mask[i] = addMask[i];
      }

      this._length = addSize;
    } else {
      for (var _i = 0; _i < addSize; _i++) {
        mask[_i] |= addMask[_i];
      }
    }
  }
  /**
   * Complementarity of this and other macro collection.
   * @param macroCollection - macro collection
   */
  ;

  _proto.complementaryCollection = function complementaryCollection(macroCollection) {
    var removeMask = macroCollection._mask;
    var mask = this._mask;
    var endIndex = this._length - 1;
    var i = Math.min(macroCollection._length - 1, endIndex);

    for (; i >= 0; i--) {
      var newValue = mask[i] & ~removeMask[i];

      if (i == endIndex && newValue === 0) {
        endIndex--;
        this._length--;
      } else {
        mask[i] = newValue;
      }
    }
  }
  /**
   * Intersection of this and other macro collection.
   * @param macroCollection - macro collection
   */
  ;

  _proto.intersectionCollection = function intersectionCollection(macroCollection) {
    var unionMask = macroCollection._mask;
    var mask = this._mask;

    for (var i = this._length - 1; i >= 0; i--) {
      var value = mask[i] & unionMask[i];

      if (value == 0 && i == this._length - 1) {
        this._length--;
      } else {
        mask[i] = value;
      }
    }
  }
  /**
   * Whether macro is enabled in this macro collection.
   * @param macro - ShaderMacro
   */
  ;

  _proto.isEnable = function isEnable(macro) {
    var index = macro._index;

    if (index >= this._length) {
      return false;
    }

    return (this._mask[index] & macro._value) !== 0;
  }
  /**
   * Clear this macro collection.
   */
  ;

  _proto.clear = function clear() {
    this._length = 0;
  };

  return ShaderMacroCollection;
}();

/**
 * The manager of the components.
 */

var ComponentsManager = /*#__PURE__*/function () {
  function ComponentsManager() {
    this._onStartScripts = new DisorderedArray();
    this._onUpdateScripts = new DisorderedArray();
    this._onLateUpdateScripts = new DisorderedArray();
    this._destroyComponents = [];
    this._onUpdateAnimations = new DisorderedArray();
    this._renderers = new DisorderedArray();
    this._onUpdateRenderers = new DisorderedArray();
    this._componentsContainerPool = [];
  }

  var _proto = ComponentsManager.prototype;

  _proto.addRenderer = function addRenderer(renderer) {
    renderer._rendererIndex = this._renderers.length;

    this._renderers.add(renderer);
  };

  _proto.removeRenderer = function removeRenderer(renderer) {
    var replaced = this._renderers.deleteByIndex(renderer._rendererIndex);

    replaced && (replaced._rendererIndex = renderer._rendererIndex);
    renderer._rendererIndex = -1;
  };

  _proto.addOnStartScript = function addOnStartScript(script) {
    script._onStartIndex = this._onStartScripts.length;

    this._onStartScripts.add(script);
  };

  _proto.removeOnStartScript = function removeOnStartScript(script) {
    var replaced = this._onStartScripts.deleteByIndex(script._onStartIndex);

    replaced && (replaced._onStartIndex = script._onStartIndex);
    script._onStartIndex = -1;
  };

  _proto.addOnUpdateScript = function addOnUpdateScript(script) {
    script._onUpdateIndex = this._onUpdateScripts.length;

    this._onUpdateScripts.add(script);
  };

  _proto.removeOnUpdateScript = function removeOnUpdateScript(script) {
    var replaced = this._onUpdateScripts.deleteByIndex(script._onUpdateIndex);

    replaced && (replaced._onUpdateIndex = script._onUpdateIndex);
    script._onUpdateIndex = -1;
  };

  _proto.addOnLateUpdateScript = function addOnLateUpdateScript(script) {
    script._onLateUpdateIndex = this._onLateUpdateScripts.length;

    this._onLateUpdateScripts.add(script);
  };

  _proto.removeOnLateUpdateScript = function removeOnLateUpdateScript(script) {
    var replaced = this._onLateUpdateScripts.deleteByIndex(script._onLateUpdateIndex);

    replaced && (replaced._onLateUpdateIndex = script._onLateUpdateIndex);
    script._onLateUpdateIndex = -1;
  };

  _proto.addOnUpdateAnimations = function addOnUpdateAnimations(animation) {
    //@ts-ignore
    animation._onUpdateIndex = this._onUpdateAnimations.length;

    this._onUpdateAnimations.add(animation);
  };

  _proto.removeOnUpdateAnimations = function removeOnUpdateAnimations(animation) {
    //@ts-ignore
    var replaced = this._onUpdateAnimations.deleteByIndex(animation._onUpdateIndex); //@ts-ignore


    replaced && (replaced._onUpdateIndex = animation._onUpdateIndex); //@ts-ignore

    animation._onUpdateIndex = -1;
  };

  _proto.addOnUpdateRenderers = function addOnUpdateRenderers(renderer) {
    renderer._onUpdateIndex = this._onUpdateRenderers.length;

    this._onUpdateRenderers.add(renderer);
  };

  _proto.removeOnUpdateRenderers = function removeOnUpdateRenderers(renderer) {
    var replaced = this._onUpdateRenderers.deleteByIndex(renderer._onUpdateIndex);

    replaced && (replaced._onUpdateIndex = renderer._onUpdateIndex);
    renderer._onUpdateIndex = -1;
  };

  _proto.addDestroyComponent = function addDestroyComponent(component) {
    this._destroyComponents.push(component);
  };

  _proto.callScriptOnStart = function callScriptOnStart() {
    var onStartScripts = this._onStartScripts;

    if (onStartScripts.length > 0) {
      var elements = onStartScripts._elements; // The 'onStartScripts.length' maybe add if you add some Script with addComponent() in some Script's onStart()

      for (var i = 0; i < onStartScripts.length; i++) {
        var script = elements[i];
        script._started = true;
        script._onStartIndex = -1;
        script.onStart();
      }

      onStartScripts.length = 0;
    }
  };

  _proto.callScriptOnUpdate = function callScriptOnUpdate(deltaTime) {
    var elements = this._onUpdateScripts._elements;

    for (var i = this._onUpdateScripts.length - 1; i >= 0; --i) {
      var element = elements[i];

      if (element._started) {
        element.onUpdate(deltaTime);
      }
    }
  };

  _proto.callScriptOnLateUpdate = function callScriptOnLateUpdate(deltaTime) {
    var elements = this._onLateUpdateScripts._elements;

    for (var i = this._onLateUpdateScripts.length - 1; i >= 0; --i) {
      var element = elements[i];

      if (element._started) {
        element.onLateUpdate(deltaTime);
      }
    }
  };

  _proto.callAnimationUpdate = function callAnimationUpdate(deltaTime) {
    var elements = this._onUpdateAnimations._elements;

    for (var i = this._onUpdateAnimations.length - 1; i >= 0; --i) {
      //@ts-ignore
      elements[i].update(deltaTime);
    }
  };

  _proto.callRendererOnUpdate = function callRendererOnUpdate(deltaTime) {
    var elements = this._onUpdateRenderers._elements;

    for (var i = this._onUpdateRenderers.length - 1; i >= 0; --i) {
      elements[i].update(deltaTime);
    }
  };

  _proto.callRender = function callRender(context) {
    var camera = context._camera;
    var elements = this._renderers._elements;

    for (var i = this._renderers.length - 1; i >= 0; --i) {
      var element = elements[i]; // filter by camera culling mask.

      if (!(camera.cullingMask & element._entity.layer)) {
        continue;
      } // filter by camera frustum.


      if (camera.enableFrustumCulling) {
        element.isCulled = !camera._frustum.intersectsBox(element.bounds);

        if (element.isCulled) {
          continue;
        }
      }

      var transform = camera.entity.transform;
      var position = transform.worldPosition;
      var center = element.bounds.getCenter(ComponentsManager._tempVector0);

      if (camera.isOrthographic) {
        var forward = transform.getWorldForward(ComponentsManager._tempVector1);
        Vector3.subtract(center, position, center);
        element._distanceForSort = Vector3.dot(center, forward);
      } else {
        element._distanceForSort = Vector3.distanceSquared(center, position);
      }

      element._updateShaderData(context);

      element._render(camera); // union camera global macro and renderer macro.


      ShaderMacroCollection.unionCollection(camera._globalShaderMacro, element.shaderData._macroCollection, element._globalShaderMacro);
    }
  };

  _proto.callComponentDestroy = function callComponentDestroy() {
    var destroyComponents = this._destroyComponents;
    var length = destroyComponents.length;

    if (length > 0) {
      for (var i = length - 1; i >= 0; --i) {
        destroyComponents[i].onDestroy();
      }

      destroyComponents.length = 0;
    }
  };

  _proto.callCameraOnBeginRender = function callCameraOnBeginRender(camera) {
    var camComps = camera.entity._components;

    for (var i = camComps.length - 1; i >= 0; --i) {
      var camComp = camComps[i];
      camComp.onBeginRender && camComp.onBeginRender(camera);
    }
  };

  _proto.callCameraOnEndRender = function callCameraOnEndRender(camera) {
    var camComps = camera.entity._components;

    for (var i = camComps.length - 1; i >= 0; --i) {
      var camComp = camComps[i];
      camComp.onBeginRender && camComp.onEndRender(camera);
    }
  };

  _proto.getActiveChangedTempList = function getActiveChangedTempList() {
    return this._componentsContainerPool.length ? this._componentsContainerPool.pop() : [];
  };

  _proto.putActiveChangedTempList = function putActiveChangedTempList(componentContainer) {
    componentContainer.length = 0;

    this._componentsContainerPool.push(componentContainer);
  };

  return ComponentsManager;
}();
ComponentsManager._tempVector0 = new Vector3();
ComponentsManager._tempVector1 = new Vector3();

/**
 * Custom clone interface.
 */

var ComponentCloner = /*#__PURE__*/function () {
  function ComponentCloner() {}

  /**
   * Clone component.
   * @param source - Clone source
   * @param target - Clone target
   */
  ComponentCloner.cloneComponent = function cloneComponent(source, target) {
    var cloneModes = CloneManager.getCloneMode(source.constructor);
    var keys = Object.keys(source);

    for (var i = 0, n = keys.length; i < n; i++) {
      var k = keys[i];
      var cloneMode = cloneModes[k];

      switch (cloneMode) {
        case undefined:
        case CloneMode.Assignment:
          target[k] = source[k];
          break;

        case CloneMode.Shallow:
          var sourcePropS = source[k];

          if (sourcePropS instanceof Object) {
            var tarProp = target[k];
            tarProp == null && (tarProp = target[k] = sourcePropS.constructor());

            _extends(tarProp, sourcePropS);
          } else {
            // Null or undefined and primitive type.
            target[k] = sourcePropS;
          }

          break;

        case CloneMode.Deep:
          var sourcePropD = source[k];

          if (sourcePropD instanceof Object) {
            var _tarProp = target[k];
            _tarProp == null && (_tarProp = target[k] = sourcePropD.constructor());
            CloneManager.deepCloneObject(sourcePropD, _tarProp);
          } else {
            // Null or undefined and primitive type.
            target[k] = sourcePropD;
          }

          break;
      }
    }

    if (source._cloneTo) {
      source._cloneTo(target);
    }
  };

  return ComponentCloner;
}();

/**
 * Used for component dependency registration.
 */
var ComponentsDependencies = /*#__PURE__*/function () {
  /**
   * @internal
   */

  /**
   * Register component dependencies.
   * @param currentComponent - The component you want to be register.
   * @param dependentComponent - The component's dependencies.
   */
  ComponentsDependencies.register = function register(currentComponent, dependentComponent) {
    this._addDependency(currentComponent, dependentComponent, this._dependenciesMap);

    this._addDependency(dependentComponent, currentComponent, this._invDependenciesMap);
  }
  /**
   * @internal
   */
  ;

  ComponentsDependencies._addCheck = function _addCheck(entity, type) {
    // Check if there are dependent components.
    var dependencies = ComponentsDependencies._dependenciesMap.get(type);

    if (dependencies) {
      for (var i = 0, len = dependencies.length; i < len; i++) {
        if (!entity.getComponent(dependencies[i])) {
          throw "you should add " + dependencies[i] + " before adding " + type;
        }
      }
    }
  }
  /**
   * @internal
   */
  ;

  ComponentsDependencies._removeCheck = function _removeCheck(entity, type) {
    var invDependencies = ComponentsDependencies._invDependenciesMap.get(type);

    if (invDependencies) {
      for (var i = 0, len = invDependencies.length; i < len; i++) {
        if (entity.getComponent(invDependencies[i])) {
          throw "you should remove " + invDependencies[i] + " before adding " + type;
        }
      }
    }
  };

  ComponentsDependencies._addDependency = function _addDependency(currentComponent, dependentComponent, map) {
    var components = map.get(currentComponent);

    if (!components) {
      components = [];
      map.set(currentComponent, components);
    }

    if (components.indexOf(dependentComponent) === -1) {
      components.push(dependentComponent);
    }
  };

  function ComponentsDependencies() {}

  return ComponentsDependencies;
}();
ComponentsDependencies._dependenciesMap = new Map();
ComponentsDependencies._invDependenciesMap = new Map();
function dependencies() {
  for (var _len = arguments.length, abilityClass = new Array(_len), _key = 0; _key < _len; _key++) {
    abilityClass[_key] = arguments[_key];
  }

  return function (target) {
    abilityClass.forEach(function (ability) {
      return ComponentsDependencies.register(target, ability);
    });
  };
}

/**
 * Layer, used for bit operations.
 */
var Layer;

(function (Layer) {
  Layer[Layer["Layer0"] = 1] = "Layer0";
  Layer[Layer["Layer1"] = 2] = "Layer1";
  Layer[Layer["Layer2"] = 4] = "Layer2";
  Layer[Layer["Layer3"] = 8] = "Layer3";
  Layer[Layer["Layer4"] = 16] = "Layer4";
  Layer[Layer["Layer5"] = 32] = "Layer5";
  Layer[Layer["Layer6"] = 64] = "Layer6";
  Layer[Layer["Layer7"] = 128] = "Layer7";
  Layer[Layer["Layer8"] = 256] = "Layer8";
  Layer[Layer["Layer9"] = 512] = "Layer9";
  Layer[Layer["Layer10"] = 1024] = "Layer10";
  Layer[Layer["Layer11"] = 2048] = "Layer11";
  Layer[Layer["Layer12"] = 4096] = "Layer12";
  Layer[Layer["Layer13"] = 8192] = "Layer13";
  Layer[Layer["Layer14"] = 16384] = "Layer14";
  Layer[Layer["Layer15"] = 32768] = "Layer15";
  Layer[Layer["Layer16"] = 65536] = "Layer16";
  Layer[Layer["Layer17"] = 131072] = "Layer17";
  Layer[Layer["Layer18"] = 262144] = "Layer18";
  Layer[Layer["Layer19"] = 524288] = "Layer19";
  Layer[Layer["Layer20"] = 1048576] = "Layer20";
  Layer[Layer["Layer21"] = 2097152] = "Layer21";
  Layer[Layer["Layer22"] = 4194304] = "Layer22";
  Layer[Layer["Layer23"] = 8388608] = "Layer23";
  Layer[Layer["Layer24"] = 16777216] = "Layer24";
  Layer[Layer["Layer25"] = 33554432] = "Layer25";
  Layer[Layer["Layer26"] = 67108864] = "Layer26";
  Layer[Layer["Layer27"] = 134217728] = "Layer27";
  Layer[Layer["Layer28"] = 268435456] = "Layer28";
  Layer[Layer["Layer29"] = 536870912] = "Layer29";
  Layer[Layer["Layer30"] = 1073741824] = "Layer30";
  Layer[Layer["Layer31"] = 2147483648] = "Layer31";
  Layer[Layer["Everything"] = 4294967295] = "Everything";
  Layer[Layer["Nothing"] = 0] = "Nothing";
})(Layer || (Layer = {}));

var _class$9, _descriptor$9, _descriptor2$9, _descriptor3$8, _descriptor4$8;

/**
 * The base class of the components.
 */
var Component = (_class$9 = /*#__PURE__*/function (_EngineObject) {
  _inheritsLoose(Component, _EngineObject);

  function Component(entity) {
    var _this;

    _this = _EngineObject.call(this, entity.engine) || this;

    _initializerDefineProperty(_this, "_entity", _descriptor$9, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_destroyed", _descriptor2$9, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_enabled", _descriptor3$8, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_awoken", _descriptor4$8, _assertThisInitialized(_this));

    _this._entity = entity;
    return _this;
  }
  /**
   * Destroy this instance.
   */


  var _proto = Component.prototype;

  _proto.destroy = function destroy() {
    if (this._destroyed) {
      return;
    }

    this._entity._removeComponent(this);

    if (this._entity.isActiveInHierarchy) {
      this._enabled && this._onDisable();

      this._onInActive();
    }

    this._destroyed = true;

    this._onDestroy();
  }
  /**
   * @internal
   */
  ;

  _proto._onAwake = function _onAwake() {}
  /**
   * @internal
   */
  ;

  _proto._onEnable = function _onEnable() {}
  /**
   * @internal
   */
  ;

  _proto._onDisable = function _onDisable() {}
  /**
   * @internal
   */
  ;

  _proto._onDestroy = function _onDestroy() {}
  /**
   * @internal
   */
  ;

  _proto._onActive = function _onActive() {}
  /**
   * @internal
   */
  ;

  _proto._onInActive = function _onInActive() {}
  /**
   * @internal
   */
  ;

  _proto._setActive = function _setActive(value) {
    if (value) {
      if (!this._awoken) {
        this._awoken = true;

        this._onAwake();
      } // You can do isActive = false in onAwake function.


      if (this._entity._isActiveInHierarchy) {
        this._onActive();

        this._enabled && this._onEnable();
      }
    } else {
      this._enabled && this._onDisable();

      this._onInActive();
    }
  };

  _createClass(Component, [{
    key: "enabled",
    get:
    /** @internal */

    /** @internal */

    /**
     * Indicates whether the component is enabled.
     */
    function get() {
      return this._enabled;
    },
    set: function set(value) {
      if (value === this._enabled) {
        return;
      }

      this._enabled = value;

      if (value) {
        this._entity.isActiveInHierarchy && this._onEnable();
      } else {
        this._entity.isActiveInHierarchy && this._onDisable();
      }
    }
    /**
     * Indicates whether the component is destroyed.
     */

  }, {
    key: "destroyed",
    get: function get() {
      return this._destroyed;
    }
    /**
     * The entity which the component belongs to.
     */

  }, {
    key: "entity",
    get: function get() {
      return this._entity;
    }
    /**
     * The scene which the component's entity belongs to.
     */

  }, {
    key: "scene",
    get: function get() {
      return this._entity.scene;
    }
  }]);

  return Component;
}(EngineObject), (_descriptor$9 = _applyDecoratedDescriptor(_class$9.prototype, "_entity", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$9 = _applyDecoratedDescriptor(_class$9.prototype, "_destroyed", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor3$8 = _applyDecoratedDescriptor(_class$9.prototype, "_enabled", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return true;
  }
}), _descriptor4$8 = _applyDecoratedDescriptor(_class$9.prototype, "_awoken", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
})), _class$9);

/**
 * Used to update tags.
 */

var UpdateFlag = /*#__PURE__*/function () {
  /** Flag. */
  function UpdateFlag(_flags) {
    if (_flags === void 0) {
      _flags = [];
    }

    this._flags = _flags;
    this.flag = true;

    this._flags.push(this);
  }
  /**
   * Destroy.
   */


  var _proto = UpdateFlag.prototype;

  _proto.destroy = function destroy() {
    var flags = this._flags;
    removeFromArray(flags, this);
    this._flags = null;
  };

  return UpdateFlag;
}();

/**
 * @internal
 */

var UpdateFlagManager = /*#__PURE__*/function () {
  function UpdateFlagManager() {
    this._updateFlags = [];
  }

  var _proto = UpdateFlagManager.prototype;

  _proto.register = function register() {
    return new UpdateFlag(this._updateFlags);
  };

  _proto.distribute = function distribute() {
    var updateFlags = this._updateFlags;

    for (var i = updateFlags.length - 1; i >= 0; i--) {
      updateFlags[i].flag = true;
    }
  };

  return UpdateFlagManager;
}();

var _class$8, _descriptor$8, _descriptor2$8, _descriptor3$7, _descriptor4$7, _descriptor5$7, _descriptor6$7, _descriptor7$5, _descriptor8$3, _descriptor9$3, _descriptor10$3, _descriptor11$3, _descriptor12$3, _descriptor13$2, _class2$7, _temp$7;
/**
 * Used to implement transformation related functions.
 */

var Transform = (_class$8 = (_temp$7 = _class2$7 = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Transform, _Component);

  function Transform() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;

    _initializerDefineProperty(_this, "_position", _descriptor$8, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_rotation", _descriptor2$8, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_rotationQuaternion", _descriptor3$7, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_scale", _descriptor4$7, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_worldPosition", _descriptor5$7, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_worldRotation", _descriptor6$7, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_worldRotationQuaternion", _descriptor7$5, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_lossyWorldScale", _descriptor8$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_localMatrix", _descriptor9$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_worldMatrix", _descriptor10$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_updateFlagManager", _descriptor11$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_isParentDirty", _descriptor12$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_parentTransformCache", _descriptor13$2, _assertThisInitialized(_this));

    _this._dirtyFlag = TransformFlag.WmWpWeWqWs;
    return _this;
  }

  var _proto = Transform.prototype;

  /**
   * Set local position by X, Y, Z value.
   * @param x - X coordinate
   * @param y - Y coordinate
   * @param z - Z coordinate
   */
  _proto.setPosition = function setPosition(x, y, z) {
    this._position.setValue(x, y, z);

    this.position = this._position;
  }
  /**
   * Set local rotation by the X, Y, Z components of the euler angle, unit in degrees.
   * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
   * @param x - The angle of rotation around the X axis
   * @param y - The angle of rotation around the Y axis
   * @param z - The angle of rotation around the Z axis
   */
  ;

  _proto.setRotation = function setRotation(x, y, z) {
    this._rotation.setValue(x, y, z);

    this.rotation = this._rotation;
  }
  /**
   * Set local rotation by the X, Y, Z, and W components of the quaternion.
   * @param x - X component of quaternion
   * @param y - Y component of quaternion
   * @param z - Z component of quaternion
   * @param w - W component of quaternion
   */
  ;

  _proto.setRotationQuaternion = function setRotationQuaternion(x, y, z, w) {
    this._rotationQuaternion.setValue(x, y, z, w);

    this.rotationQuaternion = this._rotationQuaternion;
  }
  /**
   * Set local scaling by scaling values along X, Y, Z axis.
   * @param x - Scaling along X axis
   * @param y - Scaling along Y axis
   * @param z - Scaling along Z axis
   */
  ;

  _proto.setScale = function setScale(x, y, z) {
    this._scale.setValue(x, y, z);

    this.scale = this._scale;
  }
  /**
   * Set world position by X, Y, Z value.
   * @param x - X coordinate
   * @param y - Y coordinate
   * @param z - Z coordinate
   */
  ;

  _proto.setWorldPosition = function setWorldPosition(x, y, z) {
    this._worldPosition.setValue(x, y, z);

    this.worldPosition = this._worldPosition;
  }
  /**
   * Set world rotation by the X, Y, Z components of the euler angle, unit in degrees, Yaw/Pitch/Roll sequence.
   * @param x - The angle of rotation around the X axis
   * @param y - The angle of rotation around the Y axis
   * @param z - The angle of rotation around the Z axis
   */
  ;

  _proto.setWorldRotation = function setWorldRotation(x, y, z) {
    this._worldRotation.setValue(x, y, z);

    this.worldRotation = this._worldRotation;
  }
  /**
   * Set local rotation by the X, Y, Z, and W components of the quaternion.
   * @param x - X component of quaternion
   * @param y - Y component of quaternion
   * @param z - Z component of quaternion
   * @param w - W component of quaternion
   */
  ;

  _proto.setWorldRotationQuaternion = function setWorldRotationQuaternion(x, y, z, w) {
    this._worldRotationQuaternion.setValue(x, y, z, w);

    this.worldRotationQuaternion = this._worldRotationQuaternion;
  }
  /**
   * Get the forward direction in world space.
   * @param forward - Forward vector
   * @returns Forward vector
   */
  ;

  _proto.getWorldForward = function getWorldForward(forward) {
    var e = this.worldMatrix.elements;
    forward.setValue(-e[8], -e[9], -e[10]);
    return forward.normalize();
  }
  /**
   * Get the right direction in world space.
   * @param right - Right vector
   * @returns Right vector
   */
  ;

  _proto.getWorldRight = function getWorldRight(right) {
    var e = this.worldMatrix.elements;
    right.setValue(e[0], e[1], e[2]);
    return right.normalize();
  }
  /**
   * Get the up direction in world space.
   * @param up - Up vector
   * @returns Up vector
   */
  ;

  _proto.getWorldUp = function getWorldUp(up) {
    var e = this.worldMatrix.elements;
    up.setValue(e[4], e[5], e[6]);
    return up.normalize();
  }
  /**
   * Translate along the passed Vector3.
   * @param translation - Direction and distance of translation
   * @param relativeToLocal - Relative to local space
   */
  ;

  _proto.translate = function translate(translationOrX, relativeToLocalOrY, z, relativeToLocal) {
    if (typeof translationOrX === "number") {
      var _translate2 = Transform._tempVec3;

      _translate2.setValue(translationOrX, relativeToLocalOrY, z);

      this._translate(_translate2, relativeToLocal);
    } else {
      this._translate(translationOrX, relativeToLocalOrY);
    }
  }
  /**
   * Rotate around the passed Vector3.
   * @param rotation - Euler angle in degrees
   * @param relativeToLocal - Relative to local space
   */
  ;

  _proto.rotate = function rotate(rotationOrX, relativeToLocalOrY, z, relativeToLocal) {
    if (typeof rotationOrX === "number") {
      this._rotateXYZ(rotationOrX, relativeToLocalOrY, z, relativeToLocal);
    } else {
      this._rotateXYZ(rotationOrX.x, rotationOrX.y, rotationOrX.z, relativeToLocalOrY);
    }
  }
  /**
   * Rotate around the specified axis according to the specified angle.
   * @param axis - Rotate axis
   * @param angle - Rotate angle in degrees
   * @param relativeToLocal - Relative to local space
   */
  ;

  _proto.rotateByAxis = function rotateByAxis(axis, angle, relativeToLocal) {
    if (relativeToLocal === void 0) {
      relativeToLocal = true;
    }

    var rad = angle * MathUtil.degreeToRadFactor;
    Quaternion.rotationAxisAngle(axis, rad, Transform._tempQuat0);

    this._rotateByQuat(Transform._tempQuat0, relativeToLocal);
  }
  /**
   * Rotate and ensure that the world front vector points to the target world position.
   * @param worldPosition - Target world position
   * @param worldUp - Up direction in world space, default is Vector3(0, 1, 0)
   */
  ;

  _proto.lookAt = function lookAt(worldPosition, worldUp) {
    var _worldUp;

    var position = this.worldPosition;
    var EPSILON = MathUtil.zeroTolerance;

    if (Math.abs(position.x - worldPosition.x) < EPSILON && Math.abs(position.y - worldPosition.y) < EPSILON && Math.abs(position.z - worldPosition.z) < EPSILON) {
      return;
    }

    var rotMat = Transform._tempMat43;
    var worldRotationQuaternion = this._worldRotationQuaternion;
    worldUp = (_worldUp = worldUp) != null ? _worldUp : Transform._tempVec3.setValue(0, 1, 0);
    Matrix.lookAt(position, worldPosition, worldUp, rotMat);
    rotMat.getRotation(worldRotationQuaternion).invert();
    this.worldRotationQuaternion = worldRotationQuaternion;
  }
  /**
   * Register world transform change flag.
   * @returns Change flag
   */
  ;

  _proto.registerWorldChangeFlag = function registerWorldChangeFlag() {
    return this._updateFlagManager.register();
  }
  /**
   * @internal
   */
  ;

  _proto._parentChange = function _parentChange() {
    this._isParentDirty = true;

    this._updateAllWorldFlag();
  }
  /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
   */
  ;

  _proto._updateWorldPositionFlag = function _updateWorldPositionFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWp)) {
      this._worldAssociatedChange(TransformFlag.WmWp);

      var nodeChildren = this._entity._children;

      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans;

        (_nodeChildren$i$trans = nodeChildren[i].transform) === null || _nodeChildren$i$trans === void 0 ? void 0 : _nodeChildren$i$trans._updateWorldPositionFlag();
      }
    }
  }
  /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * Get worldRotationQuaternion: Will trigger the world rotation (in quaternion) update of itself and all parent entities.
   * Get worldRotation: Will trigger the world rotation(in euler and quaternion) update of itself and world rotation(in quaternion) update of all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
   */
  ;

  _proto._updateWorldRotationFlag = function _updateWorldRotationFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWeWq)) {
      this._worldAssociatedChange(TransformFlag.WmWeWq);

      var nodeChildren = this._entity._children;

      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans2;

        (_nodeChildren$i$trans2 = nodeChildren[i].transform) === null || _nodeChildren$i$trans2 === void 0 ? void 0 : _nodeChildren$i$trans2._updateWorldPositionAndRotationFlag(); // Rotation update of parent entity will trigger world position and rotation update of all child entity.
      }
    }
  }
  /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * Get worldRotationQuaternion: Will trigger the world rotation (in quaternion) update of itself and all parent entities.
   * Get worldRotation: Will trigger the world rotation(in euler and quaternion) update of itself and world rotation(in quaternion) update of all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
   */
  ;

  _proto._updateWorldPositionAndRotationFlag = function _updateWorldPositionAndRotationFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWpWeWq)) {
      this._worldAssociatedChange(TransformFlag.WmWpWeWq);

      var nodeChildren = this._entity._children;

      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans3;

        (_nodeChildren$i$trans3 = nodeChildren[i].transform) === null || _nodeChildren$i$trans3 === void 0 ? void 0 : _nodeChildren$i$trans3._updateWorldPositionAndRotationFlag();
      }
    }
  }
  /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * Get worldScale: Will trigger the scaling update of itself and all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix) to be false.
   */
  ;

  _proto._updateWorldScaleFlag = function _updateWorldScaleFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWs)) {
      this._worldAssociatedChange(TransformFlag.WmWs);

      var nodeChildren = this._entity._children;

      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans4;

        (_nodeChildren$i$trans4 = nodeChildren[i].transform) === null || _nodeChildren$i$trans4 === void 0 ? void 0 : _nodeChildren$i$trans4._updateWorldPositionAndScaleFlag();
      }
    }
  }
  /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * Get worldScale: Will trigger the scaling update of itself and all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix) to be false.
   */
  ;

  _proto._updateWorldPositionAndScaleFlag = function _updateWorldPositionAndScaleFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWpWs)) {
      this._worldAssociatedChange(TransformFlag.WmWpWs);

      var nodeChildren = this._entity._children;

      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans5;

        (_nodeChildren$i$trans5 = nodeChildren[i].transform) === null || _nodeChildren$i$trans5 === void 0 ? void 0 : _nodeChildren$i$trans5._updateWorldPositionAndScaleFlag();
      }
    }
  }
  /**
   * Update all world transform property dirty flag, the principle is the same as above.
   */
  ;

  _proto._updateAllWorldFlag = function _updateAllWorldFlag() {
    if (!this._isContainDirtyFlags(TransformFlag.WmWpWeWqWs)) {
      this._worldAssociatedChange(TransformFlag.WmWpWeWqWs);

      var nodeChildren = this._entity._children;

      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans6;

        (_nodeChildren$i$trans6 = nodeChildren[i].transform) === null || _nodeChildren$i$trans6 === void 0 ? void 0 : _nodeChildren$i$trans6._updateAllWorldFlag();
      }
    }
  };

  _proto._getParentTransform = function _getParentTransform() {
    if (!this._isParentDirty) {
      return this._parentTransformCache;
    }

    var parentCache = null;
    var parent = this._entity.parent;

    while (parent) {
      var transform = parent.transform;

      if (transform) {
        parentCache = transform;
        break;
      } else {
        parent = parent.parent;
      }
    }

    this._parentTransformCache = parentCache;
    this._isParentDirty = false;
    return parentCache;
  };

  _proto._getScaleMatrix = function _getScaleMatrix() {
    var invRotation = Transform._tempQuat0;
    var invRotationMat = Transform._tempMat30;
    var worldRotScaMat = Transform._tempMat31;
    var scaMat = Transform._tempMat32;
    worldRotScaMat.setValueByMatrix(this.worldMatrix);
    Quaternion.invert(this.worldRotationQuaternion, invRotation);
    Matrix3x3.rotationQuaternion(invRotation, invRotationMat);
    Matrix3x3.multiply(invRotationMat, worldRotScaMat, scaMat);
    return scaMat;
  };

  _proto._isContainDirtyFlags = function _isContainDirtyFlags(targetDirtyFlags) {
    return (this._dirtyFlag & targetDirtyFlags) === targetDirtyFlags;
  };

  _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
    return (this._dirtyFlag & type) != 0;
  };

  _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
    this._dirtyFlag |= type;
  };

  _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
    this._dirtyFlag &= ~type;
  };

  _proto._worldAssociatedChange = function _worldAssociatedChange(type) {
    this._dirtyFlag |= type;

    this._updateFlagManager.distribute();
  };

  _proto._rotateByQuat = function _rotateByQuat(rotateQuat, relativeToLocal) {
    if (relativeToLocal) {
      Quaternion.multiply(this.rotationQuaternion, rotateQuat, this._rotationQuaternion);
      this.rotationQuaternion = this._rotationQuaternion;
    } else {
      Quaternion.multiply(this.worldRotationQuaternion, rotateQuat, this._worldRotationQuaternion);
      this.worldRotationQuaternion = this._worldRotationQuaternion;
    }
  };

  _proto._translate = function _translate(translation, relativeToLocal) {
    if (relativeToLocal === void 0) {
      relativeToLocal = true;
    }

    if (relativeToLocal) {
      this.position = this._position.add(translation);
    } else {
      this.worldPosition = this._worldPosition.add(translation);
    }
  };

  _proto._rotateXYZ = function _rotateXYZ(x, y, z, relativeToLocal) {
    if (relativeToLocal === void 0) {
      relativeToLocal = true;
    }

    var radFactor = MathUtil.degreeToRadFactor;
    var rotQuat = Transform._tempQuat0;
    Quaternion.rotationEuler(x * radFactor, y * radFactor, z * radFactor, rotQuat);

    this._rotateByQuat(rotQuat, relativeToLocal);
  };

  _createClass(Transform, [{
    key: "position",
    get:
    /**
     * Local position.
     * @remarks Need to re-assign after modification to ensure that the modification takes effect.
     */
    function get() {
      return this._position;
    },
    set: function set(value) {
      if (this._position !== value) {
        value.cloneTo(this._position);
      }

      this._setDirtyFlagTrue(TransformFlag.LocalMatrix);

      this._updateWorldPositionFlag();
    }
    /**
     * World position.
     * @remarks Need to re-assign after modification to ensure that the modification takes effect.
     */

  }, {
    key: "worldPosition",
    get: function get() {
      if (this._isContainDirtyFlag(TransformFlag.WorldPosition)) {
        if (this._getParentTransform()) {
          this.worldMatrix.getTranslation(this._worldPosition);
        } else {
          this._position.cloneTo(this._worldPosition);
        }

        this._setDirtyFlagFalse(TransformFlag.WorldPosition);
      }

      return this._worldPosition;
    },
    set: function set(value) {
      if (this._worldPosition !== value) {
        value.cloneTo(this._worldPosition);
      }

      var parent = this._getParentTransform();

      if (parent) {
        Matrix.invert(parent.worldMatrix, Transform._tempMat41);
        Vector3.transformCoordinate(value, Transform._tempMat41, this._position);
      } else {
        value.cloneTo(this._position);
      }

      this.position = this._position;

      this._setDirtyFlagFalse(TransformFlag.WorldPosition);
    }
    /**
     * Local rotation, defining the rotation value in degrees.
     * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
     * @remarks Need to re-assign after modification to ensure that the modification takes effect.
     */

  }, {
    key: "rotation",
    get: function get() {
      if (this._isContainDirtyFlag(TransformFlag.LocalEuler)) {
        this._rotationQuaternion.toEuler(this._rotation);

        this._rotation.scale(MathUtil.radToDegreeFactor); // radians to degrees


        this._setDirtyFlagFalse(TransformFlag.LocalEuler);
      }

      return this._rotation;
    },
    set: function set(value) {
      if (this._rotation !== value) {
        value.cloneTo(this._rotation);
      }

      this._setDirtyFlagTrue(TransformFlag.LocalMatrix | TransformFlag.LocalQuat);

      this._setDirtyFlagFalse(TransformFlag.LocalEuler);

      this._updateWorldRotationFlag();
    }
    /**
     * World rotation, defining the rotation value in degrees.
     * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
     * @remarks Need to re-assign after modification to ensure that the modification takes effect.
     */

  }, {
    key: "worldRotation",
    get: function get() {
      if (this._isContainDirtyFlag(TransformFlag.WorldEuler)) {
        this.worldRotationQuaternion.toEuler(this._worldRotation);

        this._worldRotation.scale(MathUtil.radToDegreeFactor); // Radian to angle


        this._setDirtyFlagFalse(TransformFlag.WorldEuler);
      }

      return this._worldRotation;
    },
    set: function set(value) {
      if (this._worldRotation !== value) {
        value.cloneTo(this._worldRotation);
      }

      Quaternion.rotationEuler(MathUtil.degreeToRadian(value.x), MathUtil.degreeToRadian(value.y), MathUtil.degreeToRadian(value.z), this._worldRotationQuaternion);
      this.worldRotationQuaternion = this._worldRotationQuaternion;

      this._setDirtyFlagFalse(TransformFlag.WorldEuler);
    }
    /**
     * Local rotation, defining the rotation by using a unit quaternion.
     * @remarks Need to re-assign after modification to ensure that the modification takes effect.
     */

  }, {
    key: "rotationQuaternion",
    get: function get() {
      if (this._isContainDirtyFlag(TransformFlag.LocalQuat)) {
        Quaternion.rotationEuler(MathUtil.degreeToRadian(this._rotation.x), MathUtil.degreeToRadian(this._rotation.y), MathUtil.degreeToRadian(this._rotation.z), this._rotationQuaternion);

        this._setDirtyFlagFalse(TransformFlag.LocalQuat);
      }

      return this._rotationQuaternion;
    },
    set: function set(value) {
      if (this._rotationQuaternion !== value) {
        value.cloneTo(this._rotationQuaternion);
      }

      this._setDirtyFlagTrue(TransformFlag.LocalMatrix | TransformFlag.LocalEuler);

      this._setDirtyFlagFalse(TransformFlag.LocalQuat);

      this._updateWorldRotationFlag();
    }
    /**
     * World rotation, defining the rotation by using a unit quaternion.
     * @remarks Need to re-assign after modification to ensure that the modification takes effect.
     */

  }, {
    key: "worldRotationQuaternion",
    get: function get() {
      if (this._isContainDirtyFlag(TransformFlag.WorldQuat)) {
        var parent = this._getParentTransform();

        if (parent != null) {
          Quaternion.multiply(parent.worldRotationQuaternion, this.rotationQuaternion, this._worldRotationQuaternion);
        } else {
          this.rotationQuaternion.cloneTo(this._worldRotationQuaternion);
        }

        this._setDirtyFlagFalse(TransformFlag.WorldQuat);
      }

      return this._worldRotationQuaternion;
    },
    set: function set(value) {
      if (this._worldRotationQuaternion !== value) {
        value.cloneTo(this._worldRotationQuaternion);
      }

      var parent = this._getParentTransform();

      if (parent) {
        Quaternion.invert(parent.worldRotationQuaternion, Transform._tempQuat0);
        Quaternion.multiply(value, Transform._tempQuat0, this._rotationQuaternion);
      } else {
        value.cloneTo(this._rotationQuaternion);
      }

      this.rotationQuaternion = this._rotationQuaternion;

      this._setDirtyFlagFalse(TransformFlag.WorldQuat);
    }
    /**
     * Local scaling.
     * @remarks Need to re-assign after modification to ensure that the modification takes effect.
     */

  }, {
    key: "scale",
    get: function get() {
      return this._scale;
    },
    set: function set(value) {
      if (this._scale !== value) {
        value.cloneTo(this._scale);
      }

      this._setDirtyFlagTrue(TransformFlag.LocalMatrix);

      this._updateWorldScaleFlag();
    }
    /**
     * Local lossy scaling.
     * @remarks The value obtained may not be correct under certain conditions(for example, the parent node has scaling,
     * and the child node has a rotation), the scaling will be tilted. Vector3 cannot be used to correctly represent the scaling. Must use Matrix3x3.
     */

  }, {
    key: "lossyWorldScale",
    get: function get() {
      if (this._isContainDirtyFlag(TransformFlag.WorldScale)) {
        if (this._getParentTransform()) {
          var scaleMat = this._getScaleMatrix();

          var e = scaleMat.elements;

          this._lossyWorldScale.setValue(e[0], e[4], e[8]);
        } else {
          this._scale.cloneTo(this._lossyWorldScale);
        }

        this._setDirtyFlagFalse(TransformFlag.WorldScale);
      }

      return this._lossyWorldScale;
    }
    /**
     * Local matrix.
     * @remarks Need to re-assign after modification to ensure that the modification takes effect.
     */

  }, {
    key: "localMatrix",
    get: function get() {
      if (this._isContainDirtyFlag(TransformFlag.LocalMatrix)) {
        Matrix.affineTransformation(this._scale, this.rotationQuaternion, this._position, this._localMatrix);

        this._setDirtyFlagFalse(TransformFlag.LocalMatrix);
      }

      return this._localMatrix;
    },
    set: function set(value) {
      if (this._localMatrix !== value) {
        value.cloneTo(this._localMatrix);
      }

      this._localMatrix.decompose(this._position, this._rotationQuaternion, this._scale);

      this._setDirtyFlagTrue(TransformFlag.LocalEuler);

      this._setDirtyFlagFalse(TransformFlag.LocalMatrix);

      this._updateAllWorldFlag();
    }
    /**
     * World matrix.
     * @remarks Need to re-assign after modification to ensure that the modification takes effect.
     */

  }, {
    key: "worldMatrix",
    get: function get() {
      if (this._isContainDirtyFlag(TransformFlag.WorldMatrix)) {
        var parent = this._getParentTransform();

        if (parent) {
          Matrix.multiply(parent.worldMatrix, this.localMatrix, this._worldMatrix);
        } else {
          this.localMatrix.cloneTo(this._worldMatrix);
        }

        this._setDirtyFlagFalse(TransformFlag.WorldMatrix);
      }

      return this._worldMatrix;
    },
    set: function set(value) {
      if (this._worldMatrix !== value) {
        value.cloneTo(this._worldMatrix);
      }

      var parent = this._getParentTransform();

      if (parent) {
        Matrix.invert(parent.worldMatrix, Transform._tempMat42);
        Matrix.multiply(value, Transform._tempMat42, this._localMatrix);
      } else {
        value.cloneTo(this._localMatrix);
      }

      this.localMatrix = this._localMatrix;

      this._setDirtyFlagFalse(TransformFlag.WorldMatrix);
    }
  }]);

  return Transform;
}(Component), _class2$7._tempQuat0 = new Quaternion(), _class2$7._tempVec3 = new Vector3(), _class2$7._tempMat30 = new Matrix3x3(), _class2$7._tempMat31 = new Matrix3x3(), _class2$7._tempMat32 = new Matrix3x3(), _class2$7._tempMat40 = new Matrix(), _class2$7._tempMat41 = new Matrix(), _class2$7._tempMat42 = new Matrix(), _class2$7._tempMat43 = new Matrix(), _temp$7), (_descriptor$8 = _applyDecoratedDescriptor(_class$8.prototype, "_position", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vector3();
  }
}), _descriptor2$8 = _applyDecoratedDescriptor(_class$8.prototype, "_rotation", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vector3();
  }
}), _descriptor3$7 = _applyDecoratedDescriptor(_class$8.prototype, "_rotationQuaternion", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Quaternion();
  }
}), _descriptor4$7 = _applyDecoratedDescriptor(_class$8.prototype, "_scale", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vector3(1, 1, 1);
  }
}), _descriptor5$7 = _applyDecoratedDescriptor(_class$8.prototype, "_worldPosition", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vector3();
  }
}), _descriptor6$7 = _applyDecoratedDescriptor(_class$8.prototype, "_worldRotation", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vector3();
  }
}), _descriptor7$5 = _applyDecoratedDescriptor(_class$8.prototype, "_worldRotationQuaternion", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Quaternion();
  }
}), _descriptor8$3 = _applyDecoratedDescriptor(_class$8.prototype, "_lossyWorldScale", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vector3(1, 1, 1);
  }
}), _descriptor9$3 = _applyDecoratedDescriptor(_class$8.prototype, "_localMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor10$3 = _applyDecoratedDescriptor(_class$8.prototype, "_worldMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor11$3 = _applyDecoratedDescriptor(_class$8.prototype, "_updateFlagManager", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new UpdateFlagManager();
  }
}), _descriptor12$3 = _applyDecoratedDescriptor(_class$8.prototype, "_isParentDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return true;
  }
}), _descriptor13$2 = _applyDecoratedDescriptor(_class$8.prototype, "_parentTransformCache", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
})), _class$8);
/**
 * Dirty flag of transform.
 */

var TransformFlag;

(function (TransformFlag) {
  TransformFlag[TransformFlag["LocalEuler"] = 1] = "LocalEuler";
  TransformFlag[TransformFlag["LocalQuat"] = 2] = "LocalQuat";
  TransformFlag[TransformFlag["WorldPosition"] = 4] = "WorldPosition";
  TransformFlag[TransformFlag["WorldEuler"] = 8] = "WorldEuler";
  TransformFlag[TransformFlag["WorldQuat"] = 16] = "WorldQuat";
  TransformFlag[TransformFlag["WorldScale"] = 32] = "WorldScale";
  TransformFlag[TransformFlag["LocalMatrix"] = 64] = "LocalMatrix";
  TransformFlag[TransformFlag["WorldMatrix"] = 128] = "WorldMatrix";
  TransformFlag[TransformFlag["WmWp"] = 132] = "WmWp";
  TransformFlag[TransformFlag["WmWeWq"] = 152] = "WmWeWq";
  TransformFlag[TransformFlag["WmWpWeWq"] = 156] = "WmWpWeWq";
  TransformFlag[TransformFlag["WmWs"] = 160] = "WmWs";
  TransformFlag[TransformFlag["WmWpWs"] = 164] = "WmWpWs";
  TransformFlag[TransformFlag["WmWpWeWqWs"] = 188] = "WmWpWeWqWs";
})(TransformFlag || (TransformFlag = {}));

/**
 * Entity, be used as components container.
 */

var Entity = /*#__PURE__*/function (_EngineObject) {
  _inheritsLoose(Entity, _EngineObject);

  /**
   * @internal
   */
  Entity._findChildByName = function _findChildByName(root, name) {
    var children = root._children;

    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];

      if (child.name === name) {
        return child;
      }
    }

    return null;
  }
  /**
   * @internal
   */
  ;

  Entity._traverseSetOwnerScene = function _traverseSetOwnerScene(entity, scene) {
    entity._scene = scene;
    var children = entity._children;

    for (var i = entity.childCount - 1; i >= 0; i--) {
      this._traverseSetOwnerScene(children[i], scene);
    }
  }
  /** The name of entity. */
  ;

  /**
   * Create a entity.
   * @param engine - The engine the entity belongs to.
   */
  function Entity(engine, name) {
    var _this;

    _this = _EngineObject.call(this, engine) || this;
    _this.name = void 0;
    _this.layer = Layer.Layer0;
    _this.transform = void 0;
    _this._isActiveInHierarchy = false;
    _this._components = [];
    _this._scripts = new DisorderedArray();
    _this._children = [];
    _this._scene = void 0;
    _this._isRoot = false;
    _this._isActive = true;
    _this._parent = null;
    _this._activeChangedComponents = void 0;
    _this._invModelMatrix = new Matrix();
    _this._inverseWorldMatFlag = void 0;
    _this.name = name;
    _this.transform = _this.addComponent(Transform);
    _this._inverseWorldMatFlag = _this.transform.registerWorldChangeFlag();
    return _this;
  }
  /**
   * Add component based on the component type.
   * @param type - The type of the component.
   * @returns	The component which has been added.
   */


  var _proto = Entity.prototype;

  _proto.addComponent = function addComponent(type) {
    ComponentsDependencies._addCheck(this, type);

    var component = new type(this);

    this._components.push(component);

    if (this._isActiveInHierarchy) {
      component._setActive(true);
    }

    return component;
  }
  /**
   * Get component which match the type.
   * @param type - The type of the component.
   * @returns	The first component which match type.
   */
  ;

  _proto.getComponent = function getComponent(type) {
    for (var i = this._components.length - 1; i >= 0; i--) {
      var component = this._components[i];

      if (component instanceof type) {
        return component;
      }
    }
  }
  /**
   * Get components which match the type.
   * @param type - The type of the component.
   * @param results - The components which match type.
   * @returns	The components which match type.
   */
  ;

  _proto.getComponents = function getComponents(type, results) {
    results.length = 0;

    for (var i = this._components.length - 1; i >= 0; i--) {
      var component = this._components[i];

      if (component instanceof type) {
        results.push(component);
      }
    }

    return results;
  }
  /**
   * Get the components which match the type of the entity and it's children.
   * @param type - The component type.
   * @param results - The components collection.
   * @returns	The components collection which match the type.
   */
  ;

  _proto.getComponentsIncludeChildren = function getComponentsIncludeChildren(type, results) {
    results.length = 0;

    this._getComponentsInChildren(type, results);

    return results;
  }
  /**
   * Add child entity.
   * @param child - The child entity which want to be added.
   */
  ;

  _proto.addChild = function addChild(child) {
    child.parent = this;
  }
  /**
   * Remove child entity.
   * @param child - The child entity which want to be removed.
   */
  ;

  _proto.removeChild = function removeChild(child) {
    child.parent = null;
  }
  /**
   * Find child entity by index.
   * @param index - The index of the child entity.
   * @returns	The component which be found.
   */
  ;

  _proto.getChild = function getChild(index) {
    return this._children[index];
  }
  /**
   * Find child entity by name.
   * @param name - The name of the entity which want to be found.
   * @returns The component which be found.
   */
  ;

  _proto.findByName = function findByName(name) {
    var children = this._children;

    var child = Entity._findChildByName(this, name);

    if (child) return child;

    for (var i = children.length - 1; i >= 0; i--) {
      var _child = children[i];

      var grandson = _child.findByName(name);

      if (grandson) {
        return grandson;
      }
    }

    return null;
  }
  /**
   * Find the entity by path.
   * @param path - The path fo the entity eg: /entity.
   * @returns The component which be found.
   */
  ;

  _proto.findByPath = function findByPath(path) {
    var splits = path.split("/");
    var entity = this;

    for (var i = 0, length = splits.length; i < length; ++i) {
      var split = splits[i];

      if (split) {
        entity = Entity._findChildByName(entity, split);

        if (!entity) {
          return null;
        }
      }
    }

    return entity;
  }
  /**
   * Create child entity.
   * @param name - The child entity's name.
   * @returns The child entity.
   */
  ;

  _proto.createChild = function createChild(name) {
    var child = new Entity(this.engine, name);
    child.layer = this.layer;
    child.parent = this;
    return child;
  }
  /**
   * Clear children entities.
   */
  ;

  _proto.clearChildren = function clearChildren() {
    var children = this._children;

    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];
      child._parent = null;
      child._isActiveInHierarchy && child._processInActive();

      Entity._traverseSetOwnerScene(child, null); // Must after child._processInActive().

    }

    children.length = 0;
  }
  /**
   * Clone
   * @returns Cloned entity.
   */
  ;

  _proto.clone = function clone() {
    var cloneEntity = new Entity(this._engine, this.name);
    cloneEntity._isActive = this._isActive;
    cloneEntity.transform.localMatrix = this.transform.localMatrix;
    var children = this._children;

    for (var i = 0, len = this._children.length; i < len; i++) {
      var child = children[i];
      cloneEntity.addChild(child.clone());
    }

    var components = this._components;

    for (var _i = 0, n = components.length; _i < n; _i++) {
      var sourceComp = components[_i];

      if (!(sourceComp instanceof Transform)) {
        var targetComp = cloneEntity.addComponent(sourceComp.constructor);
        ComponentCloner.cloneComponent(sourceComp, targetComp);
      }
    }

    return cloneEntity;
  }
  /**
   * Destroy self.
   */
  ;

  _proto.destroy = function destroy() {
    var abilityArray = this._components;

    for (var i = abilityArray.length - 1; i >= 0; i--) {
      abilityArray[i].destroy();
    }

    this._components.length = 0;
    var children = this._children;

    for (var _i2 = children.length - 1; _i2 >= 0; _i2--) {
      children[_i2].destroy();
    }

    this._children.length = 0;

    if (this._parent != null) {
      var parentChildren = this._parent._children;
      parentChildren.splice(parentChildren.indexOf(this), 1);
    }

    this._parent = null;
  }
  /**
   * @internal
   */
  ;

  _proto._removeComponent = function _removeComponent(component) {
    ComponentsDependencies._removeCheck(this, component.constructor);

    var components = this._components;
    components.splice(components.indexOf(component), 1);
  }
  /**
   * @internal
   */
  ;

  _proto._addScript = function _addScript(script) {
    script._entityCacheIndex = this._scripts.length;

    this._scripts.add(script);
  }
  /**
   * @internal
   */
  ;

  _proto._removeScript = function _removeScript(script) {
    var replaced = this._scripts.deleteByIndex(script._entityCacheIndex);

    replaced && (replaced._entityCacheIndex = script._entityCacheIndex);
    script._entityCacheIndex = -1;
  }
  /**
   * @internal
   */
  ;

  _proto._removeFromParent = function _removeFromParent() {
    var oldParent = this._parent;

    if (oldParent != null) {
      var oldParentChildren = oldParent._children;
      oldParentChildren.splice(oldParentChildren.indexOf(this), 1);
      this._parent = null;
    }

    return oldParent;
  }
  /**
   * @internal
   */
  ;

  _proto._processActive = function _processActive() {
    if (this._activeChangedComponents) {
      throw "Note: can't set the 'main inActive entity' active in hierarchy, if the operation is in main inActive entity or it's children script's onDisable Event.";
    }

    this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();

    this._setActiveInHierarchy(this._activeChangedComponents);

    this._setActiveComponents(true);
  }
  /**
   * @internal
   */
  ;

  _proto._processInActive = function _processInActive() {
    if (this._activeChangedComponents) {
      throw "Note: can't set the 'main active entity' inActive in hierarchy, if the operation is in main active entity or it's children script's onEnable Event.";
    }

    this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();

    this._setInActiveInHierarchy(this._activeChangedComponents);

    this._setActiveComponents(false);
  };

  _proto._getComponentsInChildren = function _getComponentsInChildren(type, results) {
    for (var i = this._components.length - 1; i >= 0; i--) {
      var component = this._components[i];

      if (component instanceof type) {
        results.push(component);
      }
    }

    for (var _i3 = this._children.length - 1; _i3 >= 0; _i3--) {
      this._children[_i3]._getComponentsInChildren(type, results);
    }
  };

  _proto._setActiveComponents = function _setActiveComponents(isActive) {
    var activeChangedComponents = this._activeChangedComponents;

    for (var i = 0, length = activeChangedComponents.length; i < length; ++i) {
      activeChangedComponents[i]._setActive(isActive);
    }

    this._engine._componentsManager.putActiveChangedTempList(activeChangedComponents);

    this._activeChangedComponents = null;
  };

  _proto._setActiveInHierarchy = function _setActiveInHierarchy(activeChangedComponents) {
    this._isActiveInHierarchy = true;
    var components = this._components;

    for (var i = components.length - 1; i >= 0; i--) {
      activeChangedComponents.push(components[i]);
    }

    var children = this._children;

    for (var _i4 = children.length - 1; _i4 >= 0; _i4--) {
      var child = children[_i4];
      child.isActive && child._setActiveInHierarchy(activeChangedComponents);
    }
  };

  _proto._setInActiveInHierarchy = function _setInActiveInHierarchy(activeChangedComponents) {
    this._isActiveInHierarchy = false;
    var components = this._components;

    for (var i = components.length - 1; i >= 0; i--) {
      activeChangedComponents.push(components[i]);
    }

    var children = this._children;

    for (var _i5 = children.length - 1; _i5 >= 0; _i5--) {
      var child = children[_i5];
      child.isActive && child._setInActiveInHierarchy(activeChangedComponents);
    }
  };

  _proto._setTransformDirty = function _setTransformDirty() {
    if (this.transform) {
      this.transform._parentChange();
    } else {
      for (var i = 0, len = this._children.length; i < len; i++) {
        this._children[i]._setTransformDirty();
      }
    }
  } //--------------------------------------------------------------deprecated----------------------------------------------------------------
  ;

  /**
   * @deprecated
   */
  _proto.getInvModelMatrix = function getInvModelMatrix() {
    if (this._inverseWorldMatFlag.flag) {
      Matrix.invert(this.transform.worldMatrix, this._invModelMatrix);
      this._inverseWorldMatFlag.flag = false;
    }

    return this._invModelMatrix;
  };

  _createClass(Entity, [{
    key: "isActive",
    get:
    /**
     * Whether to activate locally.
     */
    function get() {
      return this._isActive;
    },
    set: function set(value) {
      if (value !== this._isActive) {
        this._isActive = value;

        if (value) {
          var parent = this._parent;

          if (parent !== null && parent !== void 0 && parent._isActiveInHierarchy || this._isRoot && this._scene._isActiveInEngine) {
            this._processActive();
          }
        } else {
          if (this._isActiveInHierarchy) {
            this._processInActive();
          }
        }
      }
    }
    /**
     * Whether it is active in the hierarchy.
     */

  }, {
    key: "isActiveInHierarchy",
    get: function get() {
      return this._isActiveInHierarchy;
    }
    /**
     * The parent entity.
     */

  }, {
    key: "parent",
    get: function get() {
      return this._parent;
    },
    set: function set(entity) {
      if (entity !== this._parent) {
        var oldParent = this._removeFromParent();

        var newParent = this._parent = entity;

        if (newParent) {
          newParent._children.push(this);

          var parentScene = newParent._scene;

          if (this._scene !== parentScene) {
            Entity._traverseSetOwnerScene(this, parentScene);
          }

          if (newParent._isActiveInHierarchy) {
            !this._isActiveInHierarchy && this._isActive && this._processActive();
          } else {
            this._isActiveInHierarchy && this._processInActive();
          }
        } else {
          this._isActiveInHierarchy && this._processInActive();

          if (oldParent) {
            Entity._traverseSetOwnerScene(this, null);
          }
        }

        this._setTransformDirty();
      }
    }
    /**
     * The children entities
     */

  }, {
    key: "children",
    get: function get() {
      return this._children;
    }
    /**
     * Number of the children entities
     */

  }, {
    key: "childCount",
    get: function get() {
      return this._children.length;
    }
    /**
     * The scene the entity belongs to.
     */

  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }, {
    key: "position",
    get:
    /**
     * @deprecated
     * Use transform.position instead.
     */
    function get() {
      return this.transform.position;
    },
    set: function set(val) {
      this.transform.position = val;
    }
    /**
     * @deprecated
     * Use transform.worldPosition instead.
     */

  }, {
    key: "worldPosition",
    get: function get() {
      return this.transform.worldPosition;
    },
    set: function set(val) {
      this.transform.worldPosition = val;
    }
    /**
     * @deprecated
     * Use transform.rotationQuaternion instead.
     */

  }, {
    key: "rotation",
    get: function get() {
      return this.transform.rotationQuaternion;
    },
    set: function set(val) {
      this.transform.rotationQuaternion = val;
    }
    /**
     * @deprecated
     * Use transform.scale instead.
     */

  }, {
    key: "scale",
    get: function get() {
      return this.transform.scale;
    },
    set: function set(val) {
      this.transform.scale = val;
    }
  }]);

  return Entity;
}(EngineObject);

/**
 * Manage a set of feature objects.
 */
var FeatureManager = /*#__PURE__*/function () {
  function FeatureManager() {
    this._features = [];
    this._objects = [];
  }

  var _proto = FeatureManager.prototype;

  /**
   * Register a feature.
   * @param {SceneFeature|EngineFeature} IFeature
   */
  _proto.registerFeature = function registerFeature(IFeature) {
    var featureArray = this._features; // Search by type, avoid adding

    for (var i = 0, len = featureArray.length; i < len; i++) {
      if (featureArray[i] === IFeature) {
        return;
      }
    } // Add to global array


    featureArray.push(IFeature); // Add to existing scene

    var objectArray = this._objects;

    for (var _i = 0, _len = objectArray.length; _i < _len; _i++) {
      objectArray[_i].features.push(new IFeature());
    }
  }
  /**
   * Add an feature with functional characteristics.
   * @param {Scene|Engine} obj - Scene or engine
   */
  ;

  _proto.addObject = function addObject(obj) {
    obj.features = [];

    for (var i = 0, len = this._features.length; i < len; i++) {
      var _engine;

      obj.features.push(new this._features[i]((_engine = obj.engine) != null ? _engine : obj));
    }

    this._objects.push(obj);
  }
  /**
   * Call the specified method of the feature.
   * @param obj - Scene or engine
   * @param method - Method name
   * @param args - Function args
   */
  ;

  _proto.callFeatureMethod = function callFeatureMethod(obj, method, args) {
    var features = obj.features;
    var count = features.length;

    for (var i = 0; i < count; i++) {
      var feature = features[i];

      if (feature[method]) {
        feature[method].apply(feature, args);
      }
    }
  }
  /**
   * Find feature.
   * @param obj - Scene or engine
   * @param IFeature - plug-in
   */
  ;

  _proto.findFeature = function findFeature(obj, IFeature) {
    var features = obj.features;
    var count = features.length;

    for (var i = 0; i < count; i++) {
      var feature = features[i];

      if (feature.constructor === IFeature) {
        return feature;
      }
    }

    return undefined;
  };

  return FeatureManager;
}();

/**
 * Render queue type.
 */
var RenderQueueType;

(function (RenderQueueType) {
  RenderQueueType[RenderQueueType["Opaque"] = 1000] = "Opaque";
  RenderQueueType[RenderQueueType["AlphaTest"] = 2000] = "AlphaTest";
  RenderQueueType[RenderQueueType["Transparent"] = 3000] = "Transparent";
})(RenderQueueType || (RenderQueueType = {}));

/**
 * The base class of assets, with reference counting capability.
 */
var RefObject = /*#__PURE__*/function (_EngineObject) {
  _inheritsLoose(RefObject, _EngineObject);

  function RefObject(engine) {
    var _this;

    _this = _EngineObject.call(this, engine) || this;
    _this.isGCIgnored = false;
    _this._refCount = 0;
    _this._destroyed = false;

    engine.resourceManager._addRefObject(_this.instanceId, _assertThisInitialized(_this));

    return _this;
  }
  /**
   * Destroy self.
   * @param force - Whether to force the destruction, if it is false, refCount = 0 can be released successfully.
   * @returns Whether the release was successful.
   */


  var _proto = RefObject.prototype;

  _proto.destroy = function destroy(force) {
    if (force === void 0) {
      force = false;
    }

    if (this._destroyed) return true;
    if (!force && this._refCount !== 0) return false;
    var resourceManager = this._engine.resourceManager; // resourceManager maybe null,because engine has destroyed.
    // TODO:the right way to fix this is to ensure destroy all when call engine.destroy,thus don't need to add this project.

    if (resourceManager) {
      resourceManager._deleteAsset(this);

      resourceManager._deleteRefObject(this.instanceId);
    }

    var refCount = this._getRefCount();

    if (refCount > 0) {
      this._addRefCount(-refCount);
    }

    this._engine = null;

    this._onDestroy();

    this._destroyed = true;
    return true;
  }
  /**
   * @internal
   */
  ;

  _proto._getRefCount = function _getRefCount() {
    return this._refCount;
  }
  /**
   * @internal
   * Add reference resource.
   */
  ;

  _proto._addRefCount = function _addRefCount(value) {
    this._refCount += value;
  }
  /**
   * @internal
   * Remove reference resource.
   */
  ;

  _proto._addToResourceManager = function _addToResourceManager(path) {
    this._engine.resourceManager._addAsset(path, this);
  }
  /**
   * Called when the resource is destroyed.
   * Subclasses can override this function.
   */
  ;

  _createClass(RefObject, [{
    key: "refCount",
    get:
    /** Whether to ignore the garbage collection check, if it is true, it will not be affected by ResourceManager.gc(). */

    /**
     * Counted by valid references.
     */
    function get() {
      return this._refCount;
    }
    /**
     * Whether it has been destroyed.
     */

  }, {
    key: "destroyed",
    get: function get() {
      return this._destroyed;
    }
  }]);

  return RefObject;
}(EngineObject);

/**
 * Shader data grouping.
 */
var ShaderDataGroup;

(function (ShaderDataGroup) {
  ShaderDataGroup[ShaderDataGroup["Scene"] = 0] = "Scene";
  ShaderDataGroup[ShaderDataGroup["Camera"] = 1] = "Camera";
  ShaderDataGroup[ShaderDataGroup["Renderer"] = 2] = "Renderer";
  ShaderDataGroup[ShaderDataGroup["Material"] = 3] = "Material";
})(ShaderDataGroup || (ShaderDataGroup = {}));

/**
 * The base class of texture, contains some common functions of texture-related classes.
 */
var Texture = /*#__PURE__*/function (_RefObject) {
  _inheritsLoose(Texture, _RefObject);

  function Texture() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _RefObject.call.apply(_RefObject, [this].concat(args)) || this;
    _this.name = void 0;
    _this._platformTexture = void 0;
    _this._mipmap = void 0;
    _this._width = void 0;
    _this._height = void 0;
    _this._mipmapCount = void 0;
    _this._wrapModeU = void 0;
    _this._wrapModeV = void 0;
    _this._filterMode = void 0;
    _this._anisoLevel = 1;
    return _this;
  }

  var _proto = Texture.prototype;

  /**
   * Generate multi-level textures based on the 0th level data.
   */
  _proto.generateMipmaps = function generateMipmaps() {
    if (!this._mipmap) return;

    this._platformTexture.generateMipmaps();
  }
  /**
   * @override
   */
  ;

  _proto._onDestroy = function _onDestroy() {
    this._platformTexture.destroy();

    this._platformTexture = null;
  }
  /**
   * Get the maximum mip level of the corresponding size:rounding down.
   * @remarks http://download.nvidia.com/developer/Papers/2005/NP2_Mipmapping/NP2_Mipmap_Creation.pdf
   */
  ;

  _proto._getMaxMiplevel = function _getMaxMiplevel(size) {
    return Math.floor(Math.log2(size));
  };

  _proto._getMipmapCount = function _getMipmapCount() {
    return this._mipmap ? Math.floor(Math.log2(Math.max(this._width, this._height))) + 1 : 1;
  };

  _createClass(Texture, [{
    key: "width",
    get:
    /**
     * The width of the texture.
     */
    function get() {
      return this._width;
    }
    /**
     * The height of the texture.
     */

  }, {
    key: "height",
    get: function get() {
      return this._height;
    }
    /**
     * Wrapping mode for texture coordinate S.
     */

  }, {
    key: "wrapModeU",
    get: function get() {
      return this._wrapModeU;
    },
    set: function set(value) {
      if (value === this._wrapModeU) return;
      this._wrapModeU = value;
      this._platformTexture.wrapModeU = value;
    }
    /**
     * Wrapping mode for texture coordinate T.
     */

  }, {
    key: "wrapModeV",
    get: function get() {
      return this._wrapModeV;
    },
    set: function set(value) {
      if (value === this._wrapModeV) return;
      this._wrapModeV = value;
      this._platformTexture.wrapModeV = value;
    }
    /**
     * Texture mipmapping count.
     */

  }, {
    key: "mipmapCount",
    get: function get() {
      return this._mipmapCount;
    }
    /**
     * Filter mode for texture.
     */

  }, {
    key: "filterMode",
    get: function get() {
      return this._filterMode;
    },
    set: function set(value) {
      if (value === this._filterMode) return;
      this._filterMode = value;
      this._platformTexture.filterMode = value;
    }
    /**
     * Anisotropic level for texture.
     */

  }, {
    key: "anisoLevel",
    get: function get() {
      return this._anisoLevel;
    },
    set: function set(value) {
      var max = this._engine._hardwareRenderer.capability.maxAnisoLevel;

      if (value > max) {
        Logger.warn("anisoLevel:" + value + ", exceeds the limit and is automatically downgraded to:" + max);
        value = max;
      }

      if (value < 1) {
        Logger.warn("anisoLevel:" + value + ", must be greater than 0, and is automatically downgraded to 1");
        value = 1;
      }

      if (value === this._anisoLevel) return;
      this._anisoLevel = value;
      this._platformTexture.anisoLevel = value;
    }
  }]);

  return Texture;
}(RefObject);

var common = "#define GLSLIFY 1\n#define PI 3.14159265359\n#define LOG2 1.442695\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n"; // eslint-disable-line

var common_vert = "#define GLSLIFY 1\nattribute vec3 POSITION;\n#ifdef O3_HAS_UV\nattribute vec2 TEXCOORD_0;\n#endif\n#ifdef O3_HAS_SKIN\nattribute vec4 JOINTS_0;attribute vec4 WEIGHTS_0;\n#ifdef O3_USE_JOINT_TEXTURE\nuniform sampler2D u_jointSampler;uniform float u_jointCount;mat4 getJointMatrix(sampler2D smp,float index){float base=index/u_jointCount;float hf=0.5/u_jointCount;float v=base+hf;vec4 m0=texture2D(smp,vec2(0.125,v));vec4 m1=texture2D(smp,vec2(0.375,v));vec4 m2=texture2D(smp,vec2(0.625,v));vec4 m3=texture2D(smp,vec2(0.875,v));return mat4(m0,m1,m2,m3);}\n#else\nuniform mat4 u_jointMatrix[O3_JOINTS_NUM];\n#endif\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\nattribute vec4 COLOR_0;\n#endif\nuniform mat4 u_localMat;uniform mat4 u_modelMat;uniform mat4 u_viewMat;uniform mat4 u_projMat;uniform mat4 u_MVMat;uniform mat4 u_MVPMat;uniform mat4 u_normalMat;uniform vec3 u_cameraPos;uniform vec4 u_tilingOffset;\n#ifndef OMIT_NORMAL\n#ifdef O3_HAS_NORMAL\nattribute vec3 NORMAL;\n#endif\n#ifdef O3_HAS_TANGENT\nattribute vec4 TANGENT;\n#endif\n#endif\n"; // eslint-disable-line

var common_frag = "#define GLSLIFY 1\nuniform O3_VERTEX_PRECISION mat4 u_localMat;uniform O3_VERTEX_PRECISION mat4 u_modelMat;uniform O3_VERTEX_PRECISION mat4 u_viewMat;uniform O3_VERTEX_PRECISION mat4 u_projMat;uniform O3_VERTEX_PRECISION mat4 u_MVMat;uniform O3_VERTEX_PRECISION mat4 u_MVPMat;uniform O3_VERTEX_PRECISION mat4 u_normalMat;uniform O3_VERTEX_PRECISION vec3 u_cameraPos;"; // eslint-disable-line

var color_share = "#define GLSLIFY 1\n#ifdef O3_HAS_VERTEXCOLOR\nvarying vec4 v_color;\n#endif\n"; // eslint-disable-line

var normal_share = "#define GLSLIFY 1\n#ifdef O3_HAS_NORMAL\n#if defined( O3_HAS_TANGENT ) && defined( O3_NORMAL_TEXTURE )\nvarying mat3 v_TBN;\n#else\nvarying vec3 v_normal;\n#endif\n#endif\n"; // eslint-disable-line

var uv_share = "#define GLSLIFY 1\nvarying vec2 v_uv;"; // eslint-disable-line

var worldpos_share = "#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvarying vec3 v_pos;\n#endif\n"; // eslint-disable-line

var shadow_share = "#define GLSLIFY 1\n#ifdef O3_GENERATE_SHADOW_MAP\nuniform mat4 u_viewMatFromLight;uniform mat4 u_projMatFromLight;\n#endif\n#ifdef O3_SHADOW_MAP_COUNT\nuniform mat4 u_viewMatFromLight[O3_SHADOW_MAP_COUNT];uniform mat4 u_projMatFromLight[O3_SHADOW_MAP_COUNT];varying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];\n#endif\n"; // eslint-disable-line

var fog_share = "#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nvarying vec3 v_fogDepth;uniform O3_VERTEX_PRECISION vec3 u_fogColor;\n#ifdef O3_FOG_EXP2\nuniform O3_VERTEX_PRECISION float u_fogDensity;\n#else\nuniform O3_VERTEX_PRECISION float u_fogNear;uniform O3_VERTEX_PRECISION float u_fogFar;\n#endif\n#endif\n"; // eslint-disable-line

var begin_normal_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_NORMAL\nvec3 normal=vec3(NORMAL);\n#if defined( O3_HAS_TANGENT ) && defined( O3_NORMAL_TEXTURE )\nvec4 tangent=vec4(TANGENT);\n#endif\n#endif\n"; // eslint-disable-line

var begin_position_vert = "#define GLSLIFY 1\nvec4 position=vec4(POSITION,1.0);"; // eslint-disable-line

var position_vert = "#define GLSLIFY 1\n#ifndef O3_GENERATE_SHADOW_MAP\ngl_Position=u_MVPMat*position;\n#endif\n"; // eslint-disable-line

var color_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_VERTEXCOLOR\nv_color=COLOR_0;\n#endif\n"; // eslint-disable-line

var normal_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_NORMAL\n#if defined( O3_HAS_TANGENT ) && defined( O3_NORMAL_TEXTURE )\nvec3 normalW=normalize(mat3(u_normalMat)*normal.xyz);vec3 tangentW=normalize(mat3(u_normalMat)*tangent.xyz);vec3 bitangentW=cross(normalW,tangentW)*tangent.w;v_TBN=mat3(tangentW,bitangentW,normalW);\n#else\nv_normal=normalize(mat3(u_normalMat)*normal);\n#endif\n#endif\n"; // eslint-disable-line

var skinning_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_SKIN\n#ifdef O3_USE_JOINT_TEXTURE\nmat4 skinMatrix=WEIGHTS_0.x*getJointMatrix(u_jointSampler,JOINTS_0.x)+WEIGHTS_0.y*getJointMatrix(u_jointSampler,JOINTS_0.y)+WEIGHTS_0.z*getJointMatrix(u_jointSampler,JOINTS_0.z)+WEIGHTS_0.w*getJointMatrix(u_jointSampler,JOINTS_0.w);\n#else\nmat4 skinMatrix=WEIGHTS_0.x*u_jointMatrix[int(JOINTS_0.x)]+WEIGHTS_0.y*u_jointMatrix[int(JOINTS_0.y)]+WEIGHTS_0.z*u_jointMatrix[int(JOINTS_0.z)]+WEIGHTS_0.w*u_jointMatrix[int(JOINTS_0.w)];\n#endif\nposition=skinMatrix*position;\n#if defined(O3_HAS_NORMAL) && !defined(OMIT_NORMAL)\nnormal=vec4(skinMatrix*vec4(normal,0.0)).xyz;\n#if defined( O3_HAS_TANGENT ) && defined( O3_NORMAL_TEXTURE )\ntangent.xyz=vec4(skinMatrix*vec4(tangent.xyz,0.0)).xyz;\n#endif\n#endif\n#endif\n"; // eslint-disable-line

var blendShape_input = "#define GLSLIFY 1\n#ifdef OASIS_BLENDSHAPE\n#ifndef OASIS_BLENDSHAPE_TEXTURE\nattribute vec3 POSITION_BS0;attribute vec3 POSITION_BS1;attribute vec3 POSITION_BS2;attribute vec3 POSITION_BS3;\n#ifdef OASIS_BLENDSHAPE_NORMAL\nattribute vec3 NORMAL_BS0;attribute vec3 NORMAL_BS1;attribute vec3 NORMAL_BS2;attribute vec3 NORMAL_BS3;\n#endif\n#ifdef OASIS_BLENDSHAPE_TANGENT\nattribute vec3 TANGENT_BS0;attribute vec3 TANGENT_BS1;attribute vec3 TANGENT_BS2;attribute vec3 TANGENT_BS3;\n#endif\n#endif\nuniform float u_blendShapeWeights[4];\n#endif\n"; // eslint-disable-line

var blendShape_vert = "#define GLSLIFY 1\n#ifdef OASIS_BLENDSHAPE\n#ifdef OASIS_BLENDSHAPE_TEXTURE\n#else\nposition.xyz+=POSITION_BS0*u_blendShapeWeights[0];position.xyz+=POSITION_BS1*u_blendShapeWeights[1];position.xyz+=POSITION_BS2*u_blendShapeWeights[2];position.xyz+=POSITION_BS3*u_blendShapeWeights[3];\n#if defined( O3_HAS_NORMAL ) && defined( OASIS_BLENDSHAPE_NORMAL )\nnormal.xyz+=NORMAL_BS0*u_blendShapeWeights[0];normal.xyz+=NORMAL_BS1*u_blendShapeWeights[1];normal.xyz+=NORMAL_BS2*u_blendShapeWeights[2];normal.xyz+=NORMAL_BS3*u_blendShapeWeights[3];\n#endif\n#if defined( O3_HAS_TANGENT ) && defined( O3_NORMAL_TEXTURE ) && defined(OASIS_BLENDSHAPE_TANGENT)\ntangent.xyz+=TANGENT_BS0*u_blendShapeWeights[0];tangent.xyz+=TANGENT_BS1*u_blendShapeWeights[1];tangent.xyz+=TANGENT_BS2*u_blendShapeWeights[2];tangent.xyz+=TANGENT_BS3*u_blendShapeWeights[3];\n#endif\n#endif\n#endif\n"; // eslint-disable-line

var uv_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_UV\nv_uv=TEXCOORD_0;\n#else\nv_uv=vec2(0.,0.);\n#endif\n#ifdef O3_NEED_TILINGOFFSET\nv_uv=v_uv*u_tilingOffset.xy+u_tilingOffset.zw;\n#endif\n"; // eslint-disable-line

var worldpos_vert = "#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvec4 temp_pos=u_modelMat*position;v_pos=temp_pos.xyz/temp_pos.w;\n#endif\n"; // eslint-disable-line

var shadow_vert = "#define GLSLIFY 1\n#ifdef O3_GENERATE_SHADOW_MAP\ngl_Position=u_projMatFromLight*u_viewMatFromLight*u_modelMat*position;\n#endif\n#ifdef O3_SHADOW_MAP_COUNT\nfor(int i=0;i<O3_SHADOW_MAP_COUNT;i++){v_PositionFromLight[i]=u_projMatFromLight[i]*u_viewMatFromLight[i]*u_modelMat*vec4(POSITION,1.0);}\n#endif\n"; // eslint-disable-line

var fog_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nv_fogDepth=(u_MVMat*position).xyz;\n#endif\n"; // eslint-disable-line

var direct_light_frag = "#define GLSLIFY 1\n#ifdef O3_DIRECT_LIGHT_COUNT\nstruct DirectLight{vec3 color;vec3 direction;};uniform vec3 u_directLightColor[O3_DIRECT_LIGHT_COUNT];uniform vec3 u_directLightDirection[O3_DIRECT_LIGHT_COUNT];\n#endif\n"; // eslint-disable-line

var point_light_frag = "#define GLSLIFY 1\n#ifdef O3_POINT_LIGHT_COUNT\nstruct PointLight{vec3 color;vec3 position;float distance;};uniform vec3 u_pointLightColor[O3_POINT_LIGHT_COUNT];uniform vec3 u_pointLightPosition[O3_POINT_LIGHT_COUNT];uniform float u_pointLightDistance[O3_POINT_LIGHT_COUNT];\n#endif\n"; // eslint-disable-line

var spot_light_frag = "#define GLSLIFY 1\n#ifdef O3_SPOT_LIGHT_COUNT\nstruct SpotLight{vec3 color;vec3 position;vec3 direction;float distance;float angleCos;float penumbraCos;};uniform vec3 u_spotLightColor[O3_SPOT_LIGHT_COUNT];uniform vec3 u_spotLightPosition[O3_SPOT_LIGHT_COUNT];uniform vec3 u_spotLightDirection[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightDistance[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightAngleCos[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightPenumbraCos[O3_SPOT_LIGHT_COUNT];\n#endif\n"; // eslint-disable-line

var mobile_material_frag = "#define GLSLIFY 1\nuniform vec4 u_emissiveColor;uniform vec4 u_diffuseColor;uniform vec4 u_specularColor;uniform float u_shininess;uniform float u_normalIntensity;uniform float u_alphaCutoff;\n#ifdef O3_EMISSIVE_TEXTURE\nuniform sampler2D u_emissiveTexture;\n#endif\n#ifdef O3_DIFFUSE_TEXTURE\nuniform sampler2D u_diffuseTexture;\n#endif\n#ifdef O3_SPECULAR_TEXTURE\nuniform sampler2D u_specularTexture;\n#endif\n#ifdef O3_NORMAL_TEXTURE\nuniform sampler2D u_normalTexture;\n#endif\n"; // eslint-disable-line

var fog_frag = "#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nfloat fogDepth=length(v_fogDepth);\n#ifdef O3_FOG_EXP2\nfloat fogFactor=whiteCompliment(exp2(-u_fogDensity*u_fogDensity*fogDepth*fogDepth*LOG2));\n#else\nfloat fogFactor=smoothstep(u_fogNear,u_fogFar,fogDepth);\n#endif\ngl_FragColor.rgb=mix(gl_FragColor.rgb,u_fogColor,fogFactor);\n#endif\n"; // eslint-disable-line

var begin_mobile_frag = "#define GLSLIFY 1\nvec4 ambient=vec4(0.0);vec4 emission=u_emissiveColor;vec4 diffuse=u_diffuseColor;vec4 specular=u_specularColor;\n#ifdef O3_EMISSIVE_TEXTURE\nemission*=texture2D(u_emissiveTexture,v_uv);\n#endif\n#ifdef O3_DIFFUSE_TEXTURE\ndiffuse*=texture2D(u_diffuseTexture,v_uv);\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\ndiffuse*=v_color;\n#endif\n#ifdef O3_SPECULAR_TEXTURE\nspecular*=texture2D(u_specularTexture,v_uv);\n#endif\nambient=vec4(u_envMapLight.diffuse*u_envMapLight.diffuseIntensity,1.0)*diffuse;"; // eslint-disable-line

var begin_viewdir_frag = "#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvec3 V=normalize(u_cameraPos-v_pos);\n#endif\n"; // eslint-disable-line

var mobile_blinnphong_frag = "#define GLSLIFY 1\nvec3 N=getNormal();vec3 lightDiffuse=vec3(0.0,0.0,0.0);vec3 lightSpecular=vec3(0.0,0.0,0.0);\n#ifdef O3_DIRECT_LIGHT_COUNT\nDirectLight directionalLight;for(int i=0;i<O3_DIRECT_LIGHT_COUNT;i++){directionalLight.color=u_directLightColor[i];directionalLight.direction=u_directLightDirection[i];float d=max(dot(N,-directionalLight.direction),0.0);lightDiffuse+=directionalLight.color*d;vec3 halfDir=normalize(V-directionalLight.direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess);lightSpecular+=directionalLight.color*s;}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nPointLight pointLight;for(int i=0;i<O3_POINT_LIGHT_COUNT;i++){pointLight.color=u_pointLightColor[i];pointLight.position=u_pointLightPosition[i];pointLight.distance=u_pointLightDistance[i];vec3 direction=v_pos-pointLight.position;float dist=length(direction);direction/=dist;float decay=clamp(1.0-pow(dist/pointLight.distance,4.0),0.0,1.0);float d=max(dot(N,-direction),0.0)*decay;lightDiffuse+=pointLight.color*d;vec3 halfDir=normalize(V-direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess)*decay;lightSpecular+=pointLight.color*s;}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nSpotLight spotLight;for(int i=0;i<O3_SPOT_LIGHT_COUNT;i++){spotLight.color=u_spotLightColor[i];spotLight.position=u_spotLightPosition[i];spotLight.direction=u_spotLightDirection[i];spotLight.distance=u_spotLightDistance[i];spotLight.angleCos=u_spotLightAngleCos[i];spotLight.penumbraCos=u_spotLightPenumbraCos[i];vec3 direction=spotLight.position-v_pos;float lightDistance=length(direction);direction/=lightDistance;float angleCos=dot(direction,-spotLight.direction);float decay=clamp(1.0-pow(lightDistance/spotLight.distance,4.0),0.0,1.0);float spotEffect=smoothstep(spotLight.penumbraCos,spotLight.angleCos,angleCos);float decayTotal=decay*spotEffect;float d=max(dot(N,direction),0.0)*decayTotal;lightDiffuse+=spotLight.color*d;vec3 halfDir=normalize(V+direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess)*decayTotal;lightSpecular+=spotLight.color*s;}\n#endif\ndiffuse*=vec4(lightDiffuse,1.0);specular*=vec4(lightSpecular,1.0);\n#ifdef ALPHA_CUTOFF\nif(diffuse.a<u_alphaCutoff){discard;}\n#endif\n"; // eslint-disable-line

var noise_common = "#define GLSLIFY 1\nvec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec2 mod289(vec2 x){return x-floor(x*(1.0/289.0))*289.0;}float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod7(vec4 x){return x-floor(x*(1.0/7.0))*7.0;}vec3 mod7(vec3 x){return x-floor(x*(1.0/7.0))*7.0;}vec4 permute(vec4 x){return mod289((34.0*x+1.0)*x);}vec3 permute(vec3 x){return mod289((34.0*x+1.0)*x);}float permute(float x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}vec4 fade(vec4 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec2 fade(vec2 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}\n#define K 0.142857142857\n#define Ko 0.428571428571\n#define K2 0.020408163265306\n#define Kd2 0.0714285714285\n#define Kz 0.166666666667\n#define Kzo 0.416666666667\n#define jitter 1.0\n#define jitter1 0.8\n"; // eslint-disable-line

var noise_cellular_2D = "#define GLSLIFY 1\nvec2 cellular(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec3 oi=vec3(-1.0,0.0,1.0);vec3 of=vec3(-0.5,0.5,1.5);vec3 px=permute(Pi.x+oi);vec3 p=permute(px.x+Pi.y+oi);vec3 ox=fract(p*K)-Ko;vec3 oy=mod7(floor(p*K))*K-Ko;vec3 dx=Pf.x+0.5+jitter*ox;vec3 dy=Pf.y-of+jitter*oy;vec3 d1=dx*dx+dy*dy;p=permute(px.y+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-0.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d2=dx*dx+dy*dy;p=permute(px.z+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-1.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d3=dx*dx+dy*dy;vec3 d1a=min(d1,d2);d2=max(d1,d2);d2=min(d2,d3);d1=min(d1a,d2);d2=max(d1a,d2);d1.xy=(d1.x<d1.y)? d1.xy : d1.yx;d1.xz=(d1.x<d1.z)? d1.xz : d1.zx;d1.yz=min(d1.yz,d2.yz);d1.y=min(d1.y,d1.z);d1.y=min(d1.y,d2.x);return sqrt(d1.xy);}"; // eslint-disable-line

var noise_cellular_2x2 = "#define GLSLIFY 1\nvec2 cellular2x2(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec4 Pfx=Pf.x+vec4(-0.5,-1.5,-0.5,-1.5);vec4 Pfy=Pf.y+vec4(-0.5,-0.5,-1.5,-1.5);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 ox=mod7(p)*K+Kd2;vec4 oy=mod7(floor(p*K))*K+Kd2;vec4 dx=Pfx+jitter1*ox;vec4 dy=Pfy+jitter1*oy;vec4 d=dx*dx+dy*dy;d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.y=min(d.y,d.z);d.y=min(d.y,d.w);return sqrt(d.xy);}"; // eslint-disable-line

var noise_cellular_2x2x2 = "#define GLSLIFY 1\nvec2 cellular2x2x2(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P);vec4 Pfx=Pf.x+vec4(0.0,-1.0,0.0,-1.0);vec4 Pfy=Pf.y+vec4(0.0,0.0,-1.0,-1.0);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 p1=permute(p+Pi.z);vec4 p2=permute(p+Pi.z+vec4(1.0));vec4 ox1=fract(p1*K)-Ko;vec4 oy1=mod7(floor(p1*K))*K-Ko;vec4 oz1=floor(p1*K2)*Kz-Kzo;vec4 ox2=fract(p2*K)-Ko;vec4 oy2=mod7(floor(p2*K))*K-Ko;vec4 oz2=floor(p2*K2)*Kz-Kzo;vec4 dx1=Pfx+jitter1*ox1;vec4 dy1=Pfy+jitter1*oy1;vec4 dz1=Pf.z+jitter1*oz1;vec4 dx2=Pfx+jitter1*ox2;vec4 dy2=Pfy+jitter1*oy2;vec4 dz2=Pf.z-1.0+jitter1*oz2;vec4 d1=dx1*dx1+dy1*dy1+dz1*dz1;vec4 d2=dx2*dx2+dy2*dy2+dz2*dz2;vec4 d=min(d1,d2);d2=max(d1,d2);d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.yzw=min(d.yzw,d2.yzw);d.y=min(d.y,d.z);d.y=min(d.y,d.w);d.y=min(d.y,d2.x);return sqrt(d.xy);}"; // eslint-disable-line

var noise_cellular_3D = "#define GLSLIFY 1\nvec2 cellular(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P)-0.5;vec3 Pfx=Pf.x+vec3(1.0,0.0,-1.0);vec3 Pfy=Pf.y+vec3(1.0,0.0,-1.0);vec3 Pfz=Pf.z+vec3(1.0,0.0,-1.0);vec3 p=permute(Pi.x+vec3(-1.0,0.0,1.0));vec3 p1=permute(p+Pi.y-1.0);vec3 p2=permute(p+Pi.y);vec3 p3=permute(p+Pi.y+1.0);vec3 p11=permute(p1+Pi.z-1.0);vec3 p12=permute(p1+Pi.z);vec3 p13=permute(p1+Pi.z+1.0);vec3 p21=permute(p2+Pi.z-1.0);vec3 p22=permute(p2+Pi.z);vec3 p23=permute(p2+Pi.z+1.0);vec3 p31=permute(p3+Pi.z-1.0);vec3 p32=permute(p3+Pi.z);vec3 p33=permute(p3+Pi.z+1.0);vec3 ox11=fract(p11*K)-Ko;vec3 oy11=mod7(floor(p11*K))*K-Ko;vec3 oz11=floor(p11*K2)*Kz-Kzo;vec3 ox12=fract(p12*K)-Ko;vec3 oy12=mod7(floor(p12*K))*K-Ko;vec3 oz12=floor(p12*K2)*Kz-Kzo;vec3 ox13=fract(p13*K)-Ko;vec3 oy13=mod7(floor(p13*K))*K-Ko;vec3 oz13=floor(p13*K2)*Kz-Kzo;vec3 ox21=fract(p21*K)-Ko;vec3 oy21=mod7(floor(p21*K))*K-Ko;vec3 oz21=floor(p21*K2)*Kz-Kzo;vec3 ox22=fract(p22*K)-Ko;vec3 oy22=mod7(floor(p22*K))*K-Ko;vec3 oz22=floor(p22*K2)*Kz-Kzo;vec3 ox23=fract(p23*K)-Ko;vec3 oy23=mod7(floor(p23*K))*K-Ko;vec3 oz23=floor(p23*K2)*Kz-Kzo;vec3 ox31=fract(p31*K)-Ko;vec3 oy31=mod7(floor(p31*K))*K-Ko;vec3 oz31=floor(p31*K2)*Kz-Kzo;vec3 ox32=fract(p32*K)-Ko;vec3 oy32=mod7(floor(p32*K))*K-Ko;vec3 oz32=floor(p32*K2)*Kz-Kzo;vec3 ox33=fract(p33*K)-Ko;vec3 oy33=mod7(floor(p33*K))*K-Ko;vec3 oz33=floor(p33*K2)*Kz-Kzo;vec3 dx11=Pfx+jitter*ox11;vec3 dy11=Pfy.x+jitter*oy11;vec3 dz11=Pfz.x+jitter*oz11;vec3 dx12=Pfx+jitter*ox12;vec3 dy12=Pfy.x+jitter*oy12;vec3 dz12=Pfz.y+jitter*oz12;vec3 dx13=Pfx+jitter*ox13;vec3 dy13=Pfy.x+jitter*oy13;vec3 dz13=Pfz.z+jitter*oz13;vec3 dx21=Pfx+jitter*ox21;vec3 dy21=Pfy.y+jitter*oy21;vec3 dz21=Pfz.x+jitter*oz21;vec3 dx22=Pfx+jitter*ox22;vec3 dy22=Pfy.y+jitter*oy22;vec3 dz22=Pfz.y+jitter*oz22;vec3 dx23=Pfx+jitter*ox23;vec3 dy23=Pfy.y+jitter*oy23;vec3 dz23=Pfz.z+jitter*oz23;vec3 dx31=Pfx+jitter*ox31;vec3 dy31=Pfy.z+jitter*oy31;vec3 dz31=Pfz.x+jitter*oz31;vec3 dx32=Pfx+jitter*ox32;vec3 dy32=Pfy.z+jitter*oy32;vec3 dz32=Pfz.y+jitter*oz32;vec3 dx33=Pfx+jitter*ox33;vec3 dy33=Pfy.z+jitter*oy33;vec3 dz33=Pfz.z+jitter*oz33;vec3 d11=dx11*dx11+dy11*dy11+dz11*dz11;vec3 d12=dx12*dx12+dy12*dy12+dz12*dz12;vec3 d13=dx13*dx13+dy13*dy13+dz13*dz13;vec3 d21=dx21*dx21+dy21*dy21+dz21*dz21;vec3 d22=dx22*dx22+dy22*dy22+dz22*dz22;vec3 d23=dx23*dx23+dy23*dy23+dz23*dz23;vec3 d31=dx31*dx31+dy31*dy31+dz31*dz31;vec3 d32=dx32*dx32+dy32*dy32+dz32*dz32;vec3 d33=dx33*dx33+dy33*dy33+dz33*dz33;vec3 d1a=min(d11,d12);d12=max(d11,d12);d11=min(d1a,d13);d13=max(d1a,d13);d12=min(d12,d13);vec3 d2a=min(d21,d22);d22=max(d21,d22);d21=min(d2a,d23);d23=max(d2a,d23);d22=min(d22,d23);vec3 d3a=min(d31,d32);d32=max(d31,d32);d31=min(d3a,d33);d33=max(d3a,d33);d32=min(d32,d33);vec3 da=min(d11,d21);d21=max(d11,d21);d11=min(da,d31);d31=max(da,d31);d11.xy=(d11.x<d11.y)? d11.xy : d11.yx;d11.xz=(d11.x<d11.z)? d11.xz : d11.zx;d12=min(d12,d21);d12=min(d12,d22);d12=min(d12,d31);d12=min(d12,d32);d11.yz=min(d11.yz,d12.xy);d11.y=min(d11.y,d12.z);d11.y=min(d11.y,d11.z);return sqrt(d11.xy);}"; // eslint-disable-line

var noise_cellular = "#define GLSLIFY 1\n#include <noise_cellular_2D>\n#include <noise_cellular_3D>\n#include <noise_cellular_2x2>\n#include <noise_cellular_2x2x2>\n"; // eslint-disable-line

var noise_perlin_2D = "#define GLSLIFY 1\nfloat perlin(vec2 P){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}float perlin(vec2 P,vec2 rep){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod(Pi,rep.xyxy);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}"; // eslint-disable-line

var noise_perlin_3D = "#define GLSLIFY 1\nfloat perlin(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}float perlin(vec3 P,vec3 rep){vec3 Pi0=mod(floor(P),rep);vec3 Pi1=mod(Pi0+vec3(1.0),rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}"; // eslint-disable-line

var noise_perlin_4D = "#define GLSLIFY 1\nfloat perlin(vec4 P){vec4 Pi0=floor(P);vec4 Pi1=Pi0+1.0;Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}float perlin(vec4 P,vec4 rep){vec4 Pi0=mod(floor(P),rep);vec4 Pi1=mod(Pi0+1.0,rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}"; // eslint-disable-line

var noise_perlin = "#define GLSLIFY 1\n#include <noise_perlin_2D>\n#include <noise_perlin_3D>\n#include <noise_perlin_4D>\n"; // eslint-disable-line

var noise_psrd_2D = "#define GLSLIFY 1\nvec2 rgrad2(vec2 p,float rot){float u=permute(permute(p.x)+p.y)*0.0243902439+rot;u=fract(u)*6.28318530718;return vec2(cos(u),sin(u));}vec3 psrdnoise(vec2 pos,vec2 per,float rot){pos.y+=0.01;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 psdnoise(vec2 pos,vec2 per){return psrdnoise(pos,per,0.0);}float psrnoise(vec2 pos,vec2 per,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float psnoise(vec2 pos,vec2 per){return psrnoise(pos,per,0.0);}vec3 srdnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 sdnoise(vec2 pos){return srdnoise(pos,0.0);}float srnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float snoise(vec2 pos){return srnoise(pos,0.0);}"; // eslint-disable-line

var noise_simplex_2D = "#define GLSLIFY 1\nfloat simplex(vec2 v){const vec4 C=vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);vec2 i=floor(v+dot(v,C.yy));vec2 x0=v-i+dot(i,C.xx);vec2 i1;i1=(x0.x>x0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec4 x12=x0.xyxy+C.xxzz;x12.xy-=i1;i=mod289(i);vec3 p=permute(permute(i.y+vec3(0.0,i1.y,1.0))+i.x+vec3(0.0,i1.x,1.0));vec3 m=max(0.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.0);m=m*m;m=m*m;vec3 x=2.0*fract(p*C.www)-1.0;vec3 h=abs(x)-0.5;vec3 ox=floor(x+0.5);vec3 a0=x-ox;m*=1.79284291400159-0.85373472095314*(a0*a0+h*h);vec3 g;g.x=a0.x*x0.x+h.x*x0.y;g.yz=a0.yz*x12.xz+h.yz*x12.yw;return 130.0*dot(m,g);}"; // eslint-disable-line

var noise_simplex_3D_grad = "#define GLSLIFY 1\nfloat simplex(vec3 v,out vec3 gradient){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);vec4 m2=m*m;vec4 m4=m2*m2;vec4 pdotx=vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3));vec4 temp=m2*m*pdotx;gradient=-8.0*(temp.x*x0+temp.y*x1+temp.z*x2+temp.w*x3);gradient+=m4.x*p0+m4.y*p1+m4.z*p2+m4.w*p3;gradient*=42.0;return 42.0*dot(m4,pdotx);}"; // eslint-disable-line

var noise_simplex_3D = "#define GLSLIFY 1\nfloat simplex(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}"; // eslint-disable-line

var noise_simplex_4D = "#define GLSLIFY 1\nvec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}\n#define F4 0.309016994374947451\nfloat simplex(vec4 v){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v+dot(v,vec4(F4)));vec4 x0=v-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 m0=max(0.6-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.6-vec2(dot(x3,x3),dot(x4,x4)),0.0);m0=m0*m0;m1=m1*m1;return 49.0*(dot(m0*m0,vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2)))+dot(m1*m1,vec2(dot(p3,x3),dot(p4,x4))));}"; // eslint-disable-line

var noise_simplex = "#define GLSLIFY 1\n#include <noise_simplex_2D>\n#include <noise_simplex_3D>\n#include <noise_simplex_3D_grad>\n#include <noise_simplex_4D>\n"; // eslint-disable-line

var gamma_frag = "#define GLSLIFY 1\n#ifdef GAMMA\nfloat gamma=2.2;gl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(1.0/gamma));\n#endif\n"; // eslint-disable-line

var pbr_common_frag_define = "#define GLSLIFY 1\n#ifndef EPSILON\n#define EPSILON 1e-6\n#endif\n#ifndef RECIPROCAL_PI\n#define RECIPROCAL_PI 0.31830988618\n#endif\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n#define RE_Direct RE_Direct_Physical\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material ) GGXRoughnessToBlinnExponent( material.specularRoughness )\n"; // eslint-disable-line

var pbr_util_frag_define = "#define GLSLIFY 1\nvec4 SRGBtoLINEAR(vec4 srgbIn){\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\nvec3 linOut=pow(srgbIn.xyz,vec3(2.2));\n#else\nvec3 bLess=step(vec3(0.04045),srgbIn.xyz);vec3 linOut=mix(srgbIn.xyz/vec3(12.92),pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)),bLess);\n#endif\nreturn vec4(linOut,srgbIn.w);;\n#else\nreturn srgbIn;\n#endif\n}float pow2(const in float x){return x*x;}vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}vec3 BRDF_Diffuse_Lambert(const in vec3 diffuseColor){return RECIPROCAL_PI*diffuseColor;}float GGXRoughnessToBlinnExponent(const in float ggxRoughness){return(2.0/pow2(ggxRoughness+0.0001)-2.0);}float computeSpecularOcclusion(const in float dotNV,const in float ambientOcclusion,const in float roughness){return saturate(pow(dotNV+ambientOcclusion,exp2(-16.0*roughness-1.0))-1.0+ambientOcclusion);}"; // eslint-disable-line

var pbr_envmap_light_frag_define = "#define GLSLIFY 1\nstruct EnvMapLight{vec3 diffuse;float mipMapLevel;float diffuseIntensity;float specularIntensity;mat4 transformMatrix;};uniform EnvMapLight u_envMapLight;\n#ifdef O3_USE_SH\nuniform vec3 u_env_sh[9];\n#endif\n#ifdef O3_USE_SPECULAR_ENV\nuniform samplerCube u_env_specularSampler;\n#endif\n"; // eslint-disable-line

var pbr_base_frag_define = "#define GLSLIFY 1\nuniform float u_alphaCutoff;uniform vec4 u_baseColor;uniform float u_metal;uniform float u_roughness;uniform vec3 u_specularColor;uniform float u_glossinessFactor;uniform vec3 u_emissiveColor;uniform float u_normalIntensity;uniform float u_occlusionStrength;"; // eslint-disable-line

var pbr_texture_frag_define = "#define GLSLIFY 1\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_baseColorSampler;\n#endif\n#ifdef O3_NORMAL_TEXTURE\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_emissiveSampler;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_metallicRoughnessSampler;\n#endif\n#ifdef HAS_SPECULARGLOSSINESSMAP\nuniform sampler2D u_specularGlossinessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_occlusionSampler;\n#endif\n"; // eslint-disable-line

var pbr_runtime_frag_define = "#define GLSLIFY 1\nstruct IncidentLight{vec3 color;vec3 direction;};struct ReflectedLight{vec3 directDiffuse;vec3 directSpecular;vec3 indirectDiffuse;vec3 indirectSpecular;};struct GeometricContext{vec3 position;vec3 normal;vec3 viewDir;};struct PhysicalMaterial{vec3 diffuseColor;float specularRoughness;vec3 specularColor;};"; // eslint-disable-line

var pbr_brdf_cook_torrance_frag_define = "#define GLSLIFY 1\nvec3 F_Schlick(const in vec3 specularColor,const in float dotLH){float fresnel=exp2((-5.55473*dotLH-6.98316)*dotLH);return(1.0-specularColor)*fresnel+specularColor;}float G_GGX_SmithCorrelated(const in float alpha,const in float dotNL,const in float dotNV){float a2=pow2(alpha);float gv=dotNL*sqrt(a2+(1.0-a2)*pow2(dotNV));float gl=dotNV*sqrt(a2+(1.0-a2)*pow2(dotNL));return 0.5/max(gv+gl,EPSILON);}float D_GGX(const in float alpha,const in float dotNH){float a2=pow2(alpha);float denom=pow2(dotNH)*(a2-1.0)+1.0;return RECIPROCAL_PI*a2/pow2(denom);}vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight,const in GeometricContext geometry,const in vec3 specularColor,const in float roughness){float alpha=pow2(roughness);vec3 halfDir=normalize(incidentLight.direction+geometry.viewDir);float dotNL=saturate(dot(geometry.normal,incidentLight.direction));float dotNV=saturate(dot(geometry.normal,geometry.viewDir));float dotNH=saturate(dot(geometry.normal,halfDir));float dotLH=saturate(dot(incidentLight.direction,halfDir));vec3 F=F_Schlick(specularColor,dotLH);float G=G_GGX_SmithCorrelated(alpha,dotNL,dotNV);float D=D_GGX(alpha,dotNH);return F*(G*D);}"; // eslint-disable-line

var pbr_direct_irradiance_frag_define = "#define GLSLIFY 1\nvoid RE_Direct_Physical(const in IncidentLight directLight,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){float dotNL=saturate(dot(geometry.normal,directLight.direction));vec3 irradiance=dotNL*directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance*=PI;\n#endif\nreflectedLight.directSpecular+=irradiance*BRDF_Specular_GGX(directLight,geometry,material.specularColor,material.specularRoughness);reflectedLight.directDiffuse+=irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);}\n#ifdef O3_DIRECT_LIGHT_COUNT\nvoid getDirectionalDirectLightIrradiance(const in DirectLight directionalLight,const in GeometricContext geometry,out IncidentLight directLight){directLight.color=directionalLight.color;directLight.direction=-directionalLight.direction;}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nvoid getPointDirectLightIrradiance(const in PointLight pointLight,const in GeometricContext geometry,out IncidentLight directLight){vec3 lVector=pointLight.position-geometry.position;directLight.direction=normalize(lVector);float lightDistance=length(lVector);directLight.color=pointLight.color;directLight.color*=clamp(1.0-pow(lightDistance/pointLight.distance,4.0),0.0,1.0);}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nvoid getSpotDirectLightIrradiance(const in SpotLight spotLight,const in GeometricContext geometry,out IncidentLight directLight){vec3 lVector=spotLight.position-geometry.position;directLight.direction=normalize(lVector);float lightDistance=length(lVector);float angleCos=dot(directLight.direction,-spotLight.direction);float spotEffect=smoothstep(spotLight.penumbraCos,spotLight.angleCos,angleCos);float decayEffect=clamp(1.0-pow(lightDistance/spotLight.distance,4.0),0.0,1.0);directLight.color=spotLight.color;directLight.color*=spotEffect*decayEffect;}\n#endif\n"; // eslint-disable-line

var pbr_ibl_specular_frag_define = "#define GLSLIFY 1\nvec3 BRDF_Specular_GGX_Environment(const in GeometricContext geometry,const in vec3 specularColor,const in float roughness){float dotNV=saturate(dot(geometry.normal,geometry.viewDir));const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}float getSpecularMIPLevel(const in float blinnShininessExponent,const in int maxMIPLevel){float maxMIPLevelScalar=float(maxMIPLevel);float desiredMIPLevel=maxMIPLevelScalar+0.79248-0.5*log2(pow2(blinnShininessExponent)+1.0);return clamp(desiredMIPLevel,0.0,maxMIPLevelScalar);}vec3 getLightProbeIndirectRadiance(const in GeometricContext geometry,const in float blinnShininessExponent,const in int maxMIPLevel){\n#ifndef O3_USE_SPECULAR_ENV\nreturn vec3(0.0);\n#else\nvec3 reflectVec=reflect(-geometry.viewDir,geometry.normal);float specularMIPLevel=getSpecularMIPLevel(blinnShininessExponent,maxMIPLevel);\n#ifdef HAS_TEX_LOD\nvec4 envMapColor=textureCubeLodEXT(u_env_specularSampler,reflectVec,specularMIPLevel);\n#else\nvec4 envMapColor=textureCube(u_env_specularSampler,reflectVec,specularMIPLevel);\n#endif\nenvMapColor.rgb=SRGBtoLINEAR(envMapColor*u_envMapLight.specularIntensity).rgb;return envMapColor.rgb;\n#endif\n}void RE_IndirectSpecular_Physical(const in vec3 radiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){float dotNV=saturate(dot(geometry.normal,geometry.viewDir));float dotNL=dotNV;reflectedLight.indirectSpecular+=radiance*BRDF_Specular_GGX_Environment(geometry,material.specularColor,material.specularRoughness);}"; // eslint-disable-line

var pbr_ibl_diffuse_frag_define = "#define GLSLIFY 1\nvoid RE_IndirectDiffuse_Physical(const in vec3 irradiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){reflectedLight.indirectDiffuse+=irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);}vec3 getLightProbeIrradiance(vec3 sh[9],vec3 normal){vec3 result=sh[0]+sh[1]*(normal.y)+sh[2]*(normal.z)+sh[3]*(normal.x)+sh[4]*(normal.y*normal.x)+sh[5]*(normal.y*normal.z)+sh[6]*(3.0*normal.z*normal.z-1.0)+sh[7]*(normal.z*normal.x)+sh[8]*(normal.x*normal.x-normal.y*normal.y);return max(result,vec3(0.0));}"; // eslint-disable-line

var pbr_begin_frag = "#define GLSLIFY 1\nvec3 normal=getNormal();vec4 diffuseColor=u_baseColor;vec3 totalEmissiveRadiance=u_emissiveColor;float metalnessFactor=u_metal;float roughnessFactor=u_roughness;vec3 specularFactor=u_specularColor;float glossinessFactor=u_glossinessFactor;ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));PhysicalMaterial material;GeometricContext geometry;IncidentLight directLight;\n#ifdef HAS_BASECOLORMAP\nvec4 baseMapColor=texture2D(u_baseColorSampler,v_uv);baseMapColor=SRGBtoLINEAR(baseMapColor);diffuseColor*=baseMapColor;\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\ndiffuseColor*=v_color;\n#endif\n#ifdef ALPHA_CUTOFF\nif(diffuseColor.a<u_alphaCutoff){discard;}\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nvec4 metalRoughMapColor=texture2D(u_metallicRoughnessSampler,v_uv);roughnessFactor*=metalRoughMapColor.g;metalnessFactor*=metalRoughMapColor.b;\n#endif\n#ifdef HAS_SPECULARGLOSSINESSMAP\nvec4 specularGlossinessColor=texture2D(u_specularGlossinessSampler,v_uv);specularFactor*=specularGlossinessColor.rgb;glossinessFactor*=specularGlossinessColor.a;\n#endif\n#ifdef IS_METALLIC_WORKFLOW\nmaterial.diffuseColor=diffuseColor.rgb*(1.0-metalnessFactor);material.specularRoughness=clamp(roughnessFactor,0.04,1.0);material.specularColor=mix(vec3(MAXIMUM_SPECULAR_COEFFICIENT),diffuseColor.rgb,metalnessFactor);\n#else\nfloat specularStrength=max(max(specularFactor.r,specularFactor.g),specularFactor.b);material.diffuseColor=diffuseColor.rgb*(1.0-specularStrength);material.specularRoughness=clamp(1.0-glossinessFactor,0.04,1.0);material.specularColor=specularFactor;\n#endif\ngeometry.position=v_pos;geometry.normal=normal;geometry.viewDir=normalize(u_cameraPos-v_pos);"; // eslint-disable-line

var pbr_direct_irradiance_frag = "#define GLSLIFY 1\n#if defined( O3_DIRECT_LIGHT_COUNT ) && defined( RE_Direct )\nDirectLight directionalLight;for(int i=0;i<O3_DIRECT_LIGHT_COUNT;i++){directionalLight.color=u_directLightColor[i];directionalLight.direction=u_directLightDirection[i];getDirectionalDirectLightIrradiance(directionalLight,geometry,directLight);RE_Direct(directLight,geometry,material,reflectedLight);}\n#endif\n#if defined( O3_POINT_LIGHT_COUNT ) && defined( RE_Direct )\nPointLight pointLight;for(int i=0;i<O3_POINT_LIGHT_COUNT;i++){pointLight.color=u_pointLightColor[i];pointLight.position=u_pointLightPosition[i];pointLight.distance=u_pointLightDistance[i];getPointDirectLightIrradiance(pointLight,geometry,directLight);RE_Direct(directLight,geometry,material,reflectedLight);}\n#endif\n#if defined( O3_SPOT_LIGHT_COUNT ) && defined( RE_Direct )\nSpotLight spotLight;for(int i=0;i<O3_SPOT_LIGHT_COUNT;i++){spotLight.color=u_spotLightColor[i];spotLight.position=u_spotLightPosition[i];spotLight.direction=u_spotLightDirection[i];spotLight.distance=u_spotLightDistance[i];spotLight.angleCos=u_spotLightAngleCos[i];spotLight.penumbraCos=u_spotLightPenumbraCos[i];getSpotDirectLightIrradiance(spotLight,geometry,directLight);RE_Direct(directLight,geometry,material,reflectedLight);}\n#endif\n"; // eslint-disable-line

var pbr_ibl_diffuse_frag = "#define GLSLIFY 1\n#ifdef O3_USE_SH\nvec3 irradiance=getLightProbeIrradiance(u_env_sh,normal)*u_envMapLight.diffuseIntensity;\n#else\nvec3 irradiance=u_envMapLight.diffuse*u_envMapLight.diffuseIntensity;\n#endif\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance*=PI;\n#endif\nRE_IndirectDiffuse_Physical(irradiance,geometry,material,reflectedLight);"; // eslint-disable-line

var pbr_ibl_specular_frag = "#define GLSLIFY 1\n#if defined( RE_IndirectSpecular )\nvec3 radiance=vec3(0.0);\n#endif\n#if defined( RE_IndirectSpecular )\nradiance+=getLightProbeIndirectRadiance(geometry,Material_BlinnShininessExponent(material),int(u_envMapLight.mipMapLevel));\n#endif\n#if defined( RE_IndirectSpecular )\nRE_IndirectSpecular(radiance,geometry,material,reflectedLight);\n#endif\n"; // eslint-disable-line

var pbr_end_frag = "#define GLSLIFY 1\n#ifdef HAS_OCCLUSIONMAP\nfloat ambientOcclusion=(texture2D(u_occlusionSampler,v_uv).r-1.0)*u_occlusionStrength+1.0;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined(O3_USE_SPECULAR_ENV)\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.specularRoughness);\n#endif\n#endif\n#ifdef HAS_EMISSIVEMAP\nvec4 emissiveMapColor=texture2D(u_emissiveSampler,v_uv);emissiveMapColor=SRGBtoLINEAR(emissiveMapColor);totalEmissiveRadiance*=emissiveMapColor.rgb;\n#endif\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+totalEmissiveRadiance;gl_FragColor=vec4(outgoingLight,diffuseColor.a);"; // eslint-disable-line

var PBRShaderLib = {
  pbr_common_frag_define: pbr_common_frag_define,
  pbr_util_frag_define: pbr_util_frag_define,
  pbr_envmap_light_frag_define: pbr_envmap_light_frag_define,
  pbr_base_frag_define: pbr_base_frag_define,
  pbr_texture_frag_define: pbr_texture_frag_define,
  pbr_runtime_frag_define: pbr_runtime_frag_define,
  pbr_brdf_cook_torrance_frag_define: pbr_brdf_cook_torrance_frag_define,
  pbr_direct_irradiance_frag_define: pbr_direct_irradiance_frag_define,
  pbr_ibl_specular_frag_define: pbr_ibl_specular_frag_define,
  pbr_ibl_diffuse_frag_define: pbr_ibl_diffuse_frag_define,
  pbr_begin_frag: pbr_begin_frag,
  pbr_direct_irradiance_frag: pbr_direct_irradiance_frag,
  pbr_ibl_diffuse_frag: pbr_ibl_diffuse_frag,
  pbr_ibl_specular_frag: pbr_ibl_specular_frag,
  pbr_end_frag: pbr_end_frag
};

var normal_get = "#define GLSLIFY 1\nvec3 getNormal(){\n#ifdef O3_NORMAL_TEXTURE\n#ifndef O3_HAS_TANGENT\n#ifdef HAS_DERIVATIVES\nvec3 pos_dx=dFdx(v_pos);vec3 pos_dy=dFdy(v_pos);vec3 tex_dx=dFdx(vec3(v_uv,0.0));vec3 tex_dy=dFdy(vec3(v_uv,0.0));vec3 t=(tex_dy.t*pos_dx-tex_dx.t*pos_dy)/(tex_dx.s*tex_dy.t-tex_dy.s*tex_dx.t);\n#ifdef O3_HAS_NORMAL\nvec3 ng=normalize(v_normal);\n#else\nvec3 ng=normalize(cross(pos_dx,pos_dy));\n#endif\nt=normalize(t-ng*dot(ng,t));vec3 b=normalize(cross(ng,t));mat3 tbn=mat3(t,b,ng);\n#else\n#ifdef O3_HAS_NORMAL\nvec3 ng=normalize(v_normal);\n#else\nvec3 ng=vec3(0.0,0.0,1.0);\n#endif\nmat3 tbn=mat3(vec3(0.0),vec3(0.0),ng);\n#endif\n#else\nmat3 tbn=v_TBN;\n#endif\nvec3 n=texture2D(u_normalTexture,v_uv).rgb;n=normalize(tbn*((2.0*n-1.0)*vec3(u_normalIntensity,u_normalIntensity,1.0)));\n#else\n#ifdef O3_HAS_NORMAL\nvec3 n=normalize(v_normal);\n#elif defined(HAS_DERIVATIVES)\nvec3 pos_dx=dFdx(v_pos);vec3 pos_dy=dFdy(v_pos);vec3 n=normalize(cross(pos_dx,pos_dy));\n#else\nvec3 n=vec3(0.0,0.0,1.0);\n#endif\n#endif\nn*=float(gl_FrontFacing)*2.0-1.0;return n;}"; // eslint-disable-line

var ShaderLib = _objectSpread2(_objectSpread2({
  common: common,
  common_vert: common_vert,
  common_frag: common_frag,
  color_share: color_share,
  normal_share: normal_share,
  uv_share: uv_share,
  worldpos_share: worldpos_share,
  shadow_share: shadow_share,
  fog_share: fog_share,
  begin_normal_vert: begin_normal_vert,
  begin_position_vert: begin_position_vert,
  position_vert: position_vert,
  color_vert: color_vert,
  normal_vert: normal_vert,
  skinning_vert: skinning_vert,
  blendShape_input: blendShape_input,
  blendShape_vert: blendShape_vert,
  uv_vert: uv_vert,
  worldpos_vert: worldpos_vert,
  shadow_vert: shadow_vert,
  fog_vert: fog_vert,
  direct_light_frag: direct_light_frag,
  point_light_frag: point_light_frag,
  spot_light_frag: spot_light_frag,
  mobile_material_frag: mobile_material_frag,
  fog_frag: fog_frag,
  begin_mobile_frag: begin_mobile_frag,
  begin_viewdir_frag: begin_viewdir_frag,
  mobile_blinnphong_frag: mobile_blinnphong_frag,
  noise_common: noise_common,
  noise_cellular_2D: noise_cellular_2D,
  noise_cellular_2x2: noise_cellular_2x2,
  noise_cellular_2x2x2: noise_cellular_2x2x2,
  noise_cellular_3D: noise_cellular_3D,
  noise_cellular: noise_cellular,
  noise_perlin_2D: noise_perlin_2D,
  noise_perlin_3D: noise_perlin_3D,
  noise_perlin_4D: noise_perlin_4D,
  noise_perlin: noise_perlin,
  noise_psrd_2D: noise_psrd_2D,
  noise_simplex_2D: noise_simplex_2D,
  noise_simplex_3D_grad: noise_simplex_3D_grad,
  noise_simplex_3D: noise_simplex_3D,
  noise_simplex_4D: noise_simplex_4D,
  noise_simplex: noise_simplex,
  gamma_frag: gamma_frag
}, PBRShaderLib), {}, {
  normal_get: normal_get
});

var ShaderFactory = /*#__PURE__*/function () {
  function ShaderFactory() {}

  ShaderFactory.parseCustomMacros = function parseCustomMacros(macros) {
    return macros.map(function (m) {
      return "#define " + m + "\n";
    }).join("");
  };

  ShaderFactory.parseIncludes = function parseIncludes(src) {
    var regex = /^[ \t]*#include +<([\w\d.]+)>/gm;

    function replace(match, slice) {
      var replace = ShaderLib[slice];

      if (replace === undefined) {
        Logger.error("Shader slice \"" + match.trim() + "\" not founded.");
        return "";
      }

      return ShaderFactory.parseIncludes(replace);
    }

    return src.replace(regex, replace);
  }
  /**
   * GLSL extension.
   * @param {string[]} extensions - such as ["GL_EXT_shader_texture_lod"]
   * */
  ;

  ShaderFactory.parseExtension = function parseExtension(extensions) {
    return extensions.map(function (e) {
      return "#extension " + e + " : enable\n";
    }).join("");
  }
  /**
   * Convert lower GLSL version to GLSL 300 es.
   * @param shader - code
   * @param isFrag - Whether it is a fragment shader.
   * */
  ;

  ShaderFactory.convertTo300 = function convertTo300(shader, isFrag) {
    /** replace attribute and in */
    shader = shader.replace(/\battribute\b/g, "in");
    shader = shader.replace(/\bvarying\b/g, isFrag ? "in" : "out");
    /** replace api */

    shader = shader.replace(/\btexture(2D|Cube)\b/g, "texture");
    shader = shader.replace(/\btexture(2D|Cube)LodEXT\b/g, "textureLod");

    if (isFrag) {
      var isMRT = /\bgl_FragData\[.+?\]/g.test(shader);

      if (isMRT) {
        shader = shader.replace(/\bgl_FragColor\b/g, "gl_FragData[0]");
        var result = shader.match(/\bgl_FragData\[.+?\]/g);
        shader = this._replaceMRTShader(shader, result);
      } else {
        shader = shader.replace(/void\s+?main\s*\(/g, "out vec4 glFragColor;\nvoid main(");
        shader = shader.replace(/\bgl_FragColor\b/g, "glFragColor");
      }
    }

    return shader;
  };

  ShaderFactory._replaceMRTShader = function _replaceMRTShader(shader, result) {
    var declaration = "";
    var mrtIndexSet = new Set();

    for (var i = 0; i < result.length; i++) {
      var res = result[i].match(/\bgl_FragData\[(.+?)\]/);
      mrtIndexSet.add(res[1]);
    }

    mrtIndexSet.forEach(function (index) {
      declaration += "layout(location=" + index + ") out vec4 fragOutColor" + index + ";\n";
    });
    declaration += "void main(";
    shader = shader.replace(/\bgl_FragData\[(.+?)\]/g, "fragOutColor$1");
    shader = shader.replace(/void\s+?main\s*\(/g, declaration);
    return shader;
  };

  return ShaderFactory;
}();

/**
 * Shader macroã€‚
 */
var ShaderMacro =
/** name */

/** @internal */

/** @internal */

/**
 * @internal
 */
function ShaderMacro(name, index, value) {
  this.name = void 0;
  this._index = void 0;
  this._value = void 0;
  this.name = name;
  this._index = index;
  this._value = value;
};

/**
 * Shader uniformã€‚
 * @internal
 */
var ShaderUniform = /*#__PURE__*/function () {
  function ShaderUniform(engine) {
    this.name = void 0;
    this.propertyId = void 0;
    this.location = void 0;
    this.applyFunc = void 0;
    this.cacheValue = void 0;
    this.textureIndex = void 0;
    this.textureDefault = void 0;
    this._rhi = void 0;
    this._gl = void 0;
    var rhi = engine._hardwareRenderer;
    this._rhi = rhi;
    this._gl = rhi.gl;
  }

  var _proto = ShaderUniform.prototype;

  _proto.upload1f = function upload1f(shaderUniform, value) {
    if (this.cacheValue !== value) {
      this._gl.uniform1f(shaderUniform.location, value);

      this.cacheValue = value;
    }
  };

  _proto.upload1fv = function upload1fv(shaderUniform, value) {
    this._gl.uniform1fv(shaderUniform.location, value);
  };

  _proto.upload2f = function upload2f(shaderUniform, value) {
    var cacheValue = this.cacheValue;

    if (value.r !== undefined) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g) {
        this._gl.uniform2f(shaderUniform.location, value.r, value.g);

        cacheValue.x = value.r;
        cacheValue.y = value.g;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y) {
        this._gl.uniform2f(shaderUniform.location, value.x, value.y);

        cacheValue.x = value.x;
        cacheValue.y = value.y;
      }
    }
  };

  _proto.upload2fv = function upload2fv(shaderUniform, value) {
    this._gl.uniform2fv(shaderUniform.location, value);
  };

  _proto.upload3f = function upload3f(shaderUniform, value) {
    var cacheValue = this.cacheValue;

    if (value.r !== undefined) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b) {
        this._gl.uniform3f(shaderUniform.location, value.r, value.g, value.b);

        cacheValue.x = value.r;
        cacheValue.y = value.g;
        cacheValue.z = value.b;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z) {
        this._gl.uniform3f(shaderUniform.location, value.x, value.y, value.z);

        cacheValue.x = value.x;
        cacheValue.y = value.y;
        cacheValue.z = value.z;
      }
    }
  };

  _proto.upload3fv = function upload3fv(shaderUniform, value) {
    this._gl.uniform3fv(shaderUniform.location, value);
  };

  _proto.upload4f = function upload4f(shaderUniform, value) {
    var cacheValue = this.cacheValue;

    if (value.r !== undefined) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b || cacheValue.w !== value.a) {
        this._gl.uniform4f(shaderUniform.location, value.r, value.g, value.b, value.a);

        cacheValue.x = value.r;
        cacheValue.y = value.g;
        cacheValue.z = value.b;
        cacheValue.w = value.a;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z || cacheValue.w !== value.w) {
        this._gl.uniform4f(shaderUniform.location, value.x, value.y, value.z, value.w);

        cacheValue.x = value.x;
        cacheValue.y = value.y;
        cacheValue.z = value.z;
        cacheValue.w = value.w;
      }
    }
  };

  _proto.upload4fv = function upload4fv(shaderUniform, value) {
    this._gl.uniform4fv(shaderUniform.location, value);
  };

  _proto.upload1i = function upload1i(shaderUniform, value) {
    if (this.cacheValue !== value) {
      this._gl.uniform1i(shaderUniform.location, value);

      this.cacheValue = value;
    }
  };

  _proto.upload1iv = function upload1iv(shaderUniform, value) {
    this._gl.uniform1iv(shaderUniform.location, value);
  };

  _proto.upload2i = function upload2i(shaderUniform, value) {
    var cacheValue = this.cacheValue;

    if (value.r !== undefined) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g) {
        this._gl.uniform2i(shaderUniform.location, value.r, value.g);

        cacheValue.x = value.r;
        cacheValue.y = value.g;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y) {
        this._gl.uniform2i(shaderUniform.location, value.x, value.y);

        cacheValue.x = value.x;
        cacheValue.y = value.y;
      }
    }
  };

  _proto.upload2iv = function upload2iv(shaderUniform, value) {
    this._gl.uniform2iv(shaderUniform.location, value);
  };

  _proto.upload3i = function upload3i(shaderUniform, value) {
    var cacheValue = this.cacheValue;

    if (value.r !== undefined) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b) {
        this._gl.uniform3i(shaderUniform.location, value.r, value.g, value.b);

        cacheValue.x = value.r;
        cacheValue.y = value.g;
        cacheValue.z = value.b;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z) {
        this._gl.uniform3i(shaderUniform.location, value.x, value.y, value.z);

        cacheValue.x = value.x;
        cacheValue.y = value.y;
        cacheValue.z = value.z;
      }
    }
  };

  _proto.upload3iv = function upload3iv(shaderUniform, value) {
    this._gl.uniform3iv(shaderUniform.location, value);
  };

  _proto.upload4i = function upload4i(shaderUniform, value) {
    var cacheValue = this.cacheValue;

    if (value.r !== undefined) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b || cacheValue.w !== value.a) {
        this._gl.uniform4i(shaderUniform.location, value.r, value.g, value.b, value.a);

        cacheValue.x = value.r;
        cacheValue.y = value.g;
        cacheValue.z = value.b;
        cacheValue.w = value.a;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z || cacheValue.w !== value.w) {
        this._gl.uniform4i(shaderUniform.location, value.x, value.y, value.z, value.w);

        cacheValue.x = value.x;
        cacheValue.y = value.y;
        cacheValue.z = value.z;
        cacheValue.w = value.w;
      }
    }
  };

  _proto.upload4iv = function upload4iv(shaderUniform, value) {
    this._gl.uniform4iv(shaderUniform.location, value);
  };

  _proto.uploadMat4 = function uploadMat4(shaderUniform, value) {
    this._gl.uniformMatrix4fv(shaderUniform.location, false, value.elements);
  };

  _proto.uploadMat4v = function uploadMat4v(shaderUniform, value) {
    this._gl.uniformMatrix4fv(shaderUniform.location, false, value);
  };

  _proto.uploadTexture = function uploadTexture(shaderUniform, value) {
    var rhi = this._rhi;
    rhi.activeTexture(shaderUniform.textureIndex);
    rhi.bindTexture(value._platformTexture);
  };

  _proto.uploadTextureArray = function uploadTextureArray(shaderUniform, value) {
    var rhi = this._rhi;
    var textureIndices = shaderUniform.textureIndex;

    for (var i = 0; i < value.length; i++) {
      var texture = value[i];
      rhi.activeTexture(textureIndices[i]);
      rhi.bindTexture(texture._platformTexture);
    }
  };

  return ShaderUniform;
}();

/**
 * Shader uniform block.
 * @internal
 */
var ShaderUniformBlock = function ShaderUniformBlock() {
  this.constUniforms = [];
  this.textureUniforms = [];
};

/**
 * Shader program, corresponding to the GPU shader program.
 * @internal
 */

var ShaderProgram = /*#__PURE__*/function () {
  ShaderProgram._addLineNum = function _addLineNum(str) {
    var lines = str.split("\n");
    var limitLength = (lines.length + 1).toString().length + 6;
    var prefix;
    return lines.map(function (line, index) {
      prefix = "0:" + (index + 1);
      if (prefix.length >= limitLength) return prefix.substring(0, limitLength) + line;

      for (var i = 0; i < limitLength - prefix.length; i++) {
        prefix += " ";
      }

      return prefix + line;
    }).join("\n");
  };

  function ShaderProgram(engine, vertexSource, fragmentSource) {
    this.id = void 0;
    this.sceneUniformBlock = new ShaderUniformBlock();
    this.cameraUniformBlock = new ShaderUniformBlock();
    this.rendererUniformBlock = new ShaderUniformBlock();
    this.materialUniformBlock = new ShaderUniformBlock();
    this.otherUniformBlock = new ShaderUniformBlock();
    this._uploadRenderCount = -1;
    this._uploadCamera = void 0;
    this._uploadRenderer = void 0;
    this._uploadMaterial = void 0;
    this.attributeLocation = Object.create(null);
    this._isValid = void 0;
    this._engine = void 0;
    this._gl = void 0;
    this._vertexShader = void 0;
    this._fragmentShader = void 0;
    this._glProgram = void 0;
    this._activeTextureUint = 0;
    this._engine = engine;
    this._gl = engine._hardwareRenderer.gl;
    this._glProgram = this._createProgram(vertexSource, fragmentSource);

    if (this._glProgram) {
      this._isValid = true;

      this._recordLocation();
    } else {
      this._isValid = false;
    }

    this.id = ShaderProgram._counter++;
  }
  /**
   * Upload all shader data in shader uniform block.
   * @param uniformBlock - shader Uniform block
   * @param shaderData - shader data
   */


  var _proto = ShaderProgram.prototype;

  _proto.uploadAll = function uploadAll(uniformBlock, shaderData) {
    this.uploadUniforms(uniformBlock, shaderData);
    this.uploadTextures(uniformBlock, shaderData);
  }
  /**
   * Upload constant shader data in shader uniform block.
   * @param uniformBlock - shader Uniform block
   * @param shaderData - shader data
   */
  ;

  _proto.uploadUniforms = function uploadUniforms(uniformBlock, shaderData) {
    var properties = shaderData._properties;
    var constUniforms = uniformBlock.constUniforms;

    for (var i = 0, n = constUniforms.length; i < n; i++) {
      var uniform = constUniforms[i];
      var data = properties[uniform.propertyId];
      data != null && uniform.applyFunc(uniform, data);
    }
  }
  /**
   * Upload texture shader data in shader uniform block.
   * @param uniformBlock - shader Uniform block
   * @param shaderData - shader data
   */
  ;

  _proto.uploadTextures = function uploadTextures(uniformBlock, shaderData) {
    var properties = shaderData._properties;
    var textureUniforms = uniformBlock.textureUniforms; // textureUniforms property maybe null if ShaderUniformBlock not contain any texture.

    if (textureUniforms) {
      for (var i = 0, n = textureUniforms.length; i < n; i++) {
        var uniform = textureUniforms[i];
        var texture = properties[uniform.propertyId];

        if (texture) {
          uniform.applyFunc(uniform, texture);
        } else {
          uniform.applyFunc(uniform, uniform.textureDefault);
        }
      }
    }
  }
  /**
   * Upload ungroup texture shader data in shader uniform block.
   */
  ;

  _proto.uploadUngroupTextures = function uploadUngroupTextures() {
    var textureUniforms = this.otherUniformBlock.textureUniforms; // textureUniforms property maybe null if ShaderUniformBlock not contain any texture.

    if (textureUniforms) {
      for (var i = 0, n = textureUniforms.length; i < n; i++) {
        var uniform = textureUniforms[i];
        uniform.applyFunc(uniform, uniform.textureDefault);
      }
    }
  }
  /**
   * Grouping other data.
   */
  ;

  _proto.groupingOtherUniformBlock = function groupingOtherUniformBlock() {
    var _this$otherUniformBlo = this.otherUniformBlock,
        constUniforms = _this$otherUniformBlo.constUniforms,
        textureUniforms = _this$otherUniformBlo.textureUniforms;
    constUniforms.length > 0 && this._groupingSubOtherUniforms(constUniforms, false);
    textureUniforms.length > 0 && this._groupingSubOtherUniforms(textureUniforms, true);
  }
  /**
   * Bind this shader program.
   * @returns Whether the shader program is switched.
   */
  ;

  _proto.bind = function bind() {
    var rhi = this._engine._hardwareRenderer;

    if (rhi._currentBind !== this) {
      this._gl.useProgram(this._glProgram);

      rhi._currentBind = this;
      return true;
    } else {
      return false;
    }
  }
  /**
   * Destroy this shader program.
   */
  ;

  _proto.destroy = function destroy() {
    var gl = this._gl;
    this._vertexShader && gl.deleteShader(this._vertexShader);
    this._fragmentShader && gl.deleteShader(this._fragmentShader);
    this._glProgram && gl.deleteProgram(this._glProgram);
  };

  _proto._groupingSubOtherUniforms = function _groupingSubOtherUniforms(uniforms, isTexture) {
    for (var i = uniforms.length - 1; i >= 0; i--) {
      var uniform = uniforms[i];

      var group = Shader._getShaderPropertyGroup(uniform.name);

      if (group !== undefined) {
        uniforms.splice(uniforms.indexOf(uniform), 1);

        this._groupingUniform(uniform, group, isTexture);
      }
    }
  };

  _proto._groupingUniform = function _groupingUniform(uniform, group, isTexture) {
    switch (group) {
      case ShaderDataGroup.Scene:
        if (isTexture) {
          this.sceneUniformBlock.textureUniforms.push(uniform);
        } else {
          this.sceneUniformBlock.constUniforms.push(uniform);
        }

        break;

      case ShaderDataGroup.Camera:
        if (isTexture) {
          this.cameraUniformBlock.textureUniforms.push(uniform);
        } else {
          this.cameraUniformBlock.constUniforms.push(uniform);
        }

        break;

      case ShaderDataGroup.Renderer:
        if (isTexture) {
          this.rendererUniformBlock.textureUniforms.push(uniform);
        } else {
          this.rendererUniformBlock.constUniforms.push(uniform);
        }

        break;

      case ShaderDataGroup.Material:
        if (isTexture) {
          this.materialUniformBlock.textureUniforms.push(uniform);
        } else {
          this.materialUniformBlock.constUniforms.push(uniform);
        }

        break;

      default:
        if (isTexture) {
          this.otherUniformBlock.textureUniforms.push(uniform);
        } else {
          this.otherUniformBlock.constUniforms.push(uniform);
        }

    }
  }
  /**
   * init and link program with shader.
   */
  ;

  _proto._createProgram = function _createProgram(vertexSource, fragmentSource) {
    var gl = this._gl; // create and compile shader

    var vertexShader = this._createShader(gl.VERTEX_SHADER, vertexSource);

    if (!vertexShader) {
      return null;
    }

    var fragmentShader = this._createShader(gl.FRAGMENT_SHADER, fragmentSource);

    if (!fragmentShader) {
      return null;
    } // link program and shader


    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.validateProgram(program);

    if (gl.isContextLost()) {
      Logger.error("Context lost while linking program.");
      gl.deleteShader(vertexShader);
      gl.deleteShader(fragmentShader);
      return null;
    }

    if (Logger.isEnabled && !gl.getProgramParameter(program, gl.LINK_STATUS)) {
      Logger.error("Could not link WebGL program. \n" + gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      return null;
    }

    this._vertexShader = vertexShader;
    this._fragmentShader = fragmentShader;
    return program;
  };

  _proto._createShader = function _createShader(shaderType, shaderSource) {
    var gl = this._gl;
    var shader = gl.createShader(shaderType);

    if (!shader) {
      Logger.error("Context lost while create shader.");
      return null;
    }

    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);

    if (gl.isContextLost()) {
      Logger.error("Context lost while compiling shader.");
      gl.deleteShader(shader);
      return null;
    }

    if (Logger.isEnabled && !gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      Logger.error("Could not compile WebGL shader.\n" + gl.getShaderInfoLog(shader), ShaderProgram._addLineNum(shaderSource));
      gl.deleteShader(shader);
      return null;
    }

    return shader;
  }
  /**
   * record the location of uniform/attribute.
   */
  ;

  _proto._recordLocation = function _recordLocation() {
    var _this = this;

    var gl = this._gl;
    var program = this._glProgram;

    var uniformInfos = this._getUniformInfos();

    var attributeInfos = this._getAttributeInfos();

    uniformInfos.forEach(function (_ref) {
      var name = _ref.name,
          size = _ref.size,
          type = _ref.type;
      var shaderUniform = new ShaderUniform(_this._engine);
      var isArray = false;
      var isTexture = false;

      if (name.indexOf("[0]") > 0) {
        name = name.substr(0, name.length - 3);
        isArray = true;
      }

      var group = Shader._getShaderPropertyGroup(name);

      var location = gl.getUniformLocation(program, name);
      shaderUniform.name = name;
      shaderUniform.propertyId = Shader.getPropertyByName(name)._uniqueId;
      shaderUniform.location = location;

      switch (type) {
        case gl.FLOAT:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload1fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload1f;
            shaderUniform.cacheValue = 0;
          }

          break;

        case gl.FLOAT_VEC2:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload2fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload2f;
            shaderUniform.cacheValue = new Vector2(0, 0);
          }

          break;

        case gl.FLOAT_VEC3:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload3fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload3f;
            shaderUniform.cacheValue = new Vector3(0, 0, 0);
          }

          break;

        case gl.FLOAT_VEC4:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload4fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload4f;
            shaderUniform.cacheValue = new Vector4(0, 0, 0, 0);
          }

          break;

        case gl.BOOL:
        case gl.INT:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload1iv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload1i;
            shaderUniform.cacheValue = 0;
          }

          break;

        case gl.BOOL_VEC2:
        case gl.INT_VEC2:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload2iv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload2i;
            shaderUniform.cacheValue = new Vector2(0, 0);
          }

          break;

        case gl.BOOL_VEC3:
        case gl.INT_VEC3:

          shaderUniform.applyFunc = isArray ? shaderUniform.upload3iv : shaderUniform.upload3i;
          shaderUniform.cacheValue = new Vector3(0, 0, 0);
          break;

        case gl.BOOL_VEC4:
        case gl.INT_VEC4:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload4iv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload4i;
            shaderUniform.cacheValue = new Vector4(0, 0, 0);
          }

          break;

        case gl.FLOAT_MAT4:
          shaderUniform.applyFunc = isArray ? shaderUniform.uploadMat4v : shaderUniform.uploadMat4;
          break;

        case gl.SAMPLER_2D:
        case gl.SAMPLER_CUBE:
          var defaultTexture = type === gl.SAMPLER_2D ? _this._engine._whiteTexture2D : _this._engine._whiteTextureCube;
          isTexture = true;

          if (isArray) {
            var defaultTextures = new Array(size);
            var textureIndices = new Int32Array(size);
            var glTextureIndices = new Array(size);

            for (var i = 0; i < size; i++) {
              defaultTextures[i] = defaultTexture;
              textureIndices[i] = _this._activeTextureUint;
              glTextureIndices[i] = gl.TEXTURE0 + _this._activeTextureUint++;
            }

            shaderUniform.textureDefault = defaultTextures;
            shaderUniform.textureIndex = glTextureIndices;
            shaderUniform.applyFunc = shaderUniform.uploadTextureArray;

            _this.bind();

            gl.uniform1iv(location, textureIndices);
            shaderUniform.uploadTextureArray(shaderUniform, defaultTextures);
          } else {
            var textureIndex = gl.TEXTURE0 + _this._activeTextureUint;
            shaderUniform.textureDefault = defaultTexture;
            shaderUniform.textureIndex = textureIndex;
            shaderUniform.applyFunc = shaderUniform.uploadTexture;

            _this.bind();

            gl.uniform1i(location, _this._activeTextureUint++);
            shaderUniform.uploadTexture(shaderUniform, defaultTexture);
          }

          break;
      }

      _this._groupingUniform(shaderUniform, group, isTexture);
    });
    attributeInfos.forEach(function (_ref2) {
      var name = _ref2.name;
      _this.attributeLocation[name] = gl.getAttribLocation(program, name);
    });
  };

  _proto._getUniformInfos = function _getUniformInfos() {
    var gl = this._gl;
    var program = this._glProgram;
    var uniformInfos = [];
    var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    for (var i = 0; i < uniformCount; ++i) {
      var info = gl.getActiveUniform(program, i);
      uniformInfos[i] = info;
    }

    return uniformInfos;
  };

  _proto._getAttributeInfos = function _getAttributeInfos() {
    var gl = this._gl;
    var program = this._glProgram;
    var attributeInfos = [];
    var attributeCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

    for (var i = 0; i < attributeCount; ++i) {
      var info = gl.getActiveAttrib(program, i);
      attributeInfos[i] = info;
    }

    return attributeInfos;
  };

  _createClass(ShaderProgram, [{
    key: "isValid",
    get:
    /**
     * Whether this shader program is valid.
     */
    function get() {
      return this._isValid;
    }
  }]);

  return ShaderProgram;
}();
ShaderProgram._counter = 0;

/**
 * Shader property.
 */
var ShaderProperty =
/** @internal */

/** @internal */

/** Shader property name. */

/**
 * @internal
 */
function ShaderProperty(name) {
  this._uniqueId = void 0;
  this._group = void 0;
  this.name = void 0;
  this.name = name;
  this._uniqueId = ShaderProperty._propertyNameCounter++;
};
ShaderProperty._propertyNameCounter = 0;

/**
 * Shader containing vertex and fragment source.
 */

var Shader = /*#__PURE__*/function () {
  /** @internal */

  /**
   * Create a shader.
   * @param name - Name of the shader
   * @param vertexSource - Vertex source code
   * @param fragmentSource - Fragment source code
   */
  Shader.create = function create(name, vertexSource, fragmentSource) {
    var shaderMap = Shader._shaderMap;

    if (shaderMap[name]) {
      throw "Shader named \"" + name + "\" already exists.";
    }

    return shaderMap[name] = new Shader(name, vertexSource, fragmentSource);
  }
  /**
   * Find a shader by name.
   * @param name - Name of the shader
   */
  ;

  Shader.find = function find(name) {
    return Shader._shaderMap[name];
  }
  /**
   * Get shader macro by name.
   * @param name - Name of the shader macro
   * @returns Shader macro
   */
  ;

  Shader.getMacroByName = function getMacroByName(name) {
    var macro = Shader._macroMap[name];

    if (!macro) {
      var maskMap = Shader._macroMaskMap;
      var counter = Shader._macroCounter;
      var index = Math.floor(counter / 32);
      var bit = counter % 32;
      macro = new ShaderMacro(name, index, 1 << bit);
      Shader._macroMap[name] = macro;

      if (index == maskMap.length) {
        maskMap.length++;
        maskMap[index] = new Array(32);
      }

      maskMap[index][bit] = name;
      Shader._macroCounter++;
    }

    return macro;
  }
  /**
   * Get shader property by name.
   * @param name - Name of the shader property
   * @returns Shader property
   */
  ;

  Shader.getPropertyByName = function getPropertyByName(name) {
    var propertyNameMap = Shader._propertyNameMap;

    if (propertyNameMap[name] != null) {
      return propertyNameMap[name];
    } else {
      var property = new ShaderProperty(name);
      propertyNameMap[name] = property;
      return property;
    }
  }
  /**
   * @internal
   */
  ;

  Shader._getShaderPropertyGroup = function _getShaderPropertyGroup(propertyName) {
    var shaderProperty = Shader._propertyNameMap[propertyName];
    return shaderProperty === null || shaderProperty === void 0 ? void 0 : shaderProperty._group;
  };

  Shader._getNamesByMacros = function _getNamesByMacros(macros, out) {
    var maskMap = Shader._macroMaskMap;
    var mask = macros._mask;
    out.length = 0;

    for (var i = 0, n = macros._length; i < n; i++) {
      var subMaskMap = maskMap[i];
      var subMask = mask[i];

      var _n = subMask < 0 ? 32 : Math.floor(Math.log2(subMask)) + 1; // if is negative must contain 1 << 31.


      for (var j = 0; j < _n; j++) {
        if (subMask & 1 << j) {
          out.push(subMaskMap[j]);
        }
      }
    }
  }
  /** The name of shader. */
  ;

  function Shader(name, vertexSource, fragmentSource) {
    this.name = void 0;
    this._shaderId = 0;
    this._vertexSource = void 0;
    this._fragmentSource = void 0;
    this._shaderId = Shader._shaderCounter++;
    this.name = name;
    this._vertexSource = vertexSource;
    this._fragmentSource = fragmentSource;
  }
  /**
   * Compile shader variant by macro name list.
   *
   * @remarks
   * Usually a shader contains some macros,any combination of macros is called shader variant.
   *
   * @param engine - Engine to which the shader variant belongs
   * @param macros - Macro name list
   * @returns Is the compiled shader variant valid
   */


  var _proto = Shader.prototype;

  _proto.compileVariant = function compileVariant(engine, macros) {
    var compileMacros = Shader._compileMacros;
    compileMacros.clear();

    for (var i = 0, n = macros.length; i < n; i++) {
      compileMacros.enable(Shader.getMacroByName(macros[i]));
    }

    return this._getShaderProgram(engine, compileMacros).isValid;
  }
  /**
   * @internal
   */
  ;

  _proto._getShaderProgram = function _getShaderProgram(engine, macroCollection) {
    var shaderProgramPool = engine._getShaderProgramPool(this);

    var shaderProgram = shaderProgramPool.get(macroCollection);

    if (shaderProgram) {
      return shaderProgram;
    }

    var isWebGL2 = engine._hardwareRenderer.isWebGL2;
    var macroNameList = [];

    Shader._getNamesByMacros(macroCollection, macroNameList);

    var macroNameStr = ShaderFactory.parseCustomMacros(macroNameList);
    var versionStr = isWebGL2 ? "#version 300 es" : "#version 100";
    var precisionStr = "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      precision highp int;\n      #define O3_VERTEX_PRECISION highp\n      #define O3_FRAGMENT_PRECISION highp\n    #else\n      precision mediump float;\n      precision mediump int;\n      #define O3_VERTEX_PRECISION mediump\n      #define O3_FRAGMENT_PRECISION mediump\n    #endif\n    ";

    if (engine._hardwareRenderer.canIUse(GLCapabilityType.shaderTextureLod)) {
      precisionStr += "#define HAS_TEX_LOD\n";
    }

    if (engine._hardwareRenderer.canIUse(GLCapabilityType.standardDerivatives)) {
      precisionStr += "#define HAS_DERIVATIVES\n";
    }

    var vertexSource = ShaderFactory.parseIncludes(" " + versionStr + "\n        " + precisionStr + "\n        " + macroNameStr + "\n        " + this._vertexSource);
    var fragmentSource = ShaderFactory.parseIncludes(" " + versionStr + "\n        " + (isWebGL2 ? "" : ShaderFactory.parseExtension(Shader._shaderExtension)) + "\n        " + precisionStr + "\n        " + macroNameStr + "\n      " + this._fragmentSource);

    if (isWebGL2) {
      vertexSource = ShaderFactory.convertTo300(vertexSource);
      fragmentSource = ShaderFactory.convertTo300(fragmentSource, true);
    }

    shaderProgram = new ShaderProgram(engine, vertexSource, fragmentSource);
    shaderProgramPool.cache(shaderProgram);
    return shaderProgram;
  };

  return Shader;
}();
Shader._compileMacros = new ShaderMacroCollection();
Shader._shaderCounter = 0;
Shader._shaderMap = Object.create(null);
Shader._propertyNameMap = Object.create(null);
Shader._macroMaskMap = [];
Shader._macroCounter = 0;
Shader._macroMap = Object.create(null);
Shader._shaderExtension = ["GL_EXT_shader_texture_lod", "GL_OES_standard_derivatives", "GL_EXT_draw_buffers"];

/**
 * Shader data collection,Correspondence includes shader properties data and macros data.
 */
var ShaderData = /*#__PURE__*/function () {
  /** @internal */

  /** @internal */

  /** @internal */

  /**
   * @internal
   */
  function ShaderData(group) {
    this._group = void 0;
    this._properties = Object.create(null);
    this._macroCollection = new ShaderMacroCollection();
    this._variableMacros = Object.create(null);
    this._refCount = 0;
    this._group = group;
  }
  /**
   * Get float by shader property name.
   * @param propertyName - Shader property name
   * @returns Float
   */


  var _proto = ShaderData.prototype;

  _proto.getFloat = function getFloat(property) {
    return this._getData(property);
  }
  /**
   * Set float by shader property name.
   * @remarks Corresponding float shader property type.
   * @param propertyName - Shader property name
   * @param value - Float
   */
  ;

  _proto.setFloat = function setFloat(property, value) {
    this._setData(property, value);
  }
  /**
   * Get int by shader property name.
   * @param propertyName - Shader property name
   * @returns Int
   */
  ;

  _proto.getInt = function getInt(property) {
    return this._getData(property);
  }
  /**
   * Set int by shader property name.
   * @remarks Correspondence includes int and bool shader property type.
   * @param propertyName - Shader property name
   * @param value - Int
   */
  ;

  _proto.setInt = function setInt(property, value) {
    this._setData(property, value);
  }
  /**
   * Get float array by shader property name.
   * @param propertyName - Shader property name
   * @returns Float array
   */
  ;

  _proto.getFloatArray = function getFloatArray(property) {
    return this._getData(property);
  }
  /**
   * Set float array by shader property name.
   * @remarks Correspondence includes float arrayã€vec2 arrayã€vec3 arrayã€vec4 array and matrix array shader property type.
   * @param propertyName - Shader property name
   * @param value - Float array
   */
  ;

  _proto.setFloatArray = function setFloatArray(property, value) {
    this._setData(property, value);
  }
  /**
   * Get int array by shader property name.
   * @param propertyName - Shader property name
   * @returns Int Array
   */
  ;

  _proto.getIntArray = function getIntArray(property) {
    return this._getData(property);
  }
  /**
   * Set int array by shader property name.
   * @remarks Correspondence includes bool arrayã€int arrayã€bvec2 arrayã€bvec3 arrayã€bvec4 arrayã€ivec2 arrayã€ivec3 array and ivec4 array shader property type.
   * @param propertyName - Shader property name
   * @param value - Int Array
   */
  ;

  _proto.setIntArray = function setIntArray(property, value) {
    this._setData(property, value);
  }
  /**
   * Get two-dimensional from shader property name.
   * @param propertyName - Shader property name
   * @returns Two-dimensional vector
   */
  ;

  _proto.getVector2 = function getVector2(property) {
    return this._getData(property);
  }
  /**
   * Set two-dimensional vector from shader property name.
   * @remarks Correspondence includes vec2ã€ivec2 and bvec2 shader property type.
   * @param property - Shader property name
   * @param value - Two-dimensional vector
   */
  ;

  _proto.setVector2 = function setVector2(property, value) {
    this._setData(property, value);
  }
  /**
   * Get vector3 by shader property name.
   * @param propertyName - Shader property name
   * @returns Three-dimensional vector
   */
  ;

  _proto.getVector3 = function getVector3(property) {
    return this._getData(property);
  }
  /**
   * Set three dimensional vector by shader property name.
   * @remarks Correspondence includes vec3ã€ivec3 and bvec3 shader property type.
   * @param property - Shader property name
   * @param value - Three-dimensional vector
   */
  ;

  _proto.setVector3 = function setVector3(property, value) {
    this._setData(property, value);
  }
  /**
   * Get vector4 by shader property name.
   * @param propertyName - Shader property name
   * @returns Four-dimensional vector
   */
  ;

  _proto.getVector4 = function getVector4(property) {
    return this._getData(property);
  }
  /**
   * Set four-dimensional vector by shader property name.
   * @remarks Correspondence includes vec4ã€ivec4 and bvec4 shader property type.
   * @param property - Shader property name
   * @param value - Four-dimensional vector
   */
  ;

  _proto.setVector4 = function setVector4(property, value) {
    this._setData(property, value);
  }
  /**
   * Get matrix by shader property name.
   * @param propertyName - Shader property name
   * @returns Matrix
   */
  ;

  _proto.getMatrix = function getMatrix(property) {
    return this._getData(property);
  }
  /**
   * Set matrix by shader property name.
   * @remarks Correspondence includes matrix shader property type.
   * @param propertyName - Shader property name
   * @param value - Matrix
   */
  ;

  _proto.setMatrix = function setMatrix(property, value) {
    this._setData(property, value);
  }
  /**
   * Get color by shader property name.
   * @param propertyName - Shader property name
   * @returns Color
   */
  ;

  _proto.getColor = function getColor(property) {
    return this._getData(property);
  }
  /**
   * Set color by shader property name.
   * @remarks Correspondence includes vec4 shader property type.
   * @param propertyName - Shader property name
   * @param value - Color
   */
  ;

  _proto.setColor = function setColor(property, value) {
    this._setData(property, value);
  }
  /**
   * Get texture by shader property name.
   * @param propertyName - Shader property name
   * @returns Texture
   */
  ;

  _proto.getTexture = function getTexture(property) {
    return this._getData(property);
  }
  /**
   * Set texture by shader property name.
   * @param propertyName - Shader property name
   * @param value - Texture
   */
  ;

  _proto.setTexture = function setTexture(property, value) {
    if (this._getRefCount() > 0) {
      var lastValue = this._getData(property);

      lastValue && lastValue._addRefCount(-1);
      value && value._addRefCount(1);
    }

    this._setData(property, value);
  }
  /**
   * Get texture array by shader property name.
   * @param propertyName - Shader property name
   * @returns Texture array
   */
  ;

  _proto.getTextureArray = function getTextureArray(property) {
    return this._getData(property);
  }
  /**
   * Set texture array by shader property name.
   * @param propertyName - Shader property name
   * @param value - Texture array
   */
  ;

  _proto.setTextureArray = function setTextureArray(property, value) {
    if (this._getRefCount() > 0) {
      var lastValue = this._getData(property);

      if (lastValue) {
        for (var i = 0, n = lastValue.length; i < n; i++) {
          lastValue[i]._addRefCount(-1);
        }
      }

      if (value) {
        for (var _i = 0, _n = value.length; _i < _n; _i++) {
          value[_i]._addRefCount(1);
        }
      }
    }

    this._setData(property, value);
  }
  /**
   * Enable macro.
   * @param macroName - Macro name
   */
  ;

  _proto.enableMacro = function enableMacro(macro, value) {
    if (value === void 0) {
      value = null;
    }

    if (value) {
      this._enableVariableMacro(macro, value);
    } else {
      if (typeof macro === "string") {
        macro = Shader.getMacroByName(macro);
      }

      this._macroCollection.enable(macro);
    }
  }
  /**
   * Disable macro
   * @param macroName - Macro name
   */
  ;

  _proto.disableMacro = function disableMacro(macro) {
    if (typeof macro === "string") {
      // @todo: should optimization variable macros disable performance
      var variableValue = this._variableMacros[macro];

      if (variableValue) {
        this._disableVariableMacro(macro, variableValue);
      } else {
        macro = Shader.getMacroByName(macro);

        this._macroCollection.disable(macro);
      }
    } else {
      this._macroCollection.disable(macro);
    }
  };

  _proto.clone = function clone() {
    var shaderData = new ShaderData(this._group);
    this.cloneTo(shaderData);
    return shaderData;
  };

  _proto.cloneTo = function cloneTo(target) {
    CloneManager.deepCloneObject(this._macroCollection, target._macroCollection);

    _extends(target._variableMacros, this._variableMacros);

    var properties = this._properties;
    var targetProperties = target._properties;
    var keys = Object.keys(properties);

    for (var i = 0, n = keys.length; i < n; i++) {
      var k = keys[i];
      var _property = properties[k];

      if (_property != null) {
        if (typeof _property === "number") {
          targetProperties[k] = _property;
        } else if (_property instanceof Texture) {
          targetProperties[k] = _property;
        } else if (_property instanceof Array || _property instanceof Float32Array || _property instanceof Int32Array) {
          targetProperties[k] = _property.slice();
        } else {
          var targetProperty = targetProperties[k];

          if (targetProperty) {
            _property.cloneTo(targetProperty);
          } else {
            targetProperties[k] = _property.clone();
          }
        }
      } else {
        targetProperties[k] = _property;
      }
    }
  }
  /**
   * @internal
   */
  ;

  _proto._getData = function _getData(property) {
    if (typeof property === "string") {
      property = Shader.getPropertyByName(property);
    }

    return this._properties[property._uniqueId];
  }
  /**
   * @internal
   */
  ;

  _proto._setData = function _setData(property, value) {
    if (typeof property === "string") {
      property = Shader.getPropertyByName(property);
    }

    if (property._group !== this._group) {
      if (property._group === undefined) {
        property._group = this._group;
      } else {
        throw "Shader property " + property.name + " has been used as " + ShaderDataGroup[property._group] + " property.";
      }
    }

    this._properties[property._uniqueId] = value;
  }
  /**
   * @internal
   */
  ;

  _proto._getRefCount = function _getRefCount() {
    return this._refCount;
  }
  /**
   * @internal
   */
  ;

  _proto._addRefCount = function _addRefCount(value) {
    this._refCount += value;
    var properties = this._properties;

    for (var k in properties) {
      var _property2 = properties[k]; // @todo: Separate array to speed performance.

      if (_property2 && _property2 instanceof Texture) {
        _property2._addRefCount(value);
      }
    }
  };

  _proto._enableVariableMacro = function _enableVariableMacro(name, value) {
    var variableMacro = this._variableMacros;
    var variableValue = variableMacro[name];

    if (variableValue !== value) {
      variableValue && this._disableVariableMacro(name, variableValue);

      var _macro = Shader.getMacroByName(name + " " + value);

      this._macroCollection.enable(_macro);

      variableMacro[name] = value;
    }
  };

  _proto._disableVariableMacro = function _disableVariableMacro(name, value) {
    var oldMacro = Shader.getMacroByName(name + " " + value);

    this._macroCollection.disable(oldMacro);

    delete this._variableMacros[name];
  };

  return ShaderData;
}();

/**
 * Blend factor.
 * @remarks defines which function is used for blending pixel arithmetic
 */
var BlendFactor;

(function (BlendFactor) {
  BlendFactor[BlendFactor["Zero"] = 0] = "Zero";
  BlendFactor[BlendFactor["One"] = 1] = "One";
  BlendFactor[BlendFactor["SourceColor"] = 2] = "SourceColor";
  BlendFactor[BlendFactor["OneMinusSourceColor"] = 3] = "OneMinusSourceColor";
  BlendFactor[BlendFactor["DestinationColor"] = 4] = "DestinationColor";
  BlendFactor[BlendFactor["OneMinusDestinationColor"] = 5] = "OneMinusDestinationColor";
  BlendFactor[BlendFactor["SourceAlpha"] = 6] = "SourceAlpha";
  BlendFactor[BlendFactor["OneMinusSourceAlpha"] = 7] = "OneMinusSourceAlpha";
  BlendFactor[BlendFactor["DestinationAlpha"] = 8] = "DestinationAlpha";
  BlendFactor[BlendFactor["OneMinusDestinationAlpha"] = 9] = "OneMinusDestinationAlpha";
  BlendFactor[BlendFactor["SourceAlphaSaturate"] = 10] = "SourceAlphaSaturate";
  BlendFactor[BlendFactor["BlendColor"] = 11] = "BlendColor";
  BlendFactor[BlendFactor["OneMinusBlendColor"] = 12] = "OneMinusBlendColor";
})(BlendFactor || (BlendFactor = {}));

/**
 * Blend operation function.
 * @remarks defines how a new pixel is combined with a pixel.
 */
var BlendOperation;

(function (BlendOperation) {
  BlendOperation[BlendOperation["Add"] = 0] = "Add";
  BlendOperation[BlendOperation["Subtract"] = 1] = "Subtract";
  BlendOperation[BlendOperation["ReverseSubtract"] = 2] = "ReverseSubtract";
  BlendOperation[BlendOperation["Min"] = 3] = "Min";
  BlendOperation[BlendOperation["Max"] = 4] = "Max";
})(BlendOperation || (BlendOperation = {}));

/**
 * Set which color channels can be rendered to frame buffer.
 * @remarks enumeration can be combined using bit operations.
 */
var ColorWriteMask;

(function (ColorWriteMask) {
  ColorWriteMask[ColorWriteMask["None"] = 0] = "None";
  ColorWriteMask[ColorWriteMask["Red"] = 1] = "Red";
  ColorWriteMask[ColorWriteMask["Green"] = 2] = "Green";
  ColorWriteMask[ColorWriteMask["Blue"] = 4] = "Blue";
  ColorWriteMask[ColorWriteMask["Alpha"] = 8] = "Alpha";
  ColorWriteMask[ColorWriteMask["All"] = 15] = "All";
})(ColorWriteMask || (ColorWriteMask = {}));

/**
 * The blend state of the render target.
 */

var RenderTargetBlendState = function RenderTargetBlendState() {
  this.enabled = false;
  this.colorBlendOperation = BlendOperation.Add;
  this.alphaBlendOperation = BlendOperation.Add;
  this.sourceColorBlendFactor = BlendFactor.One;
  this.sourceAlphaBlendFactor = BlendFactor.One;
  this.destinationColorBlendFactor = BlendFactor.Zero;
  this.destinationAlphaBlendFactor = BlendFactor.Zero;
  this.colorWriteMask = ColorWriteMask.All;
};

/**
 * Blend state.
 */

var BlendState = /*#__PURE__*/function () {
  function BlendState() {
    this.targetBlendState = new RenderTargetBlendState();
    this.blendColor = new Color(0, 0, 0, 0);
    this.alphaToCoverage = false;
  }

  BlendState._getGLBlendFactor = function _getGLBlendFactor(rhi, blendFactor) {
    var gl = rhi.gl;

    switch (blendFactor) {
      case BlendFactor.Zero:
        return gl.ZERO;

      case BlendFactor.One:
        return gl.ONE;

      case BlendFactor.SourceColor:
        return gl.SRC_COLOR;

      case BlendFactor.OneMinusSourceColor:
        return gl.ONE_MINUS_SRC_COLOR;

      case BlendFactor.DestinationColor:
        return gl.DST_COLOR;

      case BlendFactor.OneMinusDestinationColor:
        return gl.ONE_MINUS_DST_COLOR;

      case BlendFactor.SourceAlpha:
        return gl.SRC_ALPHA;

      case BlendFactor.OneMinusSourceAlpha:
        return gl.ONE_MINUS_SRC_ALPHA;

      case BlendFactor.DestinationAlpha:
        return gl.DST_ALPHA;

      case BlendFactor.OneMinusDestinationAlpha:
        return gl.ONE_MINUS_DST_ALPHA;

      case BlendFactor.SourceAlphaSaturate:
        return gl.SRC_ALPHA_SATURATE;

      case BlendFactor.BlendColor:
        return gl.CONSTANT_COLOR;

      case BlendFactor.OneMinusBlendColor:
        return gl.ONE_MINUS_CONSTANT_COLOR;
    }
  };

  BlendState._getGLBlendOperation = function _getGLBlendOperation(rhi, blendOperation) {
    var gl = rhi.gl;

    switch (blendOperation) {
      case BlendOperation.Add:
        return gl.FUNC_ADD;

      case BlendOperation.Subtract:
        return gl.FUNC_SUBTRACT;

      case BlendOperation.ReverseSubtract:
        return gl.FUNC_REVERSE_SUBTRACT;

      case BlendOperation.Min:
        if (!rhi.canIUse(GLCapabilityType.blendMinMax)) {
          throw new Error("BlendOperation.Min is not supported in this context");
        }

        return gl.MIN;
      // in webgl1.0 is an extension

      case BlendOperation.Max:
        if (!rhi.canIUse(GLCapabilityType.blendMinMax)) {
          throw new Error("BlendOperation.Max is not supported in this context");
        }

        return gl.MAX;
      // in webgl1.0 is an extension
    }
  }
  /** The blend state of the render target. */
  ;

  var _proto = BlendState.prototype;

  /**
   * @internal
   * Apply the current blend state by comparing with the last blend state.
   */
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.blendState);
  };

  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var lastTargetBlendState = lastState.targetBlendState;
    var _this$targetBlendStat = this.targetBlendState,
        enabled = _this$targetBlendStat.enabled,
        colorBlendOperation = _this$targetBlendStat.colorBlendOperation,
        alphaBlendOperation = _this$targetBlendStat.alphaBlendOperation,
        sourceColorBlendFactor = _this$targetBlendStat.sourceColorBlendFactor,
        destinationColorBlendFactor = _this$targetBlendStat.destinationColorBlendFactor,
        sourceAlphaBlendFactor = _this$targetBlendStat.sourceAlphaBlendFactor,
        destinationAlphaBlendFactor = _this$targetBlendStat.destinationAlphaBlendFactor,
        colorWriteMask = _this$targetBlendStat.colorWriteMask;

    if (enabled !== lastTargetBlendState.enabled) {
      if (enabled) {
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }

      lastTargetBlendState.enabled = enabled;
    }

    if (enabled) {
      // apply blend factor.
      if (sourceColorBlendFactor !== lastTargetBlendState.sourceColorBlendFactor || destinationColorBlendFactor !== lastTargetBlendState.destinationColorBlendFactor || sourceAlphaBlendFactor !== lastTargetBlendState.sourceAlphaBlendFactor || destinationAlphaBlendFactor !== lastTargetBlendState.destinationAlphaBlendFactor) {
        gl.blendFuncSeparate(BlendState._getGLBlendFactor(rhi, sourceColorBlendFactor), BlendState._getGLBlendFactor(rhi, destinationColorBlendFactor), BlendState._getGLBlendFactor(rhi, sourceAlphaBlendFactor), BlendState._getGLBlendFactor(rhi, destinationAlphaBlendFactor));
        lastTargetBlendState.sourceColorBlendFactor = sourceColorBlendFactor;
        lastTargetBlendState.destinationColorBlendFactor = destinationColorBlendFactor;
        lastTargetBlendState.sourceAlphaBlendFactor = sourceAlphaBlendFactor;
        lastTargetBlendState.destinationAlphaBlendFactor = destinationAlphaBlendFactor;
      } // apply blend operation.


      if (colorBlendOperation !== lastTargetBlendState.colorBlendOperation || alphaBlendOperation !== lastTargetBlendState.alphaBlendOperation) {
        gl.blendEquationSeparate(BlendState._getGLBlendOperation(rhi, colorBlendOperation), BlendState._getGLBlendOperation(rhi, alphaBlendOperation));
        lastTargetBlendState.colorBlendOperation = colorBlendOperation;
        lastTargetBlendState.alphaBlendOperation = alphaBlendOperation;
      } // apply blend color.


      var blendColor = this.blendColor;

      if (!Color.equals(lastState.blendColor, blendColor)) {
        gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendColor.a);
        blendColor.cloneTo(lastState.blendColor);
      }
    } // apply color mask.


    if (colorWriteMask !== lastTargetBlendState.colorWriteMask) {
      gl.colorMask((colorWriteMask & ColorWriteMask.Red) !== 0, (colorWriteMask & ColorWriteMask.Green) !== 0, (colorWriteMask & ColorWriteMask.Blue) !== 0, (colorWriteMask & ColorWriteMask.Alpha) !== 0);
      lastTargetBlendState.colorWriteMask = colorWriteMask;
    } // apply alpha to coverage.


    var alphaToCoverage = this.alphaToCoverage;

    if (alphaToCoverage !== lastState.alphaToCoverage) {
      if (alphaToCoverage) {
        gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
      } else {
        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
      }

      lastState.alphaToCoverage = alphaToCoverage;
    }
  };

  return BlendState;
}();

/**
 * Depth/Stencil comparison function.
 * @remarks Specifies a function that compares incoming pixel depth/stencil to the current depth/stencil buffer value.
 */
var CompareFunction;

(function (CompareFunction) {
  CompareFunction[CompareFunction["Never"] = 0] = "Never";
  CompareFunction[CompareFunction["Less"] = 1] = "Less";
  CompareFunction[CompareFunction["Equal"] = 2] = "Equal";
  CompareFunction[CompareFunction["LessEqual"] = 3] = "LessEqual";
  CompareFunction[CompareFunction["Greater"] = 4] = "Greater";
  CompareFunction[CompareFunction["NotEqual"] = 5] = "NotEqual";
  CompareFunction[CompareFunction["GreaterEqual"] = 6] = "GreaterEqual";
  CompareFunction[CompareFunction["Always"] = 7] = "Always";
})(CompareFunction || (CompareFunction = {}));

/**
 * Depth state.
 */
var DepthState = /*#__PURE__*/function () {
  function DepthState() {
    this.enabled = true;
    this.writeEnabled = true;
    this.compareFunction = CompareFunction.Less;
  }

  DepthState._getGLCompareFunction = function _getGLCompareFunction(rhi, compareFunction) {
    var gl = rhi.gl;

    switch (compareFunction) {
      case CompareFunction.Never:
        return gl.NEVER;

      case CompareFunction.Less:
        return gl.LESS;

      case CompareFunction.Equal:
        return gl.EQUAL;

      case CompareFunction.LessEqual:
        return gl.LEQUAL;

      case CompareFunction.Greater:
        return gl.GREATER;

      case CompareFunction.NotEqual:
        return gl.NOTEQUAL;

      case CompareFunction.GreaterEqual:
        return gl.GEQUAL;

      case CompareFunction.Always:
        return gl.ALWAYS;
    }
  }
  /** Whether to enable the depth test. */
  ;

  var _proto = DepthState.prototype;

  /**
   * @internal
   * Apply the current depth state by comparing with the last depth state.
   */
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.depthState);
  };

  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var enabled = this.enabled,
        compareFunction = this.compareFunction,
        writeEnabled = this.writeEnabled;

    if (enabled != lastState.enabled) {
      if (enabled) {
        gl.enable(gl.DEPTH_TEST);
      } else {
        gl.disable(gl.DEPTH_TEST);
      }

      lastState.enabled = enabled;
    }

    if (enabled) {
      // apply compare func.
      if (compareFunction != lastState.compareFunction) {
        gl.depthFunc(DepthState._getGLCompareFunction(rhi, compareFunction));
        lastState.compareFunction = compareFunction;
      } // apply write enabled.


      if (writeEnabled != lastState.writeEnabled) {
        gl.depthMask(writeEnabled);
        lastState.writeEnabled = writeEnabled;
      }
    }
  };

  return DepthState;
}();

/**
 * Culling mode.
 * @remarks specifies whether or not front- and/or back-facing polygons can be culled.
 */
var CullMode;

(function (CullMode) {
  CullMode[CullMode["Off"] = 0] = "Off";
  CullMode[CullMode["Front"] = 1] = "Front";
  CullMode[CullMode["Back"] = 2] = "Back";
})(CullMode || (CullMode = {}));

/**
 * Raster state.
 */
var RasterState = /*#__PURE__*/function () {
  function RasterState() {
    this.cullMode = CullMode.Back;
    this.depthBias = 0;
    this.slopeScaledDepthBias = 0;
    this._cullFaceEnable = true;
  }

  var _proto = RasterState.prototype;

  /**
   * @internal
   */
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.rasterState);
  };

  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var cullMode = this.cullMode,
        depthBias = this.depthBias,
        slopeScaledDepthBias = this.slopeScaledDepthBias;
    var cullFaceEnable = cullMode !== CullMode.Off;

    if (cullFaceEnable !== lastState._cullFaceEnable) {
      if (cullFaceEnable) {
        gl.enable(gl.CULL_FACE);
      } else {
        gl.disable(gl.CULL_FACE);
      }

      lastState._cullFaceEnable = cullFaceEnable;
    } // apply front face.


    if (cullFaceEnable) {
      if (cullMode !== lastState.cullMode) {
        if (cullMode == CullMode.Back) {
          gl.cullFace(gl.BACK);
        } else {
          gl.cullFace(gl.FRONT);
        }

        lastState.cullMode = cullMode;
      }
    } // apply polygonOffset.


    if (depthBias !== lastState.depthBias || slopeScaledDepthBias !== lastState.slopeScaledDepthBias) {
      if (depthBias !== 0 || slopeScaledDepthBias !== 0) {
        gl.enable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(slopeScaledDepthBias, depthBias);
      } else {
        gl.disable(gl.POLYGON_OFFSET_FILL);
      }

      lastState.depthBias = depthBias;
      lastState.slopeScaledDepthBias = slopeScaledDepthBias;
    }
  };

  return RasterState;
}();

/**
 * Stencil operation mode.
 * @remarks sets the front and/or back-facing stencil test actions.
 */
var StencilOperation;

(function (StencilOperation) {
  StencilOperation[StencilOperation["Keep"] = 0] = "Keep";
  StencilOperation[StencilOperation["Zero"] = 1] = "Zero";
  StencilOperation[StencilOperation["Replace"] = 2] = "Replace";
  StencilOperation[StencilOperation["IncrementSaturate"] = 3] = "IncrementSaturate";
  StencilOperation[StencilOperation["DecrementSaturate"] = 4] = "DecrementSaturate";
  StencilOperation[StencilOperation["Invert"] = 5] = "Invert";
  StencilOperation[StencilOperation["IncrementWrap"] = 6] = "IncrementWrap";
  StencilOperation[StencilOperation["DecrementWrap"] = 7] = "DecrementWrap";
})(StencilOperation || (StencilOperation = {}));

/**
 * Stencil state.
 */
var StencilState = /*#__PURE__*/function () {
  function StencilState() {
    this.enabled = false;
    this.referenceValue = 0;
    this.mask = 0xff;
    this.writeMask = 0xff;
    this.compareFunctionFront = CompareFunction.Always;
    this.compareFunctionBack = CompareFunction.Always;
    this.passOperationFront = StencilOperation.Keep;
    this.passOperationBack = StencilOperation.Keep;
    this.failOperationFront = StencilOperation.Keep;
    this.failOperationBack = StencilOperation.Keep;
    this.zFailOperationFront = StencilOperation.Keep;
    this.zFailOperationBack = StencilOperation.Keep;
  }

  StencilState._getGLCompareFunction = function _getGLCompareFunction(rhi, compareFunction) {
    var gl = rhi.gl;

    switch (compareFunction) {
      case CompareFunction.Never:
        return gl.NEVER;

      case CompareFunction.Less:
        return gl.LESS;

      case CompareFunction.Equal:
        return gl.EQUAL;

      case CompareFunction.LessEqual:
        return gl.LEQUAL;

      case CompareFunction.Greater:
        return gl.GREATER;

      case CompareFunction.NotEqual:
        return gl.NOTEQUAL;

      case CompareFunction.GreaterEqual:
        return gl.GEQUAL;

      case CompareFunction.Always:
        return gl.ALWAYS;
    }
  };

  StencilState._getGLStencilOperation = function _getGLStencilOperation(rhi, compareFunction) {
    var gl = rhi.gl;

    switch (compareFunction) {
      case StencilOperation.Keep:
        return gl.KEEP;

      case StencilOperation.Zero:
        return gl.ZERO;

      case StencilOperation.Replace:
        return gl.REPLACE;

      case StencilOperation.IncrementSaturate:
        return gl.INCR;

      case StencilOperation.DecrementSaturate:
        return gl.DECR;

      case StencilOperation.Invert:
        return gl.INVERT;

      case StencilOperation.IncrementWrap:
        return gl.INCR_WRAP;

      case StencilOperation.DecrementWrap:
        return gl.DECR_WRAP;
    }
  }
  /** Whether to enable stencil test. */
  ;

  var _proto = StencilState.prototype;

  /**
   * @internal
   */
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.stencilState);
  };

  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var enabled = this.enabled,
        referenceValue = this.referenceValue,
        mask = this.mask,
        compareFunctionFront = this.compareFunctionFront,
        compareFunctionBack = this.compareFunctionBack,
        failOperationFront = this.failOperationFront,
        zFailOperationFront = this.zFailOperationFront,
        passOperationFront = this.passOperationFront,
        failOperationBack = this.failOperationBack,
        zFailOperationBack = this.zFailOperationBack,
        passOperationBack = this.passOperationBack,
        writeMask = this.writeMask;

    if (enabled != lastState.enabled) {
      if (enabled) {
        gl.enable(gl.STENCIL_TEST);
      } else {
        gl.disable(gl.STENCIL_TEST);
      }

      lastState.enabled = enabled;
    }

    if (enabled) {
      // apply stencil func.
      var referenceOrMaskChange = referenceValue !== lastState.referenceValue || mask !== lastState.mask;

      if (referenceOrMaskChange || compareFunctionFront !== lastState.compareFunctionFront) {
        gl.stencilFuncSeparate(gl.FRONT, StencilState._getGLCompareFunction(rhi, compareFunctionFront), referenceValue, mask);
        lastState.compareFunctionFront = compareFunctionFront;
      }

      if (referenceOrMaskChange || compareFunctionBack !== lastState.compareFunctionBack) {
        gl.stencilFuncSeparate(gl.BACK, StencilState._getGLCompareFunction(rhi, compareFunctionBack), referenceValue, mask);
        lastState.compareFunctionBack = this.compareFunctionBack;
      }

      if (referenceOrMaskChange) {
        lastState.referenceValue = this.referenceValue;
        lastState.mask = this.mask;
      } // apply stencil operation.


      if (failOperationFront !== lastState.failOperationFront || zFailOperationFront !== lastState.zFailOperationFront || passOperationFront !== lastState.passOperationFront) {
        gl.stencilOpSeparate(gl.FRONT, StencilState._getGLStencilOperation(rhi, failOperationFront), StencilState._getGLStencilOperation(rhi, zFailOperationFront), StencilState._getGLStencilOperation(rhi, passOperationFront));
        lastState.failOperationFront = failOperationFront;
        lastState.zFailOperationFront = zFailOperationFront;
        lastState.passOperationFront = passOperationFront;
      }

      if (failOperationBack !== lastState.failOperationBack || zFailOperationBack !== lastState.zFailOperationBack || passOperationBack !== lastState.passOperationBack) {
        gl.stencilOpSeparate(gl.BACK, StencilState._getGLStencilOperation(rhi, failOperationBack), StencilState._getGLStencilOperation(rhi, zFailOperationBack), StencilState._getGLStencilOperation(rhi, passOperationBack));
        lastState.failOperationBack = failOperationBack;
        lastState.zFailOperationBack = zFailOperationBack;
        lastState.passOperationBack = passOperationBack;
      } // apply write mask.


      if (writeMask !== lastState.writeMask) {
        gl.stencilMask(writeMask);
        lastState.writeMask = writeMask;
      }
    }
  };

  return StencilState;
}();

/**
 * Render state.
 */

var RenderState = /*#__PURE__*/function () {
  function RenderState() {
    this.blendState = new BlendState();
    this.depthState = new DepthState();
    this.stencilState = new StencilState();
    this.rasterState = new RasterState();
  }

  var _proto = RenderState.prototype;

  /** @internal */
  _proto._apply = function _apply(engine) {
    var hardwareRenderer = engine._hardwareRenderer;
    var lastRenderState = engine._lastRenderState;

    this.blendState._apply(hardwareRenderer, lastRenderState);

    this.depthState._apply(hardwareRenderer, lastRenderState);

    this.stencilState._apply(hardwareRenderer, lastRenderState);

    this.rasterState._apply(hardwareRenderer, lastRenderState);
  };

  return RenderState;
}();

/**
 * Material.
 */

var Material = /*#__PURE__*/function (_RefObject) {
  _inheritsLoose(Material, _RefObject);

  /** Name. */

  /** Shader used by the material. */

  /** Render queue type. */

  /** Shader data. */

  /** Render state. */
  // todo: later will as a part of shaderData when shader effect frame is OK, that is more powerful and flexible.

  /**
   * Create a material instance.
   * @param engine - Engine to which the material belongs
   * @param shader - Shader used by the material
   */
  function Material(engine, shader) {
    var _this;

    _this = _RefObject.call(this, engine) || this;
    _this.name = void 0;
    _this.shader = void 0;
    _this.renderQueueType = RenderQueueType.Opaque;
    _this.shaderData = new ShaderData(ShaderDataGroup.Material);
    _this.renderState = new RenderState();
    _this.shader = shader;
    return _this;
  }
  /**
   * Clone and return the instance.
   */


  var _proto = Material.prototype;

  _proto.clone = function clone() {
    var dest = new Material(this._engine, this.shader);
    this.cloneTo(dest);
    return dest;
  }
  /**
   * Clone to the target material.
   * @param target - target material
   */
  ;

  _proto.cloneTo = function cloneTo(target) {
    target.shader = this.shader;
    target.renderQueueType = this.renderQueueType;
    this.shaderData.cloneTo(target.shaderData);
    CloneManager.deepCloneObject(this.renderState, target.renderState);
  }
  /**
   * @override
   */
  ;

  _proto._addRefCount = function _addRefCount(value) {
    _RefObject.prototype._addRefCount.call(this, value);

    this.shaderData._addRefCount(value);
  }
  /**
   * @internal
   * @todo:temporary solution
   */
  ;

  _proto._preRender = function _preRender(renderElement) {}
  /**
   * @override
   */
  ;

  _proto._onDestroy = function _onDestroy() {};

  return Material;
}(RefObject);

/**
 * Class pool utils.
 */
var ClassPool = /*#__PURE__*/function () {
  function ClassPool(type) {
    this._elementPoolIndex = 0;
    this._elementPool = [];
    this._type = void 0;
    this._type = type;
  }
  /**
   * Get element from pool.
   */


  var _proto = ClassPool.prototype;

  _proto.getFromPool = function getFromPool() {
    var index = this._elementPoolIndex,
        pool = this._elementPool;
    this._elementPoolIndex++;

    if (pool.length === index) {
      var element = new this._type();
      pool.push(element);
      return element;
    } else {
      return pool[index];
    }
  }
  /**
   * Reset pool.
   */
  ;

  _proto.resetPool = function resetPool() {
    this._elementPoolIndex = 0;
  };

  return ClassPool;
}();

/**
 * Rendering context.
 */
var RenderContext = /*#__PURE__*/function () {
  function RenderContext() {
    this._camera = void 0;
    this._viewProjectMatrix = new Matrix();
  }

  var _proto = RenderContext.prototype;

  /**
   * @internal
   */
  _proto._setContext = function _setContext(camera) {
    this._camera = camera;
    Matrix.multiply(camera.projectionMatrix, camera.viewMatrix, this._viewProjectMatrix);
  };

  return RenderContext;
}();

/**
 * Render element.
 */
var RenderElement = /*#__PURE__*/function () {
  function RenderElement() {
    this.component = void 0;
    this.mesh = void 0;
    this.subMesh = void 0;
    this.material = void 0;
  }

  var _proto = RenderElement.prototype;

  _proto.setValue = function setValue(component, mesh, subMesh, material) {
    this.component = component;
    this.mesh = mesh;
    this.subMesh = subMesh;
    this.material = material;
  };

  return RenderElement;
}();

var SpriteElement = /*#__PURE__*/function () {
  function SpriteElement() {
    this.component = void 0;
    this.positions = void 0;
    this.uv = void 0;
    this.triangles = void 0;
    this.color = void 0;
    this.material = void 0;
    this.camera = void 0;
  }

  var _proto = SpriteElement.prototype;

  _proto.setValue = function setValue(component, positions, uv, triangles, color, material, camera) {
    this.component = component;
    this.positions = positions;
    this.uv = uv;
    this.triangles = triangles;
    this.color = color;
    this.material = material;
    this.camera = camera;
  };

  return SpriteElement;
}();

var SpriteMaskElement = /*#__PURE__*/function () {
  function SpriteMaskElement() {
    this.component = void 0;
    this.positions = void 0;
    this.uv = void 0;
    this.triangles = void 0;
    this.material = void 0;
    this.isAdd = true;
    this.camera = void 0;
  }

  var _proto = SpriteMaskElement.prototype;

  _proto.setValue = function setValue(component, positions, uv, triangles, material) {
    this.component = component;
    this.positions = positions;
    this.uv = uv;
    this.triangles = triangles;
    this.material = material;
  };

  return SpriteMaskElement;
}();

/**
 * Sprite mask interaction.
 */
var SpriteMaskInteraction;

(function (SpriteMaskInteraction) {
  SpriteMaskInteraction[SpriteMaskInteraction["None"] = 0] = "None";
  SpriteMaskInteraction[SpriteMaskInteraction["VisibleInsideMask"] = 1] = "VisibleInsideMask";
  SpriteMaskInteraction[SpriteMaskInteraction["VisibleOutsideMask"] = 2] = "VisibleOutsideMask";
})(SpriteMaskInteraction || (SpriteMaskInteraction = {}));

var _class$7, _descriptor$7, _descriptor2$7, _descriptor3$6, _descriptor4$6, _descriptor5$6, _descriptor6$6, _descriptor7$4, _descriptor8$2, _descriptor9$2, _descriptor10$2, _descriptor11$2, _descriptor12$2, _descriptor13$1, _descriptor14, _descriptor15, _descriptor16, _class2$6, _temp$6;

/**
 * Renderable component.
 */
var Renderer = (_class$7 = (_temp$6 = _class2$6 = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Renderer, _Component);

  /**
   * @internal
   */
  function Renderer(entity) {
    var _this;

    _this = _Component.call(this, entity) || this;

    _initializerDefineProperty(_this, "shaderData", _descriptor$7, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "isCulled", _descriptor2$7, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_distanceForSort", _descriptor3$6, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_onUpdateIndex", _descriptor4$6, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_rendererIndex", _descriptor5$6, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_globalShaderMacro", _descriptor6$6, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_renderSortId", _descriptor7$4, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_overrideUpdate", _descriptor8$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_materials", _descriptor9$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_transformChangeFlag", _descriptor10$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_bounds", _descriptor11$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_mvMatrix", _descriptor12$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_mvpMatrix", _descriptor13$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_mvInvMatrix", _descriptor14, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_normalMatrix", _descriptor15, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_materialsInstanced", _descriptor16, _assertThisInitialized(_this));

    var prototype = Renderer.prototype;
    _this._overrideUpdate = _this.update !== prototype.update;
    _this._transformChangeFlag = _this.entity.transform.registerWorldChangeFlag();

    _this.shaderData._addRefCount(1);

    return _this;
  }
  /**
   * Get the first instance material.
   * @returns The first instance material
   */


  var _proto = Renderer.prototype;

  _proto.getInstanceMaterial = function getInstanceMaterial(index) {
    if (index === void 0) {
      index = 0;
    }

    var materials = this._materials;

    if (materials.length > index) {
      var _material = materials[index];

      if (_material) {
        if (this._materialsInstanced[index]) {
          return _material;
        } else {
          return this._createInstanceMaterial(_material, index);
        }
      }
    }

    return null;
  }
  /**
   * Get the first material.
   * @returns The first material
   */
  ;

  _proto.getMaterial = function getMaterial(index) {
    if (index === void 0) {
      index = 0;
    }

    return this._materials[index] || null;
  }
  /**
   * Set the first material.
   * @param material - The first material
   */
  ;

  _proto.setMaterial = function setMaterial(indexOrMaterial, material) {
    if (material === void 0) {
      material = null;
    }

    var index;

    if (typeof indexOrMaterial === "number") {
      index = indexOrMaterial;
    } else {
      index = 0;
      material = indexOrMaterial;
    }

    var materials = this._materials;

    if (index >= materials.length) {
      materials.length = index + 1;
    }

    var materialsInstance = this._materialsInstanced;
    var internalMaterial = materials[index];

    if (internalMaterial !== material) {
      materials[index] = material;
      index < materialsInstance.length && (materialsInstance[index] = false);
      internalMaterial && internalMaterial._addRefCount(-1);
      material && material._addRefCount(1);
    }
  }
  /**
   * Get all instance materials.
   * @remarks Calling this function for the first time after the material is set will create an instance material to ensure that it is unique to the renderer.
   * @returns All instance materials
   */
  ;

  _proto.getInstanceMaterials = function getInstanceMaterials() {
    var materials = this._materials;
    var materialsInstance = this._materialsInstanced;

    for (var i = 0, n = materials.length; i < n; i++) {
      if (!materialsInstance[i]) {
        this._createInstanceMaterial(this._materials[i], i);
      }
    }

    return materials;
  }
  /**
   * Get all materials.
   * @returns All materials
   */
  ;

  _proto.getMaterials = function getMaterials() {
    return this._materials;
  }
  /**
   * Set all materials.
   * @param materials - All materials
   */
  ;

  _proto.setMaterials = function setMaterials(materials) {
    var count = materials.length;
    var internalMaterials = this._materials;
    var materialsInstanced = this._materialsInstanced;

    for (var i = count, n = internalMaterials.length; i < n; i++) {
      var internalMaterial = internalMaterials[i];
      internalMaterial && internalMaterial._addRefCount(-1);
    }

    internalMaterials.length !== count && (internalMaterials.length = count);
    materialsInstanced.length !== 0 && (materialsInstanced.length = 0);

    for (var _i = 0; _i < count; _i++) {
      var _internalMaterial = internalMaterials[_i];
      var _material2 = materials[_i];

      if (_internalMaterial !== _material2) {
        internalMaterials[_i] = _material2;
        _internalMaterial && _internalMaterial._addRefCount(-1);
        _material2 && _material2._addRefCount(1);
      }
    }
  };

  _proto.update = function update(deltaTime) {}
  /**
   * @internal
   */
  ;

  _proto._updateShaderData = function _updateShaderData(context) {
    var shaderData = this.shaderData;
    var worldMatrix = this.entity.transform.worldMatrix;
    var mvMatrix = this._mvMatrix;
    var mvpMatrix = this._mvpMatrix;
    var mvInvMatrix = this._mvInvMatrix;
    var normalMatrix = this._normalMatrix;
    Matrix.multiply(context._camera.viewMatrix, worldMatrix, mvMatrix);
    Matrix.multiply(context._viewProjectMatrix, worldMatrix, mvpMatrix);
    Matrix.invert(mvMatrix, mvInvMatrix);
    Matrix.invert(worldMatrix, normalMatrix);
    normalMatrix.transpose();
    shaderData.setMatrix(Renderer._localMatrixProperty, this.entity.transform.localMatrix);
    shaderData.setMatrix(Renderer._worldMatrixProperty, worldMatrix);
    shaderData.setMatrix(Renderer._mvMatrixProperty, mvMatrix);
    shaderData.setMatrix(Renderer._mvpMatrixProperty, mvpMatrix);
    shaderData.setMatrix(Renderer._mvInvMatrixProperty, mvInvMatrix);
    shaderData.setMatrix(Renderer._normalMatrixProperty, normalMatrix);
  };

  _proto._onEnable = function _onEnable() {
    var componentsManager = this.engine._componentsManager;

    if (this._overrideUpdate) {
      componentsManager.addOnUpdateRenderers(this);
    }

    componentsManager.addRenderer(this);
  };

  _proto._onDisable = function _onDisable() {
    var componentsManager = this.engine._componentsManager;

    if (this._overrideUpdate) {
      componentsManager.removeOnUpdateRenderers(this);
    }

    componentsManager.removeRenderer(this);
  }
  /**
   * @internal
   */
  ;

  /**
   * @internal
   */
  _proto._onDestroy = function _onDestroy() {
    var flag = this._transformChangeFlag;

    if (flag) {
      flag.destroy();
      this._transformChangeFlag = null;
    }

    this.shaderData._addRefCount(-1);

    for (var i = 0, n = this._materials.length; i < n; i++) {
      this._materials[i]._addRefCount(-1);
    }
  };

  _proto._updateBounds = function _updateBounds(worldBounds) {};

  _proto._createInstanceMaterial = function _createInstanceMaterial(material, index) {
    var insMaterial = material.clone();
    insMaterial.name = insMaterial.name + "(Instance)";

    material._addRefCount(-1);

    insMaterial._addRefCount(1);

    this._materialsInstanced[index] = true;
    this._materials[index] = insMaterial;
    return insMaterial;
  };

  _createClass(Renderer, [{
    key: "materialCount",
    get:
    /** ShaderData related to renderer. */

    /** Whether it is clipped by the frustum, needs to be turned on camera.enableFrustumCulling. */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal temp solution. */

    /**
     * Material count.
     */
    function get() {
      return this._materials.length;
    },
    set: function set(value) {
      var materials = this._materials;
      var materialsInstanced = this._materialsInstanced;
      materials.length !== value && (materials.length = value);
      materialsInstanced.length > value && (materialsInstanced.length = value);
    }
    /**
     * The bounding volume of the renderer.
     */

  }, {
    key: "bounds",
    get: function get() {
      var changeFlag = this._transformChangeFlag;

      if (changeFlag.flag) {
        this._updateBounds(this._bounds);

        changeFlag.flag = false;
      }

      return this._bounds;
    }
  }]);

  return Renderer;
}(Component), _class2$6._localMatrixProperty = Shader.getPropertyByName("u_localMat"), _class2$6._worldMatrixProperty = Shader.getPropertyByName("u_modelMat"), _class2$6._mvMatrixProperty = Shader.getPropertyByName("u_MVMat"), _class2$6._mvpMatrixProperty = Shader.getPropertyByName("u_MVPMat"), _class2$6._mvInvMatrixProperty = Shader.getPropertyByName("u_MVInvMat"), _class2$6._normalMatrixProperty = Shader.getPropertyByName("u_normalMat"), _temp$6), (_descriptor$7 = _applyDecoratedDescriptor(_class$7.prototype, "shaderData", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new ShaderData(ShaderDataGroup.Renderer);
  }
}), _descriptor2$7 = _applyDecoratedDescriptor(_class$7.prototype, "isCulled", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor3$6 = _applyDecoratedDescriptor(_class$7.prototype, "_distanceForSort", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$6 = _applyDecoratedDescriptor(_class$7.prototype, "_onUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor5$6 = _applyDecoratedDescriptor(_class$7.prototype, "_rendererIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor6$6 = _applyDecoratedDescriptor(_class$7.prototype, "_globalShaderMacro", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new ShaderMacroCollection();
  }
}), _descriptor7$4 = _applyDecoratedDescriptor(_class$7.prototype, "_renderSortId", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0;
  }
}), _descriptor8$2 = _applyDecoratedDescriptor(_class$7.prototype, "_overrideUpdate", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor9$2 = _applyDecoratedDescriptor(_class$7.prototype, "_materials", [shallowClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor10$2 = _applyDecoratedDescriptor(_class$7.prototype, "_transformChangeFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor11$2 = _applyDecoratedDescriptor(_class$7.prototype, "_bounds", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new BoundingBox(new Vector3(), new Vector3());
  }
}), _descriptor12$2 = _applyDecoratedDescriptor(_class$7.prototype, "_mvMatrix", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor13$1 = _applyDecoratedDescriptor(_class$7.prototype, "_mvpMatrix", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor14 = _applyDecoratedDescriptor(_class$7.prototype, "_mvInvMatrix", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor15 = _applyDecoratedDescriptor(_class$7.prototype, "_normalMatrix", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor16 = _applyDecoratedDescriptor(_class$7.prototype, "_materialsInstanced", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
})), _class$7);

/**
 * Sprite mask layer.
 */
var SpriteMaskLayer;

(function (SpriteMaskLayer) {
  SpriteMaskLayer[SpriteMaskLayer["Layer0"] = 1] = "Layer0";
  SpriteMaskLayer[SpriteMaskLayer["Layer1"] = 2] = "Layer1";
  SpriteMaskLayer[SpriteMaskLayer["Layer2"] = 4] = "Layer2";
  SpriteMaskLayer[SpriteMaskLayer["Layer3"] = 8] = "Layer3";
  SpriteMaskLayer[SpriteMaskLayer["Layer4"] = 16] = "Layer4";
  SpriteMaskLayer[SpriteMaskLayer["Layer5"] = 32] = "Layer5";
  SpriteMaskLayer[SpriteMaskLayer["Layer6"] = 64] = "Layer6";
  SpriteMaskLayer[SpriteMaskLayer["Layer7"] = 128] = "Layer7";
  SpriteMaskLayer[SpriteMaskLayer["Layer8"] = 256] = "Layer8";
  SpriteMaskLayer[SpriteMaskLayer["Layer9"] = 512] = "Layer9";
  SpriteMaskLayer[SpriteMaskLayer["Layer10"] = 1024] = "Layer10";
  SpriteMaskLayer[SpriteMaskLayer["Layer11"] = 2048] = "Layer11";
  SpriteMaskLayer[SpriteMaskLayer["Layer12"] = 4096] = "Layer12";
  SpriteMaskLayer[SpriteMaskLayer["Layer13"] = 8192] = "Layer13";
  SpriteMaskLayer[SpriteMaskLayer["Layer14"] = 16384] = "Layer14";
  SpriteMaskLayer[SpriteMaskLayer["Layer15"] = 32768] = "Layer15";
  SpriteMaskLayer[SpriteMaskLayer["Layer16"] = 65536] = "Layer16";
  SpriteMaskLayer[SpriteMaskLayer["Layer17"] = 131072] = "Layer17";
  SpriteMaskLayer[SpriteMaskLayer["Layer18"] = 262144] = "Layer18";
  SpriteMaskLayer[SpriteMaskLayer["Layer19"] = 524288] = "Layer19";
  SpriteMaskLayer[SpriteMaskLayer["Layer20"] = 1048576] = "Layer20";
  SpriteMaskLayer[SpriteMaskLayer["Layer21"] = 2097152] = "Layer21";
  SpriteMaskLayer[SpriteMaskLayer["Layer22"] = 4194304] = "Layer22";
  SpriteMaskLayer[SpriteMaskLayer["Layer23"] = 8388608] = "Layer23";
  SpriteMaskLayer[SpriteMaskLayer["Layer24"] = 16777216] = "Layer24";
  SpriteMaskLayer[SpriteMaskLayer["Layer25"] = 33554432] = "Layer25";
  SpriteMaskLayer[SpriteMaskLayer["Layer26"] = 67108864] = "Layer26";
  SpriteMaskLayer[SpriteMaskLayer["Layer27"] = 134217728] = "Layer27";
  SpriteMaskLayer[SpriteMaskLayer["Layer28"] = 268435456] = "Layer28";
  SpriteMaskLayer[SpriteMaskLayer["Layer29"] = 536870912] = "Layer29";
  SpriteMaskLayer[SpriteMaskLayer["Layer30"] = 1073741824] = "Layer30";
  SpriteMaskLayer[SpriteMaskLayer["Layer31"] = 2147483648] = "Layer31";
  SpriteMaskLayer[SpriteMaskLayer["Everything"] = 4294967295] = "Everything";
})(SpriteMaskLayer || (SpriteMaskLayer = {}));

var _class$6, _descriptor$6, _descriptor2$6, _descriptor3$5, _descriptor4$5, _descriptor5$5, _descriptor6$5, _class2$5, _temp$5;

/**
 * A component for masking Sprites.
 */
var SpriteMask = (_class$6 = (_temp$5 = _class2$5 = /*#__PURE__*/function (_Renderer) {
  _inheritsLoose(SpriteMask, _Renderer);

  /**
   * @internal
   */
  function SpriteMask(entity) {
    var _this;

    _this = _Renderer.call(this, entity) || this;
    _this._maskElement = void 0;

    _initializerDefineProperty(_this, "_positions", _descriptor$6, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_isSpriteDirty", _descriptor2$6, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_worldMatrixDirtyFlag", _descriptor3$5, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_sprite", _descriptor4$5, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_alphaCutoff", _descriptor5$5, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "influenceLayers", _descriptor6$5, _assertThisInitialized(_this));

    _this._worldMatrixDirtyFlag = entity.transform.registerWorldChangeFlag();

    _this.setMaterial(_this._engine._spriteMaskDefaultMaterial);

    _this.shaderData.setFloat(SpriteMask._alphaCutoffProperty, _this._alphaCutoff);

    return _this;
  }
  /**
   * @override
   * @inheritdoc
   */


  var _proto = SpriteMask.prototype;

  _proto._onDestroy = function _onDestroy() {
    this._worldMatrixDirtyFlag.destroy();

    _Renderer.prototype._onDestroy.call(this);
  }
  /**
   * @override
   * @inheritdoc
   */
  ;

  _proto._render = function _render(camera) {
    var sprite = this.sprite;

    if (!sprite) {
      return null;
    }

    var texture = sprite.texture;

    if (!texture) {
      return null;
    }

    var positions = this._positions;
    var transform = this.entity.transform; // Update sprite data.

    var localDirty = sprite._updateMeshData();

    if (this._worldMatrixDirtyFlag.flag || localDirty || this._isSpriteDirty) {
      var localPositions = sprite._positions;
      var localVertexPos = SpriteMask._tempVec3;
      var worldMatrix = transform.worldMatrix;

      for (var i = 0, n = positions.length; i < n; i++) {
        var curVertexPos = localPositions[i];
        localVertexPos.setValue(curVertexPos.x, curVertexPos.y, 0);
        Vector3.transformToVec3(localVertexPos, worldMatrix, positions[i]);
      }

      this._isSpriteDirty = false;
      this._worldMatrixDirtyFlag.flag = false;
    }

    this.shaderData.setTexture(SpriteMask._textureProperty, texture);
    var spriteMaskElementPool = this._engine._spriteMaskElementPool;
    var maskElement = spriteMaskElementPool.getFromPool();
    maskElement.setValue(this, positions, sprite._uv, sprite._triangles, this.getMaterial());
    maskElement.camera = camera;

    camera._renderPipeline._allSpriteMasks.add(this);

    this._maskElement = maskElement;
  };

  _createClass(SpriteMask, [{
    key: "sprite",
    get:
    /** @internal */

    /** @internal */

    /** @internal */

    /** The mask layers the sprite mask influence to. */

    /**
     * The Sprite used to define the mask.
     */
    function get() {
      return this._sprite;
    },
    set: function set(value) {
      if (this._sprite !== value) {
        this._sprite = value;
        this._isSpriteDirty = true;
      }
    }
    /**
     * The minimum alpha value used by the mask to select the area of influence defined over the mask's sprite. Value between 0 and 1.
     */

  }, {
    key: "alphaCutoff",
    get: function get() {
      return this._alphaCutoff;
    },
    set: function set(value) {
      if (this._alphaCutoff !== value) {
        this._alphaCutoff = value;
        this.shaderData.setFloat(SpriteMask._alphaCutoffProperty, value);
      }
    }
  }]);

  return SpriteMask;
}(Renderer), _class2$5._textureProperty = Shader.getPropertyByName("u_maskTexture"), _class2$5._alphaCutoffProperty = Shader.getPropertyByName("u_maskAlphaCutoff"), _class2$5._tempVec3 = new Vector3(), _temp$5), (_descriptor$6 = _applyDecoratedDescriptor(_class$6.prototype, "_positions", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [new Vector3(), new Vector3(), new Vector3(), new Vector3()];
  }
}), _descriptor2$6 = _applyDecoratedDescriptor(_class$6.prototype, "_isSpriteDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return true;
  }
}), _descriptor3$5 = _applyDecoratedDescriptor(_class$6.prototype, "_worldMatrixDirtyFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$5 = _applyDecoratedDescriptor(_class$6.prototype, "_sprite", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor5$5 = _applyDecoratedDescriptor(_class$6.prototype, "_alphaCutoff", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0.5;
  }
}), _descriptor6$5 = _applyDecoratedDescriptor(_class$6.prototype, "influenceLayers", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return SpriteMaskLayer.Everything;
  }
})), _class$6);

/**
 * Vertex element format.
 */
var VertexElementFormat;

(function (VertexElementFormat) {
  VertexElementFormat[VertexElementFormat["Float"] = 0] = "Float";
  VertexElementFormat[VertexElementFormat["Vector2"] = 1] = "Vector2";
  VertexElementFormat[VertexElementFormat["Vector3"] = 2] = "Vector3";
  VertexElementFormat[VertexElementFormat["Vector4"] = 3] = "Vector4";
  VertexElementFormat[VertexElementFormat["Byte4"] = 4] = "Byte4";
  VertexElementFormat[VertexElementFormat["UByte4"] = 5] = "UByte4";
  VertexElementFormat[VertexElementFormat["NormalizedByte4"] = 6] = "NormalizedByte4";
  VertexElementFormat[VertexElementFormat["NormalizedUByte4"] = 7] = "NormalizedUByte4";
  VertexElementFormat[VertexElementFormat["Short2"] = 8] = "Short2";
  VertexElementFormat[VertexElementFormat["UShort2"] = 9] = "UShort2";
  VertexElementFormat[VertexElementFormat["NormalizedShort2"] = 10] = "NormalizedShort2";
  VertexElementFormat[VertexElementFormat["NormalizedUShort2"] = 11] = "NormalizedUShort2";
  VertexElementFormat[VertexElementFormat["Short4"] = 12] = "Short4";
  VertexElementFormat[VertexElementFormat["UShort4"] = 13] = "UShort4";
  VertexElementFormat[VertexElementFormat["NormalizedShort4"] = 14] = "NormalizedShort4";
  VertexElementFormat[VertexElementFormat["NormalizedUShort4"] = 15] = "NormalizedUShort4";
})(VertexElementFormat || (VertexElementFormat = {}));

/**
 * Buffer usage.
 */
var BufferUsage;

(function (BufferUsage) {
  BufferUsage[BufferUsage["Static"] = 0] = "Static";
  BufferUsage[BufferUsage["Dynamic"] = 1] = "Dynamic";
  BufferUsage[BufferUsage["Stream"] = 2] = "Stream";
})(BufferUsage || (BufferUsage = {}));

/**
 * Index format.
 */
var IndexFormat;

(function (IndexFormat) {
  IndexFormat[IndexFormat["UInt8"] = 0] = "UInt8";
  IndexFormat[IndexFormat["UInt16"] = 1] = "UInt16";
  IndexFormat[IndexFormat["UInt32"] = 2] = "UInt32";
})(IndexFormat || (IndexFormat = {}));

var BufferUtil = /*#__PURE__*/function () {
  function BufferUtil() {}

  /**
   * @internal
   */
  BufferUtil._getGLBufferUsage = function _getGLBufferUsage(gl, bufferUsage) {
    switch (bufferUsage) {
      case BufferUsage.Static:
        return gl.STATIC_DRAW;

      case BufferUsage.Dynamic:
        return gl.DYNAMIC_DRAW;

      case BufferUsage.Stream:
        return gl.STREAM_DRAW;
    }
  };

  BufferUtil._getGLIndexType = function _getGLIndexType(indexFormat) {
    switch (indexFormat) {
      case IndexFormat.UInt8:
        return DataType.UNSIGNED_BYTE;

      case IndexFormat.UInt16:
        return DataType.UNSIGNED_SHORT;

      case IndexFormat.UInt32:
        return DataType.UNSIGNED_INT;
    }
  };

  BufferUtil._getGLIndexByteCount = function _getGLIndexByteCount(indexFormat) {
    switch (indexFormat) {
      case IndexFormat.UInt8:
        return 1;

      case IndexFormat.UInt16:
        return 2;

      case IndexFormat.UInt32:
        return 4;
    }
  }
  /**
   * @internal
   */
  ;

  BufferUtil._getElementInfo = function _getElementInfo(format) {
    var size;
    var type;
    var normalized = false;

    switch (format) {
      case VertexElementFormat.Float:
        size = 1;
        type = DataType.FLOAT;
        break;

      case VertexElementFormat.Vector2:
        size = 2;
        type = DataType.FLOAT;
        break;

      case VertexElementFormat.Vector3:
        size = 3;
        type = DataType.FLOAT;
        break;

      case VertexElementFormat.Vector4:
        size = 4;
        type = DataType.FLOAT;
        break;

      case VertexElementFormat.Byte4:
        size = 4;
        type = DataType.BYTE;
        break;

      case VertexElementFormat.UByte4:
        size = 4;
        type = DataType.UNSIGNED_BYTE;
        break;

      case VertexElementFormat.NormalizedByte4:
        size = 4;
        type = DataType.BYTE;
        normalized = true;
        break;

      case VertexElementFormat.NormalizedUByte4:
        size = 4;
        type = DataType.UNSIGNED_BYTE;
        normalized = true;
        break;

      case VertexElementFormat.Short2:
        size = 2;
        type = DataType.SHORT;
        break;

      case VertexElementFormat.UShort2:
        size = 2;
        type = DataType.UNSIGNED_SHORT;
        break;

      case VertexElementFormat.NormalizedShort2:
        size = 2;
        type = DataType.SHORT;
        normalized = true;
        break;

      case VertexElementFormat.NormalizedUShort2:
        size = 2;
        type = DataType.UNSIGNED_SHORT;
        normalized = true;
        break;

      case VertexElementFormat.Short4:
        size = 4;
        type = DataType.SHORT;
        break;

      case VertexElementFormat.UShort4:
        size = 4;
        type = DataType.UNSIGNED_SHORT;
        break;

      case VertexElementFormat.NormalizedShort4:
        size = 4;
        type = DataType.SHORT;
        normalized = true;
        break;

      case VertexElementFormat.NormalizedUShort4:
        size = 4;
        type = DataType.UNSIGNED_SHORT;
        normalized = true;
        break;
    }

    return {
      size: size,
      type: type,
      normalized: normalized
    };
  };

  return BufferUtil;
}();

/**
 * Vertex element.
 */

var VertexElement = /*#__PURE__*/function () {
  /**
   * Create vertex element.
   * @param semantic - Input vertex semantic
   * @param offset - Vertex data byte offset
   * @param format - Vertex data format
   * @param bindingIndex - Vertex buffer binding index
   * @param instanceStepRate - Instance cadence, the number of instances drawn for each vertex in the buffer, non-instance elements must be 0.
   */
  function VertexElement(semantic, offset, format, bindingIndex, instanceStepRate) {
    if (instanceStepRate === void 0) {
      instanceStepRate = 0;
    }

    this._glElementInfo = void 0;
    this._semantic = void 0;
    this._offset = void 0;
    this._format = void 0;
    this._bindingIndex = void 0;
    this._instanceStepRate = void 0;
    this._semantic = semantic;
    this._offset = offset;
    this._format = format;
    this._bindingIndex = bindingIndex;
    this._glElementInfo = BufferUtil._getElementInfo(this.format);
    this._instanceStepRate = Math.floor(instanceStepRate);
  }

  _createClass(VertexElement, [{
    key: "semantic",
    get:
    /**
     * Vertex semantic.
     */
    function get() {
      return this._semantic;
    }
    /**
     * Vertex data byte offset.
     */

  }, {
    key: "offset",
    get: function get() {
      return this._offset;
    }
    /**
     * Vertex data format.
     */

  }, {
    key: "format",
    get: function get() {
      return this._format;
    }
    /**
     * Vertex buffer binding index.
     */

  }, {
    key: "bindingIndex",
    get: function get() {
      return this._bindingIndex;
    }
    /**
     * Instance cadence, the number of instances drawn for each vertex in the buffer, non-instance elements must be 0.
     */

  }, {
    key: "instanceStepRate",
    get: function get() {
      return this._instanceStepRate;
    }
  }]);

  return VertexElement;
}();

/**
 * Buffer binding flag.
 */
var BufferBindFlag;

(function (BufferBindFlag) {
  BufferBindFlag[BufferBindFlag["VertexBuffer"] = 0] = "VertexBuffer";
  BufferBindFlag[BufferBindFlag["IndexBuffer"] = 1] = "IndexBuffer";
})(BufferBindFlag || (BufferBindFlag = {}));

/**
 * Define update strategy when call bufferData/bufferSubData func.
 */
var SetDataOptions;

(function (SetDataOptions) {
  SetDataOptions[SetDataOptions["None"] = 0] = "None";
  SetDataOptions[SetDataOptions["Discard"] = 1] = "Discard";
})(SetDataOptions || (SetDataOptions = {}));

/**
 * Buffer.
 */

var Buffer = /*#__PURE__*/function (_RefObject) {
  _inheritsLoose(Buffer, _RefObject);

  function Buffer(engine, type, byteLengthOrData, bufferUsage) {
    var _this;

    if (bufferUsage === void 0) {
      bufferUsage = BufferUsage.Static;
    }

    _this = _RefObject.call(this, engine) || this;
    _this._glBindTarget = void 0;
    _this._glBufferUsage = void 0;
    _this._nativeBuffer = void 0;
    _this._hardwareRenderer = void 0;
    _this._type = void 0;
    _this._byteLength = void 0;
    _this._bufferUsage = void 0;
    _this._engine = engine;
    _this._type = type;
    _this._bufferUsage = bufferUsage;
    var hardwareRenderer = engine._hardwareRenderer;
    var gl = hardwareRenderer.gl;

    var glBufferUsage = BufferUtil._getGLBufferUsage(gl, bufferUsage);

    var glBindTarget = type === BufferBindFlag.VertexBuffer ? gl.ARRAY_BUFFER : gl.ELEMENT_ARRAY_BUFFER;
    _this._nativeBuffer = gl.createBuffer();
    _this._hardwareRenderer = hardwareRenderer;
    _this._glBufferUsage = glBufferUsage;
    _this._glBindTarget = glBindTarget;

    _this.bind();

    if (typeof byteLengthOrData === "number") {
      _this._byteLength = byteLengthOrData;
      gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);
    } else {
      _this._byteLength = byteLengthOrData.byteLength;
      gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);
    }

    gl.bindBuffer(glBindTarget, null);
    return _this;
  }
  /**
   * Bind buffer.
   */


  var _proto = Buffer.prototype;

  _proto.bind = function bind() {
    var gl = this._hardwareRenderer.gl;
    gl.bindBuffer(this._glBindTarget, this._nativeBuffer);
  }
  /**
   * Set buffer data.
   * @param data - Input buffer data
   */
  ;

  _proto.setData = function setData(data, bufferByteOffset, dataOffset, dataLength, options) {
    if (bufferByteOffset === void 0) {
      bufferByteOffset = 0;
    }

    if (dataOffset === void 0) {
      dataOffset = 0;
    }

    if (options === void 0) {
      options = SetDataOptions.None;
    }

    var gl = this._hardwareRenderer.gl;
    var isWebGL2 = this._hardwareRenderer.isWebGL2;
    var glBindTarget = this._glBindTarget;
    this.bind();

    if (options === SetDataOptions.Discard) {
      gl.bufferData(glBindTarget, this._byteLength, this._glBufferUsage);
    } // TypeArray is BYTES_PER_ELEMENT, unTypeArray is 1


    var byteSize = data.BYTES_PER_ELEMENT || 1;
    var dataByteLength = dataLength ? byteSize * dataLength : data.byteLength;

    if (dataOffset !== 0 || dataByteLength < data.byteLength) {
      var isArrayBufferView = data.byteOffset !== undefined;

      if (isWebGL2 && isArrayBufferView) {
        gl.bufferSubData(glBindTarget, bufferByteOffset, data, dataOffset, dataByteLength / byteSize);
      } else {
        var subData = new Uint8Array(isArrayBufferView ? data.buffer : data, dataOffset * byteSize, dataByteLength);
        gl.bufferSubData(glBindTarget, bufferByteOffset, subData);
      }
    } else {
      gl.bufferSubData(glBindTarget, bufferByteOffset, data);
    }

    gl.bindBuffer(glBindTarget, null);
  }
  /**
   * Get buffer data.
   * @param data - Output buffer data
   */
  ;

  _proto.getData = function getData(data, bufferByteOffset, dataOffset, dataLength) {
    if (bufferByteOffset === void 0) {
      bufferByteOffset = 0;
    }

    if (dataOffset === void 0) {
      dataOffset = 0;
    }

    var isWebGL2 = this._hardwareRenderer.isWebGL2;

    if (isWebGL2) {
      var gl = this._hardwareRenderer.gl;
      this.bind();
      gl.getBufferSubData(this._glBindTarget, bufferByteOffset, data, dataOffset, dataLength);
    } else {
      throw "Buffer is write-only on WebGL1.0 platforms.";
    }
  }
  /**
   * @override
   * Destroy.
   */
  ;

  _proto._onDestroy = function _onDestroy() {
    var gl = this._hardwareRenderer.gl;
    gl.deleteBuffer(this._nativeBuffer);
    this._nativeBuffer = null;
    this._hardwareRenderer = null;
  }
  /**
   * @deprecated
   */
  ;

  _proto.resize = function resize(dataLength) {
    this.bind();
    var gl = this._hardwareRenderer.gl;
    gl.bufferData(this._glBindTarget, dataLength, this._glBufferUsage);
    this._byteLength = dataLength;
  };

  _createClass(Buffer, [{
    key: "type",
    get:
    /**
     * Buffer binding flag.
     */
    function get() {
      return this._type;
    }
    /**
     * Byte length.
     */

  }, {
    key: "byteLength",
    get: function get() {
      return this._byteLength;
    }
    /**
     * Buffer usage.
     */

  }, {
    key: "bufferUsage",
    get: function get() {
      return this._bufferUsage;
    }
    /**
     * Create Buffer.
     * @param engine - Engine
     * @param type - Buffer binding flag
     * @param byteLength - Byte length
     * @param bufferUsage - Buffer usage
     */

  }]);

  return Buffer;
}(RefObject);

/**
 * Mesh topology.
 */
var MeshTopology;

(function (MeshTopology) {
  MeshTopology[MeshTopology["Points"] = 0] = "Points";
  MeshTopology[MeshTopology["Lines"] = 1] = "Lines";
  MeshTopology[MeshTopology["LineLoop"] = 2] = "LineLoop";
  MeshTopology[MeshTopology["LineStrip"] = 3] = "LineStrip";
  MeshTopology[MeshTopology["Triangles"] = 4] = "Triangles";
  MeshTopology[MeshTopology["TriangleStrip"] = 5] = "TriangleStrip";
  MeshTopology[MeshTopology["TriangleFan"] = 6] = "TriangleFan";
})(MeshTopology || (MeshTopology = {}));

/**
 * Index buffer binding.
 */
var IndexBufferBinding = /*#__PURE__*/function () {
  /**
   * Create index buffer binding.
   * @param buffer - Index buffer
   * @param format - Index buffer format
   */
  function IndexBufferBinding(buffer, format) {
    this._buffer = void 0;
    this._format = void 0;
    this._buffer = buffer;
    this._format = format;
  }

  _createClass(IndexBufferBinding, [{
    key: "buffer",
    get:
    /** @internal */

    /** @internal */

    /**
     * Index buffer.
     */
    function get() {
      return this._buffer;
    }
    /**
     * Index buffer format.
     */

  }, {
    key: "format",
    get: function get() {
      return this._format;
    }
  }]);

  return IndexBufferBinding;
}();

/**
 * Sub-mesh, mainly contains drawing information.
 */

var SubMesh =
/** Start drawing offset. */

/** Drawing count. */

/** Drawing topology. */

/**
 * Create a sub-mesh.
 * @param start - Start drawing offset
 * @param count - Drawing count
 * @param topology - Drawing topology
 */
function SubMesh(start, count, topology) {
  if (start === void 0) {
    start = 0;
  }

  if (count === void 0) {
    count = 0;
  }

  if (topology === void 0) {
    topology = MeshTopology.Triangles;
  }

  this.start = void 0;
  this.count = void 0;
  this.topology = void 0;
  this.start = start;
  this.count = count;
  this.topology = topology;
};

/**
 * Mesh.
 */

var Mesh = /*#__PURE__*/function (_RefObject) {
  _inheritsLoose(Mesh, _RefObject);

  /**
   * Create mesh.
   * @param engine - Engine
   * @param name - Mesh name
   */
  function Mesh(engine, name) {
    var _this;

    _this = _RefObject.call(this, engine) || this;
    _this.name = void 0;
    _this.bounds = new BoundingBox();
    _this._vertexElementMap = {};
    _this._glIndexType = void 0;
    _this._glIndexByteCount = void 0;
    _this._platformPrimitive = void 0;
    _this._instanceCount = 0;
    _this._vertexBufferBindings = [];
    _this._indexBufferBinding = null;
    _this._vertexElements = [];
    _this._subMeshes = [];
    _this._updateFlagManager = new UpdateFlagManager();
    _this.name = name;
    _this._platformPrimitive = _this._engine._hardwareRenderer.createPlatformPrimitive(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Add sub-mesh, each sub-mesh can correspond to an independent material.
   * @param subMesh - Start drawing offset, if the index buffer is set, it means the offset in the index buffer, if not set, it means the offset in the vertex buffer
   * @returns Sub-mesh
   */


  var _proto = Mesh.prototype;

  _proto.addSubMesh = function addSubMesh(startOrSubMesh, count, topology) {
    if (topology === void 0) {
      topology = MeshTopology.Triangles;
    }

    if (typeof startOrSubMesh === "number") {
      startOrSubMesh = new SubMesh(startOrSubMesh, count, topology);
    }

    this._subMeshes.push(startOrSubMesh);

    return startOrSubMesh;
  }
  /**
   * Remove sub-mesh.
   * @param subMesh - Sub-mesh needs to be removed
   */
  ;

  _proto.removeSubMesh = function removeSubMesh(subMesh) {
    var subMeshes = this._subMeshes;
    var index = subMeshes.indexOf(subMesh);

    if (index !== -1) {
      subMeshes.splice(index, 1);
    }
  }
  /**
   * Clear all sub-mesh.
   */
  ;

  _proto.clearSubMesh = function clearSubMesh() {
    this._subMeshes.length = 0;
  }
  /**
   * Register update flag, update flag will be true if the vertex element changes.
   * @returns Update flag
   */
  ;

  _proto.registerUpdateFlag = function registerUpdateFlag() {
    return this._updateFlagManager.register();
  }
  /**
   * @internal
   */
  ;

  _proto._draw = function _draw(shaderProgram, subMesh) {
    this._platformPrimitive.draw(shaderProgram, subMesh);
  }
  /**
   * @override
   */
  ;

  _proto._addRefCount = function _addRefCount(value) {
    _RefObject.prototype._addRefCount.call(this, value);

    var vertexBufferBindings = this._vertexBufferBindings;

    for (var i = 0, n = vertexBufferBindings.length; i < n; i++) {
      vertexBufferBindings[i]._buffer._addRefCount(value);
    }
  }
  /**
   * @override
   * Destroy.
   */
  ;

  _proto._onDestroy = function _onDestroy() {
    this._vertexBufferBindings = null;
    this._indexBufferBinding = null;
    this._vertexElements = null;
    this._vertexElementMap = null;

    this._platformPrimitive.destroy();
  };

  _proto._setVertexElements = function _setVertexElements(elements) {
    this._clearVertexElements();

    for (var i = 0, n = elements.length; i < n; i++) {
      this._addVertexElement(elements[i]);
    }
  };

  _proto._setVertexBufferBinding = function _setVertexBufferBinding(index, binding) {
    if (this._getRefCount() > 0) {
      var lastBinding = this._vertexBufferBindings[index];
      lastBinding && lastBinding._buffer._addRefCount(-1);

      binding._buffer._addRefCount(1);
    }

    this._vertexBufferBindings[index] = binding;
  };

  _proto._setIndexBufferBinding = function _setIndexBufferBinding(binding) {
    if (binding) {
      this._indexBufferBinding = binding;
      this._glIndexType = BufferUtil._getGLIndexType(binding.format);
      this._glIndexByteCount = BufferUtil._getGLIndexByteCount(binding.format);
    } else {
      this._indexBufferBinding = null;
      this._glIndexType = undefined;
    }
  };

  _proto._clearVertexElements = function _clearVertexElements() {
    this._vertexElements.length = 0;
    var vertexElementMap = this._vertexElementMap;

    for (var k in vertexElementMap) {
      delete vertexElementMap[k];
    }
  };

  _proto._addVertexElement = function _addVertexElement(element) {
    var semantic = element.semantic;
    this._vertexElementMap[semantic] = element;

    this._vertexElements.push(element);

    this._updateFlagManager.distribute();
  };

  _createClass(Mesh, [{
    key: "subMesh",
    get:
    /** Name. */

    /** The bounding volume of the mesh. */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /**
     * First sub-mesh. Rendered using the first material.
     */
    function get() {
      return this._subMeshes[0] || null;
    }
    /**
     * A collection of sub-mesh, each sub-mesh can be rendered with an independent material.
     */

  }, {
    key: "subMeshes",
    get: function get() {
      return this._subMeshes;
    }
  }]);

  return Mesh;
}(RefObject);

/**
 * Vertex buffer binding.
 */
var VertexBufferBinding = /*#__PURE__*/function () {
  /**
   * Create vertex buffer.
   * @param buffer - Vertex buffer
   * @param stride - Vertex buffer stride
   */
  function VertexBufferBinding(buffer, stride) {
    this._buffer = void 0;
    this._stride = void 0;
    this._buffer = buffer;
    this._stride = stride;
  }

  _createClass(VertexBufferBinding, [{
    key: "buffer",
    get:
    /** @internal */

    /** @internal */

    /**
     * Vertex buffer.
     */
    function get() {
      return this._buffer;
    }
    /**
     * Vertex buffer stride.
     */

  }, {
    key: "stride",
    get: function get() {
      return this._stride;
    }
  }]);

  return VertexBufferBinding;
}();

/**
 * The filter mode of the texture.
 */
var TextureFilterMode;

(function (TextureFilterMode) {
  TextureFilterMode[TextureFilterMode["Point"] = 0] = "Point";
  TextureFilterMode[TextureFilterMode["Bilinear"] = 1] = "Bilinear";
  TextureFilterMode[TextureFilterMode["Trilinear"] = 2] = "Trilinear";
})(TextureFilterMode || (TextureFilterMode = {}));

/**
 * Texture format enumeration.
 */
var TextureFormat;

(function (TextureFormat) {
  TextureFormat[TextureFormat["R8G8B8"] = 0] = "R8G8B8";
  TextureFormat[TextureFormat["R8G8B8A8"] = 1] = "R8G8B8A8";
  TextureFormat[TextureFormat["R4G4B4A4"] = 2] = "R4G4B4A4";
  TextureFormat[TextureFormat["R5G5B5A1"] = 3] = "R5G5B5A1";
  TextureFormat[TextureFormat["R5G6B5"] = 4] = "R5G6B5";
  TextureFormat[TextureFormat["Alpha8"] = 5] = "Alpha8";
  TextureFormat[TextureFormat["LuminanceAlpha"] = 6] = "LuminanceAlpha";
  TextureFormat[TextureFormat["R32G32B32A32"] = 7] = "R32G32B32A32";
  TextureFormat[TextureFormat["DXT1"] = 8] = "DXT1";
  TextureFormat[TextureFormat["DXT5"] = 9] = "DXT5";
  TextureFormat[TextureFormat["ETC1_RGB"] = 10] = "ETC1_RGB";
  TextureFormat[TextureFormat["ETC2_RGB"] = 11] = "ETC2_RGB";
  TextureFormat[TextureFormat["ETC2_RGBA5"] = 12] = "ETC2_RGBA5";
  TextureFormat[TextureFormat["ETC2_RGBA8"] = 13] = "ETC2_RGBA8";
  TextureFormat[TextureFormat["PVRTC_RGB2"] = 14] = "PVRTC_RGB2";
  TextureFormat[TextureFormat["PVRTC_RGBA2"] = 15] = "PVRTC_RGBA2";
  TextureFormat[TextureFormat["PVRTC_RGB4"] = 16] = "PVRTC_RGB4";
  TextureFormat[TextureFormat["PVRTC_RGBA4"] = 17] = "PVRTC_RGBA4";
  TextureFormat[TextureFormat["ASTC_4x4"] = 18] = "ASTC_4x4";
  TextureFormat[TextureFormat["ASTC_5x5"] = 19] = "ASTC_5x5";
  TextureFormat[TextureFormat["ASTC_6x6"] = 20] = "ASTC_6x6";
  TextureFormat[TextureFormat["ASTC_8x8"] = 21] = "ASTC_8x8";
  TextureFormat[TextureFormat["ASTC_10x10"] = 22] = "ASTC_10x10";
  TextureFormat[TextureFormat["ASTC_12x12"] = 23] = "ASTC_12x12";
})(TextureFormat || (TextureFormat = {}));

/**
 * Wrapping mode of the texture.
 */
var TextureWrapMode;

(function (TextureWrapMode) {
  TextureWrapMode[TextureWrapMode["Clamp"] = 0] = "Clamp";
  TextureWrapMode[TextureWrapMode["Repeat"] = 1] = "Repeat";
  TextureWrapMode[TextureWrapMode["Mirror"] = 2] = "Mirror";
})(TextureWrapMode || (TextureWrapMode = {}));

/**
 * Two-dimensional texture.
 */

var Texture2D = /*#__PURE__*/function (_Texture) {
  _inheritsLoose(Texture2D, _Texture);

  /**
   * Create Texture2D.
   * @param engine - Define the engine to use to render this texture
   * @param width - Texture width
   * @param height - Texture height
   * @param format - Texture format. default  `TextureFormat.R8G8B8A8`
   * @param mipmap - Whether to use multi-level texture
   */
  function Texture2D(engine, width, height, format, mipmap) {
    var _this;

    if (format === void 0) {
      format = TextureFormat.R8G8B8A8;
    }

    if (mipmap === void 0) {
      mipmap = true;
    }

    _this = _Texture.call(this, engine) || this;
    _this._format = void 0;
    _this._mipmap = mipmap;
    _this._width = width;
    _this._height = height;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    _this._platformTexture = engine._hardwareRenderer.createPlatformTexture2D(_assertThisInitialized(_this));
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode.Repeat;
    return _this;
  }
  /**
   * Setting pixels data through color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
   * @remarks If it is the WebGL1.0 platform and the texture format is compressed, the first upload must be filled with textures.
   * @param colorBuffer - Color buffer data
   * @param mipLevel - Texture mipmapping level
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Data width. if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
   * @param height - Data height. if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
   */


  var _proto = Texture2D.prototype;

  _proto.setPixelBuffer = function setPixelBuffer(colorBuffer, mipLevel, x, y, width, height) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }

    this._platformTexture.setPixelBuffer(colorBuffer, mipLevel, x, y, width, height);
  }
  /**
   * Setting pixels data through TexImageSource, designated area and texture mipmapping level.
   * @param imageSource - The source of texture
   * @param mipLevel - Texture mipmapping level
   * @param flipY - Whether to flip the Y axis
   * @param premultiplyAlpha - Whether to premultiply the transparent channel
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   */
  ;

  _proto.setImageSource = function setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }

    if (flipY === void 0) {
      flipY = false;
    }

    if (premultiplyAlpha === void 0) {
      premultiplyAlpha = false;
    }

    this._platformTexture.setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
  }
  /**
   * Get the pixel color buffer according to the specified area.
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Area width
   * @param height - Area height
   * @param out - Color buffer
   */
  ;

  _proto.getPixelBuffer = function getPixelBuffer(x, y, width, height, out) {
    this._platformTexture.getPixelBuffer(x, y, width, height, out);
  };

  _createClass(Texture2D, [{
    key: "format",
    get:
    /**
     * Texture format.
     */
    function get() {
      return this._format;
    }
  }]);

  return Texture2D;
}(Texture);

/**
 * The rendering buffer color format enumeration.
 */
var RenderBufferColorFormat;

(function (RenderBufferColorFormat) {
  RenderBufferColorFormat[RenderBufferColorFormat["R8G8B8"] = 0] = "R8G8B8";
  RenderBufferColorFormat[RenderBufferColorFormat["R8G8B8A8"] = 1] = "R8G8B8A8";
  RenderBufferColorFormat[RenderBufferColorFormat["R4G4B4A4"] = 2] = "R4G4B4A4";
  RenderBufferColorFormat[RenderBufferColorFormat["R5G5B5A1"] = 3] = "R5G5B5A1";
  RenderBufferColorFormat[RenderBufferColorFormat["R5G6B5"] = 4] = "R5G6B5";
  RenderBufferColorFormat[RenderBufferColorFormat["Alpha8"] = 5] = "Alpha8";
  RenderBufferColorFormat[RenderBufferColorFormat["R16G16B16A16"] = 6] = "R16G16B16A16";
  RenderBufferColorFormat[RenderBufferColorFormat["R32G32B32A32"] = 7] = "R32G32B32A32";
})(RenderBufferColorFormat || (RenderBufferColorFormat = {}));

/**
 * Render buffer depth format enumeration.
 */
var RenderBufferDepthFormat;

(function (RenderBufferDepthFormat) {
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth"] = 0] = "Depth";
  RenderBufferDepthFormat[RenderBufferDepthFormat["DepthStencil"] = 1] = "DepthStencil";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Stencil"] = 2] = "Stencil";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth16"] = 3] = "Depth16";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth24"] = 4] = "Depth24";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth32"] = 5] = "Depth32";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth24Stencil8"] = 6] = "Depth24Stencil8";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth32Stencil8"] = 7] = "Depth32Stencil8";
})(RenderBufferDepthFormat || (RenderBufferDepthFormat = {}));

/**
 * Define the face of the cube texture.
 */
var TextureCubeFace;

(function (TextureCubeFace) {
  TextureCubeFace[TextureCubeFace["PositiveX"] = 0] = "PositiveX";
  TextureCubeFace[TextureCubeFace["NegativeX"] = 1] = "NegativeX";
  TextureCubeFace[TextureCubeFace["PositiveY"] = 2] = "PositiveY";
  TextureCubeFace[TextureCubeFace["NegativeY"] = 3] = "NegativeY";
  TextureCubeFace[TextureCubeFace["PositiveZ"] = 4] = "PositiveZ";
  TextureCubeFace[TextureCubeFace["NegativeZ"] = 5] = "NegativeZ";
})(TextureCubeFace || (TextureCubeFace = {}));

/**
 * Cube texture.
 */

var TextureCubeMap = /*#__PURE__*/function (_Texture) {
  _inheritsLoose(TextureCubeMap, _Texture);

  /**
   * Create TextureCube.
   * @param engine - Define the engine to use to render this texture
   * @param size - Texture size. texture width must be equal to height in cube texture
   * @param format - Texture format,default TextureFormat.R8G8B8A8
   * @param mipmap - Whether to use multi-level texture
   */
  function TextureCubeMap(engine, size, format, mipmap) {
    var _this;

    if (format === void 0) {
      format = TextureFormat.R8G8B8A8;
    }

    if (mipmap === void 0) {
      mipmap = true;
    }

    _this = _Texture.call(this, engine) || this;
    _this._format = void 0;
    _this._mipmap = mipmap;
    _this._width = size;
    _this._height = size;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    _this._platformTexture = engine._hardwareRenderer.createPlatformTextureCubeMap(_assertThisInitialized(_this));
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode.Clamp;
    return _this;
  }
  /**
   * Setting pixels data through cube face,color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
   * @remarks When compressed texture is in WebGL1, the texture must be filled first before writing the sub-region
   * @param face - Cube face
   * @param colorBuffer - Color buffer data
   * @param mipLevel - Texture mipmapping level
   * @param x - X coordinate of area start
   * @param y -  Y coordinate of area start
   * @param width - Data width.if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
   * @param height - Data height.if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
   */


  var _proto = TextureCubeMap.prototype;

  _proto.setPixelBuffer = function setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }

    this._platformTexture.setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height);
  }
  /**
   * Setting pixels data through cube face, TexImageSource, designated area and texture mipmapping level.
   * @param face - Cube face
   * @param imageSource - The source of texture
   * @param mipLevel - Texture mipmapping level
   * @param flipY - Whether to flip the Y axis
   * @param premultiplyAlpha - Whether to premultiply the transparent channel
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   */
  ;

  _proto.setImageSource = function setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }

    if (flipY === void 0) {
      flipY = false;
    }

    if (premultiplyAlpha === void 0) {
      premultiplyAlpha = false;
    }

    this._platformTexture.setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
  }
  /**
   * Get the pixel color buffer according to the specified cube face and area.
   * @param face - You can choose which cube face to read
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Area width
   * @param height - Area height
   * @param out - Color buffer
   */
  ;

  _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, out) {
    this._platformTexture.getPixelBuffer(face, x, y, width, height, out);
  };

  _createClass(TextureCubeMap, [{
    key: "format",
    get:
    /**
     * Texture format.
     */
    function get() {
      return this._format;
    }
  }]);

  return TextureCubeMap;
}(Texture);

/**
 * The texture is used for the output of depth information in off-screen rendering.
 */

var RenderDepthTexture = /*#__PURE__*/function (_Texture) {
  _inheritsLoose(RenderDepthTexture, _Texture);

  /**
   * Create RenderDepthTexture.
   * @param engine - Define the engine to use to render this depth texture
   * @param width - Texture width
   * @param height - Texture height
   * @param format - Texture format. default RenderBufferDepthFormat.Depth, engine will automatically select the supported precision
   * @param mipmap - Whether to use multi-level texture
   * @param isCube - Whether it's cube texture
   */
  function RenderDepthTexture(engine, width, height, format, mipmap, isCube) {
    var _this;

    if (format === void 0) {
      format = RenderBufferDepthFormat.Depth;
    }

    if (mipmap === void 0) {
      mipmap = false;
    }

    if (isCube === void 0) {
      isCube = false;
    }

    _this = _Texture.call(this, engine) || this;
    _this._autoMipmap = false;
    _this._format = void 0;
    _this._isCube = false;
    _this._isCube = isCube;
    _this._mipmap = mipmap;
    _this._width = width;
    _this._height = height;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    _this._platformTexture = engine._hardwareRenderer.createPlatformRenderDepthTexture(_assertThisInitialized(_this));
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode.Clamp;
    return _this;
  }

  _createClass(RenderDepthTexture, [{
    key: "format",
    get:
    /**
     * Texture format.
     */
    function get() {
      return this._format;
    }
    /**
     * Whether to render to a cube texture.
     */

  }, {
    key: "isCube",
    get: function get() {
      return this._isCube;
    }
    /**
     * Whether to automatically generate multi-level textures.
     */

  }, {
    key: "autoGenerateMipmaps",
    get: function get() {
      return this._autoMipmap;
    },
    set: function set(value) {
      this._autoMipmap = value;
    }
  }]);

  return RenderDepthTexture;
}(Texture);

/**
 * The render target used for off-screen rendering.
 */

var RenderTarget = /*#__PURE__*/function (_EngineObject) {
  _inheritsLoose(RenderTarget, _EngineObject);

  /**
   * @internal
   */
  function RenderTarget(engine, width, height, renderTexture, depth, antiAliasing) {
    var _this;

    if (depth === void 0) {
      depth = RenderBufferDepthFormat.Depth;
    }

    if (antiAliasing === void 0) {
      antiAliasing = 1;
    }

    _this = _EngineObject.call(this, engine) || this;
    _this._platformRenderTarget = void 0;
    _this._colorTextures = void 0;
    _this._depth = void 0;
    _this._antiAliasing = void 0;
    _this._width = void 0;
    _this._height = void 0;
    _this._depthTexture = void 0;
    _this._width = width;
    _this._height = height;
    _this._antiAliasing = antiAliasing;
    _this._depth = depth;

    if (renderTexture) {
      _this._colorTextures = renderTexture instanceof Array ? renderTexture.slice() : [renderTexture];
    } else {
      _this._colorTextures = [];
    }

    if (depth instanceof RenderDepthTexture) {
      _this._depthTexture = depth;
    }

    _this._platformRenderTarget = engine._hardwareRenderer.createPlatformRenderTarget(_assertThisInitialized(_this));
    return _this;
  }
  /**
   *
   * Get the render color texture by index.
   * @param index
   */


  var _proto = RenderTarget.prototype;

  _proto.getColorTexture = function getColorTexture(index) {
    if (index === void 0) {
      index = 0;
    }

    return this._colorTextures[index];
  }
  /**
   * Generate the mipmap of each attachment texture of the renderTarget according to the configuration.
   */
  ;

  _proto.generateMipmaps = function generateMipmaps() {
    var _this$_depthTexture;

    var colorTextureCount = this.colorTextureCount;

    if ((_this$_depthTexture = this._depthTexture) !== null && _this$_depthTexture !== void 0 && _this$_depthTexture.autoGenerateMipmaps) {
      this._depthTexture.generateMipmaps();
    }

    for (var i = 0; i < colorTextureCount; i++) {
      var _colorTexture = this._colorTextures[i];

      if (_colorTexture.autoGenerateMipmaps) {
        _colorTexture.generateMipmaps();
      }
    }
  }
  /**
   * Destroy render target.
   */
  ;

  _proto.destroy = function destroy() {
    this._platformRenderTarget.destroy();

    this._colorTextures.length = 0;
    this._depthTexture = null;
    this._depth = null;
  }
  /**
   * @internal
   */
  ;

  _proto._setRenderTargetFace = function _setRenderTargetFace(faceIndex) {
    this._platformRenderTarget.setRenderTargetFace(faceIndex);
  }
  /**
   * @internal
   */
  ;

  _proto._blitRenderTarget = function _blitRenderTarget() {
    this._platformRenderTarget.blitRenderTarget();
  };

  _createClass(RenderTarget, [{
    key: "width",
    get:
    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /**
     * Render target width.
     */
    function get() {
      return this._width;
    }
    /**
     * Render target height.
     */

  }, {
    key: "height",
    get: function get() {
      return this._height;
    }
    /**
     * Render color texture count.
     */

  }, {
    key: "colorTextureCount",
    get: function get() {
      return this._colorTextures.length;
    }
    /**
     * Depth texture.
     */

  }, {
    key: "depthTexture",
    get: function get() {
      return this._depthTexture;
    }
    /**
     * Anti-aliasing level.
     * @remarks If the anti-aliasing level set is greater than the maximum level supported by the hardware, the maximum level of the hardware will be used.
     */

  }, {
    key: "antiAliasing",
    get: function get() {
      return this._antiAliasing;
    }
    /**
     * Create a render target through color texture and depth format.
     * @param engine - Define the engine to use for this off-screen rendering
     * @param width - Render target width
     * @param height - Render target height
     * @param colorTexture - Render color texture
     * @param depthFormat - Depth format. default RenderBufferDepthFormat.Depth, engine will automatically select the supported precision
     * @param antiAliasing - Anti-aliasing level, default is 1
     */

  }]);

  return RenderTarget;
}(EngineObject);

/**
 * The texture is used for the output of color information in off-screen rendering.
 */

var RenderColorTexture = /*#__PURE__*/function (_Texture) {
  _inheritsLoose(RenderColorTexture, _Texture);

  /**
   * Create RenderColorTexture.
   * @param engine - Define the engine to use to render this color texture
   * @param width - Texture width
   * @param height - Texture height
   * @param format - Texture format. default RenderBufferColorFormat.R8G8B8A8
   * @param mipmap - Whether to use multi-level texture
   * @param isCube - Whether it's cube texture
   */
  function RenderColorTexture(engine, width, height, format, mipmap, isCube) {
    var _this;

    if (format === void 0) {
      format = RenderBufferColorFormat.R8G8B8A8;
    }

    if (mipmap === void 0) {
      mipmap = false;
    }

    if (isCube === void 0) {
      isCube = false;
    }

    _this = _Texture.call(this, engine) || this;
    _this._autoMipmap = false;
    _this._format = void 0;
    _this._isCube = false;
    _this._isCube = isCube;
    _this._mipmap = mipmap;
    _this._width = width;
    _this._height = height;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    _this._platformTexture = engine._hardwareRenderer.createPlatformRenderColorTexture(_assertThisInitialized(_this));
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode.Clamp;
    return _this;
  }
  /**
   * Get the pixel color buffer according to the specified cube face and area.
   * @param face - You can choose which cube face to read if it's cube texture
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Area width
   * @param height - Area height
   * @param out - Color buffer
   */


  var _proto = RenderColorTexture.prototype;

  _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, out) {
    this._platformTexture.getPixelBuffer(face, x, y, width, height, out);
  };

  _createClass(RenderColorTexture, [{
    key: "format",
    get:
    /**
     * Texture format.
     */
    function get() {
      return this._format;
    }
    /**
     * Whether to render to a cube texture.
     */

  }, {
    key: "isCube",
    get: function get() {
      return this._isCube;
    }
    /**
     * Whether to automatically generate multi-level textures.
     */

  }, {
    key: "autoGenerateMipmaps",
    get: function get() {
      return this._autoMipmap;
    },
    set: function set(value) {
      this._autoMipmap = value;
    }
  }]);

  return RenderColorTexture;
}(Texture);

/**
 * Mesh containing common vertex elements of the model.
 */

var ModelMesh = /*#__PURE__*/function (_Mesh) {
  _inheritsLoose(ModelMesh, _Mesh);

  /**
   * Create a model mesh.
   * @param engine - Engine to which the mesh belongs
   * @param name - Mesh name
   */
  function ModelMesh(engine, name) {
    var _this;

    _this = _Mesh.call(this, engine) || this;
    _this._hasBlendShape = false;
    _this._useBlendShapeNormal = false;
    _this._useBlendShapeTangent = false;
    _this._blendShapeTexture = void 0;
    _this._vertexCount = 0;
    _this._accessible = true;
    _this._verticesFloat32 = null;
    _this._verticesUint8 = null;
    _this._indices = null;
    _this._indicesFormat = null;
    _this._vertexSlotChanged = true;
    _this._vertexChangeFlag = 0;
    _this._indicesChangeFlag = false;
    _this._elementCount = 0;
    _this._vertexElementsCache = [];
    _this._positions = [];
    _this._normals = null;
    _this._colors = null;
    _this._tangents = null;
    _this._uv = null;
    _this._uv1 = null;
    _this._uv2 = null;
    _this._uv3 = null;
    _this._uv4 = null;
    _this._uv5 = null;
    _this._uv6 = null;
    _this._uv7 = null;
    _this._boneWeights = null;
    _this._boneIndices = null;
    _this._blendShapes = [];
    _this._blendShapeUpdateFlags = [];
    _this.name = name;
    return _this;
  }
  /**
   * Set positions for the mesh.
   * @param positions - The positions for the mesh.
   */


  var _proto = ModelMesh.prototype;

  _proto.setPositions = function setPositions(positions) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    var count = positions.length;
    this._positions = positions;
    this._vertexChangeFlag |= ValueChanged.Position;

    if (this._vertexCount !== count) {
      this._vertexCount = count;
    }
  }
  /**
   * Get positions for the mesh.
   * @remarks Please call the setPositions() method after modification to ensure that the modification takes effect.
   */
  ;

  _proto.getPositions = function getPositions() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    return this._positions;
  }
  /**
   * Set per-vertex normals for the mesh.
   * @param normals - The normals for the mesh.
   */
  ;

  _proto.setNormals = function setNormals(normals) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    if (normals.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }

    this._vertexSlotChanged = !!this._normals !== !!normals;
    this._vertexChangeFlag |= ValueChanged.Normal;
    this._normals = normals;
  }
  /**
   * Get normals for the mesh.
   * @remarks Please call the setNormals() method after modification to ensure that the modification takes effect.
   */
  ;

  _proto.getNormals = function getNormals() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    return this._normals;
  }
  /**
   * Set per-vertex colors for the mesh.
   * @param colors - The colors for the mesh.
   */
  ;

  _proto.setColors = function setColors(colors) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    if (colors.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }

    this._vertexSlotChanged = !!this._colors !== !!colors;
    this._vertexChangeFlag |= ValueChanged.Color;
    this._colors = colors;
  }
  /**
   * Get colors for the mesh.
   * @remarks Please call the setColors() method after modification to ensure that the modification takes effect.
   */
  ;

  _proto.getColors = function getColors() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    return this._colors;
  }
  /**
   * Set per-vertex bone weights for the mesh.
   * @param boneWeights - The bone weights for the mesh.
   */
  ;

  _proto.setBoneWeights = function setBoneWeights(boneWeights) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    if (boneWeights.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }

    this._vertexSlotChanged = boneWeights != null;
    this._vertexChangeFlag |= ValueChanged.BoneWeight;
    this._boneWeights = boneWeights;
  }
  /**
   * Get weights for the mesh.
   * @remarks Please call the setWeights() method after modification to ensure that the modification takes effect.
   */
  ;

  _proto.getBoneWeights = function getBoneWeights() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    return this._boneWeights;
  }
  /**
   * Set per-vertex bone indices for the mesh.
   * @param boneIndices - The bone indices for the mesh.
   */
  ;

  _proto.setBoneIndices = function setBoneIndices(boneIndices) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    if (boneIndices.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }

    this._vertexSlotChanged = !!this._boneIndices !== !!boneIndices;
    this._vertexChangeFlag |= ValueChanged.BoneIndex;
    this._boneIndices = boneIndices;
  }
  /**
   * Get joints for the mesh.
   * @remarks Please call the setBoneIndices() method after modification to ensure that the modification takes effect.
   */
  ;

  _proto.getBoneIndices = function getBoneIndices() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    return this._boneIndices;
  }
  /**
   * Set per-vertex tangents for the mesh.
   * @param tangents - The tangents for the mesh.
   */
  ;

  _proto.setTangents = function setTangents(tangents) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    if (tangents.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }

    this._vertexSlotChanged = !!this._tangents !== !!tangents;
    this._vertexChangeFlag |= ValueChanged.Tangent;
    this._tangents = tangents;
  }
  /**
   * Get tangents for the mesh.
   * @remarks Please call the setTangents() method after modification to ensure that the modification takes effect.
   */
  ;

  _proto.getTangents = function getTangents() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    return this._tangents;
  }
  /**
   * Set per-vertex uv for the mesh.
   * @param uv - The uv for the mesh.
   */
  ;

  _proto.setUVs = function setUVs(uv, channelIndex) {
    var _channelIndex;

    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    if (uv.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }

    channelIndex = (_channelIndex = channelIndex) != null ? _channelIndex : 0;

    switch (channelIndex) {
      case 0:
        this._vertexSlotChanged = !!this._uv !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV;
        this._uv = uv;
        break;

      case 1:
        this._vertexSlotChanged = !!this._uv1 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV1;
        this._uv1 = uv;
        break;

      case 2:
        this._vertexSlotChanged = !!this._uv2 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV2;
        this._uv2 = uv;
        break;

      case 3:
        this._vertexSlotChanged = !!this._uv3 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV3;
        this._uv3 = uv;
        break;

      case 4:
        this._vertexSlotChanged = !!this._uv4 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV4;
        this._uv4 = uv;
        break;

      case 5:
        this._vertexSlotChanged = !!this._uv5 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV5;
        this._uv5 = uv;
        break;

      case 6:
        this._vertexSlotChanged = !!this._uv6 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV6;
        this._uv6 = uv;
        break;

      case 7:
        this._vertexSlotChanged = !!this._uv7 !== !!uv;
        this._vertexChangeFlag |= ValueChanged.UV7;
        this._uv7 = uv;
        break;

      default:
        throw "The index of channel needs to be in range [0 - 7].";
    }
  }
  /**
   * Get uv for the mesh.
   * @remarks Please call the setUV() method after modification to ensure that the modification takes effect.
   */
  ;

  _proto.getUVs = function getUVs(channelIndex) {
    var _channelIndex2;

    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    channelIndex = (_channelIndex2 = channelIndex) != null ? _channelIndex2 : 0;

    switch (channelIndex) {
      case 0:
        return this._uv;

      case 1:
        return this._uv1;

      case 2:
        return this._uv2;

      case 3:
        return this._uv3;

      case 4:
        return this._uv4;

      case 5:
        return this._uv5;

      case 6:
        return this._uv6;

      case 7:
        return this._uv7;
    }

    throw "The index of channel needs to be in range [0 - 7].";
  }
  /**
   * Set indices for the mesh.
   * @param indices - The indices for the mesh.
   */
  ;

  _proto.setIndices = function setIndices(indices) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    if (this._indices !== indices) {
      this._indices = indices;

      if (indices instanceof Uint8Array) {
        this._indicesFormat = IndexFormat.UInt8;
      } else if (indices instanceof Uint16Array) {
        this._indicesFormat = IndexFormat.UInt16;
      } else if (indices instanceof Uint32Array) {
        this._indicesFormat = IndexFormat.UInt32;
      }
    }

    this._indicesChangeFlag = true;
  }
  /**
   * Get indices for the mesh.
   */
  ;

  _proto.getIndices = function getIndices() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    return this._indices;
  }
  /**
   * Add a BlendShape for this ModelMesh.
   * @param blendShape - The BlendShape
   */
  ;

  _proto.addBlendShape = function addBlendShape(blendShape) {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    this._vertexChangeFlag |= ValueChanged.BlendShape;
    this._useBlendShapeNormal = this._useBlendShapeNormal || blendShape._useBlendShapeNormal;
    this._useBlendShapeTangent = this._useBlendShapeTangent || blendShape._useBlendShapeTangent;

    this._blendShapes.push(blendShape);

    this._blendShapeUpdateFlags.push(blendShape._registerChangeFlag());

    this._hasBlendShape = true;
  }
  /**
   * Clear all BlendShapes.
   */
  ;

  _proto.clearBlendShapes = function clearBlendShapes() {
    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    this._vertexChangeFlag |= ValueChanged.BlendShape;
    this._useBlendShapeNormal = false;
    this._useBlendShapeTangent = false;
    this._blendShapes.length = 0;
    var blendShapeUpdateFlags = this._blendShapeUpdateFlags;

    for (var i = 0, n = blendShapeUpdateFlags.length; i < n; i++) {
      blendShapeUpdateFlags[i].destroy();
    }

    blendShapeUpdateFlags.length = 0;
    this._hasBlendShape = false;
  }
  /**
   * Upload Mesh Data to the graphics API.
   * @param noLongerAccessible - Whether to access data later. If true, you'll never access data anymore (free memory cache)
   */
  ;

  _proto.uploadData = function uploadData(noLongerAccessible) {
    var _vertexBufferBindings, _this$_indexBufferBin;

    if (!this._accessible) {
      throw "Not allowed to access data while accessible is false.";
    }

    var _indices = this._indices; // Vertex element change.

    if (this._vertexSlotChanged) {
      var vertexElements = this._updateVertexElements();

      this._setVertexElements(vertexElements);

      this._vertexChangeFlag = ValueChanged.All;
      this._vertexSlotChanged = false;
    } // Vertex value change.


    var vertexBufferBindings = this._vertexBufferBindings;
    var elementCount = this._elementCount;
    var vertexBuffer = (_vertexBufferBindings = vertexBufferBindings[0]) === null || _vertexBufferBindings === void 0 ? void 0 : _vertexBufferBindings._buffer;
    var vertexFloatCount = elementCount * this._vertexCount;

    if (!vertexBuffer || this._verticesFloat32.length !== vertexFloatCount) {
      vertexBuffer === null || vertexBuffer === void 0 ? void 0 : vertexBuffer.destroy();
      var vertices = new Float32Array(vertexFloatCount);
      this._verticesFloat32 = vertices;
      this._verticesUint8 = new Uint8Array(vertices.buffer);
      this._vertexChangeFlag = ValueChanged.All;

      this._updateVertices(vertices);

      var newVertexBuffer = new Buffer(this._engine, BufferBindFlag.VertexBuffer, vertices, noLongerAccessible ? BufferUsage.Static : BufferUsage.Dynamic);

      this._setVertexBufferBinding(0, new VertexBufferBinding(newVertexBuffer, elementCount * 4));
    } else if (this._vertexChangeFlag & ValueChanged.All) {
      var _vertices = this._verticesFloat32;

      this._updateVertices(_vertices);

      vertexBuffer.setData(_vertices);
    }

    var indexBuffer = (_this$_indexBufferBin = this._indexBufferBinding) === null || _this$_indexBufferBin === void 0 ? void 0 : _this$_indexBufferBin._buffer;

    if (_indices) {
      if (!indexBuffer || _indices.byteLength != indexBuffer.byteLength) {
        indexBuffer === null || indexBuffer === void 0 ? void 0 : indexBuffer.destroy();
        var newIndexBuffer = new Buffer(this._engine, BufferBindFlag.IndexBuffer, _indices);

        this._setIndexBufferBinding(new IndexBufferBinding(newIndexBuffer, this._indicesFormat));
      } else if (this._indicesChangeFlag) {
        this._indicesChangeFlag = false;
        indexBuffer.setData(_indices);

        if (this._indexBufferBinding._format !== this._indicesFormat) {
          this._setIndexBufferBinding(new IndexBufferBinding(indexBuffer, this._indicesFormat));
        }
      }
    } else if (indexBuffer) {
      indexBuffer.destroy();

      this._setIndexBufferBinding(null);
    }

    if (noLongerAccessible) {
      this._accessible = false;

      this._releaseCache();
    }
  }
  /**
   * @override
   * @internal
   */
  ;

  _proto._onDestroy = function _onDestroy() {
    _Mesh.prototype._onDestroy.call(this);

    this._accessible && this._releaseCache();
  };

  _proto._updateVertexElements = function _updateVertexElements() {
    var vertexElements = this._vertexElementsCache;
    vertexElements.length = 1;
    vertexElements[0] = POSITION_VERTEX_ELEMENT;
    var offset = 12;
    var elementCount = 3;

    if (this._normals) {
      vertexElements.push(new VertexElement("NORMAL", offset, VertexElementFormat.Vector3, 0));
      offset += 12;
      elementCount += 3;
    }

    if (this._colors) {
      vertexElements.push(new VertexElement("COLOR_0", offset, VertexElementFormat.Vector4, 0));
      offset += 16;
      elementCount += 4;
    }

    if (this._boneWeights) {
      vertexElements.push(new VertexElement("WEIGHTS_0", offset, VertexElementFormat.Vector4, 0));
      offset += 16;
      elementCount += 4;
    }

    if (this._boneIndices) {
      vertexElements.push(new VertexElement("JOINTS_0", offset, VertexElementFormat.UByte4, 0));
      offset += 4;
      elementCount += 1;
    }

    if (this._tangents) {
      vertexElements.push(new VertexElement("TANGENT", offset, VertexElementFormat.Vector4, 0));
      offset += 16;
      elementCount += 4;
    }

    if (this._uv) {
      vertexElements.push(new VertexElement("TEXCOORD_0", offset, VertexElementFormat.Vector2, 0));
      offset += 8;
      elementCount += 2;
    }

    if (this._uv1) {
      vertexElements.push(new VertexElement("TEXCOORD_1", offset, VertexElementFormat.Vector2, 0));
      offset += 8;
      elementCount += 2;
    }

    if (this._uv2) {
      vertexElements.push(new VertexElement("TEXCOORD_2", offset, VertexElementFormat.Vector2, 0));
      offset += 8;
      elementCount += 2;
    }

    if (this._uv3) {
      vertexElements.push(new VertexElement("TEXCOORD_3", offset, VertexElementFormat.Vector2, 0));
      offset += 8;
      elementCount += 2;
    }

    if (this._uv4) {
      vertexElements.push(new VertexElement("TEXCOORD_4", offset, VertexElementFormat.Vector2, 0));
      offset += 8;
      elementCount += 2;
    }

    if (this._uv5) {
      vertexElements.push(new VertexElement("TEXCOORD_5", offset, VertexElementFormat.Vector2, 0));
      offset += 8;
      elementCount += 2;
    }

    if (this._uv6) {
      vertexElements.push(new VertexElement("TEXCOORD_6", offset, VertexElementFormat.Vector2, 0));
      offset += 8;
      elementCount += 2;
    }

    if (this._uv7) {
      vertexElements.push(new VertexElement("TEXCOORD_7", offset, VertexElementFormat.Vector2, 0));
      offset += 8;
      elementCount += 2;
    }

    var blendShapeCount = Math.min(this._blendShapes.length, 4);

    for (var i = 0, n = blendShapeCount; i < n; i++) {
      vertexElements.push(new VertexElement("POSITION_BS" + i, offset, VertexElementFormat.Vector3, 0));
      offset += 12;
      elementCount += 3;

      if (this._useBlendShapeNormal) {
        vertexElements.push(new VertexElement("NORMAL_BS" + i, offset, VertexElementFormat.Vector3, 0));
        offset += 12;
        elementCount += 3;
      }

      if (this._useBlendShapeTangent) {
        vertexElements.push(new VertexElement("TANGENT_BS" + i, offset, VertexElementFormat.Vector3, 0));
        offset += 12;
        elementCount += 3;
      }
    }

    this._elementCount = elementCount;
    return vertexElements;
  };

  _proto._updateVertices = function _updateVertices(vertices) {
    // prettier-ignore
    var _elementCount = this._elementCount,
        _vertexCount = this._vertexCount,
        _positions = this._positions,
        _normals = this._normals,
        _colors = this._colors,
        _vertexChangeFlag = this._vertexChangeFlag,
        _boneWeights = this._boneWeights,
        _boneIndices = this._boneIndices,
        _tangents = this._tangents,
        _uv = this._uv,
        _uv1 = this._uv1,
        _uv2 = this._uv2,
        _uv3 = this._uv3,
        _uv4 = this._uv4,
        _uv5 = this._uv5,
        _uv6 = this._uv6,
        _uv7 = this._uv7;

    if (_vertexChangeFlag & ValueChanged.Position) {
      for (var i = 0; i < _vertexCount; i++) {
        var start = _elementCount * i;
        var position = _positions[i];
        vertices[start] = position.x;
        vertices[start + 1] = position.y;
        vertices[start + 2] = position.z;
      }
    }

    var offset = 3;

    if (_normals) {
      if (_vertexChangeFlag & ValueChanged.Normal) {
        for (var _i = 0; _i < _vertexCount; _i++) {
          var _start = _elementCount * _i + offset;

          var normal = _normals[_i];

          if (normal) {
            vertices[_start] = normal.x;
            vertices[_start + 1] = normal.y;
            vertices[_start + 2] = normal.z;
          }
        }
      }

      offset += 3;
    }

    if (_colors) {
      if (_vertexChangeFlag & ValueChanged.Color) {
        for (var _i2 = 0; _i2 < _vertexCount; _i2++) {
          var _start2 = _elementCount * _i2 + offset;

          var color = _colors[_i2];

          if (color) {
            vertices[_start2] = color.r;
            vertices[_start2 + 1] = color.g;
            vertices[_start2 + 2] = color.b;
            vertices[_start2 + 3] = color.a;
          }
        }
      }

      offset += 4;
    }

    if (_boneWeights) {
      if (_vertexChangeFlag & ValueChanged.BoneWeight) {
        for (var _i3 = 0; _i3 < _vertexCount; _i3++) {
          var _start3 = _elementCount * _i3 + offset;

          var weight = _boneWeights[_i3];

          if (weight) {
            vertices[_start3] = weight.x;
            vertices[_start3 + 1] = weight.y;
            vertices[_start3 + 2] = weight.z;
            vertices[_start3 + 3] = weight.w;
          }
        }
      }

      offset += 4;
    }

    if (_boneIndices) {
      if (_vertexChangeFlag & ValueChanged.BoneIndex) {
        var _verticesUint8 = this._verticesUint8;

        for (var _i4 = 0; _i4 < _vertexCount; _i4++) {
          var _start4 = _elementCount * _i4 + offset;

          var joint = _boneIndices[_i4];

          if (joint) {
            var internalStart = _start4 * 4;
            _verticesUint8[internalStart] = joint.x;
            _verticesUint8[internalStart + 1] = joint.y;
            _verticesUint8[internalStart + 2] = joint.z;
            _verticesUint8[internalStart + 3] = joint.w;
          }
        }
      }

      offset += 1;
    }

    if (_tangents) {
      if (_vertexChangeFlag & ValueChanged.Tangent) {
        for (var _i5 = 0; _i5 < _vertexCount; _i5++) {
          var _start5 = _elementCount * _i5 + offset;

          var tangent = _tangents[_i5];

          if (tangent) {
            vertices[_start5] = tangent.x;
            vertices[_start5 + 1] = tangent.y;
            vertices[_start5 + 2] = tangent.z;
          }
        }
      }

      offset += 4;
    }

    if (_uv) {
      if (_vertexChangeFlag & ValueChanged.UV) {
        for (var _i6 = 0; _i6 < _vertexCount; _i6++) {
          var _start6 = _elementCount * _i6 + offset;

          var _uv8 = _uv[_i6];

          if (_uv8) {
            vertices[_start6] = _uv8.x;
            vertices[_start6 + 1] = _uv8.y;
          }
        }
      }

      offset += 2;
    }

    if (_uv1) {
      if (_vertexChangeFlag & ValueChanged.UV1) {
        for (var _i7 = 0; _i7 < _vertexCount; _i7++) {
          var _start7 = _elementCount * _i7 + offset;

          var _uv9 = _uv1[_i7];

          if (_uv9) {
            vertices[_start7] = _uv9.x;
            vertices[_start7 + 1] = _uv9.y;
          }
        }
      }

      offset += 2;
    }

    if (_uv2) {
      if (_vertexChangeFlag & ValueChanged.UV2) {
        for (var _i8 = 0; _i8 < _vertexCount; _i8++) {
          var _start8 = _elementCount * _i8 + offset;

          var _uv10 = _uv2[_i8];

          if (_uv10) {
            vertices[_start8] = _uv10.x;
            vertices[_start8 + 1] = _uv10.y;
          }
        }
      }

      offset += 2;
    }

    if (_uv3) {
      if (_vertexChangeFlag & ValueChanged.UV3) {
        for (var _i9 = 0; _i9 < _vertexCount; _i9++) {
          var _start9 = _elementCount * _i9 + offset;

          var _uv11 = _uv3[_i9];

          if (_uv11) {
            vertices[_start9] = _uv11.x;
            vertices[_start9 + 1] = _uv11.y;
          }
        }
      }

      offset += 2;
    }

    if (_uv4) {
      if (_vertexChangeFlag & ValueChanged.UV4) {
        for (var _i10 = 0; _i10 < _vertexCount; _i10++) {
          var _start10 = _elementCount * _i10 + offset;

          var _uv12 = _uv4[_i10];

          if (_uv12) {
            vertices[_start10] = _uv12.x;
            vertices[_start10 + 1] = _uv12.y;
          }
        }
      }

      offset += 2;
    }

    if (_uv5) {
      if (_vertexChangeFlag & ValueChanged.UV5) {
        for (var _i11 = 0; _i11 < _vertexCount; _i11++) {
          var _start11 = _elementCount * _i11 + offset;

          var _uv13 = _uv5[_i11];

          if (_uv13) {
            vertices[_start11] = _uv13.x;
            vertices[_start11 + 1] = _uv13.y;
          }
        }
      }

      offset += 2;
    }

    if (_uv6) {
      if (_vertexChangeFlag & ValueChanged.UV6) {
        for (var _i12 = 0; _i12 < _vertexCount; _i12++) {
          var _start12 = _elementCount * _i12 + offset;

          var _uv14 = _uv6[_i12];

          if (_uv14) {
            vertices[_start12] = _uv14.x;
            vertices[_start12 + 1] = _uv14.y;
          }
        }
      }

      offset += 2;
    }

    if (_uv7) {
      if (_vertexChangeFlag & ValueChanged.UV7) {
        for (var _i13 = 0; _i13 < _vertexCount; _i13++) {
          var _start13 = _elementCount * _i13 + offset;

          var _uv15 = _uv7[_i13];

          if (_uv15) {
            vertices[_start13] = _uv15.x;
            vertices[_start13 + 1] = _uv15.y;
          }
        }
      }

      offset += 2;
    } // BlendShape.


    if (_vertexChangeFlag & ValueChanged.BlendShape) {
      var blendShapes = this._blendShapes;
      var blendShapeUpdateFlags = this._blendShapeUpdateFlags;
      var blendShapeCount = Math.min(blendShapes.length, 4);
      this.engine._hardwareRenderer;

      {
        for (var _i14 = 0; _i14 < blendShapeCount; _i14++) {
          var blendShapeUpdateFlag = blendShapeUpdateFlags[_i14];

          if (blendShapeUpdateFlag.flag) {
            var blendShape = blendShapes[_i14];
            var frames = blendShape.frames;
            var frameCount = frames.length;
            var endFrame = frames[frameCount - 1];

            if (frameCount > 0 && endFrame.deltaPositions.length !== this._vertexCount) {
              throw "BlendShape frame deltaPositions length must same with mesh vertexCount.";
            }

            var deltaPositions = endFrame.deltaPositions;

            for (var j = 0; j < _vertexCount; j++) {
              var _start14 = _elementCount * j + offset;

              var deltaPosition = deltaPositions[j];

              if (deltaPosition) {
                vertices[_start14] = deltaPosition.x;
                vertices[_start14 + 1] = deltaPosition.y;
                vertices[_start14 + 2] = deltaPosition.z;
              }
            }

            offset += 3;

            if (this._useBlendShapeNormal) {
              var deltaNormals = endFrame.deltaNormals;

              if (deltaNormals) {
                for (var _j = 0; _j < _vertexCount; _j++) {
                  var _start15 = _elementCount * _j + offset;

                  var deltaNormal = deltaNormals[_j];

                  if (deltaNormal) {
                    vertices[_start15] = deltaNormal.x;
                    vertices[_start15 + 1] = deltaNormal.y;
                    vertices[_start15 + 2] = deltaNormal.z;
                  }
                }
              }

              offset += 3;
            }

            if (this._useBlendShapeTangent) {
              var deltaTangents = endFrame.deltaTangents;

              if (deltaTangents) {
                for (var _j2 = 0; _j2 < _vertexCount; _j2++) {
                  var _start16 = _elementCount * _j2 + offset;

                  var deltaTangent = deltaTangents[_j2];

                  if (deltaTangent) {
                    vertices[_start16] = deltaTangent.x;
                    vertices[_start16 + 1] = deltaTangent.y;
                    vertices[_start16 + 2] = deltaTangent.z;
                  }
                }
              }

              offset += 3;
            }

            blendShapeUpdateFlag.flag = false;
          }
        }
      }
    }

    this._vertexChangeFlag = 0;
  };

  _proto._releaseCache = function _releaseCache() {
    var blendShapeUpdateFlags = this._blendShapeUpdateFlags;

    for (var i = 0, n = blendShapeUpdateFlags.length; i < n; i++) {
      blendShapeUpdateFlags[i].destroy();
    }

    this._verticesUint8 = null;
    this._indices = null;
    this._verticesFloat32 = null;
    this._positions.length = 0;
    this._tangents = null;
    this._normals = null;
    this._colors = null;
    this._uv = null;
    this._uv1 = null;
    this._uv2 = null;
    this._uv3 = null;
    this._uv4 = null;
    this._uv5 = null;
    this._uv6 = null;
    this._uv7 = null;
    this._blendShapes = null;
    this._blendShapeUpdateFlags = null;
  };

  _createClass(ModelMesh, [{
    key: "accessible",
    get:
    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /**
     * Whether to access data of the mesh.
     */
    function get() {
      return this._accessible;
    }
    /**
     * Vertex count of current mesh.
     */

  }, {
    key: "vertexCount",
    get: function get() {
      return this._vertexCount;
    }
    /**
     * BlendShape count of this ModelMesh.
     */

  }, {
    key: "blendShapes",
    get: function get() {
      if (!this._accessible) {
        throw "Not allowed to access data while accessible is false.";
      }

      return this._blendShapes;
    }
  }]);

  return ModelMesh;
}(Mesh);
var POSITION_VERTEX_ELEMENT = new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0);
var ValueChanged;

(function (ValueChanged) {
  ValueChanged[ValueChanged["Position"] = 1] = "Position";
  ValueChanged[ValueChanged["Normal"] = 2] = "Normal";
  ValueChanged[ValueChanged["Color"] = 4] = "Color";
  ValueChanged[ValueChanged["Tangent"] = 8] = "Tangent";
  ValueChanged[ValueChanged["BoneWeight"] = 16] = "BoneWeight";
  ValueChanged[ValueChanged["BoneIndex"] = 32] = "BoneIndex";
  ValueChanged[ValueChanged["UV"] = 64] = "UV";
  ValueChanged[ValueChanged["UV1"] = 128] = "UV1";
  ValueChanged[ValueChanged["UV2"] = 256] = "UV2";
  ValueChanged[ValueChanged["UV3"] = 512] = "UV3";
  ValueChanged[ValueChanged["UV4"] = 1024] = "UV4";
  ValueChanged[ValueChanged["UV5"] = 2048] = "UV5";
  ValueChanged[ValueChanged["UV6"] = 4096] = "UV6";
  ValueChanged[ValueChanged["UV7"] = 8192] = "UV7";
  ValueChanged[ValueChanged["BlendShape"] = 16384] = "BlendShape";
  ValueChanged[ValueChanged["All"] = 65535] = "All";
})(ValueChanged || (ValueChanged = {}));

/**
 * Mesh skin data, equal glTF skins define
 */
var Skin = /*#__PURE__*/function (_EngineObject) {
  _inheritsLoose(Skin, _EngineObject);

  /**
   * Constructor of skin
   * @param name - name
   */
  function Skin(name) {
    var _this;

    _this = _EngineObject.call(this, null) || this;
    _this.name = name;
    _this.inverseBindMatrices = void 0;
    _this.joints = void 0;
    _this.skeleton = void 0;
    _this.inverseBindMatrices = []; // inverse bind matrix array

    _this.joints = []; // joints name array, element type: string

    _this.skeleton = "none"; // root bone name

    return _this;
  }

  return Skin;
}(EngineObject);

var _class$5, _descriptor$5, _descriptor2$5, _class2$4, _temp$4;

/**
 * MeshRenderer Component.
 */
var MeshRenderer = (_class$5 = (_temp$4 = _class2$4 = /*#__PURE__*/function (_Renderer) {
  _inheritsLoose(MeshRenderer, _Renderer);

  /**
   * @internal
   */
  function MeshRenderer(entity) {
    var _this;

    _this = _Renderer.call(this, entity) || this;

    _initializerDefineProperty(_this, "_mesh", _descriptor$5, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_meshUpdateFlag", _descriptor2$5, _assertThisInitialized(_this));

    return _this;
  }
  /**
   * Mesh assigned to the renderer.
   */


  var _proto = MeshRenderer.prototype;

  /**
   * @internal
   */
  _proto._render = function _render(camera) {
    var mesh = this._mesh;

    if (mesh) {
      if (this._meshUpdateFlag.flag) {
        var shaderData = this.shaderData;
        var vertexElements = mesh._vertexElements;
        shaderData.disableMacro(MeshRenderer._uvMacro);
        shaderData.disableMacro(MeshRenderer._normalMacro);
        shaderData.disableMacro(MeshRenderer._tangentMacro);
        shaderData.disableMacro(MeshRenderer._vertexColorMacro);

        for (var i = 0, n = vertexElements.length; i < n; i++) {
          var semantic = vertexElements[i].semantic;

          switch (semantic) {
            case "TEXCOORD_0":
              shaderData.enableMacro(MeshRenderer._uvMacro);
              break;

            case "NORMAL":
              shaderData.enableMacro(MeshRenderer._normalMacro);
              break;

            case "TANGENT":
              shaderData.enableMacro(MeshRenderer._tangentMacro);
              break;

            case "COLOR_0":
              shaderData.enableMacro(MeshRenderer._vertexColorMacro);
              break;
          }
        }

        this._meshUpdateFlag.flag = false;
      }

      var subMeshes = mesh.subMeshes;
      var renderPipeline = camera._renderPipeline;
      var renderElementPool = this._engine._renderElementPool;

      for (var _i = 0, _n = subMeshes.length; _i < _n; _i++) {
        var material = this._materials[_i];

        if (material) {
          var element = renderElementPool.getFromPool();
          element.setValue(this, mesh, subMeshes[_i], material);
          renderPipeline.pushPrimitive(element);
        }
      }
    } else {
      Logger.error("mesh is null.");
    }
  }
  /**
   * @internal
   * @override
   */
  ;

  _proto._onDestroy = function _onDestroy() {
    _Renderer.prototype._onDestroy.call(this);

    var mesh = this._mesh;

    if (mesh && !mesh.destroyed) {
      mesh._addRefCount(-1);

      this._mesh = null;
    }
  }
  /**
   * @internal
   */
  ;

  _proto._cloneTo = function _cloneTo(target) {
    target.mesh = this._mesh;
  }
  /**
   * @override
   */
  ;

  _proto._updateBounds = function _updateBounds(worldBounds) {
    var mesh = this._mesh;

    if (mesh) {
      var localBounds = mesh.bounds;
      var worldMatrix = this._entity.transform.worldMatrix;
      BoundingBox.transform(localBounds, worldMatrix, worldBounds);
    } else {
      worldBounds.min.setValue(0, 0, 0);
      worldBounds.max.setValue(0, 0, 0);
    }
  };

  _createClass(MeshRenderer, [{
    key: "mesh",
    get: function get() {
      return this._mesh;
    },
    set: function set(mesh) {
      var lastMesh = this._mesh;

      if (lastMesh !== mesh) {
        if (lastMesh) {
          lastMesh._addRefCount(-1);

          this._meshUpdateFlag.destroy();
        }

        if (mesh) {
          mesh._addRefCount(1);

          this._meshUpdateFlag = mesh.registerUpdateFlag();
        }

        this._mesh = mesh;
      }
    }
  }]);

  return MeshRenderer;
}(Renderer), _class2$4._uvMacro = Shader.getMacroByName("O3_HAS_UV"), _class2$4._normalMacro = Shader.getMacroByName("O3_HAS_NORMAL"), _class2$4._tangentMacro = Shader.getMacroByName("O3_HAS_TANGENT"), _class2$4._vertexColorMacro = Shader.getMacroByName("O3_HAS_VERTEXCOLOR"), _temp$4), (_descriptor$5 = _applyDecoratedDescriptor(_class$5.prototype, "_mesh", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$5 = _applyDecoratedDescriptor(_class$5.prototype, "_meshUpdateFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class$5);

var _class$4, _descriptor$4, _descriptor2$4, _descriptor3$4, _descriptor4$4, _descriptor5$4, _descriptor6$4, _class2$3, _temp$3;

/**
 * SkinnedMeshRenderer.
 */
var SkinnedMeshRenderer = (_class$4 = (_temp$3 = _class2$3 = /*#__PURE__*/function (_MeshRenderer) {
  _inheritsLoose(SkinnedMeshRenderer, _MeshRenderer);

  /**
   * Constructor of SkinnedMeshRenderer
   * @param entity - Entity
   */
  function SkinnedMeshRenderer(entity) {
    var _this;

    _this = _MeshRenderer.call(this, entity) || this;

    _initializerDefineProperty(_this, "matrixPalette", _descriptor$4, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "jointNodes", _descriptor2$4, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "jointTexture", _descriptor3$4, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_hasInitJoints", _descriptor4$4, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_mat", _descriptor5$4, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_useJointTexture", _descriptor6$4, _assertThisInitialized(_this));

    _this._skin = void 0;
    _this._blendShapeWeights = void 0;
    _this._mat = new Matrix();
    _this._skin = null;
    return _this;
  }
  /**
   * @internal
   */


  var _proto = SkinnedMeshRenderer.prototype;

  _proto._updateShaderData = function _updateShaderData(context) {
    _MeshRenderer.prototype._updateShaderData.call(this, context);

    var shaderData = this.shaderData;

    if (!this._useJointTexture && this.matrixPalette) {
      shaderData.setFloatArray(SkinnedMeshRenderer._jointMatrixProperty, this.matrixPalette);
    }

    var mesh = this.mesh;

    if (mesh._hasBlendShape) {
      shaderData.setFloatArray(SkinnedMeshRenderer._blendShapeWeightsProperty, this._blendShapeWeights);
      shaderData.enableMacro(SkinnedMeshRenderer._blendShapeMacro);

      if (mesh._useBlendShapeNormal) {
        shaderData.enableMacro(SkinnedMeshRenderer._blendShapeNormalMacro);
      } else {
        shaderData.disableMacro(SkinnedMeshRenderer._blendShapeNormalMacro);
      }

      if (mesh._useBlendShapeTangent) {
        shaderData.enableMacro(SkinnedMeshRenderer._blendShapeTangentMacro);
      } else {
        shaderData.disableMacro(SkinnedMeshRenderer._blendShapeTangentMacro);
      }
    } else {
      shaderData.disableMacro(SkinnedMeshRenderer._blendShapeMacro);
    }
  }
  /**
   * Skin Object.
   */
  ;

  _proto._initJoints = function _initJoints() {
    var _this$jointNodes;

    if (!this._skin) return;
    var skin = this._skin;
    var joints = skin.joints;
    var jointNodes = [];

    for (var i = joints.length - 1; i >= 0; i--) {
      jointNodes[i] = this.findByNodeName(this.entity, joints[i]);
    } // end of for


    this.matrixPalette = new Float32Array(jointNodes.length * 16);
    this.jointNodes = jointNodes;
    /** Whether to use a skeleton texture */

    var rhi = this.entity.engine._hardwareRenderer;
    if (!rhi) return;
    var maxAttribUniformVec4 = rhi.renderStates.getParameter(rhi.gl.MAX_VERTEX_UNIFORM_VECTORS);
    var maxJoints = Math.floor((maxAttribUniformVec4 - 20) / 4);
    var shaderData = this.shaderData;
    var jointCount = (_this$jointNodes = this.jointNodes) === null || _this$jointNodes === void 0 ? void 0 : _this$jointNodes.length;

    if (jointCount) {
      shaderData.enableMacro("O3_HAS_SKIN");
      shaderData.setInt(SkinnedMeshRenderer._jointCountProperty, jointCount);

      if (joints.length > maxJoints) {
        if (rhi.canIUseMoreJoints) {
          this._useJointTexture = true;
        } else {
          Logger.error("component's joints count(" + joints + ") greater than device's MAX_VERTEX_UNIFORM_VECTORS number " + maxAttribUniformVec4 + ", and don't support jointTexture in this device. suggest joint count less than " + maxJoints + ".", this);
        }
      } else {
        var _maxJoints = Math.max(SkinnedMeshRenderer._maxJoints, joints.length);

        SkinnedMeshRenderer._maxJoints = _maxJoints;
        shaderData.disableMacro("O3_USE_JOINT_TEXTURE");
        shaderData.enableMacro("O3_JOINTS_NUM", _maxJoints.toString());
      }
    } else {
      shaderData.disableMacro("O3_HAS_SKIN");
    }
  };

  _proto.findByNodeName = function findByNodeName(entity, nodeName) {
    if (!entity) return null;
    var n = entity.findByName(nodeName);
    if (n) return n;
    return this.findByNodeName(entity.parent, nodeName);
  }
  /**
   * @internal
   */
  ;

  _proto.update = function update() {
    if (!this._hasInitJoints) {
      this._initJoints();

      this._hasInitJoints = true;
    }

    if (this._skin) {
      var joints = this.jointNodes;
      var ibms = this._skin.inverseBindMatrices;
      var matrixPalette = this.matrixPalette;
      var worldToLocal = this.entity.getInvModelMatrix();
      var mat = this._mat;

      for (var i = joints.length - 1; i >= 0; i--) {
        mat.identity();

        if (joints[i]) {
          Matrix.multiply(joints[i].transform.worldMatrix, ibms[i], mat);
        } else {
          ibms[i].cloneTo(mat);
        }

        Matrix.multiply(worldToLocal, mat, mat);
        matrixPalette.set(mat.elements, i * 16);
      }

      if (this._useJointTexture) {
        this.createJointTexture();
      }
    }
  }
  /**
   * Generate joint texture.
   * Format: (4 * RGBA) * jointCont
   */
  ;

  _proto.createJointTexture = function createJointTexture() {
    if (!this.jointTexture) {
      var engine = this.engine;
      var rhi = engine._hardwareRenderer;
      if (!rhi) return;
      this.jointTexture = new Texture2D(engine, 4, this.jointNodes.length, TextureFormat.R32G32B32A32, false);
      this.jointTexture.filterMode = TextureFilterMode.Point;
      this.shaderData.enableMacro("O3_USE_JOINT_TEXTURE");
      this.shaderData.setTexture(SkinnedMeshRenderer._jointSamplerProperty, this.jointTexture);
    }

    this.jointTexture.setPixelBuffer(this.matrixPalette);
  };

  _createClass(SkinnedMeshRenderer, [{
    key: "blendShapeWeights",
    get:
    /**
     * The weights of the BlendShapes.
     * @remarks Array index is BlendShape index.
     */
    function get() {
      return this._blendShapeWeights;
    },
    set: function set(value) {
      this._blendShapeWeights = value;
    }
  }, {
    key: "skin",
    get: function get() {
      return this._skin;
    },
    set: function set(skin) {
      this._skin = skin;
    }
  }]);

  return SkinnedMeshRenderer;
}(MeshRenderer), _class2$3._blendShapeMacro = Shader.getMacroByName("OASIS_BLENDSHAPE"), _class2$3._blendShapeNormalMacro = Shader.getMacroByName("OASIS_BLENDSHAPE_NORMAL"), _class2$3._blendShapeTangentMacro = Shader.getMacroByName("OASIS_BLENDSHAPE_TANGENT"), _class2$3._jointCountProperty = Shader.getPropertyByName("u_jointCount"), _class2$3._jointSamplerProperty = Shader.getPropertyByName("u_jointSampler"), _class2$3._jointMatrixProperty = Shader.getPropertyByName("u_jointMatrix"), _class2$3._blendShapeWeightsProperty = Shader.getPropertyByName("u_blendShapeWeights"), _class2$3._maxJoints = 0, _temp$3), (_descriptor$4 = _applyDecoratedDescriptor(_class$4.prototype, "matrixPalette", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$4 = _applyDecoratedDescriptor(_class$4.prototype, "jointNodes", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$4 = _applyDecoratedDescriptor(_class$4.prototype, "jointTexture", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$4 = _applyDecoratedDescriptor(_class$4.prototype, "_hasInitJoints", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor5$4 = _applyDecoratedDescriptor(_class$4.prototype, "_mat", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6$4 = _applyDecoratedDescriptor(_class$4.prototype, "_useJointTexture", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
})), _class$4);

/**
 * Used to generate common primitive meshes.
 */

var PrimitiveMesh = /*#__PURE__*/function () {
  function PrimitiveMesh() {}

  /**
   * Create a sphere mesh.
   * @param engine - Engine
   * @param radius - Sphere radius
   * @param segments - Number of segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Sphere model mesh
   */
  PrimitiveMesh.createSphere = function createSphere(engine, radius, segments, noLongerAccessible) {
    if (radius === void 0) {
      radius = 0.5;
    }

    if (segments === void 0) {
      segments = 18;
    }

    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }

    var mesh = new ModelMesh(engine);
    segments = Math.max(2, Math.floor(segments));
    var count = segments + 1;
    var vertexCount = count * count;
    var rectangleCount = segments * segments;

    var indices = PrimitiveMesh._generateIndices(engine, vertexCount, rectangleCount * 6);

    var thetaRange = Math.PI;
    var alphaRange = thetaRange * 2;
    var countReciprocal = 1.0 / count;
    var segmentsReciprocal = 1.0 / segments;
    var positions = new Array(vertexCount);
    var normals = new Array(vertexCount);
    var uvs = new Array(vertexCount);

    for (var i = 0; i < vertexCount; ++i) {
      var x = i % count;
      var y = i * countReciprocal | 0;
      var u = x * segmentsReciprocal;
      var v = y * segmentsReciprocal;
      var alphaDelta = u * alphaRange;
      var thetaDelta = v * thetaRange;
      var sinTheta = Math.sin(thetaDelta);
      var posX = -radius * Math.cos(alphaDelta) * sinTheta;
      var posY = radius * Math.cos(thetaDelta);
      var posZ = radius * Math.sin(alphaDelta) * sinTheta; // Position

      positions[i] = new Vector3(posX, posY, posZ); // Normal

      normals[i] = new Vector3(posX, posY, posZ); // Texcoord

      uvs[i] = new Vector2(u, v);
    }

    var offset = 0;

    for (var _i = 0; _i < rectangleCount; ++_i) {
      var _x = _i % segments;

      var _y = _i * segmentsReciprocal | 0;

      var a = _y * count + _x;
      var b = a + 1;
      var c = a + count;
      var d = c + 1;
      indices[offset++] = b;
      indices[offset++] = a;
      indices[offset++] = d;
      indices[offset++] = a;
      indices[offset++] = c;
      indices[offset++] = d;
    }

    var bounds = mesh.bounds;
    bounds.min.setValue(-radius, -radius, -radius);
    bounds.max.setValue(radius, radius, radius);

    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);

    return mesh;
  }
  /**
   * Create a cuboid mesh.
   * @param engine - Engine
   * @param width - Cuboid width
   * @param height - Cuboid height
   * @param depth - Cuboid depth
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Cuboid model mesh
   */
  ;

  PrimitiveMesh.createCuboid = function createCuboid(engine, width, height, depth, noLongerAccessible) {
    if (width === void 0) {
      width = 1;
    }

    if (height === void 0) {
      height = 1;
    }

    if (depth === void 0) {
      depth = 1;
    }

    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }

    var mesh = new ModelMesh(engine);
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var halfDepth = depth / 2;
    var positions = new Array(24);
    var normals = new Array(24);
    var uvs = new Array(24); // Up

    positions[0] = new Vector3(-halfWidth, halfHeight, -halfDepth);
    positions[1] = new Vector3(halfWidth, halfHeight, -halfDepth);
    positions[2] = new Vector3(halfWidth, halfHeight, halfDepth);
    positions[3] = new Vector3(-halfWidth, halfHeight, halfDepth);
    normals[0] = new Vector3(0, 1, 0);
    normals[1] = new Vector3(0, 1, 0);
    normals[2] = new Vector3(0, 1, 0);
    normals[3] = new Vector3(0, 1, 0);
    uvs[0] = new Vector2(0, 0);
    uvs[1] = new Vector2(1, 0);
    uvs[2] = new Vector2(1, 1);
    uvs[3] = new Vector2(0, 1); // Down

    positions[4] = new Vector3(-halfWidth, -halfHeight, -halfDepth);
    positions[5] = new Vector3(halfWidth, -halfHeight, -halfDepth);
    positions[6] = new Vector3(halfWidth, -halfHeight, halfDepth);
    positions[7] = new Vector3(-halfWidth, -halfHeight, halfDepth);
    normals[4] = new Vector3(0, -1, 0);
    normals[5] = new Vector3(0, -1, 0);
    normals[6] = new Vector3(0, -1, 0);
    normals[7] = new Vector3(0, -1, 0);
    uvs[4] = new Vector2(0, 1);
    uvs[5] = new Vector2(1, 1);
    uvs[6] = new Vector2(1, 0);
    uvs[7] = new Vector2(0, 0); // Left

    positions[8] = new Vector3(-halfWidth, halfHeight, -halfDepth);
    positions[9] = new Vector3(-halfWidth, halfHeight, halfDepth);
    positions[10] = new Vector3(-halfWidth, -halfHeight, halfDepth);
    positions[11] = new Vector3(-halfWidth, -halfHeight, -halfDepth);
    normals[8] = new Vector3(-1, 0, 0);
    normals[9] = new Vector3(-1, 0, 0);
    normals[10] = new Vector3(-1, 0, 0);
    normals[11] = new Vector3(-1, 0, 0);
    uvs[8] = new Vector2(0, 0);
    uvs[9] = new Vector2(1, 0);
    uvs[10] = new Vector2(1, 1);
    uvs[11] = new Vector2(0, 1); // Right

    positions[12] = new Vector3(halfWidth, halfHeight, -halfDepth);
    positions[13] = new Vector3(halfWidth, halfHeight, halfDepth);
    positions[14] = new Vector3(halfWidth, -halfHeight, halfDepth);
    positions[15] = new Vector3(halfWidth, -halfHeight, -halfDepth);
    normals[12] = new Vector3(1, 0, 0);
    normals[13] = new Vector3(1, 0, 0);
    normals[14] = new Vector3(1, 0, 0);
    normals[15] = new Vector3(1, 0, 0);
    uvs[12] = new Vector2(1, 0);
    uvs[13] = new Vector2(0, 0);
    uvs[14] = new Vector2(0, 1);
    uvs[15] = new Vector2(1, 1); // Front

    positions[16] = new Vector3(-halfWidth, halfHeight, halfDepth);
    positions[17] = new Vector3(halfWidth, halfHeight, halfDepth);
    positions[18] = new Vector3(halfWidth, -halfHeight, halfDepth);
    positions[19] = new Vector3(-halfWidth, -halfHeight, halfDepth);
    normals[16] = new Vector3(0, 0, 1);
    normals[17] = new Vector3(0, 0, 1);
    normals[18] = new Vector3(0, 0, 1);
    normals[19] = new Vector3(0, 0, 1);
    uvs[16] = new Vector2(0, 0);
    uvs[17] = new Vector2(1, 0);
    uvs[18] = new Vector2(1, 1);
    uvs[19] = new Vector2(0, 1); // Back

    positions[20] = new Vector3(-halfWidth, halfHeight, -halfDepth);
    positions[21] = new Vector3(halfWidth, halfHeight, -halfDepth);
    positions[22] = new Vector3(halfWidth, -halfHeight, -halfDepth);
    positions[23] = new Vector3(-halfWidth, -halfHeight, -halfDepth);
    normals[20] = new Vector3(0, 0, -1);
    normals[21] = new Vector3(0, 0, -1);
    normals[22] = new Vector3(0, 0, -1);
    normals[23] = new Vector3(0, 0, -1);
    uvs[20] = new Vector2(1, 0);
    uvs[21] = new Vector2(0, 0);
    uvs[22] = new Vector2(0, 1);
    uvs[23] = new Vector2(1, 1);
    var indices = new Uint16Array(36); // prettier-ignore
    // Up

    indices[0] = 0, indices[1] = 2, indices[2] = 1, indices[3] = 2, indices[4] = 0, indices[5] = 3, // Down
    indices[6] = 4, indices[7] = 6, indices[8] = 7, indices[9] = 6, indices[10] = 4, indices[11] = 5, // Left
    indices[12] = 8, indices[13] = 10, indices[14] = 9, indices[15] = 10, indices[16] = 8, indices[17] = 11, // Right
    indices[18] = 12, indices[19] = 14, indices[20] = 15, indices[21] = 14, indices[22] = 12, indices[23] = 13, // Front
    indices[24] = 16, indices[25] = 18, indices[26] = 17, indices[27] = 18, indices[28] = 16, indices[29] = 19, // Back
    indices[30] = 20, indices[31] = 22, indices[32] = 23, indices[33] = 22, indices[34] = 20, indices[35] = 21;
    var bounds = mesh.bounds;
    bounds.min.setValue(-halfWidth, -halfHeight, -halfDepth);
    bounds.max.setValue(halfWidth, halfHeight, halfDepth);

    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);

    return mesh;
  }
  /**
   * Create a plane mesh.
   * @param engine - Engine
   * @param width - Plane width
   * @param height - Plane height
   * @param horizontalSegments - Plane horizontal segments
   * @param verticalSegments - Plane vertical segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Plane model mesh
   */
  ;

  PrimitiveMesh.createPlane = function createPlane(engine, width, height, horizontalSegments, verticalSegments, noLongerAccessible) {
    if (width === void 0) {
      width = 1;
    }

    if (height === void 0) {
      height = 1;
    }

    if (horizontalSegments === void 0) {
      horizontalSegments = 1;
    }

    if (verticalSegments === void 0) {
      verticalSegments = 1;
    }

    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }

    var mesh = new ModelMesh(engine);
    horizontalSegments = Math.max(1, Math.floor(horizontalSegments));
    verticalSegments = Math.max(1, Math.floor(verticalSegments));
    var horizontalCount = horizontalSegments + 1;
    var verticalCount = verticalSegments + 1;
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var gridWidth = width / horizontalSegments;
    var gridHeight = height / verticalSegments;
    var vertexCount = horizontalCount * verticalCount;
    var rectangleCount = verticalSegments * horizontalSegments;

    var indices = PrimitiveMesh._generateIndices(engine, vertexCount, rectangleCount * 6);

    var horizontalCountReciprocal = 1.0 / horizontalCount;
    var horizontalSegmentsReciprocal = 1.0 / horizontalSegments;
    var verticalSegmentsReciprocal = 1.0 / verticalSegments;
    var positions = new Array(vertexCount);
    var normals = new Array(vertexCount);
    var uvs = new Array(vertexCount);

    for (var i = 0; i < vertexCount; ++i) {
      var x = i % horizontalCount;
      var y = i * horizontalCountReciprocal | 0; // Position

      positions[i] = new Vector3(x * gridWidth - halfWidth, y * gridHeight - halfHeight, 0); // Normal

      normals[i] = new Vector3(0, 0, 1); // Texcoord

      uvs[i] = new Vector2(x * horizontalSegmentsReciprocal, 1 - y * verticalSegmentsReciprocal);
    }

    var offset = 0;

    for (var _i2 = 0; _i2 < rectangleCount; ++_i2) {
      var _x2 = _i2 % horizontalSegments;

      var _y2 = _i2 * horizontalSegmentsReciprocal | 0;

      var a = _y2 * horizontalCount + _x2;
      var b = a + 1;
      var c = a + horizontalCount;
      var d = c + 1;
      indices[offset++] = b;
      indices[offset++] = c;
      indices[offset++] = a;
      indices[offset++] = b;
      indices[offset++] = d;
      indices[offset++] = c;
    }

    var bounds = mesh.bounds;
    bounds.min.setValue(-halfWidth, -halfHeight, 0);
    bounds.max.setValue(halfWidth, halfHeight, 0);

    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);

    return mesh;
  }
  /**
   * Create a cylinder mesh.
   * @param engine - Engine
   * @param radiusTop - The radius of top cap
   * @param radiusBottom - The radius of bottom cap
   * @param height - The height of torso
   * @param radialSegments - Cylinder radial segments
   * @param heightSegments - Cylinder height segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Cylinder model mesh
   */
  ;

  PrimitiveMesh.createCylinder = function createCylinder(engine, radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible) {
    if (radiusTop === void 0) {
      radiusTop = 0.5;
    }

    if (radiusBottom === void 0) {
      radiusBottom = 0.5;
    }

    if (height === void 0) {
      height = 2;
    }

    if (radialSegments === void 0) {
      radialSegments = 20;
    }

    if (heightSegments === void 0) {
      heightSegments = 1;
    }

    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }

    var mesh = new ModelMesh(engine);
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    var radialCount = radialSegments + 1;
    var verticalCount = heightSegments + 1;
    var halfHeight = height * 0.5;
    var unitHeight = height / heightSegments;
    var torsoVertexCount = radialCount * verticalCount;
    var torsoRectangleCount = radialSegments * heightSegments;
    var capTriangleCount = radialSegments * 2;
    var totalVertexCount = torsoVertexCount + 2 + capTriangleCount;

    var indices = PrimitiveMesh._generateIndices(engine, totalVertexCount, torsoRectangleCount * 6 + capTriangleCount * 3);

    var radialCountReciprocal = 1.0 / radialCount;
    var radialSegmentsReciprocal = 1.0 / radialSegments;
    var heightSegmentsReciprocal = 1.0 / heightSegments;
    var positions = new Array(totalVertexCount);
    var normals = new Array(totalVertexCount);
    var uvs = new Array(totalVertexCount);
    var indicesOffset = 0; // Create torso

    var thetaStart = Math.PI;
    var thetaRange = Math.PI * 2;
    var radiusDiff = radiusBottom - radiusTop;
    var slope = radiusDiff / height;
    var radiusSlope = radiusDiff / heightSegments;

    for (var i = 0; i < torsoVertexCount; ++i) {
      var x = i % radialCount;
      var y = i * radialCountReciprocal | 0;
      var u = x * radialSegmentsReciprocal;
      var v = y * heightSegmentsReciprocal;
      var theta = thetaStart + u * thetaRange;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      var radius = radiusBottom - y * radiusSlope;
      var posX = radius * sinTheta;
      var posY = y * unitHeight - halfHeight;
      var posZ = radius * cosTheta; // Position

      positions[i] = new Vector3(posX, posY, posZ); // Normal

      normals[i] = new Vector3(sinTheta, slope, cosTheta); // Texcoord

      uvs[i] = new Vector2(u, 1 - v);
    }

    for (var _i3 = 0; _i3 < torsoRectangleCount; ++_i3) {
      var _x3 = _i3 % radialSegments;

      var _y3 = _i3 * radialSegmentsReciprocal | 0;

      var a = _y3 * radialCount + _x3;
      var b = a + 1;
      var c = a + radialCount;
      var d = c + 1;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = c;
      indices[indicesOffset++] = a;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = d;
      indices[indicesOffset++] = c;
    } // Bottom position


    positions[torsoVertexCount] = new Vector3(0, -halfHeight, 0); // Bottom normal

    normals[torsoVertexCount] = new Vector3(0, -1, 0); // Bottom texcoord

    uvs[torsoVertexCount] = new Vector2(0.5, 0.5); // Top position

    positions[torsoVertexCount + 1] = new Vector3(0, halfHeight, 0); // Top normal

    normals[torsoVertexCount + 1] = new Vector3(0, 1, 0); // Top texcoord

    uvs[torsoVertexCount + 1] = new Vector2(0.5, 0.5); // Add cap vertices

    var offset = torsoVertexCount + 2;
    var diameterTopReciprocal = 1.0 / (radiusTop * 2);
    var diameterBottomReciprocal = 1.0 / (radiusBottom * 2);
    var positionStride = radialCount * heightSegments;

    for (var _i4 = 0; _i4 < radialSegments; ++_i4) {
      var curPosBottom = positions[_i4];
      var curPosX = curPosBottom.x;
      var curPosZ = curPosBottom.z; // Bottom position

      positions[offset] = new Vector3(curPosX, -halfHeight, curPosZ); // Bottom normal

      normals[offset] = new Vector3(0, -1, 0); // Bottom texcoord

      uvs[offset++] = new Vector2(curPosX * diameterBottomReciprocal + 0.5, 0.5 - curPosZ * diameterBottomReciprocal);
      var curPosTop = positions[_i4 + positionStride];
      curPosX = curPosTop.x;
      curPosZ = curPosTop.z; // Top position

      positions[offset] = new Vector3(curPosX, halfHeight, curPosZ); // Top normal

      normals[offset] = new Vector3(0, 1, 0); // Top texcoord

      uvs[offset++] = new Vector2(curPosX * diameterTopReciprocal + 0.5, curPosZ * diameterTopReciprocal + 0.5);
    } // Add cap indices


    var topCapIndex = torsoVertexCount + 1;
    var bottomIndiceIndex = torsoVertexCount + 2;
    var topIndiceIndex = bottomIndiceIndex + 1;

    for (var _i5 = 0; _i5 < radialSegments; ++_i5) {
      var firstStride = _i5 * 2;
      var secondStride = _i5 === radialSegments - 1 ? 0 : firstStride + 2; // Bottom

      indices[indicesOffset++] = torsoVertexCount;
      indices[indicesOffset++] = bottomIndiceIndex + secondStride;
      indices[indicesOffset++] = bottomIndiceIndex + firstStride; // Top

      indices[indicesOffset++] = topCapIndex;
      indices[indicesOffset++] = topIndiceIndex + firstStride;
      indices[indicesOffset++] = topIndiceIndex + secondStride;
    }

    var bounds = mesh.bounds;
    var radiusMax = Math.max(radiusTop, radiusBottom);
    bounds.min.setValue(-radiusMax, -halfHeight, -radiusMax);
    bounds.max.setValue(radiusMax, halfHeight, radiusMax);

    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);

    return mesh;
  }
  /**
   * Create a torus mesh.
   * @param engine - Engine
   * @param radius - Torus radius
   * @param tubeRadius - Torus tube
   * @param radialSegments - Torus radial segments
   * @param tubularSegments - Torus tubular segments
   * @param arc - Central angle
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Torus model mesh
   */
  ;

  PrimitiveMesh.createTorus = function createTorus(engine, radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible) {
    if (radius === void 0) {
      radius = 0.5;
    }

    if (tubeRadius === void 0) {
      tubeRadius = 0.1;
    }

    if (radialSegments === void 0) {
      radialSegments = 30;
    }

    if (tubularSegments === void 0) {
      tubularSegments = 30;
    }

    if (arc === void 0) {
      arc = 360;
    }

    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }

    var mesh = new ModelMesh(engine);
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    var vertexCount = (radialSegments + 1) * (tubularSegments + 1);
    var rectangleCount = radialSegments * tubularSegments;

    var indices = PrimitiveMesh._generateIndices(engine, vertexCount, rectangleCount * 6);

    var positions = new Array(vertexCount);
    var normals = new Array(vertexCount);
    var uvs = new Array(vertexCount);
    arc = arc / 180 * Math.PI;
    var offset = 0;

    for (var i = 0; i <= radialSegments; i++) {
      for (var j = 0; j <= tubularSegments; j++) {
        var u = j / tubularSegments * arc;
        var v = i / radialSegments * Math.PI * 2;
        var cosV = Math.cos(v);
        var sinV = Math.sin(v);
        var cosU = Math.cos(u);
        var sinU = Math.sin(u);
        var position = new Vector3((radius + tubeRadius * cosV) * cosU, (radius + tubeRadius * cosV) * sinU, tubeRadius * sinV);
        positions[offset] = position;
        var centerX = radius * cosU;
        var centerY = radius * sinU;
        normals[offset] = new Vector3(position.x - centerX, position.y - centerY, position.z).normalize();
        uvs[offset++] = new Vector2(j / tubularSegments, i / radialSegments);
      }
    }

    offset = 0;

    for (var _i6 = 1; _i6 <= radialSegments; _i6++) {
      for (var _j = 1; _j <= tubularSegments; _j++) {
        var a = (tubularSegments + 1) * _i6 + _j - 1;
        var b = (tubularSegments + 1) * (_i6 - 1) + _j - 1;
        var c = (tubularSegments + 1) * (_i6 - 1) + _j;
        var d = (tubularSegments + 1) * _i6 + _j;
        indices[offset++] = a;
        indices[offset++] = b;
        indices[offset++] = d;
        indices[offset++] = b;
        indices[offset++] = c;
        indices[offset++] = d;
      }
    }

    var bounds = mesh.bounds;
    var outerRadius = radius + tubeRadius;
    bounds.min.setValue(-outerRadius, -outerRadius, -tubeRadius);
    bounds.max.setValue(outerRadius, outerRadius, tubeRadius);

    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);

    return mesh;
  }
  /**
   * Create a cone mesh.
   * @param engine - Engine
   * @param radius - The radius of cap
   * @param height - The height of torso
   * @param radialSegments - Cylinder radial segments
   * @param heightSegments - Cylinder height segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Cone model mesh
   */
  ;

  PrimitiveMesh.createCone = function createCone(engine, radius, height, radialSegments, heightSegments, noLongerAccessible) {
    if (radius === void 0) {
      radius = 0.5;
    }

    if (height === void 0) {
      height = 2;
    }

    if (radialSegments === void 0) {
      radialSegments = 20;
    }

    if (heightSegments === void 0) {
      heightSegments = 1;
    }

    if (noLongerAccessible === void 0) {
      noLongerAccessible = true;
    }

    var mesh = new ModelMesh(engine);
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    var radialCount = radialSegments + 1;
    var verticalCount = heightSegments + 1;
    var halfHeight = height * 0.5;
    var unitHeight = height / heightSegments;
    var torsoVertexCount = radialCount * verticalCount;
    var torsoRectangleCount = radialSegments * heightSegments;
    var totalVertexCount = torsoVertexCount + 1 + radialSegments;

    var indices = PrimitiveMesh._generateIndices(engine, totalVertexCount, torsoRectangleCount * 6 + radialSegments * 3);

    var radialCountReciprocal = 1.0 / radialCount;
    var radialSegmentsReciprocal = 1.0 / radialSegments;
    var heightSegmentsReciprocal = 1.0 / heightSegments;
    var positions = new Array(totalVertexCount);
    var normals = new Array(totalVertexCount);
    var uvs = new Array(totalVertexCount);
    var indicesOffset = 0; // Create torso

    var thetaStart = Math.PI;
    var thetaRange = Math.PI * 2;
    var slope = radius / height;

    for (var i = 0; i < torsoVertexCount; ++i) {
      var x = i % radialCount;
      var y = i * radialCountReciprocal | 0;
      var u = x * radialSegmentsReciprocal;
      var v = y * heightSegmentsReciprocal;
      var theta = thetaStart + u * thetaRange;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      var curRadius = radius - y * radius;
      var posX = curRadius * sinTheta;
      var posY = y * unitHeight - halfHeight;
      var posZ = curRadius * cosTheta; // Position

      positions[i] = new Vector3(posX, posY, posZ); // Normal

      normals[i] = new Vector3(sinTheta, slope, cosTheta); // Texcoord

      uvs[i] = new Vector2(u, 1 - v);
    }

    for (var _i7 = 0; _i7 < torsoRectangleCount; ++_i7) {
      var _x4 = _i7 % radialSegments;

      var _y4 = _i7 * radialSegmentsReciprocal | 0;

      var a = _y4 * radialCount + _x4;
      var b = a + 1;
      var c = a + radialCount;
      var d = c + 1;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = c;
      indices[indicesOffset++] = a;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = d;
      indices[indicesOffset++] = c;
    } // Bottom position


    positions[torsoVertexCount] = new Vector3(0, -halfHeight, 0); // Bottom normal

    normals[torsoVertexCount] = new Vector3(0, -1, 0); // Bottom texcoord

    uvs[torsoVertexCount] = new Vector2(0.5, 0.5); // Add bottom cap vertices

    var offset = torsoVertexCount + 1;
    var diameterBottomReciprocal = 1.0 / (radius * 2);

    for (var _i8 = 0; _i8 < radialSegments; ++_i8) {
      var curPos = positions[_i8];
      var curPosX = curPos.x;
      var curPosZ = curPos.z; // Bottom position

      positions[offset] = new Vector3(curPosX, -halfHeight, curPosZ); // Bottom normal

      normals[offset] = new Vector3(0, -1, 0); // Bottom texcoord

      uvs[offset++] = new Vector2(curPosX * diameterBottomReciprocal + 0.5, 0.5 - curPosZ * diameterBottomReciprocal);
    }

    var bottomIndiceIndex = torsoVertexCount + 1;

    for (var _i9 = 0; _i9 < radialSegments; ++_i9) {
      var firstStride = _i9;
      var secondStride = _i9 === radialSegments - 1 ? 0 : firstStride + 1; // Bottom

      indices[indicesOffset++] = torsoVertexCount;
      indices[indicesOffset++] = bottomIndiceIndex + secondStride;
      indices[indicesOffset++] = bottomIndiceIndex + firstStride;
    }

    var bounds = mesh.bounds;
    bounds.min.setValue(-radius, -halfHeight, -radius);
    bounds.max.setValue(radius, halfHeight, radius);

    PrimitiveMesh._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);

    return mesh;
  };

  PrimitiveMesh._initialize = function _initialize(mesh, positions, normals, uvs, indices, noLongerAccessible) {
    mesh.setPositions(positions);
    mesh.setNormals(normals);
    mesh.setUVs(uvs);
    mesh.setIndices(indices);
    mesh.uploadData(noLongerAccessible);
    mesh.addSubMesh(0, indices.length);
  };

  PrimitiveMesh._generateIndices = function _generateIndices(engine, vertexCount, indexCount) {
    var indices = null;

    if (vertexCount > 65535) {
      if (engine._hardwareRenderer.canIUse(GLCapabilityType.elementIndexUint)) {
        indices = new Uint32Array(indexCount);
      } else {
        throw Error("The vertex count is over limit.");
      }
    } else {
      indices = new Uint16Array(indexCount);
    }

    return indices;
  };

  return PrimitiveMesh;
}();

/**
 * BufferMesh.
 */

var BufferMesh = /*#__PURE__*/function (_Mesh) {
  _inheritsLoose(BufferMesh, _Mesh);

  function BufferMesh() {
    return _Mesh.apply(this, arguments) || this;
  }

  var _proto = BufferMesh.prototype;

  /**
   * Set vertex elements.
   * @param elements - Vertex element collection
   */
  _proto.setVertexElements = function setVertexElements(elements) {
    this._setVertexElements(elements);
  }
  /**
   * Set vertex buffer binding.
   * @param vertexBufferBindings - Vertex buffer binding
   * @param index - Vertex buffer index, the default value is 0
   */
  ;

  _proto.setVertexBufferBinding = function setVertexBufferBinding(bufferOrBinding, strideOrFirstIndex, index) {
    if (strideOrFirstIndex === void 0) {
      strideOrFirstIndex = 0;
    }

    if (index === void 0) {
      index = 0;
    }

    var binding = bufferOrBinding;
    var isBinding = binding.buffer !== undefined;
    isBinding || (binding = new VertexBufferBinding(bufferOrBinding, strideOrFirstIndex));
    var bindings = this._vertexBufferBindings;
    bindings.length <= index && (bindings.length = index + 1);

    this._setVertexBufferBinding(isBinding ? strideOrFirstIndex : index, binding);
  }
  /**
   * Set vertex buffer binding.
   * @param vertexBufferBindings - Vertex buffer binding
   * @param firstIndex - First vertex buffer index, the default value is 0
   */
  ;

  _proto.setVertexBufferBindings = function setVertexBufferBindings(vertexBufferBindings, firstIndex) {
    if (firstIndex === void 0) {
      firstIndex = 0;
    }

    var bindings = this._vertexBufferBindings;
    var count = vertexBufferBindings.length;
    var needLength = firstIndex + count;
    bindings.length < needLength && (bindings.length = needLength);

    for (var i = 0; i < count; i++) {
      this._setVertexBufferBinding(firstIndex + i, vertexBufferBindings[i]);
    }
  }
  /**
   * Set index buffer binding.
   * @param buffer - Index buffer
   * @param format - Index buffer format
   */
  ;

  _proto.setIndexBufferBinding = function setIndexBufferBinding(bufferOrBinding, format) {
    var binding = bufferOrBinding;

    if (binding) {
      var isBinding = binding.buffer !== undefined;
      isBinding || (binding = new IndexBufferBinding(bufferOrBinding, format));
    }

    this._setIndexBufferBinding(binding);
  };

  _createClass(BufferMesh, [{
    key: "instanceCount",
    get:
    /**
     * Instanced count, disable instanced drawing when set zero.
     */
    function get() {
      return this._instanceCount;
    },
    set: function set(value) {
      this._instanceCount = value;
    }
    /**
     * Vertex buffer binding collection.
     */

  }, {
    key: "vertexBufferBindings",
    get: function get() {
      return this._vertexBufferBindings;
    }
    /**
     * Index buffer binding.
     */

  }, {
    key: "indexBufferBinding",
    get: function get() {
      return this._indexBufferBinding;
    }
    /**
     * Vertex element collection.
     */

  }, {
    key: "vertexElements",
    get: function get() {
      return this._vertexElements;
    }
  }]);

  return BufferMesh;
}(Mesh);

/**
 * BlendShapeFrame.
 */
var BlendShapeFrame =
/** Weight of BlendShapeFrame. */

/** Delta positions for the frame being added. */

/** Delta normals for the frame being added. */

/** Delta tangents for the frame being added. */

/**
 * Create a BlendShapeFrame.
 * @param weight - Weight of BlendShapeFrame
 * @param deltaPositions - Delta positions for the frame being added
 * @param deltaNormals - Delta normals for the frame being added
 * @param deltaTangents - Delta tangents for the frame being added
 */
function BlendShapeFrame(weight, deltaPositions, deltaNormals, deltaTangents) {
  if (deltaNormals === void 0) {
    deltaNormals = null;
  }

  if (deltaTangents === void 0) {
    deltaTangents = null;
  }

  this.weight = void 0;
  this.deltaPositions = void 0;
  this.deltaNormals = void 0;
  this.deltaTangents = void 0;

  if (deltaNormals && deltaNormals.length !== deltaPositions.length) {
    throw "deltaNormals length must same with deltaPositions length.";
  }

  if (deltaTangents && deltaTangents.length !== deltaPositions.length) {
    throw "deltaTangents length must same with deltaPositions length.";
  }

  this.weight = weight;
  this.deltaPositions = deltaPositions;
  this.deltaNormals = deltaNormals;
  this.deltaTangents = deltaTangents;
};

/**
 * BlendShape.
 */

var BlendShape = /*#__PURE__*/function () {
  /**
   * Create a BlendShape.
   * @param name - BlendShape name.
   */
  function BlendShape(name) {
    this.name = void 0;
    this._useBlendShapeNormal = false;
    this._useBlendShapeTangent = false;
    this._frames = [];
    this._updateFlagManager = new UpdateFlagManager();
    this.name = name;
  }
  /**
   * Add a BlendShapeFrame by weight, deltaPositions, deltaNormals and deltaTangents.
   * @param weight - Weight of BlendShapeFrame
   * @param deltaPositions - Delta positions for the frame being added
   * @param deltaNormals - Delta normals for the frame being added
   * @param deltaTangents - Delta tangents for the frame being added
   */


  var _proto = BlendShape.prototype;

  _proto.addFrame = function addFrame(frameOrWeight, deltaPositions, deltaNormals, deltaTangents) {
    if (typeof frameOrWeight === "number") {
      var _frame = new BlendShapeFrame(frameOrWeight, deltaPositions, deltaNormals, deltaTangents);

      this._addFrame(_frame);

      return _frame;
    } else {
      this._addFrame(frameOrWeight);
    }

    this._updateFlagManager.distribute();
  }
  /**
   * Clear all frames.
   */
  ;

  _proto.clearFrames = function clearFrames() {
    this._frames.length = 0;

    this._updateFlagManager.distribute();

    this._useBlendShapeNormal = false;
    this._useBlendShapeTangent = false;
  }
  /**
   * @internal
   */
  ;

  _proto._registerChangeFlag = function _registerChangeFlag() {
    return this._updateFlagManager.register();
  };

  _proto._addFrame = function _addFrame(frame) {
    var frames = this._frames;
    var frameCount = frames.length;

    if (frameCount > 0 && frame.deltaPositions.length !== frames[frameCount - 1].deltaPositions.length) {
      throw "Frame's deltaPositions length must same with before frame deltaPositions length.";
    }

    this._useBlendShapeNormal = this._useBlendShapeNormal || frame.deltaNormals !== null;
    this._useBlendShapeTangent = this._useBlendShapeTangent || frame.deltaTangents !== null;

    this._frames.push(frame);
  };

  _createClass(BlendShape, [{
    key: "frames",
    get:
    /** Name of BlendShape. */

    /** @internal */

    /** @internal */

    /**
     * Frames of BlendShape.
     */
    function get() {
      return this._frames;
    }
  }]);

  return BlendShape;
}();

var Basic2DBatcher = /*#__PURE__*/function () {
  /** The maximum number of vertex. */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */
  function Basic2DBatcher(engine) {
    this._subMeshPool = new ClassPool(SubMesh);
    this._batchedQueue = [];
    this._meshes = [];
    this._meshCount = 1;
    this._vertexBuffers = [];
    this._indiceBuffers = [];
    this._vertices = void 0;
    this._indices = void 0;
    this._flushId = 0;
    this._vertexCount = 0;
    this._elementCount = 0;
    var MAX_VERTEX_COUNT = Basic2DBatcher.MAX_VERTEX_COUNT;
    this._vertices = new Float32Array(MAX_VERTEX_COUNT * 9);
    this._indices = new Uint16Array(MAX_VERTEX_COUNT * 3);
    var _meshes = this._meshes,
        _meshCount = this._meshCount;

    for (var i = 0; i < _meshCount; i++) {
      _meshes[i] = this._createMesh(engine, i);
    }
  }

  var _proto = Basic2DBatcher.prototype;

  _proto.drawElement = function drawElement(element) {
    var len = element.positions.length;

    if (this._vertexCount + len > Basic2DBatcher.MAX_VERTEX_COUNT) {
      this.flush(element.camera.engine);
    }

    this._vertexCount += len;
    this._batchedQueue[this._elementCount++] = element;
  };

  _proto.flush = function flush(engine) {
    var batchedQueue = this._batchedQueue;

    if (batchedQueue.length === 0) {
      return;
    }

    this._updateData(engine);

    this.drawBatches(engine);

    if (!Basic2DBatcher._canUploadSameBuffer) {
      this._flushId++;
    }

    batchedQueue.length = 0;

    this._subMeshPool.resetPool();

    this._vertexCount = 0;
    this._elementCount = 0;
  };

  _proto.clear = function clear() {
    this._flushId = 0;
    this._vertexCount = 0;
    this._elementCount = 0;
    this._batchedQueue.length = 0;
  };

  _proto.destroy = function destroy() {
    this._batchedQueue = null;
    var meshes = this._meshes,
        vertexBuffers = this._vertexBuffers,
        indiceBuffers = this._indiceBuffers;

    for (var i = 0, n = meshes.length; i < n; ++i) {
      meshes[i].destroy();
    }

    this._meshes = null;

    for (var _i = 0, _n = vertexBuffers.length; _i < _n; ++_i) {
      vertexBuffers[_i].destroy();
    }

    this._vertexBuffers = null;

    for (var _i2 = 0, _n2 = indiceBuffers.length; _i2 < _n2; ++_i2) {
      indiceBuffers[_i2].destroy();
    }

    this._indiceBuffers = null;
  };

  _proto._createMesh = function _createMesh(engine, index) {
    var MAX_VERTEX_COUNT = Basic2DBatcher.MAX_VERTEX_COUNT;
    var mesh = new BufferMesh(engine, "BufferMesh" + index);
    var vertexElements = [];
    var vertexStride = this.createVertexElements(vertexElements); // vertices

    this._vertexBuffers[index] = new Buffer(engine, BufferBindFlag.VertexBuffer, MAX_VERTEX_COUNT * 4 * vertexStride, BufferUsage.Dynamic); // indices

    this._indiceBuffers[index] = new Buffer(engine, BufferBindFlag.IndexBuffer, MAX_VERTEX_COUNT * 3, BufferUsage.Dynamic);
    mesh.setVertexBufferBinding(this._vertexBuffers[index], vertexStride);
    mesh.setIndexBufferBinding(this._indiceBuffers[index], IndexFormat.UInt16);
    mesh.setVertexElements(vertexElements);
    return mesh;
  };

  _proto._updateData = function _updateData(engine) {
    var _meshes = this._meshes,
        _flushId = this._flushId;

    if (!Basic2DBatcher._canUploadSameBuffer && this._meshCount <= _flushId) {
      this._meshCount++;
      _meshes[_flushId] = this._createMesh(engine, _flushId);
    }

    var batchedQueue = this._batchedQueue,
        vertices = this._vertices,
        indices = this._indices;
    var mesh = _meshes[_flushId];
    mesh.clearSubMesh();
    var vertexIndex = 0;
    var indiceIndex = 0;
    var vertexStartIndex = 0;
    var vertexCount = 0;
    var curIndiceStartIndex = 0;
    var curMeshIndex = 0;
    var preElement = null;

    for (var i = 0, len = batchedQueue.length; i < len; i++) {
      var _curElement = batchedQueue[i]; // Batch vertex

      vertexIndex = this.updateVertices(_curElement, vertices, vertexIndex); // Batch indice

      var triangles = _curElement.triangles;
      var triangleNum = triangles.length;

      for (var j = 0; j < triangleNum; j++) {
        indices[indiceIndex++] = triangles[j] + curIndiceStartIndex;
      }

      curIndiceStartIndex += _curElement.positions.length;

      if (preElement === null) {
        vertexCount += triangleNum;
      } else {
        if (this.canBatch(preElement, _curElement)) {
          vertexCount += triangleNum;
        } else {
          mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex, vertexCount));
          vertexStartIndex += vertexCount;
          vertexCount = triangleNum;
          batchedQueue[curMeshIndex++] = preElement;
        }
      }

      preElement = _curElement;
    }

    mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex, vertexCount));
    batchedQueue[curMeshIndex] = preElement;

    this._vertexBuffers[_flushId].setData(vertices, 0, 0, vertexIndex);

    this._indiceBuffers[_flushId].setData(indices, 0, 0, indiceIndex);
  };

  _proto._getSubMeshFromPool = function _getSubMeshFromPool(start, count) {
    var subMesh = this._subMeshPool.getFromPool();

    subMesh.start = start;
    subMesh.count = count;
    subMesh.topology = MeshTopology.Triangles;
    return subMesh;
  }
  /**
   * @internal
   */
  ;

  return Basic2DBatcher;
}();
Basic2DBatcher.MAX_VERTEX_COUNT = 4096;
Basic2DBatcher._canUploadSameBuffer = true;

var SpriteMaskBatcher = /*#__PURE__*/function (_Basic2DBatcher) {
  _inheritsLoose(SpriteMaskBatcher, _Basic2DBatcher);

  function SpriteMaskBatcher() {
    return _Basic2DBatcher.apply(this, arguments) || this;
  }

  var _proto = SpriteMaskBatcher.prototype;

  _proto.createVertexElements = function createVertexElements(vertexElements) {
    vertexElements[0] = new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0);
    vertexElements[1] = new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0);
    return 20;
  };

  _proto.canBatch = function canBatch(preElement, curElement) {
    if (preElement.isAdd !== curElement.isAdd) {
      return false;
    } // Compare renderer property


    var preShaderData = preElement.component.shaderData;
    var curShaderData = curElement.component.shaderData;
    var textureProperty = SpriteMask._textureProperty;
    var alphaCutoffProperty = SpriteMask._alphaCutoffProperty;
    return preShaderData.getTexture(textureProperty) === curShaderData.getTexture(textureProperty) && preShaderData.getTexture(alphaCutoffProperty) === curShaderData.getTexture(alphaCutoffProperty);
  };

  _proto.updateVertices = function updateVertices(element, vertices, vertexIndex) {
    var positions = element.positions,
        uv = element.uv;
    var verticesNum = positions.length;

    for (var i = 0; i < verticesNum; i++) {
      var curPos = positions[i];
      var curUV = uv[i];
      vertices[vertexIndex++] = curPos.x;
      vertices[vertexIndex++] = curPos.y;
      vertices[vertexIndex++] = curPos.z;
      vertices[vertexIndex++] = curUV.x;
      vertices[vertexIndex++] = curUV.y;
    }

    return vertexIndex;
  };

  _proto.drawBatches = function drawBatches(engine) {
    var mesh = this._meshes[this._flushId];
    var subMeshes = mesh.subMeshes;
    var batchedQueue = this._batchedQueue;

    for (var i = 0, len = subMeshes.length; i < len; i++) {
      var subMesh = subMeshes[i];
      var spriteMaskElement = batchedQueue[i];

      if (!subMesh || !spriteMaskElement) {
        return;
      }

      var renderer = spriteMaskElement.component;
      var material = spriteMaskElement.material;
      var compileMacros = Shader._compileMacros; // union render global macro and material self macro.

      ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, material.shaderData._macroCollection, compileMacros); // Update stencil state

      var stencilState = material.renderState.stencilState;
      var op = spriteMaskElement.isAdd ? StencilOperation.IncrementSaturate : StencilOperation.DecrementSaturate;
      stencilState.passOperationFront = op;
      stencilState.passOperationBack = op;

      var program = material.shader._getShaderProgram(engine, compileMacros);

      if (!program.isValid) {
        return;
      }

      var camera = spriteMaskElement.camera;
      program.bind();
      program.groupingOtherUniformBlock();
      program.uploadAll(program.sceneUniformBlock, camera.scene.shaderData);
      program.uploadAll(program.cameraUniformBlock, camera.shaderData);
      program.uploadAll(program.rendererUniformBlock, renderer.shaderData);
      program.uploadAll(program.materialUniformBlock, material.shaderData);

      material.renderState._apply(engine);

      engine._hardwareRenderer.drawPrimitive(mesh, subMesh, program);
    }
  };

  return SpriteMaskBatcher;
}(Basic2DBatcher);

/**
 * @internal
 */

var SpriteMaskManager = /*#__PURE__*/function () {
  function SpriteMaskManager(engine) {
    this._batcher = void 0;
    this._preMaskLayer = 0;
    this._batcher = new SpriteMaskBatcher(engine);
  }

  var _proto = SpriteMaskManager.prototype;

  _proto.clear = function clear() {
    this._preMaskLayer = 0;

    this._batcher.clear();
  };

  _proto.preRender = function preRender(camera, renderer) {
    if (renderer.maskInteraction === SpriteMaskInteraction.None) {
      return;
    }

    this._batcher.clear();

    this._processMasksDiff(camera, renderer);

    this._batcher.flush(camera.engine);
  };

  _proto.postRender = function postRender(renderer) {
    if (renderer.maskInteraction === SpriteMaskInteraction.None) {
      return;
    }

    this._preMaskLayer = renderer.maskLayer;
  };

  _proto.destroy = function destroy() {
    this._batcher.destroy();

    this._batcher = null;
  };

  _proto._processMasksDiff = function _processMasksDiff(camera, renderer) {
    var preMaskLayer = this._preMaskLayer;
    var curMaskLayer = renderer.maskLayer;

    if (preMaskLayer !== curMaskLayer) {
      var allMasks = camera._renderPipeline._allSpriteMasks;
      var commonLayer = preMaskLayer & curMaskLayer;
      var addLayer = curMaskLayer & ~preMaskLayer;
      var reduceLayer = preMaskLayer & ~curMaskLayer;
      var allMaskElements = allMasks._elements;

      for (var i = 0, n = allMasks.length; i < n; i++) {
        var mask = allMaskElements[i];
        var influenceLayers = mask.influenceLayers;

        if (influenceLayers & commonLayer) {
          continue;
        }

        if (influenceLayers & addLayer) {
          var maskRenderElement = mask._maskElement;
          maskRenderElement.isAdd = true;

          this._batcher.drawElement(maskRenderElement);

          continue;
        }

        if (influenceLayers & reduceLayer) {
          var _maskRenderElement = mask._maskElement;
          _maskRenderElement.isAdd = false;

          this._batcher.drawElement(_maskRenderElement);
        }
      }
    }
  };

  return SpriteMaskManager;
}();

/**
 * The Background mode enumeration.
 */
var BackgroundMode;

(function (BackgroundMode) {
  BackgroundMode[BackgroundMode["SolidColor"] = 0] = "SolidColor";
  BackgroundMode[BackgroundMode["Sky"] = 1] = "Sky";
  BackgroundMode[BackgroundMode["Texture"] = 2] = "Texture";
})(BackgroundMode || (BackgroundMode = {}));

/**
 * Filling mode of background texture.
 */
var BackgroundTextureFillMode;

(function (BackgroundTextureFillMode) {
  BackgroundTextureFillMode[BackgroundTextureFillMode["AspectFitWidth"] = 0] = "AspectFitWidth";
  BackgroundTextureFillMode[BackgroundTextureFillMode["AspectFitHeight"] = 1] = "AspectFitHeight";
  BackgroundTextureFillMode[BackgroundTextureFillMode["Fill"] = 2] = "Fill";
})(BackgroundTextureFillMode || (BackgroundTextureFillMode = {}));

/**
 * Sky.
 */
var Sky = function Sky() {
  this.material = void 0;
  this.mesh = void 0;
  this._matrix = new Matrix();
};

/**
 * Background of scene.
 */
var Background = /*#__PURE__*/function () {
  /**
   * Constructor of Background.
   * @param _engine Engine Which the background belongs to.
   */
  function Background(_engine) {
    this._engine = _engine;
    this.mode = BackgroundMode.SolidColor;
    this.solidColor = new Color(0.25, 0.25, 0.25, 1.0);
    this.sky = new Sky();
    this._textureFillMode = BackgroundTextureFillMode.AspectFitHeight;
    this._texture = null;
  }
  /**
   * @internal
   */


  var _proto = Background.prototype;

  _proto._resizeBackgroundTexture = function _resizeBackgroundTexture() {
    if (!this._texture) {
      return;
    }

    var canvas = this._engine.canvas;
    var width = canvas.width,
        height = canvas.height;
    var _backgroundTextureMesh = this._engine._backgroundTextureMesh;

    var positions = _backgroundTextureMesh.getPositions();

    switch (this._textureFillMode) {
      case BackgroundTextureFillMode.Fill:
        positions[0].setValue(-1, -1, 1);
        positions[1].setValue(1, -1, 1);
        positions[2].setValue(-1, 1, 1);
        positions[3].setValue(1, 1, 1);
        break;

      case BackgroundTextureFillMode.AspectFitWidth:
        var fitWidthScale = this._texture.height * width / this.texture.width / height;
        positions[0].setValue(-1, -fitWidthScale, 1);
        positions[1].setValue(1, -fitWidthScale, 1);
        positions[2].setValue(-1, fitWidthScale, 1);
        positions[3].setValue(1, fitWidthScale, 1);
        break;

      case BackgroundTextureFillMode.AspectFitHeight:
        var fitHeightScale = this._texture.width * height / this.texture.height / width;
        positions[0].setValue(-fitHeightScale, -1, 1);
        positions[1].setValue(fitHeightScale, -1, 1);
        positions[2].setValue(-fitHeightScale, 1, 1);
        positions[3].setValue(fitHeightScale, 1, 1);
        break;
    }

    _backgroundTextureMesh.setPositions(positions);

    _backgroundTextureMesh.uploadData(false);
  };

  _createClass(Background, [{
    key: "texture",
    get:
    /**
     * Background mode.
     * @defaultValue `BackgroundMode.SolidColor`
     * @remarks If using `BackgroundMode.Sky` mode and material or mesh of the `sky` is not defined, it will downgrade to `BackgroundMode.SolidColor`.
     */

    /**
     * Background solid color.
     * @defaultValue `new Color(0.25, 0.25, 0.25, 1.0)`
     * @remarks When `mode` is `BackgroundMode.SolidColor`, the property will take effects.
     */

    /**
     * Background sky.
     * @remarks When `mode` is `BackgroundMode.Sky`, the property will take effects.
     */

    /** @internal */

    /**
     * Background texture.
     * @remarks When `mode` is `BackgroundMode.Texture`, the property will take effects.
     */
    function get() {
      return this._texture;
    },
    set: function set(value) {
      if (this._texture !== value) {
        this._texture = value;

        this._engine._backgroundTextureMaterial.shaderData.setTexture("u_baseTexture", value);
      }
    }
    /**
     * @internal
     * Background texture fill mode.
     * @remarks When `mode` is `BackgroundMode.Texture`, the property will take effects.
     * @defaultValue `BackgroundTextureFillMode.FitHeight`
     */

  }, {
    key: "textureFillMode",
    get: function get() {
      return this._textureFillMode;
    },
    set: function set(value) {
      if (value !== this._textureFillMode) {
        this._textureFillMode = value;

        this._resizeBackgroundTexture();
      }
    }
  }]);

  return Background;
}();

/**
 * Diffuse mode.
 */
var DiffuseMode;

(function (DiffuseMode) {
  DiffuseMode[DiffuseMode["SolidColor"] = 0] = "SolidColor";
  DiffuseMode[DiffuseMode["SphericalHarmonics"] = 1] = "SphericalHarmonics";
})(DiffuseMode || (DiffuseMode = {}));

/**
 * Ambient light.
 */

var AmbientLight = /*#__PURE__*/function () {
  function AmbientLight(scene) {
    this._scene = void 0;
    this._diffuseSphericalHarmonics = void 0;
    this._diffuseSolidColor = new Color(0.212, 0.227, 0.259);
    this._diffuseIntensity = 1.0;
    this._specularReflection = void 0;
    this._specularIntensity = 1.0;
    this._diffuseMode = DiffuseMode.SolidColor;
    this._shArray = new Float32Array(27);
    this._scene = scene;
    var shaderData = this._scene.shaderData;
    shaderData.setColor(AmbientLight._diffuseColorProperty, this._diffuseSolidColor);
    shaderData.setFloat(AmbientLight._diffuseIntensityProperty, this._diffuseIntensity);
    shaderData.setFloat(AmbientLight._specularIntensityProperty, this._specularIntensity);
  }

  var _proto = AmbientLight.prototype;

  _proto._preComputeSH = function _preComputeSH(sh, out) {
    /**
     * Basis constants
     *
     * 0: 1/2 * Math.sqrt(1 / Math.PI)
     *
     * 1: -1/2 * Math.sqrt(3 / Math.PI)
     * 2: 1/2 * Math.sqrt(3 / Math.PI)
     * 3: -1/2 * Math.sqrt(3 / Math.PI)
     *
     * 4: 1/2 * Math.sqrt(15 / Math.PI)
     * 5: -1/2 * Math.sqrt(15 / Math.PI)
     * 6: 1/4 * Math.sqrt(5 / Math.PI)
     * 7: -1/2 * Math.sqrt(15 / Math.PI)
     * 8: 1/4 * Math.sqrt(15 / Math.PI)
     */

    /**
     * Convolution kernel
     *
     * 0: Math.PI
     * 1: (2 * Math.PI) / 3
     * 2: Math.PI / 4
     */
    var src = sh.coefficients; // l0

    out[0] = src[0] * 0.886227; // kernel0 * basis0 = 0.886227

    out[1] = src[1] * 0.886227;
    out[2] = src[2] * 0.886227; // l1

    out[3] = src[3] * -1.023327; // kernel1 * basis1 = -1.023327;

    out[4] = src[4] * -1.023327;
    out[5] = src[5] * -1.023327;
    out[6] = src[6] * 1.023327; // kernel1 * basis2 = 1.023327

    out[7] = src[7] * 1.023327;
    out[8] = src[8] * 1.023327;
    out[9] = src[9] * -1.023327; // kernel1 * basis3 = -1.023327

    out[10] = src[10] * -1.023327;
    out[11] = src[11] * -1.023327; // l2

    out[12] = src[12] * 0.858086; // kernel2 * basis4 = 0.858086

    out[13] = src[13] * 0.858086;
    out[14] = src[14] * 0.858086;
    out[15] = src[15] * -0.858086; // kernel2 * basis5 = -0.858086

    out[16] = src[16] * -0.858086;
    out[17] = src[17] * -0.858086;
    out[18] = src[18] * 0.247708; // kernel2 * basis6 = 0.247708

    out[19] = src[19] * 0.247708;
    out[20] = src[20] * 0.247708;
    out[21] = src[21] * -0.858086; // kernel2 * basis7 = -0.858086

    out[22] = src[22] * -0.858086;
    out[23] = src[23] * -0.858086;
    out[24] = src[24] * 0.429042; // kernel2 * basis8 = 0.429042

    out[25] = src[25] * 0.429042;
    out[26] = src[26] * 0.429042;
    return out;
  };

  _createClass(AmbientLight, [{
    key: "diffuseMode",
    get:
    /**
     * Diffuse mode of ambient light.
     */
    function get() {
      return this._diffuseMode;
    },
    set: function set(value) {
      this._diffuseMode = value;

      if (value === DiffuseMode.SphericalHarmonics) {
        this._scene.shaderData.enableMacro(AmbientLight._shMacro);
      } else {
        this._scene.shaderData.disableMacro(AmbientLight._shMacro);
      }
    }
    /**
     * Diffuse reflection solid color.
     * @remarks Effective when diffuse reflection mode is `DiffuseMode.SolidColor`.
     */

  }, {
    key: "diffuseSolidColor",
    get: function get() {
      return this._diffuseSolidColor;
    },
    set: function set(value) {
      if (value !== this._diffuseSolidColor) {
        value.cloneTo(this._diffuseSolidColor);
      }
    }
    /**
     * Diffuse reflection spherical harmonics 3.
     * @remarks Effective when diffuse reflection mode is `DiffuseMode.SphericalHarmonics`.
     */

  }, {
    key: "diffuseSphericalHarmonics",
    get: function get() {
      return this._diffuseSphericalHarmonics;
    },
    set: function set(value) {
      this._diffuseSphericalHarmonics = value;
      var shaderData = this._scene.shaderData;

      if (value) {
        shaderData.setFloatArray(AmbientLight._diffuseSHProperty, this._preComputeSH(value, this._shArray));
      }
    }
    /**
     * Diffuse reflection intensity.
     */

  }, {
    key: "diffuseIntensity",
    get: function get() {
      return this._diffuseIntensity;
    },
    set: function set(value) {
      this._diffuseIntensity = value;

      this._scene.shaderData.setFloat(AmbientLight._diffuseIntensityProperty, value);
    }
    /**
     * Specular reflection texture.
     */

  }, {
    key: "specularTexture",
    get: function get() {
      return this._specularReflection;
    },
    set: function set(value) {
      this._specularReflection = value;
      var shaderData = this._scene.shaderData;

      if (value) {
        shaderData.setTexture(AmbientLight._specularTextureProperty, value);
        shaderData.setFloat(AmbientLight._mipLevelProperty, this._specularReflection.mipmapCount);
        shaderData.enableMacro(AmbientLight._specularMacro);
      } else {
        shaderData.disableMacro(AmbientLight._specularMacro);
      }
    }
    /**
     * Specular reflection intensity.
     */

  }, {
    key: "specularIntensity",
    get: function get() {
      return this._specularIntensity;
    },
    set: function set(value) {
      this._specularIntensity = value;

      this._scene.shaderData.setFloat(AmbientLight._specularIntensityProperty, value);
    }
  }]);

  return AmbientLight;
}();
AmbientLight._shMacro = Shader.getMacroByName("O3_USE_SH");
AmbientLight._specularMacro = Shader.getMacroByName("O3_USE_SPECULAR_ENV");
AmbientLight._diffuseColorProperty = Shader.getPropertyByName("u_envMapLight.diffuse");
AmbientLight._diffuseSHProperty = Shader.getPropertyByName("u_env_sh");
AmbientLight._diffuseIntensityProperty = Shader.getPropertyByName("u_envMapLight.diffuseIntensity");
AmbientLight._specularTextureProperty = Shader.getPropertyByName("u_env_specularSampler");
AmbientLight._specularIntensityProperty = Shader.getPropertyByName("u_envMapLight.specularIntensity");
AmbientLight._mipLevelProperty = Shader.getPropertyByName("u_envMapLight.mipMapLevel");

/**
 * Scene feature plug-in.
 * @deprecated
 */
var SceneFeature = /*#__PURE__*/function () {
  function SceneFeature() {}

  var _proto = SceneFeature.prototype;

  /**
   * Callback before every scene update.
   * @param scene - Scene
   */
  _proto.preUpdate = function preUpdate(scene) {}
  /**
   * Callback after every scene update.
   * @param scene - Scene
   */
  ;

  _proto.postUpdate = function postUpdate(scene) {}
  /**
   * Callback before scene rendering.
   * @param scene - Scene
   * @param camera - Camera
   */
  ;

  _proto.preRender = function preRender(scene, camera) {}
  /**
   * Callback after scene rendering.
   * @param scene - Scene
   * @param camera - Camera
   */
  ;

  _proto.postRender = function postRender(scene, camera) {}
  /**
   * Callback after the scene is destroyed.
   * @param scene - Scene
   */
  ;

  _proto.destroy = function destroy(scene) {};

  return SceneFeature;
}();

/**
 * Light base class.
 */

var Light = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Light, _Component);

  function Light() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this._viewMat = void 0;
    _this._inverseViewMat = void 0;
    return _this;
  }

  var _proto = Light.prototype;

  /**
   * Mount to the current Scene.
   * @internal
   * @override
   */
  _proto._onEnable = function _onEnable() {
    this.scene.findFeature(LightFeature).attachRenderLight(this);
  }
  /**
   * Unmount from the current Scene.
   * @internal
   * @override
   */
  ;

  _proto._onDisable = function _onDisable() {
    this.scene.findFeature(LightFeature).detachRenderLight(this);
  }
  /**
   * View matrix.
   */
  ;

  _createClass(Light, [{
    key: "viewMatrix",
    get: function get() {
      if (!this._viewMat) this._viewMat = new Matrix();
      Matrix.invert(this.entity.transform.worldMatrix, this._viewMat);
      return this._viewMat;
    }
    /**
     * Inverse view matrix.
     */

  }, {
    key: "inverseViewMatrix",
    get: function get() {
      if (!this._inverseViewMat) this._inverseViewMat = new Matrix();
      Matrix.invert(this.viewMatrix, this._inverseViewMat);
      return this._inverseViewMat;
    }
  }]);

  return Light;
}(Component);
Light._maxLight = 10;

/**
 * Directional light.
 */

var DirectLight = /*#__PURE__*/function (_Light) {
  _inheritsLoose(DirectLight, _Light);

  function DirectLight() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Light.call.apply(_Light, [this].concat(args)) || this;
    _this.color = new Color(1, 1, 1, 1);
    _this.intensity = 1;
    _this._forward = new Vector3();
    _this._lightColor = new Color(1, 1, 1, 1);
    _this._reverseDirection = new Vector3();
    return _this;
  }

  /**
   * @internal
   */
  DirectLight._updateShaderData = function _updateShaderData(shaderData) {
    var data = DirectLight._combinedData;
    shaderData.setFloatArray(DirectLight._colorProperty, data.color);
    shaderData.setFloatArray(DirectLight._directionProperty, data.direction);
  };

  var _proto = DirectLight.prototype;

  /**
   * @internal
   */
  _proto._appendData = function _appendData(lightIndex) {
    var colorStart = lightIndex * 3;
    var directionStart = lightIndex * 3;
    var lightColor = this.lightColor;
    var direction = this.direction;
    var data = DirectLight._combinedData;
    data.color[colorStart] = lightColor.r;
    data.color[colorStart + 1] = lightColor.g;
    data.color[colorStart + 2] = lightColor.b;
    data.direction[directionStart] = direction.x;
    data.direction[directionStart + 1] = direction.y;
    data.direction[directionStart + 2] = direction.z;
  };

  _createClass(DirectLight, [{
    key: "direction",
    get:
    /**
     * Get direction.
     */
    function get() {
      this.entity.transform.getWorldForward(this._forward);
      return this._forward;
    }
    /**
     * Get the final light color.
     */

  }, {
    key: "lightColor",
    get: function get() {
      this._lightColor.r = this.color.r * this.intensity;
      this._lightColor.g = this.color.g * this.intensity;
      this._lightColor.b = this.color.b * this.intensity;
      this._lightColor.a = this.color.a * this.intensity;
      return this._lightColor;
    }
    /**
     * Get the opposite direction of the directional light direction.
     */

  }, {
    key: "reverseDirection",
    get: function get() {
      Vector3.scale(this.direction, -1, this._reverseDirection);
      return this._reverseDirection;
    }
  }]);

  return DirectLight;
}(Light);
DirectLight._colorProperty = Shader.getPropertyByName("u_directLightColor");
DirectLight._directionProperty = Shader.getPropertyByName("u_directLightDirection");
DirectLight._combinedData = {
  color: new Float32Array(3 * Light._maxLight),
  direction: new Float32Array(3 * Light._maxLight)
};

/**
 * Point light.
 */

var PointLight = /*#__PURE__*/function (_Light) {
  _inheritsLoose(PointLight, _Light);

  function PointLight() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Light.call.apply(_Light, [this].concat(args)) || this;
    _this.color = new Color(1, 1, 1, 1);
    _this.intensity = 1.0;
    _this.distance = 100;
    _this._lightColor = new Color(1, 1, 1, 1);
    return _this;
  }

  /**
   * @internal
   */
  PointLight._updateShaderData = function _updateShaderData(shaderData) {
    var data = PointLight._combinedData;
    shaderData.setFloatArray(PointLight._colorProperty, data.color);
    shaderData.setFloatArray(PointLight._positionProperty, data.position);
    shaderData.setFloatArray(PointLight._distanceProperty, data.distance);
  }
  /** Light color. */
  ;

  var _proto = PointLight.prototype;

  /**
   * @internal
   */
  _proto._appendData = function _appendData(lightIndex) {
    var colorStart = lightIndex * 3;
    var positionStart = lightIndex * 3;
    var distanceStart = lightIndex;
    var lightColor = this.lightColor;
    var lightPosition = this.position;
    var data = PointLight._combinedData;
    data.color[colorStart] = lightColor.r;
    data.color[colorStart + 1] = lightColor.g;
    data.color[colorStart + 2] = lightColor.b;
    data.position[positionStart] = lightPosition.x;
    data.position[positionStart + 1] = lightPosition.y;
    data.position[positionStart + 2] = lightPosition.z;
    data.distance[distanceStart] = this.distance;
  };

  _createClass(PointLight, [{
    key: "position",
    get:
    /**
     * Get light position.
     */
    function get() {
      return this.entity.transform.worldPosition;
    }
    /**
     * Get the final light color.
     */

  }, {
    key: "lightColor",
    get: function get() {
      this._lightColor.r = this.color.r * this.intensity;
      this._lightColor.g = this.color.g * this.intensity;
      this._lightColor.b = this.color.b * this.intensity;
      this._lightColor.a = this.color.a * this.intensity;
      return this._lightColor;
    }
  }]);

  return PointLight;
}(Light);
PointLight._colorProperty = Shader.getPropertyByName("u_pointLightColor");
PointLight._positionProperty = Shader.getPropertyByName("u_pointLightPosition");
PointLight._distanceProperty = Shader.getPropertyByName("u_pointLightDistance");
PointLight._combinedData = {
  color: new Float32Array(3 * Light._maxLight),
  position: new Float32Array(3 * Light._maxLight),
  distance: new Float32Array(Light._maxLight)
};

/**
 * Spot light.
 */

var SpotLight = /*#__PURE__*/function (_Light) {
  _inheritsLoose(SpotLight, _Light);

  function SpotLight() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Light.call.apply(_Light, [this].concat(args)) || this;
    _this.color = new Color(1, 1, 1, 1);
    _this.intensity = 1.0;
    _this.distance = 100;
    _this.angle = Math.PI / 6;
    _this.penumbra = Math.PI / 12;
    _this._forward = new Vector3();
    _this._lightColor = new Color(1, 1, 1, 1);
    _this._inverseDirection = new Vector3();
    return _this;
  }

  /**
   * @internal
   */
  SpotLight._updateShaderData = function _updateShaderData(shaderData) {
    var data = SpotLight._combinedData;
    shaderData.setFloatArray(SpotLight._colorProperty, data.color);
    shaderData.setFloatArray(SpotLight._positionProperty, data.position);
    shaderData.setFloatArray(SpotLight._directionProperty, data.direction);
    shaderData.setFloatArray(SpotLight._distanceProperty, data.distance);
    shaderData.setFloatArray(SpotLight._angleCosProperty, data.angleCos);
    shaderData.setFloatArray(SpotLight._penumbraCosProperty, data.penumbraCos);
  }
  /** Light color. */
  ;

  var _proto = SpotLight.prototype;

  /**
   * @internal
   */
  _proto._appendData = function _appendData(lightIndex) {
    var colorStart = lightIndex * 3;
    var positionStart = lightIndex * 3;
    var directionStart = lightIndex * 3;
    var distanceStart = lightIndex;
    var penumbraCosStart = lightIndex;
    var angleCosStart = lightIndex;
    var color = this.lightColor;
    var position = this.position;
    var direction = this.direction;
    var data = SpotLight._combinedData;
    data.color[colorStart] = color.r;
    data.color[colorStart + 1] = color.g;
    data.color[colorStart + 2] = color.b;
    data.position[positionStart] = position.x;
    data.position[positionStart + 1] = position.y;
    data.position[positionStart + 2] = position.z;
    data.direction[directionStart] = direction.x;
    data.direction[directionStart + 1] = direction.y;
    data.direction[directionStart + 2] = direction.z;
    data.distance[distanceStart] = this.distance;
    data.angleCos[angleCosStart] = Math.cos(this.angle);
    data.penumbraCos[penumbraCosStart] = Math.cos(this.angle + this.penumbra);
  };

  _createClass(SpotLight, [{
    key: "position",
    get:
    /**
     * Get light position.
     */
    function get() {
      return this.entity.transform.worldPosition;
    }
    /**
     * Get light direction.
     */

  }, {
    key: "direction",
    get: function get() {
      this.entity.transform.getWorldForward(this._forward);
      return this._forward;
    }
    /**
     * Get the opposite direction of the spotlight.
     */

  }, {
    key: "reverseDirection",
    get: function get() {
      Vector3.scale(this.direction, -1, this._inverseDirection);
      return this._inverseDirection;
    }
    /**
     * Get the final light color.
     */

  }, {
    key: "lightColor",
    get: function get() {
      this._lightColor.r = this.color.r * this.intensity;
      this._lightColor.g = this.color.g * this.intensity;
      this._lightColor.b = this.color.b * this.intensity;
      this._lightColor.a = this.color.a * this.intensity;
      return this._lightColor;
    }
  }]);

  return SpotLight;
}(Light);
SpotLight._colorProperty = Shader.getPropertyByName("u_spotLightColor");
SpotLight._positionProperty = Shader.getPropertyByName("u_spotLightPosition");
SpotLight._directionProperty = Shader.getPropertyByName("u_spotLightDirection");
SpotLight._distanceProperty = Shader.getPropertyByName("u_spotLightDistance");
SpotLight._angleCosProperty = Shader.getPropertyByName("u_spotLightAngleCos");
SpotLight._penumbraCosProperty = Shader.getPropertyByName("u_spotLightPenumbraCos");
SpotLight._combinedData = {
  color: new Float32Array(3 * Light._maxLight),
  position: new Float32Array(3 * Light._maxLight),
  direction: new Float32Array(3 * Light._maxLight),
  distance: new Float32Array(Light._maxLight),
  angleCos: new Float32Array(Light._maxLight),
  penumbraCos: new Float32Array(Light._maxLight)
};

/**
 * Determine whether there are lights in the scene.
 * @returns Has light
 */

function hasLight() {
  return this.findFeature(LightFeature).visibleLights.length > 0;
}
/**
 * Light plug-in.
 */

var LightFeature = /*#__PURE__*/function (_SceneFeature) {
  _inheritsLoose(LightFeature, _SceneFeature);

  function LightFeature() {
    var _this;

    _this = _SceneFeature.call(this) || this;
    _this.visibleLights = void 0;
    _this.visibleLights = [];
    return _this;
  }
  /**
   * Register a light object to the current scene.
   * @param light
   */


  var _proto = LightFeature.prototype;

  _proto.attachRenderLight = function attachRenderLight(light) {
    var index = this.visibleLights.indexOf(light);

    if (index == -1) {
      this.visibleLights.push(light);
    } else {
      Logger.warn("Light already attached.");
    }
  }
  /**
   * Remove a light object from the current scene.
   * @param light
   */
  ;

  _proto.detachRenderLight = function detachRenderLight(light) {
    var index = this.visibleLights.indexOf(light);

    if (index != -1) {
      this.visibleLights.splice(index, 1);
    }
  }
  /**
   * @internal
   */
  ;

  _proto._updateShaderData = function _updateShaderData(shaderData) {
    /**
     * ambientLight and envMapLight only use the last one in the scene
     * */
    var directLightCount = 0;
    var pointLightCount = 0;
    var spotLightCount = 0;
    var lights = this.visibleLights;

    for (var i = 0, len = lights.length; i < len; i++) {
      var light = lights[i];

      if (light instanceof DirectLight) {
        light._appendData(directLightCount++);
      } else if (light instanceof PointLight) {
        light._appendData(pointLightCount++);
      } else if (light instanceof SpotLight) {
        light._appendData(spotLightCount++);
      }
    }

    if (directLightCount) {
      DirectLight._updateShaderData(shaderData);

      shaderData.enableMacro("O3_DIRECT_LIGHT_COUNT", directLightCount.toString());
    } else {
      shaderData.disableMacro("O3_DIRECT_LIGHT_COUNT");
    }

    if (pointLightCount) {
      PointLight._updateShaderData(shaderData);

      shaderData.enableMacro("O3_POINT_LIGHT_COUNT", pointLightCount.toString());
    } else {
      shaderData.disableMacro("O3_POINT_LIGHT_COUNT");
    }

    if (spotLightCount) {
      SpotLight._updateShaderData(shaderData);

      shaderData.enableMacro("O3_SPOT_LIGHT_COUNT", spotLightCount.toString());
    } else {
      shaderData.disableMacro("O3_SPOT_LIGHT_COUNT");
    }
  };

  return LightFeature;
}(SceneFeature);

/**
 * Scene.
 */

var Scene = /*#__PURE__*/function (_EngineObject) {
  _inheritsLoose(Scene, _EngineObject);

  /**
   * Create scene.
   * @param engine - Engine
   * @param name - Name
   */
  function Scene(engine, name) {
    var _this;

    _this = _EngineObject.call(this, engine) || this;
    _this.name = void 0;
    _this.background = new Background(_this._engine);
    _this.ambientLight = void 0;
    _this.shaderData = new ShaderData(ShaderDataGroup.Scene);
    _this._activeCameras = [];
    _this._isActiveInEngine = false;
    _this._destroyed = false;
    _this._rootEntities = [];
    _this.features = [];
    _this.name = name || "";
    var shaderData = _this.shaderData;
    Scene.sceneFeatureManager.addObject(_assertThisInitialized(_this));

    shaderData._addRefCount(1);

    _this.ambientLight = new AmbientLight(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Create root entity.
   * @param name - Entity name
   * @returns Entity
   */


  var _proto = Scene.prototype;

  _proto.createRootEntity = function createRootEntity(name) {
    var entity = new Entity(this._engine, name);
    this.addRootEntity(entity);
    return entity;
  }
  /**
   * Append an entity.
   * @param entity - The root entity to add
   */
  ;

  _proto.addRootEntity = function addRootEntity(entity) {
    var isRoot = entity._isRoot; // let entity become root

    if (!isRoot) {
      entity._isRoot = true;

      entity._removeFromParent();
    } // add or remove from scene's rootEntities


    var oldScene = entity._scene;

    if (oldScene !== this) {
      if (oldScene && isRoot) {
        oldScene._removeEntity(entity);
      }

      this._rootEntities.push(entity);

      Entity._traverseSetOwnerScene(entity, this);
    } else if (!isRoot) {
      this._rootEntities.push(entity);
    } // process entity active/inActive


    if (this._isActiveInEngine) {
      !entity._isActiveInHierarchy && entity._isActive && entity._processActive();
    } else {
      entity._isActiveInHierarchy && entity._processInActive();
    }
  }
  /**
   * Remove an entity.
   * @param entity - The root entity to remove
   */
  ;

  _proto.removeRootEntity = function removeRootEntity(entity) {
    if (entity._isRoot && entity._scene == this) {
      this._removeEntity(entity);

      this._isActiveInEngine && entity._processInActive();

      Entity._traverseSetOwnerScene(entity, null);
    }
  }
  /**
   * Get root entity from index.
   * @param index - Index
   * @returns Entity
   */
  ;

  _proto.getRootEntity = function getRootEntity(index) {
    if (index === void 0) {
      index = 0;
    }

    return this._rootEntities[index];
  }
  /**
   * Find entity globally by name.
   * @param name - Entity name
   * @returns Entity
   */
  ;

  _proto.findEntityByName = function findEntityByName(name) {
    var children = this._rootEntities;

    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];

      if (child.name === name) {
        return child;
      }
    }

    for (var _i = children.length - 1; _i >= 0; _i--) {
      var _child = children[_i];

      var entity = _child.findByName(name);

      if (entity) {
        return entity;
      }
    }

    return null;
  }
  /**
   * Find entity globally by name,use â€˜/â€™ symbol as a path separator.
   * @param path - Entity's path
   * @returns Entity
   */
  ;

  _proto.findEntityByPath = function findEntityByPath(path) {
    var splits = path.split("/").filter(Boolean);

    for (var i = 0, n = this.rootEntitiesCount; i < n; i++) {
      var findEntity = this.getRootEntity(i);
      if (findEntity.name != splits[0]) continue;

      for (var j = 1, m = splits.length; j < m; ++j) {
        findEntity = Entity._findChildByName(findEntity, splits[j]);
        if (!findEntity) break;
      }

      return findEntity;
    }

    return null;
  }
  /**
   * Destroy this scene.
   */
  ;

  _proto.destroy = function destroy() {
    if (this._destroyed) {
      return;
    }

    this._isActiveInEngine && (this._engine.sceneManager.activeScene = null);
    Scene.sceneFeatureManager.callFeatureMethod(this, "destroy", [this]);

    for (var i = 0, n = this.rootEntitiesCount; i < n; i++) {
      this._rootEntities[i].destroy();
    }

    this._rootEntities.length = 0;
    this._activeCameras.length = 0;
    Scene.sceneFeatureManager._objects = [];

    this.shaderData._addRefCount(-1);

    this._destroyed = true;
  }
  /**
   * @internal
   */
  ;

  _proto._attachRenderCamera = function _attachRenderCamera(camera) {
    var index = this._activeCameras.indexOf(camera);

    if (index === -1) {
      this._activeCameras.push(camera);
    } else {
      Logger.warn("Camera already attached.");
    }
  }
  /**
   * @internal
   */
  ;

  _proto._detachRenderCamera = function _detachRenderCamera(camera) {
    var index = this._activeCameras.indexOf(camera);

    if (index !== -1) {
      this._activeCameras.splice(index, 1);
    }
  }
  /**
   * @internal
   */
  ;

  _proto._processActive = function _processActive(active) {
    this._isActiveInEngine = active;
    var rootEntities = this._rootEntities;

    for (var i = rootEntities.length - 1; i >= 0; i--) {
      var entity = rootEntities[i];

      if (entity._isActive) {
        active ? entity._processActive() : entity._processInActive();
      }
    }
  }
  /**
   * @internal
   */
  ;

  _proto._updateShaderData = function _updateShaderData() {
    var lightMgr = this.findFeature(LightFeature);

    lightMgr._updateShaderData(this.shaderData);
  };

  _proto._removeEntity = function _removeEntity(entity) {
    var oldRootEntities = this._rootEntities;
    oldRootEntities.splice(oldRootEntities.indexOf(entity), 1);
  } //-----------------------------------------@deprecated-----------------------------------
  ;

  Scene.registerFeature = function registerFeature(Feature) {
    Scene.sceneFeatureManager.registerFeature(Feature);
  };

  _proto.findFeature = function findFeature(Feature) {
    return Scene.sceneFeatureManager.findFeature(this, Feature);
  };

  _createClass(Scene, [{
    key: "rootEntitiesCount",
    get:
    /** Scene name. */

    /** The background of the scene. */

    /** Ambient light. */

    /** Scene-related shader data. */

    /** @internal */

    /** @internal */

    /**
     * Count of root entities.
     */
    function get() {
      return this._rootEntities.length;
    }
    /**
     * Root entity collection.
     */

  }, {
    key: "rootEntities",
    get: function get() {
      return this._rootEntities;
    }
    /**
     * Whether it's destroyed.
     */

  }, {
    key: "destroyed",
    get: function get() {
      return this._destroyed;
    }
  }]);

  return Scene;
}(EngineObject);
Scene.sceneFeatureManager = new FeatureManager();

/**
 * Scene manager.
 */
var SceneManager = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function SceneManager(engine) {
    this.engine = engine;
    this._activeScene = void 0;
  }
  /**
   * Load and activate scene.
   * @param url - the path of the scene
   * @param destroyOldScene - whether to destroy old scene information
   * @returns scene promise
   */


  var _proto = SceneManager.prototype;

  _proto.loadScene = function loadScene(url, destroyOldScene) {
    var _this = this;

    if (destroyOldScene === void 0) {
      destroyOldScene = true;
    }

    var scenePromise = this.engine.resourceManager.load(url);
    scenePromise.then(function (scene) {
      var oldScene = _this._activeScene;
      _this.activeScene = scene;

      if (oldScene && destroyOldScene) {
        oldScene.destroy();
      }
    });
    return scenePromise;
  }
  /**
   * Merge the source scene into the target scene.
   * @remarks the global information of destScene will be used after the merge, and the lightingMap information will be merged.
   * @param sourceScene - source scene
   * @param destScene - target scene
   */
  ;

  _proto.mergeScenes = function mergeScenes(sourceScene, destScene) {
    var oldRootEntities = sourceScene.rootEntities;

    for (var i = 0, n = oldRootEntities.length; i < n; i++) {
      destScene.addRootEntity(oldRootEntities[i]);
    }
  };

  _createClass(SceneManager, [{
    key: "activeScene",
    get:
    /**
     * Get the activated scene.
     */
    function get() {
      return this._activeScene;
    },
    set: function set(scene) {
      var oldScene = this._activeScene;

      if (oldScene !== scene) {
        oldScene && oldScene._processActive(false);
        scene && scene._processActive(true);
        this._activeScene = scene;
      }
    }
  }]);

  return SceneManager;
}();

var blinnPhongFs = "#define GLSLIFY 1\n#include <common>\n#include <common_frag>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <pbr_envmap_light_frag_define>\n#include <direct_light_frag>\n#include <point_light_frag>\n#include <spot_light_frag>\n#include <mobile_material_frag>\n#include <fog_share>\n#include <normal_get>\nvoid main(){\n#include <begin_mobile_frag>\n#include <begin_viewdir_frag>\n#include <mobile_blinnphong_frag>\ngl_FragColor=emission+ambient+diffuse+specular;gl_FragColor.a=diffuse.a;\n#include <fog_frag>\n}"; // eslint-disable-line

var blinnPhongVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <shadow_vert>\n#include <position_vert>\n#include <fog_vert>\n}"; // eslint-disable-line

var particleFs = "#define GLSLIFY 1\nvarying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;uniform sampler2D u_texture;void main(){if(v_lifeLeft==1.0){discard;}float alphaFactor=1.0;\n#ifdef fadeIn\nfloat fadeInFactor=step(0.5,v_lifeLeft);alphaFactor=2.0*fadeInFactor*(1.0-v_lifeLeft)+(1.0-fadeInFactor);\n#endif\n#ifdef fadeOut\nfloat fadeOutFactor=step(0.5,v_lifeLeft);alphaFactor=alphaFactor*2.0*(1.0-fadeOutFactor)*v_lifeLeft+alphaFactor*fadeOutFactor;\n#endif\n#ifdef particleTexture\nvec4 tex=texture2D(u_texture,v_uv);\n#ifdef useOriginColor\ngl_FragColor=vec4(tex.rgb,alphaFactor*tex.a*v_color.w);\n#else\ngl_FragColor=vec4(v_color.xyz*tex.rgb,alphaFactor*tex.a*v_color.w);\n#endif\n#else\ngl_FragColor=vec4(v_color.xyz,alphaFactor*v_color.w);\n#endif\n}"; // eslint-disable-line

var particleVs = "#define GLSLIFY 1\nattribute vec3 a_position;attribute vec3 a_velocity;attribute vec3 a_acceleration;attribute vec4 a_color;attribute vec4 a_lifeAndSize;attribute vec2 a_rotation;attribute vec3 a_uv;attribute vec2 a_normalizedUv;uniform float u_time;uniform bool u_once;uniform mat4 u_MVPMat;varying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;\n#ifdef is2d\nuniform mat4 u_viewInvMat;uniform mat4 u_projMat;uniform mat4 u_viewMat;uniform mat4 u_modelMat;\n#endif\nmat2 rotation2d(float angle){float s=sin(angle);float c=cos(angle);return mat2(c,-s,s,c);}void main(){v_color=a_color;v_uv=a_uv.xy;float life=a_lifeAndSize.y;float startTime=a_lifeAndSize.x;float deltaTime=max(mod(u_time-startTime,life),0.0);if((u_once&&u_time>life+startTime)){deltaTime=0.0;}v_lifeLeft=1.0-deltaTime/life;float scale=a_lifeAndSize.z;vec3 position=a_position+(a_velocity+a_acceleration*deltaTime*0.5)*deltaTime;\n#ifdef isScaleByLifetime\nscale*=v_lifeLeft;\n#else\nscale*=pow(a_lifeAndSize.w,deltaTime);\n#endif\n#ifdef rotateToVelocity\nvec3 v=a_velocity+a_acceleration*deltaTime;float angle=atan(v.z,v.x)*2.0;\n#else\nfloat deltaAngle=deltaTime*a_rotation.y;float angle=a_rotation.x+deltaAngle;\n#endif\n#ifdef is2d\nvec2 rotatedPoint=rotation2d(angle)*vec2(a_normalizedUv.x,a_normalizedUv.y*a_uv.z);vec3 basisX=u_viewInvMat[0].xyz;vec3 basisZ=u_viewInvMat[1].xyz;vec3 localPosition=vec3(basisX*rotatedPoint.x+basisZ*rotatedPoint.y)*scale+position;gl_Position=u_projMat*u_viewMat*vec4(localPosition+u_modelMat[3].xyz,1.);\n#else\n#ifdef rotateToVelocity\nfloat s=sin(angle);float c=cos(angle);\n#else\nfloat s=sin(angle);float c=cos(angle);\n#endif\nvec4 rotatedPoint=vec4((a_normalizedUv.x*c+a_normalizedUv.y*a_uv.z*s)*scale,0.,(a_normalizedUv.x*s-a_normalizedUv.y*a_uv.z*c)*scale,1.);vec4 orientation=vec4(0,0,0,1);vec4 q2=orientation+orientation;vec4 qx=orientation.xxxw*q2.xyzx;vec4 qy=orientation.xyyw*q2.xyzy;vec4 qz=orientation.xxzw*q2.xxzz;mat4 localMatrix=mat4((1.0-qy.y)-qz.z,qx.y+qz.w,qx.z-qy.w,0,qx.y-qz.w,(1.0-qx.x)-qz.z,qy.z+qx.w,0,qx.z+qy.w,qy.z-qx.w,(1.0-qx.x)-qy.y,0,position.x,position.y,position.z,1);rotatedPoint=localMatrix*rotatedPoint;gl_Position=u_MVPMat*rotatedPoint;\n#endif\n}"; // eslint-disable-line

var pbrFs = "#define GLSLIFY 1\n#include <common>\n#include <common_frag>\n#include <pbr_common_frag_define>\n#include <pbr_util_frag_define>\n#include <fog_share>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <direct_light_frag>\n#include <point_light_frag>\n#include <spot_light_frag>\n#include <pbr_envmap_light_frag_define>\n#include <pbr_base_frag_define>\n#include <pbr_texture_frag_define>\n#include <pbr_runtime_frag_define>\n#include <normal_get>\n#include <pbr_brdf_cook_torrance_frag_define>\n#include <pbr_direct_irradiance_frag_define>\n#include <pbr_ibl_diffuse_frag_define>\n#include <pbr_ibl_specular_frag_define>\nvoid main(){\n#include <pbr_begin_frag>\n#include <pbr_direct_irradiance_frag>\n#include <pbr_ibl_diffuse_frag>\n#include <pbr_ibl_specular_frag>\n#include <pbr_end_frag>\n#include <gamma_frag>\n#include <fog_frag>\n}"; // eslint-disable-line

var pbrVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <shadow_vert>\n#include <position_vert>\n#include <fog_vert>\n}"; // eslint-disable-line

var shadowMapFs = "#define GLSLIFY 1\nvec4 pack(float depth){const vec4 bitShift=vec4(1.0,256.0,256.0*256.0,256.0*256.0*256.0);const vec4 bitMask=vec4(1.0/256.0,1.0/256.0,1.0/256.0,0.0);vec4 rgbaDepth=fract(depth*bitShift);rgbaDepth-=rgbaDepth.gbaa*bitMask;return rgbaDepth;}void main(){gl_FragColor=pack(gl_FragCoord.z);}"; // eslint-disable-line

var shadowMapVs = "#define GLSLIFY 1\n#include <common_vert>\n#include <blendShape_input>\n#include <normal_share>\n#include <shadow_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <shadow_vert>\n#include <position_vert>\n}"; // eslint-disable-line

var shadowFs = "#define GLSLIFY 1\n#ifdef O3_SHADOW_MAP_COUNT\nuniform float u_shadowBias[O3_SHADOW_MAP_COUNT];uniform float u_shadowIntensity[O3_SHADOW_MAP_COUNT];uniform float u_shadowRadius[O3_SHADOW_MAP_COUNT];uniform vec2 u_shadowMapSize[O3_SHADOW_MAP_COUNT];uniform sampler2D u_shadowMaps[O3_SHADOW_MAP_COUNT];varying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];const vec4 bitShift=vec4(1.0,1.0/256.0,1.0/(256.0*256.0),1.0/(256.0*256.0*256.0));float unpack(const in vec4 rgbaDepth){return dot(rgbaDepth,bitShift);}float getVisibility(vec4 positionFromLight,const in sampler2D shadowMap,vec2 mapSize,float intensity,float bias,float radius){vec3 shadowCoord=(positionFromLight.xyz/positionFromLight.w)/2.0+0.5;float filterX=step(0.0,shadowCoord.x)*(1.0-step(1.0,shadowCoord.x));float filterY=step(0.0,shadowCoord.y)*(1.0-step(1.0,shadowCoord.y));shadowCoord.z-=bias;vec2 texelSize=vec2(1.0)/mapSize;float visibility=0.0;for(float y=-1.0;y<=1.0;y+=1.0){for(float x=-1.0;x<=1.0;x+=1.0){vec2 uv=shadowCoord.xy+texelSize*vec2(x,y)*radius;vec4 rgbaDepth=texture2D(shadowMap,uv);float depth=unpack(rgbaDepth);visibility+=step(depth,shadowCoord.z)*intensity;}}visibility*=(1.0/9.0);return visibility*filterX*filterY;}\n#endif\nvoid main(){vec4 shadowColor=vec4(1.0,1.0,1.0,1.0);\n#ifdef O3_SHADOW_MAP_COUNT\nfloat visibility=1.0;\n#if (O3_SHADOW_MAP_COUNT == 1)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);\n#elif (O3_SHADOW_MAP_COUNT == 2)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);visibility-=getVisibility(v_PositionFromLight[1],u_shadowMaps[1],u_shadowMapSize[1],u_shadowIntensity[1],u_shadowBias[1],u_shadowRadius[1]);\n#elif (O3_SHADOW_MAP_COUNT == 3)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);visibility-=getVisibility(v_PositionFromLight[1],u_shadowMaps[1],u_shadowMapSize[1],u_shadowIntensity[1],u_shadowBias[1],u_shadowRadius[1]);visibility-=getVisibility(v_PositionFromLight[2],u_shadowMaps[2],u_shadowMapSize[2],u_shadowIntensity[2],u_shadowBias[2],u_shadowRadius[2]);\n#endif\nvisibility=clamp(visibility,0.0,1.0);shadowColor=vec4(visibility,visibility,visibility,1.0);\n#endif\ngl_FragColor=shadowColor;}"; // eslint-disable-line

var skyboxFs = "#define GLSLIFY 1\nuniform samplerCube u_cube;varying vec3 v_cubeUV;void main(){gl_FragColor=textureCube(u_cube,v_cubeUV);}"; // eslint-disable-line

var skyboxVs = "#define GLSLIFY 1\n#include <common_vert>\nuniform mat4 u_mvpNoscale;varying vec3 v_cubeUV;void main(){v_cubeUV=POSITION.xyz;gl_Position=u_mvpNoscale*vec4(POSITION,1.0);gl_Position.z=gl_Position.w;}"; // eslint-disable-line

var spriteMaskFs = "#define GLSLIFY 1\nuniform sampler2D u_maskTexture;uniform float u_maskAlphaCutoff;varying vec2 v_uv;void main(){vec4 color=texture2D(u_maskTexture,v_uv);if(color.a<u_maskAlphaCutoff){discard;}gl_FragColor=color;}"; // eslint-disable-line

var spriteMaskVs = "#define GLSLIFY 1\nuniform mat4 u_VPMat;attribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=u_VPMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}"; // eslint-disable-line

var spriteFs = "#define GLSLIFY 1\n#ifdef USE_CUSTOM_TEXTURE\nuniform sampler2D u_cusTomTexture;\n#else\nuniform sampler2D u_spriteTexture;\n#endif\nvarying vec2 v_uv;varying vec4 v_color;void main(){\n#ifdef USE_CUSTOM_TEXTURE\nvec4 baseColor=texture2D(u_cusTomTexture,v_uv);\n#else\nvec4 baseColor=texture2D(u_spriteTexture,v_uv);\n#endif\ngl_FragColor=baseColor*v_color;}"; // eslint-disable-line

var spriteVs = "#define GLSLIFY 1\n#ifdef USE_MODEL_MATRIX\nuniform mat4 u_MVPMat;\n#else\nuniform mat4 u_VPMat;\n#endif\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;attribute vec4 COLOR_0;varying vec2 v_uv;varying vec4 v_color;void main(){\n#ifdef USE_MODEL_MATRIX\ngl_Position=u_MVPMat*vec4(POSITION,1.0);\n#else\ngl_Position=u_VPMat*vec4(POSITION,1.0);\n#endif\nv_uv=TEXCOORD_0;v_color=COLOR_0;}"; // eslint-disable-line

var unlitFs = "#define GLSLIFY 1\n#include <uv_share>\n#include <fog_share>\nuniform vec4 u_baseColor;uniform float u_alphaCutoff;\n#ifdef O3_BASE_TEXTURE\nuniform sampler2D u_baseTexture;\n#endif\nvoid main(){vec4 baseColor=u_baseColor;\n#ifdef O3_BASE_TEXTURE\nbaseColor*=texture2D(u_baseTexture,v_uv);\n#endif\n#ifdef ALPHA_CUTOFF\nif(baseColor.a<u_alphaCutoff){discard;}\n#endif\ngl_FragColor=baseColor;\n#include <fog_frag>\n}"; // eslint-disable-line

var unlitVs = "#define GLSLIFY 1\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <position_vert>\n#include <fog_vert>\n}"; // eslint-disable-line

var backgroundTextureVs = "#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=vec4(POSITION,1.0);v_uv=TEXCOORD_0;}"; // eslint-disable-line

var backgroundTextureFs = "#define GLSLIFY 1\nuniform sampler2D u_baseTexture;varying vec2 v_uv;void main(){gl_FragColor=texture2D(u_baseTexture,v_uv);}"; // eslint-disable-line

/**
 * Internal shader pool.
 * @internal
 */

var ShaderPool = /*#__PURE__*/function () {
  function ShaderPool() {}

  ShaderPool.init = function init() {
    Shader.create("blinn-phong", blinnPhongVs, blinnPhongFs);
    Shader.create("pbr", pbrVs, pbrFs);
    Shader.create("unlit", unlitVs, unlitFs);
    Shader.create("shadow-map", shadowMapVs, shadowMapFs);
    Shader.create("shadow", shadowMapVs, shadowFs);
    Shader.create("skybox", skyboxVs, skyboxFs);
    Shader.create("particle-shader", particleVs, particleFs);
    Shader.create("SpriteMask", spriteMaskVs, spriteMaskFs);
    Shader.create("Sprite", spriteVs, spriteFs);
    Shader.create("background-texture", backgroundTextureVs, backgroundTextureFs);
  };

  return ShaderPool;
}();

/**
 * Shader program pool.
 * @internal
 */
var ShaderProgramPool = /*#__PURE__*/function () {
  function ShaderProgramPool() {
    this._cacheHierarchy = 1;
    this._cacheMap = Object.create(null);
    this._lastQueryMap = void 0;
    this._lastQueryKey = void 0;
  }

  var _proto = ShaderProgramPool.prototype;

  /**
   * Get shader program by macro collection.
   * @param macros - macro collection
   * @returns shader program
   */
  _proto.get = function get(macros) {
    var cacheMap = this._cacheMap;
    var maskLength = macros._length;

    if (maskLength > this._cacheHierarchy) {
      this._resizeCacheMapHierarchy(cacheMap, 0, maskLength);
    }

    var mask = macros._mask;
    var endIndex = macros._length - 1;
    var maxEndIndex = this._cacheHierarchy - 1;

    for (var i = 0; i < maxEndIndex; i++) {
      var subMask = endIndex < i ? 0 : mask[i];
      var subCacheShaders = cacheMap[subMask];
      subCacheShaders || (cacheMap[subMask] = subCacheShaders = Object.create(null));
      cacheMap = subCacheShaders;
    }

    var cacheKey = endIndex < maxEndIndex ? 0 : mask[maxEndIndex];
    var shader = cacheMap[cacheKey];

    if (!shader) {
      this._lastQueryKey = cacheKey;
      this._lastQueryMap = cacheMap;
    }

    return shader;
  }
  /**
   * Cache the shader program.
   *
   * @remarks
   * The method must return an empty value after calling get() to run normally.
   *
   * @param shaderProgram - shader program
   */
  ;

  _proto.cache = function cache(shaderProgram) {
    this._lastQueryMap[this._lastQueryKey] = shaderProgram;
  };

  _proto._resizeCacheMapHierarchy = function _resizeCacheMapHierarchy(cacheMap, hierarchy, resizeLength) {
    // only expand but not shrink.
    var end = this._cacheHierarchy - 1;

    if (hierarchy == end) {
      for (var k in cacheMap) {
        var shader = cacheMap[k];

        for (var i = 0, n = resizeLength - end; i < n; i++) {
          if (i == n - 1) {
            cacheMap[0] = shader;
          } else {
            cacheMap = cacheMap[i == 0 ? k : 0] = Object.create(null);
          }
        }
      }

      this._cacheHierarchy = resizeLength;
    } else {
      for (var _k in cacheMap) {
        this._resizeCacheMapHierarchy(cacheMap[_k], ++hierarchy, resizeLength);
      }
    }
  };

  return ShaderProgramPool;
}();

var ColliderFeature = /*#__PURE__*/function (_SceneFeature) {
  _inheritsLoose(ColliderFeature, _SceneFeature);

  function ColliderFeature() {
    var _this;

    _this = _SceneFeature.call(this) || this;
    _this.colliders = void 0;
    _this.colliders = [];
    return _this;
  }
  /**
   * Add a collider component.
   * @param collider - The collider component to add
   */


  var _proto = ColliderFeature.prototype;

  _proto.attachCollider = function attachCollider(collider) {
    this.colliders.push(collider);
  }
  /**
   * Remove a collider component.
   * @param collider - The collider component to remove
   */
  ;

  _proto.detachCollider = function detachCollider(collider) {
    var index = this.colliders.indexOf(collider);

    if (index != -1) {
      this.colliders.splice(index, 1);
    }
  };

  return ColliderFeature;
}(SceneFeature);

/**
 * Define collider data.
 */
var Collider = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Collider, _Component);

  /**
   * @param {Entity} entity
   */
  function Collider(entity) {
    return _Component.call(this, entity) || this;
  }

  var _proto = Collider.prototype;

  _proto._onEnable = function _onEnable() {
    this.scene.findFeature(ColliderFeature).attachCollider(this);
  };

  _proto._onDisable = function _onDisable() {
    this.scene.findFeature(ColliderFeature).detachCollider(this);
  };

  _proto._updateHitResult = function _updateHitResult(ray, distance, outHit, origin, isWorldRay) {
    if (isWorldRay === void 0) {
      isWorldRay = false;
    }

    ray.getPoint(distance, outHit.point);

    if (!isWorldRay) {
      Vector3.transformCoordinate(outHit.point, this.entity.transform.worldMatrix, outHit.point);
    }

    outHit.distance = Vector3.distance(origin, outHit.point);
    outHit.collider = this;
  };

  _proto._getLocalRay = function _getLocalRay(ray) {
    var worldToLocal = this.entity.getInvModelMatrix();
    var outRay = Collider._ray;
    Vector3.transformCoordinate(ray.origin, worldToLocal, outRay.origin);
    Vector3.transformNormal(ray.direction, worldToLocal, outRay.direction);
    outRay.direction.normalize();
    return outRay;
  }
  /**
   * @internal
   */
  ;

  _proto._raycast = function _raycast(ray, hit) {
    throw "Error: use concrete type instead!";
  };

  return Collider;
}(Component);
Collider._ray = new Ray();

/**
 * Axis Aligned Bound Box (AABB).
 * @extends Collider
 */
var ABoxCollider = /*#__PURE__*/function (_Collider) {
  _inheritsLoose(ABoxCollider, _Collider);

  /**
   * Constructor of ABoxCollider.
   * @param entity - Entity which the box belongs to
   */
  function ABoxCollider(entity) {
    var _this;

    _this = _Collider.call(this, entity) || this;
    _this.boxMin = void 0;
    _this.boxMax = void 0;
    _this._corners = [];
    _this._cornerFlag = false;
    _this.boxMin = new Vector3(-0.5, -0.5, -0.5);
    _this.boxMax = new Vector3(0.5, 0.5, 0.5);
    return _this;
  }
  /**
   * Set box from the minimum point of the box and the maximum point of the box.
   * @param min - The minimum point of the box
   * @param max - The maximum point of the box
   */


  var _proto = ABoxCollider.prototype;

  _proto.setBoxMinMax = function setBoxMinMax(min, max) {
    this.boxMin = min;
    this.boxMax = max;
    this._cornerFlag = true;
  }
  /**
   * Set box from the center point and the size of the bounding box.
   * @param center - The center point
   * @param size - The size of the bounding box
   */
  ;

  _proto.setBoxCenterSize = function setBoxCenterSize(center, size) {
    var halfSize = ABoxCollider._tempVec3;
    Vector3.scale(size, 0.5, halfSize);
    Vector3.add(center, halfSize, this.boxMax);
    Vector3.subtract(center, halfSize, this.boxMin);
    this._cornerFlag = true;
  }
  /**
   * Get the eight corners of this bounding box.
   */
  ;

  _proto.getCorners = function getCorners() {
    if (this._cornerFlag) {
      var minX = this.boxMin.x;
      var minY = this.boxMin.y;
      var minZ = this.boxMin.z;
      var w = this.boxMax.x - minX;
      var h = this.boxMax.y - minY;
      var d = this.boxMax.z - minZ;

      if (this._corners.length === 0) {
        for (var i = 0; i < 8; ++i) {
          this._corners.push(new Vector3());
        }
      }

      this._corners[0].setValue(minX + w, minY + h, minZ + d);

      this._corners[1].setValue(minX, minY + h, minZ + d);

      this._corners[2].setValue(minX, minY, minZ + d);

      this._corners[3].setValue(minX + w, minY, minZ + d);

      this._corners[4].setValue(minX + w, minY + h, minZ);

      this._corners[5].setValue(minX, minY + h, minZ);

      this._corners[6].setValue(minX, minY, minZ);

      this._corners[7].setValue(minX + w, minY, minZ);

      this._cornerFlag = false;
    }

    return this._corners; // if (this._corners.length === 0) {
    //   const minX = this.boxMin.x;
    //   const minY = this.boxMin.y;
    //   const minZ = this.boxMin.z;
    //   const w = this.boxMax.x - minX;
    //   const h = this.boxMax.y - minY;
    //   const d = this.boxMax.z - minZ;
    //   this._corners = [
    //     new Vector3(minX + w, minY + h, minZ + d),
    //     new Vector3(minX, minY + h, minZ + d),
    //     new Vector3(minX, minY, minZ + d),
    //     new Vector3(minX + w, minY, minZ + d),
    //     new Vector3(minX + w, minY + h, minZ),
    //     new Vector3(minX, minY + h, minZ),
    //     new Vector3(minX, minY, minZ),
    //     new Vector3(minX + w, minY, minZ)
    //   ];
    // }
    // return this._corners;
  }
  /**
   * @internal
   */
  ;

  _proto._raycast = function _raycast(ray, hit) {
    var localRay = this._getLocalRay(ray);

    var boundingBox = ABoxCollider._tempBox;
    this.boxMin.cloneTo(boundingBox.min);
    this.boxMax.cloneTo(boundingBox.max);
    var intersect = localRay.intersectBox(boundingBox);

    if (intersect !== -1) {
      this._updateHitResult(localRay, intersect, hit, ray.origin);

      return true;
    } else {
      return false;
    } // end of else

  };

  return ABoxCollider;
}(Collider);
ABoxCollider._tempVec3 = new Vector3();
ABoxCollider._tempBox = new BoundingBox();

/**
 * Represents a plane in three dimensional space.
 */
var PlaneCollider = /*#__PURE__*/function (_Collider) {
  _inheritsLoose(PlaneCollider, _Collider);

  /**
   * Constructor of PlaneCollider.
   * @param entity - Entity which the plane belongs to
   */
  function PlaneCollider(entity) {
    var _this;

    _this = _Collider.call(this, entity) || this;
    /** The point through the plane. */

    _this.planePoint = void 0;
    _this.normal = void 0;
    _this.planePoint = new Vector3();
    /** The normal direction of the plane. */

    _this.normal = new Vector3(0, 1, 0);
    return _this;
  }
  /**
   * Set a plane from point and normal.
   * @param  point - The point through the plane
   * @param  normal - The normal direction of the plane
   */


  var _proto = PlaneCollider.prototype;

  _proto.setPlane = function setPlane(point, normal) {
    this.planePoint = point;
    this.normal = normal;
  }
  /**
   * @internal
   */
  ;

  _proto._raycast = function _raycast(ray, hit) {
    var localRay = this._getLocalRay(ray);

    var boundingPlane = PlaneCollider._tempPlane;
    this.normal.cloneTo(boundingPlane.normal);
    boundingPlane.distance = -Vector3.dot(this.planePoint, boundingPlane.normal);
    var intersect = localRay.intersectPlane(boundingPlane);

    if (intersect !== -1) {
      this._updateHitResult(localRay, intersect, hit, ray.origin);

      return true;
    } else {
      return false;
    } // end of else

  };

  return PlaneCollider;
}(Collider);
PlaneCollider._tempPlane = new Plane();

/**
 * A bounding sphere.
 */
var ASphereCollider = /*#__PURE__*/function (_Collider) {
  _inheritsLoose(ASphereCollider, _Collider);

  /**
   * Constructor of ASphereCollider.
   * @param  entity - Entity which the sphere belongs to
   */
  function ASphereCollider(entity) {
    var _this;

    _this = _Collider.call(this, entity) || this;
    /** The center point of the sphere. */

    _this.center = void 0;
    _this.radius = void 0;
    _this.center = new Vector3();
    /** The radius of the sphere. */

    _this.radius = 1;
    return _this;
  }
  /**
   * Set the center and radius of the sphere.
   * @param center - The center point of the sphere
   * @param radius - The radius of the sphere
   */


  var _proto = ASphereCollider.prototype;

  _proto.setSphere = function setSphere(center, radius) {
    this.center = center;
    this.radius = radius;
  }
  /**
   * @internal
   */
  ;

  _proto._raycast = function _raycast(ray, hit) {
    var transform = this.entity.transform;
    var boundingSphere = ASphereCollider._tempSphere;
    Vector3.transformCoordinate(this.center, transform.worldMatrix, boundingSphere.center);
    var lossyScale = transform.lossyWorldScale;
    boundingSphere.radius = this.radius * Math.max(lossyScale.x, lossyScale.y, lossyScale.z);
    var intersect = ray.intersectSphere(boundingSphere);

    if (intersect !== -1) {
      this._updateHitResult(ray, intersect, hit, ray.origin, true);

      return true;
    } else {
      return false;
    }
  };

  return ASphereCollider;
}(Collider);
ASphereCollider._tempSphere = new BoundingSphere();

var BoxCollider = /*#__PURE__*/function (_ABoxCollider) {
  _inheritsLoose(BoxCollider, _ABoxCollider);

  function BoxCollider(entity) {
    var _this;

    _this = _ABoxCollider.call(this, entity) || this;
    _this._center = new Vector3();
    _this._size = new Vector3();
    _this.isShowCollider = true;
    _this.center = _this.center;
    _this.size = _this.size;
    _this.isShowCollider = _this.isShowCollider;
    return _this;
  }

  _createClass(BoxCollider, [{
    key: "center",
    get: function get() {
      return this._center;
    },
    set: function set(value) {
      this._center = value;
      this.setBoxCenterSize(this._center, this._size);
    }
  }, {
    key: "size",
    get: function get() {
      return this._size;
    },
    set: function set(value) {
      this._size = value;
      this.setBoxCenterSize(this._center, this._size);
    }
  }]);

  return BoxCollider;
}(ABoxCollider);

var SphereCollider = /*#__PURE__*/function (_ASphereCollider) {
  _inheritsLoose(SphereCollider, _ASphereCollider);

  function SphereCollider(entity) {
    var _this;

    _this = _ASphereCollider.call(this, entity) || this;
    _this.__center = new Vector3();
    _this.__radius = 1.0;
    _this.isShowCollider = true;
    _this._center = _this._center;
    _this._radius = _this._radius;
    _this.isShowCollider = _this.isShowCollider;
    return _this;
  }

  _createClass(SphereCollider, [{
    key: "_center",
    get: function get() {
      return this.__center;
    },
    set: function set(value) {
      this.__center = value;
      this.setSphere(this.__center, this.__radius);
    }
  }, {
    key: "_radius",
    get: function get() {
      return this.__radius;
    },
    set: function set(value) {
      this.__radius = value;
      this.setSphere(this.__center, this.__radius);
    }
  }]);

  return SphereCollider;
}(ASphereCollider);

Scene.registerFeature(ColliderFeature); //-- colliders

/**
 * Structure used to get information back from a raycast or a sweep.
 */

var HitResult = function HitResult() {
  this.collider = null;
  this.distance = 0;
  this.point = new Vector3();
  this.normal = new Vector3();
};

/*
 * Manager for physical scenes.
 */

var PhysicsManager = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function PhysicsManager(engine) {
    this._engine = void 0;
    this._engine = engine;
  }
  /**
   * Casts a ray through the Scene and returns the first hit.
   * @param ray - The ray
   * @returns Returns true if the ray intersects with a Collider, otherwise false.
   */


  var _proto = PhysicsManager.prototype;

  _proto.raycast = function raycast(ray, distanceOrResult, layerMaskOrResult, outHitResult) {
    var cf = this._engine.sceneManager.activeScene.findFeature(ColliderFeature);

    var colliders = cf.colliders;
    var hitResult;
    var distance = Number.MAX_VALUE;

    if (typeof distanceOrResult === "number") {
      distance = distanceOrResult;
    } else if (distanceOrResult != undefined) {
      hitResult = distanceOrResult;
    }

    var layerMask = Layer.Everything;

    if (typeof layerMaskOrResult === "number") {
      layerMask = layerMaskOrResult;
    } else if (layerMaskOrResult != undefined) {
      hitResult = layerMaskOrResult;
    }

    if (outHitResult) {
      hitResult = outHitResult;
    }

    var isHit = false;
    var curHit = PhysicsManager._currentHit;

    for (var i = 0, len = colliders.length; i < len; i++) {
      var collider = colliders[i];

      if (!(collider.entity.layer & layerMask)) {
        continue;
      }

      if (collider._raycast(ray, curHit)) {
        isHit = true;

        if (curHit.distance < distance) {
          if (hitResult) {
            curHit.normal.cloneTo(hitResult.normal);
            curHit.point.cloneTo(hitResult.point);
            hitResult.distance = curHit.distance;
            hitResult.collider = curHit.collider;
          } else {
            return true;
          }

          distance = curHit.distance;
        }
      }
    }

    if (!isHit && hitResult) {
      hitResult.collider = null;
      hitResult.distance = 0;
      hitResult.point.setValue(0, 0, 0);
      hitResult.normal.setValue(0, 0, 0);
    }

    return isHit;
  };

  return PhysicsManager;
}();
PhysicsManager._currentHit = new HitResult();

/** TODO: delete */

var engineFeatureManager = new FeatureManager();
ShaderPool.init();
/**
 * Engine.
 */

var Engine = /*#__PURE__*/function (_EventDispatcher) {
  _inheritsLoose(Engine, _EventDispatcher);

  /**
   * Create engine.
   * @param canvas - The canvas to use for rendering
   * @param hardwareRenderer - Graphics API renderer
   */
  function Engine(canvas, hardwareRenderer) {
    var _this;

    _this = _EventDispatcher.call(this, null) || this;
    _this.physicsManager = new PhysicsManager(_assertThisInitialized(_this));
    _this._componentsManager = new ComponentsManager();
    _this._hardwareRenderer = void 0;
    _this._lastRenderState = new RenderState();
    _this._renderElementPool = new ClassPool(RenderElement);
    _this._spriteElementPool = new ClassPool(SpriteElement);
    _this._spriteMaskElementPool = new ClassPool(SpriteMaskElement);
    _this._spriteDefaultMaterial = void 0;
    _this._spriteMaskDefaultMaterial = void 0;
    _this._renderContext = new RenderContext();
    _this._whiteTexture2D = void 0;
    _this._whiteTextureCube = void 0;
    _this._backgroundTextureMaterial = void 0;
    _this._backgroundTextureMesh = void 0;
    _this._renderCount = 0;
    _this._shaderProgramPools = [];
    _this._spriteMaskManager = void 0;
    _this._canvas = void 0;
    _this._resourceManager = new ResourceManager(_assertThisInitialized(_this));
    _this._sceneManager = new SceneManager(_assertThisInitialized(_this));
    _this._vSyncCount = 1;
    _this._targetFrameRate = 60;
    _this._time = new Time();
    _this._isPaused = true;
    _this._requestId = void 0;
    _this._timeoutId = void 0;
    _this._vSyncCounter = 1;
    _this._targetFrameInterval = 1000 / 60;

    _this._animate = function () {
      if (_this._vSyncCount) {
        _this._requestId = requestAnimationFrame(_this._animate);

        if (_this._vSyncCounter++ % _this._vSyncCount === 0) {
          _this.update();

          _this._vSyncCounter = 1;
        }
      } else {
        _this._timeoutId = window.setTimeout(_this._animate, _this._targetFrameInterval);

        _this.update();
      }
    };

    _this.features = [];
    _this._hardwareRenderer = hardwareRenderer;

    _this._hardwareRenderer.init(canvas);

    _this._canvas = canvas; // @todo delete

    engineFeatureManager.addObject(_assertThisInitialized(_this));
    _this._sceneManager.activeScene = new Scene(_assertThisInitialized(_this), "DefaultScene");
    _this._spriteMaskManager = new SpriteMaskManager(_assertThisInitialized(_this));
    _this._spriteDefaultMaterial = _this._createSpriteMaterial();
    _this._spriteMaskDefaultMaterial = _this._createSpriteMaskMaterial();
    var whitePixel = new Uint8Array([255, 255, 255, 255]);
    var whiteTexture2D = new Texture2D(_assertThisInitialized(_this), 1, 1, TextureFormat.R8G8B8A8, false);
    whiteTexture2D.setPixelBuffer(whitePixel);
    whiteTexture2D.isGCIgnored = true;
    var whiteTextureCube = new TextureCubeMap(_assertThisInitialized(_this), 1, TextureFormat.R8G8B8A8, false);
    whiteTextureCube.setPixelBuffer(TextureCubeFace.PositiveX, whitePixel);
    whiteTextureCube.setPixelBuffer(TextureCubeFace.NegativeX, whitePixel);
    whiteTextureCube.setPixelBuffer(TextureCubeFace.PositiveY, whitePixel);
    whiteTextureCube.setPixelBuffer(TextureCubeFace.NegativeY, whitePixel);
    whiteTextureCube.setPixelBuffer(TextureCubeFace.PositiveZ, whitePixel);
    whiteTextureCube.setPixelBuffer(TextureCubeFace.NegativeZ, whitePixel);
    whiteTextureCube.isGCIgnored = true;
    _this._whiteTexture2D = whiteTexture2D;
    _this._whiteTextureCube = whiteTextureCube;
    _this._backgroundTextureMaterial = new Material(_assertThisInitialized(_this), Shader.find("background-texture"));
    _this._backgroundTextureMaterial.isGCIgnored = true;
    _this._backgroundTextureMaterial.renderState.depthState.compareFunction = CompareFunction.LessEqual;
    _this._backgroundTextureMesh = PrimitiveMesh.createPlane(_assertThisInitialized(_this), 2, 2, 1, 1, false);
    _this._backgroundTextureMesh.isGCIgnored = true;
    return _this;
  }
  /**
   * Create an entity.
   * @param name - The name of the entity
   * @returns Entity
   */


  var _proto = Engine.prototype;

  _proto.createEntity = function createEntity(name) {
    return new Entity(this, name);
  }
  /**
   * Pause the engine.
   */
  ;

  _proto.pause = function pause() {
    this._isPaused = true;
    cancelAnimationFrame(this._requestId);
    clearTimeout(this._timeoutId);
  }
  /**
   * Resume the engine.
   */
  ;

  _proto.resume = function resume() {
    if (!this._isPaused) return;
    this._isPaused = false;
    this.time.reset();
    requestAnimationFrame(this._animate);
  }
  /**
   * Update the engine loop manually. If you call engine.run(), you generally don't need to call this function.
   */
  ;

  _proto.update = function update() {
    var time = this._time;
    var deltaTime = time.deltaTime;
    time.tick();

    this._renderElementPool.resetPool();

    this._spriteElementPool.resetPool();

    this._spriteMaskElementPool.resetPool();

    engineFeatureManager.callFeatureMethod(this, "preTick", [this, this._sceneManager._activeScene]);
    var scene = this._sceneManager._activeScene;
    var componentsManager = this._componentsManager;

    if (scene) {
      componentsManager.callScriptOnStart();
      componentsManager.callScriptOnUpdate(deltaTime);
      componentsManager.callAnimationUpdate(deltaTime);
      componentsManager.callScriptOnLateUpdate(deltaTime);

      this._render(scene);
    }

    this._componentsManager.callComponentDestroy();

    engineFeatureManager.callFeatureMethod(this, "postTick", [this, this._sceneManager._activeScene]);
  }
  /**
   * Execution engine loop.
   */
  ;

  _proto.run = function run() {
    // @todo: delete
    engineFeatureManager.callFeatureMethod(this, "preLoad", [this]);
    this.resume();
    this.trigger(new Event("run", this));
  }
  /**
   * Destroy engine.
   */
  ;

  _proto.destroy = function destroy() {
    if (this._sceneManager) {
      this._whiteTexture2D.destroy(true);

      this._whiteTextureCube.destroy(true);

      this.trigger(new Event("shutdown", this));
      engineFeatureManager.callFeatureMethod(this, "shutdown", [this]); // -- cancel animation

      this.pause();
      this._animate = null;

      this._sceneManager._activeScene.destroy();

      this._resourceManager.gc(); // If engine destroy, callComponentDestroy() maybe will not call anymore.


      this._componentsManager.callComponentDestroy();

      this._sceneManager = null;
      this._resourceManager = null;
      this._canvas = null;
      this.features = [];
      this._time = null; // delete mask manager

      this._spriteMaskManager.destroy(); // todo: delete


      engineFeatureManager._objects = [];
      this.removeAllEventListeners();
    }
  }
  /**
   * @internal
   */
  ;

  _proto._getShaderProgramPool = function _getShaderProgramPool(shader) {
    var index = shader._shaderId;
    var shaderProgramPools = this._shaderProgramPools;
    var pool = shaderProgramPools[index];

    if (!pool) {
      var length = index + 1;

      if (length < shaderProgramPools.length) {
        shaderProgramPools.length = length;
      }

      shaderProgramPools[index] = pool = new ShaderProgramPool();
    }

    return pool;
  };

  _proto._render = function _render(scene) {
    var cameras = scene._activeCameras;
    var componentsManager = this._componentsManager;
    var deltaTime = this.time.deltaTime;
    componentsManager.callRendererOnUpdate(deltaTime);

    scene._updateShaderData();

    if (cameras.length > 0) {
      // Sort on priority
      //@ts-ignore
      cameras.sort(function (camera1, camera2) {
        return camera1.priority - camera2.priority;
      });

      for (var i = 0, l = cameras.length; i < l; i++) {
        var camera = cameras[i];
        var cameraEntity = camera.entity;

        if (camera.enabled && cameraEntity.isActiveInHierarchy) {
          componentsManager.callCameraOnBeginRender(camera);
          Scene.sceneFeatureManager.callFeatureMethod(scene, "preRender", [scene, camera]); //TODO: will be removed

          camera.render();
          Scene.sceneFeatureManager.callFeatureMethod(scene, "postRender", [scene, camera]); //TODO: will be removed

          componentsManager.callCameraOnEndRender(camera);
        }
      }
    } else {
      Logger.debug("NO active camera.");
    }
  };

  _proto._createSpriteMaterial = function _createSpriteMaterial() {
    var material = new Material(this, Shader.find("Sprite"));
    var renderState = material.renderState;
    var target = renderState.blendState.targetBlendState;
    target.enabled = true;
    target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
    target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
    target.sourceAlphaBlendFactor = BlendFactor.One;
    target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
    target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
    renderState.depthState.writeEnabled = false;
    renderState.rasterState.cullMode = CullMode.Off;
    material.renderQueueType = RenderQueueType.Transparent;
    material.isGCIgnored = true;
    return material;
  };

  _proto._createSpriteMaskMaterial = function _createSpriteMaskMaterial() {
    var material = new Material(this, Shader.find("SpriteMask"));
    var renderState = material.renderState;
    renderState.blendState.targetBlendState.colorWriteMask = ColorWriteMask.None;
    renderState.rasterState.cullMode = CullMode.Off;
    renderState.stencilState.enabled = true;
    renderState.depthState.enabled = false;
    material.isGCIgnored = true;
    return material;
  } //-----------------------------------------@deprecated-----------------------------------
  ;

  _proto.findFeature = function findFeature(Feature) {
    return engineFeatureManager.findFeature(this, Feature);
  };

  Engine.registerFeature = function registerFeature(Feature) {
    engineFeatureManager.registerFeature(Feature);
  };

  _createClass(Engine, [{
    key: "canvas",
    get:
    /** Physics manager of Engine. */

    /* @internal */

    /* @internal */

    /* @internal */

    /* @internal */

    /* @internal */

    /* @internal */

    /** @internal */

    /**
     * The canvas to use for rendering.
     */
    function get() {
      return this._canvas;
    }
    /**
     * Get the resource manager.
     */

  }, {
    key: "resourceManager",
    get: function get() {
      return this._resourceManager;
    }
    /**
     * Get the scene manager.
     */

  }, {
    key: "sceneManager",
    get: function get() {
      return this._sceneManager;
    }
    /**
     * Get the Time class.
     */

  }, {
    key: "time",
    get: function get() {
      return this._time;
    }
    /**
     * Whether the engine is paused.
     */

  }, {
    key: "isPaused",
    get: function get() {
      return this._isPaused;
    }
    /**
     * The number of vertical synchronization means the number of vertical blanking for one frame.
     * @remarks 0 means that the vertical synchronization is turned off.
     */

  }, {
    key: "vSyncCount",
    get: function get() {
      return this._vSyncCount;
    },
    set: function set(value) {
      this._vSyncCount = Math.max(0, Math.floor(value));
    }
    /**
     * Set the target frame rate you want to achieve.
     * @remarks
     * It only takes effect when vSyncCount = 0 (ie, vertical synchronization is turned off).
     * The larger the value, the higher the target frame rate, Number.POSITIVE_INFINITY represents the infinite target frame rate.
     */

  }, {
    key: "targetFrameRate",
    get: function get() {
      return this._targetFrameRate;
    },
    set: function set(value) {
      value = Math.max(0.000001, value);
      this._targetFrameRate = value;
      this._targetFrameInterval = 1000 / value;
    }
  }]);

  return Engine;
}(EventDispatcher);

/**
 * System info.
 */
var SystemInfo = /*#__PURE__*/function () {
  function SystemInfo() {}

  /**
   * @internal
   */
  SystemInfo._isIos = function _isIos() {
    if (!window) {
      return false;
    }

    var ua = window.navigator.userAgent.toLocaleLowerCase();
    return /iphone|ipad|ipod/.test(ua);
  };

  _createClass(SystemInfo, null, [{
    key: "devicePixelRatio",
    get:
    /**
     * The pixel ratio of the device.
     */
    function get() {
      return window.devicePixelRatio;
    }
  }]);

  return SystemInfo;
}();

/**
 * Engine feature plug-in.
 * @deprecated
 */
var EngineFeature = /*#__PURE__*/function () {
  function EngineFeature() {}

  var _proto = EngineFeature.prototype;

  /**
   * Callback before the engine main loop runs,used to load resource.
   * @param engine - Engine
   */
  _proto.preLoad = function preLoad(engine) {}
  /**
   * Callback before every engine tick.
   * @param engine - Engine
   * @param currentScene - Scene
   */
  ;

  _proto.preTick = function preTick(engine, currentScene) {}
  /**
   * Callback after every engine tick.
   * @param  engine - Engine
   */
  ;

  _proto.postTick = function postTick(engine, currentScene) {}
  /**
   * Callback after the engine is destroyed.
   * @param engine - Engine
   */
  ;

  _proto.shutdown = function shutdown(engine) {};

  return EngineFeature;
}();

var _class$3, _descriptor$3, _descriptor2$3, _descriptor3$3, _descriptor4$3, _descriptor5$3, _descriptor6$3, _descriptor7$3;

/**
 * Script class, used for logic writing.
 */
var Script = (_class$3 = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Script, _Component);

  function Script() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;

    _initializerDefineProperty(_this, "_started", _descriptor$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_onStartIndex", _descriptor2$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_onUpdateIndex", _descriptor3$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_onLateUpdateIndex", _descriptor4$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_onPreRenderIndex", _descriptor5$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_onPostRenderIndex", _descriptor6$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_entityCacheIndex", _descriptor7$3, _assertThisInitialized(_this));

    return _this;
  }

  var _proto = Script.prototype;

  /**
   * Called when be enabled first time, only once.
   */
  _proto.onAwake = function onAwake() {}
  /**
   * Called when be enabled.
   */
  ;

  _proto.onEnable = function onEnable() {}
  /**
   * Called before the frame-level loop start for the first time, only once.
   */
  ;

  _proto.onStart = function onStart() {}
  /**
   * The main loop, called frame by frame.
   * @param deltaTime - The deltaTime when the script update.
   */
  ;

  _proto.onUpdate = function onUpdate(deltaTime) {}
  /**
   * Called after the onUpdate finished, called frame by frame.
   * @param deltaTime - The deltaTime when the script update.
   */
  ;

  _proto.onLateUpdate = function onLateUpdate(deltaTime) {}
  /**
   * Called before camera rendering, called per camera.
   * @param camera - Current camera.
   */
  ;

  _proto.onBeginRender = function onBeginRender(camera) {}
  /**
   * Called after camera rendering, called per camera.
   * @param camera - Current camera.
   */
  ;

  _proto.onEndRender = function onEndRender(camera) {}
  /**
   * Called when the collision enter.
   * @param other Collider
   */
  ;

  _proto.onTriggerEnter = function onTriggerEnter(other) {}
  /**
   * Called when the collision stay.
   * @remarks onTriggerStay is called every frame while the collision stay.
   * @param other Collider
   */
  ;

  _proto.onTriggerStay = function onTriggerStay(other) {}
  /**
   * Called when the collision exit.
   * @param other Collider
   */
  ;

  _proto.onTriggerExit = function onTriggerExit(other) {}
  /**
   * Called when the pointer is down while over the Collider.
   */
  ;

  _proto.onPointerDown = function onPointerDown() {}
  /**
   * Called when the pointer is up while over the Collider.
   */
  ;

  _proto.onPointerUp = function onPointerUp() {}
  /**
   * Called when the pointer is down and up with the same collider.
   */
  ;

  _proto.onPointerClick = function onPointerClick() {}
  /**
   * Called when the pointer is enters the Collider.
   */
  ;

  _proto.onPointerEnter = function onPointerEnter() {}
  /**
   * Called when the pointer is no longer over the Collider.
   */
  ;

  _proto.onPointerExit = function onPointerExit() {}
  /**
   * Called when the pointer is down while over the Collider and is still holding down.
   * @remarks onPointerDrag is called every frame while the pointer is down.
   */
  ;

  _proto.onPointerDrag = function onPointerDrag() {}
  /**
   * Called when be disabled.
   */
  ;

  _proto.onDisable = function onDisable() {}
  /**
   * Called at the end of the destroyed frame.
   */
  ;

  _proto.onDestroy = function onDestroy() {}
  /**
   * @internal
   * @inheritDoc
   * @override
   */
  ;

  _proto._onAwake = function _onAwake() {
    this.onAwake();
  }
  /**
   * @internal
   * @inheritDoc
   * @override
   */
  ;

  _proto._onEnable = function _onEnable() {
    var componentsManager = this.engine._componentsManager;
    var prototype = Script.prototype;

    if (!this._started) {
      componentsManager.addOnStartScript(this);
    }

    if (this.onUpdate !== prototype.onUpdate) {
      componentsManager.addOnUpdateScript(this);
    }

    if (this.onLateUpdate !== prototype.onLateUpdate) {
      componentsManager.addOnLateUpdateScript(this);
    }

    this._entity._addScript(this);

    this.onEnable();
  }
  /**
   * @internal
   * @inheritDoc
   * @override
   */
  ;

  _proto._onDisable = function _onDisable() {
    var componentsManager = this.engine._componentsManager; // Use "xxIndex" is more safe.
    // When call onDisable it maybe it still not in script queue,for example write "entity.isActive = false" in onWake().

    if (this._onStartIndex !== -1) {
      componentsManager.removeOnStartScript(this);
    }

    if (this._onUpdateIndex !== -1) {
      componentsManager.removeOnUpdateScript(this);
    }

    if (this._onLateUpdateIndex !== -1) {
      componentsManager.removeOnLateUpdateScript(this);
    }

    if (this._entityCacheIndex !== -1) {
      this._entity._removeScript(this);
    }

    this.onDisable();
  }
  /**
   * @internal
   * @inheritDoc
   * @override
   */
  ;

  _proto._onDestroy = function _onDestroy() {
    this.engine._componentsManager.addDestroyComponent(this);
  };

  return Script;
}(Component), (_descriptor$3 = _applyDecoratedDescriptor(_class$3.prototype, "_started", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor2$3 = _applyDecoratedDescriptor(_class$3.prototype, "_onStartIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor3$3 = _applyDecoratedDescriptor(_class$3.prototype, "_onUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor4$3 = _applyDecoratedDescriptor(_class$3.prototype, "_onLateUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor5$3 = _applyDecoratedDescriptor(_class$3.prototype, "_onPreRenderIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor6$3 = _applyDecoratedDescriptor(_class$3.prototype, "_onPostRenderIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor7$3 = _applyDecoratedDescriptor(_class$3.prototype, "_entityCacheIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
})), _class$3);

/**
 * Camera clear flags enumeration.
 */
var CameraClearFlags;

(function (CameraClearFlags) {
  CameraClearFlags[CameraClearFlags["DepthColor"] = 0] = "DepthColor";
  CameraClearFlags[CameraClearFlags["Depth"] = 1] = "Depth";
  CameraClearFlags[CameraClearFlags["None"] = 2] = "None";
})(CameraClearFlags || (CameraClearFlags = {}));

var passNum = 0;
/**
 * RenderPass.
 */

var RenderPass = /*#__PURE__*/function () {
  /**
   * Create a RenderPass.
   * @param name - Pass name
   * @param priority - Priority, less than 0 before the default pass, greater than 0 after the default pass
   * @param renderTarget - The specified Render Target
   * @param replaceMaterial -  Replaced material
   * @param mask - Perform bit and operations with Entity.Layer to filter the objects that this Pass needs to render
   */
  function RenderPass(name, priority, renderTarget, replaceMaterial, mask) {
    if (name === void 0) {
      name = "RENDER_PASS" + passNum++;
    }

    if (priority === void 0) {
      priority = 0;
    }

    if (renderTarget === void 0) {
      renderTarget = null;
    }

    if (replaceMaterial === void 0) {
      replaceMaterial = null;
    }

    if (mask === void 0) {
      mask = null;
    }

    this.name = void 0;
    this.enabled = void 0;
    this.priority = void 0;
    this.renderTarget = void 0;
    this.replaceMaterial = void 0;
    this.mask = void 0;
    this.renderOverride = void 0;
    this.clearFlags = void 0;
    this.clearColor = void 0;
    this.name = name;
    this.enabled = true;
    this.priority = priority;
    this.renderTarget = renderTarget;
    this.replaceMaterial = replaceMaterial;
    this.mask = mask || Layer.Everything;
    this.renderOverride = false; // If renderOverride is set to true, you need to implement the render method
  }
  /**
   * Rendering callback, will be executed if renderOverride is set to true.
   * @param camera - Camera
   * @param opaqueQueue - Opaque queue
   * @param alphaTestQueue - Alpha test queue
   * @param transparentQueue - Transparent queue
   */


  var _proto = RenderPass.prototype;

  _proto.render = function render(camera, opaqueQueue, alphaTestQueue, transparentQueue) {}
  /**
   * Post rendering callback.
   * @param camera - Camera
   * @param opaqueQueue - Opaque queue
   * @param alphaTestQueue - Alpha test queue
   * @param transparentQueue - Transparent queue
   */
  ;

  _proto.preRender = function preRender(camera, opaqueQueue, alphaTestQueue, transparentQueue) {}
  /**
   * Post rendering callback.
   * @param camera - Camera
   * @param opaqueQueue - Opaque queue
   * @param alphaTestQueue - Alpha test queue
   * @param transparentQueue - Transparent queue
   */
  ;

  _proto.postRender = function postRender(camera, opaqueQueue, alphaTestQueue, transparentQueue) {};

  return RenderPass;
}();

/**
 * @internal
 */
var SpriteBatcher = /*#__PURE__*/function (_Basic2DBatcher) {
  _inheritsLoose(SpriteBatcher, _Basic2DBatcher);

  function SpriteBatcher() {
    return _Basic2DBatcher.apply(this, arguments) || this;
  }

  var _proto = SpriteBatcher.prototype;

  _proto.createVertexElements = function createVertexElements(vertexElements) {
    vertexElements[0] = new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0);
    vertexElements[1] = new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0);
    vertexElements[2] = new VertexElement("COLOR_0", 20, VertexElementFormat.Vector4, 0);
    return 36;
  };

  _proto.canBatch = function canBatch(preElement, curElement) {
    var preRenderer = preElement.component;
    var curRenderer = curElement.component; // Compare mask

    if (!this.checkBatchWithMask(preRenderer, curRenderer)) {
      return false;
    } // Compare renderer property


    var textureProperty = SpriteBatcher._textureProperty;

    if (preRenderer.shaderData.getTexture(textureProperty) !== curRenderer.shaderData.getTexture(textureProperty)) {
      return false;
    } // Compare material


    return preElement.material === curElement.material;
  };

  _proto.checkBatchWithMask = function checkBatchWithMask(left, right) {
    var leftMaskInteraction = left.maskInteraction;

    if (leftMaskInteraction !== right.maskInteraction) {
      return false;
    }

    if (leftMaskInteraction === SpriteMaskInteraction.None) {
      return true;
    }

    return left.maskLayer === right.maskLayer;
  };

  _proto.updateVertices = function updateVertices(element, vertices, vertexIndex) {
    var positions = element.positions,
        uv = element.uv,
        color = element.color;
    var verticesNum = positions.length;

    for (var i = 0; i < verticesNum; i++) {
      var curPos = positions[i];
      var curUV = uv[i];
      vertices[vertexIndex++] = curPos.x;
      vertices[vertexIndex++] = curPos.y;
      vertices[vertexIndex++] = curPos.z;
      vertices[vertexIndex++] = curUV.x;
      vertices[vertexIndex++] = curUV.y;
      vertices[vertexIndex++] = color.r;
      vertices[vertexIndex++] = color.g;
      vertices[vertexIndex++] = color.b;
      vertices[vertexIndex++] = color.a;
    }

    return vertexIndex;
  };

  _proto.drawBatches = function drawBatches(engine) {
    var mesh = this._meshes[this._flushId];
    var subMeshes = mesh.subMeshes;
    var batchedQueue = this._batchedQueue;
    var maskManager = engine._spriteMaskManager;

    for (var i = 0, len = subMeshes.length; i < len; i++) {
      var subMesh = subMeshes[i];
      var spriteElement = batchedQueue[i];

      if (!subMesh || !spriteElement) {
        return;
      }

      var renderer = spriteElement.component;
      var camera = spriteElement.camera;
      var material = spriteElement.material;
      maskManager.preRender(camera, renderer);
      var compileMacros = Shader._compileMacros; // union render global macro and material self macro.

      ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, material.shaderData._macroCollection, compileMacros);

      var program = material.shader._getShaderProgram(engine, compileMacros);

      if (!program.isValid) {
        return;
      }

      program.bind();
      program.groupingOtherUniformBlock();
      program.uploadAll(program.sceneUniformBlock, camera.scene.shaderData);
      program.uploadAll(program.cameraUniformBlock, camera.shaderData);
      program.uploadAll(program.rendererUniformBlock, renderer.shaderData);
      program.uploadAll(program.materialUniformBlock, material.shaderData);

      material.renderState._apply(engine);

      engine._hardwareRenderer.drawPrimitive(mesh, subMesh, program);

      maskManager.postRender(renderer);
    }
  };

  _proto.destroy = function destroy() {
    this._batchedQueue = null;
    var meshes = this._meshes,
        vertexBuffers = this._vertexBuffers,
        indiceBuffers = this._indiceBuffers;

    for (var i = 0, n = meshes.length; i < n; ++i) {
      meshes[i].destroy();
    }

    this._meshes = null;

    for (var _i = 0, _n = vertexBuffers.length; _i < _n; ++_i) {
      vertexBuffers[_i].destroy();
    }

    this._vertexBuffers = null;

    for (var _i2 = 0, _n2 = indiceBuffers.length; _i2 < _n2; ++_i2) {
      indiceBuffers[_i2].destroy();
    }

    this._indiceBuffers = null;
  };

  return SpriteBatcher;
}(Basic2DBatcher);
SpriteBatcher._textureProperty = Shader.getPropertyByName("u_spriteTexture");

/**
 * Render queue.
 */
var RenderQueue = /*#__PURE__*/function () {
  /**
   * @internal
   */
  RenderQueue._compareFromNearToFar = function _compareFromNearToFar(a, b) {
    return a.material.renderQueueType - b.material.renderQueueType || a.component._distanceForSort - b.component._distanceForSort || b.component._renderSortId - a.component._renderSortId;
  }
  /**
   * @internal
   */
  ;

  RenderQueue._compareFromFarToNear = function _compareFromFarToNear(a, b) {
    return a.material.renderQueueType - b.material.renderQueueType || b.component._distanceForSort - a.component._distanceForSort || b.component._renderSortId - a.component._renderSortId;
  };

  function RenderQueue(engine) {
    this.items = [];
    this._spriteBatcher = void 0;
    this._spriteBatcher = new SpriteBatcher(engine);
  }
  /**
   * Push a render element.
   */


  var _proto = RenderQueue.prototype;

  _proto.pushPrimitive = function pushPrimitive(element) {
    this.items.push(element);
  };

  _proto.render = function render(camera, replaceMaterial, mask) {
    var items = this.items;

    if (items.length === 0) {
      return;
    }

    var engine = camera.engine,
        scene = camera.scene;
    var renderCount = engine._renderCount;
    var rhi = engine._hardwareRenderer;
    var sceneData = scene.shaderData;
    var cameraData = camera.shaderData;

    for (var i = 0, n = items.length; i < n; i++) {
      var item = items[i];
      var renderPassFlag = item.component.entity.layer;

      if (!(renderPassFlag & mask)) {
        continue;
      }

      if (!!item.mesh) {
        this._spriteBatcher.flush(engine);

        var compileMacros = Shader._compileMacros;
        var element = item;
        var renderer = element.component;
        var material = replaceMaterial ? replaceMaterial : element.material;
        var rendererData = renderer.shaderData;
        var materialData = material.shaderData; // @todo: temporary solution

        material._preRender(element); // union render global macro and material self macro.


        ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, materialData._macroCollection, compileMacros);

        var program = material.shader._getShaderProgram(engine, compileMacros);

        if (!program.isValid) {
          continue;
        }

        var switchProgram = program.bind();
        var switchRenderCount = renderCount !== program._uploadRenderCount;

        if (switchRenderCount) {
          program.groupingOtherUniformBlock();
          program.uploadAll(program.sceneUniformBlock, sceneData);
          program.uploadAll(program.cameraUniformBlock, cameraData);
          program.uploadAll(program.rendererUniformBlock, rendererData);
          program.uploadAll(program.materialUniformBlock, materialData); // Ungroup textures should upload default value, texture uint maybe change by logic of texture bind.

          program.uploadUngroupTextures();
          program._uploadCamera = camera;
          program._uploadRenderer = renderer;
          program._uploadMaterial = material;
          program._uploadRenderCount = renderCount;
        } else {
          if (program._uploadCamera !== camera) {
            program.uploadAll(program.cameraUniformBlock, cameraData);
            program._uploadCamera = camera;
          } else if (switchProgram) {
            program.uploadTextures(program.cameraUniformBlock, cameraData);
          }

          if (program._uploadRenderer !== renderer) {
            program.uploadAll(program.rendererUniformBlock, rendererData);
            program._uploadRenderer = renderer;
          } else if (switchProgram) {
            program.uploadTextures(program.rendererUniformBlock, rendererData);
          }

          if (program._uploadMaterial !== material) {
            program.uploadAll(program.materialUniformBlock, materialData);
            program._uploadMaterial = material;
          } else if (switchProgram) {
            program.uploadTextures(program.materialUniformBlock, materialData);
          } // We only consider switchProgram case, because ungroup texture's value is always default.


          if (switchProgram) {
            program.uploadUngroupTextures();
          }
        }

        material.renderState._apply(camera.engine);

        rhi.drawPrimitive(element.mesh, element.subMesh, program);
      } else {
        var spriteElement = item;

        this._spriteBatcher.drawElement(spriteElement);
      }
    }

    this._spriteBatcher.flush(engine);
  }
  /**
   * Clear collection.
   */
  ;

  _proto.clear = function clear() {
    this.items.length = 0;

    this._spriteBatcher.clear();
  }
  /**
   * Destroy internal resources.
   */
  ;

  _proto.destroy = function destroy() {
    this._spriteBatcher.destroy();

    this._spriteBatcher = null;
  }
  /**
   * Sort the elements.
   */
  ;

  _proto.sort = function sort(compareFunc) {
    this._quickSort(this.items, 0, this.items.length, compareFunc);
  }
  /**
   * @remarks
   * Modified based on v8.
   * https://github.com/v8/v8/blob/7.2-lkgr/src/js/array.js
   */
  ;

  _proto._quickSort = function _quickSort(a, from, to, compareFunc) {
    while (true) {
      // Insertion sort is faster for short arrays.
      if (to - from <= 10) {
        this._insertionSort(a, from, to, compareFunc);

        return;
      }

      var third_index = from + to >> 1; // Find a pivot as the median of first, last and middle element.

      var v0 = a[from];
      var v1 = a[to - 1];
      var v2 = a[third_index];
      var c01 = compareFunc(v0, v1);

      if (c01 > 0) {
        // v1 < v0, so swap them.
        var tmp = v0;
        v0 = v1;
        v1 = tmp;
      } // v0 <= v1.


      var c02 = compareFunc(v0, v2);

      if (c02 >= 0) {
        // v2 <= v0 <= v1.
        var _tmp = v0;
        v0 = v2;
        v2 = v1;
        v1 = _tmp;
      } else {
        // v0 <= v1 && v0 < v2
        var c12 = compareFunc(v1, v2);

        if (c12 > 0) {
          // v0 <= v2 < v1
          var _tmp2 = v1;
          v1 = v2;
          v2 = _tmp2;
        }
      } // v0 <= v1 <= v2


      a[from] = v0;
      a[to - 1] = v2;
      var pivot = v1;
      var low_end = from + 1; // Upper bound of elements lower than pivot.

      var high_start = to - 1; // Lower bound of elements greater than pivot.

      a[third_index] = a[low_end];
      a[low_end] = pivot; // From low_end to i are elements equal to pivot.
      // From i to high_start are elements that haven't been compared yet.

      partition: for (var i = low_end + 1; i < high_start; i++) {
        var element = a[i];
        var order = compareFunc(element, pivot);

        if (order < 0) {
          a[i] = a[low_end];
          a[low_end] = element;
          low_end++;
        } else if (order > 0) {
          do {
            high_start--;
            if (high_start == i) break partition;
            var top_elem = a[high_start];
            order = compareFunc(top_elem, pivot);
          } while (order > 0);

          a[i] = a[high_start];
          a[high_start] = element;

          if (order < 0) {
            element = a[i];
            a[i] = a[low_end];
            a[low_end] = element;
            low_end++;
          }
        }
      }

      if (to - high_start < low_end - from) {
        this._quickSort(a, high_start, to, compareFunc);

        to = low_end;
      } else {
        this._quickSort(a, from, low_end, compareFunc);

        from = high_start;
      }
    }
  };

  _proto._insertionSort = function _insertionSort(a, from, to, compareFunc) {
    for (var i = from + 1; i < to; i++) {
      var j = void 0;
      var element = a[i];

      for (j = i - 1; j >= from; j--) {
        var tmp = a[j];
        var order = compareFunc(tmp, element);

        if (order > 0) {
          a[j + 1] = tmp;
        } else {
          break;
        }
      }

      a[j + 1] = element;
    }
  };

  return RenderQueue;
}();

/**
 * Basic render pipeline.
 */
var BasicRenderPipeline = /*#__PURE__*/function () {
  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /**
   * Create a basic render pipeline.
   * @param camera - Camera
   */
  function BasicRenderPipeline(camera) {
    this._opaqueQueue = void 0;
    this._transparentQueue = void 0;
    this._alphaTestQueue = void 0;
    this._allSpriteMasks = new DisorderedArray();
    this._camera = void 0;
    this._defaultPass = void 0;
    this._renderPassArray = void 0;
    this._lastCanvasSize = new Vector2();
    this._camera = camera;
    var engine = camera.engine;
    this._opaqueQueue = new RenderQueue(engine);
    this._alphaTestQueue = new RenderQueue(engine);
    this._transparentQueue = new RenderQueue(engine);
    this._renderPassArray = [];
    this._defaultPass = new RenderPass("default", 0, null, null, 0);
    this.addRenderPass(this._defaultPass);
  }
  /**
   * Default render pass.
   */


  var _proto = BasicRenderPipeline.prototype;

  /**
   * Add render pass.
   * @param nameOrPass - The name of this Pass or RenderPass object. When it is a name, the following parameters need to be provided
   * @param priority - Priority, less than 0 before the default pass, greater than 0 after the default pass
   * @param renderTarget - The specified Render Target
   * @param replaceMaterial -  Replaced material
   * @param mask - Perform bit and operations with Entity.Layer to filter the objects that this Pass needs to render
   */
  _proto.addRenderPass = function addRenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask) {
    if (priority === void 0) {
      priority = null;
    }

    if (renderTarget === void 0) {
      renderTarget = null;
    }

    if (replaceMaterial === void 0) {
      replaceMaterial = null;
    }

    if (mask === void 0) {
      mask = null;
    }

    if (typeof nameOrPass === "string") {
      var renderPass = new RenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask);

      this._renderPassArray.push(renderPass);
    } else if (nameOrPass instanceof RenderPass) {
      this._renderPassArray.push(nameOrPass);
    }

    this._renderPassArray.sort(function (p1, p2) {
      return p1.priority - p2.priority;
    });
  }
  /**
   * Remove render pass by name or render pass object.
   * @param nameOrPass - Render pass name or render pass object
   */
  ;

  _proto.removeRenderPass = function removeRenderPass(nameOrPass) {
    var pass;
    if (typeof nameOrPass === "string") pass = this.getRenderPass(nameOrPass);else if (nameOrPass instanceof RenderPass) pass = nameOrPass;

    if (pass) {
      var idx = this._renderPassArray.indexOf(pass);

      this._renderPassArray.splice(idx, 1);
    }
  }
  /**
   * Get render pass by name.
   * @param  name - Render pass name
   */
  ;

  _proto.getRenderPass = function getRenderPass(name) {
    for (var i = 0, len = this._renderPassArray.length; i < len; i++) {
      var pass = this._renderPassArray[i];
      if (pass.name === name) return pass;
    }

    return null;
  }
  /**
   * Destroy internal resources.
   */
  ;

  _proto.destroy = function destroy() {
    this._opaqueQueue.destroy();

    this._alphaTestQueue.destroy();

    this._transparentQueue.destroy();

    this._allSpriteMasks = null;
    this._renderPassArray = null;
    this._defaultPass = null;
    this._camera = null;
  }
  /**
   * Perform scene rendering.
   * @param context - Render context
   * @param cubeFace - Render surface of cube texture
   */
  ;

  _proto.render = function render(context, cubeFace) {
    var camera = this._camera;
    var opaqueQueue = this._opaqueQueue;
    var alphaTestQueue = this._alphaTestQueue;
    var transparentQueue = this._transparentQueue;

    camera.engine._spriteMaskManager.clear();

    opaqueQueue.clear();
    alphaTestQueue.clear();
    transparentQueue.clear();
    this._allSpriteMasks.length = 0;

    camera.engine._componentsManager.callRender(context);

    opaqueQueue.sort(RenderQueue._compareFromNearToFar);
    alphaTestQueue.sort(RenderQueue._compareFromNearToFar);
    transparentQueue.sort(RenderQueue._compareFromFarToNear);

    for (var i = 0, len = this._renderPassArray.length; i < len; i++) {
      this._drawRenderPass(this._renderPassArray[i], camera, cubeFace);
    }
  };

  _proto._drawRenderPass = function _drawRenderPass(pass, camera, cubeFace) {
    pass.preRender(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);

    if (pass.enabled) {
      var _pass$clearFlags, _pass$clearColor;

      var engine = camera.engine,
          scene = camera.scene;
      var background = scene.background;
      var rhi = engine._hardwareRenderer;
      var renderTarget = camera.renderTarget || pass.renderTarget;
      rhi.activeRenderTarget(renderTarget, camera);
      renderTarget === null || renderTarget === void 0 ? void 0 : renderTarget._setRenderTargetFace(cubeFace);
      var clearFlags = (_pass$clearFlags = pass.clearFlags) != null ? _pass$clearFlags : camera.clearFlags;
      var color = (_pass$clearColor = pass.clearColor) != null ? _pass$clearColor : background.solidColor;

      if (clearFlags !== CameraClearFlags.None) {
        rhi.clearRenderTarget(camera.engine, clearFlags, color);
      }

      if (pass.renderOverride) {
        pass.render(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
      } else {
        this._opaqueQueue.render(camera, pass.replaceMaterial, pass.mask);

        this._alphaTestQueue.render(camera, pass.replaceMaterial, pass.mask);

        if (background.mode === BackgroundMode.Sky) {
          this._drawSky(engine, camera, background.sky);
        } else if (background.mode === BackgroundMode.Texture && background.texture) {
          this._drawBackgroundTexture(engine, background);
        }

        this._transparentQueue.render(camera, pass.replaceMaterial, pass.mask);
      }

      renderTarget === null || renderTarget === void 0 ? void 0 : renderTarget._blitRenderTarget();
      renderTarget === null || renderTarget === void 0 ? void 0 : renderTarget.generateMipmaps();
    }

    pass.postRender(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
  }
  /**
   * Push a render element to the render queue.
   * @param element - Render element
   */
  ;

  _proto.pushPrimitive = function pushPrimitive(element) {
    var renderQueueType = element.material.renderQueueType;

    if (renderQueueType > RenderQueueType.Transparent + RenderQueueType.AlphaTest >> 1) {
      this._transparentQueue.pushPrimitive(element);
    } else if (renderQueueType > RenderQueueType.AlphaTest + RenderQueueType.Opaque >> 1) {
      this._alphaTestQueue.pushPrimitive(element);
    } else {
      this._opaqueQueue.pushPrimitive(element);
    }
  };

  _proto._drawBackgroundTexture = function _drawBackgroundTexture(engine, background) {
    var rhi = engine._hardwareRenderer;
    var _backgroundTextureMaterial = engine._backgroundTextureMaterial,
        _backgroundTextureMesh = engine._backgroundTextureMesh,
        canvas = engine.canvas;

    if ((this._lastCanvasSize.x !== canvas.width || this._lastCanvasSize.y !== canvas.height) && background._textureFillMode !== BackgroundTextureFillMode.Fill) {
      this._lastCanvasSize.setValue(canvas.width, canvas.height);

      background._resizeBackgroundTexture();
    }

    var program = _backgroundTextureMaterial.shader._getShaderProgram(engine, Shader._compileMacros);

    program.bind();
    program.uploadAll(program.materialUniformBlock, _backgroundTextureMaterial.shaderData);
    program.uploadUngroupTextures();

    _backgroundTextureMaterial.renderState._apply(engine);

    rhi.drawPrimitive(_backgroundTextureMesh, _backgroundTextureMesh.subMesh, program);
  };

  _proto._drawSky = function _drawSky(engine, camera, sky) {
    var material = sky.material,
        mesh = sky.mesh,
        _matrix = sky._matrix;

    if (!material) {
      Logger.warn("The material of sky is not defined.");
      return;
    }

    if (!mesh) {
      Logger.warn("The mesh of sky is not defined.");
      return;
    }

    var rhi = engine._hardwareRenderer;
    var shaderData = material.shaderData,
        shader = material.shader,
        renderState = material.renderState;
    var compileMacros = Shader._compileMacros;
    ShaderMacroCollection.unionCollection(camera._globalShaderMacro, shaderData._macroCollection, compileMacros);
    var viewMatrix = camera.viewMatrix,
        projectionMatrix = camera.projectionMatrix;
    viewMatrix.cloneTo(_matrix);
    var e = _matrix.elements;
    e[12] = e[13] = e[14] = 0;
    Matrix.multiply(projectionMatrix, _matrix, _matrix);
    shaderData.setMatrix("u_mvpNoscale", _matrix);

    var program = shader._getShaderProgram(engine, compileMacros);

    program.bind();
    program.groupingOtherUniformBlock();
    program.uploadAll(program.materialUniformBlock, shaderData);
    program.uploadUngroupTextures();

    renderState._apply(engine);

    rhi.drawPrimitive(mesh, mesh.subMesh, program);
  };

  _createClass(BasicRenderPipeline, [{
    key: "defaultRenderPass",
    get: function get() {
      return this._defaultPass;
    }
  }]);

  return BasicRenderPipeline;
}();

var _dec, _class$2, _class2$2, _descriptor$2, _descriptor2$2, _descriptor3$2, _descriptor4$2, _descriptor5$2, _descriptor6$2, _descriptor7$2, _descriptor8$1, _descriptor9$1, _descriptor10$1, _descriptor11$1, _descriptor12$1, _class3, _temp$2;

var MathTemp = function MathTemp() {};
/**
 * Camera component, as the entrance to the three-dimensional world.
 */


MathTemp.tempMat4 = new Matrix();
MathTemp.tempVec4 = new Vector4();
MathTemp.tempVec3 = new Vector3();
MathTemp.tempVec2 = new Vector2();
var Camera = (_dec = dependencies(Transform), _dec(_class$2 = (_class2$2 = (_temp$2 = _class3 = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Camera, _Component);

  /**
   * Create the Camera component.
   * @param entity - Entity
   */
  function Camera(entity) {
    var _this;

    _this = _Component.call(this, entity) || this;
    _this.shaderData = new ShaderData(ShaderDataGroup.Camera);
    _this.priority = 0;
    _this.enableFrustumCulling = true;
    _this.clearFlags = CameraClearFlags.DepthColor;
    _this.cullingMask = Layer.Everything;
    _this._globalShaderMacro = new ShaderMacroCollection();

    _initializerDefineProperty(_this, "_frustum", _descriptor$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_renderPipeline", _descriptor2$2, _assertThisInitialized(_this));

    _this._isOrthographic = false;
    _this._isProjMatSetting = false;
    _this._nearClipPlane = 0.1;
    _this._farClipPlane = 100;
    _this._fieldOfView = 45;
    _this._orthographicSize = 10;
    _this._isProjectionDirty = true;
    _this._isInvProjMatDirty = true;
    _this._isFrustumProjectDirty = true;
    _this._customAspectRatio = undefined;
    _this._renderTarget = null;

    _initializerDefineProperty(_this, "_frustumViewChangeFlag", _descriptor3$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_transform", _descriptor4$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_isViewMatrixDirty", _descriptor5$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_isInvViewProjDirty", _descriptor6$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_projectionMatrix", _descriptor7$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_viewMatrix", _descriptor8$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_viewport", _descriptor9$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_inverseProjectionMatrix", _descriptor10$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_lastAspectSize", _descriptor11$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_invViewProjMat", _descriptor12$1, _assertThisInitialized(_this));

    var transform = _this.entity.transform;
    _this._transform = transform;
    _this._isViewMatrixDirty = transform.registerWorldChangeFlag();
    _this._isInvViewProjDirty = transform.registerWorldChangeFlag();
    _this._frustumViewChangeFlag = transform.registerWorldChangeFlag();
    _this._renderPipeline = new BasicRenderPipeline(_assertThisInitialized(_this));

    _this.shaderData._addRefCount(1);

    return _this;
  }
  /**
   * Restore the automatic calculation of projection matrix through fieldOfView, nearClipPlane and farClipPlane.
   */


  var _proto = Camera.prototype;

  _proto.resetProjectionMatrix = function resetProjectionMatrix() {
    this._isProjMatSetting = false;

    this._projMatChange();
  }
  /**
   * Restore the automatic calculation of the aspect ratio through the viewport aspect ratio.
   */
  ;

  _proto.resetAspectRatio = function resetAspectRatio() {
    this._customAspectRatio = undefined;

    this._projMatChange();
  }
  /**
   * Transform a point from world space to viewport space.
   * @param point - Point in world space
   * @param out - A point in the viewport space, X and Y are the viewport space coordinates, Z is the viewport depth, the near clipping plane is 0, the far clipping plane is 1, and W is the world unit distance from the camera
   * @returns Point in viewport space
   */
  ;

  _proto.worldToViewportPoint = function worldToViewportPoint(point, out) {
    Matrix.multiply(this.projectionMatrix, this.viewMatrix, MathTemp.tempMat4);
    MathTemp.tempVec4.setValue(point.x, point.y, point.z, 1.0);
    Vector4.transform(MathTemp.tempVec4, MathTemp.tempMat4, MathTemp.tempVec4);
    var w = MathTemp.tempVec4.w;
    var nx = MathTemp.tempVec4.x / w;
    var ny = MathTemp.tempVec4.y / w;
    var nz = MathTemp.tempVec4.z / w; // Transform of coordinate axis.

    out.x = (nx + 1.0) * 0.5;
    out.y = (1.0 - ny) * 0.5;
    out.z = nz;
    out.w = w;
    return out;
  }
  /**
   * Transform a point from viewport space to world space.
   * @param point - Point in viewport space, X and Y are the viewport space coordinates, Z is the viewport depth. The near clipping plane is 0, and the far clipping plane is 1
   * @param out - Point in world space
   * @returns Point in world space
   */
  ;

  _proto.viewportToWorldPoint = function viewportToWorldPoint(point, out) {
    var invViewProjMat = this.invViewProjMat;
    return this._innerViewportToWorldPoint(point, invViewProjMat, out);
  }
  /**
   * Generate a ray by a point in viewport.
   * @param point - Point in viewport space, which is represented by normalization
   * @param out - Ray
   * @returns Ray
   */
  ;

  _proto.viewportPointToRay = function viewportPointToRay(point, out) {
    var clipPoint = MathTemp.tempVec3; // Use the intersection of the near clipping plane as the origin point.

    clipPoint.setValue(point.x, point.y, 0);
    var origin = this.viewportToWorldPoint(clipPoint, out.origin); // Use the intersection of the far clipping plane as the origin point.

    clipPoint.z = 1.0;

    var farPoint = this._innerViewportToWorldPoint(clipPoint, this._invViewProjMat, clipPoint);

    Vector3.subtract(farPoint, origin, out.direction);
    out.direction.normalize();
    return out;
  }
  /**
   * Transform the X and Y coordinates of a point from screen space to viewport space
   * @param point - Point in screen space
   * @param out - Point in viewport space
   * @returns Point in viewport space
   */
  ;

  _proto.screenToViewportPoint = function screenToViewportPoint(point, out) {
    var canvas = this.engine.canvas;
    var viewport = this.viewport;
    out.x = (point.x / canvas.width - viewport.x) / viewport.z;
    out.y = (point.y / canvas.height - viewport.y) / viewport.w;
    return out;
  }
  /**
   * Transform the X and Y coordinates of a point from viewport space to screen space.
   * @param point - Point in viewport space
   * @param out - Point in screen space
   * @returns Point in screen space
   */
  ;

  _proto.viewportToScreenPoint = function viewportToScreenPoint(point, out) {
    var canvas = this.engine.canvas;
    var viewport = this.viewport;
    out.x = (viewport.x + point.x * viewport.z) * canvas.width;
    out.y = (viewport.y + point.y * viewport.w) * canvas.height;
    return out;
  }
  /**
   * Transform a point from world space to screen space.
   * @param point - Point in world space
   * @param out - Point of screen space
   * @returns Point of screen space
   */
  ;

  _proto.worldToScreenPoint = function worldToScreenPoint(point, out) {
    this.worldToViewportPoint(point, out);
    return this.viewportToScreenPoint(out, out);
  }
  /**
   * Transform a point from screen space to world space.
   * @param point - Screen space point
   * @param out - Point in world space
   * @returns Point in world space
   */
  ;

  _proto.screenToWorldPoint = function screenToWorldPoint(point, out) {
    this.screenToViewportPoint(point, out);
    return this.viewportToWorldPoint(out, out);
  }
  /**
   * Generate a ray by a point in screen.
   * @param point - Point in screen space, the unit is pixel
   * @param out - Ray
   * @returns Ray
   */
  ;

  _proto.screenPointToRay = function screenPointToRay(point, out) {
    var viewportPoint = MathTemp.tempVec2;
    this.screenToViewportPoint(point, viewportPoint);
    return this.viewportPointToRay(viewportPoint, out);
  }
  /**
   * Manually call the rendering of the camera.
   * @param cubeFace - Cube rendering surface collection
   */
  ;

  _proto.render = function render(cubeFace) {
    // compute cull frustum.
    var context = this.engine._renderContext;

    context._setContext(this);

    if (this.enableFrustumCulling && (this._frustumViewChangeFlag.flag || this._isFrustumProjectDirty)) {
      this._frustum.calculateFromMatrix(context._viewProjectMatrix);

      this._frustumViewChangeFlag.flag = false;
      this._isFrustumProjectDirty = false;
    }

    this._updateShaderData(context); // union scene and camera macro.


    ShaderMacroCollection.unionCollection(this.scene.shaderData._macroCollection, this.shaderData._macroCollection, this._globalShaderMacro);

    this._renderPipeline.render(context, cubeFace);

    this._engine._renderCount++;
  }
  /**
   * @override
   * @inheritdoc
   */
  ;

  _proto._onActive = function _onActive() {
    this.entity.scene._attachRenderCamera(this);
  }
  /**
   * @override
   * @inheritdoc
   */
  ;

  _proto._onInActive = function _onInActive() {
    this.entity.scene._detachRenderCamera(this);
  }
  /**
   * @override
   * @inheritdoc
   */
  ;

  _proto._onDestroy = function _onDestroy() {
    var _this$_renderPipeline;

    (_this$_renderPipeline = this._renderPipeline) === null || _this$_renderPipeline === void 0 ? void 0 : _this$_renderPipeline.destroy();

    this._isInvViewProjDirty.destroy();

    this._isViewMatrixDirty.destroy();

    this.shaderData._addRefCount(-1);
  };

  _proto._projMatChange = function _projMatChange() {
    this._isFrustumProjectDirty = true;
    this._isProjectionDirty = true;
    this._isInvProjMatDirty = true;
    this._isInvViewProjDirty.flag = true;
  };

  _proto._innerViewportToWorldPoint = function _innerViewportToWorldPoint(point, invViewProjMat, out) {
    // Depth is a normalized value, 0 is nearPlane, 1 is farClipPlane.
    var depth = point.z * 2 - 1; // Transform to clipping space matrix

    var clipPoint = MathTemp.tempVec4;
    clipPoint.setValue(point.x * 2 - 1, 1 - point.y * 2, depth, 1);
    Vector4.transform(clipPoint, invViewProjMat, clipPoint);
    var invW = 1.0 / clipPoint.w;
    out.x = clipPoint.x * invW;
    out.y = clipPoint.y * invW;
    out.z = clipPoint.z * invW;
    return out;
  };

  _proto._updateShaderData = function _updateShaderData(context) {
    var shaderData = this.shaderData;
    shaderData.setMatrix(Camera._viewMatrixProperty, this.viewMatrix);
    shaderData.setMatrix(Camera._projectionMatrixProperty, this.projectionMatrix);
    shaderData.setMatrix(Camera._vpMatrixProperty, context._viewProjectMatrix);
    shaderData.setMatrix(Camera._inverseViewMatrixProperty, this._transform.worldMatrix);
    shaderData.setMatrix(Camera._inverseProjectionMatrixProperty, this.inverseProjectionMatrix);
    shaderData.setVector3(Camera._cameraPositionProperty, this._transform.worldPosition);
  }
  /**
   * @private
   * The inverse matrix of view projection matrix.
   */
  ;

  _createClass(Camera, [{
    key: "nearClipPlane",
    get:
    /** Shader data. */

    /** Rendering priority - A Camera with higher priority will be rendered on top of a camera with lower priority. */

    /** Whether to enable frustum culling, it is enabled by default. */

    /**
     * Determining what to clear when rendering by a Camera.
     * @defaultValue `CameraClearFlags.DepthColor`
     */

    /**
     * Culling mask - which layers the camera renders.
     * @remarks Support bit manipulation, corresponding to Entity's layer.
     */

    /** @internal */

    /** @internal */

    /** @internal */

    /**
     * Near clip plane - the closest point to the camera when rendering occurs.
     */
    function get() {
      return this._nearClipPlane;
    },
    set: function set(value) {
      this._nearClipPlane = value;

      this._projMatChange();
    }
    /**
     * Far clip plane - the furthest point to the camera when rendering occurs.
     */

  }, {
    key: "farClipPlane",
    get: function get() {
      return this._farClipPlane;
    },
    set: function set(value) {
      this._farClipPlane = value;

      this._projMatChange();
    }
    /**
     * The camera's view angle. activating when camera use perspective projection.
     */

  }, {
    key: "fieldOfView",
    get: function get() {
      return this._fieldOfView;
    },
    set: function set(value) {
      this._fieldOfView = value;

      this._projMatChange();
    }
    /**
     * Aspect ratio. The default is automatically calculated by the viewport's aspect ratio. If it is manually set,
     * the manual value will be kept. Call resetAspectRatio() to restore it.
     */

  }, {
    key: "aspectRatio",
    get: function get() {
      var _this$_customAspectRa;

      var canvas = this._entity.engine.canvas;
      return (_this$_customAspectRa = this._customAspectRatio) != null ? _this$_customAspectRa : canvas.width * this._viewport.z / (canvas.height * this._viewport.w);
    },
    set: function set(value) {
      this._customAspectRatio = value;

      this._projMatChange();
    }
    /**
     * Viewport, normalized expression, the upper left corner is (0, 0), and the lower right corner is (1, 1).
     * @remarks Re-assignment is required after modification to ensure that the modification takes effect.
     */

  }, {
    key: "viewport",
    get: function get() {
      return this._viewport;
    },
    set: function set(value) {
      if (value !== this._viewport) {
        value.cloneTo(this._viewport);
      }

      this._projMatChange();
    }
    /**
     * Whether it is orthogonal, the default is false. True will use orthographic projection, false will use perspective projection.
     */

  }, {
    key: "isOrthographic",
    get: function get() {
      return this._isOrthographic;
    },
    set: function set(value) {
      this._isOrthographic = value;

      this._projMatChange();
    }
    /**
     * Half the size of the camera in orthographic mode.
     */

  }, {
    key: "orthographicSize",
    get: function get() {
      return this._orthographicSize;
    },
    set: function set(value) {
      this._orthographicSize = value;

      this._projMatChange();
    }
    /**
     * View matrix.
     */

  }, {
    key: "viewMatrix",
    get: function get() {
      // Remove scale
      if (this._isViewMatrixDirty.flag) {
        this._isViewMatrixDirty.flag = false;
        Matrix.invert(this._transform.worldMatrix, this._viewMatrix);
      }

      return this._viewMatrix;
    }
    /**
     * The projection matrix is â€‹â€‹calculated by the relevant parameters of the camera by default.
     * If it is manually set, the manual value will be maintained. Call resetProjectionMatrix() to restore it.
     */

  }, {
    key: "projectionMatrix",
    get: function get() {
      var canvas = this._entity.engine.canvas;

      if ((!this._isProjectionDirty || this._isProjMatSetting) && this._lastAspectSize.x === canvas.width && this._lastAspectSize.y === canvas.height) {
        return this._projectionMatrix;
      }

      this._isProjectionDirty = false;
      this._lastAspectSize.x = canvas.width;
      this._lastAspectSize.y = canvas.height;
      var aspectRatio = this.aspectRatio;

      if (!this._isOrthographic) {
        Matrix.perspective(MathUtil.degreeToRadian(this._fieldOfView), aspectRatio, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);
      } else {
        var width = this._orthographicSize * aspectRatio;
        var height = this._orthographicSize;
        Matrix.ortho(-width, width, -height, height, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);
      }

      return this._projectionMatrix;
    }
    /**
     * Whether to enable HDR.
     * @todo When render pipeline modification
     */
    ,
    set: function set(value) {
      this._projectionMatrix = value;
      this._isProjMatSetting = true;

      this._projMatChange();
    }
  }, {
    key: "enableHDR",
    get: function get() {
      console.log("not implementation");
      return false;
    },
    set: function set(value) {
      console.log("not implementation");
    }
    /**
     * RenderTarget. After setting, it will be rendered to the renderTarget. If it is empty, it will be rendered to the main canvas.
     */

  }, {
    key: "renderTarget",
    get: function get() {
      return this._renderTarget;
    },
    set: function set(value) {
      this._renderTarget = value;
    }
  }, {
    key: "invViewProjMat",
    get: function get() {
      if (this._isInvViewProjDirty.flag) {
        this._isInvViewProjDirty.flag = false;
        Matrix.multiply(this._transform.worldMatrix, this.inverseProjectionMatrix, this._invViewProjMat);
      }

      return this._invViewProjMat;
    }
    /**
     * @private
     * The inverse of the projection matrix.
     */

  }, {
    key: "inverseProjectionMatrix",
    get: function get() {
      if (this._isInvProjMatDirty) {
        this._isInvProjMatDirty = false;
        Matrix.invert(this.projectionMatrix, this._inverseProjectionMatrix);
      }

      return this._inverseProjectionMatrix;
    }
  }]);

  return Camera;
}(Component), _class3._viewMatrixProperty = Shader.getPropertyByName("u_viewMat"), _class3._projectionMatrixProperty = Shader.getPropertyByName("u_projMat"), _class3._vpMatrixProperty = Shader.getPropertyByName("u_VPMat"), _class3._inverseViewMatrixProperty = Shader.getPropertyByName("u_viewInvMat"), _class3._inverseProjectionMatrixProperty = Shader.getPropertyByName("u_projInvMat"), _class3._cameraPositionProperty = Shader.getPropertyByName("u_cameraPos"), _temp$2), (_descriptor$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_frustum", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new BoundingFrustum();
  }
}), _descriptor2$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_renderPipeline", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_frustumViewChangeFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_transform", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_isViewMatrixDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_isInvViewProjDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor7$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_projectionMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor8$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_viewMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor9$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_viewport", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vector4(0, 0, 1, 1);
  }
}), _descriptor10$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_inverseProjectionMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
}), _descriptor11$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_lastAspectSize", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vector2(0, 0);
  }
}), _descriptor12$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_invViewProjMat", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Matrix();
  }
})), _class2$2)) || _class$2);

var mimeType = {
  json: "json",
  gltf: "json",
  mtl: "json",
  prefab: "json",
  txt: "text",
  bin: "arraybuffer",
  png: "image",
  webp: "image",
  jpg: "image"
};
var defaultRetryCount = 4;
var defaultTimeout = 15000;
var defaultInterval = 500;

/**
 * Web request.
 * @param url - The link
 * @param config - Load configuration
 */
function request(url, config) {
  if (config === void 0) {
    config = {};
  }

  return new AssetPromise(function (resolve, reject, setProgress) {
    var _config$retryCount, _config$retryInterval, _config$timeout, _config$type;

    var retryCount = (_config$retryCount = config.retryCount) != null ? _config$retryCount : defaultRetryCount;
    var retryInterval = (_config$retryInterval = config.retryInterval) != null ? _config$retryInterval : defaultInterval;
    config.timeout = (_config$timeout = config.timeout) != null ? _config$timeout : defaultTimeout;
    config.type = (_config$type = config.type) != null ? _config$type : getMimeTypeFromUrl(url);
    var realRequest = config.type === "image" ? requestImage : requestRes;
    var lastError;
    var executor = new MultiExecutor(function () {
      return realRequest(url, config).onProgress(setProgress).then(function (res) {
        resolve(res);
        executor.stop();
      }).catch(function (err) {
        return lastError = err;
      });
    }, retryCount, retryInterval);
    executor.start(function () {
      reject(lastError);
    });
  });
}

function requestImage(url, config) {
  return new AssetPromise(function (resolve, reject) {
    var timeout = config.timeout;
    var img = new Image();

    var onerror = function onerror() {
      reject(new Error("request " + url + " fail"));
    };

    img.onerror = onerror;
    img.onabort = onerror;
    var timeoutId = setTimeout(function () {
      reject(new Error("request " + url + " timeout"));
    }, timeout);

    img.onload = function (timeoutId) {
      return function () {
        // Call requestAnimationFrame to avoid iOS's bug.
        requestAnimationFrame(function () {
          //@ts-ignore
          resolve(img);
          img.onload = null;
          img.onerror = null;
          img.onabort = null;
        });
        clearTimeout(timeoutId);
      };
    }(timeoutId);

    img.crossOrigin = "anonymous";
    img.src = url;
  });
}

function requestRes(url, config) {
  return new AssetPromise(function (resolve, reject, setProgress) {
    var _config$method;

    var xhr = new XMLHttpRequest();
    xhr.timeout = config.timeout;
    config.method = (_config$method = config.method) != null ? _config$method : "get";

    xhr.onload = function () {
      var _xhr$response;

      if (xhr.status < 200 || xhr.status >= 300) {
        reject(new Error("request failed from: " + url));
        return;
      }

      var result = (_xhr$response = xhr.response) != null ? _xhr$response : xhr.responseText;
      resolve(result);
    };

    xhr.onerror = function () {
      reject(new Error("request failed from: " + url));
    };

    xhr.ontimeout = function () {
      reject(new Error("request timeout from: " + url));
    };

    xhr.onprogress = function (e) {
      setProgress(e.loaded / e.total);
    };

    xhr.open(config.method, url, true);
    xhr.withCredentials = config.credentials === "include"; //@ts-ignore

    xhr.responseType = config.type;
    var headers = config.headers;

    if (headers) {
      Object.keys(headers).forEach(function (name) {
        xhr.setRequestHeader(name, headers[name]);
      });
    }

    xhr.send(config.body);
  });
}

function getMimeTypeFromUrl(url) {
  var extname = url.substring(url.lastIndexOf(".") + 1);
  return mimeType[extname];
}

var MultiExecutor = /*#__PURE__*/function () {
  function MultiExecutor(execFunc, totalCount, interval) {
    this.execFunc = execFunc;
    this.totalCount = totalCount;
    this.interval = interval;
    this._timeoutId = -100;
    this._currentCount = 0;
    this.done = void 0;
    this.exec = this.exec.bind(this);
  }

  var _proto = MultiExecutor.prototype;

  _proto.start = function start(done) {
    this.done = done;
    this.exec();
  };

  _proto.stop = function stop() {
    clearTimeout(this._timeoutId);
  };

  _proto.exec = function exec() {
    var _this = this;

    if (this._currentCount >= this.totalCount) {
      this.done && this.done();
      return;
    }

    this._currentCount++;
    this.execFunc(this._currentCount).then(function () {
      //@ts-ignore
      _this._timeoutId = setTimeout(_this.exec, _this.interval);
    });
  };

  return MultiExecutor;
}();

/**
 * Loader abstract class.
 */
var Loader = function Loader(useCache) {
  this.useCache = useCache;
  this.request = request;
};

/**
 * Asset Type.
 */
var AssetType;

(function (AssetType) {
  AssetType["Text"] = "text";
  AssetType["JSON"] = "json";
  AssetType["Buffer"] = "buffer";
  AssetType["Texture2D"] = "texture2d";
  AssetType["TextureCube"] = "texture-cube";
  AssetType["Material"] = "material";
  AssetType["Mesh"] = "mesh";
  AssetType["AnimationClip"] = "animation-clip";
  AssetType["Prefab"] = "prefab";
  AssetType["KTX"] = "ktx";
  AssetType["KTXCube"] = "ktx-cube";
  AssetType["SpriteAtlas"] = "sprite-atlas";
})(AssetType || (AssetType = {}));

/**
 * Set which face for render.
 */
var RenderFace;

(function (RenderFace) {
  RenderFace[RenderFace["Front"] = 0] = "Front";
  RenderFace[RenderFace["Back"] = 1] = "Back";
  RenderFace[RenderFace["Double"] = 2] = "Double";
})(RenderFace || (RenderFace = {}));

/**
 * Alpha blend mode.
 */
var BlendMode;

(function (BlendMode) {
  BlendMode[BlendMode["Normal"] = 0] = "Normal";
  BlendMode[BlendMode["Additive"] = 1] = "Additive";
})(BlendMode || (BlendMode = {}));

var BaseMaterial = /*#__PURE__*/function (_Material) {
  _inheritsLoose(BaseMaterial, _Material);

  /**
   * Create a BaseMaterial instance.
   * @param engine - Engine to which the material belongs
   * @param shader - Shader used by the material
   */
  function BaseMaterial(engine, shader) {
    var _this;

    _this = _Material.call(this, engine, shader) || this;
    _this._renderFace = RenderFace.Front;
    _this._isTransparent = false;
    _this._blendMode = void 0;
    _this.blendMode = BlendMode.Normal;

    _this.shaderData.setFloat(BaseMaterial._alphaCutoffProp, 0);

    return _this;
  }
  /**
   * @override
   * Clone and return the instance.
   */


  var _proto = BaseMaterial.prototype;

  _proto.clone = function clone() {
    var dest = new BaseMaterial(this._engine, this.shader);
    this.cloneTo(dest);
    return dest;
  }
  /**
   * @override
   * Clone to the target material.
   * @param target - target material
   */
  ;

  _proto.cloneTo = function cloneTo(target) {
    _Material.prototype.cloneTo.call(this, target);

    target._renderFace = this._renderFace;
    target._isTransparent = this._isTransparent;
    target._blendMode = this._blendMode;
  };

  _createClass(BaseMaterial, [{
    key: "isTransparent",
    get:
    /**
     * Is this material transparent.
     * @remarks
     * If material is transparent, transparent blend mode will be affected by `blendMode`, default is `BlendMode.Normal`.
     */
    function get() {
      return this._isTransparent;
    },
    set: function set(value) {
      if (value === this._isTransparent) return;
      this._isTransparent = value;
      var _this$renderState = this.renderState,
          depthState = _this$renderState.depthState,
          targetBlendState = _this$renderState.blendState.targetBlendState;

      if (value) {
        targetBlendState.enabled = true;
        depthState.writeEnabled = false;
        this.renderQueueType = RenderQueueType.Transparent;
      } else {
        targetBlendState.enabled = false;
        depthState.writeEnabled = true;
        this.renderQueueType = this.shaderData.getFloat(BaseMaterial._alphaCutoffProp) ? RenderQueueType.AlphaTest : RenderQueueType.Opaque;
      }
    }
    /**
     * Alpha cutoff value.
     * @remarks
     * Fragments with alpha channel lower than cutoff value will be discarded.
     * `0` means no fragment will be discarded.
     */

  }, {
    key: "alphaCutoff",
    get: function get() {
      return this.shaderData.getFloat(BaseMaterial._alphaCutoffProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(BaseMaterial._alphaCutoffProp, value);

      if (value > 0) {
        this.shaderData.enableMacro(BaseMaterial._alphaCutoffMacro);
        this.renderQueueType = this._isTransparent ? RenderQueueType.Transparent : RenderQueueType.AlphaTest;
      } else {
        this.shaderData.disableMacro(BaseMaterial._alphaCutoffMacro);
        this.renderQueueType = this._isTransparent ? RenderQueueType.Transparent : RenderQueueType.Opaque;
      }
    }
    /**
     * Set which face for render.
     */

  }, {
    key: "renderFace",
    get: function get() {
      return this._renderFace;
    },
    set: function set(value) {
      if (value === this._renderFace) return;
      this._renderFace = value;

      switch (value) {
        case RenderFace.Front:
          this.renderState.rasterState.cullMode = CullMode.Back;
          break;

        case RenderFace.Back:
          this.renderState.rasterState.cullMode = CullMode.Front;
          break;

        case RenderFace.Double:
          this.renderState.rasterState.cullMode = CullMode.Off;
          break;
      }
    }
    /**
     * Alpha blend mode.
     * @remarks
     * Only take effect when `isTransparent` is `true`.
     */

  }, {
    key: "blendMode",
    get: function get() {
      return this._blendMode;
    },
    set: function set(value) {
      if (value === this._blendMode) return;
      this._blendMode = value;
      var target = this.renderState.blendState.targetBlendState;

      switch (value) {
        case BlendMode.Normal:
          target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
          target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
          target.sourceAlphaBlendFactor = BlendFactor.One;
          target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
          target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
          break;

        case BlendMode.Additive:
          target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
          target.destinationColorBlendFactor = BlendFactor.One;
          target.sourceAlphaBlendFactor = BlendFactor.One;
          target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
          target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
          break;
      }
    }
  }]);

  return BaseMaterial;
}(Material);
BaseMaterial._alphaCutoffMacro = Shader.getMacroByName("ALPHA_CUTOFF");
BaseMaterial._alphaCutoffProp = Shader.getPropertyByName("u_alphaCutoff");

/**
 * Blinn-phong Material.
 */

var BlinnPhongMaterial = /*#__PURE__*/function (_BaseMaterial) {
  _inheritsLoose(BlinnPhongMaterial, _BaseMaterial);

  function BlinnPhongMaterial(engine) {
    var _this;

    _this = _BaseMaterial.call(this, engine, Shader.find("blinn-phong")) || this;
    var shaderData = _this.shaderData;
    shaderData.enableMacro("O3_NEED_WORLDPOS");
    shaderData.enableMacro("O3_NEED_TILINGOFFSET");
    shaderData.setColor(BlinnPhongMaterial._diffuseColorProp, new Color(1, 1, 1, 1));
    shaderData.setColor(BlinnPhongMaterial._specularColorProp, new Color(1, 1, 1, 1));
    shaderData.setColor(BlinnPhongMaterial._emissiveColorProp, new Color(0, 0, 0, 1));
    shaderData.setVector4(BlinnPhongMaterial._tilingOffsetProp, new Vector4(1, 1, 0, 0));
    shaderData.setFloat(BlinnPhongMaterial._shininessProp, 16);
    shaderData.setFloat(BlinnPhongMaterial._normalIntensityProp, 1);
    return _this;
  }
  /**
   * @override
   */


  var _proto = BlinnPhongMaterial.prototype;

  _proto.clone = function clone() {
    var dest = new BlinnPhongMaterial(this._engine);
    this.cloneTo(dest);
    return dest;
  };

  _createClass(BlinnPhongMaterial, [{
    key: "baseColor",
    get:
    /**
     * Base color.
     */
    function get() {
      return this.shaderData.getColor(BlinnPhongMaterial._diffuseColorProp);
    },
    set: function set(value) {
      var baseColor = this.shaderData.getColor(BlinnPhongMaterial._diffuseColorProp);

      if (value !== baseColor) {
        value.cloneTo(baseColor);
      }
    }
    /**
     * Base texture.
     */

  }, {
    key: "baseTexture",
    get: function get() {
      return this.shaderData.getTexture(BlinnPhongMaterial._baseTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(BlinnPhongMaterial._baseTextureProp, value);

      if (value) {
        this.shaderData.enableMacro("O3_DIFFUSE_TEXTURE");
      } else {
        this.shaderData.disableMacro("O3_DIFFUSE_TEXTURE");
      }
    }
    /**
     * Specular color.
     */

  }, {
    key: "specularColor",
    get: function get() {
      return this.shaderData.getColor(BlinnPhongMaterial._specularColorProp);
    },
    set: function set(value) {
      var specularColor = this.shaderData.getColor(BlinnPhongMaterial._specularColorProp);

      if (value !== specularColor) {
        value.cloneTo(specularColor);
      }
    }
    /**
     * Specular texture.
     */

  }, {
    key: "specularTexture",
    get: function get() {
      return this.shaderData.getTexture(BlinnPhongMaterial._specularTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(BlinnPhongMaterial._specularTextureProp, value);

      if (value) {
        this.shaderData.enableMacro("O3_SPECULAR_TEXTURE");
      } else {
        this.shaderData.disableMacro("O3_SPECULAR_TEXTURE");
      }
    }
    /**
     * Emissive color.
     */

  }, {
    key: "emissiveColor",
    get: function get() {
      return this.shaderData.getColor(BlinnPhongMaterial._emissiveColorProp);
    },
    set: function set(value) {
      var emissiveColor = this.shaderData.getColor(BlinnPhongMaterial._emissiveColorProp);

      if (value !== emissiveColor) {
        value.cloneTo(emissiveColor);
      }
    }
    /**
     * Emissive texture.
     */

  }, {
    key: "emissiveTexture",
    get: function get() {
      return this.shaderData.getTexture(BlinnPhongMaterial._emissiveTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(BlinnPhongMaterial._emissiveTextureProp, value);

      if (value) {
        this.shaderData.enableMacro("O3_EMISSIVE_TEXTURE");
      } else {
        this.shaderData.disableMacro("O3_EMISSIVE_TEXTURE");
      }
    }
    /**
     * Normal texture.
     */

  }, {
    key: "normalTexture",
    get: function get() {
      return this.shaderData.getTexture(BlinnPhongMaterial._normalTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(BlinnPhongMaterial._normalTextureProp, value);

      if (value) {
        this.shaderData.enableMacro("O3_NORMAL_TEXTURE");
      } else {
        this.shaderData.disableMacro("O3_NORMAL_TEXTURE");
      }
    }
    /**
     * Normal texture intensity.
     */

  }, {
    key: "normalIntensity",
    get: function get() {
      return this.shaderData.getFloat(BlinnPhongMaterial._normalIntensityProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(BlinnPhongMaterial._normalIntensityProp, value);
    }
    /**
     * Set the specular reflection coefficient, the larger the value, the more convergent the specular reflection effect.
     */

  }, {
    key: "shininess",
    get: function get() {
      return this.shaderData.getFloat(BlinnPhongMaterial._shininessProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(BlinnPhongMaterial._shininessProp, value);
    }
    /**
     * Tiling and offset of main textures.
     */

  }, {
    key: "tilingOffset",
    get: function get() {
      return this.shaderData.getVector4(BlinnPhongMaterial._tilingOffsetProp);
    },
    set: function set(value) {
      var tilingOffset = this.shaderData.getVector4(BlinnPhongMaterial._tilingOffsetProp);

      if (value !== tilingOffset) {
        value.cloneTo(tilingOffset);
      }
    }
  }]);

  return BlinnPhongMaterial;
}(BaseMaterial);
BlinnPhongMaterial._diffuseColorProp = Shader.getPropertyByName("u_diffuseColor");
BlinnPhongMaterial._specularColorProp = Shader.getPropertyByName("u_specularColor");
BlinnPhongMaterial._emissiveColorProp = Shader.getPropertyByName("u_emissiveColor");
BlinnPhongMaterial._tilingOffsetProp = Shader.getPropertyByName("u_tilingOffset");
BlinnPhongMaterial._shininessProp = Shader.getPropertyByName("u_shininess");
BlinnPhongMaterial._normalIntensityProp = Shader.getPropertyByName("u_normalIntensity");
BlinnPhongMaterial._baseTextureProp = Shader.getPropertyByName("u_diffuseTexture");
BlinnPhongMaterial._specularTextureProp = Shader.getPropertyByName("u_specularTexture");
BlinnPhongMaterial._emissiveTextureProp = Shader.getPropertyByName("u_emissiveTexture");
BlinnPhongMaterial._normalTextureProp = Shader.getPropertyByName("u_normalTexture");

/**
 * PBR (Physically-Based Rendering) Material.
 */

var PBRBaseMaterial = /*#__PURE__*/function (_BaseMaterial) {
  _inheritsLoose(PBRBaseMaterial, _BaseMaterial);

  /**
   * Create a pbr base material instance.
   * @param engine - Engine to which the material belongs
   */
  function PBRBaseMaterial(engine) {
    var _this;

    _this = _BaseMaterial.call(this, engine, Shader.find("pbr")) || this;
    var shaderData = _this.shaderData;
    shaderData.enableMacro("O3_NEED_WORLDPOS");
    shaderData.enableMacro("O3_NEED_TILINGOFFSET");
    shaderData.setColor(PBRBaseMaterial._baseColorProp, new Color(1, 1, 1, 1));
    shaderData.setColor(PBRBaseMaterial._emissiveColorProp, new Color(0, 0, 0, 1));
    shaderData.setVector4(PBRBaseMaterial._tilingOffsetProp, new Vector4(1, 1, 0, 0));
    shaderData.setFloat(PBRBaseMaterial._normalTextureIntensityProp, 1);
    shaderData.setFloat(PBRBaseMaterial._occlusionTextureIntensityProp, 1);
    return _this;
  }

  _createClass(PBRBaseMaterial, [{
    key: "baseColor",
    get:
    /**
     * Base color.
     */
    function get() {
      return this.shaderData.getColor(PBRBaseMaterial._baseColorProp);
    },
    set: function set(value) {
      var baseColor = this.shaderData.getColor(PBRBaseMaterial._baseColorProp);

      if (value !== baseColor) {
        value.cloneTo(baseColor);
      }
    }
    /**
     * Base texture.
     */

  }, {
    key: "baseTexture",
    get: function get() {
      return this.shaderData.getTexture(PBRBaseMaterial._baseTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(PBRBaseMaterial._baseTextureProp, value);

      if (value) {
        this.shaderData.enableMacro("HAS_BASECOLORMAP");
      } else {
        this.shaderData.disableMacro("HAS_BASECOLORMAP");
      }
    }
    /**
     * Normal texture.
     */

  }, {
    key: "normalTexture",
    get: function get() {
      return this.shaderData.getTexture(PBRBaseMaterial._normalTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(PBRBaseMaterial._normalTextureProp, value);

      if (value) {
        this.shaderData.enableMacro("O3_NORMAL_TEXTURE");
      } else {
        this.shaderData.disableMacro("O3_NORMAL_TEXTURE");
      }
    }
    /**
     * Normal texture intensity.
     */

  }, {
    key: "normalTextureIntensity",
    get: function get() {
      return this.shaderData.getFloat(PBRBaseMaterial._normalTextureIntensityProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(PBRBaseMaterial._normalTextureIntensityProp, value);
      this.shaderData.setFloat("u_normalIntensity", value);
    }
    /**
     * Emissive color.
     */

  }, {
    key: "emissiveColor",
    get: function get() {
      return this.shaderData.getColor(PBRBaseMaterial._emissiveColorProp);
    },
    set: function set(value) {
      var emissiveColor = this.shaderData.getColor(PBRBaseMaterial._emissiveColorProp);

      if (value !== emissiveColor) {
        value.cloneTo(emissiveColor);
      }
    }
    /**
     * Emissive texture.
     */

  }, {
    key: "emissiveTexture",
    get: function get() {
      return this.shaderData.getTexture(PBRBaseMaterial._emissiveTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(PBRBaseMaterial._emissiveTextureProp, value);

      if (value) {
        this.shaderData.enableMacro("HAS_EMISSIVEMAP");
      } else {
        this.shaderData.disableMacro("HAS_EMISSIVEMAP");
      }
    }
    /**
     * Occlusion texture.
     */

  }, {
    key: "occlusionTexture",
    get: function get() {
      return this.shaderData.getTexture(PBRBaseMaterial._occlusionTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(PBRBaseMaterial._occlusionTextureProp, value);

      if (value) {
        this.shaderData.enableMacro("HAS_OCCLUSIONMAP");
      } else {
        this.shaderData.disableMacro("HAS_OCCLUSIONMAP");
      }
    }
    /**
     * Occlusion texture intensity.
     */

  }, {
    key: "occlusionTextureIntensity",
    get: function get() {
      return this.shaderData.getFloat(PBRBaseMaterial._occlusionTextureIntensityProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(PBRBaseMaterial._occlusionTextureIntensityProp, value);
    }
    /**
     * Tiling and offset of main textures.
     */

  }, {
    key: "tilingOffset",
    get: function get() {
      return this.shaderData.getVector4(PBRBaseMaterial._tilingOffsetProp);
    },
    set: function set(value) {
      var tilingOffset = this.shaderData.getVector4(PBRBaseMaterial._tilingOffsetProp);

      if (value !== tilingOffset) {
        value.cloneTo(tilingOffset);
      }
    }
  }]);

  return PBRBaseMaterial;
}(BaseMaterial);
PBRBaseMaterial._baseColorProp = Shader.getPropertyByName("u_baseColor");
PBRBaseMaterial._emissiveColorProp = Shader.getPropertyByName("u_emissiveColor");
PBRBaseMaterial._tilingOffsetProp = Shader.getPropertyByName("u_tilingOffset");
PBRBaseMaterial._baseTextureProp = Shader.getPropertyByName("u_baseColorSampler");
PBRBaseMaterial._normalTextureProp = Shader.getPropertyByName("u_normalTexture");
PBRBaseMaterial._normalTextureIntensityProp = Shader.getPropertyByName("u_normalIntensity");
PBRBaseMaterial._occlusionTextureIntensityProp = Shader.getPropertyByName("u_occlusionStrength");
PBRBaseMaterial._emissiveTextureProp = Shader.getPropertyByName("u_emissiveSampler");
PBRBaseMaterial._occlusionTextureProp = Shader.getPropertyByName("u_occlusionSampler");

/**
 * PBR (Metallic-Roughness Workflow) Material.
 */

var PBRMaterial = /*#__PURE__*/function (_PBRBaseMaterial) {
  _inheritsLoose(PBRMaterial, _PBRBaseMaterial);

  /**
   * Create a pbr metallic-roughness workflow material instance.
   * @param engine - Engine to which the material belongs
   */
  function PBRMaterial(engine) {
    var _this;

    _this = _PBRBaseMaterial.call(this, engine) || this;

    _this.shaderData.enableMacro("IS_METALLIC_WORKFLOW");

    _this.shaderData.setFloat(PBRMaterial._metallicProp, 1.0);

    _this.shaderData.setFloat(PBRMaterial._roughnessProp, 1.0);

    return _this;
  }
  /**
   * @override
   */


  var _proto = PBRMaterial.prototype;

  _proto.clone = function clone() {
    var dest = new PBRMaterial(this._engine);
    this.cloneTo(dest);
    return dest;
  };

  _createClass(PBRMaterial, [{
    key: "metallic",
    get:
    /**
     * Metallic.
     */
    function get() {
      return this.shaderData.getFloat(PBRMaterial._metallicProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(PBRMaterial._metallicProp, value);
    }
    /**
     * Roughness.
     */

  }, {
    key: "roughness",
    get: function get() {
      return this.shaderData.getFloat(PBRMaterial._roughnessProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(PBRMaterial._roughnessProp, value);
    }
    /**
     * Roughness metallic texture.
     * @remarks G channel is roughness, B channel is metallic
     */

  }, {
    key: "roughnessMetallicTexture",
    get: function get() {
      return this.shaderData.getTexture(PBRMaterial._metallicRoughnessTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(PBRMaterial._metallicRoughnessTextureProp, value);

      if (value) {
        this.shaderData.enableMacro("HAS_METALROUGHNESSMAP");
      } else {
        this.shaderData.disableMacro("HAS_METALROUGHNESSMAP");
      }
    }
  }]);

  return PBRMaterial;
}(PBRBaseMaterial);
PBRMaterial._metallicProp = Shader.getPropertyByName("u_metal");
PBRMaterial._roughnessProp = Shader.getPropertyByName("u_roughness");
PBRMaterial._metallicRoughnessTextureProp = Shader.getPropertyByName("u_metallicRoughnessSampler");

/**
 * PBR (Specular-Glossiness Workflow) Material.
 */

var PBRSpecularMaterial = /*#__PURE__*/function (_PBRBaseMaterial) {
  _inheritsLoose(PBRSpecularMaterial, _PBRBaseMaterial);

  /**
   * Create a pbr specular-glossiness workflow material instance.
   * @param engine - Engine to which the material belongs
   */
  function PBRSpecularMaterial(engine) {
    var _this;

    _this = _PBRBaseMaterial.call(this, engine) || this;

    _this.shaderData.setColor(PBRSpecularMaterial._specularColorProp, new Color(1, 1, 1, 1));

    _this.shaderData.setFloat(PBRSpecularMaterial._glossinessProp, 1.0);

    return _this;
  }
  /**
   * @override
   */


  var _proto = PBRSpecularMaterial.prototype;

  _proto.clone = function clone() {
    var dest = new PBRSpecularMaterial(this._engine);
    this.cloneTo(dest);
    return dest;
  };

  _createClass(PBRSpecularMaterial, [{
    key: "specularColor",
    get:
    /**
     * Specular color.
     */
    function get() {
      return this.shaderData.getColor(PBRSpecularMaterial._specularColorProp);
    },
    set: function set(value) {
      var specularColor = this.shaderData.getColor(PBRSpecularMaterial._specularColorProp);

      if (value !== specularColor) {
        value.cloneTo(specularColor);
      }
    }
    /**
     * Glossiness.
     */

  }, {
    key: "glossiness",
    get: function get() {
      return this.shaderData.getFloat(PBRSpecularMaterial._glossinessProp);
    },
    set: function set(value) {
      this.shaderData.setFloat(PBRSpecularMaterial._glossinessProp, value);
    }
    /**
     * Specular glossiness texture.
     * @remarks RGB is specular, A is glossiness
     */

  }, {
    key: "specularGlossinessTexture",
    get: function get() {
      return this.shaderData.getTexture(PBRSpecularMaterial._specularGlossinessTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(PBRSpecularMaterial._specularGlossinessTextureProp, value);

      if (value) {
        this.shaderData.enableMacro("HAS_SPECULARGLOSSINESSMAP");
      } else {
        this.shaderData.disableMacro("HAS_SPECULARGLOSSINESSMAP");
      }
    }
  }]);

  return PBRSpecularMaterial;
}(PBRBaseMaterial);
PBRSpecularMaterial._specularColorProp = Shader.getPropertyByName("u_specularColor");
PBRSpecularMaterial._glossinessProp = Shader.getPropertyByName("u_glossinessFactor");
PBRSpecularMaterial._specularGlossinessTextureProp = Shader.getPropertyByName("u_specularGlossinessSampler");

/**
 * Unlit Material.
 */

var UnlitMaterial = /*#__PURE__*/function (_BaseMaterial) {
  _inheritsLoose(UnlitMaterial, _BaseMaterial);

  /**
   * Create a unlit material instance.
   * @param engine - Engine to which the material belongs
   */
  function UnlitMaterial(engine) {
    var _this;

    _this = _BaseMaterial.call(this, engine, Shader.find("unlit")) || this;
    var shaderData = _this.shaderData;
    shaderData.enableMacro("OMIT_NORMAL");
    shaderData.enableMacro("O3_NEED_TILINGOFFSET");
    shaderData.setColor(UnlitMaterial._baseColorProp, new Color(1, 1, 1, 1));
    shaderData.setVector4(UnlitMaterial._tilingOffsetProp, new Vector4(1, 1, 0, 0));
    return _this;
  }
  /**
   * @override
   */


  var _proto = UnlitMaterial.prototype;

  _proto.clone = function clone() {
    var dest = new UnlitMaterial(this._engine);
    this.cloneTo(dest);
    return dest;
  };

  _createClass(UnlitMaterial, [{
    key: "baseColor",
    get:
    /**
     * Base color.
     */
    function get() {
      return this.shaderData.getColor(UnlitMaterial._baseColorProp);
    },
    set: function set(value) {
      var baseColor = this.shaderData.getColor(UnlitMaterial._baseColorProp);

      if (value !== baseColor) {
        value.cloneTo(baseColor);
      }
    }
    /**
     * Base texture.
     */

  }, {
    key: "baseTexture",
    get: function get() {
      return this.shaderData.getTexture(UnlitMaterial._baseTextureProp);
    },
    set: function set(value) {
      this.shaderData.setTexture(UnlitMaterial._baseTextureProp, value);

      if (value) {
        this.shaderData.enableMacro("O3_BASE_TEXTURE");
      } else {
        this.shaderData.disableMacro("O3_BASE_TEXTURE");
      }
    }
    /**
     * Tiling and offset of main textures.
     */

  }, {
    key: "tilingOffset",
    get: function get() {
      return this.shaderData.getVector4(UnlitMaterial._tilingOffsetProp);
    },
    set: function set(value) {
      var tilingOffset = this.shaderData.getVector4(UnlitMaterial._tilingOffsetProp);

      if (value !== tilingOffset) {
        value.cloneTo(tilingOffset);
      }
    }
  }]);

  return UnlitMaterial;
}(BaseMaterial);
UnlitMaterial._baseColorProp = Shader.getPropertyByName("u_baseColor");
UnlitMaterial._baseTextureProp = Shader.getPropertyByName("u_baseTexture");
UnlitMaterial._tilingOffsetProp = Shader.getPropertyByName("u_tilingOffset");

/**
 * Sprite Atlas.
 */
var SpriteAtlas = /*#__PURE__*/function (_RefObject) {
  _inheritsLoose(SpriteAtlas, _RefObject);

  var _proto = SpriteAtlas.prototype;

  /**
   * Get the last sprite named 'name' from the atlas.
   * @param name - The name of the sprite you want to find
   * @returns The sprite you want to find
   */
  _proto.getSprite = function getSprite(name) {
    var sprite = this._sprites[this._spriteNamesToIndex[name]];

    if (!sprite) {
      console.warn("There is no sprite named " + name + " in the atlas.");
    }

    return sprite;
  }
  /**
   * Get all the sprite named 'name' from the atlas.
   * @param name - The name of the sprites you want to find
   * @param outSprites - This array holds the sprites found
   * @returns The sprites you want to find
   */
  ;

  _proto.getSprites = function getSprites(name, outSprites) {
    outSprites.length = 0;
    var i = this._spriteNamesToIndex[name];

    if (i !== undefined) {
      var _sprites = this._sprites;

      for (; i >= 0; i--) {
        var sprite = _sprites[i];
        sprite.name === name && outSprites.push(sprite);
      }
    } else {
      console.warn("The name of the sprite you want to find is not exit in SpriteAtlas.");
    }

    return outSprites;
  }
  /**
   * Constructor a SpriteAtlas.
   * @param engine - Engine to which the SpriteAtlas belongs
   */
  ;

  function SpriteAtlas(engine) {
    var _this;

    _this = _RefObject.call(this, engine) || this;
    _this._sprites = new Array();
    _this._spriteNamesToIndex = {};
    return _this;
  }
  /**
   * @internal
   */


  _proto._addSprite = function _addSprite(sprite) {
    this._spriteNamesToIndex[sprite.name] = this._sprites.push(sprite) - 1;
  }
  /**
   * @override
   */
  ;

  _proto._onDestroy = function _onDestroy() {
    this._sprites = null;
    this._spriteNamesToIndex = null;
  };

  _createClass(SpriteAtlas, [{
    key: "sprites",
    get:
    /**
     * All the sprites in the atlas.
     */
    function get() {
      return this._sprites;
    }
  }]);

  return SpriteAtlas;
}(RefObject);

/**
 * 2D sprite.
 */
var Sprite = /*#__PURE__*/function (_RefObject) {
  _inheritsLoose(Sprite, _RefObject);

  /**
   * Constructor a Sprite.
   * @param engine - Engine to which the sprite belongs
   * @param texture - Texture from which to obtain the Sprite
   * @param region - Rectangle region of the texture to use for the Sprite, specified in normalized
   * @param pivot - Sprite's pivot point relative to its graphic rectangle, specified in normalized
   * @param pixelsPerUnit - The number of pixels in the Sprite that correspond to one unit in world space
   * @param name - The name of Sprite
   */
  function Sprite(engine, texture, region, pivot, pixelsPerUnit, name) {
    var _this;

    if (texture === void 0) {
      texture = null;
    }

    if (region === void 0) {
      region = null;
    }

    if (pivot === void 0) {
      pivot = null;
    }

    if (pixelsPerUnit === void 0) {
      pixelsPerUnit = 128;
    }

    if (name === void 0) {
      name = null;
    }

    _this = _RefObject.call(this, engine) || this;
    _this.name = void 0;
    _this._uv = [new Vector2(), new Vector2(), new Vector2(), new Vector2()];
    _this._positions = [new Vector2(), new Vector2(), new Vector2(), new Vector2()];
    _this._bounds = new BoundingBox();
    _this._triangles = void 0;
    _this._assetID = void 0;
    _this._pixelsPerUnit = void 0;
    _this._texture = null;
    _this._atlasRotated = false;
    _this._region = new Rect(0, 0, 1, 1);
    _this._pivot = new Vector2(0.5, 0.5);
    _this._atlasRegion = new Rect(0, 0, 1, 1);
    _this._atlasRegionOffset = new Vector4(0, 0, 0, 0);
    _this._dirtyFlag = DirtyFlag$1.all;
    _this.name = name;
    _this._texture = texture;
    _this._pixelsPerUnit = pixelsPerUnit;
    region && region.cloneTo(_this._region);
    pivot && pivot.cloneTo(_this._pivot);
    _this._triangles = Sprite._rectangleTriangles;
    return _this;
  }
  /**
   * @override
   */


  var _proto = Sprite.prototype;

  _proto._onDestroy = function _onDestroy() {
    if (this._texture) {
      this._texture = null;
    }
  }
  /**
   * Update positions and bounds.
   */
  ;

  _proto._updatePositionsAndBounds = function _updatePositionsAndBounds() {
    var texture = this._texture,
        bounds = this._bounds;

    if (texture) {
      var atlasRegion = this._atlasRegion,
          pivot = this._pivot,
          atlasRegionOffset = this._atlasRegionOffset;
      var _this$_region = this._region,
          regionX = _this$_region.x,
          regionY = _this$_region.y,
          regionW = _this$_region.width,
          regionH = _this$_region.height;
      var pPUReciprocal = 1.0 / this._pixelsPerUnit; // Coordinates of the four boundaries.

      var lx, ty, rx, by; // TextureSize

      var textureW, textureH;

      if (this._atlasRotated) {
        textureW = texture.height * atlasRegion.height * pPUReciprocal;
        textureH = texture.width * atlasRegion.width * pPUReciprocal;
      } else {
        textureW = texture.width * atlasRegion.width * pPUReciprocal;
        textureH = texture.height * atlasRegion.height * pPUReciprocal;
      } // Determine whether it has been trimmed.


      if (atlasRegionOffset.x == 0 && atlasRegionOffset.y == 0 && atlasRegionOffset.z == 0 && atlasRegionOffset.w == 0) {
        // Real rendering size.
        var realRenderW = textureW * regionW;
        var realRenderH = textureH * regionH;
        lx = -pivot.x * realRenderW;
        by = -pivot.y * realRenderH;
        rx = realRenderW + lx;
        ty = realRenderH + by;
      } else {
        var blankLeft = atlasRegionOffset.x,
            blankTop = atlasRegionOffset.y,
            blankRight = atlasRegionOffset.z,
            blankBottom = atlasRegionOffset.w;
        var oriWidth = textureW / (1 - blankRight - blankLeft);
        var oriHeight = textureH / (1 - blankBottom - blankTop); // The size of the real rendering.

        lx = (-pivot.x * regionW + Math.max(blankLeft, regionX) - regionX) * oriWidth;
        ty = (pivot.y * regionH - Math.max(blankTop, regionY) + regionY) * oriHeight;
        rx = (-pivot.x * regionW + Math.min(1 - blankRight, regionX + regionW) - regionX) * oriWidth;
        by = (pivot.y * regionH - Math.min(1 - blankBottom, regionY + regionH) + regionY) * oriHeight;
      } // Assign values â€‹â€‹to _positions


      var positions = this._positions; // Top-left.

      positions[0].setValue(lx, ty); // Top-right.

      positions[1].setValue(rx, ty); // Bottom-right.

      positions[2].setValue(rx, by); // Bottom-left.

      positions[3].setValue(lx, by); // Update bounds.

      bounds.min.setValue(lx, by, 0);
      bounds.max.setValue(rx, ty, 0);
    } else {
      // Update bounds.
      bounds.min.setValue(0, 0, 0);
      bounds.max.setValue(0, 0, 0);
    }
  }
  /**
   * Update mesh.
   */
  ;

  _proto._updateMesh = function _updateMesh() {
    if (this._isContainDirtyFlag(DirtyFlag$1.positions)) {
      this._updatePositionsAndBounds();
    }

    if (this._isContainDirtyFlag(DirtyFlag$1.uv)) {
      var _atlasRegion = this._atlasRegion,
          uv = this._uv,
          region = this._region,
          _atlasRotated = this._atlasRotated,
          atlasRegionOffset = this._atlasRegionOffset;
      var left, top, right, bottom; // Determine whether it has been trimmed.

      if (atlasRegionOffset.x == 0 && atlasRegionOffset.y == 0 && atlasRegionOffset.z == 0 && atlasRegionOffset.w == 0) {
        var atlasRegionW = _atlasRegion.width,
            atlasRegionH = _atlasRegion.height;

        if (_atlasRotated) {
          left = atlasRegionW * (1 - region.y - region.height) + _atlasRegion.x;
          top = atlasRegionH * region.x + _atlasRegion.y;
          right = atlasRegionW * region.height + left;
          bottom = atlasRegionH * region.width + top;
        } else {
          left = atlasRegionW * region.x + _atlasRegion.x;
          top = atlasRegionH * region.y + _atlasRegion.y;
          right = atlasRegionW * region.width + left;
          bottom = atlasRegionH * region.height + top;
        }
      } else {
        var regionX = region.x,
            regionY = region.y;
        var atlasRegionX = _atlasRegion.x,
            atlasRegionY = _atlasRegion.y;
        var blankLeft = atlasRegionOffset.x,
            blankTop = atlasRegionOffset.y,
            blankRight = atlasRegionOffset.z,
            blankBottom = atlasRegionOffset.w; // Proportion of the original sprite size in the atlas.

        if (_atlasRotated) {
          var textureW = _atlasRegion.width / (1 - blankBottom - blankTop);
          var textureH = _atlasRegion.height / (1 - blankRight - blankLeft);
          left = (Math.max(blankBottom, 1 - regionY - region.height) - blankBottom) * textureW + atlasRegionX;
          top = (Math.max(blankLeft, regionX) - blankLeft) * textureH + atlasRegionY;
          right = (Math.min(1 - blankTop, 1 - regionY) - blankBottom) * textureW + atlasRegionX;
          bottom = (Math.min(1 - blankRight, regionX + region.width) - blankLeft) * textureH + atlasRegionY;
        } else {
          var _textureW = _atlasRegion.width / (1 - blankRight - blankLeft);

          var _textureH = _atlasRegion.height / (1 - blankBottom - blankTop);

          left = (Math.max(blankLeft, regionX) - blankLeft) * _textureW + atlasRegionX;
          top = (Math.max(blankTop, regionY) - blankTop) * _textureH + atlasRegionY;
          right = (Math.min(1 - blankRight, regionX + region.width) - blankLeft) * _textureW + atlasRegionX;
          bottom = (Math.min(1 - blankBottom, regionY + region.height) - blankTop) * _textureH + atlasRegionY;
        }
      }

      if (_atlasRotated) {
        // If it is rotated, we need to rotate the UV 90 degrees counterclockwise to correct it.
        // Top-right.
        uv[0].setValue(right, top); // Bottom-right.

        uv[1].setValue(right, bottom); // Bottom-left.

        uv[2].setValue(left, bottom); // Top-left.

        uv[3].setValue(left, top);
      } else {
        // Top-left.
        uv[0].setValue(left, top); // Top-right.

        uv[1].setValue(right, top); // Bottom-right.

        uv[2].setValue(right, bottom); // Bottom-left.

        uv[3].setValue(left, bottom);
      }
    }
  }
  /**
   * @internal
   * Update mesh data of the sprite.
   * @returns True if the data is refreshed, false otherwise.
   */
  ;

  _proto._updateMeshData = function _updateMeshData() {
    if (this._isContainDirtyFlag(DirtyFlag$1.all)) {
      this._updateMesh();

      this._setDirtyFlagFalse(DirtyFlag$1.all);

      return true;
    }

    return false;
  };

  _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
    return (this._dirtyFlag & type) != 0;
  };

  _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
    this._dirtyFlag |= type;
  };

  _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
    this._dirtyFlag &= ~type;
  };

  _createClass(Sprite, [{
    key: "texture",
    get:
    /** The name of sprite. */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal temp solution. */

    /**
     * The reference to the used texture.
     */
    function get() {
      return this._texture;
    },
    set: function set(value) {
      if (this._texture !== value) {
        this._texture = value;

        this._setDirtyFlagTrue(DirtyFlag$1.positions);
      }
    }
    /**
     *  Bounding volume of the sprite.
     *  @remarks The returned bounds should be considered deep-read-only.
     */

  }, {
    key: "bounds",
    get: function get() {
      if (this._isContainDirtyFlag(DirtyFlag$1.positions) && this._texture) {
        this._updatePositionsAndBounds();

        this._setDirtyFlagFalse(DirtyFlag$1.positions);
      }

      return this._bounds;
    }
    /**
     * Is it rotated 90 degrees clockwise when packing.
     */

  }, {
    key: "atlasRotated",
    get: function get() {
      return this._atlasRotated;
    },
    set: function set(value) {
      if (this._atlasRotated != value) {
        this._atlasRotated = value;

        this._setDirtyFlagTrue(DirtyFlag$1.positions | DirtyFlag$1.uv);
      }
    }
    /**
     * The rectangle region of the original texture on its atlas texture, specified in normalized.
     */

  }, {
    key: "atlasRegion",
    get: function get() {
      return this._atlasRegion;
    },
    set: function set(value) {
      var x = MathUtil.clamp(value.x, 0, 1);
      var y = MathUtil.clamp(value.y, 0, 1);

      this._atlasRegion.setValue(x, y, MathUtil.clamp(value.width, 0, 1 - x), MathUtil.clamp(value.height, 0, 1 - y));

      this._setDirtyFlagTrue(DirtyFlag$1.positions | DirtyFlag$1.uv);
    }
    /**
     * The rectangle region offset of the original texture on its atlas texture, specified in normalized.
     */

  }, {
    key: "atlasRegionOffset",
    get: function get() {
      return this._atlasRegionOffset;
    },
    set: function set(value) {
      var x = MathUtil.clamp(value.x, 0, 1);
      var y = MathUtil.clamp(value.y, 0, 1);

      this._atlasRegionOffset.setValue(x, y, MathUtil.clamp(value.z, 0, 1 - x), MathUtil.clamp(value.w, 0, 1 - y));

      this._setDirtyFlagTrue(DirtyFlag$1.positions | DirtyFlag$1.uv);
    }
    /**
     * Location of the sprite's center point in the rectangle region, specified in normalized.
     */

  }, {
    key: "pivot",
    get: function get() {
      return this._pivot;
    },
    set: function set(value) {
      this._pivot.setValue(MathUtil.clamp(value.x, 0, 1), MathUtil.clamp(value.y, 0, 1));

      this._setDirtyFlagTrue(DirtyFlag$1.positions);
    }
    /**
     * The rectangle region of the sprite, specified in normalized.
     */

  }, {
    key: "region",
    get: function get() {
      return this._region;
    },
    set: function set(value) {
      var region = this._region;
      var x = MathUtil.clamp(value.x, 0, 1);
      var y = MathUtil.clamp(value.y, 0, 1);
      region.setValue(x, y, MathUtil.clamp(value.width, 0, 1 - x), MathUtil.clamp(value.height, 0, 1 - y));

      this._setDirtyFlagTrue(DirtyFlag$1.positions | DirtyFlag$1.uv);
    }
    /**
     * The number of pixels in the sprite that correspond to one unit in world space.
     */

  }, {
    key: "pixelsPerUnit",
    get: function get() {
      return this._pixelsPerUnit;
    },
    set: function set(value) {
      if (this._pixelsPerUnit !== value) {
        this._pixelsPerUnit = value;

        this._setDirtyFlagTrue(DirtyFlag$1.positions);
      }
    }
  }]);

  return Sprite;
}(RefObject);
Sprite._rectangleTriangles = [0, 2, 1, 2, 0, 3];
var DirtyFlag$1;

(function (DirtyFlag) {
  DirtyFlag[DirtyFlag["positions"] = 1] = "positions";
  DirtyFlag[DirtyFlag["uv"] = 2] = "uv";
  DirtyFlag[DirtyFlag["all"] = 3] = "all";
})(DirtyFlag$1 || (DirtyFlag$1 = {}));

var _class$1, _descriptor$1, _descriptor2$1, _descriptor3$1, _descriptor4$1, _descriptor5$1, _descriptor6$1, _descriptor7$1, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _class2$1, _temp$1;

/**
 * Renders a Sprite for 2D graphics.
 */
var SpriteRenderer = (_class$1 = (_temp$1 = _class2$1 = /*#__PURE__*/function (_Renderer) {
  _inheritsLoose(SpriteRenderer, _Renderer);

  /**
   * @internal
   */
  function SpriteRenderer(entity) {
    var _this;

    _this = _Renderer.call(this, entity) || this;

    _initializerDefineProperty(_this, "_customLocalBounds", _descriptor$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_customRootEntity", _descriptor2$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_positions", _descriptor3$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_sprite", _descriptor4$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_color", _descriptor5$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_flipX", _descriptor6$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_flipY", _descriptor7$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_cacheFlipX", _descriptor8, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_cacheFlipY", _descriptor9, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_dirtyFlag", _descriptor10, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_isWorldMatrixDirty", _descriptor11, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_maskInteraction", _descriptor12, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_maskLayer", _descriptor13, _assertThisInitialized(_this));

    _this._isWorldMatrixDirty = entity.transform.registerWorldChangeFlag();

    _this.setMaterial(_this._engine._spriteDefaultMaterial);

    return _this;
  }
  /**
   * @internal
   */


  var _proto = SpriteRenderer.prototype;

  _proto._render = function _render(camera) {
    var sprite = this.sprite;

    if (!sprite) {
      return;
    }

    var texture = sprite.texture;

    if (!texture) {
      return;
    }

    var _positions = this._positions;
    var transform = this.entity.transform; // Update sprite data.

    var localDirty = sprite._updateMeshData();

    if (this._isWorldMatrixDirty.flag || localDirty || this._isContainDirtyFlag(DirtyFlag.Sprite)) {
      var localPositions = sprite._positions;
      var localVertexPos = SpriteRenderer._tempVec3;
      var worldMatrix = transform.worldMatrix;
      var flipX = this.flipX,
          flipY = this.flipY;

      for (var i = 0, n = _positions.length; i < n; i++) {
        var curVertexPos = localPositions[i];
        localVertexPos.setValue(flipX ? -curVertexPos.x : curVertexPos.x, flipY ? -curVertexPos.y : curVertexPos.y, 0);
        Vector3.transformToVec3(localVertexPos, worldMatrix, _positions[i]);
      }

      this._setDirtyFlagFalse(DirtyFlag.Flip);

      this._setDirtyFlagFalse(DirtyFlag.Sprite);

      this._isWorldMatrixDirty.flag = false;
      this._cacheFlipX = flipX;
      this._cacheFlipY = flipY;
    } else if (this._isContainDirtyFlag(DirtyFlag.Flip)) {
      var _flipX = this.flipX,
          _flipY = this.flipY;
      var flipXChange = this._cacheFlipX !== _flipX;
      var flipYChange = this._cacheFlipY !== _flipY;

      if (flipXChange || flipYChange) {
        var _transform$worldPosit = transform.worldPosition,
            x = _transform$worldPosit.x,
            y = _transform$worldPosit.y;

        for (var _i = 0, _n = _positions.length; _i < _n; _i++) {
          var curPos = _positions[_i];

          if (flipXChange) {
            curPos.x = x * 2 - curPos.x;
          }

          if (flipYChange) {
            curPos.y = y * 2 - curPos.y;
          }
        }
      }

      this._setDirtyFlagFalse(DirtyFlag.Flip);

      this._cacheFlipX = _flipX;
      this._cacheFlipY = _flipY;
    }

    if (this._isContainDirtyFlag(DirtyFlag.MaskInteraction)) {
      this._updateStencilState();

      this._setDirtyFlagFalse(DirtyFlag.MaskInteraction);
    }

    this.shaderData.setTexture(SpriteRenderer._textureProperty, texture);
    var material = this.getMaterial();
    var spriteElementPool = this._engine._spriteElementPool;
    var spriteElement = spriteElementPool.getFromPool();
    spriteElement.setValue(this, _positions, sprite._uv, sprite._triangles, this.color, material, camera);

    camera._renderPipeline.pushPrimitive(spriteElement);
  }
  /**
   * @internal
   */
  ;

  _proto._onDestroy = function _onDestroy() {
    this._isWorldMatrixDirty.destroy();

    _Renderer.prototype._onDestroy.call(this);
  };

  _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
    return (this._dirtyFlag & type) != 0;
  };

  _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
    this._dirtyFlag |= type;
  };

  _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
    this._dirtyFlag &= ~type;
  }
  /**
   * @override
   */
  ;

  _proto._updateBounds = function _updateBounds(worldBounds) {
    var sprite = this._sprite;

    if (sprite) {
      if (this._customLocalBounds && this._customRootEntity) {
        var worldMatrix = this._customRootEntity.transform.worldMatrix;
        BoundingBox.transform(this._customLocalBounds, worldMatrix, worldBounds);
      } else {
        var localBounds = sprite.bounds;
        var _worldMatrix = this._entity.transform.worldMatrix;
        BoundingBox.transform(localBounds, _worldMatrix, worldBounds);
      }
    } else {
      worldBounds.min.setValue(0, 0, 0);
      worldBounds.max.setValue(0, 0, 0);
    }
  };

  _proto._updateStencilState = function _updateStencilState() {
    // Update stencil.
    var material = this.getInstanceMaterial();
    var stencilState = material.renderState.stencilState;
    var maskInteraction = this._maskInteraction;

    if (maskInteraction === SpriteMaskInteraction.None) {
      stencilState.enabled = false;
      stencilState.writeMask = 0xff;
      stencilState.referenceValue = 0;
      stencilState.compareFunctionFront = stencilState.compareFunctionBack = CompareFunction.Always;
    } else {
      stencilState.enabled = true;
      stencilState.writeMask = 0x00;
      stencilState.referenceValue = 1;
      var compare = maskInteraction === SpriteMaskInteraction.VisibleInsideMask ? CompareFunction.LessEqual : CompareFunction.Greater;
      stencilState.compareFunctionFront = compare;
      stencilState.compareFunctionBack = compare;
    }
  };

  _createClass(SpriteRenderer, [{
    key: "sprite",
    get:
    /** @internal temp solution. */

    /** @internal temp solution. */

    /**
     * The Sprite to render.
     */
    function get() {
      return this._sprite;
    },
    set: function set(value) {
      if (this._sprite !== value) {
        this._sprite = value;

        this._setDirtyFlagTrue(DirtyFlag.Sprite);
      }
    }
    /**
     * Rendering color for the Sprite graphic.
     */

  }, {
    key: "color",
    get: function get() {
      return this._color;
    },
    set: function set(value) {
      if (this._color !== value) {
        value.cloneTo(this._color);
      }
    }
    /**
     * Flips the sprite on the X axis.
     */

  }, {
    key: "flipX",
    get: function get() {
      return this._flipX;
    },
    set: function set(value) {
      if (this._flipX !== value) {
        this._flipX = value;

        this._setDirtyFlagTrue(DirtyFlag.Flip);
      }
    }
    /**
     * Flips the sprite on the Y axis.
     */

  }, {
    key: "flipY",
    get: function get() {
      return this._flipY;
    },
    set: function set(value) {
      if (this._flipY !== value) {
        this._flipY = value;

        this._setDirtyFlagTrue(DirtyFlag.Flip);
      }
    }
    /**
     * Interacts with the masks.
     */

  }, {
    key: "maskInteraction",
    get: function get() {
      return this._maskInteraction;
    },
    set: function set(value) {
      if (this._maskInteraction !== value) {
        this._maskInteraction = value;

        this._setDirtyFlagTrue(DirtyFlag.MaskInteraction);
      }
    }
    /**
     * The mask layer the sprite renderer belongs to.
     */

  }, {
    key: "maskLayer",
    get: function get() {
      return this._maskLayer;
    },
    set: function set(value) {
      this._maskLayer = value;
    }
  }]);

  return SpriteRenderer;
}(Renderer), _class2$1._textureProperty = Shader.getPropertyByName("u_spriteTexture"), _class2$1._tempVec3 = new Vector3(), _temp$1), (_descriptor$1 = _applyDecoratedDescriptor(_class$1.prototype, "_customLocalBounds", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor2$1 = _applyDecoratedDescriptor(_class$1.prototype, "_customRootEntity", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor3$1 = _applyDecoratedDescriptor(_class$1.prototype, "_positions", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [new Vector3(), new Vector3(), new Vector3(), new Vector3()];
  }
}), _descriptor4$1 = _applyDecoratedDescriptor(_class$1.prototype, "_sprite", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor5$1 = _applyDecoratedDescriptor(_class$1.prototype, "_color", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Color(1, 1, 1, 1);
  }
}), _descriptor6$1 = _applyDecoratedDescriptor(_class$1.prototype, "_flipX", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor7$1 = _applyDecoratedDescriptor(_class$1.prototype, "_flipY", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor8 = _applyDecoratedDescriptor(_class$1.prototype, "_cacheFlipX", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor9 = _applyDecoratedDescriptor(_class$1.prototype, "_cacheFlipY", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor10 = _applyDecoratedDescriptor(_class$1.prototype, "_dirtyFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return DirtyFlag.All;
  }
}), _descriptor11 = _applyDecoratedDescriptor(_class$1.prototype, "_isWorldMatrixDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor12 = _applyDecoratedDescriptor(_class$1.prototype, "_maskInteraction", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return SpriteMaskInteraction.None;
  }
}), _descriptor13 = _applyDecoratedDescriptor(_class$1.prototype, "_maskLayer", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return SpriteMaskLayer.Layer0;
  }
})), _class$1);
var DirtyFlag;

(function (DirtyFlag) {
  DirtyFlag[DirtyFlag["Flip"] = 1] = "Flip";
  DirtyFlag[DirtyFlag["Sprite"] = 2] = "Sprite";
  DirtyFlag[DirtyFlag["All"] = 3] = "All";
  DirtyFlag[DirtyFlag["MaskInteraction"] = 4] = "MaskInteraction";
})(DirtyFlag || (DirtyFlag = {}));

/**
 * Associate AnimationCurve and the Entity
 */
var AnimationClipCurveBinding = function AnimationClipCurveBinding() {
  this.relativePath = void 0;
  this.type = void 0;
  this.property = void 0;
  this.curve = void 0;
};

var AnimationProperty;

(function (AnimationProperty) {
  AnimationProperty[AnimationProperty["Position"] = 0] = "Position";
  AnimationProperty[AnimationProperty["Rotation"] = 1] = "Rotation";
  AnimationProperty[AnimationProperty["Scale"] = 2] = "Scale";
  AnimationProperty[AnimationProperty["BlendShapeWeights"] = 3] = "BlendShapeWeights";
})(AnimationProperty || (AnimationProperty = {}));

/**
 * Base class for AnimationClips and BlendTrees.
 */
var Motion = function Motion() {};

/**
 * Stores keyframe based animations.
 */

var AnimationClip = /*#__PURE__*/function (_Motion) {
  _inheritsLoose(AnimationClip, _Motion);

  /**
   * @param name - The AnimationClip's name
   */
  function AnimationClip(name) {
    var _this;

    _this = _Motion.call(this) || this;
    _this.name = name;
    _this._curveBindings = [];
    _this._length = 0;
    _this._events = [];
    return _this;
  }
  /**
   * Adds an animation event to the clip.
   * @param event - The animation event
   */


  var _proto = AnimationClip.prototype;

  _proto.addEvent = function addEvent(event) {
    this._events.push(event);

    this._events.sort(function (a, b) {
      return a.time - b.time;
    });
  }
  /**
   * Clears all events from the clip.
   */
  ;

  _proto.clearEvents = function clearEvents() {
    this._events.length = 0;
  }
  /**
   * Add curve binding for the clip.
   * @param relativePath - Path to the game object this curve applies to. The relativePath is formatted similar to a pathname, e.g. "/root/spine/leftArm"
   * @param type- The class type of the component that is animated
   * @param propertyName - The name to the property being animated
   * @param curve - The animation curve
   */
  ;

  _proto.addCurveBinding = function addCurveBinding(relativePath, type, propertyName, curve) {
    var property;

    switch (propertyName) {
      case "position":
        property = AnimationProperty.Position;
        break;

      case "rotation":
        property = AnimationProperty.Rotation;
        break;

      case "scale":
        property = AnimationProperty.Scale;
        break;

      case "blendShapeWeights":
        property = AnimationProperty.BlendShapeWeights;
        break;
    }

    var curveBinding = new AnimationClipCurveBinding();
    curveBinding.relativePath = relativePath;
    curveBinding.type = type;
    curveBinding.property = property;
    curveBinding.curve = curve;

    if (curve.length > this._length) {
      this._length = curve.length;
    }

    this._curveBindings.push(curveBinding);
  }
  /**
   * Clears all curve bindings from the clip.
   */
  ;

  _proto.clearCurveBindings = function clearCurveBindings() {
    this._curveBindings.length = 0;
    this._length = 0;
  }
  /**
   * @internal
   * Samples an animation at a given time.
   * @param entity - The animated entity
   * @param time - The time to sample an animation
   */
  ;

  _proto._sampleAnimation = function _sampleAnimation(entity, time) {
    var length = this._curveBindings.length;

    for (var i = length - 1; i >= 0; i--) {
      var curveData = this._curveBindings[i];
      var curve = curveData.curve,
          property = curveData.property,
          relativePath = curveData.relativePath,
          type = curveData.type;
      var val = curve.evaluate(time);
      var target = entity.findByName(relativePath);
      var transform = target.transform;

      if (type === Transform) {
        switch (property) {
          case AnimationProperty.Position:
            transform.position = val;
            break;

          case AnimationProperty.Rotation:
            transform.rotationQuaternion = val;
            break;

          case AnimationProperty.Scale:
            transform.scale = val;
            break;
        }
      }
    }
  };

  _createClass(AnimationClip, [{
    key: "events",
    get:
    /** @internal */

    /**
     * Animation events for this animation clip.
     */
    function get() {
      return this._events;
    }
    /**
     * Animation curve bindings for this animation clip.
     */

  }, {
    key: "curveBindings",
    get: function get() {
      return this._curveBindings;
    }
    /**
     * Animation length in seconds.
     */

  }, {
    key: "length",
    get: function get() {
      return this._length;
    }
  }]);

  return AnimationClip;
}(Motion);

/**
 * @internal
 */

var AnimatorUtils = /*#__PURE__*/function () {
  function AnimatorUtils() {}

  AnimatorUtils.scaleWeight = function scaleWeight(s, w, out) {
    var sX = s.x;
    var sY = s.y;
    var sZ = s.z;
    out.x = sX > 0 ? Math.pow(Math.abs(sX), w) : -Math.pow(Math.abs(sX), w);
    out.y = sY > 0 ? Math.pow(Math.abs(sY), w) : -Math.pow(Math.abs(sY), w);
    out.z = sZ > 0 ? Math.pow(Math.abs(sZ), w) : -Math.pow(Math.abs(sZ), w);
  };

  AnimatorUtils.scaleBlend = function scaleBlend(sa, sb, w, out) {
    var saw = AnimatorUtils._tempVector30;
    var sbw = AnimatorUtils._tempVector31;
    AnimatorUtils.scaleWeight(sa, 1.0 - w, saw);
    AnimatorUtils.scaleWeight(sb, w, sbw);
    var sng = w > 0.5 ? sb : sa;
    out.x = sng.x > 0 ? Math.abs(saw.x * sbw.x) : -Math.abs(saw.x * sbw.x);
    out.y = sng.y > 0 ? Math.abs(saw.y * sbw.y) : -Math.abs(saw.y * sbw.y);
    out.z = sng.z > 0 ? Math.abs(saw.z * sbw.z) : -Math.abs(saw.z * sbw.z);
  };

  AnimatorUtils.quaternionWeight = function quaternionWeight(s, w, out) {
    out.x = s.x * w;
    out.y = s.y * w;
    out.z = s.z * w;
    out.w = s.w;
  };

  return AnimatorUtils;
}();
AnimatorUtils._tempVector30 = new Vector3();
AnimatorUtils._tempVector31 = new Vector3();

var AnimatorLayerBlendingMode;

(function (AnimatorLayerBlendingMode) {
  AnimatorLayerBlendingMode[AnimatorLayerBlendingMode["Override"] = 0] = "Override";
  AnimatorLayerBlendingMode[AnimatorLayerBlendingMode["Additive"] = 1] = "Additive";
})(AnimatorLayerBlendingMode || (AnimatorLayerBlendingMode = {}));

/**
 * Layer state.
 */
var LayerState;

(function (LayerState) {
  LayerState[LayerState["Standby"] = 0] = "Standby";
  LayerState[LayerState["Playing"] = 1] = "Playing";
  LayerState[LayerState["CrossFading"] = 2] = "CrossFading";
  LayerState[LayerState["FixedCrossFading"] = 3] = "FixedCrossFading";
})(LayerState || (LayerState = {}));

/**
 * @internal
 */
var AnimationCurveOwner = /*#__PURE__*/function () {
  function AnimationCurveOwner(target, type, property) {
    this.crossCurveMark = 0;
    this.crossCurveIndex = void 0;
    this.target = void 0;
    this.type = void 0;
    this.property = void 0;
    this.component = void 0;
    this.defaultValue = void 0;
    this.fixedPoseValue = void 0;
    this.target = target;
    this.type = type;
    this.property = property;

    switch (property) {
      case AnimationProperty.Position:
        this.defaultValue = new Vector3();
        this.fixedPoseValue = new Vector3();
        this.component = target.transform;
        break;

      case AnimationProperty.Rotation:
        this.defaultValue = new Quaternion();
        this.fixedPoseValue = new Quaternion();
        this.component = target.transform;
        break;

      case AnimationProperty.Scale:
        this.defaultValue = new Vector3();
        this.fixedPoseValue = new Vector3();
        this.component = target.transform;
        break;

      case AnimationProperty.BlendShapeWeights:
        this.defaultValue = new Float32Array(4);
        this.fixedPoseValue = new Float32Array(4);
        this.component = target.getComponent(SkinnedMeshRenderer);
        break;
    }
  }

  var _proto = AnimationCurveOwner.prototype;

  _proto.saveDefaultValue = function saveDefaultValue() {
    switch (this.property) {
      case AnimationProperty.Position:
        this.target.transform.position.cloneTo(this.defaultValue);
        break;

      case AnimationProperty.Rotation:
        this.target.transform.rotationQuaternion.cloneTo(this.defaultValue);
        break;

      case AnimationProperty.Scale:
        this.target.transform.scale.cloneTo(this.defaultValue);
        break;
    }
  };

  _proto.saveFixedPoseValue = function saveFixedPoseValue() {
    switch (this.property) {
      case AnimationProperty.Position:
        this.target.transform.position.cloneTo(this.fixedPoseValue);
        break;

      case AnimationProperty.Rotation:
        this.target.transform.rotationQuaternion.cloneTo(this.fixedPoseValue);
        break;

      case AnimationProperty.Scale:
        this.target.transform.scale.cloneTo(this.fixedPoseValue);
        break;
    }
  };

  return AnimationCurveOwner;
}();

/**
 * @internal
 */
var AnimationEventHandler = function AnimationEventHandler() {
  this.event = void 0;
  this.handlers = [];
};

/**
 * Transitions define when and how the state machine switch from on state to another. AnimatorTransition always originate from a StateMachine or a StateMachine entry.
 */
var AnimatorStateTransition = function AnimatorStateTransition() {
  this.duration = 0;
  this.offset = 0;
  this.exitTime = 1;
  this.destinationState = void 0;
};

/**
 * Animation wrap mode.
 */
var WrapMode;

(function (WrapMode) {
  WrapMode[WrapMode["Once"] = 0] = "Once";
  WrapMode[WrapMode["Loop"] = 1] = "Loop";
})(WrapMode || (WrapMode = {}));

/**
 * @internal
 */
var AnimatorStatePlayData = /*#__PURE__*/function () {
  function AnimatorStatePlayData() {
    this.state = void 0;
    this.stateData = void 0;
    this.frameTime = void 0;
    this.finished = void 0;
    this.clipTime = void 0;
    this.currentEventIndex = void 0;
  }

  var _proto = AnimatorStatePlayData.prototype;

  _proto.reset = function reset(state, stateData, offsetFrameTime) {
    this.state = state;
    this.frameTime = offsetFrameTime;
    this.stateData = stateData;
    this.finished = false;
    this.clipTime = this.state.clipStartTime;
    this.currentEventIndex = 0;
  };

  _proto.update = function update() {
    var state = this.state;
    var time = this.frameTime;
    var duration = state.clipEndTime - state.clipStartTime;

    if (time > duration) {
      if (state.wrapMode === WrapMode.Loop) {
        time = time % duration;
      } else {
        time = duration;
        this.finished = true;
      }
    }

    this.clipTime = time + this.state.clipStartTime;
  };

  return AnimatorStatePlayData;
}();

/**
 * @internal
 */

var AnimatorLayerData = /*#__PURE__*/function () {
  function AnimatorLayerData() {
    this.animatorStateDataMap = {};
    this.srcPlayData = new AnimatorStatePlayData();
    this.destPlayData = new AnimatorStatePlayData();
    this.layerState = LayerState.Standby;
    this.crossCurveMark = 0;
    this.manuallyTransition = new AnimatorStateTransition();
    this.crossFadeTransition = void 0;
  }

  var _proto = AnimatorLayerData.prototype;

  _proto.switchPlayData = function switchPlayData() {
    var srcPlayData = this.destPlayData;
    var switchTemp = this.srcPlayData;
    this.srcPlayData = srcPlayData;
    this.destPlayData = switchTemp;
  };

  return AnimatorLayerData;
}();

/**
 * @internal
 */
var AnimatorStateData = function AnimatorStateData() {
  this.curveOwners = [];
  this.eventHandlers = [];
};

/**
 * @internal
 */
var AnimatorStateInfo = function AnimatorStateInfo() {
  this.layerIndex = void 0;
  this.state = void 0;
};

/**
 * @internal
 */
var CrossCurveData = function CrossCurveData() {
  this.curveOwner = void 0;
  this.srcCurveIndex = void 0;
  this.destCurveIndex = void 0;
};

var _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _class2, _temp;

/**
 * The controller of the animation system.
 */
var Animator = (_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Animator, _Component);

  /**
   * @internal
   */
  function Animator(entity) {
    var _this;

    _this = _Component.call(this, entity) || this;
    _this._animatorController = void 0;

    _initializerDefineProperty(_this, "_speed", _descriptor, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_controllerUpdateFlag", _descriptor2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_animatorLayersData", _descriptor3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_crossCurveDataCollection", _descriptor4, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_animationCurveOwners", _descriptor5, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_crossCurveDataPool", _descriptor6, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_animationEventHandlerPool", _descriptor7, _assertThisInitialized(_this));

    return _this;
  }
  /**
   * Play a state by name.
   * @param stateName - The state name
   * @param layerIndex - The layer index(default -1). If layer is -1, play the first state with the given state name
   * @param normalizedTimeOffset - The time offset between 0 and 1(default 0)
   */


  var _proto = Animator.prototype;

  _proto.play = function play(stateName, layerIndex, normalizedTimeOffset) {
    var _this$_controllerUpda;

    if (layerIndex === void 0) {
      layerIndex = -1;
    }

    if (normalizedTimeOffset === void 0) {
      normalizedTimeOffset = 0;
    }

    if ((_this$_controllerUpda = this._controllerUpdateFlag) !== null && _this$_controllerUpda !== void 0 && _this$_controllerUpda.flag) {
      this._clearPlayData();
    }

    var animatorInfo = this._getAnimatorStateInfo(stateName, layerIndex, Animator._animatorInfo);

    var state = animatorInfo.state;

    if (!state) {
      return;
    }

    if (!state.clip) {
      console.warn("The state named " + stateName + " has no AnimationClip data.");
      return;
    }

    var animatorLayerData = this._getAnimatorLayerData(animatorInfo.layerIndex);

    var srcPlayData = animatorLayerData.srcPlayData;
    var curState = srcPlayData.state;

    if (curState && curState !== state) {
      this._revertDefaultValue(srcPlayData);
    } //CM: Not consider same stateName, but different animation


    var animatorStateData = this._getAnimatorStateData(stateName, state, animatorLayerData);

    animatorLayerData.layerState = LayerState.Playing;
    srcPlayData.reset(state, animatorStateData, state._getDuration() * normalizedTimeOffset);

    this._saveDefaultValues(animatorStateData);
  }
  /**
   * Create a cross fade from the current state to another state.
   * @param stateName - The state name
   * @param normalizedTransitionDuration - The duration of the transition (normalized)
   * @param layerIndex - The layer index(default -1). If layer is -1, play the first state with the given state name
   * @param normalizedTimeOffset - The time offset between 0 and 1(default 0)
   */
  ;

  _proto.crossFade = function crossFade(stateName, normalizedTransitionDuration, layerIndex, normalizedTimeOffset) {
    var _this$_controllerUpda2;

    if (layerIndex === void 0) {
      layerIndex = -1;
    }

    if (normalizedTimeOffset === void 0) {
      normalizedTimeOffset = 0;
    }

    if ((_this$_controllerUpda2 = this._controllerUpdateFlag) !== null && _this$_controllerUpda2 !== void 0 && _this$_controllerUpda2.flag) {
      this._clearPlayData();
    }

    var _this$_getAnimatorSta = this._getAnimatorStateInfo(stateName, layerIndex, Animator._animatorInfo),
        state = _this$_getAnimatorSta.state;

    var _this$_getAnimatorLay = this._getAnimatorLayerData(layerIndex),
        manuallyTransition = _this$_getAnimatorLay.manuallyTransition;

    manuallyTransition.duration = normalizedTransitionDuration;
    manuallyTransition.offset = normalizedTimeOffset;
    manuallyTransition.destinationState = state;

    this._crossFadeByTransition(manuallyTransition, layerIndex);
  }
  /**
   * Evaluates the animator component based on deltaTime.
   * @param deltaTime - The deltaTime when the animation update
   */
  ;

  _proto.update = function update(deltaTime) {
    var _this$_controllerUpda3;

    if (this.speed === 0) {
      return;
    }

    var animatorController = this._animatorController;

    if (!animatorController) {
      return;
    }

    if ((_this$_controllerUpda3 = this._controllerUpdateFlag) !== null && _this$_controllerUpda3 !== void 0 && _this$_controllerUpda3.flag) {
      return;
    }

    deltaTime *= this.speed;

    for (var i = 0, n = animatorController.layers.length; i < n; i++) {
      var animatorLayerData = this._getAnimatorLayerData(i);

      if (animatorLayerData.layerState === LayerState.Standby) {
        continue;
      }

      this._updateLayer(i, i === 0, deltaTime / 1000);
    }
  }
  /**
   * @override
   * @internal
   */
  ;

  _proto._onEnable = function _onEnable() {
    this.engine._componentsManager.addOnUpdateAnimations(this);
  }
  /**
   * @override
   * @internal
   */
  ;

  _proto._onDisable = function _onDisable() {
    this.engine._componentsManager.removeOnUpdateAnimations(this);
  };

  _proto._getAnimatorStateInfo = function _getAnimatorStateInfo(stateName, layerIndex, out) {
    var state = null;
    var animatorController = this._animatorController;

    if (animatorController) {
      var layers = animatorController.layers;

      if (layerIndex === -1) {
        for (var i = 0, n = layers.length; i < n; i++) {
          state = layers[i].stateMachine.findStateByName(stateName);

          if (state) {
            layerIndex = i;
            break;
          }
        }
      } else {
        state = layers[layerIndex].stateMachine.findStateByName(stateName);
      }
    }

    out.layerIndex = layerIndex;
    out.state = state;
    return out;
  };

  _proto._saveDefaultValues = function _saveDefaultValues(stateData) {
    var curveOwners = stateData.curveOwners;

    for (var i = curveOwners.length - 1; i >= 0; i--) {
      curveOwners[i].saveDefaultValue();
    }
  };

  _proto._getAnimatorStateData = function _getAnimatorStateData(stateName, animatorState, animatorLayerData) {
    var animatorStateDataCollection = animatorLayerData.animatorStateDataMap;
    var animatorStateData = animatorStateDataCollection[stateName];

    if (!animatorStateData) {
      animatorStateData = new AnimatorStateData();
      animatorStateDataCollection[stateName] = animatorStateData;

      this._saveAnimatorStateData(animatorState, animatorStateData);

      this._saveAnimatorEventHandlers(animatorState, animatorStateData);
    }

    return animatorStateData;
  };

  _proto._saveAnimatorStateData = function _saveAnimatorStateData(animatorState, animatorStateData) {
    var entity = this.entity,
        animationCureOwners = this._animationCurveOwners;
    var curveOwners = animatorStateData.curveOwners;
    var curves = animatorState.clip._curveBindings;

    for (var i = curves.length - 1; i >= 0; i--) {
      var curve = curves[i];
      var targetEntity = curve.relativePath === "" ? entity : entity.findByPath(curve.relativePath);
      var property = curve.property;
      var instanceId = targetEntity.instanceId;
      var propertyOwners = animationCureOwners[instanceId] || (animationCureOwners[instanceId] = []);
      curveOwners[i] = propertyOwners[property] || (propertyOwners[property] = new AnimationCurveOwner(targetEntity, curve.type, property));
    }
  };

  _proto._saveAnimatorEventHandlers = function _saveAnimatorEventHandlers(state, animatorStateData) {
    var eventHandlerPool = this._animationEventHandlerPool;
    var scripts = this._entity._scripts;
    var scriptCount = scripts.length;
    var eventHandlers = animatorStateData.eventHandlers;
    var events = state.clip.events;
    eventHandlerPool.resetPool();
    eventHandlers.length = 0;

    for (var i = 0, n = events.length; i < n; i++) {
      var event = events[i];
      var eventHandler = eventHandlerPool.getFromPool();
      var funcName = event.functionName;
      var handlers = eventHandler.handlers;
      eventHandler.event = event;
      handlers.length = 0;

      for (var j = scriptCount - 1; j >= 0; j--) {
        var handler = scripts.get(j)[funcName];
        handler && handlers.push(handler);
      }

      eventHandlers.push(eventHandler);
    }
  };

  _proto._clearCrossData = function _clearCrossData(animatorLayerData) {
    animatorLayerData.crossCurveMark++;
    this._crossCurveDataCollection.length = 0;

    this._crossCurveDataPool.resetPool();
  };

  _proto._addCrossCurveData = function _addCrossCurveData(crossCurveData, owner, curCurveIndex, nextCurveIndex) {
    var dataItem = this._crossCurveDataPool.getFromPool();

    dataItem.curveOwner = owner;
    dataItem.srcCurveIndex = curCurveIndex;
    dataItem.destCurveIndex = nextCurveIndex;
    crossCurveData.push(dataItem);
  };

  _proto._prepareCrossFading = function _prepareCrossFading(animatorLayerData) {
    var crossCurveData = this._crossCurveDataCollection;
    var crossCurveMark = animatorLayerData.crossCurveMark; // Add src cross curve data.

    this._prepareSrcCrossData(crossCurveData, animatorLayerData.srcPlayData, crossCurveMark, false); // Add dest cross curve data.


    this._prepareDestCrossData(crossCurveData, animatorLayerData.destPlayData, crossCurveMark, false);
  };

  _proto._prepareStandbyCrossFading = function _prepareStandbyCrossFading(animatorLayerData) {
    var crossCurveData = this._crossCurveDataCollection;
    var srcPlayData = animatorLayerData.srcPlayData,
        crossCurveMark = animatorLayerData.crossCurveMark; // Standby have two sub state, one is never play, one is finished, never play srcPlayData is null.

    srcPlayData && this._prepareSrcCrossData(crossCurveData, srcPlayData, crossCurveMark, true); // Add dest cross curve data.

    this._prepareDestCrossData(crossCurveData, animatorLayerData.destPlayData, crossCurveMark, true);
  };

  _proto._prepareFixedPoseCrossFading = function _prepareFixedPoseCrossFading(animatorLayerData) {
    var crossCurveData = this._crossCurveDataCollection; // Save current cross curve data owner fixed pose.

    for (var i = crossCurveData.length - 1; i >= 0; i--) {
      var item = crossCurveData[i];
      item.curveOwner.saveFixedPoseValue(); // Reset destCurveIndex When fixed pose crossFading again.

      item.destCurveIndex = -1;
    } // prepare dest AnimatorState cross data.


    this._prepareDestCrossData(crossCurveData, animatorLayerData.destPlayData, animatorLayerData.crossCurveMark, true);
  };

  _proto._prepareSrcCrossData = function _prepareSrcCrossData(crossCurveData, srcPlayData, crossCurveMark, saveFixed) {
    var curveOwners = srcPlayData.stateData.curveOwners;

    for (var i = curveOwners.length - 1; i >= 0; i--) {
      var owner = curveOwners[i];
      owner.crossCurveMark = crossCurveMark;
      owner.crossCurveIndex = crossCurveData.length;
      saveFixed && owner.saveFixedPoseValue();

      this._addCrossCurveData(crossCurveData, owner, i, -1);
    }
  };

  _proto._prepareDestCrossData = function _prepareDestCrossData(crossCurveData, destPlayData, crossCurveMark, saveFixed) {
    var curveOwners = destPlayData.stateData.curveOwners;

    for (var i = curveOwners.length - 1; i >= 0; i--) {
      var owner = curveOwners[i]; // Not include in previous AnimatorState.

      if (owner.crossCurveMark === crossCurveMark) {
        crossCurveData[owner.crossCurveIndex].destCurveIndex = i;
      } else {
        saveFixed && owner.saveFixedPoseValue();
        owner.crossCurveMark = crossCurveMark;
        owner.crossCurveIndex = crossCurveData.length;

        this._addCrossCurveData(crossCurveData, owner, -1, i);
      }
    }
  };

  _proto._evaluateCurve = function _evaluateCurve(property, curve, time, additive) {
    var value = curve.evaluate(time);

    if (additive) {
      var baseValue = curve.keys[0].value;

      switch (property) {
        case AnimationProperty.Position:
          var pos = Animator._tempVector3;
          Vector3.subtract(value, baseValue, pos);
          return pos;

        case AnimationProperty.Rotation:
          var rot = Animator._tempQuaternion;
          Quaternion.conjugate(baseValue, rot);
          Quaternion.multiply(rot, value, rot);
          return rot;

        case AnimationProperty.Scale:
          var scale = Animator._tempVector3;
          Vector3.divide(value, baseValue, scale);
          return scale;
      }
    }

    return value;
  };

  _proto._getAnimatorLayerData = function _getAnimatorLayerData(layerIndex) {
    var animatorLayerData = this._animatorLayersData[layerIndex];
    animatorLayerData || (this._animatorLayersData[layerIndex] = animatorLayerData = new AnimatorLayerData());
    return animatorLayerData;
  };

  _proto._updateLayer = function _updateLayer(layerIndex, firstLayer, deltaTime) {
    var _this$_animatorContro = this._animatorController.layers[layerIndex],
        blendingMode = _this$_animatorContro.blendingMode,
        weight = _this$_animatorContro.weight;
    var animLayerData = this._animatorLayersData[layerIndex];
    var srcPlayData = animLayerData.srcPlayData,
        destPlayData = animLayerData.destPlayData,
        crossFadeTransitionInfo = animLayerData.crossFadeTransition;
    var layerAdditive = blendingMode === AnimatorLayerBlendingMode.Additive;
    var layerWeight = firstLayer ? 1.0 : weight;

    this._checkTransition(srcPlayData, crossFadeTransitionInfo, layerIndex);

    switch (animLayerData.layerState) {
      case LayerState.Playing:
        this._updatePlayingState(srcPlayData, animLayerData, layerWeight, deltaTime, layerAdditive);

        break;

      case LayerState.FixedCrossFading:
        this._updateCrossFadeFromPose(destPlayData, animLayerData, layerWeight, deltaTime, layerAdditive);

        break;

      case LayerState.CrossFading:
        this._updateCrossFade(srcPlayData, destPlayData, animLayerData, layerWeight, deltaTime, layerAdditive);

        break;
    }
  };

  _proto._updatePlayingState = function _updatePlayingState(playData, layerData, weight, delta, additive) {
    var _playData$stateData = playData.stateData,
        curveOwners = _playData$stateData.curveOwners,
        eventHandlers = _playData$stateData.eventHandlers;
    var state = playData.state;
    var curves = state.clip._curveBindings;
    var lastClipTime = playData.clipTime;
    playData.update();
    var clipTime = playData.clipTime;
    eventHandlers.length && this._fireAnimationEvents(playData, eventHandlers, lastClipTime, clipTime);

    for (var i = curves.length - 1; i >= 0; i--) {
      var owner = curveOwners[i];

      var value = this._evaluateCurve(owner.property, curves[i].curve, clipTime, additive);

      if (additive) {
        this._applyClipValueAdditive(owner, value, weight);
      } else {
        this._applyClipValue(owner, value, weight);
      }
    }

    playData.frameTime += state.speed * delta;

    if (playData.finished) {
      layerData.layerState = LayerState.Standby;
    }
  };

  _proto._updateCrossFade = function _updateCrossFade(srcPlayData, destPlayData, layerData, weight, delta, additive) {
    var crossCurveDataCollection = this._crossCurveDataCollection;
    var srcCurves = srcPlayData.state.clip._curveBindings;
    var destState = destPlayData.state;
    var destCurves = destState.clip._curveBindings;
    var crossWeight = destPlayData.frameTime / (destState._getDuration() * layerData.crossFadeTransition.duration);
    crossWeight >= 1.0 && (crossWeight = 1.0);
    srcPlayData.update();
    destPlayData.update();
    var srcClipTime = srcPlayData.clipTime;
    var destClipTime = destPlayData.clipTime;

    for (var i = crossCurveDataCollection.length - 1; i >= 0; i--) {
      var _crossCurveDataCollec = crossCurveDataCollection[i],
          curveOwner = _crossCurveDataCollec.curveOwner,
          srcCurveIndex = _crossCurveDataCollec.srcCurveIndex,
          destCurveIndex = _crossCurveDataCollec.destCurveIndex;
      var property = curveOwner.property,
          defaultValue = curveOwner.defaultValue;
      var srcValue = srcCurveIndex >= 0 ? this._evaluateCurve(property, srcCurves[srcCurveIndex].curve, srcClipTime, additive) : defaultValue;
      var destValue = destCurveIndex >= 0 ? this._evaluateCurve(property, destCurves[destCurveIndex].curve, destClipTime, additive) : defaultValue;

      this._applyCrossClipValue(curveOwner, srcValue, destValue, crossWeight, weight, additive);
    }

    this._updateCrossFadeData(layerData, crossWeight, delta, false);
  };

  _proto._updateCrossFadeFromPose = function _updateCrossFadeFromPose(destPlayData, layerData, weight, delta, additive) {
    var crossCurveDataCollection = this._crossCurveDataCollection;
    var destState = destPlayData.state;
    var curves = destState.clip._curveBindings;
    var crossWeight = destPlayData.frameTime / (destState._getDuration() * layerData.crossFadeTransition.duration);
    crossWeight >= 1.0 && (crossWeight = 1.0);
    destPlayData.update();
    var destClipTime = destPlayData.clipTime;

    for (var i = crossCurveDataCollection.length - 1; i >= 0; i--) {
      var _crossCurveDataCollec2 = crossCurveDataCollection[i],
          curveOwner = _crossCurveDataCollec2.curveOwner,
          destCurveIndex = _crossCurveDataCollec2.destCurveIndex;
      var destValue = destCurveIndex >= 0 ? this._evaluateCurve(curveOwner.property, curves[destCurveIndex].curve, destClipTime, additive) : curveOwner.defaultValue;

      this._applyCrossClipValue(curveOwner, curveOwner.fixedPoseValue, destValue, crossWeight, weight, additive);
    }

    this._updateCrossFadeData(layerData, crossWeight, delta, true);
  };

  _proto._updateCrossFadeData = function _updateCrossFadeData(layerData, crossWeight, delta, fixed) {
    var destPlayData = layerData.destPlayData;
    destPlayData.frameTime += destPlayData.state.speed * delta;

    if (crossWeight === 1.0) {
      if (destPlayData.finished) {
        layerData.layerState = LayerState.Standby;
      } else {
        layerData.layerState = LayerState.Playing;
      }

      layerData.switchPlayData();
    } else {
      fixed || (layerData.srcPlayData.frameTime += layerData.srcPlayData.state.speed * delta);
    }
  };

  _proto._applyCrossClipValue = function _applyCrossClipValue(owner, srcValue, destValue, crossWeight, layerWeight, additive) {
    var value;

    if (owner.type === Transform) {
      var transform = owner.target.transform;

      switch (owner.property) {
        case AnimationProperty.Position:
          Vector3.lerp(srcValue, destValue, crossWeight, Animator._tempVector3);
          value = Animator._tempVector3;
          break;

        case AnimationProperty.Rotation:
          Quaternion.slerp(srcValue, destValue, crossWeight, Animator._tempQuaternion);
          value = Animator._tempQuaternion;
          break;

        case AnimationProperty.Scale:
          {
            var scale = transform.scale;
            Vector3.lerp(srcValue, destValue, crossWeight, Animator._tempVector3);
            transform.scale = scale;
            value = Animator._tempVector3;
            break;
          }
      }
    }

    if (additive) {
      this._applyClipValueAdditive(owner, value, layerWeight);
    } else {
      this._applyClipValue(owner, value, layerWeight);
    }
  };

  _proto._applyClipValue = function _applyClipValue(owner, value, weight) {
    if (owner.type === Transform) {
      var transform = owner.target.transform;

      switch (owner.property) {
        case AnimationProperty.Position:
          if (weight === 1.0) {
            transform.position = value;
          } else {
            var position = transform.position;
            Vector3.lerp(position, value, weight, position);
            transform.position = position;
          }

          break;

        case AnimationProperty.Rotation:
          if (weight === 1.0) {
            transform.rotationQuaternion = value;
          } else {
            var rotationQuaternion = transform.rotationQuaternion;
            Quaternion.slerp(rotationQuaternion, value, weight, rotationQuaternion);
            transform.rotationQuaternion = rotationQuaternion;
          }

          break;

        case AnimationProperty.Scale:
          if (weight === 1.0) {
            transform.scale = value;
          } else {
            var scale = transform.scale;
            Vector3.lerp(scale, value, weight, scale);
            transform.scale = scale;
          }

          break;
      }
    } else if (owner.type === SkinnedMeshRenderer) {
      switch (owner.property) {
        case AnimationProperty.BlendShapeWeights:
          owner.component.blendShapeWeights = value;
          break;
      }
    }
  };

  _proto._applyClipValueAdditive = function _applyClipValueAdditive(owner, additiveValue, weight) {
    if (owner.type === Transform) {
      var transform = owner.target.transform;

      switch (owner.property) {
        case AnimationProperty.Position:
          var position = transform.position;
          position.x += additiveValue.x * weight;
          position.y += additiveValue.y * weight;
          position.z += additiveValue.z * weight;
          transform.position = position;
          break;

        case AnimationProperty.Rotation:
          var rotationQuaternion = transform.rotationQuaternion;
          AnimatorUtils.quaternionWeight(additiveValue, weight, additiveValue);
          additiveValue.normalize();
          rotationQuaternion.multiply(additiveValue);
          transform.rotationQuaternion = rotationQuaternion;
          break;

        case AnimationProperty.Scale:
          var scale = transform.scale;
          AnimatorUtils.scaleWeight(scale, weight, scale);
          Vector3.multiply(scale, additiveValue, scale);
          transform.scale = scale;
          break;
      }
    }
  };

  _proto._revertDefaultValue = function _revertDefaultValue(playData) {
    var clip = playData.state.clip;

    if (clip) {
      var curves = clip._curveBindings;
      var curveOwners = playData.stateData.curveOwners;

      for (var i = curves.length - 1; i >= 0; i--) {
        var owner = curveOwners[i];
        var transform = owner.target.transform;

        switch (owner.property) {
          case AnimationProperty.Position:
            transform.position = owner.defaultValue;
            break;

          case AnimationProperty.Rotation:
            transform.rotationQuaternion = owner.defaultValue;
            break;

          case AnimationProperty.Scale:
            transform.scale = owner.defaultValue;
            break;
        }
      }
    }
  };

  _proto._checkTransition = function _checkTransition(stateData, crossFadeTransition, layerIndex) {
    var state = stateData.state,
        clipTime = stateData.clipTime;

    var duration = state._getDuration();

    var transitions = state.transitions;

    for (var i = 0, n = transitions.length; i < n; ++i) {
      var transition = transitions[i];

      if (duration * transition.exitTime <= clipTime) {
        crossFadeTransition !== transition && this._crossFadeByTransition(transition, layerIndex);
      }
    }
  };

  _proto._crossFadeByTransition = function _crossFadeByTransition(transition, layerIndex) {
    var name = transition.destinationState.name;

    var animatorStateInfo = this._getAnimatorStateInfo(name, layerIndex, Animator._animatorInfo);

    var crossState = animatorStateInfo.state;

    if (!crossState) {
      return;
    }

    if (!crossState.clip) {
      console.warn("The state named " + name + " has no AnimationClip data.");
      return;
    }

    var animatorLayerData = this._getAnimatorLayerData(animatorStateInfo.layerIndex);

    var layerState = animatorLayerData.layerState;
    var destPlayData = animatorLayerData.destPlayData;

    var animatorStateData = this._getAnimatorStateData(name, crossState, animatorLayerData);

    var duration = crossState._getDuration();

    var offset = duration * transition.offset;
    destPlayData.reset(crossState, animatorStateData, offset);

    this._saveDefaultValues(animatorStateData);

    switch (layerState) {
      // Maybe not play, maybe end.
      case LayerState.Standby:
        animatorLayerData.layerState = LayerState.FixedCrossFading;

        this._clearCrossData(animatorLayerData);

        this._prepareStandbyCrossFading(animatorLayerData);

        break;

      case LayerState.Playing:
        animatorLayerData.layerState = LayerState.CrossFading;

        this._clearCrossData(animatorLayerData);

        this._prepareCrossFading(animatorLayerData);

        break;

      case LayerState.CrossFading:
        animatorLayerData.layerState = LayerState.FixedCrossFading;

        this._prepareFixedPoseCrossFading(animatorLayerData);

        break;

      case LayerState.FixedCrossFading:
        this._prepareFixedPoseCrossFading(animatorLayerData);

        break;
    }

    animatorLayerData.crossFadeTransition = transition;
  };

  _proto._fireAnimationEvents = function _fireAnimationEvents(playState, eventHandlers, lastClipTime, clipTime) {
    // TODO: If play backward, not work.
    if (clipTime < lastClipTime) {
      this._fireSubAnimationEvents(playState, eventHandlers, lastClipTime, playState.state.clipEndTime);

      playState.currentEventIndex = 0;

      this._fireSubAnimationEvents(playState, eventHandlers, playState.state.clipStartTime, clipTime);
    } else {
      this._fireSubAnimationEvents(playState, eventHandlers, lastClipTime, clipTime);
    }
  };

  _proto._fireSubAnimationEvents = function _fireSubAnimationEvents(playState, eventHandlers, lastClipTime, curClipTime) {
    for (var i = playState.currentEventIndex, n = eventHandlers.length; i < n; i++) {
      var eventHandler = eventHandlers[i];
      var _eventHandler$event = eventHandler.event,
          time = _eventHandler$event.time,
          parameter = _eventHandler$event.parameter;

      if (time > curClipTime) {
        break;
      }

      var handlers = eventHandler.handlers;

      if (time >= lastClipTime) {
        for (var j = handlers.length - 1; j >= 0; j--) {
          handlers[j](parameter);
        }

        playState.currentEventIndex = i + 1;
      }
    }
  };

  _proto._clearPlayData = function _clearPlayData() {
    this._animatorLayersData.length = 0;
    this._crossCurveDataCollection.length = 0;
    this._animationCurveOwners.length = 0;
    this._controllerUpdateFlag.flag = false;
  };

  _createClass(Animator, [{
    key: "speed",
    get:
    /**
     * The playback speed of the Animator, 1.0 is normal playback speed.
     */
    function get() {
      return this._speed;
    },
    set: function set(value) {
      this._speed = value;
    }
    /**
     * All layers from the AnimatorController which belongs this Animator.
     */

  }, {
    key: "animatorController",
    get: function get() {
      return this._animatorController;
    },
    set: function set(animatorController) {
      if (animatorController !== this._animatorController) {
        this._controllerUpdateFlag && this._controllerUpdateFlag.destroy();
        this._controllerUpdateFlag = animatorController && animatorController._registerChangeFlag();
        this._animatorController = animatorController;
      }
    }
  }]);

  return Animator;
}(Component), _class2._tempVector3 = new Vector3(), _class2._tempQuaternion = new Quaternion(), _class2._animatorInfo = new AnimatorStateInfo(), _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, "_speed", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 1.0;
  }
}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "_controllerUpdateFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, "_animatorLayersData", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, "_crossCurveDataCollection", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, "_animationCurveOwners", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, "_crossCurveDataPool", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new ClassPool(CrossCurveData);
  }
}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, "_animationEventHandlerPool", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new ClassPool(AnimationEventHandler);
  }
})), _class);

/**
 * Store the data for Animator playback.
 */
var AnimatorController = /*#__PURE__*/function () {
  function AnimatorController() {
    this._updateFlagManager = new UpdateFlagManager();
    this._layers = [];
    this._layersMap = {};
  }

  var _proto = AnimatorController.prototype;

  /**
   * Get the layer by name.
   * @param name - The layer's name.
   */
  _proto.findLayerByName = function findLayerByName(name) {
    return this._layersMap[name];
  }
  /**
   * Add a layer to the controller.
   * @param layer - The layer to add
   */
  ;

  _proto.addLayer = function addLayer(layer) {
    this._layers.push(layer);

    this._layersMap[layer.name] = layer;

    this._distributeUpdateFlag();
  }
  /**
   * Remove a layer from the controller.
   * @param layerIndex - The index of the AnimatorLayer
   */
  ;

  _proto.removeLayer = function removeLayer(layerIndex) {
    var theLayer = this.layers[layerIndex];

    this._layers.splice(layerIndex, 1);

    delete this._layersMap[theLayer.name];

    this._distributeUpdateFlag();
  }
  /**
   * Clear layers.
   */
  ;

  _proto.clearLayers = function clearLayers() {
    this._layers.length = 0;

    for (var name in this._layersMap) {
      delete this._layersMap[name];
    }

    this._distributeUpdateFlag();
  }
  /**
   * @internal
   */
  ;

  _proto._registerChangeFlag = function _registerChangeFlag() {
    return this._updateFlagManager.register();
  };

  _proto._distributeUpdateFlag = function _distributeUpdateFlag() {
    this._updateFlagManager.distribute();
  };

  _createClass(AnimatorController, [{
    key: "layers",
    get:
    /**
     * The layers in the controller.
     */
    function get() {
      return this._layers;
    }
  }]);

  return AnimatorController;
}();

/**
 * The Animation Layer contains a state machine that controls animations of a model or part of it.
 */

var AnimatorControllerLayer =
/** The blending weight that the layers has. It is not taken into account for the first layer. */

/** The blending mode used by the layer. It is not taken into account for the first layer. */

/** The state machine for the layer. */

/**
 * @param name - The layer's name
 */
function AnimatorControllerLayer(name) {
  this.name = name;
  this.weight = 1.0;
  this.blendingMode = AnimatorLayerBlendingMode.Override;
  this.stateMachine = void 0;
};

/**
 * States are the basic building blocks of a state machine. Each state contains a AnimationClip which will play while the character is in that state.
 */

var AnimatorState = /*#__PURE__*/function () {
  /**
   * @param name - The state's name
   */
  function AnimatorState(name) {
    this.name = name;
    this.speed = 1.0;
    this.wrapMode = WrapMode.Loop;
    this._clipStartTime = 0;
    this._clipEndTime = Infinity;
    this._clip = void 0;
    this._transitions = [];
  }
  /**
   * Add an outgoing transition to the destination state.
   * @param transition - The transition
   */


  var _proto = AnimatorState.prototype;

  _proto.addTransition = function addTransition(transition) {
    this._transitions.push(transition);
  }
  /**
   * Remove a transition from the state.
   * @param transition - The transition
   */
  ;

  _proto.removeTransition = function removeTransition(transition) {
    var index = this._transitions.indexOf(transition);

    index !== -1 && this._transitions.splice(index, 1);
  }
  /**
   * Clears all transitions from the state.
   */
  ;

  _proto.clearTransitions = function clearTransitions() {
    this._transitions.length = 0;
  }
  /**
   * @internal
   */
  ;

  _proto._getDuration = function _getDuration() {
    return this._clipEndTime - this._clipStartTime;
  };

  _createClass(AnimatorState, [{
    key: "transitions",
    get:
    /** The speed of the clip. 1 is normal speed, default 1. */

    /** The wrap mode used in the state. */

    /**
     * The transitions that are going out of the state.
     */
    function get() {
      return this._transitions;
    }
    /**
     * Æ’The clip that is being played by this animator state.
     */

  }, {
    key: "clip",
    get: function get() {
      return this._clip;
    },
    set: function set(clip) {
      this._clip = clip;
      this._clipEndTime = Math.min(this._clipEndTime, clip.length);
    }
    /**
     * The clip start time the user set , default is 0.
     */

  }, {
    key: "clipStartTime",
    get: function get() {
      return this._clipStartTime;
    },
    set: function set(time) {
      this._clipStartTime = time < 0 ? 0 : time;
    }
    /**
     * The clip end time the user set , default is the clip duration.
     */

  }, {
    key: "clipEndTime",
    get: function get() {
      return this._clipEndTime;
    },
    set: function set(time) {
      var clip = this._clip;

      if (clip) {
        this._clipEndTime = Math.min(time, clip.length);
      }
    }
  }]);

  return AnimatorState;
}();

/**
 * A graph controlling the interaction of states. Each state references a motion.
 */
var AnimatorStateMachine = /*#__PURE__*/function () {
  function AnimatorStateMachine() {
    this.states = [];
    this._statesMap = {};
  }

  var _proto = AnimatorStateMachine.prototype;

  /**
   * Add a state to the state machine.
   * @param name - The name of the new state
   */
  _proto.addState = function addState(name) {
    var state = this.findStateByName(name);

    if (!state) {
      state = new AnimatorState(name);
      this.states.push(state);
      this._statesMap[name] = state;
    } else {
      console.warn("The state named " + name + " has existed.");
    }

    return state;
  }
  /**
   * Remove a state from the state machine.
   * @param state - The state
   */
  ;

  _proto.removeState = function removeState(state) {
    var name = state.name;
    var index = this.states.indexOf(state);

    if (index > -1) {
      this.states.splice(index, 1);
    }

    delete this._statesMap[name];
  }
  /**
   * Get the state by name.
   * @param name - The layer's name
   */
  ;

  _proto.findStateByName = function findStateByName(name) {
    return this._statesMap[name];
  }
  /**
   * Makes a unique state name in the state machine.
   * @param name - Desired name for the state.
   * @returns Unique name.
   */
  ;

  _proto.makeUniqueStateName = function makeUniqueStateName(name) {
    var _statesMap = this._statesMap;
    var originName = name;
    var index = 0;

    while (_statesMap[name]) {
      name = originName + " " + index;
      index++;
    }

    return name;
  };

  return AnimatorStateMachine;
}();

var InterpolableValueType;

(function (InterpolableValueType) {
  InterpolableValueType[InterpolableValueType["Float"] = 0] = "Float";
  InterpolableValueType[InterpolableValueType["FloatArray"] = 1] = "FloatArray";
  InterpolableValueType[InterpolableValueType["Vector2"] = 2] = "Vector2";
  InterpolableValueType[InterpolableValueType["Vector3"] = 3] = "Vector3";
  InterpolableValueType[InterpolableValueType["Vector4"] = 4] = "Vector4";
  InterpolableValueType[InterpolableValueType["Quaternion"] = 5] = "Quaternion";
})(InterpolableValueType || (InterpolableValueType = {}));

/**
 * Animation interpolation method.
 */
var InterpolationType;

(function (InterpolationType) {
  InterpolationType[InterpolationType["Linear"] = 0] = "Linear";
  InterpolationType[InterpolationType["CubicSpine"] = 1] = "CubicSpine";
  InterpolationType[InterpolationType["Step"] = 2] = "Step";
  InterpolationType[InterpolationType["Hermite"] = 3] = "Hermite";
})(InterpolationType || (InterpolationType = {}));

/**
 * Store a collection of Keyframes that can be evaluated over time.
 */
var AnimationCurve = /*#__PURE__*/function () {
  function AnimationCurve() {
    this.keys = [];
    this.interpolation = void 0;
    this._valueSize = void 0;
    this._valueType = void 0;
    this._currentValue = void 0;
    this._length = 0;
    this._currentIndex = 0;
  }

  var _proto = AnimationCurve.prototype;

  /**
   * Add a new key to the curve.
   * @param key - The keyframe
   */
  _proto.addKey = function addKey(key) {
    var time = key.time;
    this.keys.push(key);

    if (time > this._length) {
      this._length = time;
    }

    if (!this._valueSize) {
      //CM: It's not reasonable to write here.
      if (typeof key.value == "number") {
        this._valueSize = 1;
        this._valueType = InterpolableValueType.Float;
        this._currentValue = 0;
      }

      if (key.value instanceof Vector2) {
        this._valueSize = 2;
        this._valueType = InterpolableValueType.Vector2;
        this._currentValue = new Vector2();
      }

      if (key.value instanceof Vector3) {
        this._valueSize = 3;
        this._valueType = InterpolableValueType.Vector3;
        this._currentValue = new Vector3();
      }

      if (key.value instanceof Vector4) {
        this._valueSize = 4;
        this._valueType = InterpolableValueType.Vector4;
        this._currentValue = new Vector4();
      }

      if (key.value instanceof Quaternion) {
        this._valueSize = 4;
        this._valueType = InterpolableValueType.Quaternion;
        this._currentValue = new Quaternion();
      }

      if (key.value instanceof Float32Array) {
        var size = key.value.length;
        this._valueSize = size;
        this._valueType = InterpolableValueType.FloatArray;
        this._currentValue = new Float32Array(size);
      }
    }

    this.keys.sort(function (a, b) {
      return a.time - b.time;
    });
  }
  /**
   * Evaluate the curve at time.
   * @param time - The time within the curve you want to evaluate
   */
  ;

  _proto.evaluate = function evaluate(time) {
    var keys = this.keys,
        interpolation = this.interpolation;
    var length = this.keys.length; // Compute curIndex and nextIndex.

    var curIndex = this._currentIndex; // Reset loop.

    if (curIndex !== -1 && time < keys[curIndex].time) {
      curIndex = -1;
    }

    var nextIndex = curIndex + 1;

    while (nextIndex < length) {
      if (time < keys[nextIndex].time) {
        break;
      }

      curIndex++;
      nextIndex++;
    }

    this._currentIndex = curIndex; // Evaluate value.

    var value;

    if (curIndex === -1) {
      value = keys[0].value;
    } else if (nextIndex === length) {
      value = keys[curIndex].value;
    } else {
      // Time between first frame and end frame.
      var curFrameTime = keys[curIndex].time;
      var duration = keys[nextIndex].time - curFrameTime;
      var t = (time - curFrameTime) / duration;
      var dur = duration;

      switch (interpolation) {
        case InterpolationType.Linear:
          value = this._evaluateLinear(curIndex, nextIndex, t);
          break;

        case InterpolationType.Step:
          value = this._evaluateStep(nextIndex);
          break;

        case InterpolationType.CubicSpine:
        case InterpolationType.Hermite:
          value = this._evaluateHermite(curIndex, nextIndex, t, dur);
      }
    }

    return value;
  }
  /**
   * Removes the keyframe at index and inserts key.
   * @param index - The index of the key to move
   * @param key - The key to insert
   */
  ;

  _proto.moveKey = function moveKey(index, key) {
    this.keys[index] = key;
  }
  /**
   * Removes a key.
   * @param index - The index of the key to remove
   */
  ;

  _proto.removeKey = function removeKey(index) {
    this.keys.splice(index, 1);
    var keys = this.keys;
    var count = this.keys.length;
    var newLength = 0;

    for (var i = count - 1; i >= 0; i--) {
      if (keys[i].time > length) {
        newLength = keys[i].time;
      }
    }

    this._length = newLength;
  };

  _proto._evaluateLinear = function _evaluateLinear(frameIndex, nextFrameIndex, t) {
    var _valueType = this._valueType,
        keys = this.keys;

    switch (_valueType) {
      case InterpolableValueType.Float:
        return keys[frameIndex].value * (1 - t) + keys[nextFrameIndex].value * t;

      case InterpolableValueType.FloatArray:
        var curValue = this._currentValue;
        var value = keys[frameIndex].value;
        var nextValue = keys[nextFrameIndex].value;

        for (var i = 0, n = value.length; i < n; i++) {
          curValue[i] = value[i] * (1 - t) + nextValue[i] * t;
        }

        return curValue;

      case InterpolableValueType.Vector2:
        Vector2.lerp(keys[frameIndex].value, keys[nextFrameIndex].value, t, this._currentValue);
        return this._currentValue;

      case InterpolableValueType.Vector3:
        Vector3.lerp(keys[frameIndex].value, keys[nextFrameIndex].value, t, this._currentValue);
        return this._currentValue;

      case InterpolableValueType.Quaternion:
        Quaternion.slerp(keys[frameIndex].value, keys[nextFrameIndex].value, t, this._currentValue);
        return this._currentValue;
    }
  };

  _proto._evaluateStep = function _evaluateStep(nextFrameIndex) {
    var _valueSize = this._valueSize,
        keys = this.keys;

    if (_valueSize === 1) {
      return keys[nextFrameIndex].value;
    } else {
      return keys[nextFrameIndex].value;
    }
  };

  _proto._evaluateHermite = function _evaluateHermite(frameIndex, nextFrameIndex, t, dur) {
    var _valueSize = this._valueSize,
        keys = this.keys;
    var curKey = keys[frameIndex];
    var nextKey = keys[nextFrameIndex];

    switch (_valueSize) {
      case 1:
        {
          var t0 = curKey.outTangent,
              t1 = nextKey.inTangent,
              p0 = curKey.value,
              p1 = nextKey.value;

          if (Number.isFinite(t0) && Number.isFinite(t1)) {
            var t2 = t * t;
            var t3 = t2 * t;
            var a = 2.0 * t3 - 3.0 * t2 + 1.0;
            var b = t3 - 2.0 * t2 + t;
            var c = t3 - t2;
            var d = -2.0 * t3 + 3.0 * t2;
            return a * p0 + b * t0 * dur + c * t1 * dur + d * p1;
          } else {
            return curKey.value;
          }
        }

      case 2:
        {
          var _p = curKey.value;
          var tan0 = curKey.outTangent;
          var _p2 = nextKey.value;
          var tan1 = nextKey.inTangent;

          var _t = t * t;

          var _t2 = _t * t;

          var _a = 2.0 * _t2 - 3.0 * _t + 1.0;

          var _b = _t2 - 2.0 * _t + t;

          var _c = _t2 - _t;

          var _d = -2.0 * _t2 + 3.0 * _t;

          var _t3 = tan0.x,
              _t4 = tan1.x;

          if (Number.isFinite(_t3) && Number.isFinite(_t4)) {
            this._currentValue.x = _a * _p.x + _b * _t3 * dur + _c * _t4 * dur + _d * _p2.x;
          } else {
            this._currentValue.x = _p.x;
          }

          _t3 = tan0.y, _t4 = tan1.y;
          if (Number.isFinite(_t3) && Number.isFinite(_t4)) this._currentValue.y = _a * _p.y + _b * _t3 * dur + _c * _t4 * dur + _d * _p2.y;else {
            this._currentValue.y = _p.y;
          }
          return this._currentValue;
        }

      case 3:
        {
          var _p3 = curKey.value;
          var _tan = curKey.outTangent;
          var _p4 = nextKey.value;
          var _tan2 = nextKey.inTangent;

          var _t5 = t * t;

          var _t6 = _t5 * t;

          var _a2 = 2.0 * _t6 - 3.0 * _t5 + 1.0;

          var _b2 = _t6 - 2.0 * _t5 + t;

          var _c2 = _t6 - _t5;

          var _d2 = -2.0 * _t6 + 3.0 * _t5;

          var _t7 = _tan.x,
              _t8 = _tan2.x;

          if (Number.isFinite(_t7) && Number.isFinite(_t8)) {
            this._currentValue.x = _a2 * _p3.x + _b2 * _t7 * dur + _c2 * _t8 * dur + _d2 * _p4.x;
          } else {
            this._currentValue.x = _p3.x;
          }

          _t7 = _tan.y, _t8 = _tan2.y;

          if (Number.isFinite(_t7) && Number.isFinite(_t8)) {
            this._currentValue.y = _a2 * _p3.y + _b2 * _t7 * dur + _c2 * _t8 * dur + _d2 * _p4.y;
          } else {
            this._currentValue.y = _p3.y;
          }

          _t7 = _tan.z, _t8 = _tan2.z;

          if (Number.isFinite(_t7) && Number.isFinite(_t8)) {
            this._currentValue.z = _a2 * _p3.z + _b2 * _t7 * dur + _c2 * _t8 * dur + _d2 * _p4.z;
          } else {
            this._currentValue.z = _p3.z;
          }

          return this._currentValue;
        }

      case 4:
        {
          var _p5 = curKey.value;
          var _tan3 = curKey.outTangent;
          var _p6 = nextKey.value;
          var _tan4 = nextKey.inTangent;

          var _t9 = t * t;

          var _t10 = _t9 * t;

          var _a3 = 2.0 * _t10 - 3.0 * _t9 + 1.0;

          var _b3 = _t10 - 2.0 * _t9 + t;

          var _c3 = _t10 - _t9;

          var _d3 = -2.0 * _t10 + 3.0 * _t9;

          var _t11 = _tan3.x,
              _t12 = _tan4.x;

          if (Number.isFinite(_t11) && Number.isFinite(_t12)) {
            this._currentValue.x = _a3 * _p5.x + _b3 * _t11 * dur + _c3 * _t12 * dur + _d3 * _p6.x;
          } else {
            this._currentValue.x = _p5.x;
          }

          _t11 = _tan3.y, _t12 = _tan4.y;

          if (Number.isFinite(_t11) && Number.isFinite(_t12)) {
            this._currentValue.y = _a3 * _p5.y + _b3 * _t11 * dur + _c3 * _t12 * dur + _d3 * _p6.y;
          } else {
            this._currentValue.y = _p5.y;
          }

          _t11 = _tan3.z, _t12 = _tan4.z;

          if (Number.isFinite(_t11) && Number.isFinite(_t12)) {
            this._currentValue.z = _a3 * _p5.z + _b3 * _t11 * dur + _c3 * _t12 * dur + _d3 * _p6.z;
          } else {
            this._currentValue.z = _p5.z;
          }

          _t11 = _tan3.w, _t12 = _tan4.w;

          if (Number.isFinite(_t11) && Number.isFinite(_t12)) {
            this._currentValue.w = _a3 * _p5.w + _b3 * _t11 * dur + _c3 * _t12 * dur + _d3 * _p6.w;
          } else {
            this._currentValue.w = _p5.w;
          }

          return this._currentValue;
        }
    }
  };

  _createClass(AnimationCurve, [{
    key: "length",
    get:
    /**
     * Animation curve length in seconds.
     */
    function get() {
      return this._length;
    }
  }]);

  return AnimationCurve;
}();

/**
 * Keyframe.
 * @typeParam V - Type of Keyframe value
 */
var Keyframe = function Keyframe() {
  this.time = void 0;
  this.value = void 0;
};
/**
 * InterpolableKeyframe.
 * @typeParam T - Type of Tangent value
 * @typeParam V - Type of Keyframe value
 */

var InterpolableKeyframe = /*#__PURE__*/function (_Keyframe) {
  _inheritsLoose(InterpolableKeyframe, _Keyframe);

  function InterpolableKeyframe() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Keyframe.call.apply(_Keyframe, [this].concat(args)) || this;
    _this.inTangent = void 0;
    _this.outTangent = void 0;
    return _this;
  }

  return InterpolableKeyframe;
}(Keyframe);

/**
 * AnimationEvent lets you call a script function similar to SendMessage as part of playing back an animation.
 */
var AnimationEvent = function AnimationEvent() {
  this.time = void 0;
  this.functionName = void 0;
  this.parameter = void 0;
};

var AnimatorConditionMode;

(function (AnimatorConditionMode) {
  AnimatorConditionMode[AnimatorConditionMode["If"] = 0] = "If";
  AnimatorConditionMode[AnimatorConditionMode["IfNot"] = 1] = "IfNot";
  AnimatorConditionMode[AnimatorConditionMode["Greater"] = 2] = "Greater";
  AnimatorConditionMode[AnimatorConditionMode["Less"] = 3] = "Less";
  AnimatorConditionMode[AnimatorConditionMode["Equals"] = 4] = "Equals";
  AnimatorConditionMode[AnimatorConditionMode["NotEquals"] = 5] = "NotEquals";
})(AnimatorConditionMode || (AnimatorConditionMode = {}));

/**
 * SkyboxMaterial
 */
var SkyBoxMaterial = /*#__PURE__*/function (_Material) {
  _inheritsLoose(SkyBoxMaterial, _Material);

  function SkyBoxMaterial(engine) {
    var _this;

    _this = _Material.call(this, engine, Shader.find("skybox")) || this;
    _this.renderState.rasterState.cullMode = CullMode.Off;
    _this.renderState.depthState.compareFunction = CompareFunction.LessEqual;
    return _this;
  }
  /** Texture cube map of the sky box material. */


  _createClass(SkyBoxMaterial, [{
    key: "textureCubeMap",
    get: function get() {
      return this.shaderData.getTexture("u_cube");
    },
    set: function set(v) {
      this.shaderData.setTexture("u_cube", v);
    }
  }]);

  return SkyBoxMaterial;
}(Material);

var DirtyFlagType;
/**
 * Blend mode enums of the particle renderer's material.
 */

(function (DirtyFlagType) {
  DirtyFlagType[DirtyFlagType["Position"] = 1] = "Position";
  DirtyFlagType[DirtyFlagType["Velocity"] = 2] = "Velocity";
  DirtyFlagType[DirtyFlagType["Acceleration"] = 4] = "Acceleration";
  DirtyFlagType[DirtyFlagType["Color"] = 8] = "Color";
  DirtyFlagType[DirtyFlagType["Alpha"] = 16] = "Alpha";
  DirtyFlagType[DirtyFlagType["Size"] = 32] = "Size";
  DirtyFlagType[DirtyFlagType["StartAngle"] = 64] = "StartAngle";
  DirtyFlagType[DirtyFlagType["StartTime"] = 128] = "StartTime";
  DirtyFlagType[DirtyFlagType["LifeTime"] = 256] = "LifeTime";
  DirtyFlagType[DirtyFlagType["RotateVelocity"] = 512] = "RotateVelocity";
  DirtyFlagType[DirtyFlagType["Scale"] = 1024] = "Scale";
  DirtyFlagType[DirtyFlagType["Everything"] = 4294967295] = "Everything";
})(DirtyFlagType || (DirtyFlagType = {}));

var ParticleRendererBlendMode;
/**
 * Particle Renderer Component.
 */

(function (ParticleRendererBlendMode) {
  ParticleRendererBlendMode[ParticleRendererBlendMode["Transparent"] = 0] = "Transparent";
  ParticleRendererBlendMode[ParticleRendererBlendMode["Additive"] = 1] = "Additive";
})(ParticleRendererBlendMode || (ParticleRendererBlendMode = {}));

var ParticleRenderer = /*#__PURE__*/function (_MeshRenderer) {
  _inheritsLoose(ParticleRenderer, _MeshRenderer);

  /** The max number of indices that Uint16Array can support. */
  ParticleRenderer._getRandom = function _getRandom() {
    return Math.random() - 0.5;
  };

  function ParticleRenderer(props) {
    var _this;

    _this = _MeshRenderer.call(this, props) || this;
    _this._vertexStride = void 0;
    _this._vertices = void 0;
    _this._vertexBuffer = void 0;
    _this._maxCount = 1000;
    _this._position = new Vector3();
    _this._positionRandomness = new Vector3();
    _this._positionArray = void 0;
    _this._velocity = new Vector3();
    _this._velocityRandomness = new Vector3();
    _this._acceleration = new Vector3();
    _this._accelerationRandomness = new Vector3();
    _this._color = new Color(1, 1, 1, 1);
    _this._colorRandomness = 0;
    _this._size = 1;
    _this._sizeRandomness = 0;
    _this._alpha = 1;
    _this._alphaRandomness = 0;
    _this._startAngle = 0;
    _this._startAngleRandomness = 0;
    _this._rotateVelocity = 0;
    _this._rotateVelocityRandomness = 0;
    _this._lifetime = 5;
    _this._startTimeRandomness = 0;
    _this._scale = 1;
    _this._isOnce = false;
    _this._onceTime = 0;
    _this._time = 0;
    _this._isInit = false;
    _this._isStart = false;
    _this._updateDirtyFlag = DirtyFlagType.Everything;
    _this._isRotateToVelocity = false;
    _this._isUseOriginColor = false;
    _this._isScaleByLifetime = false;
    _this._is2d = true;
    _this._isFadeIn = false;
    _this._isFadeOut = false;
    _this._playOnEnable = true;
    _this._blendMode = ParticleRendererBlendMode.Transparent;
    _this.spriteSheet = void 0;

    _this.setMaterial(_this._createMaterial());

    return _this;
  }
  /**
   * @override
   * @internal
   */


  var _proto = ParticleRenderer.prototype;

  _proto.update = function update(deltaTime) {
    if (!this._isInit || !this._isStart) {
      return;
    } // Stop after play once


    if (this._isOnce && this._time > this._onceTime) {
      return this.stop();
    }

    if (this._updateDirtyFlag) {
      this._updateBuffer();

      this._updateDirtyFlag = 0;
    }

    this._time += deltaTime / 1000;
    this.shaderData.setFloat("u_time", this._time);
  }
  /**
   * @override
   * @internal
   */
  ;

  _proto._onEnable = function _onEnable() {
    _MeshRenderer.prototype._onEnable.call(this);

    if (this._playOnEnable) {
      this.start();
    }
  }
  /**
   * Start emitting.
   */
  ;

  _proto.start = function start() {
    this._isStart = true;
    this._time = 0;
  }
  /**
   * Stop emitting.
   */
  ;

  _proto.stop = function stop() {
    this._isStart = false;
  };

  _proto._createMaterial = function _createMaterial() {
    var material = new Material(this.engine, Shader.find("particle-shader"));
    var renderState = material.renderState;
    var target = renderState.blendState.targetBlendState;
    target.enabled = true;
    target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
    target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
    target.sourceAlphaBlendFactor = BlendFactor.One;
    target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
    renderState.depthState.writeEnabled = false;
    material.renderQueueType = RenderQueueType.Transparent;
    this.isUseOriginColor = true;
    this.is2d = true;
    this.isFadeOut = true;
    return material;
  };

  _proto._createMesh = function _createMesh() {
    var mesh = new BufferMesh(this._entity.engine, "particleMesh");
    var vertexStride = 96;
    var vertexCount = this._maxCount * 4;
    var vertexFloatCount = vertexCount * vertexStride;
    var vertices = new Float32Array(vertexFloatCount);
    var indices = null;
    var useUint32 = false;

    if (vertexCount > ParticleRenderer._uint16VertexLimit) {
      if (this.engine._hardwareRenderer.canIUse(GLCapabilityType.elementIndexUint)) {
        useUint32 = true;
        indices = new Uint32Array(6 * this._maxCount);
      } else {
        throw Error("The vertex count is over limit.");
      }
    } else {
      indices = new Uint16Array(6 * this._maxCount);
    }

    for (var i = 0, idx = 0; i < this._maxCount; ++i) {
      var startIndex = i * 4;
      indices[idx++] = startIndex;
      indices[idx++] = startIndex + 1;
      indices[idx++] = startIndex + 2;
      indices[idx++] = startIndex;
      indices[idx++] = startIndex + 2;
      indices[idx++] = startIndex + 3;
    }

    var vertexElements = [new VertexElement("a_position", 0, VertexElementFormat.Vector3, 0), new VertexElement("a_velocity", 12, VertexElementFormat.Vector3, 0), new VertexElement("a_acceleration", 24, VertexElementFormat.Vector3, 0), new VertexElement("a_color", 36, VertexElementFormat.Vector4, 0), new VertexElement("a_lifeAndSize", 52, VertexElementFormat.Vector4, 0), new VertexElement("a_rotation", 68, VertexElementFormat.Vector2, 0), new VertexElement("a_uv", 76, VertexElementFormat.Vector3, 0), new VertexElement("a_normalizedUv", 88, VertexElementFormat.Vector2, 0)];
    var vertexBuffer = new Buffer(this.engine, BufferBindFlag.VertexBuffer, vertexFloatCount * 4, BufferUsage.Dynamic);
    var indexBuffer = new Buffer(this.engine, BufferBindFlag.IndexBuffer, indices, BufferUsage.Dynamic);
    mesh.setVertexBufferBinding(vertexBuffer, vertexStride);
    mesh.setIndexBufferBinding(indexBuffer, useUint32 ? IndexFormat.UInt32 : IndexFormat.UInt16);
    mesh.setVertexElements(vertexElements);
    mesh.addSubMesh(0, indices.length);
    this._vertexBuffer = vertexBuffer;
    this._vertexStride = vertexStride / 4;
    this._vertices = vertices;
    return mesh;
  };

  _proto._updateBuffer = function _updateBuffer() {
    for (var x = 0; x < this._maxCount; x++) {
      this._updateSingleBuffer(x);
    }

    this._vertexBuffer.setData(this._vertices);
  };

  _proto._updateSingleBuffer = function _updateSingleBuffer(i) {
    var _updateDirtyFlag = this._updateDirtyFlag,
        vertices = this._vertices,
        vertexStride = this._vertexStride;
    var getRandom = ParticleRenderer._getRandom;
    var offset = i * 4;
    var k0 = offset * vertexStride;
    var k1 = (offset + 1) * vertexStride;
    var k2 = (offset + 2) * vertexStride;
    var k3 = (offset + 3) * vertexStride;

    if (_updateDirtyFlag & DirtyFlagType.Position) {
      var _this$_position = this._position,
          x = _this$_position.x,
          y = _this$_position.y,
          z = _this$_position.z;
      var _positionArray = this._positionArray,
          _positionRandomness = this._positionRandomness;

      if (_positionArray) {
        if (_positionArray.length !== this._maxCount) {
          throw Error("The length of positionArray must be equal to maxCount.");
        }

        var pos = _positionArray[i];
        x += pos.x;
        y += pos.y;
        z += pos.z;
      } else {
        x += getRandom() * _positionRandomness.x;
        y += getRandom() * _positionRandomness.y;
        z += getRandom() * _positionRandomness.z;
      }

      vertices[k0] = vertices[k1] = vertices[k2] = vertices[k3] = x;
      vertices[k0 + 1] = vertices[k1 + 1] = vertices[k2 + 1] = vertices[k3 + 1] = y;
      vertices[k0 + 2] = vertices[k1 + 2] = vertices[k2 + 2] = vertices[k3 + 2] = z;
    }

    if (_updateDirtyFlag & DirtyFlagType.Velocity) {
      var _velocity = this._velocity,
          _velocityRandomness = this._velocityRandomness;
      vertices[k0 + 3] = vertices[k1 + 3] = vertices[k2 + 3] = vertices[k3 + 3] = _velocity.x + getRandom() * _velocityRandomness.x;
      vertices[k0 + 4] = vertices[k1 + 4] = vertices[k2 + 4] = vertices[k3 + 4] = _velocity.y + getRandom() * _velocityRandomness.y;
      vertices[k0 + 5] = vertices[k1 + 5] = vertices[k2 + 5] = vertices[k3 + 5] = _velocity.z + getRandom() * _velocityRandomness.z;
    }

    if (_updateDirtyFlag & DirtyFlagType.Acceleration) {
      var _acceleration = this._acceleration,
          _accelerationRandomness = this._accelerationRandomness;
      vertices[k0 + 6] = vertices[k1 + 6] = vertices[k2 + 6] = vertices[k3 + 6] = _acceleration.x + getRandom() * _accelerationRandomness.x;
      vertices[k0 + 7] = vertices[k1 + 7] = vertices[k2 + 7] = vertices[k3 + 7] = _acceleration.y + getRandom() * _accelerationRandomness.y;
      vertices[k0 + 8] = vertices[k1 + 8] = vertices[k2 + 8] = vertices[k3 + 8] = _acceleration.z + getRandom() * _accelerationRandomness.z;
    }

    if (_updateDirtyFlag & DirtyFlagType.Color) {
      var _color = this._color,
          _colorRandomness = this._colorRandomness;
      vertices[k0 + 9] = vertices[k1 + 9] = vertices[k2 + 9] = vertices[k3 + 9] = MathUtil.clamp(_color.r + getRandom() * _colorRandomness, 0, 1);
      vertices[k0 + 10] = vertices[k1 + 10] = vertices[k2 + 10] = vertices[k3 + 10] = MathUtil.clamp(_color.g + getRandom() * _colorRandomness, 0, 1);
      vertices[k0 + 11] = vertices[k1 + 11] = vertices[k2 + 11] = vertices[k3 + 11] = MathUtil.clamp(_color.b + getRandom() * _colorRandomness, 0, 1);
    }

    if (_updateDirtyFlag & DirtyFlagType.Alpha) {
      vertices[k0 + 12] = vertices[k1 + 12] = vertices[k2 + 12] = vertices[k3 + 12] = MathUtil.clamp(this._alpha + getRandom() * this._alphaRandomness, 0, 1);
    }

    if (_updateDirtyFlag & DirtyFlagType.StartTime) {
      vertices[k0 + 13] = vertices[k1 + 13] = vertices[k2 + 13] = vertices[k3 + 13] = Math.random() * this._startTimeRandomness;
    }

    if (_updateDirtyFlag & DirtyFlagType.LifeTime) {
      var _lifetime = this._lifetime;
      vertices[k0 + 14] = vertices[k1 + 14] = vertices[k2 + 14] = vertices[k3 + 14] = _lifetime + getRandom() * _lifetime;
    } // Update the duration of play once when startTime or lifetime changes.


    if (_updateDirtyFlag & DirtyFlagType.StartTime || _updateDirtyFlag & DirtyFlagType.LifeTime) {
      this._onceTime = Math.max(this._onceTime, vertices[k0 + 13] + vertices[k0 + 14]);
    }

    if (_updateDirtyFlag & DirtyFlagType.Size) {
      var _size = this._size;
      vertices[k0 + 15] = vertices[k1 + 15] = vertices[k2 + 15] = vertices[k3 + 15] = Math.max(_size + getRandom() * this._sizeRandomness * _size * 2, 0);
    }

    if (_updateDirtyFlag & DirtyFlagType.Scale) {
      vertices[k0 + 16] = vertices[k1 + 16] = vertices[k2 + 16] = vertices[k3 + 16] = this._scale;
    }

    if (_updateDirtyFlag & DirtyFlagType.StartAngle) {
      vertices[k0 + 17] = vertices[k1 + 17] = vertices[k2 + 17] = vertices[k3 + 17] = this._startAngle + getRandom() * Math.PI * this._startAngleRandomness * 2;
    }

    if (_updateDirtyFlag & DirtyFlagType.RotateVelocity) {
      vertices[k0 + 18] = vertices[k1 + 18] = vertices[k2 + 18] = vertices[k3 + 18] = this._rotateVelocity + getRandom() * this._rotateVelocityRandomness;
    }

    this._updateSingleUv(i, k0, k1, k2, k3);
  };

  _proto._updateSingleUv = function _updateSingleUv(i, k0, k1, k2, k3) {
    var spriteSheet = this.spriteSheet;
    var texture = this.getMaterial().shaderData.getTexture("u_texture");
    var vertices = this._vertices;

    if (texture) {
      var width = texture.width;
      var height = texture.height;

      if (spriteSheet) {
        var _spriteSheet = spriteSheet[i % spriteSheet.length],
            x = _spriteSheet.x,
            y = _spriteSheet.y,
            w = _spriteSheet.w,
            h = _spriteSheet.h;
        var u = x / width;
        var v = y / height;
        var p = u + w / width;
        var q = v + h / height;
        var ratio = h / w; // left bottom

        vertices[k0 + 19] = u;
        vertices[k0 + 20] = q;
        vertices[k0 + 21] = ratio; // right bottom

        vertices[k1 + 19] = p;
        vertices[k1 + 20] = q;
        vertices[k1 + 21] = ratio; // right top

        vertices[k2 + 19] = p;
        vertices[k2 + 20] = v;
        vertices[k2 + 21] = ratio; // left top

        vertices[k3 + 19] = u;
        vertices[k3 + 20] = v;
        vertices[k3 + 21] = ratio;
      } else {
        var _ratio = height / width; // left bottom


        vertices[k0 + 19] = 0;
        vertices[k0 + 20] = 1;
        vertices[k0 + 21] = _ratio; // right bottom

        vertices[k1 + 19] = 1;
        vertices[k1 + 20] = 1;
        vertices[k1 + 21] = _ratio; // right top

        vertices[k2 + 19] = 1;
        vertices[k2 + 20] = 0;
        vertices[k2 + 21] = _ratio; // left top

        vertices[k3 + 19] = 0;
        vertices[k3 + 20] = 0;
        vertices[k3 + 21] = _ratio;
      }
    } else {
      // left bottom
      vertices[k0 + 19] = 0;
      vertices[k0 + 20] = 0;
      vertices[k0 + 21] = 1; // right bottom

      vertices[k1 + 19] = 1;
      vertices[k1 + 20] = 0;
      vertices[k1 + 21] = 1; // right top

      vertices[k2 + 19] = 1;
      vertices[k2 + 20] = 1;
      vertices[k2 + 21] = 1; // left top

      vertices[k3 + 19] = 0;
      vertices[k3 + 20] = 1;
      vertices[k3 + 21] = 1;
    }

    vertices[k0 + 22] = -0.5;
    vertices[k0 + 23] = -0.5;
    vertices[k1 + 22] = 0.5;
    vertices[k1 + 23] = -0.5;
    vertices[k2 + 22] = 0.5;
    vertices[k2 + 23] = 0.5;
    vertices[k3 + 22] = -0.5;
    vertices[k3 + 23] = 0.5;
  };

  _createClass(ParticleRenderer, [{
    key: "texture",
    get:
    /**
     * Texture of particle.
     */
    function get() {
      return this.getMaterial().shaderData.getTexture("u_texture");
    },
    set: function set(texture) {
      if (texture) {
        this.shaderData.enableMacro("particleTexture");
        this.getMaterial().shaderData.setTexture("u_texture", texture);
      } else {
        this.shaderData.disableMacro("particleTexture");
      }
    }
    /**
     * Position of particles.
     */

  }, {
    key: "position",
    get: function get() {
      return this._position;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Position;
      this._position = value;
    }
    /**
     * Random range of positions.
     */

  }, {
    key: "positionRandomness",
    get: function get() {
      return this._positionRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Position;
      this._positionRandomness = value;
    }
    /**
     * Array of fixed positions.
     */

  }, {
    key: "positionArray",
    get: function get() {
      return this._positionArray;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Position;
      this._positionArray = value;
    }
    /**
     * Velocity of particles.
     */

  }, {
    key: "velocity",
    get: function get() {
      return this._velocity;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Velocity;
      this._velocity = value;
    }
    /**
     * Random range of velocity.
     */

  }, {
    key: "velocityRandomness",
    get: function get() {
      return this._velocityRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Velocity;
      this._velocityRandomness = value;
    }
    /**
     * Acceleration of particles.
     */

  }, {
    key: "acceleration",
    get: function get() {
      return this._acceleration;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Acceleration;
      this._acceleration = value;
    }
    /**
     * Random range of acceleration.
     */

  }, {
    key: "accelerationRandomness",
    get: function get() {
      return this._accelerationRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Acceleration;
      this._accelerationRandomness = value;
    }
    /**
     * Color of particles.
     */

  }, {
    key: "color",
    get: function get() {
      return this._color;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Color;
      this._color = value;
    }
    /**
     * Random range of color.
     */

  }, {
    key: "colorRandomness",
    get: function get() {
      return this._colorRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Color;
      this._colorRandomness = value;
    }
    /**
     * Size of particles.
     */

  }, {
    key: "size",
    get: function get() {
      return this._size;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Size;
      this._size = value;
    }
    /**
     * Random range of size.
     */

  }, {
    key: "sizeRandomness",
    get: function get() {
      return this._sizeRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Size;
      this._sizeRandomness = value;
    }
    /**
     * Alpha of particles.
     */

  }, {
    key: "alpha",
    get: function get() {
      return this._alpha;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Alpha;
      this._alpha = value;
    }
    /**
     * Random range of alpha.
     */

  }, {
    key: "alphaRandomness",
    get: function get() {
      return this._alphaRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Alpha;
      this._alphaRandomness = value;
    }
    /**
     * Angle of particles.
     */

  }, {
    key: "angle",
    get: function get() {
      return this._startAngle;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.StartAngle;
      this._startAngle = value;
    }
    /**
     * Random range of angle.
     */

  }, {
    key: "angleRandomness",
    get: function get() {
      return this._startAngleRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.StartAngle;
      this._startAngleRandomness = value;
    }
    /**
     * Rotate velocity of particles.
     */

  }, {
    key: "rotateVelocity",
    get: function get() {
      return this._rotateVelocity;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.RotateVelocity;
      this._rotateVelocity = value;
    }
    /**
     * Random range of rotate velocity.
     */

  }, {
    key: "rotateVelocityRandomness",
    get: function get() {
      return this._rotateVelocityRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.RotateVelocity;
      this._rotateVelocityRandomness = value;
    }
    /**
     * Lifetime of particles.
     */

  }, {
    key: "lifetime",
    get: function get() {
      return this._lifetime;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.LifeTime;
      this._lifetime = value;
      this._onceTime = 0;
    }
    /**
     * Random range of start time.
     */

  }, {
    key: "startTimeRandomness",
    get: function get() {
      return this._startTimeRandomness;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.StartTime;
      this._startTimeRandomness = value;
      this._onceTime = 0;
    }
    /**
     * Scale factor of particles.
     */

  }, {
    key: "scale",
    get: function get() {
      return this._scale;
    },
    set: function set(value) {
      this._updateDirtyFlag |= DirtyFlagType.Scale;
      this._scale = value;
    }
    /**
     * Max count of particles.
     */

  }, {
    key: "maxCount",
    get: function get() {
      return this._maxCount;
    },
    set: function set(value) {
      this._isStart = false;
      this._isInit = false;
      this._maxCount = value;
      this._updateDirtyFlag = DirtyFlagType.Everything;
      this.mesh = this._createMesh();

      this._updateBuffer();

      this._isInit = true;
      this.shaderData.setFloat("u_time", 0);
    }
    /**
     * Whether play once.
     */

  }, {
    key: "isOnce",
    get: function get() {
      return this._isOnce;
    },
    set: function set(value) {
      this._time = 0;
      this.shaderData.setInt("u_once", value ? 1 : 0);
      this._isOnce = value;
    }
    /**
     * Whether follow the direction of velocity.
     */

  }, {
    key: "isRotateToVelocity",
    get: function get() {
      return this._isRotateToVelocity;
    },
    set: function set(value) {
      if (value) {
        this.shaderData.enableMacro("rotateToVelocity");
      } else {
        this.shaderData.disableMacro("rotateToVelocity");
      }

      this._isRotateToVelocity = value;
    }
    /**
     * Whether use origin color.
     */

  }, {
    key: "isUseOriginColor",
    get: function get() {
      return this._isUseOriginColor;
    },
    set: function set(value) {
      if (value) {
        this.shaderData.enableMacro("useOriginColor");
      } else {
        this.shaderData.disableMacro("useOriginColor");
      }

      this._isUseOriginColor = value;
    }
    /**
     * Whether scale by lifetime.
     */

  }, {
    key: "isScaleByLifetime",
    get: function get() {
      return this._isScaleByLifetime;
    },
    set: function set(value) {
      if (value) {
        this.shaderData.enableMacro("isScaleByLifetime");
      } else {
        this.shaderData.disableMacro("isScaleByLifetime");
      }

      this._isScaleByLifetime = value;
    }
    /**
     * Whether 2D rendering.
     */

  }, {
    key: "is2d",
    get: function get() {
      return this._is2d;
    },
    set: function set(value) {
      if (value) {
        this.shaderData.enableMacro("is2d");
      } else {
        this.shaderData.disableMacro("is2d");
        this.getMaterial().renderState.rasterState.cullMode = CullMode.Off;
      }

      this._is2d = value;
    }
    /**
     * Whether fade in.
     */

  }, {
    key: "isFadeIn",
    get: function get() {
      return this._isFadeIn;
    },
    set: function set(value) {
      if (value) {
        this.shaderData.enableMacro("fadeIn");
      } else {
        this.shaderData.disableMacro("fadeIn");
      }

      this._isFadeIn = value;
    }
    /**
     * Whether fade out.
     */

  }, {
    key: "isFadeOut",
    get: function get() {
      return this._isFadeOut;
    },
    set: function set(value) {
      if (value) {
        this.shaderData.enableMacro("fadeOut");
      } else {
        this.shaderData.disableMacro("fadeOut");
      }

      this._isFadeOut = value;
    }
    /**
     * Whether play on enable.
     */

  }, {
    key: "playOnEnable",
    get: function get() {
      return this._playOnEnable;
    },
    set: function set(value) {
      this._playOnEnable = value;

      if (value) {
        this.start();
      } else {
        this.stop();
      }
    }
    /**
     * Blend mode of the particle renderer's material.
     */

  }, {
    key: "blendMode",
    get: function get() {
      return this._blendMode;
    },
    set: function set(value) {
      var blendState = this.getMaterial().renderState.blendState;
      var target = blendState.targetBlendState;

      if (value === ParticleRendererBlendMode.Transparent) {
        target.enabled = true;
        target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
        target.sourceAlphaBlendFactor = BlendFactor.One;
        target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
      } else if (value === ParticleRendererBlendMode.Additive) {
        target.enabled = true;
        target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = BlendFactor.One;
        target.sourceAlphaBlendFactor = BlendFactor.One;
        target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
      }

      this._blendMode = value;
    }
  }]);

  return ParticleRenderer;
}(MeshRenderer);
ParticleRenderer._uint16VertexLimit = 65535;

var FRAG_SHADER = "#define GLSLIFY 1\nvarying vec2 v_uv;uniform sampler2D u_texture;void main(void){gl_FragColor=texture2D(u_texture,v_uv);}"; // eslint-disable-line

var VERT_SHADER = "#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;uniform mat4 u_projMat;uniform mat4 u_viewMat;void main(){gl_Position=u_projMat*u_viewMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}"; // eslint-disable-line

Shader.create("trail", VERT_SHADER, FRAG_SHADER);
var TrailMaterial = /*#__PURE__*/function (_Material) {
  _inheritsLoose(TrailMaterial, _Material);

  function TrailMaterial(engine) {
    var _this;

    _this = _Material.call(this, engine, Shader.find("trail")) || this;
    var target = _this.renderState.blendState.targetBlendState;
    target.enabled = true;
    target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.SourceAlpha;
    target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.One;
    _this.renderState.depthState.writeEnabled = false;
    return _this;
  }

  return TrailMaterial;
}(Material);

var _tempVector3 = new Vector3();
/**
 * @deprecated
 */


var TrailRenderer = /*#__PURE__*/function (_MeshRenderer) {
  _inheritsLoose(TrailRenderer, _MeshRenderer);

  /**
   * @deprecated
   */
  function TrailRenderer(entity, props) {
    var _this;

    _this = _MeshRenderer.call(this, entity) || this;
    _this._vertexStride = void 0;
    _this._vertices = void 0;
    _this._vertexBuffer = void 0;
    _this._stroke = void 0;
    _this._minSeg = void 0;
    _this._lifetime = void 0;
    _this._maxPointNum = void 0;
    _this._points = void 0;
    _this._pointStates = void 0;
    _this._strapPoints = void 0;
    _this._curPointNum = void 0;
    _this._prePointsNum = void 0;
    _this._stroke = props.stroke || 0.2;
    _this._minSeg = props.minSeg || 0.02;
    _this._lifetime = props.lifetime || 1000;
    _this._maxPointNum = _this._lifetime / 1000.0 * entity.engine.targetFrameRate;
    _this._points = [];
    _this._pointStates = [];
    _this._strapPoints = [];

    for (var i = 0; i < _this._maxPointNum; i++) {
      _this._points.push(new Vector3());

      _this._pointStates.push(_this._lifetime);

      _this._strapPoints.push(new Vector3());

      _this._strapPoints.push(new Vector3());
    }

    _this._curPointNum = 0;
    var mtl = props.material || new TrailMaterial(_this.engine);

    _this.setMaterial(mtl);

    _this.setTexture(props.texture);

    _this._initGeometry();

    return _this;
  }
  /**
   * @internal
   */


  var _proto = TrailRenderer.prototype;

  _proto.update = function update(deltaTime) {
    var mov = 0,
        newIdx = 0;

    for (var i = 0; i < this._curPointNum; i++) {
      this._pointStates[i] -= deltaTime;

      if (this._pointStates[i] < 0) {
        mov++;
      } else if (mov > 0) {
        newIdx = i - mov; // Move data

        this._pointStates[newIdx] = this._pointStates[i]; // Move point

        this._points[i].cloneTo(this._points[newIdx]);
      }
    }

    this._curPointNum -= mov;
    var appendNewPoint = true;

    if (this._curPointNum === this._maxPointNum) {
      appendNewPoint = false;
    } else if (this._curPointNum > 0) {
      var lastPoint = this._points[this._points.length - 1];

      if (Vector3.distance(this.entity.worldPosition, lastPoint) < this._minSeg) {
        appendNewPoint = false;
      }
    }

    if (appendNewPoint) {
      this._pointStates[this._curPointNum] = this._lifetime;
      this.entity.worldPosition.cloneTo(this._points[this._curPointNum]);
      this._curPointNum++;
    }
  }
  /**
   * @internal
   */
  ;

  _proto._render = function _render(camera) {
    this._updateStrapVertices(camera, this._points);

    this._updateStrapCoords();

    this._vertexBuffer.setData(this._vertices);

    _MeshRenderer.prototype._render.call(this, camera);
  }
  /**
   * @deprecated
   * Set trail texture.
   * @param texture
   */
  ;

  _proto.setTexture = function setTexture(texture) {
    if (texture) {
      this.getMaterial().shaderData.setTexture("u_texture", texture);
    }
  };

  _proto._initGeometry = function _initGeometry() {
    var mesh = new BufferMesh(this._entity.engine);
    var vertexStride = 20;
    var vertexCount = this._maxPointNum * 2;
    var vertexFloatCount = vertexCount * vertexStride;
    var vertices = new Float32Array(vertexFloatCount);
    var vertexElements = [new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0), new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0)];
    var vertexBuffer = new Buffer(this.engine, vertexFloatCount * 4, BufferUsage.Dynamic);
    mesh.setVertexBufferBinding(vertexBuffer, vertexStride);
    mesh.setVertexElements(vertexElements);
    mesh.addSubMesh(0, vertexCount, MeshTopology.TriangleStrip);
    this._vertexBuffer = vertexBuffer;
    this._vertexStride = vertexStride;
    this._vertices = vertices;
    this.mesh = mesh;
  };

  _proto._updateStrapVertices = function _updateStrapVertices(camera, points) {
    var m = camera.viewMatrix;
    var e = m.elements;
    var vx = new Vector3(e[0], e[4], e[8]);
    var vy = new Vector3(e[1], e[5], e[9]);
    var vz = new Vector3(e[2], e[6], e[10]);
    var s = this._stroke;
    vy.scale(s);
    var up = new Vector3();
    var down = new Vector3();
    var rotation = new Quaternion();
    Vector3.transformByQuat(vx, rotation, vx);
    Vector3.transformByQuat(vy, rotation, vy);
    var dy = new Vector3();
    var cross = new Vector3();
    var perpVector = new Vector3();
    vx.normalize();
    var vertices = this._vertices; //-- quad pos

    for (var i = 0; i < this._maxPointNum; i++) {
      //-- center pos
      if (i < this._curPointNum) {
        var p = points[i];

        if (i === this._curPointNum - 1 && i !== 0) {
          Vector3.subtract(p, points[i - 1], perpVector);
        } else {
          Vector3.subtract(points[i + 1], p, perpVector);
        }

        this._projectOnPlane(perpVector, vz, perpVector);

        perpVector.normalize(); // Calculate angle between vectors

        var angle = Math.acos(Vector3.dot(vx, perpVector));
        Vector3.cross(vx, perpVector, cross);

        if (Vector3.dot(cross, vz) <= 0) {
          angle = Math.PI * 2 - angle;
        }

        Quaternion.rotationAxisAngle(vz, angle, rotation);
        Vector3.transformByQuat(vy, rotation, dy);
        Vector3.add(p, dy, up);
        Vector3.subtract(p, dy, down);
      }

      var p0 = i * 2 * this._vertexStride / 4;
      var p1 = (i * 2 + 1) * this._vertexStride / 4;
      vertices[p0] = up.x;
      vertices[p0 + 1] = up.y;
      vertices[p0 + 2] = up.z;
      vertices[p1] = down.x;
      vertices[p1 + 1] = down.y;
      vertices[p1 + 2] = down.z;
    }
  };

  _proto._updateStrapCoords = function _updateStrapCoords() {
    if (this._prePointsNum === this._curPointNum) {
      return;
    }

    this._prePointsNum = this._curPointNum;
    var count = this._curPointNum;
    var texDelta = 1.0 / count;
    var vertices = this._vertices;

    for (var i = 0; i < count; i++) {
      var d = 1.0 - i * texDelta;
      var p0 = i * 2 * this._vertexStride / 4;
      var p1 = (i * 2 + 1) * this._vertexStride / 4;
      vertices[p0] = 0;
      vertices[p0 + 1] = d;
      vertices[p1] = 1.0;
      vertices[p1 + 1] = d;
    }
  };

  _proto._projectOnVector = function _projectOnVector(a, p, out) {
    var n_p = p.clone();
    Vector3.normalize(n_p, n_p);
    var cosine = Vector3.dot(a, n_p);
    out.x = n_p.x * cosine;
    out.y = n_p.y * cosine;
    out.z = n_p.z * cosine;
  };

  _proto._projectOnPlane = function _projectOnPlane(a, n, out) {
    this._projectOnVector(a, n, _tempVector3);

    Vector3.subtract(a, _tempVector3, out);
  };

  return TrailRenderer;
}(MeshRenderer);

/**
 * AABBox = {
 *  min: [-1,-1,-1],
 *  max: [1,1,1]
 * };
 *
 * Sphere = {
 *  center: [0,0,0],
 *  radius: 1
 * };
 */

/**
 * Check whether the boxes intersect.
 * @param boxA - The first box to check
 * @param boxB - The second box to check
 * @returns True if the boxes intersect, false otherwise
 */

function intersectBox2Box(boxA, boxB) {
  return boxA.min.x <= boxB.max.x && boxA.max.x >= boxB.min.x && boxA.min.y <= boxB.max.y && boxA.max.y >= boxB.min.y && boxA.min.z <= boxB.max.z && boxA.max.z >= boxB.min.z;
}
/**
 * Check whether the spheres intersect.
 * @param sphereA - The first sphere to check
 * @param sphereB - The second sphere to check
 * @returns True if the spheres intersect, false otherwise
 */

function intersectSphere2Sphere(sphereA, sphereB) {
  var distance = Vector3.distance(sphereA.center, sphereB.center);
  return distance < sphereA.radius + sphereA.radius;
}
/**
 * Check whether the sphere and the box intersect.
 * @param sphere - The sphere to check
 * @param box - The box to check
 * @returns True if the sphere and the box intersect, false otherwise
 */

function intersectSphere2Box(sphere, box) {
  var center = sphere.center;
  var closestPoint = new Vector3(Math.max(box.min.x, Math.min(center.x, box.max.x)), Math.max(box.min.y, Math.min(center.y, box.max.y)), Math.max(box.min.z, Math.min(center.z, box.max.z)));
  var distance = Vector3.distance(center, closestPoint);
  return distance < sphere.radius;
}

/**
 * Detect collisions between the Collider on the current entity and other Colliders in the scene.
 */

var CollisionDetection = /*#__PURE__*/function (_Script) {
  _inheritsLoose(CollisionDetection, _Script);

  /**
   * Constructor of the collision detection.
   * @param entity - Entity to which the collision detection belong
   */
  function CollisionDetection(entity) {
    var _this;

    _this = _Script.call(this, entity) || this;
    _this._colliderManager = void 0;
    _this._myCollider = void 0;
    _this._overlappedCollider = void 0;
    _this._sphere = void 0;
    _this._box = new BoundingBox();
    return _this;
  }
  /**
   * The collider that intersects with the collider on the current Entity.
   */


  var _proto = CollisionDetection.prototype;

  /**
   * When every frame is updated, calculate the collision with other collider.
   */
  _proto.onUpdate = function onUpdate(deltaTime) {
    _Script.prototype.onUpdate.call(this, deltaTime);

    var overlappedCollider = null;

    if (this._colliderManager && this._myCollider) {
      var colliders = this._colliderManager.colliders;

      if (this._myCollider instanceof ABoxCollider) {
        this._updateWorldBox(this._myCollider, this._box);

        for (var i = 0, len = colliders.length; i < len; i++) {
          var collider = colliders[i];

          if (collider != this._myCollider && this._boxCollision(collider)) {
            overlappedCollider = collider;
            var scripts = this.entity._scripts;

            for (var _i = 0, _len = scripts.length; _i < _len; _i++) {
              scripts.get(_i).onTriggerStay(collider);
            }
          }
        } // end of for

      } else if (this._myCollider instanceof ASphereCollider) {
        this._sphere = this._getWorldSphere(this._myCollider);

        for (var _i2 = 0, _len2 = colliders.length; _i2 < _len2; _i2++) {
          var _collider = colliders[_i2];

          if (_collider != this._myCollider && this._sphereCollision(_collider)) {
            overlappedCollider = _collider;
            var _scripts = this.entity._scripts;

            for (var _i3 = 0, _len3 = _scripts.length; _i3 < _len3; _i3++) {
              _scripts.get(_i3).onTriggerStay(_collider);
            }
          }
        } // end of for

      }
    } // end of if
    //-- overlap events


    if (overlappedCollider != null && this._overlappedCollider != overlappedCollider) {
      var _scripts2 = this.entity._scripts;

      for (var _i4 = 0, _len4 = _scripts2.length; _i4 < _len4; _i4++) {
        _scripts2.get(_i4).onTriggerEnter(overlappedCollider);
      }
    }

    if (this._overlappedCollider != null && this._overlappedCollider != overlappedCollider) {
      var _scripts3 = this.entity._scripts;

      for (var _i5 = 0, _len5 = _scripts3.length; _i5 < _len5; _i5++) {
        _scripts3.get(_i5).onTriggerExit(this._overlappedCollider);
      }
    }

    this._overlappedCollider = overlappedCollider;
  }
  /**
   * Calculate the boundingbox in world space from boxCollider.
   * @param boxCollider - The boxCollider to calculate
   * @param out - The calculated boundingBox
   */
  ;

  _proto._updateWorldBox = function _updateWorldBox(boxCollider, out) {
    var mat = boxCollider.entity.transform.worldMatrix;
    var source = CollisionDetection._tempBox1;
    boxCollider.boxMax.cloneTo(source.max);
    boxCollider.boxMin.cloneTo(source.min);
    BoundingBox.transform(source, mat, out);
  }
  /**
   * Get the sphere info of the given sphere collider in world space.
   * @param sphereCollider - The given sphere collider
   */
  ;

  _proto._getWorldSphere = function _getWorldSphere(sphereCollider) {
    var center = new Vector3();
    Vector3.transformCoordinate(sphereCollider.center, sphereCollider.entity.transform.worldMatrix, center);
    return {
      radius: sphereCollider.radius,
      center: center
    };
  }
  /**
   * Collider and another collider do collision detection.
   * @param other - The another collider to collision detection
   */
  ;

  _proto._boxCollision = function _boxCollision(other) {
    if (other instanceof ABoxCollider) {
      var box = CollisionDetection._tempBox2;

      this._updateWorldBox(other, box);

      return intersectBox2Box(box, this._box);
    } else if (other instanceof ASphereCollider) {
      var sphere = this._getWorldSphere(other);

      return intersectSphere2Box(sphere, this._box);
    }

    return false;
  }
  /**
   * Collider and another collider do collision detection.
   * @param other - The another collider to collision detection
   */
  ;

  _proto._sphereCollision = function _sphereCollision(other) {
    if (other instanceof ABoxCollider) {
      var box = CollisionDetection._tempBox2;

      this._updateWorldBox(other, box);

      return intersectSphere2Box(this._sphere, box);
    } else if (other instanceof ASphereCollider) {
      var sphere = this._getWorldSphere(other);

      return intersectSphere2Sphere(sphere, this._sphere);
    }

    return false;
  };

  _proto.onAwake = function onAwake() {
    this._colliderManager = this.scene.findFeature(ColliderFeature);
    this._myCollider = this.entity.getComponent(Collider);
  };

  _createClass(CollisionDetection, [{
    key: "overlappedCollider",
    get: function get() {
      return this._overlappedCollider;
    }
  }]);

  return CollisionDetection;
}(Script);
CollisionDetection._tempBox1 = new BoundingBox();
CollisionDetection._tempBox2 = new BoundingBox();

/**
 * Fog.
 */

var Fog = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Fog, _Component);

  function Fog(entity) {
    var _this;

    _this = _Component.call(this, entity) || this;
    _this._color = new Color(1, 0, 0, 1);
    _this.color = _this._color;
    return _this;
  }
  /**
   * @internal
   * @override
   */


  var _proto = Fog.prototype;

  _proto._onEnable = function _onEnable() {
    this.scene.shaderData.enableMacro("O3_HAS_FOG");
  }
  /**
   * @internal
   * @override
   */
  ;

  _proto._onDisable = function _onDisable() {
    this.scene.shaderData.disableMacro("O3_HAS_FOG");
  };

  _createClass(Fog, [{
    key: "color",
    get:
    /**
     * Fog color.
     */
    function get() {
      return this._color;
    },
    set: function set(value) {
      this._color = value;
      this.scene.shaderData.setColor(Fog._colorProperty, value);
    }
  }]);

  return Fog;
}(Component);
Fog._colorProperty = Shader.getPropertyByName("u_fogColor");

/**
 * Exponential fog.
 */

var EXP2Fog = /*#__PURE__*/function (_Fog) {
  _inheritsLoose(EXP2Fog, _Fog);

  function EXP2Fog(entity) {
    var _this;

    _this = _Fog.call(this, entity) || this;
    _this._density = 0.0025;
    _this.density = _this._density;
    return _this;
  }
  /**
   * @internal
   * @override
   */


  var _proto = EXP2Fog.prototype;

  _proto._onEnable = function _onEnable() {
    this.scene.shaderData.enableMacro("O3_FOG_EXP2");
  }
  /**
   * @internal
   * @override
   */
  ;

  _proto._onDisable = function _onDisable() {
    this.scene.shaderData.disableMacro("O3_FOG_EXP2");
  };

  _createClass(EXP2Fog, [{
    key: "density",
    get:
    /**
     * Density of fog.
     */
    function get() {
      return this._density;
    },
    set: function set(value) {
      this._density = value;
      this.scene.shaderData.setFloat(EXP2Fog._densityProperty, value);
    }
  }]);

  return EXP2Fog;
}(Fog);
EXP2Fog._densityProperty = Shader.getPropertyByName("u_fogDensity");

/**
 * Linear fog, according to the distance of the camera linear difference fog density.
 */

var LinearFog = /*#__PURE__*/function (_Fog) {
  _inheritsLoose(LinearFog, _Fog);

  function LinearFog(entity) {
    var _this;

    _this = _Fog.call(this, entity) || this;
    _this._near = 1;
    _this._far = 1000;
    _this.near = _this._near;
    _this.far = _this._far;
    return _this;
  }

  _createClass(LinearFog, [{
    key: "near",
    get:
    /**
     * Start of fog.
     */
    function get() {
      return this._near;
    },
    set: function set(value) {
      this._near = value;
      this.scene.shaderData.setFloat(LinearFog._nearProperty, value);
    }
    /**
     * End of fog.
     */

  }, {
    key: "far",
    get: function get() {
      return this._far;
    },
    set: function set(value) {
      this._far = value;
      this.scene.shaderData.setFloat(LinearFog._farProperty, value);
    }
  }]);

  return LinearFog;
}(Fog);
LinearFog._nearProperty = Shader.getPropertyByName("u_fogNear");
LinearFog._farProperty = Shader.getPropertyByName("u_fogFar");

/**
 * Environmental probes, providing necessary capabilities such as reflection and refraction.
 * @example
 * ```ts
 * const probe = cameraEntity.addComponent( CubeProbe )
 * probe.onTextureChange = cubeTexture => {
 *   envLight.specularTexture = cubeTexture;
 *   skybox.specularTexture = cubeTexture;
 * }
 * ```
 */

var Probe = /*#__PURE__*/function (_Script) {
  _inheritsLoose(Probe, _Script);

  function Probe() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Script.call.apply(_Script, [this].concat(args)) || this;
    _this.probeLayer = Layer.Everything;
    _this.width = 1024;
    _this.height = 1024;
    _this.antiAliasing = 1;
    _this._isCube = false;
    _this._oriCameraRenderTarget = void 0;
    _this._renderTarget = void 0;
    _this._renderTargetSwap = void 0;
    _this._activeRenderTarget = void 0;
    _this._camera = void 0;
    _this._oriCameraCullingMask = void 0;
    return _this;
  }

  var _proto = Probe.prototype;

  /**
   * Provide hooks for users to exchange Texture.
   * @remarks Prevent issue: Feedback Loops Between Textures and the Framebuffer.
   */
  _proto.onTextureChange = function onTextureChange(renderColorTexture) {}
  /**
   * @override
   */
  ;

  _proto.onBeginRender = function onBeginRender(camera) {
    if (!this.enabled) return;
    this._camera = camera;
    this._oriCameraCullingMask = camera.cullingMask;
    camera.cullingMask = this.probeLayer;

    if (!this._activeRenderTarget || this._activeRenderTarget.width !== this.width || this._activeRenderTarget.height !== this.height || this._activeRenderTarget.antiAliasing !== this.antiAliasing) {
      this._renderTarget = new RenderTarget(this.engine, this.width, this.height, new RenderColorTexture(this.engine, this.width, this.height, undefined, undefined, this._isCube), RenderBufferDepthFormat.Depth, this.antiAliasing);
      this._renderTargetSwap = new RenderTarget(this.engine, this.width, this.height, new RenderColorTexture(this.engine, this.width, this.height, undefined, undefined, this._isCube), RenderBufferDepthFormat.Depth, this.antiAliasing);
      this._activeRenderTarget = this._renderTarget;
    }

    this._oriCameraRenderTarget = camera.renderTarget;
    camera.renderTarget = this._activeRenderTarget;
  }
  /**
   * @override
   */
  ;

  _proto.onEndRender = function onEndRender(camera) {
    if (!this.enabled) return;
    this.onTextureChange && this.onTextureChange(this._texture);
    this._activeRenderTarget = this._activeRenderTarget === this._renderTarget ? this._renderTargetSwap : this._renderTarget;
  };

  _proto._reset = function _reset() {
    if (!this.enabled) return;
    this._camera.renderTarget = this._oriCameraRenderTarget;
    this._camera.cullingMask = this._oriCameraCullingMask;
  };

  _createClass(Probe, [{
    key: "_texture",
    get: function get() {
      var _this$_activeRenderTa;

      return (_this$_activeRenderTa = this._activeRenderTarget) === null || _this$_activeRenderTa === void 0 ? void 0 : _this$_activeRenderTa.getColorTexture();
    }
  }]);

  return Probe;
}(Script);

var cacheTarget = new Vector3();
var cacheUp = new Vector3();
var cacheDir = new Vector3();
/**
 * Cube probe, generate cubeTexture, used for dynamic environment reflection and other effects.
 */

var CubeProbe = /*#__PURE__*/function (_Probe) {
  _inheritsLoose(CubeProbe, _Probe);

  function CubeProbe() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Probe.call.apply(_Probe, [this].concat(args)) || this;
    _this.position = new Vector3(0, 0, 0);
    _this._isCube = true;
    _this.oriViewMatrix = new Matrix();
    _this._oriFieldOfView = void 0;
    return _this;
  }

  var _proto = CubeProbe.prototype;

  /**
   * @override
   */
  _proto.onBeginRender = function onBeginRender(camera) {
    if (!this.enabled) return;

    _Probe.prototype.onBeginRender.call(this, camera);

    this._storeCamera(camera); // Render 6 faces


    for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
      // Change camera parameters
      this._setCamera(faceIndex, camera);

      camera.render(TextureCubeFace.PositiveX + faceIndex);
    }

    this._restoreCamera(camera);

    _Probe.prototype._reset.call(this);
  }
  /**
   * Store original camera parameters.
   */
  ;

  _proto._storeCamera = function _storeCamera(camera) {
    camera.viewMatrix.cloneTo(this.oriViewMatrix);
    this._oriFieldOfView = camera.fieldOfView;
  }
  /**
   * Restore camera parameters.
   */
  ;

  _proto._restoreCamera = function _restoreCamera(camera) {
    this.oriViewMatrix.cloneTo(camera.viewMatrix);
    camera.fieldOfView = this._oriFieldOfView;
  }
  /**
   * Set camera parameters according to the rendering surface.
   */
  ;

  _proto._setCamera = function _setCamera(faceIndex, camera) {
    switch (faceIndex) {
      // positive_x
      case 0:
        cacheUp.setValue(0, -1, 0);
        cacheDir.setValue(1, 0, 0);
        break;
      // negative_x

      case 1:
        cacheUp.setValue(0, -1, 0);
        cacheDir.setValue(-1, 0, 0);
        break;
      // positive_y

      case 2:
        cacheUp.setValue(0, 0, 1);
        cacheDir.setValue(0, 1, 0);
        break;
      // negative_y

      case 3:
        cacheUp.setValue(0, 0, -1);
        cacheDir.setValue(0, -1, 0);
        break;
      // positive_z

      case 4:
        cacheUp.setValue(0, -1, 0);
        cacheDir.setValue(0, 0, 1);
        break;
      // negative_z

      case 5:
        cacheUp.setValue(0, -1, 0);
        cacheDir.setValue(0, 0, -1);
        break;
    }

    Vector3.add(this.position, cacheDir, cacheTarget);
    Matrix.lookAt(this.position, cacheTarget, cacheUp, camera.viewMatrix);
    camera.fieldOfView = 90;
  };

  return CubeProbe;
}(Probe);

/**
 * Shadow manager.
 */

var LightShadow = /*#__PURE__*/function () {
  /**
   * @internal
   */
  LightShadow._updateShaderData = function _updateShaderData(shaderData) {
    var data = LightShadow._combinedData;
    shaderData.setFloatArray(LightShadow._viewMatFromLightProperty, data.viewMatrix);
    shaderData.setFloatArray(LightShadow._projMatFromLightProperty, data.projectionMatrix);
    shaderData.setFloatArray(LightShadow._shadowBiasProperty, data.bias);
    shaderData.setFloatArray(LightShadow._shadowIntensityProperty, data.intensity);
    shaderData.setFloatArray(LightShadow._shadowRadiusProperty, data.radius);
    shaderData.setFloatArray(LightShadow._shadowMapSizeProperty, data.mapSize);
    shaderData.setTextureArray(LightShadow._shadowMapsProperty, data.map);
  }
  /**
   * Clear all shadow maps.
   */
  ;

  LightShadow.clearMap = function clearMap() {
    LightShadow._combinedData.map.length = 0;
  };

  function LightShadow(light, props) {
    if (props === void 0) {
      props = {
        engine: null,
        width: 512,
        height: 512
      };
    }

    this._mapSize = void 0;
    this._renderTarget = void 0;
    this.light = void 0;
    this.bias = 0.005;
    this.intensity = 0.2;
    this.radius = 1;
    this.projectionMatrix = new Matrix();
    this.light = light;
    var _props = props,
        engine = _props.engine,
        width = _props.width,
        height = _props.height;
    this._mapSize = new Vector2(width, height);
    this._renderTarget = new RenderTarget(engine, width, height, new RenderColorTexture(engine, width, height));
  }
  /**
   * The RenderTarget corresponding to the shadow map.
   */


  var _proto = LightShadow.prototype;

  /**
   * Initialize the projection matrix for lighting.
   * @param light - The light to generate shadow
   */
  _proto.initShadowProjectionMatrix = function initShadowProjectionMatrix(light) {
    /**
     * Directional light projection matrix, the default coverage area is left: -5, right: 5, bottom: -5, up: 5, near: 0.5, far: 50.
     */
    if (light instanceof DirectLight) {
      Matrix.ortho(-5, 5, -5, 5, 0.1, 50, this.projectionMatrix);
    }
    /**
     * Point light projection matrix, default configuration: fov: 50, aspect: 1, near: 0.5, far: 50.
     */


    if (light instanceof PointLight) {
      Matrix.perspective(MathUtil.degreeToRadian(50), 1, 0.5, 50, this.projectionMatrix);
    }
    /**
     * Spotlight projection matrix, the default configuration: fov: this.angle * 2 * Math.sqrt(2), aspect: 1, near: 0.1, far: this.distance + 5
     */


    if (light instanceof SpotLight) {
      var fov = Math.min(Math.PI / 2, light.angle * 2 * Math.sqrt(2));
      Matrix.perspective(fov, 1, 0.1, light.distance + 5, this.projectionMatrix);
    }
  };

  _proto.appendData = function appendData(lightIndex) {
    var viewStart = lightIndex * 16;
    var projectionStart = lightIndex * 16;
    var biasStart = lightIndex;
    var intensityStart = lightIndex;
    var radiusStart = lightIndex;
    var mapSizeStart = lightIndex * 2;
    var mapStart = lightIndex;
    var data = LightShadow._combinedData;
    data.viewMatrix.set(this.light.viewMatrix.elements, viewStart);
    data.projectionMatrix.set(this.projectionMatrix.elements, projectionStart);
    data.bias[biasStart] = this.bias;
    data.intensity[intensityStart] = this.intensity;
    data.radius[radiusStart] = this.radius;
    data.mapSize[mapSizeStart] = this.mapSize.x;
    data.mapSize[mapSizeStart + 1] = this.mapSize.y;
    data.map[mapStart] = this.map;
  };

  _createClass(LightShadow, [{
    key: "renderTarget",
    get: function get() {
      return this._renderTarget;
    }
    /**
     * Shadow map's color render texture.
     */

  }, {
    key: "map",
    get: function get() {
      return this._renderTarget.getColorTexture();
    }
    /**
     * Shadow map size.
     */

  }, {
    key: "mapSize",
    get: function get() {
      return this._mapSize;
    }
  }]);

  return LightShadow;
}();
LightShadow._viewMatFromLightProperty = Shader.getPropertyByName("u_viewMatFromLight");
LightShadow._projMatFromLightProperty = Shader.getPropertyByName("u_projMatFromLight");
LightShadow._shadowBiasProperty = Shader.getPropertyByName("u_shadowBias");
LightShadow._shadowIntensityProperty = Shader.getPropertyByName("u_shadowIntensity");
LightShadow._shadowRadiusProperty = Shader.getPropertyByName("u_shadowRadius");
LightShadow._shadowMapSizeProperty = Shader.getPropertyByName("u_shadowMapSize");
LightShadow._shadowMapsProperty = Shader.getPropertyByName("u_shadowMaps");
LightShadow._maxLight = 3;
LightShadow._combinedData = {
  viewMatrix: new Float32Array(16 * LightShadow._maxLight),
  projectionMatrix: new Float32Array(16 * LightShadow._maxLight),
  bias: new Float32Array(LightShadow._maxLight),
  intensity: new Float32Array(LightShadow._maxLight),
  radius: new Float32Array(LightShadow._maxLight),
  mapSize: new Float32Array(2 * LightShadow._maxLight),
  map: []
};

/**
 * Set whether the light to generate shadows.
 */

Object.defineProperty(Light.prototype, "enableShadow", {
  get: function get() {
    return this._enableShadow;
  },
  set: function set(enabled) {
    this._enableShadow = enabled;

    if (this._enableShadow) {
      if (this instanceof AmbientLight) {
        this._enableShadow = false;
        Logger.warn("Has no shadow!");
        return;
      }

      this.shadow = this.shadow || new LightShadow(this, {
        engine: this.engine,
        width: 512,
        height: 512
      });
      this.shadow.initShadowProjectionMatrix(this);
    }
  }
});
/**
 * Set whether the renderer to receive shadows.
 */

Object.defineProperty(Component.prototype, "receiveShadow", {
  get: function get() {
    return this._recieveShadow;
  },
  set: function set(enabled) {
    this._recieveShadow = enabled;
  }
});
/**
 * Set whether the renderer to cast shadows.
 */

Object.defineProperty(Component.prototype, "castShadow", {
  get: function get() {
    return this._castShadow;
  },
  set: function set(enabled) {
    this._castShadow = enabled;
  }
});

/**
 * Shadow Map material.
 */

var ShadowMapMaterial = /*#__PURE__*/function (_Material) {
  _inheritsLoose(ShadowMapMaterial, _Material);

  function ShadowMapMaterial(engine) {
    var _this;

    _this = _Material.call(this, engine, Shader.find("shadow-map")) || this;

    _this.shaderData.enableMacro("O3_GENERATE_SHADOW_MAP");

    return _this;
  }

  return ShadowMapMaterial;
}(Material);

/**
 * RenderPass for rendering shadow map.
 */
var ShadowMapPass = /*#__PURE__*/function (_RenderPass) {
  _inheritsLoose(ShadowMapPass, _RenderPass);

  /**
   * Constructor.
   * @param light  - The light that the shadow belongs to
   */
  function ShadowMapPass(name, priority, renderTarget, replaceMaterial, mask, light) {
    var _this;

    _this = _RenderPass.call(this, name, priority, renderTarget, replaceMaterial, mask) || this;
    _this.light = void 0;
    _this.light = light;
    _this.clearColor = new Color(1, 1, 1, 1);
    return _this;
  }
  /**
   * @override
   */


  var _proto = ShadowMapPass.prototype;

  _proto.preRender = function preRender(camera, queue) {
    // The viewProjection matrix from the light.
    var shaderData = this.replaceMaterial.shaderData;
    shaderData.setMatrix(ShadowMapPass._viewMatFromLightProperty, this.light.viewMatrix);
    shaderData.setMatrix(ShadowMapPass._projMatFromLightProperty, this.light.shadow.projectionMatrix);
  };

  return ShadowMapPass;
}(RenderPass);
ShadowMapPass._viewMatFromLightProperty = Shader.getPropertyByName("u_viewMatFromLight");
ShadowMapPass._projMatFromLightProperty = Shader.getPropertyByName("u_projMatFromLight");

/**
 * Shadow material.
 */

var ShadowMaterial = /*#__PURE__*/function (_Material) {
  _inheritsLoose(ShadowMaterial, _Material);

  function ShadowMaterial(engine) {
    var _this;

    _this = _Material.call(this, engine, Shader.find("shadow")) || this;
    var targetBlendState = _this.renderState.blendState.targetBlendState;
    targetBlendState.enabled = true;
    targetBlendState.sourceColorBlendFactor = targetBlendState.sourceAlphaBlendFactor = BlendFactor.DestinationColor;
    targetBlendState.destinationColorBlendFactor = targetBlendState.destinationAlphaBlendFactor = BlendFactor.Zero;
    _this.renderState.depthState.compareFunction = CompareFunction.LessEqual;
    _this.renderQueueType = RenderQueueType.Transparent;
    return _this;
  }

  return ShadowMaterial;
}(Material);

/**
 * RenderPass for rendering shadow.
 */

var ShadowPass = /*#__PURE__*/function (_RenderPass) {
  _inheritsLoose(ShadowPass, _RenderPass);

  function ShadowPass() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _RenderPass.call.apply(_RenderPass, [this].concat(args)) || this;
    _this.clearFlags = CameraClearFlags.None;
    return _this;
  }
  /**
   * @override
   */


  var _proto = ShadowPass.prototype;

  _proto.preRender = function preRender(camera, queue) {
    this.enabled = false;
    var lightMgr = camera.scene.findFeature(LightFeature);
    var lights = lightMgr.visibleLights;
    var shaderData = this.replaceMaterial.shaderData; // keep render based on default render pass

    var pass = camera._renderPipeline.defaultRenderPass;
    this.renderTarget = pass.renderTarget;
    var shadowMapCount = 0;
    LightShadow.clearMap();

    for (var i = 0, len = lights.length; i < len; i++) {
      var lgt = lights[i];

      if (lgt.enableShadow) {
        lgt.shadow.appendData(shadowMapCount++);
      }
    }

    if (shadowMapCount) {
      this.enabled = true;

      LightShadow._updateShaderData(shaderData);

      shaderData.enableMacro("O3_SHADOW_MAP_COUNT", shadowMapCount.toString());
    } else {
      shaderData.disableMacro("O3_SHADOW_MAP_COUNT");
    }
  };

  return ShadowPass;
}(RenderPass);

/**
 * Shadow plug-in.
 */

var ShadowFeature = /*#__PURE__*/function (_SceneFeature) {
  _inheritsLoose(ShadowFeature, _SceneFeature);

  function ShadowFeature() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _SceneFeature.call.apply(_SceneFeature, [this].concat(args)) || this;
    _this._shadowPass = void 0;
    _this._shadowMapMaterial = void 0;
    return _this;
  }

  var _proto = ShadowFeature.prototype;

  /**
   * @override
   */
  _proto.preRender = function preRender(scene, camera) {
    var lights = scene.findFeature(LightFeature).visibleLights;

    if (lights.length > 0) {
      // Check RenderPass for rendering shadows.
      if (!this._shadowPass) {
        this.addShadowPass(camera);
      } // Check RenderPass for rendering shadow map.


      var renderPipeline = camera._renderPipeline;

      for (var i = 0, len = lights.length; i < len; i++) {
        var lgt = lights[i];

        if (lgt.enableShadow && !lgt.shadowMapPass) {
          lgt.shadowMapPass = this.addShadowMapPass(camera, lgt);
        } else if (!lgt.enableShadow && lgt.shadowMapPass) {
          renderPipeline.removeRenderPass(lgt.shadowMapPass);
          lgt.shadowMapPass = null;
        }
      }

      this.updatePassRenderFlag(renderPipeline._opaqueQueue);
      this.updatePassRenderFlag(renderPipeline._alphaTestQueue);
      this.updatePassRenderFlag(renderPipeline._transparentQueue);
    }
  }
  /**
   * Add RenderPass for rendering shadows.
   * @param camera - The camera for rendering
   */
  ;

  _proto.addShadowPass = function addShadowPass(camera) {
    var shadowMaterial = new ShadowMaterial(camera.engine);
    this._shadowPass = new ShadowPass("ShadowPass", 1, null, shadowMaterial, Layer.Layer30); // SHADOW

    var renderer = camera._renderPipeline;
    renderer.addRenderPass(this._shadowPass);
  }
  /**
   * Add RenderPass for rendering shadow map.
   * @param camera - The camera for rendering
   * @param light - The light that the shadow belongs to
   */
  ;

  _proto.addShadowMapPass = function addShadowMapPass(camera, light) {
    // Share shadow map material.
    this._shadowMapMaterial = this._shadowMapMaterial || new ShadowMapMaterial(camera.engine);
    var shadowMapPass = new ShadowMapPass("ShadowMapPass", -1, light.shadow.renderTarget, this._shadowMapMaterial, Layer.Layer31, // SHADOW_MAP
    light);
    var renderer = camera._renderPipeline;
    renderer.addRenderPass(shadowMapPass);
    return shadowMapPass;
  }
  /**
   * Update the renderPassFlag state of renderers in the scene.
   * @param renderQueue - Render queue
   */
  ;

  _proto.updatePassRenderFlag = function updatePassRenderFlag(renderQueue) {
    var items = renderQueue.items;

    for (var i = 0, len = items.length; i < len; i++) {
      var item = items[i];
      var ability = item.component;
      var receiveShadow = ability.recieveShadow;
      var castShadow = ability.castShadow;

      if (receiveShadow === true) {
        ability.entity.layer |= Layer.Layer30; //SHADOW;
      } else if (receiveShadow === false) {
        ability.entity.layer &= ~Layer.Layer30; //SHADOW;
      }

      if (castShadow === true) {
        ability.entity.layer |= Layer.Layer31; //SHADOW_MAP;
      } else if (castShadow === false) {
        ability.entity.layer &= ~Layer.Layer31; //SHADOW_MAP;
      }
    }
  };

  return ShadowFeature;
}(SceneFeature);

Scene.registerFeature(ShadowFeature);

Scene.registerFeature(LightFeature);
Scene.prototype.hasLight = hasLight;

export { ABoxCollider, Collider as ACollider, ASphereCollider, AmbientLight, AnimationClip, AnimationClipCurveBinding, AnimationCurve, AnimationEvent, AnimationProperty, Animator, AnimatorConditionMode, AnimatorController, AnimatorControllerLayer, AnimatorLayerBlendingMode, AnimatorState, AnimatorStateMachine, AnimatorStateTransition, AssetPromise, AssetPromiseStatus, AssetType, Background, BackgroundMode, BaseMaterial, BasicRenderPipeline, BlendFactor, BlendMode, BlendOperation, BlendShape, BlendShapeFrame, BlinnPhongMaterial, BoxCollider, Buffer, BufferBindFlag, BufferMesh, BufferUsage, BufferUtil, Camera, CameraClearFlags, CloneManager, ColliderFeature, CollisionDetection, ColorWriteMask, CompareFunction, Component, CubeProbe, CullMode, DataType, DiffuseMode, DirectLight, EXP2Fog, Engine, EngineFeature, EngineObject, Entity, Event, EventDispatcher, Fog, GLCapabilityType, HitResult, IndexBufferBinding, IndexFormat, InterpolableKeyframe, InterpolableValueType, InterpolationType, Keyframe, Layer, Light, LinearFog, Loader, Logger, Material, Mesh, MeshRenderer, MeshTopology, ModelMesh, ObjectValues, PBRBaseMaterial, PBRMaterial, PBRSpecularMaterial, ParticleRenderer, ParticleRendererBlendMode, PhysicsManager, PlaneCollider, PointLight, PrimitiveMesh, Probe, RefObject, RenderBufferColorFormat, RenderBufferDepthFormat, RenderColorTexture, RenderDepthTexture, RenderElement, RenderFace, RenderPass, RenderQueue, RenderQueueType, RenderTarget, Renderer, ResourceManager, Scene, SceneFeature, SceneManager, Script, SetDataOptions, Shader, ShaderData, ShaderFactory, Skin, SkinnedMeshRenderer, Sky, SkyBoxMaterial, SphereCollider, SpotLight, Sprite, SpriteAtlas, SpriteElement, SpriteMask, SpriteMaskInteraction, SpriteMaskLayer, SpriteRenderer, StencilOperation, SubMesh, SystemInfo, Texture, Texture2D, TextureCubeFace, TextureCubeMap, TextureFilterMode, TextureFormat, TextureWrapMode, Time, TrailMaterial, TrailRenderer, Transform, UnlitMaterial, UpdateFlag, Util, VertexBufferBinding, VertexElement, VertexElementFormat, WrapMode, assignmentClone, deepClone, dependencies, ignoreClone, request, resourceLoader, shallowClone };
//# sourceMappingURL=module.js.map
