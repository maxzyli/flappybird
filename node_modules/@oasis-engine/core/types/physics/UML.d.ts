import { Ray, Vector3 } from "@oasis-engine/math";
import { Component } from "../Component";
import { Engine } from "../Engine";
import { HitResult } from "../HitResult";
import { Layer } from "../Layer";
/**
 * Basic class of collider shape.
 */
export declare abstract class ColliderShape {
    /** The rotation of this ColliderShape. */
    position: Vector3;
    /** Whether the ColliderShape is a trigger. */
    isTrigger: boolean;
    /** The physic material of this ColliderShape. */
    material: PhysicsMaterial;
}
/**
 * Box-shaped collider shape.
 */
export declare class BoxColliderShape extends ColliderShape {
    /** The size of this BoxColliderShape. */
    size: Vector3;
}
/**
 *  Sphere-shaped collider shape.
 */
export declare class SphereColliderShape extends ColliderShape {
    /** The radius of this SphereColliderShape. */
    radius: number;
}
/**
 * Plane-shaped collider shape.
 */
export declare class PlaneColliderShape extends ColliderShape {
    /** The rotation of this PlaneColliderShape. */
    rotation: Vector3;
}
/**
 *  Capsule-shaped collider shape.
 */
export declare class CapsuleColliderShape extends ColliderShape {
    /** The radius of this CapsuleColliderShape. */
    radius: number;
    /** The height of this CapsuleColliderShape. */
    height: number;
    /** The up axis of this CapsuleColliderShape. */
    upAxis: ColliderShapeUpAxis;
}
/**
 * Basic class of rigid body collider.
 */
export declare abstract class Collider extends Component {
    /** The shape of the Collider. */
    get shapes(): Readonly<ColliderShape[]>;
    /**
     * Add a collider shape.
     * @param shape - The collider shape.
     */
    addShape(shape: ColliderShape): void;
    /**
     * Remove a collider shape.
     * @param shape - The collider shape.
     */
    removeShape(shape: ColliderShape): void;
    /**
     * Clear all shape collection.
     */
    clearShapes(): void;
}
/**
 * A static rigid body collider component that will not move when colliding with a dynamic rigid body collider.
 * @remarks Mostly used for object which always stays at the same place and never moves around.
 */
export declare class StaticCollider extends Collider {
}
/**
 * A dynamic rigid body collider component.
 */
export declare class DynamicCollider extends Collider {
    /** The linear velocity vector of the RigidBody measured in world unit per second. */
    linearVelocity: number;
    /** The angular velocity vector of the RigidBody measured in radians per second. */
    angularVelocity: number;
    /** The linear damping of the RigidBody. */
    linearDamping: number;
    /** The angular damping of the RigidBody. */
    angularDamping: number;
    /** The mass of the RigidBody. */
    mass: number;
    /** Controls whether physics affects the RigidBody. */
    isKinematic: boolean;
    /** apply a force to the DynamicCollider. */
    applyForce(force: Vector3): void;
    /** apply a torque to the DynamicCollider. */
    applyTorque(torque: Vector3): void;
}
export declare class PhysicsManager {
    constructor(engine: Engine);
    /**
     * Casts a ray through the Scene and returns the first hit.
     * @param ray - The ray
     * @returns Returns true if the ray intersects with a Collider, otherwise false.
     */
    raycast(ray: Ray): Boolean;
    /**
     * Casts a ray through the Scene and returns the first hit.
     * @param ray - The ray
     * @param outHitResult - If true is returned, outHitResult will contain more detailed collision information
     * @returns Returns true if the ray intersects with a Collider, otherwise false.
     */
    raycast(ray: Ray, outHitResult: HitResult): Boolean;
    /**
     * Casts a ray through the Scene and returns the first hit.
     * @param ray - The ray
     * @param distance - The max distance the ray should check
     * @returns Returns true if the ray intersects with a Collider, otherwise false.
     */
    raycast(ray: Ray, distance: number): Boolean;
    /**
     * Casts a ray through the Scene and returns the first hit.
     * @param ray - The ray
     * @param distance - The max distance the ray should check
     * @param outHitResult - If true is returned, outHitResult will contain more detailed collision information
     * @returns Returns true if the ray intersects with a Collider, otherwise false.
     */
    raycast(ray: Ray, distance: number, outHitResult: HitResult): Boolean;
    /**
     * Casts a ray through the Scene and returns the first hit.
     * @param ray - The ray
     * @param distance - The max distance the ray should check
     * @param layerMask - Layer mask that is used to selectively ignore Colliders when casting
     * @returns Returns true if the ray intersects with a Collider, otherwise false.
     */
    raycast(ray: Ray, distance: number, layerMask: Layer): Boolean;
    /**
     * Casts a ray through the Scene and returns the first hit.
     * @param ray - The ray
     * @param distance - The max distance the ray should check
     * @param layerMask - Layer mask that is used to selectively ignore Colliders when casting
     * @param outHitResult - If true is returned, outHitResult will contain more detailed collision information
     * @returns Returns true if the ray intersects with a Collider, otherwise false.
     */
    raycast(ray: Ray, distance: number, layerMask: Layer, outHitResult: HitResult): Boolean;
}
/**
 * Describe how to handle with collisions between colliders.
 */
export declare class PhysicsMaterial {
    /** The bounciness of collider surface. */
    bounciness: number;
    /** The friction coefficient used when already moving. */
    dynamicFriction: number;
    /** The friction coefficient used when an object is lying on a surface. */
    staticFriction: number;
    /** The friction bounce mode. */
    bounceCombine: PhysicsMaterialCombineMode;
    /** The friction combine mode. */
    frictionCombine: PhysicsMaterialCombineMode;
}
/**
 * Describes how physics materials of the colliders are combined.
 */
export declare enum PhysicsMaterialCombineMode {
    /** Averages the friction/bounce of the two colliding materials. */
    Average = 0,
    /** Uses the smaller friction/bounce of the two colliding materials. */
    Minimum = 1,
    /** Uses the larger friction/bounce of the two colliding materials. */
    Maximum = 2,
    /** Multiplies the friction/bounce of the two colliding materials. */
    Multiply = 3
}
/**
 * The up axis of the collider shape.
 */
export declare enum ColliderShapeUpAxis {
    /** Up axis is X. */
    X = 0,
    /** Up axis is Y. */
    Y = 1,
    /** Up axis is Z. */
    Z = 2
}
