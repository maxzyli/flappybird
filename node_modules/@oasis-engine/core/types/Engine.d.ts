import { ResourceManager } from "./asset/ResourceManager";
import { EventDispatcher, Time } from "./base";
import { Canvas } from "./Canvas";
import { ComponentsManager } from "./ComponentsManager";
import { EngineFeature } from "./EngineFeature";
import { Entity } from "./Entity";
import { Material } from "./material/Material";
import { IHardwareRenderer } from "./renderingHardwareInterface/IHardwareRenderer";
import { ClassPool } from "./RenderPipeline/ClassPool";
import { RenderContext } from "./RenderPipeline/RenderContext";
import { RenderElement } from "./RenderPipeline/RenderElement";
import { SpriteElement } from "./RenderPipeline/SpriteElement";
import { SpriteMaskElement } from "./RenderPipeline/SpriteMaskElement";
import { Scene } from "./Scene";
import { SceneManager } from "./SceneManager";
import { RenderState } from "./shader/state/RenderState";
import { PhysicsManager } from "./PhysicsManager";
/**
 * Engine.
 */
export declare class Engine extends EventDispatcher {
    /** Physics manager of Engine. */
    readonly physicsManager: PhysicsManager;
    _componentsManager: ComponentsManager;
    _hardwareRenderer: IHardwareRenderer;
    _lastRenderState: RenderState;
    _renderElementPool: ClassPool<RenderElement>;
    _spriteElementPool: ClassPool<SpriteElement>;
    _spriteMaskElementPool: ClassPool<SpriteMaskElement>;
    _spriteDefaultMaterial: Material;
    _spriteMaskDefaultMaterial: Material;
    _renderContext: RenderContext;
    protected _canvas: Canvas;
    private _resourceManager;
    private _sceneManager;
    private _vSyncCount;
    private _targetFrameRate;
    private _time;
    private _isPaused;
    private _requestId;
    private _timeoutId;
    private _vSyncCounter;
    private _targetFrameInterval;
    private _animate;
    /**
     * The canvas to use for rendering.
     */
    get canvas(): Canvas;
    /**
     * Get the resource manager.
     */
    get resourceManager(): ResourceManager;
    /**
     * Get the scene manager.
     */
    get sceneManager(): SceneManager;
    /**
     * Get the Time class.
     */
    get time(): Time;
    /**
     * Whether the engine is paused.
     */
    get isPaused(): boolean;
    /**
     * The number of vertical synchronization means the number of vertical blanking for one frame.
     * @remarks 0 means that the vertical synchronization is turned off.
     */
    get vSyncCount(): number;
    set vSyncCount(value: number);
    /**
     * Set the target frame rate you want to achieve.
     * @remarks
     * It only takes effect when vSyncCount = 0 (ie, vertical synchronization is turned off).
     * The larger the value, the higher the target frame rate, Number.POSITIVE_INFINITY represents the infinite target frame rate.
     */
    get targetFrameRate(): number;
    set targetFrameRate(value: number);
    /**
     * Create engine.
     * @param canvas - The canvas to use for rendering
     * @param hardwareRenderer - Graphics API renderer
     */
    constructor(canvas: Canvas, hardwareRenderer: IHardwareRenderer);
    /**
     * Create an entity.
     * @param name - The name of the entity
     * @returns Entity
     */
    createEntity(name?: string): Entity;
    /**
     * Pause the engine.
     */
    pause(): void;
    /**
     * Resume the engine.
     */
    resume(): void;
    /**
     * Update the engine loop manually. If you call engine.run(), you generally don't need to call this function.
     */
    update(): void;
    /**
     * Execution engine loop.
     */
    run(): void;
    /**
     * Destroy engine.
     */
    destroy(): void;
    _render(scene: Scene): void;
    private _createSpriteMaterial;
    private _createSpriteMaskMaterial;
    findFeature(Feature: any): EngineFeature;
    static registerFeature(Feature: new () => EngineFeature): void;
    features: EngineFeature[];
}
